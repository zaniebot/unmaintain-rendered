<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Do not use mmap by default. - BurntSushi/ripgrep #579</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Do not use mmap by default.</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/pull/579">#579</a>
        opened by <a href="https://github.com/samhocevar">@samhocevar</a>
        on 2017-08-22 14:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samhocevar">@samhocevar</a></div>
            <div class="timeline-body"><p>Reading memory-mapped files is inherently insecure because no safe
mechanism exists to prevent out-of-bounds reads if the file gets
truncated. The POSIX standard says “An implementation may deliver
SIGBUS signals when a reference would cause an error in the mapped
object, such as out-of-space condition.” so it seems safer to disable
mmap by default.</p>
<p>The bug is simply triggered using this command:</p>
<pre><code># dd of=zob count=0 seek=16G; (sleep 0.1; truncate -s1 zob)&amp;; rg -a lol zob
[2]    15028 bus error  rg -a lol zob</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-22 18:38</div>
            <div class="timeline-body"><p>Note that the definition of &quot;safety&quot; you&#x27;re using doesn&#x27;t seem to align with Rust&#x27;s definition of safety. That is, if SIGBUS is guaranteed for out-of-bounds indexing, then there is no memory unsafety here since SIGBUS will terminate the process.</p>
<p>Disabling memory maps by default because you can trigger a SIGBUS with a pathological case doesn&#x27;t seem like a strong enough motivation to me. Is there some other motivation you&#x27;d like to put forward? What are the end user facing ramifications of the unsafety that you speak of?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 11:24</div>
            <div class="timeline-body"><p>My motivation is that <em>another user on the system</em> can make my process crash with an uncaught <code>SIGBUS</code>, and I like my applications to not crash when merely reading files.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 11:30</div>
            <div class="timeline-body"><blockquote>
<p>My motivation is that another user on the system can make my process crash with an uncaught SIGBUS, and I like my applications to not crash when merely reading files.</p>
</blockquote>
<p>OK, then I&#x27;d suggest adding an alias that disables memory maps, for example, <code>alias rg=&quot;rg --no-mmap&quot;</code>. That works today.</p>
<p>Personally, I&#x27;m inclined to think your use case is pretty niche (how often has ripgrep crashed on you because of this?), and I&#x27;m not convinced it&#x27;s worth it to disable faster search by default because of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 11:45</div>
            <div class="timeline-body"><p>You do not seem to agree that this is a security bug. I do not know how I can convince you that it is; if the Rust community has a security team, I suggest asking them for their opinion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hadronized">@hadronized</a> on 2017-08-23 11:48</div>
            <div class="timeline-body"><p>Isn’t there a way to still have mmap enabled and catch the signal upfront? If a <code>SIGBUS</code> is detected, abort everything as there’s no stable answer.</p>
<p>You’d have a return code – and security teams will be happy – and performance will remain exactly the same.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 11:59</div>
            <div class="timeline-body"><blockquote>
<p>You do not seem to agree that this is a security bug. I do not know how I can convince you that it is</p>
</blockquote>
<p>You can convince me by focusing on the end user ramifications here. From what I&#x27;ve seen from you so far, the ramification is that another user on the same system as you can cause your process to abort. Is there some vulnerability that can result from this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 12:02</div>
            <div class="timeline-body"><blockquote>
<p>Isn’t there a way to still have mmap enabled and catch the signal upfront? If a SIGBUS is detected, abort everything as there’s no stable answer.</p>
</blockquote>
<p>Why does the signal need to be caught? If the process receives SIGBUS, doesn&#x27;t the process subsequently terminate?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 12:02</div>
            <div class="timeline-body"><blockquote>
<p>From what I&#x27;ve seen from you so far, the ramification is that another user on the same system as you can cause your process to abort. Is there some vulnerability that can result from this?</p>
</blockquote>
<p>That is the definition of a local denial of service vulnerability.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 12:06</div>
            <div class="timeline-body"><blockquote>
<p>That is the definition of a local denial of service vulnerability.</p>
</blockquote>
<p>Could you please help me understand the actual issue here instead of quoting definitions? I&#x27;m trying to understand your use case, and you aren&#x27;t making it easy.</p>
<p>For example, am I correct in assuming that the only way this can happen is if the other end user has write access to a file you&#x27;re trying to search? If that&#x27;s true, then I don&#x27;t really understand why a DoS of this nature is important to you. Could you elaborate more on when this happens?</p>
<p>Could you also say why passing the <code>--no-mmap</code> flag is insufficient? Would you be happier if the documentation said that ripgrep&#x27;s defaults were optimized for a single user machine?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flure">@flure</a> on 2017-08-23 12:14</div>
            <div class="timeline-body"><p>I think it&#x27;s more logical to have an option <code>--fast-but-may-crash</code> rather than an option <code>--safe-but-slower</code>. Whatever the security issues are.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hadronized">@hadronized</a> on 2017-08-23 12:18</div>
            <div class="timeline-body"><p>Is <code>mmap</code> the right default, anyway? Is it really faster than loading into via copy streaming?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 12:18</div>
            <div class="timeline-body"><blockquote>
<p>Would you be happier if the documentation said that ripgrep&#x27;s defaults were optimized for a single user machine?</p>
</blockquote>
<p>That would not be accurate, because the bug exists on a single user machine, too. Maybe I would be “happier” if the documentation said that ripgrep can abort unexpectedly while reading files unless <code>--no-mmap</code> is specified, but I would be even happier if the default behaviour was to never crash.</p>
<p>Also, here is what GNU grep did in 2010:</p>
<pre><code>    grep: remove --mmap
    mmap is a bad idea for sequentially accessed file because it will cause
    a page fault for every read page.  Just consider it a failed experiment,
    and ignore --mmap while accepting it for backwards compatibility.</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 12:23</div>
            <div class="timeline-body"><blockquote>
<p>For example, am I correct in assuming that the only way this can happen is if the other end user has write access to a file you&#x27;re trying to search? If that&#x27;s true, then I don&#x27;t really understand why a DoS of this nature is important to you. Could you elaborate more on when this happens?</p>
</blockquote>
<p>Your assumption is correct. But it means that even as root, one cannot reliably search through the files of all users with ripgrep.</p>
<p>The problem with security issues is not when they happen, but if they can happen, and in this case they can, so they need to be fixed (or at least documented).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 12:31</div>
            <div class="timeline-body"><blockquote>
<p>I think it&#x27;s more logical to have an option --fast-but-may-crash rather than an option --safe-but-slower. Whatever the security issues are.</p>
</blockquote>
<p>@flure It seems to me that this PR is trying to change the default. The <code>--mmap</code> and <code>--no-mmap</code> flags already exist. By default, ripgrep tries to choose between memory maps and buffered reading, depending on which it thinks will be faster (a heuristic). If we never permit memory maps to be used by default, then we leave easy performance gains on the table by default.</p>
<blockquote>
<p>Is mmap the right default, anyway? Is it really faster than loading into via copy streaming?</p>
</blockquote>
<p>@phaazon No, it&#x27;s not the right default <em>all the time</em>. It&#x27;s the right default <em>some of the time</em>. Please look at the heuristic this PR is removing, and it&#x27;s also discussed in <a href="http://blog.burntsushi.net/ripgrep/#single-file-benchmarks">ripgrep&#x27;s benchmarks</a>.</p>
<blockquote>
<p>That would not be accurate, because the bug exists on a single user machine, too. Maybe I would be “happier” if the documentation said that ripgrep can abort unexpectedly while reading files unless --no-mmap is specified, but I would be even happier if the default behaviour was to never crash.</p>
</blockquote>
<p>I would be OK with adding that verbiage to the docs (<code>rg -h</code>, <code>rg --help</code>, and <code>man rg</code>), so long as it includes <em>why</em> ripgrep would abort, e.g., &quot;ripgrep can abort unexpectedly by default if it searches a file that is simultaneously truncated. This behavior can be disabled by passing the <code>--no-mmap</code> flag.&quot;</p>
<p>I don&#x27;t see how changing the default behavior here is wise. If this were a bug that people were tripping over constantly, then I would be more sympathetic to your concern. But as far as I can tell, this bug is rare enough that leaving performance on the table isn&#x27;t worth it.</p>
<blockquote>
<p>Also, here is what GNU grep did in 2010:</p>
</blockquote>
<p>Right, I&#x27;m aware of GNU grep&#x27;s history here. I purposefully re-litigated their experiment because I didn&#x27;t believe their conclusion, and thus far, the data says their conclusion is wrong now (it may have been right in 2010, I don&#x27;t know).</p>
<blockquote>
<p>Your assumption is correct. But it means that even as root, one cannot reliably search through the files of all users with ripgrep.</p>
</blockquote>
<p>Understood. I&#x27;m personally OK with the trade off because if you want to do that, you can pass the <code>--no-mmap</code> flag.</p>
<blockquote>
<p>The problem with security issues is not when they happen, but if they can happen, and in this case they can, so they need to be fixed (or at least documented).</p>
</blockquote>
<p>I understand that. But not all security issues are created equal, and security doesn&#x27;t trump everything else all the time IMO.</p>
<hr>
<p>To summarize, it seems like a compromise here is to add a warning to the docs, but to leave the current defaults in tact.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 12:47</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t see how changing the default behavior here is wise.</p>
</blockquote>
<p>I know, hence my suggestion to ask a security team. For instance, I do not see any sane Linux distro knowingly shipping ripgrep with this default.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 13:00</div>
            <div class="timeline-body"><blockquote>
<p>I know, hence my suggestion to ask a security team.</p>
</blockquote>
<p>Oh? Is there something else to this issue that I&#x27;m missing? Happy to learn. :-)</p>
<blockquote>
<p>For instance, I do not see any sane Linux distro knowingly shipping ripgrep with this default.</p>
</blockquote>
<p>I&#x27;m fine with only insane Linux distros shipping ripgrep. In fact, I use such a Linux distro!</p>
<p>But if sane Linux distros want a piece of the action, then I&#x27;d be honored, and they can come to me with their concerns, and I&#x27;m confident we can figure something out. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samhocevar">@samhocevar</a> on 2017-08-23 15:12</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;m fine with only insane Linux distros shipping ripgrep.</p>
</blockquote>
<p>Just for the record, I said no such thing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 15:18</div>
            <div class="timeline-body"><p>I think PR has exhausted constructive feedback.</p>
<p>If someone would like to propose a fix, please open a new issue and focus on the user experience. Thanks. In the mean time, when I get a chance, I&#x27;ll improve the documentation to cover the trade offs here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 15:18</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:16 UTC
    </footer>
</body>
</html>
