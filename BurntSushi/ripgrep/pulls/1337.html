<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ignore: rework inter-thread messaging - BurntSushi/ripgrep #1337</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ignore: rework inter-thread messaging</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/pull/1337">#1337</a>
        opened by <a href="https://github.com/zsugabubus">@zsugabubus</a>
        on 2019-08-02 12:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a></div>
            <div class="timeline-body"><p>Change the meaning of <code>Quit</code> message. Now it means terminate. The final
&quot;dance&quot; is unnecessary, because by the time quitting begins, no thread
will ever spawn a new <code>Work</code>.</p>
<p>Replace that heuristic spin-loop, with blocking receive.</p>
<p>Optimize use of atomic operations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-08-02 12:58</div>
            <div class="timeline-body"><p>Thanks. This will take me a while to get to, because I&#x27;ll need to carefully review this to make sure it&#x27;s correct. It is very very easy to introduce subtle bugs into this code, and more importantly, those bugs can be hard to catch.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on 2019-08-02 12:59</div>
            <div class="timeline-body"><p>I tried to explain every subtle details in comments, to make sure it&#x27;s correct what I do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1474 on 2019-08-02 13:17</div>
            <div class="timeline-body"><p>Nice. This is clever. I think I buy it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:17</div>
            <div class="timeline-body"><p>Why the <code>map_err</code> here instead of an <code>unwrap</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2019-08-02 13:19</div>
            <div class="timeline-body"><p>Nice nice. I think I buy this change. Before merging it, I&#x27;m going to try to test this as best I can.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2019-08-02 13:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:27</div>
            <div class="timeline-body"><p>A few lines below I wrote an <code>unreachable!()</code> assertion that also covers <code>try_recv()</code> and this way <code>recv()</code> errors. So you will get a meaningful error message when panicking (although it can never occur (currently)).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:33</div>
            <div class="timeline-body"><p>Although that <code>uncreachable!()</code> statement below is unnecessary, and we could use <code>unwrap</code> everywhere, I just wanted to explicitly distinguish <code>Err(TryRecvError::Empty)</code> from <code>Err(TryRecvError::Disconnected)</code> cases. In the future, maybe <code>Disconnected</code> brach will be the quit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2019-08-02 13:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2019-08-02 13:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:34</div>
            <div class="timeline-body"><p>Right, yeah, I saw that. But then it becomes harder to distinguish between &quot;channel somehow got disconnected from a bug&quot; and &quot;this particular blocking <code>recv</code> failed.&quot; That is, forwarding the error like this strips information from the inevitable backtrace as far as I can tell. I&#x27;d rather see it panic closer to where the error occurred.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:35</div>
            <div class="timeline-body"><p>Yeah I like the idea of distinguishing the error cases. That part is good. :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2019-08-02 13:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on 2019-08-02 13:37</div>
            <div class="timeline-body"><p>I also expect some minimal(?) speedups, because that two expensive atomic operations are gone before <code>return Some(work)</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-08-02 13:41</div>
            <div class="timeline-body"><p>Keep in mind that atomic operations are themselves likely quite inexpensive compared with processing the work itself, so I&#x27;d be surprised to see any performance changes here. Other than perhaps latency being better with quitting, but it&#x27;s hard to reason about that.</p>
<p>My longer term plans for this code is to either find a way to switch to <code>rayon</code>, or be more principled about work stealing and work distribution.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2019-08-02 13:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:48</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;d rather see it panic closer to where the error occurred</p>
</blockquote>
<p>I have no so much experience in Rust. It seems very reasonable.</p>
<p>On the other hand, what if you want to call <code>drop</code> on the channel intentionally and you want it to quit instead of panicking. Then it&#x27;s better to forward the error instead of <code>unwrap</code>. And I think, knowing which <code>(try_)recv</code> panicked is secondary. The most important information is that it hase been disconnected.</p>
<p>But it&#x27;s hard to reason about, which would be the better choice, because it cannot occur now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2019-08-02 13:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1489 on 2019-08-02 13:52</div>
            <div class="timeline-body"><blockquote>
<p>And I think, knowing which (try_)recv panicked is secondary. The most important information is that it hase been disconnected.</p>
</blockquote>
<p>If you use <code>recv().unwrap()</code> instead of <code>recv().map_err(...)</code>, then we get both. Where as with the <code>map_err</code>, you only know that the channel was disconnected.</p>
<blockquote>
<p>But it&#x27;s hard to reason about, which would be the better choice, because it cannot occur now.</p>
</blockquote>
<p>Right, <em>unless</em> there is a bug. So basically, this is about choosing a failure mode that provides the most information and is thus easier to debug, if and when it does occur.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> approved on 2020-02-17 21:56</div>
            <div class="timeline-body"><p>I&#x27;m finally getting around to merging this! It will be coming in as part of #1486.</p>
<p>I reviewed this again, tested it and tried to break it. But it seems solid. All in all, I think it is much much more elegant than what was here before. So, thank you very much!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rollup</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-02-17 21:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-02-17 22:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on 2020-02-17 22:22</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2020-02-17 22:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2020-02-19 22:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-19 22:16</div>
            <div class="timeline-body"><p>@zsugabubus So I unfortunately had to revert this PR. While I wasn&#x27;t able to reproduce any problems locally, I was observing transient CI failures that could only be explained by the parallel directory traversal accidentally dropping work. After staring at this patch for a bit, I think I convinced myself that the problem is a race between when <code>value</code> is populated from the blocking receive here, the call to <code>self.resume()</code> and the call to <code>self.waiting()</code> above.</p>
<p>In particular, I believe there is a possible interleaving where <code>self.waiting() == 1</code> is true but there is actually still more work to be done. Once <code>value = ...;</code> is unblocked, it is possible for another worker to think that it was the last one running before <code>self.resume()</code> is called. This in turn causes the <code>Quit</code> domino effect to kick in, which in turn is guaranteed to cause all other workers to stop even if there is still outstanding work to be done.</p>
<p>I believe I had similar issues in my initial implementation of parallel traversal, and that was what provoked the introduction of the &quot;waiting&quot; and &quot;quitting&quot; dance. AIUI, you probably would need something similar here to fix the race, I think.</p>
<p>Using blocking semantics however is still probably better than the implementation I have now, which inserts sleeps in order to avoid burning the CPU. Nevertheless, I&#x27;m going to stick with the old implementation for now unless you want to take another crack at it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2020-02-20 00:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 00:27</div>
            <div class="timeline-body"><p>But new works can’t only originate from a (running) worker? (Did something change since or I had some fatal assumptions?)</p>
<p>If every other worker is blocked at that <code>recv</code>, they surely won’t add anything… and before the last one goes to sleep (blocking) can safely start killing its brothers (initiate quitting).</p>
<p>The thing you talk about could only occur only if something other than a worker would start pushing new works, no (*)?
This is the only code segment that accesses <code>tx</code> from outside, but it surely finishes before workers start at all (it just puts on root directories):
https://github.com/BurntSushi/ripgrep/blob/72f5a25435f3dad1c69d16010b0aa796f2523f70/ignore/src/walk.rs#L1140-L1144</p>
<p>~*: Or if there is a bug(?) in channels implementation and makes <code>try_recv</code> reporting no work (empty), even though there would we works; and then randomly wakes up a blocking <code>recv</code> instead. (Is it possible?)~ No.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2020-02-20 00:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 00:36</div>
            <div class="timeline-body"><p>On the other hand, I took a short glimpse into the documentation of channels, and if everything is true, we could completely eliminate <code>resume()</code>s and <code>waiting()</code>s by <a href="https://docs.rs/crossbeam-channel/0.4.0/crossbeam_channel/struct.Receiver.html#method.is_empty"><code>is_empty()</code></a>. So instead <code>self.waiting() == 1</code>, <code>self.rx.is_empty()</code> could be written simply.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2020-02-20 00:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 00:54</div>
            <div class="timeline-body"><p>So first I want to say that since reverting it, all transient failures I was observing have completely stopped. (The nature of the transient failures was such that the parallel traverser was returning only a subset of file paths that it should be returning. So it was either skipping some file paths or it was stopping early.) So I think, at least from my perspective, there is clear evidence that there is a problem with this change.</p>
<p>The key to my thinking behind the problem is that there is an <em>unsynchronized</em> race between the <code>self.waiting() == 1</code> check and <code>value = ...;</code> being unblocked and <code>self.resume()</code> being called. Between those statements, there exists a point in time in which there is work remaining in a worker, but where that worker is currently regarded as <code>waiting.</code> All that needs to happen for that to occur is this:</p>
<ol>
<li>Consider that all workers, except for one, are <code>waiting</code>.</li>
<li>The last remaining worker finds one more job to do and sends it on the channel.</li>
<li>One of the previously <code>waiting</code> workers wakes up from the job that the last running worker sent, but <code>self.resume()</code> has not been called yet.</li>
<li>The last worker, from (2), calls <code>get_work</code> and sees that the channel has nothing on it, so it executes <code>self.waiting() == 1</code>. Since the worker in (3) hasn&#x27;t called <code>self.resume()</code> yet, <code>self.waiting() == 1</code> evaluates to true.</li>
<li>This sets off a chain reaction that stops all workers, despite that fact that (3) got more work (which could itself spawn more work).</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2020-02-20 00:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 00:57</div>
            <div class="timeline-body"><p>We definitely cannot use <code>self.rx.is_empty()</code>. The fact that the channel is empty does not imply that the traversal has finished. It could simply be that a worker is running and is <em>about</em> to produce more work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2020-02-20 01:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 01:22</div>
            <div class="timeline-body"><p>Cried and thinking a bit and I thought of something. Really hope not too big bullshit: Increment a counter before <code>tx.send</code>s and decrement it when we have completely finished with the work; basically a counter for “works pending”.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2020-02-20 02:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 02:01</div>
            <div class="timeline-body"><p>Possibly... I&#x27;d have to think more carefully about it and don&#x27;t have the energy at the moment. My initial instinct is that it sounds like it might have the same problem though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 02:38</div>
            <div class="timeline-body"><p>Some thoughts to make it clearer:</p>
<ul>
<li>The last running worker processes the last work. Counter is 1. (1 pending.)</li>
<li>It adds a new work (W), but before it do so, it increments the counter by one (2 pending); so it ensures that <code>try_recv</code> + quit testing won’t initiate a quitting–like before–because even if (W) has been finished–counter will be &gt;=1. And now it doesn’t matter which blocking or non-blocking <code>recv</code> will be woken up and when, because worker won’t exit only if it got an empty response and no pending works.</li>
<li>Here, no pending work really mean that <code>rx.recv</code> will block indefinitely.</li>
<li>The order of increments and decrements doesn’t count until they are well-paired (increment first, then decrement). The only value we care is 0. After reaching zero it never will be &gt;0 (because the well-ordering).</li>
</ul>
<p>If implemented well, it sounds obvious to me in plain English: If there are no pending works, there are nothing to do. We can quit now.</p>
<p>It was a bit hard to explain because my limited English skills and because it’s a tautology.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2020-02-20 02:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2020-02-20 20:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 20:56</div>
            <div class="timeline-body"><p>I think I get it! And then we can remove the <code>waiting</code>/<code>resume</code> stuff entirely. Great. I have it implemented in #1491.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsugabubus">@zsugabubus</a> on <code>ignore/src/walk.rs</code>:1479 on 2020-02-20 21:09</div>
            <div class="timeline-body"><p>I’m glad I could help fix my mistake.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsugabubus">@zsugabubus</a> reviewed on 2020-02-20 21:09</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:17 UTC
    </footer>
</body>
</html>
