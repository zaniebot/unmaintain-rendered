<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for additional text encodings. - BurntSushi/ripgrep #398</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for additional text encodings.</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/BurntSushi/ripgrep/pull/398">#398</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2017-03-09 01:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>Add support for additional text encodings.</p>
<p>This includes, but is not limited to, UTF-16, latin-1, GBK, EUC-JP
and Shift_JIS. (Courtesy of the <code>encoding_rs</code> crate.)</p>
<p>Specifically, this feature enables ripgrep to search files that are
encoded in an encoding other than UTF-8. The list of available encodings
is tied directly to what the <code>encoding_rs</code> crate supports, which is in
turn tied to the Encoding Standard. The full list of available encodings
can be found here: https://encoding.spec.whatwg.org/#concept-encoding-get</p>
<p>This pull request also introduces the notion that text encodings can be
automatically detected on a best effort basis. Currently, the only
support for this is checking for a UTF-16 bom. In all other cases, a
text encoding of <code>auto</code> (the default) implies a UTF-8 or ASCII
compatible source encoding. When a text encoding is otherwise specified,
it is unconditionally used for all files searched.</p>
<p>Since ripgrep&#x27;s regex engine is fundamentally built on top of UTF-8,
this feature works by transcoding the files to be searched from their
source encoding to UTF-8. This transcoding only happens when:</p>
<ol>
<li><code>auto</code> is specified and a non-UTF-8 encoding is detected.</li>
<li>A specific encoding is given by end users (including UTF-8).</li>
</ol>
<p>When transcoding occurs, errors are handled by automatically inserting
the Unicode replacement character.</p>
<p>In all other cases, the source text is searched directly, which implies
an assumption that it is at least ASCII compatible, but where UTF-8 is
most useful. In this scenario, encoding errors are not detected.</p>
<p>This design may not be optimal in all cases, but it has some advantages:</p>
<ol>
<li>In the happy path (&quot;UTF-8 everywhere&quot;) remains happy. I have not been
able to witness any performance regressions.</li>
<li>In the non-UTF-8 path, implementation complexity is kept relatively
low. The cost here is transcoding itself. A potentially superior
implementation might build decoding of any encoding into the regex
engine itself. In particular, the fundamental problem with
transcoding everything first is that literal optimizations are nearly
negated.</li>
</ol>
<p>Future work should entail improving the user experience. For example, we
might want to auto-detect more text encodings. A more elaborate UX
experience might permit end users to specify multiple text encodings,
although this seems hard to pull off in an ergonomic way.</p>
<p>Fixes #1</p>
<hr>
<p><strong>Initial PR message:</strong></p>
<p>This is in-progress work on adding UTF-16 support to ripgrep.</p>
<p>This &quot;works,&quot; but it needs to be cleaned up a bit before it can be merged:</p>
<ul>
<li>[x] Add tests where the input is UTF-16.</li>
<li>[x] Add a flag that permits controlling this behavior. (We could elect to punt on this if the right UX choice isn&#x27;t obvious.)</li>
<li>[x] When reading anything but UTF-8, we need to disable the memory map searcher. It&#x27;s not practical to transcode a memory mapped file in a way that isn&#x27;t isomorphic to just using the normal incremental <code>io::Read</code> interface. (This should be done optimistically by &quot;bailing&quot; out of the memory map strategy if there&#x27;s a BOM rather than pessimistically to avoid additional syscalls in the happy path.)</li>
<li>[x] The API for <code>DecodeReader</code> needs to be tweaked so that its internal buffer can be reused. (Without this, the normal UTF-8 happy path causes ripgrep to be slower than grep!)</li>
</ul>
<p>If you want to try this PR out (which would be most welcome), then because of the memory map issue mentioned above, you&#x27;ll need to pass the <code>--no-mmap</code> flag to ripgrep.</p>
<p>To a first approximation, ripgrep is approximately 5x slower searching UTF-16 when compared to UTF-8. Interestingly, this applies both to searching a single ~1GB subtitle file and searching the Linux repo with all source files converted to UTF-16. At first I thought this seemed bad, but <code>iconv</code> itself isn&#x27;t much faster---certainly within the same order of magnitude it seems.</p>
<p>Another exciting thing I learned is that GNU grep doesn&#x27;t support searching UTF-16 at all. For some reason, I thought it did. So this is an even better feature than I previously thought!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/BurntSushi">@BurntSushi</a> by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-09 01:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-09 01:33</div>
            <div class="timeline-body"><p>cc @roblourens</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-11 16:33</div>
            <div class="timeline-body"><p>OK, I&#x27;ve updated the PR to take care of the internal buffer and memory map issue. I also refactored the transcoder to be more robust.</p>
<p>I&#x27;d like to punt on adding new flags for now, which I think means I just need to work on writing a few more tests and this should be good to go!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Add UTF-16 support.&quot; to &quot;Add support for additional text encodings.&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-12 18:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-12 18:25</div>
            <div class="timeline-body"><p>(Build failures are unrelated. There&#x27;s a bug in nightly Cargo that&#x27;s being fixed.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-12 18:26</div>
            <div class="timeline-body"><p>I&#x27;ve updated the PR with tests. I also ended up adding support for all encodings supported by <code>encoding_rs</code>, which includes UTF-16, GBK, EUC-JP and Shift_JIS, among others. I added a new <code>-E/--encoding</code> flag that permits controlling which text encoding is used. The default value is <code>auto</code>, which basically means &quot;assume UTF-8 unless we see a UTF-16 bom.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-12 23:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-12 23:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2017-03-12 23:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/hsivonen">@hsivonen</a> reviewed on 2017-04-12 09:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/hsivonen">@hsivonen</a> on <code>src/args.rs</code>:747 on 2017-04-12 09:57</div>
            <div class="timeline-body"><p>Considering that the <code>None</code> case results in error rather than continuing with some default value, it would make more sense to use the <code>for_label_no_replacement</code> variant here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>src/args.rs</code>:747 on 2017-04-12 11:42</div>
            <div class="timeline-body"><p>TIL about the replacement encoding: https://encoding.spec.whatwg.org/#replacement</p>
<p>Thanks for the tip! :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2017-04-12 11:42</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:15 UTC
    </footer>
</body>
</html>
