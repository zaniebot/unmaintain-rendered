<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>globset: add constructor for GlobSetBuilder that preallocates space - BurntSushi/ripgrep #1915</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>globset: add constructor for GlobSetBuilder that preallocates space</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/pull/1915">#1915</a>
        opened by <a href="https://github.com/AlexTMjugador">@AlexTMjugador</a>
        on 2021-06-28 11:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexTMjugador">@AlexTMjugador</a></div>
            <div class="timeline-body"><p>This constructor helps avoiding reallocations when the number of globs that will be added is known or can be reasonably well estimated in advance. This speeds up the builder a bit, especially for larger glob sets.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-29 11:29</div>
            <div class="timeline-body"><p>@AlexTMjugador Thanks for the PR!</p>
<p>I&#x27;m having a hard time imagining a case where this is useful/meaningful. Do you have a real world benchmark that you can show me?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexTMjugador">@AlexTMjugador</a> on 2021-06-30 10:52</div>
            <div class="timeline-body"><p>I don&#x27;t know of any real world benchmark that highlights any noticeable performance difference with this change, but I did a quick <code>cargo bench</code> with rustc version <code>1.55.0-nightly (7c3872e6b 2021-06-24)</code>.</p>

Benchmark source code

<pre><code>fn lots_of_globs_no_capacity() {
    let mut builder = GlobSetBuilder::new();

    for i in 0..10000 {
        builder.add(GlobBuilder::new(&amp;format!(&quot;hello*{}&quot;, i)).build().unwrap());
    }

    builder.build().unwrap();
}

fn lots_of_globs_with_capacity() {
    let mut builder = GlobSetBuilder::with_capacity(10000);

    for i in 0..10000 {
        builder.add(GlobBuilder::new(&amp;format!(&quot;hello*{}&quot;, i)).build().unwrap());
    }

    builder.build().unwrap();
}

#[cfg(test)]
mod tests {
    use super::*;
    use test::Bencher;

    #[bench]
    fn no_capacity(b: &amp;mut Bencher) {
        b.iter(|| lots_of_globs_no_capacity());
    }

    #[bench]
    fn with_capacity(b: &amp;mut Bencher) {
        b.iter(|| lots_of_globs_with_capacity());
    }
}
</code></pre>


<p>The results on my Linux 5.10.0 machine with 16 GiB 1333 MHz dual-channel DDR3 RAM and a Intel Core i3-2100 CPU where as follows:</p>
<pre><code>    Finished bench [optimized] target(s) in 2.10s
     Running unittests (target/release/deps/benchmark-b49d7e8bd2ddd614)

running 2 tests
test tests::no_capacity   ... bench:  97,001,928 ns/iter (+/- 547,969)
test tests::with_capacity ... bench:  96,271,824 ns/iter (+/- 302,626)

test result: ok. 0 passed; 0 failed; 0 ignored; 2 measured; 0 filtered out; finished in 58.22s
</code></pre>
<p>So passing a capacity to <code>GlobSetBuilder</code> definitely offers an improvement for this test case, consistently reducing in almost 1 millisecond the time needed to build a set of 10000 globs.</p>
<p>I also ran the benchmarks included in this repository, adding a new <code>new_reglob_many_with_capacity</code> benchmark, modeled after <code>new_reglob_many</code>. In this case the performance is almost identical (note the reduced variance):</p>
<pre><code>    Finished bench [optimized] target(s) in 0.05s
     Running unittests (target/release/deps/bench-6b2d350b3a9a4166)

running 9 tests
...
test many_short_regex_set               ... bench:         306 ns/iter (+/- 22)
test many_short_regex_set_with_capacity ... bench:         307 ns/iter (+/- 3)
...
</code></pre>
<p>Overall, I&#x27;d argue this is not a game-changing improvement, but I can imagine that, if for some reason a networking application needs to match quite a bit of globs against incoming data, any improvement in its response times would be welcome. On the other hand, these changes have a negligible impact in code size and layout and doing less reallocations is definitely better, so I&#x27;d say they can&#x27;t &quot;backfire&quot; as something that slows down already existing use cases, as shown by the maybe more typical benchmarks already included in the repository.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-07-14 10:55</div>
            <div class="timeline-body"><p>When updating the PR, could you please rebase? ripgrep doesn&#x27;t use merge commits anywhere. Thanks.</p>
<p>Glancing at your benchmark... I&#x27;m not sure I agree with your conclusion:</p>
<blockquote>
<p>So passing a capacity to GlobSetBuilder definitely offers an improvement for this test case, consistently reducing in almost 1 millisecond the time needed to build a set of 10000 globs.</p>
</blockquote>
<p>The measured difference is less than 1%. And moreover, the difference is well within the noise.</p>
<p>More generally, it just doesn&#x27;t make sense to me that pre-allocating space like this would have any meaningful impact. Namely, allocating memory is a pittance compared to what a globset builder is actually doing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexTMjugador">@AlexTMjugador</a> on 2021-07-14 11:22</div>
            <div class="timeline-body"><blockquote>
<p>When updating the PR, could you please rebase? ripgrep doesn&#x27;t use merge commits anywhere. Thanks.</p>
</blockquote>
<p>Sorry, I have just updated the branch to the latest master without thinking too much about whether I should rebase or merge. Thanks for the reminder!</p>
<blockquote>
<p>The measured difference is less than 1%. And moreover, the difference is well within the noise.</p>
<p>More generally, it just doesn&#x27;t make sense to me that pre-allocating space like this would have any meaningful impact. Namely, allocating memory is a pittance compared to what a globset builder is actually doing.</p>
</blockquote>
<p>I also think that it probably doesn&#x27;t matter much. I did some tests later with bigger sets and the difference was a bit more noticeable, exceeding the 1% difference threshold, but still pretty minor, and the set size was getting ridiculous. I agree with your opinion that this is a pittance compared to other things more relevant to performance. In retrospect, this looks like a premature optimization for every conceivable use case I can come up with. Should I close this PR, then?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-07-14 12:09</div>
            <div class="timeline-body"><p>Yeah let&#x27;s go ahead and close this, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-07-14 12:09</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:18 UTC
    </footer>
</body>
</html>
