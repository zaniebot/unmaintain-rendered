<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>^$ matches a phantom line at end of file - BurntSushi/ripgrep #441</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>^$ matches a phantom line at end of file</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/441">#441</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2017-04-08 00:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>This is simple to demonstrate. Note the behavior difference between GNU grep and ripgrep:</p>
<pre><code>$ cat scratch 
a
b

c


d
$ rg '^$' scratch
3:
5:
6:
8:
$ egrep -n '^$' scratch
3:
5:
6:
</code></pre>
<p>The <code>^$</code> pattern is a useful idiom for detecting empty lines in a file. ripgrep's behavior in particular outputs a line numbered 8, even though there are only 7 lines in the file:</p>
<pre><code>$ wc -l scratch
7 scratch
</code></pre>
<p>More generally, ripgrep should never emit a line with a number greater than the number of lines in the file, even if the file ends with a trailing <code>\n</code>.</p>
<p>See also https://github.com/BurntSushi/ripgrep/issues/416 and https://github.com/rust-lang/regex/issues/355#issuecomment-292679709 for the root cause</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-08 00:30</div>
            <div class="timeline-body"><p>cc @BatmanAoD</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @BurntSushi on 2017-04-08 00:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-04-10 18:18</div>
            <div class="timeline-body"><p>Thanks for filing this. I agree that it's reasonable to keep the <code>regex</code> crate behavior.</p>
<p>(Also, I know you asked for example use-cases for this, and unfortunately, although I know I've used something like <code>ack '^$'</code> in the past, I can't actually remember the specifics. I did find some StackOverflow questions with numerous upvotes about how to search for empty lines, but I didn't see anyone discussing specifically why they wanted to do that. This may not be a common enough use-case to be a high-priority bug.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-10 18:22</div>
            <div class="timeline-body"><p>@BatmanAoD Right. When I asked that, I hadn't thought of &quot;match empty lines.&quot; Once I spent a couple of minutes thinking, I remembered it. That's a strong enough use case as far as I'm concerned. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-10 18:22</div>
            <div class="timeline-body"><p>(I wouldn't expect someone to care about matching empty lines necessarily, but I could see someone being interested in counting them.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/blankname">@blankname</a> on 2017-04-10 18:34</div>
            <div class="timeline-body"><p>I use matching empty lines in conjunction with the --invert-match option to filter out empty lines when piping commands.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-04-10 19:35</div>
            <div class="timeline-body"><p>@blankname That actually shouldn't be a problem! You'll &quot;erroneously&quot; filter out a phantom line--which should have no effect.</p>
<p>@BurntSushi Counting seems like an interesting application indeed, but as soon as I thought about that I thought &quot;isn't that just a sort of crumby, broken <code>loc</code>?&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-10 20:26</div>
            <div class="timeline-body"><p>I've never heard of, or used, <code>loc</code>. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-04-10 21:07</div>
            <div class="timeline-body"><p><code>loc</code> and <code>tokei</code> are Rust clones of <code>cloc</code>, which counts the lines of code in a project and produces a nice little table where the rows are different languages (autodetected) and the columns are things like blank lines, comments, and actual code. I've used <code>cloc</code> a lot more than <code>loc</code> (it's a lot older), but I figured <code>loc</code> would be the right one to mention here!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 22:14</div>
            <div class="timeline-body"><p>Here are a pair of regression tests:</p>
<pre><code class="language-rust">// See: https://github.com/BurntSushi/ripgrep/issues/441
clean!(regression_441_mmap, &quot;^$&quot;, &quot;test&quot;, |wd: WorkDir, mut cmd: Command| {
    wd.create(&quot;test&quot;, &quot;a\nb\n\nc\n\n\nd\n&quot;);
    cmd.arg(&quot;--mmap&quot;);

    let lines: String = wd.stdout(&amp;mut cmd);
    assert_eq!(lines, &quot;\n\n\n&quot;);
});

// See: https://github.com/BurntSushi/ripgrep/issues/441
clean!(regression_441_no_mmap, &quot;^$&quot;, &quot;test&quot;, |wd: WorkDir, mut cmd: Command| {
    wd.create(&quot;test&quot;, &quot;a\nb\n\nc\n\n\nd\n&quot;);
    cmd.arg(&quot;--no-mmap&quot;);

    let lines: String = wd.stdout(&amp;mut cmd);
    assert_eq!(lines, &quot;\n\n\n&quot;);
});
</code></pre>
<p>Interestingly, the output of the <code>mmap</code> test is <code>\n\n\n\n</code> and the output of the <code>no_mmap</code> test is <code>\n\n\n\n\n</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @BurntSushi on 2017-05-08 22:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 22:21</div>
            <div class="timeline-body"><p>And also a more precise comparison with grep:</p>
<pre><code>$ cat scratch
a
b

c


d
$ xxd scratch
00000000: 610a 620a 0a63 0a0a 0a64 0a              a.b..c...d.
$ grep '^$' scratch | xxd
00000000: 0a0a 0a                                  ...
$ rg --mmap '^$' scratch | xxd
00000000: 0a0a 0a0a                                ....
$ rg --no-mmap '^$' scratch | xxd
00000000: 0a0a 0a0a 0a                             .....
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "libripgrep" by @BurntSushi on 2018-06-03 21:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-03 21:08</div>
            <div class="timeline-body"><p>I believe this bug should be fixed in libripgrep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2018-06-05 17:00</div>
            <div class="timeline-body"><p>&quot;Should&quot; meaning &quot;ought to be&quot;? Since the libripgrep issue itself states that libripgrep won't be a proper &quot;thing unto itself&quot;, do you have an idea of which specific subcomponent should handle this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-05 17:17</div>
            <div class="timeline-body"><p>libripgrep is a complete rewrite of the search components of ripgrep. As I progress through that rewrite, I'm looking at bugs in this space that I can fix.</p>
<p>The libripgrep milestone is tracked here: https://github.com/BurntSushi/ripgrep/issues?q=is%3Aopen+is%3Aissue+milestone%3Alibripgrep</p>
<blockquote>
<p>Since the libripgrep issue itself states that libripgrep won't be a proper &quot;thing unto itself&quot;</p>
</blockquote>
<p>This just means that there isn't going to be a singular ripgrep library. There will be many. The <code>grep</code> crate will be the focal point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2018-06-05 17:29</div>
            <div class="timeline-body"><p>Ah, okay, I thought it was more of a refactoring/splitting than a complete rewrite.</p>
<p>Might #416 (or even a partial solution like #929) be another candidate for fixing in the rewrite?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-05 17:55</div>
            <div class="timeline-body"><p>Unlikely. The fix for #416 is to fix the regex engine.</p>
<blockquote>
<p>Ah, okay, I thought it was more of a refactoring/splitting than a complete rewrite.</p>
</blockquote>
<p>They are both true. I don't think the distinction matters much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2018-08-20 11:10</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:08 UTC
    </footer>
</body>
</html>
