<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add --nb-lines-limit to ignore the rest of file and speedup the seach - BurntSushi/ripgrep #456</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add --nb-lines-limit to ignore the rest of file and speedup the seach</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/456">#456</a>
        opened by <a href="https://github.com/zimski">@zimski</a>
        on 2017-04-21 15:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zimski">@zimski</a></div>
            <div class="timeline-body"><p>I would tell to <code>ripgrep</code> to search only in let's say the first 5 lines on each file, because it's the only relevant part for the use-case.</p>
<p>I want this feature to speedup the search on a huge number of large files with an known structure and the relevant part is only in the first 5 lines for example.</p>
<p>it's like a combine of <code>find | head -n5 | grep</code></p>
<pre><code>0. #------------- header with the data I am looking for
.... lines
5.#-------------
the rest of the file should be ignored
...
</code></pre>
<p>If you think that this usecase can be usefull for you, I can contribute.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-21 15:45</div>
            <div class="timeline-body"><p>That's interesting. You should actually be able to run <code>find | head -n5 | rg</code> and have it work just like it would with <code>grep</code>.</p>
<p>The key problem with taking over file discovery is that it reduces composition with other tools. However, ripgrep can still be used just like you would use <code>grep</code> in this case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/richarson">@richarson</a> on 2017-04-23 19:03</div>
            <div class="timeline-body"><p>@zimski, I would have said: &quot;It's like GNU grep's -m/--max-count option&quot; :)</p>
<p>I don't know if other versions of grep have a similar option.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-23 19:34</div>
            <div class="timeline-body"><p>@richarson I don't think it's like that all though? And if it was, that would be good news because ripgrep has the <code>-m/--max-count</code> flag. The OP seems to be asking for &quot;only search the first 5 lines&quot; rather than &quot;show me the first 5 matches.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zimski">@zimski</a> on 2017-04-23 20:00</div>
            <div class="timeline-body"><p>Yep @BurntSushi  you are right, @richarson maybe my issue description was not clear enough.</p>
<p>To make the usecase more easy to understand, I will explain how I want to use this feature.</p>
<p>I have a lot of servers caching on disk a lot of contents using Nginx ( like a CDN )</p>
<p>To speedup the cache flushing and make it more smart (flush only some urls .. some domains) we insert some <code>KEY</code> on the header of the cached file.</p>
<p>the file stored looks like this</p>
<pre><code>KEY:  domain/urls ... uac
HTTP headers

file content
</code></pre>
<p>To flush we run a <code>ripgrep</code> on the root cache folder and catch the targeted files to remove them.</p>
<p>However, the cached file can be large, and <code>ripgrep</code> will search on the whole file if it doesn't find nothing in the header part ( obviously it will find nothing and all this time/cpu was wasted :\ )</p>
<p>So if I can to tell to <code>ripgrep</code> to consider only the first line .. I will gain a lot.</p>
<p>I hope this will be make this feature proposal more clearer and considerable.</p>
<p>I have done some experiment using the only <code>find head and grep</code> and I gain a lot, but I am sure that it can be more efficient (memory/cpu) if it was implemented inside <code>ripgrep</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-23 20:26</div>
            <div class="timeline-body"><blockquote>
<p>I have done some experiment using the only find head and grep and I gain a lot, but I am sure that it can be more efficient (memory/cpu) if it was implemented inside ripgrep</p>
</blockquote>
<p>Doubtful. Maybe a little. You could test this by creating an identical directory structure, but with only the first five lines of each file you're trying to search. Then compare <code>rg</code> with <code>find | head | rg</code>.</p>
<p>This seems really niche to me. I think I'd rather you try to find a way to use <code>find</code> instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/richarson">@richarson</a> on 2017-04-24 22:20</div>
            <div class="timeline-body"><p>@BurntSushi you're right of course, I misinterpreted what @zimski was asking for.</p>
<p>And good to know ripgrep has that option too :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 21:36</div>
            <div class="timeline-body"><p>I'm going to close this under the principle that ripgrep can't add a new flag for every use case under the sun. Yes, we'd all love to have the pretty output, but falling back to standard pipelining sometimes should be OK.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2017-05-08 21:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Rodrigodd">@Rodrigodd</a> on 2025-07-17 16:30</div>
            <div class="timeline-body"><p>I stumbled upon this issue while trying to search for this flag, so I’m documenting it here in case it helps anyone else.</p>
<hr />
<p>Using <code>find | head -n5 | rg</code> doesn’t work. The command <code>find | head -n5</code> simply lists the names of 5 files. I tried to get it to work using something like <code>find . -exec</code>, but then you lose the filename information in the output.</p>
<p>However, it is possible to use the <code>--pre</code> option instead:</p>
<pre><code class="language-sh">rg pattern --pre=head
</code></pre>
<p>This limits the search to the first 10 lines of each file. Note that the <code>--pre</code> option doesn't allow you to pass arguments to the command, so you cannot easily search instead only the first 5 lines or the first 100 bytes. For anything more complicated you could follow the help for the option:</p>
<pre><code>   --pre=COMMAND
       For each input PATH, this flag causes ripgrep to search the standard output of COMMAND PATH instead of the contents of PATH.   This  option
       expects  the  COMMAND program to either be a path or to be available in your PATH. Either an empty string COMMAND or the --no-pre flag will
       disable this behavior.

       WARNING     When this flag is set, ripgrep will unconditionally spawn a process for every file that is searched. Therefore, this can  incur
                   an unnecessarily large performance penalty if you don't otherwise need the flexibility offered by this flag. One possible miti‐
                   gation to this is to use the --pre-glob flag to limit which files a preprocessor is run with.

       A preprocessor is not run when ripgrep is searching stdin.

       When searching over sets of files that may require one of several preprocessors, COMMAND should be a wrapper program which first classifies
       PATH based on magic numbers/content or based on the PATH name and then dispatches to an appropriate preprocessor. Each COMMAND also has its
       standard input connected to PATH for convenience.

       For example, a shell script for COMMAND might look like:

           case &quot;$1&quot; in
           *.pdf)
               exec pdftotext &quot;$1&quot; -
               ;;
           *)
               case $(file &quot;$1&quot;) in
               *Zstandard*)
                   exec pzstd -cdq
                   ;;
               *)
                   exec cat
                   ;;
               esac
               ;;
           esac

       The  above  script  uses  pdftotext to convert a PDF file to plain text. For all other files, the script uses the file utility to sniff the
       type of the file based on its contents. If it is a compressed file in the Zstandard format, then pzstd is used to decompress  the  contents
       to stdout.

       This overrides the -z/--search-zip flag.</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:09 UTC
    </footer>
</body>
</html>
