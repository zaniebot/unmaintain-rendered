<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for stop after num matches - BurntSushi/ripgrep #159</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for stop after num matches</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/159">#159</a>
        opened by <a href="https://github.com/mengelbrecht">@mengelbrecht</a>
        on 2016-10-09 08:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mengelbrecht">@mengelbrecht</a></div>
            <div class="timeline-body"><p>Add an option to stop reading a file after <code>num</code> matches have been found. This equals the <code>-m</code>, <code>--max-count</code> option from grep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-09 13:01</div>
            <div class="timeline-body"><p>I believe GNU grep has this, right?</p>
<p>I&#x27;m inclined to add it, but could you provide a use case for it? One slight
concern I have is its use in recursive directory search, since on a multi
core system, the output of search results isn&#x27;t deterministic. However, I
can see it being useful as a way to avoid flooding your terminal.</p>
<p>For single file search, its usefulness is a bit clearer I think.</p>
<p>On Oct 9, 2016 4:42 AM, &quot;Markus Engelbrecht&quot; notifications@github.com
wrote:</p>
<blockquote>
<p>Add an option to stop reading a file after num matches have been found.
This equals the -m, --max-count option from grep.</p>
<p>—
You are receiving this because you are subscribed to this thread.
Reply to this email directly, view it on GitHub
<a href="https://github.com/BurntSushi/ripgrep/issues/159">BurntSushi/ripgrep#159</a>, or mute the thread
https://github.com/notifications/unsubscribe-auth/AAb34gtufVeUBufuNmREEbhedQaxI24uks5qyKjXgaJpZM4KR8jt
.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mengelbrecht">@mengelbrecht</a> on 2016-10-09 14:00</div>
            <div class="timeline-body"><p>Yes GNU grep has this.</p>
<p>The use case is repeatedly filtering stdin (or a single file) with a match limit to look for a specific match. If the match is not found the user can refine the pattern until it is.
This technique can be applied to filter a list of files for a certain entry and pick it (e.g. <a href="https://github.com/ctrlpvim/ctrlp.vim">CtrlP</a> fuzzy file finding).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-09 14:08</div>
            <div class="timeline-body"><p>@mgee But even if you give a list of files, <code>ripgrep</code> will process them in parallel, which means the output won&#x27;t be deterministic. That means the option only becomes useful in your use case if you pass <code>-j1</code> (which disables parallelism and therefore gets deterministic output).</p>
<p>I&#x27;m not necessarily saying that this is a good reason to not have this flag, but I am saying that it seems like bad UX.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-09 14:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mengelbrecht">@mengelbrecht</a> on 2016-10-09 14:31</div>
            <div class="timeline-body"><p>@BurntSushi true, this option only has good UX when used with stdin or a single file (my use case). Maybe a note in the documentation about non-determinism when <code>ripgrep</code> is given multiple files (or a path) would be sufficient?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mengelbrecht">@mengelbrecht</a> on 2016-10-09 15:28</div>
            <div class="timeline-body"><p>@BurntSushi I just realized that what I previously wrote could be misunderstood. With <em>a list of files</em> I meant I have a single file which contains a list of filenames which I successively filter with a pattern. In each step the pattern can be refined to reduce the list of matched filenames until the desired filename is found.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-09 15:48</div>
            <div class="timeline-body"><p>@mgee Ah, I did misunderstand that. Thanks for clarifying.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-06 18:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mengelbrecht">@mengelbrecht</a> on 2016-11-06 19:04</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sergeevabc">@sergeevabc</a> on 2019-03-25 12:46</div>
            <div class="timeline-body"><p>GNU’s Grep <code>-m</code> is quite an ambiguous switch. Manual says <code>stop after NUM matches</code>, but since Grep is line-based tool (which slips away every now and then), it counts not actual pattern matches, but lines. Imagine this:</p>
<pre><code>$ grep -m 4 -n -oP pattern
2:8  
2:11 
3:16           
4:28                      &lt;--- you need 4 results only, stop after that
4:29 
4:30 
4:36 
</code></pre>
<p>Instead, you have to <code>grep ... | head -4</code> to get 4 results.</p>
<p>Now Ripgrep provides a clearer description (<code>limit the number of matching lines per file searched to NUM</code>), thanks for that! But it turns out that it cannot stop after actual pattern matches. So frustrating…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlphaJack">@AlphaJack</a> on 2023-07-26 21:33</div>
            <div class="timeline-body"><p><code>ack -1 ...</code> is useful for recursive search, as it stops searching other files after a match is found. <code>grep</code> cannot reproduce this behavior, as <code>-m 1</code> does not prevent searching other files after a match is found.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Podbrushkin">@Podbrushkin</a> on 2023-12-27 11:50</div>
            <div class="timeline-body"><p>Not sure why this is closed as Completed, since RipGrep doesn&#x27;t have option &quot;to stop after num matches&quot;.
I have a 5gb text file without linebreaks, I want to find a substring in it and get byte offset of its first occurrence. Both Grep and RipGrep can&#x27;t help me with that.</p>
<p><code>rg -b -o --no-line-number --line-buffered --fixed-strings -m 1 &quot;000000&quot; .\5gbunicode.txt</code> - This takes 20 seconds and outputs 3876278 lines, while I need only one. <code>--max-matches</code> would be very helpful. Or if there would be alternative <code>--line-buffered</code> which will buffer relative to actual output, not to file structure. I think to buffer lines relative to output is more reasonable, since buffering is about output, not input. This way at least it will be possible to limit output by pressing Ctrl+C once you see in terminal first matches occurring.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-12-27 14:11</div>
            <div class="timeline-body"><blockquote>
<p>Not sure why this is closed as Completed</p>
</blockquote>
<p>It was closed as completed because a <code>-m/--max-count</code> flag was added. There was even a <a href="https://github.com/BurntSushi/ripgrep/commit/58aca2efb24801b43870acac5b40c59fbc9ef350">commit</a> referenced that can click on above. I&#x27;m not sure how else to explain it.</p>
<blockquote>
<p><code>rg -b -o --no-line-number --line-buffered --fixed-strings -m 1 &quot;000000&quot; .\5gbunicode.txt</code> - This takes 20 seconds and outputs 3876278 lines, while I need only one.</p>
</blockquote>
<p>When reporting behavior that doesn&#x27;t work like you expect, <em><strong>please</strong></em> include a reproduction. And please don&#x27;t bump issues that are 7 years old. Please just take a moment to minimize it. Here, watch:</p>
<pre><code>$ cat haystack
fooabcfooabc
fooabcfooabc
$ rg abc haystack
1:fooabcfooabc
2:fooabcfooabc
$ rg abc haystack -m1
1:fooabcfooabc
$ rg abc haystack -m1 -o
1:abc
1:abc
</code></pre>
<p>The above output should make it clear that the <code>-m1</code> flag is actually doing something. In the second example, only one line is printed, although that line does contain two matches. In the second example, two lines are printed, but only from the first matching line. Indeed, this is consistent with how the <code>-m/--max-count</code> flag is documented:</p>
<pre><code>    -m NUM, --max-count=NUM
        Limit the number of matching lines per file searched to NUM.

        Note that 0 is a legal value but not likely to be useful. When used,
        ripgrep won&#x27;t search anything.
</code></pre>
<p>That is, it is a limit on the number of matching lines and not the number of matches.</p>
<p>To me, this suggests your <code>5gbunicode.txt</code> file is one giant line.</p>
<blockquote>
<p>I want to find a substring in it and get byte offset of its first occurrence. Both Grep and RipGrep can&#x27;t help me with that.</p>
</blockquote>
<p>Of course they can. Watch:</p>
<pre><code>$ rg abc haystack -m1 -o | head -n1
abc
</code></pre>
<p>Both ripgrep and grep will stop searching after printing the first match.</p>
<blockquote>
<p>Or if there would be alternative --line-buffered which will buffer relative to actual output, not to file structure. I think to buffer lines relative to output is more reasonable, since buffering is about output, not input. This way at least it will be possible to limit output by pressing Ctrl+C once you see in terminal first matches occurring.</p>
</blockquote>
<p>I can&#x27;t make heads or tails of what you&#x27;re saying here. The default behavior is to choose the buffering strategy based on where ripgrep is printing (line buffering for tty and block buffering for a file). By passing <code>--line-buffered</code>, you are forcing line buffering and disabling ripgrep&#x27;s automatic heuristic. It is unclear why you&#x27;re doing that here and I don&#x27;t understand what you&#x27;re asking for. Please <a href="https://github.com/BurntSushi/ripgrep/discussions">open a Discussion question</a> about this if you&#x27;re still confused.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:01 UTC
    </footer>
</body>
</html>
