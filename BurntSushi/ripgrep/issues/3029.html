<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ripgrep can become unresponsive to even ctrl-c for some time when ran with permission issues - BurntSushi/ripgrep #3029</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Ripgrep can become unresponsive to even ctrl-c for some time when ran with permission issues</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/3029">#3029</a>
        opened by <a href="https://github.com/Porkepix">@Porkepix</a>
        on 2025-04-11 12:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Porkepix">@Porkepix</a></div>
            <div class="timeline-body"><h3>Please tick this box to confirm you have reviewed the above.</h3>
<ul>
<li>[x] I have a different issue.</li>
</ul>
<h3>What version of ripgrep are you using?</h3>
<p>14.1.1</p>
<h3>How did you install ripgrep?</h3>
<p>Arch's repos</p>
<h3>What operating system are you using ripgrep on?</h3>
<p>ArchLinux</p>
<h3>Describe your bug.</h3>
<p>Running ripgrep to match something from the root cause numerous issues which are at least for some normal and expected, at least for the first kind of this list:</p>
<ul>
<li><code>Permission denied (os error 13)</code></li>
<li><code>Invalid argument (os error 22)</code> in <code>/proc</code> locations</li>
</ul>
<h3>What are the steps to reproduce the behavior?</h3>
<p>Run <code>rg &quot;am_pm&quot; /</code> for example, then try to cancel it with <code>ctrl-c</code>.</p>
<h3>What is the actual behavior?</h3>
<p>It hangs for dozens of seconds before <code>ctrl-c</code> actually kills it and we get our prompt back.</p>
<h3>What is the expected behavior?</h3>
<p>It shouldn't hang on the <code>ctrl-c</code> and we should get our prompt back immediately.
Curiously enough, if the exact same command is ran with <code>sudo</code>, then<code>ctrl-c</code> acts instantly and we get no hangs at all.</p>
<p>To note that it also hangs for a long time after no more errors are printed and it seemingly ended the search before we finally get a prompt back.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-04-11 12:57</div>
            <div class="timeline-body"><p>Duplicate of #2897, #1331, #311</p>
<p>Possibly related: #1145, #873</p>
<p>This isn't something that ripgrep can control. ripgrep doesn't even try to handle <code>^C</code>, and any unhandled signal means that the OS will attempt to kill the process. But there are lots of reasons why a process can't easily be stopped.</p>
<p>Search <code>/</code>, and particularly including special files like <code>/proc</code> and what not, is bad juju. In some cases, even just <em>reading</em> files in those directories will have side effects on your system. And particularly so when running as <code>root</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2025-04-11 12:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">duplicate</span> added by @BurntSushi on 2025-04-11 12:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Porkepix">@Porkepix</a> on 2025-04-11 13:00</div>
            <div class="timeline-body"><blockquote>
<p>This isn't something that ripgrep can control. ripgrep doesn't even try to handle <code>^C</code>, and any unhandled signal means that the OS will attempt to kill the process. But there are lots of reasons why a process can't easily be stopped.</p>
<p>Search <code>/</code>, and particularly including special files like <code>/proc</code> and what not, is bad juju. In some cases, even just <em>reading</em> files in those directories will have side effects on your system. And particularly so when running as <code>root</code>.</p>
</blockquote>
<p>But then why the difference of treatment between when it's run by <code>sudo</code> or not?</p>
<p>I get that it might not be recommended, but it's sometimes useful when you don't remember where something can be, and <code>GNU grep</code> seems to handle it without pain, aside the expected permissions errors?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-04-11 13:23</div>
            <div class="timeline-body"><p>Because <code>sudo</code> impacts how those files are read. Reconsider what I said above: the mere <em>act</em> of reading some files has side effects, and permissions can impact how those files are read. I cannot <em>possibly</em> give you a precise answer here because there's no MRE. If I run your commands on one of my systems, it completes after 30 seconds without problems. And I can <code>^C</code> at any point and it terminates almost instantly. On the other hand, if I run <code>sudo rg am_pm /</code>, then the search is still running minutes later. And note that I had to unmount my network shares before doing this test, because other ripgrep would just search over literal terabytes from my NAS. And in my experience, network I/O can absolutely cause the kind of hanging you're seeing.</p>
<p>GNU grep falls over too, depending on what you're doing:</p>
<pre><code>$ time grep -a ZQZQZQZQ /proc/self/pagemap
zsh: killed     grep --color=auto -a ZQZQZQZQ /proc/self/pagemap

real    4.460
user    1.321
sys     3.123
maxmem  6685 MB
faults  0
$ sudo dmesg | rg -i oom
[137771.992498] grep invoked oom-killer: gfp_mask=0x140dca(GFP_HIGHUSER_MOVABLE|__GFP_COMP|__GFP_ZERO), order=0, oom_score_adj=0
[137771.992522]  oom_kill_process.cold+0x8/0x8a
[137771.992676] [  pid  ]   uid  tgid total_vm      rss rss_anon rss_file rss_shmem pgtables_bytes swapents oom_score_adj name
[137771.992800] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/user.slice/user-1000.slice/session-3.scope,task=grep,pid=49358,uid=1000
[137771.992814] Out of memory: Killed process 49358 (grep) total-vm:9476316kB, anon-rss:6845824kB, file-rss:444kB, shmem-rss:0kB, UID:1000 pgtables:13460kB oom_score_adj:0
</code></pre>
<p>Maybe multi-threading makes ripgrep use more memory, to the point that it grinds your system to a hault. It's very hard to say without being able to stand over your shoulder. You could try running with <code>rg -j1</code> to test that theory.</p>
<p>An MRE here means isolating the problematic files.</p>
<blockquote>
<p>but it's sometimes useful when you don't remember where something can be</p>
</blockquote>
<p>The linked issues give you work-arounds via <code>.rgignore</code> files. I assume that what you're looking for is known not to be in special directories like <code>/sys</code>, <code>/proc</code> and <code>/dev</code>. If so, then you should exclude those directories and you should be fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Porkepix">@Porkepix</a> on 2025-04-11 13:29</div>
            <div class="timeline-body"><blockquote>
<p>Because <code>sudo</code> impacts how those files are read. Reconsider what I said above: the mere <em>act</em> of reading some files has side effects, and permissions can impact how those files are read. I cannot <em>possibly</em> give you a precise answer here because there's no MRE. If I run your commands on one of my systems, it completes after 30 seconds without problems. And I can <code>^C</code> at any point and it terminates almost instantly. On the other hand, if I run <code>sudo rg am_pm /</code>, then the search is still running minutes later. And note that I had to unmount my network shares before doing this test, because other ripgrep would just search over literal terabytes from my NAS. And in my experience, network I/O can absolutely cause the kind of hanging you're seeing.</p>
<p>GNU grep falls over too, depending on what you're doing:</p>
<pre><code>$ time grep -a ZQZQZQZQ /proc/self/pagemap
zsh: killed     grep --color=auto -a ZQZQZQZQ /proc/self/pagemap

real    4.460
user    1.321
sys     3.123
maxmem  6685 MB
faults  0
$ sudo dmesg | rg -i oom
[137771.992498] grep invoked oom-killer: gfp_mask=0x140dca(GFP_HIGHUSER_MOVABLE|__GFP_COMP|__GFP_ZERO), order=0, oom_score_adj=0
[137771.992522]  oom_kill_process.cold+0x8/0x8a
[137771.992676] [  pid  ]   uid  tgid total_vm      rss rss_anon rss_file rss_shmem pgtables_bytes swapents oom_score_adj name
[137771.992800] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0,global_oom,task_memcg=/user.slice/user-1000.slice/session-3.scope,task=grep,pid=49358,uid=1000
[137771.992814] Out of memory: Killed process 49358 (grep) total-vm:9476316kB, anon-rss:6845824kB, file-rss:444kB, shmem-rss:0kB, UID:1000 pgtables:13460kB oom_score_adj:0
</code></pre>
<p>Maybe multi-threading makes ripgrep use more memory, to the point that it grinds your system to a hault. It's very hard to say without being able to stand over your shoulder. You could try running with <code>rg -j1</code> to test that theory.</p>
<p>An MRE here means isolating the problematic files.</p>
<blockquote>
<p>but it's sometimes useful when you don't remember where something can be</p>
</blockquote>
<p>The linked issues give you work-arounds via <code>.rgignore</code> files. I assume that what you're looking for is known not to be in special directories like <code>/sys</code>, <code>/proc</code> and <code>/dev</code>. If so, then you should exclude those directories and you should be fine.</p>
</blockquote>
<p>Just to understand, what does MRE stands for?</p>
<p>Because I think there might have been a misunderstanding here, it doesn't put my whole system to a halt, it just hangs the terminal running the command that doesn't respond instantly to <code>ctrl-c</code>.</p>
<p>I had no network storage attached, so this is out of the equation, however <code>j1</code> indeed result in <code>ctrl-c</code> being handled instantly.</p>
<p>I'll look at the <code>.rgignore</code> file, didn't knew this was a thing now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-04-11 13:52</div>
            <div class="timeline-body"><p>For MRE, see <a href="https://en.wikipedia.org/wiki/Minimal_reproducible_example">https://en.wikipedia.org/wiki/Minimal_reproducible_example</a> and <a href="https://stackoverflow.com/help/minimal-reproducible-example">https://stackoverflow.com/help/minimal-reproducible-example</a></p>
<p>In this case, an MRE would probably mean isolating the specific directories causing problems. And this case is particularly gnarly because that might not even be possible. What you might be seeing is only possible through an aggregate effect.</p>
<blockquote>
<p>Because I think there might have been a misunderstanding here, it doesn't put my whole system to a halt, it just hangs the terminal running the command that doesn't respond instantly to <code>ctrl-c</code>.</p>
</blockquote>
<p>No I get that. The imprecision of my response is an artifact of 1) others experience overall system hangs when searching <code>/</code> and 2) the inability to know <em>precisely</em> know what is happening in your situation. Think of it like a <a href="https://en.wikipedia.org/wiki/Diagnosis_of_exclusion">diagnosis of exclusion</a>. We could go back-and-forth all day with theories I have and you saying, &quot;well no, my specific situation doesn't have that.&quot; (e.g., No network I/O.)</p>
<p>The actual bottom line here this:</p>
<ol>
<li>It is known that searching special directories like <code>/proc</code>, <code>/sys</code> and <code>/dev</code> is problematic. You might get OOMed. It might run forever. It might grind your system to a hault. It might even <em>reboot</em> your system!</li>
<li>The best way to avoid those problems, in general, is to exclude them from your search.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Porkepix">@Porkepix</a> on 2025-10-21 23:35</div>
            <div class="timeline-body"><p>@BurntSushi I realize I've let this unanswered, first thanks for explanations (and I still have to look for the <code>.rgignore</code> way of managing this.</p>
<p>But I  wondered if maybe it was considered at some point in the past if it'd be relevant for these special directories to get the same treatment as hidden directories or <code>.gitignore</code> content and ignore these by default, unless user explicitly request otherwise through flags/config? Cases were people would went to search in these are probably quite rares I'd say?</p>
<p>Also, as I wanted to check if either one of these three would be the real culprit, I just noticed I can't reproduce the issue anymore, whether it's by some system changes or due to the newest <code>ripgrep 15.0.0</code>!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-10-22 12:59</div>
            <div class="timeline-body"><p>@Porkepix I've seen that question appear in one form or another a few times, so I've decided to just answer it once and for all here: https://github.com/BurntSushi/ripgrep/discussions/3204</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Porkepix">@Porkepix</a> on 2025-10-22 14:12</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/Porkepix">@Porkepix</a> I've seen that question appear in one form or another a few times, so I've decided to just answer it once and for all here: <a href="https://github.com/BurntSushi/ripgrep/discussions/3204">#3204</a></p>
</blockquote>
<p>Thanks for the detailed answer; it's a shame you can't (I think) pin this like you can with an issue. Or maybe a first answer to a FAQ.md to come if you get some other recurring questions like this one!</p>
<p>Maybe something changed for those three special directories anyway, for the better, as the issue that always triggered now doesn't anymore, so it might be better handled now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-10-22 14:22</div>
            <div class="timeline-body"><p>It's probably just luck to be honest. The behavior of files in these directories can be heavily reliant on system state.</p>
<p>I'd just strongly urge against searching them.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:54 UTC
    </footer>
</body>
</html>
