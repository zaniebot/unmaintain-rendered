<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>semi-automatic encoding detection - BurntSushi/ripgrep #746</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>semi-automatic encoding detection</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/746">#746</a>
        opened by <a href="https://github.com/tbsmark86">@tbsmark86</a>
        on 2018-01-12 21:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/tbsmark86">@tbsmark86</a></div>
            <div class="timeline-body"><p>When dealing with directory&#x27;s with mixed encoding (legacy and utf-8) its impossible to search for certain chars on all files.  (Like German umlaute).</p>
<p>I&#x27;d like to see an option that something like &quot;-E cp1252&quot; is only used if the file is invalid as utf-8. There are of course some corner case where a cp1252 file can be valid utf-8 but those should be rare.</p>
<p>I&#x27;am completely new to rust - i&#x27;ve hacked something that works for me:</p>
<pre><code>--- a/src/decoder.rs
+++ b/src/decoder.rs
@@ -1,7 +1,7 @@
 use std::cmp;
 use std::io::{self, Read};
 
-use encoding_rs::{Decoder, Encoding, UTF_8};
+use encoding_rs::{Decoder, Encoding, UTF_8, DecoderResult};
 
 /// A BOM is at least 2 bytes and at most 3 bytes.
 ///
@@ -139,8 +139,11 @@ pub struct DecodeReader&lt;R, B&gt; {
     /// Whether a &quot;last&quot; read has occurred. After this point, EOF will always
     /// be returned.
     last: bool,
+    /// Only use decode if any invalid utf8 sequence is encounterd
+    try_utf8_first: bool,
     /// The underlying text decoder derived from the BOM, if one exists.
     decoder: Option&lt;Decoder&gt;,
+    utf8_decoder: Decoder,
 }
 
 impl&lt;R: io::Read, B: AsMut&lt;[u8]&gt;&gt; DecodeReader&lt;R, B&gt; {
@@ -167,7 +170,9 @@ impl&lt;R: io::Read, B: AsMut&lt;[u8]&gt;&gt; DecodeReader&lt;R, B&gt; {
             pos: 0,
             first: enc.is_none(),
             last: false,
+            try_utf8_first: true,
             decoder: enc.map(|enc| enc.new_decoder_with_bom_removal()),
+            utf8_decoder: UTF_8.new_decoder_with_bom_removal()
         }
     }
 @@ -255,6 +260,52 @@ impl&lt;R: io::Read, B: AsMut&lt;[u8]&gt;&gt; DecodeReader&lt;R, B&gt; {
         self.decoder = bom.decoder();
         Ok(())
     }
+    
+    fn detect_streaming(&amp;mut self, buf: &amp;mut [u8]) -&gt; io::Result&lt;usize&gt; {
+        assert!(buf.len() &gt;= 4);
+        if self.last {
+            return Ok(0);
+        }
+        if self.pos &gt;= self.buflen {
+            self.fill()?;
+        }
+        let mut nwrite = 0;
+        loop {
+            let (error, nin, nout) =
+                self.utf8_decoder.decode_to_utf8_without_replacement(
+                    &amp;self.buf.as_mut()[self.pos..self.buflen], buf, false);
+            match error {
+                DecoderResult::Malformed(_, _) =&gt; {
+                    if nwrite &gt; 0 {
+                        return Ok(nwrite);
+                    }
+                    return self.transcode(buf);
+                }
+                _ =&gt; {}
+            }
+            self.pos += nin;
+            nwrite += nout;
+            // If we&#x27;ve written at least one byte to the caller-provided
+            // buffer, then our mission is complete.
+            if nwrite &gt; 0 {
+                break;
+            }
+            // Otherwise, we know that our internal buffer has insufficient
+            // data to transcode at least one char, so we attempt to refill it.
+            self.fill()?;
+            // Quit on EOF.
+            if self.buflen == 0 {
+                self.pos = 0;
+                self.last = true;
+                let (_, _, nout, _) =
+                    self.utf8_decoder.decode_to_utf8(
+                        &amp;[], buf, true);
+                return Ok(nout);
+            }
+        }
+        Ok(nwrite)
+
+    }
 }
 
 impl&lt;R: io::Read, B: AsMut&lt;[u8]&gt;&gt; io::Read for DecodeReader&lt;R, B&gt; {
@@ -276,6 +327,9 @@ impl&lt;R: io::Read, B: AsMut&lt;[u8]&gt;&gt; io::Read for DecodeReader&lt;R, B&gt; {
                 io::ErrorKind::Other,
                 &quot;DecodeReader: byte buffer must have length at least 4&quot;));
         }
+        if self.try_utf8_first {
+            return self.detect_streaming(buf);
+        }
         self.transcode(buf)
     }
 }
</code></pre>
<p>Obviously this is not really optional, also it may be better if this a kind of child-class that&#x27;s only active while this option is used.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Semi-automatic encoding detection&quot; to &quot;semi-automatic encoding detection&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-31 02:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-31 02:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-31 02:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-31 02:08</div>
            <div class="timeline-body"><p>I agree this would be a nice feature. Thanks for reporting it. Thanks for the patch as well.</p>
<p>I think before we work on any code for this, we need a strong specification that outlines ripgrep&#x27;s automatic encoding detection behavior. We need to be careful going down this road because encoding detection can never be bullet proof, which exposes us to bug reports that we cannot fix. For that reason, while I do think this would be cool, I&#x27;m not actually quite convinced that we should definitely do this. I&#x27;ll leave this issue open for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tbsmark86">@tbsmark86</a> on 2018-02-26 19:12</div>
            <div class="timeline-body"><p>Yes automatic detection can&#x27;t be bullet proof.</p>
<p>But if it is never documented as &#x27;automatic&#x27; won&#x27;t that solve the bug report problem?</p>
<p>Something like that:</p>
<p>-E --encoding
Specify the text ...
--fallback-encoding 
Specify the text encoding to use if a file can not be read as UTF-8.
Mutally exclusive to --encoding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 16:23</div>
            <div class="timeline-body"><p>Here are my thoughts:</p>
<ol>
<li>While I in principle am not opposed to some sort of &quot;smart&quot; encoding detection, it is not something that I want to maintain. It seems like something that will forever be buggy. If someone else wants to maintain a high quality crate for doing automatic encoding detection and can slide in as a <code>Read</code> adapter easily, then I might consider using it.</li>
<li>With the new <code>--pre</code> flag, it is actually now possible to do this via a user provided program.</li>
</ol>
<p>In light of that, I&#x27;m going to close this. Thanks for the thoughts though!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 16:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wontfix</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 16:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> removed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 16:23</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:05 UTC
    </footer>
</body>
</html>
