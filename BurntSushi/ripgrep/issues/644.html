<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Regexp expression failure when using lookbehind - BurntSushi/ripgrep #644</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Regexp expression failure when using lookbehind</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/644">#644</a>
        opened by <a href="https://github.com/scottchiefbaker">@scottchiefbaker</a>
        on 2017-10-20 17:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/scottchiefbaker">@scottchiefbaker</a></div>
            <div class="timeline-body"><p>I was attempting to find all the lines in my code that contain foobar, and were <strong>not</strong> commented out. The way I&#x27;ve done this with <code>ack</code> and <code>ag</code> in the past has been using lookbehinds:</p>
<pre><code>ack &#x27;(?&lt;!#)foobar&#x27;
ag &#x27;(?&lt;!#)foobar&#x27;
</code></pre>
<p>Attemping the same regexp in <code>rg</code> I get a parse error:</p>
<pre><code>:rg &#x27;(?&lt;!#)foobar&#x27;
Error parsing regex near &#x27;(?&lt;!#)f&#x27; at character offset 2: Unrecognized flag: &#x27;&lt;&#x27;. (Allowed flags: i, m, s, U, u, x.)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-10-20 17:27</div>
            <div class="timeline-body"><p>From the <a href="https://github.com/BurntSushi/ripgrep#why-shouldnt-i-use-ripgrep">README</a>:</p>
<blockquote>
<p><strong>ripgrep uses a regex engine based on finite automata, so if you want fancy regex features such as backreferences or look around, ripgrep won&#x27;t give them to you.</strong> ripgrep does support lots of things though, including, but not limited to: lazy quantification (e.g., a+?), repetitions (e.g., a{2,5}), begin/end assertions (e.g., ^\w+$), word boundaries (e.g., \bfoo\b), and support for Unicode categories (e.g., \p{Sc} to match currency symbols or \p{Lu} to match any uppercase letter). (Fancier regexes will never be supported.)</p>
</blockquote>
<p>From the output of <code>rg --help</code>:</p>
<blockquote>
<p>ripgrep&#x27;s regex engine uses finite automata and guarantees linear time
searching. Because of this, features like backreferences and arbitrary
lookaround are not supported.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-10-20 17:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-10-20 17:28</div>
            <div class="timeline-body"><p>You might consider <code>rg foobar | rg -v &#x27;^\s*#&#x27;</code> (or similar) instead.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:05 UTC
    </footer>
</body>
</html>
