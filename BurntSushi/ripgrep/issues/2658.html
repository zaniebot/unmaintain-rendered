<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`--line-regexp` no longer works with `--null-data` after upgrading to 14.0.1 - BurntSushi/ripgrep #2658</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>--line-regexp</code> no longer works with <code>--null-data</code> after upgrading to 14.0.1</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2658">#2658</a>
        opened by <a href="https://github.com/Frederick888">@Frederick888</a>
        on 2023-11-27 13:24
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Frederick888">@Frederick888</a></div>
            <div class="timeline-body">Please tick this box to confirm you have reviewed the above.
<ul>
<li>[X] I have a different issue.</li>
</ul>
What version of ripgrep are you using?
<p>ripgrep 14.0.1</p>
<p>features:-simd-accel,+pcre2
simd(compile):+SSE2,-SSSE3,-AVX2
simd(runtime):+SSE2,+SSSE3,+AVX2</p>
<p>PCRE2 10.42 is available (JIT is available)</p>
How did you install ripgrep?
<p>Arch Linux official repository.</p>
What operating system are you using ripgrep on?
<p>Arch Linux x86_64 (rolling)</p>
Describe your bug.
<p>Previously using ripgrep 13.0.0, when <code>--null-data</code> was given, ripgrep would basically treat NUL the same as an end of a line, and <code>--line-regexp</code> could be used to match a whole line.</p>
<p>After upgrading to 14.0.1, it no longer matches.</p>
What are the steps to reproduce the behavior?
<p><code>printf &#x27;%s\0&#x27; &#x27;foo&#x27; &#x27;bar&#x27; &#x27;hello&#x27; &#x27;world&#x27; | rg --null-data --line-regexp &#x27;foo&#x27;</code></p>
What is the actual behavior?
<p>It prints nothing to stdout using ripgrep 14.0.1.</p>
<pre><code>DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1093: using heuristics to determine whether to read from stdin or search ./ (is_readable_stdin=true, stdin_consumed=false, mode=Search(Standard))
DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1106: heuristic chose to search stdin
DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1254: found hostname for hyperlink configuration: FredArch
DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1264: hyperlink format: &quot;&quot;
DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 1 thread(s)
DEBUG|globset|crates/globset/src/lib.rs:448: glob converted to regex: Glob { glob: &quot;**/.DS_*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.DS_[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true, backslash_escape: true, empty_alternates: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;.&#x27;), Literal(&#x27;D&#x27;), Literal(&#x27;S&#x27;), Literal(&#x27;_&#x27;), ZeroOrMore]) }
DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 28 basenames, 2 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 1 regexes
DEBUG|grep_regex::config|crates/regex/src/config.rs:175: assembling HIR from 1 fixed string literals
DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
</code></pre>
What is the expected behavior?
<p>It prints <code>foo</code>, like 13.0.0 used to do. (I did not see relevant breaking changes in 14.0.0&#x27;s release announcement.)</p>
<hr>
<p>Ignoring some dependency patches, <code>git bisect</code> pointed me to 1035f6b1ff502eb5b1a5fc49a79f45971c772d47.</p>
<p>Bisect script used:</p>
<pre><code>#!/usr/bin/env bash

pushd &quot;~/Programming/Rust/ripgrep&quot; &gt;/dev/null

function cleanup() {
    git reset --hard
    popd &gt;/dev/null
}

trap &#x27;cleanup&#x27; EXIT

cat Cargo.toml | rg -v /home/andrew | sponge Cargo.toml

if ! cargo build; then
    exit 125
fi

if ! printf &#x27;%s\0&#x27; foo bar hello world | cargo run -- --line-regexp --null-data bar &gt;/dev/null; then
    exit 1
fi

exit 0
</code></pre>
<pre><code># bad: [cd5440fb6230f72ab598916c1c5ab96686541d47] changelog: fix wording
# good: [af6b6c543b224d348a8876f0c06245d9ea7929c5] 13.0.0
git bisect start &#x27;master&#x27; &#x27;13.0.0&#x27;
# bad: [c9584b035b19244e370a50fd872a3ae2039e2931] ci/release: use GitHub CLI
git bisect bad c9584b035b19244e370a50fd872a3ae2039e2931
# good: [7f23cd63a51d45415bb3df28d053562844194767] ignore/types: add automated test for sortedness
git bisect good 7f23cd63a51d45415bb3df28d053562844194767
# good: [335aa4937aed8f9c1bf3f5722e8fc4d671d46dcb] ignore/types: add *.pyi for Python
git bisect good 335aa4937aed8f9c1bf3f5722e8fc4d671d46dcb
# bad: [a68db3ac02fbfa2154cb2c8029c39e89d24c2792] deps: drop temporary patch and move to bstr 1.6
git bisect bad a68db3ac02fbfa2154cb2c8029c39e89d24c2792
# bad: [51480d57a67c229d624e5d1edb4aa3782e883696] regex: simplify AST analysis a bit
git bisect bad 51480d57a67c229d624e5d1edb4aa3782e883696
# good: [a7f1276021df2217dead1481b2c2b38595ed8fb3] readme: update Debian instructions
git bisect good a7f1276021df2217dead1481b2c2b38595ed8fb3
# bad: [e028ea37928930c80e5c3172d1df306b85a86758] regex: migrate grep-regex to regex-automata
git bisect bad e028ea37928930c80e5c3172d1df306b85a86758
# bad: [1035f6b1ff502eb5b1a5fc49a79f45971c772d47] deps: initial migration steps to regex 1.9
git bisect bad 1035f6b1ff502eb5b1a5fc49a79f45971c772d47
# first bad commit: [1035f6b1ff502eb5b1a5fc49a79f45971c772d47] deps: initial migration steps to regex 1.9
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-11-28 02:02</div>
            <div class="timeline-body"><p>Oh this is a nasty one. It turns out that ripgrep 13 was only working accidentally here. For example, I can make it fail:</p>
<pre><code>$ printf &#x27;%s\0&#x27; &#x27;bar&#x27; &#x27;hello&#x27; &#x27;world&#x27; | rg-13.0.0 --null-data --line-regexp &#x27;\w{3}&#x27;
$
</code></pre>
<p>And I can even make ripgrep 14 succeed with a sufficiently wacky regex:</p>
<pre><code>$ printf &#x27;%s\0&#x27; &#x27;foo&#x27; &#x27;bar&#x27; &#x27;hello&#x27; &#x27;world&#x27; | rg --null-data --line-regexp &#x27;[A-Z]*bar|[A-Y]*blahblah&#x27;
bar%
</code></pre>
<p>What is happening here are literal optimizations. When searching for <code>foo</code> with ripgrep 13, ripgrep builds a regex like <code>(?m:^)foo(?m:$)</code>, and because the old regex engine couldn&#x27;t handle literal optimizations involving line anchors, ripgrep plucked out <code>foo</code> as an inner literal and scanned for that first. Once it found a &quot;line&quot; containing <code>foo</code>, it <em>strips the line terminators</em> and then runs the full regex. Thus, it finds a match.</p>
<p>But in ripgrep 14, the regex engine is a lot more sophisticated and can handle the literal optimization on its own. So ripgrep backs off and let&#x27;s it do its thing. But of course, in this context, the regex engine is running on potentially many lines at once, and so the <code>(?m:^)</code> and <code>(?m:$)</code> really need to be able to match. By default, they only match <code>\n</code>. And thus, no match is found because NUL is used as a line terminator.</p>
<p>Thankfully, in the rewrite of the regex engine, I added a new <a href="https://docs.rs/regex-automata/latest/regex_automata/meta/struct.Config.html#method.line_terminator">config option to set the line terminator used by <code>(?m:^)</code> and <code>(?m:$)</code></a>. Indeed, I did it for <em>exactly</em> this use case. I just haven&#x27;t gotten around to making ripgrep use that option yet. Its handling of line terminators is pretty twisted and needs to be unfucked.</p>
<p>I think as a stop-gap, I&#x27;ll make ripgrep divert to the &quot;slower&quot; line-by-line search when <code>--null-data</code> is used. That will ensure correct operation at least.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rollup</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-11-28 02:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-11-28 02:17</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:13 UTC
    </footer>
</body>
</html>
