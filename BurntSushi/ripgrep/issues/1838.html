<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Byte pattern detection works inconsistently - BurntSushi/ripgrep #1838</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Byte pattern detection works inconsistently</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/1838">#1838</a>
        opened by <a href="https://github.com/bdlmt">@bdlmt</a>
        on 2021-03-31 01:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/bdlmt">@bdlmt</a></div>
            <div class="timeline-body"><h4>What version of ripgrep are you using?</h4>
<blockquote>
<p>ripgrep 12.1.1 (rev 7cb211378a)
-SIMD -AVX (compiled)
+SIMD +AVX (runtime)</p>
</blockquote>
<p>Initially, I found the bug while using 11.0.2:</p>
<blockquote>
<p>ripgrep 11.0.2
-SIMD -AVX (compiled)
+SIMD +AVX (runtime)</p>
</blockquote>
<h4>How did you install ripgrep?</h4>
<blockquote>
<p>sudo dpkg -i ./ripgrep_12.1.1_amd64.deb</p>
</blockquote>
<h4>What operating system are you using ripgrep on?</h4>
<p>Ubuntu 20.04.2 LTS</p>
<blockquote>
<p>Linux local 5.8.0-45-generic #51~20.04.1-Ubuntu SMP Tue Feb 23 13:46:31 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</p>
</blockquote>
<h4>Describe your bug.</h4>
<p>Using command line mode, escaping from Unicode mode in order to scan for bytes doesn't seem to work as documented.</p>
<h4>What are the steps to reproduce the behavior?</h4>
<p>Simple to reproduce. A scan of /usr/bin will suffice.</p>
<h4>What is the actual behavior?</h4>
<p>An rg scan of /usr/bin for ELF magic values returns 0 results, while there should be over 1000 matching files:</p>
<pre><code>user@local:~$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/
user@local:~$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/*
user@local:~$
</code></pre>
<p>Using the same byte pattern, a direct scan of individual files works as expected:</p>
<pre><code>user@local:~$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/ls
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/ed
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/file
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/find
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
</code></pre>
<p>Reducing the set of files scanned seems to change the results when using a filename wildcard, but not when just just specifying the directory:</p>
<pre><code>user@local:~$ mkdir test
user@local:~/test$ cd test
user@local:~/test$ cp /usr/bin/ls .
user@local:~/test$ cp /usr/bin/ed . 
user@local:~/test$ cp /usr/bin/file .
user@local:~/test$ cp /usr/bin/find .
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./*
Binary file ./ls matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./find matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./file matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./ed matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./ls 
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./ed
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./file 
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./find 
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
</code></pre>
<p>Removing the \x00 bytes from the tail of the pattern changes ripgrep's behavior, and seems to work as expected:</p>
<pre><code>user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin/ | wc -l
0
user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01' /usr/bin/ | wc -l
1092
</code></pre>
<p>Here are some debug outputs from the 4-file ~/test directory:</p>
<pre><code>user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./ --debug
DEBUG|grep_regex::literal|crates/regex/src/literal.rs:58: literal prefixes detected: Literals { lits: [Complete(ELF)], limit_size: 250, limit_class: 10 }
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
</code></pre>
<pre><code>user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01' ./* --debug
DEBUG|grep_regex::literal|crates/regex/src/literal.rs:58: literal prefixes detected: Literals { lits: [Complete(ELF)], limit_size: 250, limit_class: 10 }
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
Binary file ./ls matches (found &quot;\u{0}&quot; byte around offset 7)
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes

Binary file ./find matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./file matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./ed matches (found &quot;\u{0}&quot; byte around offset 7)
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
</code></pre>
<pre><code>user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01' ./ --debug
DEBUG|grep_regex::literal|crates/regex/src/literal.rs:58: literal prefixes detected: Literals { lits: [Complete(ELF)], limit_size: 250, limit_class: 10 }
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
Binary file ./ls matches (found &quot;\u{0}&quot; byte around offset 7)
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes

Binary file ./find matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./file matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ./ed matches (found &quot;\u{0}&quot; byte around offset 7)
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
</code></pre>
<pre><code>user@local:~/test$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01' ./ls --debug
DEBUG|grep_regex::literal|crates/regex/src/literal.rs:58: literal prefixes detected: Literals { lits: [Complete(ELF)], limit_size: 250, limit_class: 10 }
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
Binary file matches (found &quot;\u{0}&quot; byte around offset 7)
</code></pre>
<h4>What is the expected behavior?</h4>
<p>ripgrep should consistently match on files in a search path which contain a specified byte pattern, using the documented method.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-03-31 01:58</div>
            <div class="timeline-body"><p>Further test results, when copying all of /usr/bin into a local test directory.</p>
<p>Somehow, there are more pattern hits after a copy:</p>
<pre><code>user@local:~$ mkdir test2
user@local:~$ cd test2/
user@local:~/test2$ cp /usr/bin/* .
cp: -r not specified; omitting directory '/usr/bin/X11'
user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01' /usr/bin | wc -l
1092
user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01' | wc -l
1468
</code></pre>
<p>The full byte pattern search still doesn't match any files, unless individual files are targeted:</p>
<pre><code>user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' | wc -l
0
user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' ./ls | wc -l
1
</code></pre>
<p>And here's some more --debug output:</p>
<pre><code>user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' --debug
DEBUG|grep_regex::literal|crates/regex/src/literal.rs:58: literal prefixes detected: Literals { lits: [Complete(ELF)], limit_size: 250, limit_class: 10 }
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-03-31 02:16</div>
            <div class="timeline-body"><p>At first, I thought this might just be some confusion at how ripgrep handles binary files. The guide's section on binary data tries to explain the different modes. But since you are enabling binary mode via <code>-uuu</code> in all of your searches, that <em>should</em> cause things to behave consistently.</p>
<p>On mobile at the moment, but I suspect there may be a bug in how ripgrep is detecting and handling binary data specifically when a match occurs. I'll take a look when I'm back on my workstation.</p>
<p>Out of curiosity, do your results change if you add the <code>--no-mmap</code> flag? What about <code>--mmap</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-03-31 02:18</div>
            <div class="timeline-body"><p>(I believe there were changes in this area between the 11 and 12 releases, so please make sure you're doing all your testing with the latest release.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-03-31 04:45</div>
            <div class="timeline-body"><blockquote>
<p>(I believe there were changes in this area between the 11 and 12 releases, so please make sure you're doing all your testing with the latest release.)</p>
</blockquote>
<p>All reported test results have been with latest.
(I was using 11.0.2 initially, but replicated all results in 12.1.1 for the bug report.)</p>
<blockquote>
<p>At first, I thought this might just be some confusion at how ripgrep handles binary files. The guide's section on binary data tries to explain the different modes. But since you are enabling binary mode via <code>-uuu</code> in all of your searches, that <em>should</em> cause things to behave consistently.</p>
<p>On mobile at the moment, but I suspect there may be a bug in how ripgrep is detecting and handling binary data specifically when a match occurs. I'll take a look when I'm back on my workstation.</p>
<p>Out of curiosity, do your results change if you add the <code>--no-mmap</code> flag? What about <code>--mmap</code>?</p>
</blockquote>
<p>The issue seems unchanged by '--no-mmap':</p>
<pre><code>user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' --no-mmap | wc -l
0
</code></pre>
<p>But the results do change with '--mmap':</p>
<pre><code>user@local:~/test2$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' --mmap | wc -l
1447
</code></pre>
<p>1447 seems to be the correct number of matches for that directory.</p>
<p>I tested using '--mmap' with a much larger set of files as well, and again got the expected number of matches.
(Though, slower than I expected, but maybe that's a side effect of escaping out of Unicode mode to do byte searches with regex.)</p>
<p>Here's a debug run with '--mmap' over the test dir with only 4 files:</p>
<pre><code>$ rg -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' --mmap --debug
DEBUG|grep_regex::literal|crates/regex/src/literal.rs:58: literal prefixes detected: Literals { lits: [Complete(ELF)], limit_size: 250, limit_class: 10 }
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexesBinary file ls matches (found &quot;\u{0}&quot; byte around offset 7)


Binary file file matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file find matches (found &quot;\u{0}&quot; byte around offset 7)

Binary file ed matches (found &quot;\u{0}&quot; byte around offset 7)
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
DEBUG|globset|crates/globset/src/lib.rs:431: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-03-31 12:17</div>
            <div class="timeline-body"><blockquote>
<p>(Though, slower than I expected, but maybe that's a side effect of escaping out of Unicode mode to do byte searches with regex.)</p>
</blockquote>
<p>Yeah, forcing memory maps when searching a bunch of tiny files actually results in some pretty serious overhead that slows down the entire enterprise.</p>
<p>In any case, I am able to reproduce this on my own <code>/usr/bin</code> directory, so I'll investigate this as soon as I can. Thanks for the great bug report!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-03-31 15:33</div>
            <div class="timeline-body"><blockquote>
<p>In any case, I am able to reproduce this on my own <code>/usr/bin</code> directory, so I'll investigate this as soon as I can.</p>
</blockquote>
<p>If I were to attempt to investigate and fix the issue, where's your best guess to start looking?
I'm still new to Rust, but willing to dig in.</p>
<blockquote>
<p>Thanks for the great bug report!</p>
</blockquote>
<p>No problem; thank you for creating and maintaining a great project.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-03-31 16:36</div>
            <div class="timeline-body"><p>OK, so I took a look at this, and yeesh, this is actually behaving as <em>intended</em>. Which is kind of scary, because the UX here is just totally abysmal. This is a perfect storm, basically.</p>
<p>TL;DR - If you put <code>--no-mmap</code> in your ripgrep config file (or alias or whatever), then you'll get consistent behavior. For the specific case of searching for explicit binary data, you almost always want the <code>-a</code> flag. Otherwise, a <code>\x00</code> byte will never match anything, by construction.</p>
<p>So the top-level issue here is that binary detection/handling fundamentally works differently depending on whether memory maps are used or not.</p>
<p>The underlying motivation for binary handling is a desire for ripgrep to treat files as &quot;text.&quot; Of course, ripgrep, like any grep, can also search binary files. The main problem is that you generally don't want to <em>accidentally</em> print out results from a binary file because it can muck with your terminal via escape sequences and what not. On top of that, there is the issue that &quot;text&quot; files are typically line oriented where as binary data isn't. That means a single &quot;line&quot; in a binary data (typically a meaningless concept) can actually be quite large. Since ripgrep requires that each line be able to fit in memory, it uses a trick: it converts <code>\x00</code> bytes into line terminators in an effort to make binary data &quot;look&quot; like text. When this happens, the file is also marked as &quot;binary.&quot; If a match occurs, you get the &quot;match found but it's a binary file so we aren't going to print anything&quot; message.</p>
<p>Only looking at the above, we can explain why <code>rg -uuu 'foo\x00\x00'</code> finds nothing and why <code>rg -uuu 'foo'</code> finds something:</p>
<ul>
<li>The third <code>-u</code> flag is synonymous with <code>--binary</code>. This causes ripgrep to disable auto-filtering of binary data. The main UX concern here is that if no match is found, then one should be able to conclude that no matches exist.</li>
<li>Since the <code>-a/--text</code> flag is <em>not</em> enabled, ripgrep does not treat everything as if it were &quot;text.&quot; Instead, it tries to do binary detection. As stated above, this has a dual purpose: to prevent dumping arbitrary binary data to your terminal, but also to avoid using gratuitous amounts of memory for long lines in binary files. Thus, <strong>all <code>\x00</code> bytes in every file searched are rewritten to <code>\n</code> bytes</strong>. This is what explains why <code>foo\x00</code> won't match: <code>\x00</code> can never match because all such bytes are re-mapped to line terminators. But <code>foo</code> contains no NUL bytes, and thus can match.</li>
</ul>
<p>All of that behavior was lifted <em>exactly</em> from GNU grep. Including the NUL byte rewriting. However, GNU grep makes it much harder to search for NUL bytes. It doesn't recognize things like <code>\x00</code>, and inserting a NUL byte into a shell string is weird.</p>
<p>If that weren't confusing enough as it is, there's another catch here. When you search a single file directly, ripgrep will typically switch over to using memory maps to read the file since it tends to be faster in that case. The issue with memory maps is that we can't apply the above technique in the same way without destroying the performance benefit gained by using memory maps in the first place. In particular:</p>
<ol>
<li>We can't search the entire file for <code>\x00</code> without adverse consequences. e.g., In particularly big files, in the worst case, this could require reading the entire file twice. When it comes to memory maps, they aren't searched in blocks, but rather, as a single contiguous slice. Thus binary detection is itself different for memory maps.</li>
<li>When using memory maps, we never copy the data from the actual file just for searching. Therefore, there is no real opportunity to rewrite <code>\x00</code> bytes as line terminators, even if we could find all such <code>\x00</code> bytes.</li>
</ol>
<p>So, with memory maps, we do binary detection slightly differently:</p>
<ol>
<li>We look for a <code>\x00</code> byte in the first <code>N</code> bytes of a file.</li>
<li>When printing matches or contextual lines, we search only those specific lines for a <code>\x00</code> byte. In this way, we prevent dumping binary data to the terminal.</li>
</ol>
<p>Thus, when you search a file directly, you get matches because ripgrep is using memory maps for searching and thus doesn't rewrite <code>\x00</code> bytes as line terminators. So your pattern finds a hit.</p>
<p>So what could we do differently here? I don't think documentation is going to really help much here. It's such an oddball case. We could add to the relevant section on the guide with this particular case study. And in particular, we could say something like, &quot;add <code>--no-mmap</code> to your config file to make binary data handling consistent.&quot; The performance improvement from memory maps isn't <em>that</em> great, after all.</p>
<p>In terms of behavior changes, here are some things I can think of in no particular order. But I also include reasons why they problematic:</p>
<ol>
<li>We could force the <code>--no-mmap</code> strategy to have the same binary handling logic as the <code>--mmap</code> strategy. e.g., By only looking for binary data in the first N bytes and otherwise only searching matching lines. This would at least avoid dumping binary data to your terminal. However, this gives up on the heuristic for avoiding large heap usages due to long &quot;lines&quot; in binary data. Memory maps don't have this problem since the OS handles paging things in and out of memory transparently. Having the heap explode when searching binary data seems unfortunate.</li>
<li>We could get rid of memory maps entirely. The problem here is that they do have some nice perf benefits. They also enable <a href="https://github.com/BurntSushi/ripgrep/blob/master/FAQ.md#pcre2-slow">certain configurations to run very very fast</a> that wouldn't otherwise be possible without memory maps.</li>
<li>We could somehow force the memory map binary handling to match the non-memory map handling. The only way I can think to do this would be to chunk up the memory map, copy data from it and rewrite its bytes like we do in the non-mmap case. But this is adding a lot of extra costs to the memory map handling that we can safely ignore precisely because of the nature of memory maps.</li>
<li>We could forcefully disable the use of memory maps whenever <code>--binary</code> mode is enabled. But this is enabled by default when searching a specific file, so this would effectively shut off memory maps completely.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">doc</span> added by @BurntSushi on 2021-03-31 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2021-03-31 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-03-31 18:30</div>
            <div class="timeline-body"><p>Thank you for your detailed explanation!</p>
<blockquote>
<p>For the specific case of searching for explicit binary data, you almost always want the -a flag. Otherwise, a \x00 byte will never match anything, by construction.</p>
</blockquote>
<p>Aha! I missed that in the docs.</p>
<blockquote>
<p>That means a single &quot;line&quot; in a binary data (typically a meaningless concept) can actually be quite large. Since ripgrep requires that each line be able to fit in memory, it uses a trick: it converts \x00 bytes into line terminators in an effort to make binary data &quot;look&quot; like text.</p>
</blockquote>
<p>Okay, got it.</p>
<blockquote>
<p>The third -u flag is synonymous with --binary.</p>
</blockquote>
<p>After reading through your response and the man page, I'm not able to rectify this behavior:</p>
<pre><code>user@local:~$ rg -a --binary '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin | wc -l
0
user@local:~$ rg -a -uuu '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin | wc -l
1081
user@local:~$ rg -a --binary --mmap '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin | wc -l
1080
user@local:~$ rg -a -uuu --mmap '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin | wc -l
1081
user@local:~$ rg -a --binary --no-mmap '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin | wc -l
0
user@local:~$ rg -a -uuu --no-mmap '(?-u)\x7f\x45\x4c\x46\x02\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00' /usr/bin | wc -l
1081
</code></pre>
<p><code>-uuu</code> and <code>--binary</code> seem to have different behavior when combined with <code>-a</code>, <code>--mmap</code>, and <code>--no-mmap</code>.</p>
<p>Assuming I understand your explanation correctly, the <code>-uuu</code> cases are behaving as expected, while the <code>--binary</code> cases don't seem to be.</p>
<p>(Edit: rearranged the test cases to make more sense side-by-side.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-03-31 19:21</div>
            <div class="timeline-body"><blockquote>
<p>In terms of behavior changes, here are some things I can think of in no particular order. But I also include reasons why they problematic:</p>
<ol>
<li>We could force the --no-mmap strategy to have the same binary handling logic as the --mmap strategy. e.g., By only looking for binary data in the first N bytes and otherwise only searching matching lines. This would at least avoid dumping binary data to your terminal. However, this gives up on the heuristic for avoiding large heap usages due to long &quot;lines&quot; in binary data. Memory maps don't have this problem since the OS handles paging things in and out of memory transparently. Having the heap explode when searching binary data seems unfortunate.</li>
<li>We could get rid of memory maps entirely. The problem here is that they do have some nice perf benefits. They also enable certain configurations to run very very fast that wouldn't otherwise be possible without memory maps.</li>
<li>We could somehow force the memory map binary handling to match the non-memory map handling. The only way I can think to do this would be to chunk up the memory map, copy data from it and rewrite its bytes like we do in the non-mmap case. But this is adding a lot of extra costs to the memory map handling that we can safely ignore precisely because of the nature of memory maps.</li>
<li>We could forcefully disable the use of memory maps whenever --binary mode is enabled. But this is enabled by default when searching a specific file, so this would effectively shut off memory maps completely.</li>
</ol>
</blockquote>
<p>Would it make sense to have this as an option as well?
5. Use memory map mode whenever --binary mode is enabled. Treat a binary file as a long line and let the OS handle paging. No \x00 replacement overhead would be required, and the heap wouldn't explode on large binaries.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-03-31 19:36</div>
            <div class="timeline-body"><p>@bdlmt The <code>-a/--text</code> and <code>--binary</code> flag are mutually exclusive things. They actually override each other. So <code>-a --binary</code> enables binary searching while <code>--binary -a</code> makes everything searched as if it were text. Of course, the former is equivalent to <code>--binary</code> without <code>-a</code> and the latter is equivalent to <code>-a</code> without <code>--binary</code>.</p>
<blockquote>
<ol start="5">
<li>Use memory map mode whenever --binary mode is enabled. Treat a binary file as a long line and let the OS handle paging. No <code>\x00</code> replacement overhead would be required, and the heap wouldn't explode on large binaries.</li>
</ol>
</blockquote>
<p>It wouldn't. Aside from the downside of this seriously regressing performance when <code>--binary</code> is enabled, it's also just plain impossible. Memory maps can only be used in a subset of cases. They can't be used on streams and certain files (like <code>/proc/cpuinfo</code>) can't be memory mapped. If it was just a matter of performance regressing, then it would make sense to list it for completeness. But it's actually impossible. Standard <code>read</code> syscalls are the only universal way to search data.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-03-31 19:58</div>
            <div class="timeline-body"><blockquote>
<p>The <code>-a/--text</code> and <code>--binary</code> flag are mutually exclusive things. They actually override each other. So <code>-a --binary</code> enables binary searching while <code>--binary -a</code> makes everything searched as if it were text. Of course, the former is equivalent to <code>--binary</code> without <code>-a</code> and the latter is equivalent to <code>-a</code> without <code>--binary</code>.</p>
</blockquote>
<p>I see now. I read the man page incorrectly. I misunderstood this line under <code>--binary</code>:</p>
<pre><code>This flag can be disabled with --no-binary. It overrides the -a/--text flag.
</code></pre>
<p>I thought &quot;It&quot; referred to <code>--no-binary</code>, not <code>--binary</code>. I should have realized I had it wrong, based on the intended nature of <code>-a/--text</code> and <code>--binary</code>.</p>
<blockquote>
<p>They can't be used on streams and certain files (like /proc/cpuinfo) can't be memory mapped.</p>
</blockquote>
<p>Good point; I wasn't thinking far enough outside my recent use case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bdlmt">@bdlmt</a> on 2021-04-01 18:48</div>
            <div class="timeline-body"><blockquote>
<ol>
<li>We could force the --no-mmap strategy to have the same binary handling logic as the --mmap strategy. e.g., By only looking for binary data in the first N bytes and otherwise only searching matching lines. This would at least avoid dumping binary data to your terminal. However, this gives up on the heuristic for avoiding large heap usages due to long &quot;lines&quot; in binary data. Memory maps don't have this problem since the OS handles paging things in and out of memory transparently. Having the heap explode when searching binary data seems unfortunate.</li>
</ol>
</blockquote>
<p>From a UX point of view, behavior change option <strong>1</strong> seems best. Mixing <code>-a/--text</code> with <code>-uuu</code> to enable text mode during a binary search in order to successfully match on raw <code>\x00</code> bytes is a bit awkward and not intuitive. The change would also address the unexpected disparity between using <code>-a/--text</code> with <code>--binary</code> (mutually exclusive) vs. using <code>-a/--text</code> with <code>-uuu</code> (text mode enabled on binaries), because <code>-a/--text</code> would no longer be necessary when matching on <code>\x00</code> bytes.</p>
<p>From a performance point of view, it seems like leaving it as-is would be best, unless there's a way to split a binary file into multiple &quot;lines&quot; without replacing bytes.</p>
<p>As a user, I like the sound of improving the UX, but obviously not if there's a significant performance hit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rollup</span> added by @BurntSushi on 2023-11-25 15:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2023-11-25 20:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:20 UTC
    </footer>
</body>
</html>
