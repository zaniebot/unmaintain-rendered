<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Get number of matched entries for each directory - BurntSushi/ripgrep #216</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Get number of matched entries for each directory</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/216">#216</a>
        opened by <a href="https://github.com/jacwah">@jacwah</a>
        on 2016-11-03 13:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jacwah">@jacwah</a></div>
            <div class="timeline-body"><p>I'm creating a <code>tree</code>-like utility (https://github.com/jacwah/ntree) and the <code>ignore</code> crate seems really useful for implementing it. There is however an issue: to render the tree, the program needs to know the number of matched entries in each directory, or at least somehow query <code>Walk</code> for each entry to see if there are more entries left in the same directory.</p>
<p>Pseudocode examples below to illustrate what I mean:</p>
<pre><code>for entry in walk {
    if entry.is_dir() {
        process_dir(entry.path(), entry.get_num_entries());
    }
    // ...
}

for entry in walk {
    process_entry(entry.path(), entry.parent_has_more_entries();
}

for entry in walk {
    process_entry(entry.path(), entry.peek_next_sibling().is_some();
}
</code></pre>
<p>Is there currently a way to do this with the <code>ignore</code> crate I've missed? If not, are you willing to include such a feature? I'm available for discussion and implementation work :)</p>
<p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-03 14:19</div>
            <div class="timeline-body"><p>Thanks for reaching out! My first reaction is: why do you need to know the number of matched entries in each directory? (It isn't obvious to me from looking at the output of <code>tree</code>, but perhaps I am missing something!)</p>
<p>Assuming you do in fact need it...</p>
<p>I think we should simplify the problem first. Irrespective of the <code>ignore</code> crate, can you achieve what you want using the <code>walkdir</code> crate? I kind of suspect not, since <code>walkdir</code> does a <em>depth first</em> traversal of the directory tree as opposed to breadth first. This is pretty important, because it means your resource (memory + file descriptors) use scales with the depth of the tree. In a breadth first traversal, you need to keep around a lot more state.</p>
<p>There's really no way to adapt a depth first search to a breadth first search without making sacrifices like &quot;store the entire tree in memory.&quot; So I think you're kind of hosed in that regard.</p>
<p>I think the only path forward here is to implement a new breadth first recursive iterator, which would have to live in this crate, since you'll really want to make use of internal APIs like the one found in <code>ignore/src/dir.rs</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jacwah">@jacwah</a> on 2016-11-03 14:49</div>
            <div class="timeline-body"><p>Thanks for answering so quickly!</p>
<p>Take a look at this output:</p>
<pre><code>.
├── a
├── b
│   ├── 1
│   ├── 2
│   └── 3
├── c
└── d
</code></pre>
<p>To render the lines of the contents of <code>b</code>, the program needs to know that there are in fact more entries of <code>.</code> to come to continue drawing the leftmost vertical line.</p>
<p>Thanks also for the primer on depth first vs breadth first! I'll be sure to poke around the source to see whether me getting something working is feasible or not. Is ok if I contact you with further questions here? (or maybe through some other medium if you prefer)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-03 14:58</div>
            <div class="timeline-body"><p>If you can deal with only needing to look at whether there is a &quot;next&quot; element or not, then you should be able to use a peekable iterator, no? You can turn any iterator into a <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.peekable"><code>peekable</code></a> iterator. The next element should also give you the <em>depth</em> of the entry, which I imagine might be useful too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-03 15:08</div>
            <div class="timeline-body"><p>Oh, and yes, asking more questions here is encouraged. Please do!</p>
<p>You can also find me on most of the Rust IRC channels with the same <code>burntsushi</code> handle. However, I don't log on to IRC during work. Prime time for me tends to be 4-9PM EST and potentially large chunks of time on the weekend, but that can vary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-03 15:15</div>
            <div class="timeline-body"><p>With <code>peekable</code>, you can look at the next entry, and if one exists and its depth is less than the current entry, then you know you can use a <code>terminal_line</code> instead of a <code>branched_line</code>. Does that sound right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jacwah">@jacwah</a> on 2016-11-03 16:01</div>
            <div class="timeline-body"><p>Just peeking the next entry is not enough. Consider the following output:</p>
<pre><code>.
├── a
├── b
│   ├── 1
│   ├── 2
│   └── 3
├── c
└── d
    ├── 1
    ├── 2
    └── 3
</code></pre>
<p>To know whether to terminate the line from <code>.</code> at <code>d</code> or not, the program has to peek at the (optional) next sibling, not just the next element.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-03 16:13</div>
            <div class="timeline-body"><p>Ah, I see. Then I think you're forced to use breadth first search unfortunately. (Or build an alternative depth first search that does the right amount of peeking you need.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2016-11-03 20:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-19 14:32</div>
            <div class="timeline-body"><p>@jacwah I'm going to close this because I'm not sure there's anything actionable here and I personally don't have the bandwidth to support this use case. I might be amenable to maintaining one. If you'd like to discuss an implementation plan, feel free to open a new issue (or just comment in this one and we can re-open it). Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2016-11-19 14:32</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:41:52 UTC
    </footer>
</body>
</html>
