<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preprocessing source files before searching - BurntSushi/ripgrep #686</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Preprocessing source files before searching</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/686">#686</a>
        opened by <a href="https://github.com/ghost">@ghost</a>
        on 2017-11-17 23:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ghost">@ghost</a></div>
            <div class="timeline-body"><p>I think that it would be useful to be able to preprocess source files, and search the preprocessed output.</p>
<p>The exact nature of preprocessing would depend on the language. In Java, for example, Unicode escape sequences in source code are translated to the corresponding Unicode characters (see §3.2 Lexical Translations of the Java Language Specification); thus, the following is a valid Java compilation unit:</p>
<pre><code class="language-java">public class UnicodeEscapesTest {\u000a public static void main(String[] args) {
System.out.println\u0028\u0022Hello\u002c world!\u0022\u0029;
} }
</code></pre>
<p>For C and C++, it could be useful to allow full preprocessing to be performed, although this might be rather complicated to support because there would need to be a way to specify the preprocessing binary to use, preprocessor options, and ideally parse the line number information emitted by the preprocessor so that the correct source file line numbers are printed by ripgrep.</p>
<p>As a lighter option to full preprocessing, one possible preprocessing operation would be merging of string literals. C and C++ compilers will merge adjacent string literals into one (e.g. <code>&quot;abc&quot; &quot;def&quot;</code> is translated to <code>&quot;abcdef&quot;</code>). Java's compiler evaluates String-type constant expressions.</p>
<p><strong>EDIT</strong> In a way, this is related to #225 Support decompression on the fly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-18 02:25</div>
            <div class="timeline-body"><p>Sorry, but I have no idea what you're suggesting here. Could you show a simple example with input and output corresponding to the preprocessing you want?</p>
<p>Please consider showing motivating examples. Corner cases of language specifications aren't convincing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ghost">@ghost</a> on 2017-11-18 19:26</div>
            <div class="timeline-body"><p>I opened this enhancement request for searching within Java files in particular, although I anticipate that this could be highly useful for C and C++ source code as well, given that the preprocessor can drastically affect how source code expands to the actually-compiled code.</p>
<p>Suppose that I wanted to find the text &quot;Hello, world!&quot; within Java source files. This might be represented as the sequence of literal Unicode characters &quot;Hello, world!&quot;, as with:</p>
<pre><code class="language-java">public class UnicodeEscapesTest { public static void main(String[] args) {
System.out.println(&quot;Hello, world!&quot;);
} }
</code></pre>
<p>Or, because of the ability to use Unicode escape sequences, it can be &quot;obfuscated&quot;. For example, <code>\u002c</code> represents the comma character, as does <code>\u002C</code>. Reading the Java 9 Language Spec this morning, I found out that one can even use arbitrarily many 'u's, as in <code>\uuuuuuu002c</code>:</p>
<pre><code class="language-java">public class UnicodeEscapesTest { public static void main(String[] args) {
System.out.println(&quot;Hello\uuuuuuuuu002c world!&quot;);
} }
</code></pre>
<p>So, in order to not miss finding the occurrence of &quot;Hello, world!&quot; in the above file, I would need to adjust the regexp to allow the equivalent Unicode escape sequence for each character:</p>
<pre>
rg -tjava '(H|\\u+0048)(e|\\u+0065)(l|\\u+006[Cc])(l|\\u+006[Cc])(o|\\u+006[Ff])(,|\\u+002[Cc])( |\\u+0020)(w|\\u+0077)(o|\\u+006[Ff])(r|\\u0072)(l|\\u+006[Cc])(d|\\u+0064)(!|\\u+0021)'
</pre>

<p>Searching for &quot;Hello, world!&quot; case insensitively would be a bit more challenging.</p>
<p>Note that the Unicode escape sequence translation is not limited to string literals; Unicode escape sequences can be utilized in any part of the source file.</p>
<p>If ripgrep could preprocess Unicode escape sequences by replacing them with the corresponding character(s), then it would eliminate the pitfall of not finding an actual occurrence of a regexp match just because the match was obfuscated via Unicode escape sequences. Such obfuscation is not necessarily malicious; I once used this feature of the Java language to work around a limitation of some software that I was using.</p>
<p>To give an example of searching through C code, suppose one encounters a multiple definition linker error for a symbol <code>IMPL_someFunction</code> and one wants to know where this function is actually defined. It might be that a macro invocation is used that expands to that identifier, making the task of finding the definitions of this symbol more difficult.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-18 20:43</div>
            <div class="timeline-body"><p>Thanks for elaborating, but I consider this feature request <em>well</em> out of scope for ripgrep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2017-11-18 20:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wontfix</span> added by @BurntSushi on 2017-11-18 20:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2017-11-18 20:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @BurntSushi on 2017-11-18 20:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/agguser">@agguser</a> on 2018-06-14 08:09</div>
            <div class="timeline-body"><p>Is there any chance that <code>rg</code> will support pre-processing sources? This is for normalizing inputs, instead of creating a complex pattern to match, or generating all normalized sources first that take up disk space and will be out-of-sync if sources change.</p>
<p>Or is there a quicker version of <code>for f in **/*; do echo &quot;$f&quot;; sed … &quot;$f&quot; | rg …; done</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-14 11:16</div>
            <div class="timeline-body"><blockquote>
<p>Is there any chance that rg will support pre-processing sources?</p>
</blockquote>
<p>I don't see it happening, no.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:21 UTC
    </footer>
</body>
</html>
