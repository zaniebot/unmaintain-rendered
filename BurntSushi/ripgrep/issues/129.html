<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>maximum line length - BurntSushi/ripgrep #129</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>maximum line length</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/129">#129</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2016-09-28 17:47
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>I'd like <code>ripgrep</code> to have the ability to either hide or trim lines that are very long. Some lines take up my entire screen and are borderline useless to look at. It's possible that finding an intelligent way to shorten them would be best, since my guess is that the actual matched text is much smaller than the full line. However, this is harder to implement.</p>
<p>I don't think this should be enabled by default. It seems a little surprising for <code>ripgrep</code> to hide lines like that. In general, I like the work flow of, &quot;run a search, see huge lines, confirm that I don't care about them and run ripgrep again with an option to hide them.&quot; It may however be plausible to enable this limit if results are being dumped to a terminal (we already enable colors, line numbers and file headings).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @BurntSushi on 2016-09-28 17:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kaushalmodi">@kaushalmodi</a> on 2016-09-29 00:46</div>
            <div class="timeline-body"><p>A very good use case is searching in minified js/css.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-09-29 00:47</div>
            <div class="timeline-body"><p>@kaushalmodi Yup. I'm pretty sure that was precisely the thing I hit. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tjayrush">@tjayrush</a> on 2016-10-25 18:01</div>
            <div class="timeline-body"><p>I'd rather see a Linux-like approach to this. Pipe the file through something like 'tr' first, then pipe the output through 'cut'  Like this: cat file.js | sed 's/;/;\n/' | ripgrep whatever | cut -c1-100</p>
<p>edited: to correct command line to use sed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-25 18:07</div>
            <div class="timeline-body"><p>@tjayrush What is the purpose of <code>tr</code> there?</p>
<p>In any case, <code>rg</code> has the opportunity to show better output here, for example, by only showing the match and a few characters around it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tjayrush">@tjayrush</a> on 2016-10-25 18:56</div>
            <div class="timeline-body"><p>I meant for 'tr' to convert some character into new lines (I forgot to finish editing my comment) to alleviate the long line problem. If 'rg' can already limit to the context that's better.</p>
<p>The larger point was that instead of adding a new command line option, pipe the output (or input) into another already-existing command line program.</p>
<hr />
<p>Thomas Jay Rush
jrush@greathill.com</p>
<blockquote>
<p>On Oct 25, 2016, at 2:07 PM, Andrew Gallant notifications@github.com wrote:</p>
<p>@tjayrush What is the purpose of tr there?</p>
<p>In any case, rg has the opportunity to show better output here, for example, by only showing the match and a few characters around it.</p>
<p>—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub, or mute the thread.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-25 21:55</div>
            <div class="timeline-body"><p>I think my comment still stands.</p>
<p>Also, rg searches recursively by default. In that case, it doesn't make
sense to modify the input.</p>
<p>I don't think you need to argue in favor of piping. I'm all for it. But it
isn't always sufficient.</p>
<p>On Oct 25, 2016 2:56 PM, &quot;Thomas Jay Rush&quot; notifications@github.com wrote:</p>
<blockquote>
<p>I meant for 'tr' to convert some character into new lines (I forgot to
finish editing my comment) to alleviate the long line problem. If 'rg' can
already limit to the context that's better.</p>
<p>The larger point was that instead of adding a new command line option,
pipe the output (or input) into another already-existing command line
program.</p>
<hr />
<p>Thomas Jay Rush
jrush@greathill.com</p>
<blockquote>
<p>On Oct 25, 2016, at 2:07 PM, Andrew Gallant notifications@github.com
wrote:</p>
<p>@tjayrush What is the purpose of tr there?</p>
<p>In any case, rg has the opportunity to show better output here, for
example, by only showing the match and a few characters around it.</p>
<p>—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub, or mute the thread.</p>
</blockquote>
<p>—
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHub
https://github.com/BurntSushi/ripgrep/issues/129#issuecomment-256140440,
or mute the thread
https://github.com/notifications/unsubscribe-auth/AAb34iE21_xLvAOvcbGrT8TAZgCpsleNks5q3lDmgaJpZM4KJHLX
.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-19 15:05</div>
            <div class="timeline-body"><p>OK, in the interest of moving forward, here is a proposed specification.</p>
<p>Add a new flag, <code>-M/--max-columns NUM</code>, which is disabled by default. When enabled, lines with more than <code>NUM</code> columns are suppressed from output. Columns are counted as the number of bytes in a line.</p>
<hr />
<p>I mentioned above it might be cool to only show the context around each match (within a line), but I think that's a complicated feature that deserves its own issue/motivation/specification. I think the above flag solves the most pressing problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @BurntSushi on 2016-11-19 15:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hpsu">@hpsu</a> on 2016-11-22 09:31</div>
            <div class="timeline-body"><p>ag has
<code>-W --width NUM          Truncate match lines after NUM characters</code>
but yeah, I would really like this!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 15:52</div>
            <div class="timeline-body"><h2>Spec</h2>
<p>Make length of printed lines limit-able with conventional COLUMNS environment variable.
If the latter is not a parseable integer, query the tty or Console width.</p>
<p>Every output line should consist of a contiguous input.</p>
<p>Amount of context before first match on output line should be equal to that after last.
Add the <code>--min-context NUM</code> parameter which specifies minimal context length.</p>
<p>Print at least one match on every output line.
If contexts of a single match do not fit, decrease the min-context for them.
If a single match itself does not fit, drop its end.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-22 16:48</div>
            <div class="timeline-body"><blockquote>
<p>If the latter is not a parseable integer, query the tty or Console width.</p>
</blockquote>
<p>I would prefer to not add more code that does this to ripgrep. There's already too much of it and it has been a <em>terrible</em> pain to maintain. It's sucked up unbelievable amounts of time. Let's just use <code>COLUMNS</code> and/or a user-providable setting.</p>
<blockquote>
<p>Amount of context before first match on output line should be equal to that after last.
Add the --min-context NUM parameter which specifies minimal context length.</p>
</blockquote>
<p>How does this interact with character encodings? You can't just arbitrarily cut a byte sequence, since you may wind up cutting a UTF-8 sequence in half, for example. While the input isn't necessarily valid UTF-8, our output <em>better</em> be valid UTF-8 if the input is also valid UTF-8.</p>
<blockquote>
<p>Print at least one match on every output line.
If contexts of a single match do not fit, decrease the min-context for them.
If a single match itself does not fit, drop its end.</p>
</blockquote>
<p>How does this generalize to multiple matches on the same line?</p>
<p>What about lines emitted from <code>--context/--before-context/--after-context</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 16:58</div>
            <div class="timeline-body"><blockquote>
<p>Let's just use COLUMNS and/or a user-providable setting.</p>
</blockquote>
<p>But what can go wrong? Explicit setting is meant for editor plugins.</p>
<blockquote>
<p>How does this generalize to multiple matches on the same line?</p>
</blockquote>
<p>This paragraph only applies to the case of the single one (on the <em>output</em> line).</p>
<p>Lines from <code>--context</code> get trimmed at end.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-22 17:02</div>
            <div class="timeline-body"><blockquote>
<p>But what can go wrong?</p>
</blockquote>
<p>I spent my entire weekend dealing with tty stuff on Windows. I don't want to do it again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 17:03</div>
            <div class="timeline-body"><p>It's already been dealt with in mingw-w64, and isn't really rust/ripgrep issue as they do obey the tty api.</p>
<p>The tty fiddling (size/isatty) should be in a stable separate crate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-22 17:14</div>
            <div class="timeline-body"><p>@forgottenswitch ripgrep has to work with MSVC too.</p>
<p>I don't really feel like debating this much further. I'd like to leave it out for now. We can revisit it later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 17:26</div>
            <div class="timeline-body"><blockquote>
<p>How does this interact with character encodings?</p>
</blockquote>
<p>All printing is done in UTF-8 characters.
The font is assumed to be monospaced, i.e. not to have characters that take up fractional number of columns.
Each incorrect byte is assumed to take up 1 column.
Each character is assumed to take up 1 column, with the exception of Tab taking 8.
(as long as there is no <code>Char.len_in_glyphs</code>; some characters take 0, but ignore it).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-22 17:40</div>
            <div class="timeline-body"><p>Consider the following line where <code>foo</code> corresponds to the match:</p>
<pre><code>☃☃☃foo☃☃☃
</code></pre>
<p>Its UTF-8 encoding looks like this:</p>
<pre><code>\xe2\x98\x83\xe2\x98\x83\xe2\x98\x83foo\xe2\x98\x83\xe2\x98\x83\xe2\x98\x83
</code></pre>
<p>Now consider a <code>--min-context</code> of 2. Does <code>2</code> refer to Unicode codepoints? Or bytes? If bytes, you'd end up splitting the snowmen on either side of <code>foo</code>.</p>
<p>If <code>2</code> refers to Unicode codepoints, then I guess you also need to consider graphemes? Should we worry about that? And even if you figure all of that out, you have to realize that the input may not be valid UTF-8.</p>
<p>I see, OK, you updated your comment. You want the <code>2</code> to refer to Unicode codepoints, and you want each codepoint to be 1 column. I think that's OK, but we probably want to use the <a href="https://crates.io/crates/unicode-width"><code>unicode-width</code></a> crate to estimate the display columns of a single codepoint. <a href="https://unicode-rs.github.io/unicode-width/unicode_width/trait.UnicodeWidthStr.html">But it also works with <code>&amp;str</code>, which is nice.</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 17:51</div>
            <div class="timeline-body"><p>OK, will update the pull when done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-22 17:57</div>
            <div class="timeline-body"><p>Here are some thoughts that I would like you to consider:</p>
<ol>
<li>I still consider this an incredibly complex feature with lots of edge cases. Could you please write up the full spec in one comment so it's easy to follow? (Editing a prior comment is fine.)</li>
<li>Hacking it into the existing printer without a better abstraction is something I <em>don't</em> want to maintain.</li>
<li>The existing printer, in fact, isn't really something I want to maintain. I would like to refactor it and possibly move it to an external library. I would like you to consider holding off implementing this until then.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 18:15</div>
            <div class="timeline-body"><h2>Spec</h2>
<p>Make length of printed lines limit-able with conventional COLUMNS environment variable.</p>
<p>Every output line consist of a contiguous input.</p>
<p>Amount of context before the first match on output line should be equal to that after last.
Add the <code>--min-context NUM</code> parameter which specifies minimal context length on each side.</p>
<p>Print at least one match on every output line.
If only one match on this output line:</p>
<ul>
<li>if contexts do not fit, decrease the min-context for them</li>
<li>if the match itself does not fit, drop its end</li>
</ul>
<p>Lines from <code>--context</code> get trimmed at end.</p>
<p>All printing is done in UTF-8 characters.
The font is assumed to be monospaced, i.e. not to have characters that take up fractional number of columns.
Each incorrect byte is assumed to take up 1 column.
How many columns each character takes is determined with <code>unicode-width</code> crate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2016-11-22 18:18</div>
            <div class="timeline-body"><blockquote>
<p>Each incorrect byte is assumed to take up 1 column.
How many columns each character takes is determined with unicode-width crate.</p>
</blockquote>
<p>Unclear. Implementing should bring more light.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-06 14:33</div>
            <div class="timeline-body"><p>This would be extremely useful. I've just searched a directory which happened to include a few <code>.min.js</code> files - the output is basically useless.</p>
<p>I agree <code>COLUMNS</code> is the best way to do, preferably without a required switch so things &quot;just work&quot;.</p>
<p>A few suggestions:</p>
<ul>
<li>just truncate lines at <code>COLUMNS x 3</code> unless a <code>--no-truncate</code> flag is set</li>
<li>show <code>[2 matches found in line of length 12,345,678 characters]</code> instead of showing the line if the line is greater than <code>COLUMNS x 3</code>.</li>
<li>use <code>-uu</code> or <code>-uuu</code> flag. <code>*.min.js</code> or any file with only very long lines can basically be considered equivalent to binary (?), or at least they are in my head.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-06 17:31</div>
            <div class="timeline-body"><blockquote>
<p>I agree COLUMNS is the best way to do, preferably without a required switch so things &quot;just work&quot;.</p>
</blockquote>
<p>They don't show up in <code>env</code> output. Therefore at least <code>export COLUMNS</code> would be required in <code>.bashrc</code>. But they are only needed util there is a (reliable) <code>tty</code> crate.</p>
<p>Also, <code>--min-context</code> should probably be a fraction not to easily exceed COLUMNS/2.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-06 17:36</div>
            <div class="timeline-body"><p>COLUMNS works fine on linux:</p>
<pre><code>~ || echo &quot;number of columns: $COLUMNS&quot;
number of columns: 80
</code></pre>
<p>Is anyone serious really using another OS and trying to work in the terminal?</p>
<p>In 2017, I mean really?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-06 17:36</div>
            <div class="timeline-body"><pre><code>$ env | grep COL
$
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-06 17:40</div>
            <div class="timeline-body"><p>What OS is that?</p>
<p><code>env</code> doesn't work for me either, I need to either reference <code>COLUMNS</code> as above or use <code>printenv</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-06 17:42</div>
            <div class="timeline-body"><p>It is linux, and <code>man bash</code> does not say that <code>COLUMNS</code> are exported, only that it is &quot;set by the shell&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-06 17:43</div>
            <div class="timeline-body"><p>ye, i see the problem now, COLUMNS is available in the shell but not in a subprocess.</p>
<p><code>tty</code> is needed. My mistake, sorry.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-06 17:44</div>
            <div class="timeline-body"><p>But maybe <code>--columns</code> should still be there to change output width of <code>rg ... &gt; file</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-06 18:46</div>
            <div class="timeline-body"><blockquote>
<p>Is anyone serious really using another OS and trying to work in the terminal?</p>
</blockquote>
<blockquote>
<p>In 2017, I mean really?</p>
</blockquote>
<p>This issue tracker isn't the place to start an OS war. In particular, ripgrep has first class support for Windows, Mac and Linux. That isn't changing. Comments like &quot;In 2017, I mean really?&quot; aren't helpful.</p>
<p>We can add a <code>--columns NUM</code> flag that is disabled by default. If you want it on by default, then create an alias or wrapper script that sets it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-06 21:10</div>
            <div class="timeline-body"><p>sorry, OS comment was a joke really. the &quot;I mean really?&quot; was supposed to exaggerate the point and demonstrate I wasn't being serious. That was lost I guess.</p>
<p><code>--columns NUM</code> would be a good start.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-06 21:12</div>
            <div class="timeline-body"><p>@samuelcolvin Ah sorry about the misunderstanding! I missed that. Thanks for the clarification. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-07 15:22</div>
            <div class="timeline-body"><h4>Spec</h4>
<p>Make length of printed lines limit-able with <code>--columns NUM</code>.</p>
<p>Also add <code>--context-columns NUM[,NUM]</code>.
The amount is interpreted as mandatory width of match contexts.
Two amounts apply to left and rights contexts, respectively.</p>
<p>Default is <code>--context-columns 20</code>.
If a single match does not fit on the output line, the latter becomes
<code>&lt;left context&gt;&lt;match beginning&gt;[..]&lt;right context&gt;</code>.</p>
<p>At most <code>--truncate NUM</code> (3 by default) lines are printed per input line.
When there still are matches left, an <code>[N matches at this M characters line]</code>
pseudo-match, ignoring <code>--context-columns</code>, is printed (where M is a decimal-separated number of Unicode codepoints).</p>
<p>When <code>--truncated-is-binary</code> is given, a file whose line's matches exceed <code>--truncate</code> is considered binary.</p>
<p>In output, invalid codepoints are replaced with a space.
Width of graphemes is determined with the <code>unicode-width</code> crate.
The font is assumed to be monospaced, i.e. not to have characters that take up fractional number of columns.
Lines produced by <code>--context</code> are trimmed at the end.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-07 15:37</div>
            <div class="timeline-body"><p>I think i'd like to start with something simpler that just provides a maximum line length. Also &quot;context&quot; already has a meaning in ripgrep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-07 15:45</div>
            <div class="timeline-body"><p>simpler is definitely best IMHO.</p>
<p>The only suggestion I would make would be that with <code>--truncate NUM</code> <code>NUM</code> defaults to a large but reasonable number. eg. 300.</p>
<p>You could then set <code>--truncate 0</code> for infinite or <code>--truncate to 5000</code> for a much larger but finite number.</p>
<p>Eg. the limit is on by default. I know we can configure with aliases but I would guess very few users actually do that, best to have a sensible default.</p>
<p>As long has you have a clear ellipsis (perhaps in a different colour) the truncation will be clear.</p>
<p>I also think <code>--truncate</code> is clearer than <code>--max-columns</code> or <code>--columns</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-07 15:55</div>
            <div class="timeline-body"><p>Spec</p>
<p>Make length of output lines limit-able with <code>--truncate NUM</code>.
Fit from start of first match up to end of the last, with even context on both sides, as much as <code>--truncate</code> permits.
If fit is impossible, file is considered binary.
When binary files are still searched, <code>[N matches at this M characters line]</code> is printed.</p>
<p>In output, invalid codepoints are replaced with a space.
Width of graphemes is determined with the unicode-width crate.
The font is assumed to be monospaced, i.e. not to have characters that take up fractional number of columns.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-07 15:57</div>
            <div class="timeline-body"><p>We absolutely, positively, cannot make it the default. We <em>could</em> make it the default when ripgrep is emitting to a tty (like we've done for colors, line numbers and match groupings). We can't make it the true default because ripgrep (like grep) is useful for filtering data as well, and a tool that automatically drops lines just because they are too long does not sound good to me. I am still weary about making it the default even for just emitting to a tty. I worry that dropping data is a bridge too far. However, we've already kind of crossed that bridge by filtering corpora using <code>.gitignore</code> files.</p>
<p>I would be fine with using <code>--truncate</code> as the name. However, this does imply that some part of the line is still visible instead of being dropped completely, which I imagine is also useful. I'd like to only add a single flag for this.</p>
<p>Finally, when <code>--truncate</code> is given, does it specify bytes, Unicode codepoints or graphemes? There are performance <em>and</em> usability trade offs here. Simply hiding the lines is considerably simpler.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-07 15:59</div>
            <div class="timeline-body"><p>@forgottenswitch I would like to move away from &quot;fitting&quot; the lines. I think we should consider two options: simple truncation or complete hiding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-07 16:00</div>
            <div class="timeline-body"><p>I expected that as the simpler way, but isn't it the https://github.com/BurntSushi/ripgrep/issues/129#issuecomment-261718964 with columns counted as graphemes?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-07 16:03</div>
            <div class="timeline-body"><p>I would say truncation was preferable and &quot;columns&quot; in the terminal (whatever that translates to) would be best but, at least for me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-07 16:06</div>
            <div class="timeline-body"><p>@forgottenswitch I'm sorry, but I don't understand. <a href="https://github.com/BurntSushi/ripgrep/issues/129#issuecomment-271091507">This comment</a> mentions &quot;fitting&quot; the lines and looking at matches.</p>
<p>What I'm trying to say is this: if we can avoid writing a specification that needs to do something that is <em>encoding aware</em>, then this feature becomes much simpler. The <code>--max-columns</code> flag, which simply drops lines that are too long, achieves this because it uses the length of a line in bytes. The <code>--truncate NUM</code> flag, however, poses interesting difficulties. If <code>NUM</code> is bytes, then it's possible to naively emit invalid UTF-8 even when the input is completely valid UTF-8.</p>
<p>@samuelcolvin &quot;columns&quot; in the terminal is a visual thing. A single column can contain an <em>arbitrary</em> number of bytes because of combining characters in Unicode. Checking if every line satisfies this limit is <em>not</em> feasible because of the performance hit it requires.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-07 16:08</div>
            <div class="timeline-body"><p>The reason why I like having <code>--max-columns</code> disabled by default (even for emitting to tty) is that it makes <em>dropping</em> the lines a specifically user driven action. The <code>--truncate NUM</code> approach satisfies this by marking truncatation with ellipsis, but then you wind up with other problems described in my previous comment. We could add a short flag, <code>-M</code>, to make this a bit easier to apply iteratively.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-07 16:11</div>
            <div class="timeline-body"><p>I understand why don't want to apply it by default, fine with me.</p>
<p>For length, I guess just bytes is fine. The primary use case is just to make viewing easier where a line which shows 111 columns instead of 120 is no problem. I'm guessing 99% of ripgrep usage is on ascii code anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-07 16:13</div>
            <div class="timeline-body"><blockquote>
<p>I'm guessing 99% of ripgrep usage is on ascii code anyway.</p>
</blockquote>
<p>@samuelcolvin Possibly. I do track mentions of ripgrep on the Internet, and there seems to be quite a few mentions of it in otherwise Chinese, Russian and Japanese publications.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-07 16:16</div>
            <div class="timeline-body"><blockquote>
<p>The --truncate NUM flag, however, poses interesting difficulties. If NUM is bytes, then it's possible to naively emit invalid UTF-8 even when the input is completely valid UTF-8.</p>
</blockquote>
<p>Backtrack to beginning of the last character?
In UTF-8, it is &quot;backtrack to last non-10xxxxxx byte&quot;.</p>
<p>Also, <code>--truncate[-as-utf] NUM</code> (or <code>-MM</code>) for slow mode, considering graphemes.
But then again, -utf depends on unicode-width.</p>
<p>Fitting was to improve both readability and pager's scrolling of overly long lines
(dozens of screen lines, either from binary or minified/log files).
It probably doesn't matter at all because 1. terminal scroll could be used instead of pager 2. rg is for code search
It would have also be slow by requiring utf parsing.
If grapheme width determination was too slow, maybe a dedicated thread could have been tried.</p>
<p>Maybe ripgrep should just consider any file having a line longer than 256 bytes a binary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2017-01-07 16:19</div>
            <div class="timeline-body"><p>@forgottenswitch you seem determined to make this complicated. :-)</p>
<p>Surely best to start with the simplest and most obvious solution and make it more complicated when required.</p>
<p>utf8 counting would be nice but isn't required; anything else is surely excessive at this stage.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-08 04:18</div>
            <div class="timeline-body"><p>OK, I tried addressing different problem - printing matches even in huge lines, instead of omitting them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">libripgrep</span> added by @BurntSushi on 2017-01-11 03:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "libripgrep" by @BurntSushi on 2017-01-11 03:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-01-26 16:33</div>
            <div class="timeline-body"><p>Context before a match could be ellipsized, and total number of matches on a line limited.
<a href="https://github.com/BurntSushi/ripgrep/compare/master...forgottenswitch:hctx_compress">Implementation</a>, <a href="https://gist.github.com/forgottenswitch/a8575db29ca9c99633d582dca24c24a4">benchmark</a>.
Incorrect UTF-8 is handled by <code>String::to_utf8_lossy</code>-ing the context.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RalfJung">@RalfJung</a> on 2017-02-02 12:37</div>
            <div class="timeline-body"><p>I have to say I wouldn't find just dropping lines very useful; I still may want to know that these lines matched, but I also want to be able to see other matches. I hacked something quick-n-dirty together in <a href="https://github.com/RalfJung/ripgrep/tree/longlines">https://github.com/RalfJung/ripgrep/tree/longlines</a>, but I'm not proposing this as a solution to anything, I was just looking for an excuse to write some Rust code ;)</p>
<p>The simplest thing I can come up with that I'd actually like to use is something where we can set a <code>--max-width</code> or so, and if the line in bytes is longer than that, instead of printing the line, it prints how many matches were found in the line. So nothing would be entirely omitted. Would that be accepted? I'd be happy to give it a try.</p>
<p>Of course, something that actually ellipsizes long lines and prints them as &quot;... context match1 context ... context match2 context ...&quot; would be better, but then as you discussed above things quickly become really complicated because unicode.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-02-02 12:43</div>
            <div class="timeline-body"><blockquote>
<p>The simplest thing I can come up with that I'd actually like to use is something where we can set a --max-width or so, and if the line in bytes is longer than that, instead of printing the line, it prints how many matches were found in the line. So nothing would be entirely omitted. Would that be accepted? I'd be happy to give it a try.</p>
</blockquote>
<p>@RalfJung I think I like that idea. It would have to be disabled by default though (and perhaps enabled by default when emitting to a tty).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RalfJung">@RalfJung</a> on 2017-02-02 14:09</div>
            <div class="timeline-body"><p>All right, I prototyped this at <a href="https://github.com/RalfJung/ripgrep/commit/9618f87aefa8fc1ee821b4d3d7797a5542762f24">https://github.com/RalfJung/ripgrep/commit/9618f87aefa8fc1ee821b4d3d7797a5542762f24</a>. This is just about the behavior if the option is set (to 80), obviously; what remains to be done is adding the CLI argument, deciding about the default, and wiring the printer to that.</p>
<p>There are some open questions however already on this level:</p>
<ul>
<li>What to do in &quot;replace&quot; mode? Right now, the option would not affect that mode at all. I think this makes sense. Probably, in replace mode, you actually want to do something with that replaced text.</li>
<li>Dies ripgrep support any form of internationalization? I now plugged an English string right into there.</li>
<li>Bikeshedding about the way the message is displayed. ;)</li>
<li>How to write the newline after the message. I currently just call <code>write_eol</code>, but it seems like it could happen that <code>write_match</code> then calls <code>write_eol</code> again for the same line. What is the best way to avoid that? To avoid duplicate newlines, I could test the exact negative of what <code>write_match</code> tests when writing the &quot;stuff omitted&quot; message, but that sounds like an awful idea. I could move the check performed by <code>write_match</code> into <code>write_matched_line</code>, but that will lead to code duplication. So I guess the cleanest thing to do is to write a little function <code>write_eol_if_missing_from_buf</code> or so, that takes an <code>&amp;[u8]</code> and calls <code>write_eol</code> if that buffer does not end in a newline.</li>
<li>What to do with context lines? Should it just silently not write them (could lead to weird gaps, where some context line is printed and others are not), or print a message saying that a line has been omitted?</li>
</ul>
<p>EDIT: Slightly updated version at <a href="https://github.com/RalfJung/ripgrep/commit/50c07fc55a41100c9c10b1da57689428036029e6">https://github.com/RalfJung/ripgrep/commit/50c07fc55a41100c9c10b1da57689428036029e6</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forgottenswitch">@forgottenswitch</a> on 2017-02-02 15:39</div>
            <div class="timeline-body"><blockquote>
<p>Of course, something that actually ellipsizes long lines and prints them as &quot;... context match1 context ... context match2 context ...&quot; would be better, but then as you discussed above things quickly become really complicated because unicode.</p>
</blockquote>
<p>I posted implementation above; it does not seem to be so.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RalfJung">@RalfJung</a> on 2017-02-03 10:46</div>
            <div class="timeline-body"><p>Wow, impressive! That does look nice indeed. I somehow missed these links before, sorry.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-02-03 12:03</div>
            <div class="timeline-body"><p>I would like to avoid the contextual display. That should be a separate issue. I do not want to bring that code (if at all) until libripgrep is done. The code and the feature are too complex.</p>
<p>@RalfJung I don't have rock solid answers for your questions, but here's an attempt:</p>
<ul>
<li>If the <code>-r/--replace</code> flag is used, then ignoring <code>--max-width</code> doesn't seem quite right. I think it should still be applied to the <em>result</em> of the replacement.</li>
<li>ripgrep has no internationalization.</li>
<li>We can bikeshed in the PR.</li>
<li>I'm not sure about the eol writing. I'd have to look more closely.</li>
<li>For context lines, I think printing something like &quot;context line omitted because of --max-width&quot; is reasonable.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RalfJung">@RalfJung</a> on 2017-02-03 12:13</div>
            <div class="timeline-body"><blockquote>
<p>If the -r/--replace flag is used, then ignoring --max-width doesn't seem quite right. I think it should still be applied to the result of the replacement.</p>
</blockquote>
<p>So should it also still show the number of matches? That'd be extra work, unless there is a way I don't know about to get this from <code>re.replace_all</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-02-03 12:16</div>
            <div class="timeline-body"><p>@RalfJung <code>re.replace_all</code> accepts anything that satisfies the <code>regex::bytes::Replacer</code> trait (including <code>FnMut(&amp;Captures) -&gt; Vec&lt;u8&gt;</code> or your own type), which should enable you to both do the replacement and count the number of times it occurred.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RalfJung">@RalfJung</a> on 2017-02-11 17:58</div>
            <div class="timeline-body"><p>Right, I could use a closure or implement the trait for a custom type that also does the counting... but that will cost some performance, it seems, since we <em>want</em> to be called for every match and hence cannot use the <code>no_expansion</code> optimization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2017-03-13 01:21</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:41:45 UTC
    </footer>
</body>
</html>
