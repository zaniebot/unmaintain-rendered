<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allow following symlinks to files  - BurntSushi/ripgrep #2811</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Allow following symlinks to files</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2811">#2811</a>
        opened by <a href="https://github.com/smammy">@smammy</a>
        on 2024-05-17 18:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/smammy">@smammy</a></div>
            <div class="timeline-body"><p>I just got caught in the situation described in #460: ripgrep didn't find a file I knew existed, and it turned out that the file was actually a symlink to another file in the same directory.</p>
<p>In general, it seems to me that skipping symlinks to <em>directories</em> is a sensible default, but I'm not quite convinced that skipping symlinks to <em>files</em> is sensible. At least I'd like to be able to ask ripgrep to follow symlinks to files and search their contents <em>without</em> ripgrep also following symlinks to directories and recursing into them.</p>
<p>While following a symlink to a huge directory, or a directory on a network share, or to, say, <code>/proc</code> or <code>/sys</code> could cause all sorts of pathological behavior, following a symlink to a file only doubles the matches output for that file.</p>
<p>I propose an extension to the <code>--follow</code> switch to specify which target types should be processed via symlinks. It could be documented as follows:</p>
<pre><code>-L, --follow[=WHICH]
    By default, ripgrep only processes symlinks given
    as PATHs on the command line. This flag instructs
    ripgrep to also process symbolic links it
    encounters while traversing directories.
    
    Note that ripgrep will check for symbolic link loops
    and report errors if it finds one. ripgrep will also
    report errors for broken links. To suppress error
    messages, use the --no‚Äêmessages flag.
    
    WHICH can be `to-files' or `to-directories' to limit
    ripgrep to only processing symlinks that resolve to
    regular files or directories, respectively.
</code></pre>
<p>Thanks for considering this!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-05-26 16:19</div>
            <div class="timeline-body"><p>What does GNU grep do here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smammy">@smammy</a> on 2024-05-29 16:25</div>
            <div class="timeline-body"><p><code>grep -r</code> ignores all symlinks (other than those given on the command line), and <code>grep -R</code> dereferences all symlinks. If I wasn't accustomed to ripgrep, I'd probably use something like this:</p>
<pre><code class="language-bash">find haystack \! -xtype d -exec grep -H needle '{}' +
</code></pre>
<p>(But I'd prefer not to have to.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-09-23 02:05</div>
            <div class="timeline-body"><p>To clarify here, are you saying that GNU grep's behavior is the same as ripgrep's, but that you want ripgrep to offer a convenience for this?</p>
<p>I feel like while you might be right that following symlink files might be wise, there is potentially additional cost to this. And I think ripgrep's current semantic model around this is simpler to understand, which I think is valuable here.</p>
<p>Note that if you do use <code>-L</code>, you can also combine that with <code>.rgignore</code> to ignore directories you don't want to search.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2025-09-23 02:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smammy">@smammy</a> on 2025-10-04 16:45</div>
            <div class="timeline-body"><blockquote>
<p>To clarify here, are you saying that GNU grep's behavior is the same as ripgrep's, but that you want ripgrep to offer a convenience for this?</p>
</blockquote>
<p>Yes, exactly.</p>
<blockquote>
<p>I feel like while you might be right that following symlink files might be wise, there is potentially additional cost to this. And I think ripgrep's current semantic model around this is simpler to understand, which I think is valuable here.</p>
</blockquote>
<p>Yeah, that makes sense to me.</p>
<p>Thinking about this more, I think what I'm really after is <strong>an option to prevent ripgrep from visiting a file or directory more than once.</strong> It might encounter files multiple times via symlinks, leading to increased runtime and duplicate results. (I imagine preventing this would require keeping a list of e.g. visited inodes, and all threads would have to have access to it. Not a straightforward feature to implement!)</p>
<p>Having this option would allow me to turn <code>-L</code> on more readily, so that I don't miss results that are on the other side of a symlink, without the downsides. (Even without <code>-L</code> turned on, you can still end up with duplicate results if hardlinks are present, although I assume that's pretty rare in practice at this point.)</p>
<p>I will contemplate this and (maybe) open a new feature request at some point.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:49 UTC
    </footer>
</body>
</html>
