```yaml
number: 2116
title: "[globset] option to capture groups "
type: issue
state: closed
author: svark
labels: []
assignees: []
created_at: 2022-01-02T13:27:22Z
updated_at: 2022-01-04T14:38:22Z
url: https://github.com/BurntSushi/ripgrep/issues/2116
synced_at: 2026-01-12T16:13:24Z
```

# [globset] option to capture groups 

---

_@svark_

#### Option to capture groups in globset crate.
Currently, Glob::regex method does not capture groups that represent globs.
In some scenarios  it would be useful to access the individual captures within a path that matched a glob pattern.  
In this feature request we ask for an option to return a regex from Glob struct with captured groups.

 So for a glob pattern such as

`*.rs` we return `.*\.rs `or `[^/]*\.rs` from Glob::regex.
 
With the option to capture groups.
we could return 
 `(.*)\.rs `or `([^/]*)\.rs`

In general each glob could have a group in the regex.   This option would not change any functionality currently exposed in globset other than returning a regex with groups.



---

_Comment by @BurntSushi on 2022-01-03 13:08_

Sorry, but it's not clear to me what specific API additions you're requesting. Could you please write out the changes you want to make to the API? Ideally, any new routines would include documentation stating their contract.

---

_Comment by @svark on 2022-01-03 16:53_

I propose the following two changes

1)  New addition in GlobBuilder that sets an option:

```rust
pub fn GlobBuilder::capture_globs(&mut self, yes: bool) -> &mut GlobBuilder<'a>
```

When the option `capture_globs` is set to true,  the regex returned from `Glob` has capturing groups for each glob pattern.
By default this will be set to false.


2)  Change the implementation of the existing api
```rust
pub fn Glob::regex(&self) -> &str
```

to return a regex with capturing groups for each glob pattern when `GlobBuilder::capture_globs` is set to true.
The regex with captured groups can used to format results of matches or perform replacements. 

----










---

_Comment by @BurntSushi on 2022-01-03 16:55_

How is it determined where capture groups are placed?

---

_Comment by @svark on 2022-01-03 17:09_

We could wrap each  occurence of a glob pattern with a corresponding regex capturing group.
Any(`?`) pattern becomes `(.)` or `([^/])`
ZeroOrmore  becomes `(.*)` 
RecursivePrefix -> `(/?|.*/)` 
RecursiveSuffix -> `/(.?)` 
ClassRange -> `([xxxx])`
Alternates is already captured.


---

_Comment by @BurntSushi on 2022-01-03 17:14_

Could you show some code that you would write in order to make use of this new API? And ideally describe the use case at a high level. To be honest, I'm kind of confused at what you're trying to achieve here.

---

_Comment by @svark on 2022-01-04 04:56_

Hi Andrew, 

A simple example is what is done in build rules to build targets based on input selected using glob patterns.
So the input of a build rule selects some files using glob patterns. 
We apply a rule to produce outputs based on selecting portions (where globs occur) of the file.

This rule below is from [Tup  manual]( http://gittup.org/tup/manual.html) which is easy to read.
```
: foreach *_text.txt |> foo %f |> %g_binary.bin
```
`foreach *_text.txt` selects files based on glob pattern, and applies the `rule foo %f`  each file.  Files of the form `%g_binary` are generated by rule.  `%g` in the ouput indicates where expanded/substituted glob pattern appear in the output files
We could use %1g,%2g,.. etc to make different globs substitutions.


Here is some code that can accomplish this for existing files on filesystem. Walking down the directory we discover inputs files based on globs calling is_match to filter files. From the filtered_paths we then collect first group using the regex with capturing groups.  This would be used for substitution in %g.  

https://gist.github.com/svark/3d39be5f4da7c5a4e385d74be9072202



---

_Comment by @BurntSushi on 2022-01-04 14:29_

I see, okay, thank you for providing that.

So, in theory, I'm not opposed to this, but I have two concerns.

Firstly, I'm not sure that this library will always use regexes internally to do glob matching. So I'm hesitant to add further APIs that expose the current implementation. I realize that there is already an API that returns the regex though, and just because we have APIs that return the glob converted to a regex doesn't mean that the implementation has to actually use that regex. So I think I can look past this concern.

Secondly though, it kind of seems like this API is a little difficult to use. I hinted at this earlier by asking for a function contract, but specifically, it seems difficult to me to know where exactly capturing groups are inserted. I realize you provided a mapping, but this doesn't seem like an easy to understand API to me. More to the point, if we get it wrong in the first go-round, then changing the way capturing groups are inserted is likely to break existing uses of it in very subtle ways. And perhaps it's not even about getting it "wrong" per se, but rather, perhaps there are multiple reasonable mappings.

Overall, this seems like kind of a hazard to me. You might consider copying the glob parser out of this crate, and then also copying the regex generation code and modify it to fit your needs. It is actually a relatively small bit of what this crate does. _Most_ of the crate is about dealing with glob sets and optimizing the heck out of them. But since you're just using the regex, you are actually pulling in a large bit of code that you're not even using anyway.

---

_Comment by @svark on 2022-01-04 14:38_

Thank you, I understand your concerns. As you said this approach to mapping may not be exactly what users might need always. I will copy the relevant parsers to fit my needs.

---

_Closed by @svark on 2022-01-04 14:38_

---
