<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Globset uses inefficient hasher - BurntSushi/ripgrep #1717</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Globset uses inefficient hasher</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/1717">#1717</a>
        opened by <a href="https://github.com/tkaitchuck">@tkaitchuck</a>
        on 2020-10-28 04:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/tkaitchuck">@tkaitchuck</a></div>
            <div class="timeline-body"><p>Globset currently is using <code>fnv</code> hasher for a HashMap that is keyed with a <code>Vec&lt;u8&gt;</code>.
This is very inefficient because the <code>fnv</code> algorithm requires processing one byte at a time, and cannot be vectorized.
On <a href="https://github.com/tkaitchuck/aHash#speed">my benchmarks</a> anything over the 25-32 byte range it actually slower than the default sip-hash implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-10-28 06:31</div>
            <div class="timeline-body"><p>Your benchmarks are on hash functions, and not on globset. There is maybe a correlation between the performance of the hash function and the performance of globset matching, but it is far from clear. For example, I would bet that keys less than 25 bytes are actually quite common.</p>
<p>I think the next step here would be a globset benchmark. I'm pretty sure I used fnv originally because I noticed an improvement over the default, but that was a long time ago and wouldn't mind seeing it relitigated. But as it stands, this issue lacks actionable data.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2020-10-28 06:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tkaitchuck">@tkaitchuck</a> on 2020-10-31 07:19</div>
            <div class="timeline-body"><p>Looking at the benchmark code https://github.com/BurntSushi/ripgrep/blob/master/crates/globset/benches/bench.rs#L78
I notice two things:</p>
<ol>
<li>None of the inputs insert strings over 6 characters into the hashmap</li>
<li>The map is created and immediately thrown away, (IE there aren't many puts/gets per map creation).</li>
</ol>
<p>Are both of these realistic? If so the construction cost of the map will completely dominate and the actual hashing algorithm will matter little.
I just ran the benchmark <code>many_short_regex_set</code> (Are there any other relevant tests?) with all of the stdlib default sip-13, aHash, fnv, and fxHash, and the difference between them was within the (fairly large) noise from run to run. If you noticed a difference years ago it could have been before https://github.com/rust-lang/rust/pull/31356 which made a big difference in map construction time.</p>
<p>If the map really is only likely to be used for a single lookup it may be worth considering another data structure all together.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-01-05 14:41</div>
            <div class="timeline-body"><p>I don't think there is anything presently actionable here at the moment. There are likely many different avenues for improving performance in <code>globset</code>, and it should start with a holistic review.</p>
<blockquote>
<p>The map is created and immediately thrown away, (IE there aren't many puts/gets per map creation).</p>
</blockquote>
<p>As far as I can tell, this is not an accurate description of the benchmark. Here is the code as I see it:</p>
<pre><code class="language-rust">#[bench]
fn many_short_regex_set(b: &amp;mut test::Bencher) {
    let set = new_reglob_many(MANY_SHORT_GLOBS);
    b.iter(|| assert_eq!(2, set.matches(MANY_SHORT_SEARCH).iter().count()));
}
</code></pre>
<p>That creates a single <code>GlobSet</code> and then repeatedly benchmarks its search speed. That is, internally, a map is created and then queried many times.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2023-01-05 14:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:15 UTC
    </footer>
</body>
</html>
