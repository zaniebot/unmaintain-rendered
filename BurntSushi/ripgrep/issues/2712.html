<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>shard regexes when there are many and do multiple passes over the haystack - BurntSushi/ripgrep #2712</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>shard regexes when there are many and do multiple passes over the haystack</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2712">#2712</a>
        opened by <a href="https://github.com/kochbj">@kochbj</a>
        on 2024-01-11 23:34
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kochbj">@kochbj</a></div>
            <div class="timeline-body"><h4>Describe your feature request</h4>
<p>Huge ripgrep fan. Thanks for making such a great program. I don't know how hard this would be, but I often have files with 1000s of patterns. It's inconvenient that I have to use <code>split</code> to create separate files first and then run rg again in a loop. Could rg just split the patterns file itself and keep the shards in memory? No worries if this is an impractical idea!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-01-12 00:01</div>
            <div class="timeline-body"><p>I don't understand the request. Whether you shard them manually or not, they all get compiled into a single regex pattern by joining them with <code>|</code>. I think it would be better to avoid the XY problem and describe the real thing you're trying to do. This means including the command you're running, the inputs you're giving to it, the actual output and the expected/desired output. As Jerry Maguire says, <em><a href="https://www.youtube.com/watch?v=l1B1_jQnlFk">help me help you</a></em>.</p>
<p>Regex engines (with the exception of things like Hyperscan and other more niche engines) generally don't scale well to that many patterns. You're basically up shit's creek without a paddle. ripgrep's default regex engine is based on finite automata and so will generally do much better than a backtracker like PCRE2, but it has its limits. One special case here is if all your patterns are literals (which becomes true if you pass <code>-F</code>). In that case, ripgrep can do a little better by diverting to Aho-Corasick.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kochbj">@kochbj</a> on 2024-01-12 03:23</div>
            <div class="timeline-body"><p>Thanks for the quick reply, and the advice about <code>-F</code>; thats helpful.  I'm asking (or really just suggesting) a convenience wrapper for when the regex engine maxes out. If you do <code>-if</code> with a pattern file with 2M lines, it throws this error:</p>
<p><code>compiled regex exceeds size limit of 104857600</code></p>
<p>This could be avoided if rg just ran multiple loops through the data at max size chunks in the pattern file. I know this isn't normal grep behavior, but would be useful to me as an extra flag for -f. Here's a pattern file; it's fixed strings, but you can reproduce the behavior with <code>-i</code>.</p>
<p><a href="https://github.com/BurntSushi/ripgrep/files/13911174/rg_all_conferences_papers.inArxiv.citations.citingids.txt.zip">rg_all_conferences_papers.inArxiv.citations.citingids.txt.zip</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-01-14 14:50</div>
            <div class="timeline-body"><blockquote>
<p>This could be avoided if rg just ran multiple loops through the data at max size chunks in the pattern file.</p>
</blockquote>
<p>Ah yeah this isn't going to happen, sorry. To you it might look like one extra little flag, but to me it looks like completely reshuffling the internals. And it looks like a flag that begets more flags. This sort of thing is definitely something you'll want to build as a layer on top of ripgrep. Building something bespoke is much easier than targeting the general case.</p>
<blockquote>
<p>If you do <code>-if</code> with a pattern file with 2M lines, it throws this error:</p>
</blockquote>
<p>So for your data, while it contains 2 million patterns, it's actually less than half of that because of duplicates.</p>
<p>But right. As soon as you throw <code>-i/--ignore-case</code> in there, the regex engine has to get involved in order to implement case insensitive searching. Did you know that you can configure different size limits? The defaults are just there so that you don't accidentally consume a whole bunch of memory. But you can do, e.g., <code>--regex-size-limit 10G --dfa-size-limit 10G</code> and searching for your patterns will work, even with <code>-i/--ignore-case</code> enabled. It won't be the fastest thing in the world, but it works.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kochbj">@kochbj</a> on 2024-01-14 17:44</div>
            <div class="timeline-body"><p>Haha, I figured that's what you'd say. Fair enough. I did not notice the regex-size-limit flag. That's super useful! Anyways will close the issue. Thanks for the quick responses.</p>
<p>P.S. I meant to grab the uniq one, but it made the point. :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @kochbj on 2024-01-14 17:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2024-01-14 19:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Infinite file length for -f " to "shard regexes when there are many and do multiple passes over the haystack" by @BurntSushi on 2024-01-14 19:00</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:45 UTC
    </footer>
</body>
</html>
