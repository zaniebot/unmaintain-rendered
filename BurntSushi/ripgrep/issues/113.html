<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance comparison - BurntSushi/ripgrep #113</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Performance comparison</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/113">#113</a>
        opened by <a href="https://github.com/floyd-fuh">@floyd-fuh</a>
        on 2016-09-27 07:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/floyd-fuh">@floyd-fuh</a></div>
            <div class="timeline-body"><p>This is just a fyi with a couple of questions, feel free to close the issue if you think this doesn&#x27;t fit here.</p>
<p>I tried running the grep-it.sh script from my crass project with ripgrep:</p>
<p>https://github.com/floyd-fuh/crass/blob/master/grep-it.sh</p>
<p>But it doesn&#x27;t seem to be much faster on data that has only few matches:</p>
<p>https://github.com/floyd-fuh/crass/blob/123ac1adb81c3a2e05086824d2532ff4bed0ce7c/testing/ripgrep-test.txt</p>
<p>The regex are very specific and therefore there are usually only very few matches at all. I only used the &quot;time&quot; command for benchmarking but ripgrep wasn&#x27;t really that much faster. ripgrep failed to interprete two regex (one look ahead and one with the command line argument -o) and therefore even did two searches less than gnu grep. The biggest benefit was that ripgrep used 4 cores instead of only 1. As soons as I activated the BACKGROUND and switched MAX_PROCESSES to 4, gnu grep and ripgrep used roughly the same time, although in the BACKGROUND case the script only checks every 0.25 seconds (sleep 0.25) if a new subprocess with gnu grep can be scheduled.</p>
<p>It would be interesting to hear why you think it didn&#x27;t outperform gnu grep.</p>
<p>Currently I don&#x27;t think I&#x27;ll support ripgrep in the project, because a) it is not really faster in that usecase, b) it doesn&#x27;t support all the regex and c) has to be installed manually while gnu grep is usually already there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-09-27 13:00</div>
            <div class="timeline-body"><p>I&#x27;m not really sure how to analyze what you&#x27;ve given me. It&#x27;s not clear at all what you&#x27;re actually timing, what you&#x27;re searching or how to actually reproduce what you&#x27;ve done. I need at least that much to give you a meaningful response. If your benchmark is taking over 2 minutes to run, then I expect that to correspond to a <em>tremendous</em> amount of data or a ton of searches or both. Is that true? That&#x27;s a really important fact because if it is a tremendous amount of data, then you&#x27;re likely measuring disk I/O, not search speed.</p>
<blockquote>
<p>It would be interesting to hear why you think it didn&#x27;t outperform gnu grep.</p>
</blockquote>
<p>I couldn&#x27;t even possibly begin to answer that question. Did you by chance happen to <a href="http://blog.burntsushi.net/ripgrep/">read my blog post</a> on the topic? I get that it&#x27;s long, but that&#x27;s because <strong>benchmarks are hard</strong>. I need to understand much more precisely what you&#x27;re doing.</p>
<p>For example, if your corpus is a bunch of really really tiny files and your searches are simple literals, then I&#x27;d guess both programs are spending all their time in directory iteration, and will therefore have comparable times.</p>
<blockquote>
<p>it is not really faster in that usecase</p>
</blockquote>
<p><strong><code>ripgrep</code> isn&#x27;t faster than <code>grep</code> in every use case.</strong> For example, if you&#x27;re searching a bunch of files on disk that aren&#x27;t actually in memory, then <code>rg</code> and <code>grep</code> are likely going to perform similarly because the limiting factor is actually reading from disk. <code>rg</code>, in all likelihood, <em>can&#x27;t</em> be faster than <code>grep</code> in that case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-09-27 13:03</div>
            <div class="timeline-body"><blockquote>
<p>ripgrep failed to interprete two regex (one look ahead and one with the command line argument -o)</p>
</blockquote>
<p><code>ripgrep</code> is based on finite automata and therefore doesn&#x27;t support look around. <code>egrep</code> doesn&#x27;t either. Only <code>grep -P</code> does.</p>
<p>The <code>-o/--only-matching</code> flag is on the list of things to add. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/floyd-fuh">@floyd-fuh</a> on 2016-09-27 13:24</div>
            <div class="timeline-body"><p>I totally get that benchmarking is hard. I didn&#x27;t try to do benchmarking. That&#x27;s not a benchmark :) . It&#x27;s a single use case. And you are might be right, maybe I am just measuring disc speed (IO). The disc is an SSD. I didn&#x27;t think about what is actually the bottleneck, I just ran a comparison for my use case. Again I wasn&#x27;t trying to prove/disprove anything. I just ran a test and thought you might be interested. Yes I read your blog post. And the result of my tests was that it doesn&#x27;t matter what I use (gnu grep -P or ripgrep) for my project.</p>
<p>Yes, it&#x27;s a tremendous amount of data if you want to call it that (7 Android apps run through apktool and dex2jar and not cleaning up, therefore leaving everything in that folder such as zip files etc.).</p>
<p>I was just really surprised that the difference was so small. Unfortunately I can&#x27;t release my test data set. If you want you can do your own tests with grep-it.sh with some public data.</p>
<p>Maybe it&#x27;s helpful if you include in your blog post that disc IO could be a bottleneck rather then the grep software</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/floyd-fuh">@floyd-fuh</a> on 2016-09-27 13:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-09-27 13:30</div>
            <div class="timeline-body"><blockquote>
<p>I was just really surprised that the difference was so small.</p>
</blockquote>
<p>If you take a look at my benchmarks in my blog, you can see how the tools are much closer on some benchmarks but much farther apart on others. For example, on this one, a correct <code>grep</code> search takes over <strong>4 minutes</strong>, but <code>rg</code> only takes a few seconds: http://blog.burntsushi.net/ripgrep/#subtitles-no-literal --- But this is actually benchmarking the software itself, not the rate at which your disk can offer up data.</p>
<blockquote>
<p>Maybe it&#x27;s helpful if you include in your blog post that disc IO could be a bottleneck rather then the grep software</p>
</blockquote>
<p>I did. Read the methodology section. :-) Specifically:</p>
<blockquote>
<p>Every benchmarked command is run three times before being measured as a “warm up.” Specifically, this is to ensure that the corpora being searched is already in the operating system’s page cache. If we didn’t do this, we might end up benchmarking disk I/O, which is not only uninteresting for our purposes, but is probably not a common end user scenario. It’s more likely that you’ll be executing lots of searches against the same corpus (at least, I know I do).</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/victoriastuart">@victoriastuart</a> on 2017-01-27 19:01</div>
            <div class="timeline-body"><p>Hi: re benchmarking, I just ran some tests on my system [Arch Linux x86_64; note: SSD (~70+ times faster than my HDD; xfce4; ...]:</p>
<p>COMPARISON:</p>
<pre><code>$ pwd
    /home/victoria

$ ls 2&gt;/dev/null -laR | wc -l
    1951389    ## &lt;&lt; ~1.95M files</code></pre>
<ul>
<li>&quot;Static Build Tools:&quot;  is line 12 in /home/victoria/projects/shortcuts/ut-x</li>
<li>Compare grep vs rg (ripgrep)</li>
<li>~/.bashrc:<ul>
<li>alias grep=&#x27;grep 2&gt;/dev/null --color=always&#x27;</li>
<li>alias rg=&#x27;rg --color always&#x27;</li>
</ul>
</li>
</ul>
<p><strong>1. grep:</strong></p>
<pre><code>$ time grep -r . -e &quot;Static Build Tools:&quot;
    ./projects/shortcuts/ut-x:Static Build Tools:
    Command exited with non-zero status 2
    10:04.24</code></pre>
<ul>
<li><p>10 min 04 sec!!</p>
</li>
<li><p>Drilling down (to make grep search easier):</p>
<p>$ cd projects/</p>
</li>
<li><p>repeat search:</p>
<p>$ time grep -r . -e &quot;Static Build Tools:&quot;
./shortcuts/ut-x:Static Build Tools:
0:43.19</p>
</li>
<li><p>... 43 sec</p>
<p>$ cd shortcuts/
$ time grep -r . -e &quot;Static Build Tools:&quot;
./ut-x:Static Build Tools:
0:00.00</p>
<p>$ cd ~
$ pwd
/home/victoria</p>
</li>
</ul>
<p><strong>2. ripgrep (rg):</strong></p>
<pre><code>$ time rg . -e &quot;Static Build Tools:&quot;
    projects/shortcuts/ut-x
    12:Static Build Tools:
    1:22.83</code></pre>
<ul>
<li><p>1 min 23 sec (ripgrep), vs. 10 min 04 sec (grep)</p>
<p>$ cd projects/</p>
<p>$ time rg . -e &quot;Static Build Tools:&quot;
shortcuts/ut-x
12:Static Build Tools:
0:00.36</p>
</li>
<li><p>&lt;1 sec (rg) vs. 43 sec (grep)!</p>
<p>$ cd shortcuts/</p>
<p>$ time rg . -e &quot;Static Build Tools:&quot;
ut-x
12:Static Build Tools:
0:00.01    ## &lt;&lt; i.e. instantaneous! (faster than &#x27;time&#x27; can report, essentially!  ;-)</p>
</li>
<li><p>Q.E.D.! :-D</p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-27 20:12</div>
            <div class="timeline-body"><p>@victoriastuart Nice results. :-) I&#x27;m willing to bet you&#x27;ve got some big binary files in that directory that ripgrep is skipping but that grep isn&#x27;t. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/victoriastuart">@victoriastuart</a> on 2017-01-27 20:23</div>
            <div class="timeline-body"><p>lol, maybe/probably :-p</p>
<p>Those tests (just a quick &#x27;hack&#x27;) were done on a 500GB SSD (/home/...), that I use for my programming work (Python; ML; ...). There are a lot of data files, virtual environments, ... etc. on that fast SSD.</p>
<p>/ [root] is on another/dedicated (250 GB) SSD.</p>
<p>I keep GitHub repos, scripts, other stuff on a 5 TB HDD ... all backed up (rsync/rsnapshot: 4x daily) to another 5 TB HDD.</p>
<p>Anyway, &quot;as is&quot; ripgrep appears to be blazing fast;  I only became aware of it a couple of days ago, from this great article,</p>
<p>https://medium.com/@crashybang/supercharge-vim-with-fzf-and-ripgrep-d4661fc853d2#.57jipcwcw</p>
<p>... so I decided to check it out.  Nice work; thank you!!  :-D</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:01 UTC
    </footer>
</body>
</html>
