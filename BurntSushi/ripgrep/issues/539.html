<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>add decompression support on Unix systems - BurntSushi/ripgrep #539</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>add decompression support on Unix systems</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/539">#539</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2017-07-04 13:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>@wavexx <a href="https://github.com/BurntSushi/ripgrep/issues/225#issuecomment-312873930">Suggests farming out decompression to established stream decompressors</a>. I am somewhat attracted to this path since it will cover a lot of use cases, and at least on the face of things, seems relatively easy to implement. If this turns out to be a much larger project than I anticipated, then the trade off may no longer make sense. The intention is to support decompression on all supported platforms, so we don&#x27;t want to invest a bunch of work in a Unix-only option.</p>
<p>I&#x27;m not sure when I personally will have time to work on this, but as long as it&#x27;s easy to maintain, I&#x27;m not intrinsically opposed to farming this out to another process. Note that the core search code can work on <em>any</em> arbitrary thing that implements <a href="https://doc.rust-lang.org/std/io/trait.Read.html"><code>io::Read</code></a>, which means the glue code required for this should be pretty limited. There&#x27;s already an example of this at play for encoding support, where any supported encoding is first transcoded to UTF-8 before being searched. The scope of that addition was pretty much limited to <a href="https://github.com/BurntSushi/ripgrep/blob/master/src/decoder.rs">implementing <code>io::Read</code></a> and doesn&#x27;t require touching any of the core search code.</p>
<p>If someone else wanted to work on this, I&#x27;d be happy to mentor it. I haven&#x27;t thought about it too much, but I think these are probably the high level steps one needs to take:</p>
<ul>
<li>Come up with a way of detecting when a certain type of decompressor is needed. It&#x27;s probably sufficient to use the file extension as a first pass, although one should consider special cases like <code>.tar.gz</code> (probably by skipping them at first, but maybe eventually trying to read <code>tar</code> archives as well).</li>
<li>Implement glue code that takes as input a command that executes stream decompression on a specific file path and outputs an implementation of <code>io::Read</code> that is suitable to pass to the <code>io::Read</code> searcher.</li>
<li>Think about what a path forward looks like for replacing out-of-process decompression with in-process decompression. For example, if and when Rust gets a native gzip decompression library that is suitable for use (maybe it already is), then how could it be used to replace use of, say, the <code>gzip</code> command seamlessly? This will be important for eventually migrating to cross platform decompression support.</li>
<li>Give some thought to Windows support. It doesn&#x27;t actually seem like this is inherently Windows-incompatible, but may favor Unix systems by virtue of the tooling typically available in a Unix environment.</li>
<li>Initially ignore any and all decompression on <code>stdin</code>. Callers can invoke their own decompressor in this case easily enough that we shouldn&#x27;t do anything smart. (A future path might add a flag to force decompression of a specific format.)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-07-04 13:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-07-04 13:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/phiresky">@phiresky</a> on 2017-10-06 15:23</div>
            <div class="timeline-body"><blockquote>
<p>Note that the core search code can work on any arbitrary thing that implements io::Read, which means the glue code required for this should be pretty limited</p>
</blockquote>
<p>If that&#x27;s the case, it seems like it would be easy to implement an independent rust library which is able to transparently open compressed files as a io::Read using any method (streaming external tool via pipes, C FFI or native Rust library), without ripgrep itself actually caring about the method.</p>
<p>It still needs some thought though:</p>
<ol>
<li>Which format maps to which decompressor. I think there is always only one correct solution to decompressing a given file so this should not need to be configured. Might be good to use <a href="https://github.com/robo9k/rust-magic">magic</a> though to detect the file type for differing file endings (all the zip-derived formats like  jar, apk, docx, odt)</li>
<li>Buffering - gunzip et al. might buffer their output which looking at the man page cannot be configured</li>
<li>What about archives? io::Read only works cleanly when a single compressed stream maps to a single file</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-10-06 15:27</div>
            <div class="timeline-body"><p>We should probably punt on archives for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tailhook">@tailhook</a> on 2017-12-02 00:28</div>
            <div class="timeline-body"><p>What to do think about <a href="https://crates.io/crates/anycat">anycat</a> crate for the task?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-12-02 00:36</div>
            <div class="timeline-body"><p>@tailhook No, I don&#x27;t think so. That seems like a nifty little utility, but it doesn&#x27;t pull its weight as a library dependency. Also, that&#x27;s using C libraries, which I talked about in #225. This particular ticket is strictly for an implementation path that involves shelling out to existing utilities.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/balajisivaraman">@balajisivaraman</a> on 2018-01-02 18:51</div>
            <div class="timeline-body"><p>I had a quick glance at this and had the following thought. The standard library provides a <code>Command</code> implementation that lets us spawn child processes from the currently running process. It also handily lets us pipe from the process&#x27; <code>stdout</code>. And the <code>stdout</code> already has the <code>Read</code> trait implemented for it.</p>
<p>By using the above, I was able to get a very trivial solution for this problem by just doing the following.</p>
<pre><code>use std::process::Command;
use std::process::Stdio;
match Command::new(&quot;gunzip&quot;)
      .args(&amp;[&quot;-c&quot;, &quot;/home/balaji/Projects/rust/samples/test.gz&quot;])
      .stdout(Stdio::piped())
      .spawn() {
         Ok(cmd) =&gt; self.search(printer,path, cmd.stdout.unwrap()), //Note: This is calling the worker&#x27;s search method with the reader obtained from Pipe
         _ =&gt; Ok(0)
       }
</code></pre>
<p>I tested it out and it was able to spawn the process, do the unzipping and print the expected output to stdout.</p>
<p>@BurntSushi, My apologies if this looks like a very naive solution and not what you were looking for at all. The only reason I wanted to post that line of thought here is that I felt it achieved the intended purpose: Support decompression on unix systems at minimal cost to the maintainer for the time being.</p>
<p>Please let me know whether this is what you had in mind when you opened this ticket.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-02 18:58</div>
            <div class="timeline-body"><p>@balajisivaraman Woohoo! Yeah that is exactly what I had in mind. :) The trickier issues are thinking through the UX I think. I don&#x27;t have time to rethink it through all right now but I can rattle off some general principles:</p>
<ol>
<li>The absence of decompression commands should not cause ripgrep to fail. I do suspect a debug message would be appropriate.</li>
<li>If a decompression command runs but then fails, then ripgrep should probably emit an error message but other continue searching. (Similar to how it handles files that it doesn&#x27;t have permission to read.)</li>
<li>What, if any, CLI flags do we expose related to this feature? Perhaps it&#x27;s best to start by exposing none and simply recognize a hard-coded set of file extensions that we map to a particular kind of decompression command.</li>
<li>We likely need to be a touch smart about what we search. For example, it seems like we would want to search something like <code>titles.csv.gz</code> but perhaps not <code>ripgrep-0.7.1.tar.gz</code>, even though they both have <code>.gz</code> extensions. Perhaps anything with a <code>.tar.{foo}</code> extension is skipped by decompression? Not sure. (Keep in mind that ripgrep would currently ignore such things today because it&#x27;s likely to detect it as a binary file very quickly. But in this case, it&#x27;s not clear we want to do that after decompression since decompression itself could be quite costly.)</li>
</ol>
<p>There are maybe other things I&#x27;ve missed. :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/balajisivaraman">@balajisivaraman</a> on 2018-01-02 19:10</div>
            <div class="timeline-body"><p>Yay! :smiley:</p>
<p>Like you, I will also do some thinking on this and arrive at a cohesive list of things on how the UX should be by maybe tomorrow; adding to the ones you&#x27;ve already posted. Once that is finalised and agreed, I can actually take this up and start working on it, if that is OK with you. üëç</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-02 21:43</div>
            <div class="timeline-body"><p>@balajisivaraman Yeah that would be great! This would be a significant contribution. It&#x27;s a really nice feature to have in ripgrep.</p>
<p>When thinking through the UX, keep in mind that &quot;let&#x27;s punt&quot; is a totally valid answer. Keeping things simple and building on it later is a totally fine way to do things. The only downside here is that you need to be a little careful to leave yourself breathing room with respect to breaking changes. i.e., Adding a new flag for this and then removing that flag later is probably something we want to avoid (but adding no flags now and adding more flags later is OK!). (Not that I&#x27;m saying we should or shouldn&#x27;t add flags for this, it&#x27;s just an example.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/balajisivaraman">@balajisivaraman</a> on 2018-01-03 18:50</div>
            <div class="timeline-body"><p>Ok, I&#x27;ve thought about it a fair bit and here are my thoughts, partly summations of BurntSushi&#x27;s:</p>
<ul>
<li><p>Going forward, when <code>rg</code> encounters any file ending with <code>.bz2</code>, <code>.gz</code>, <code>.xz</code> or <code>.lzma</code>, it will automatically use the corresponding decompressors (<code>bunzip2</code>, <code>gunzip</code>, <code>unxz</code> or <code>unlzma</code>) to perform the decompression as a child process. It will then use the <code>Read</code> instance obtained from that process&#x27; <code>stdout</code> to perform the search. (Note: One advantage we get by doing it this way is that it doesn&#x27;t affect the existing UTF-16/32 transcoder, so if the archived file is encoded differently, we can still handle it.)</p>
<ul>
<li>If the expected binary itself is not available, <code>rg</code> will gracefully exit and output a corresponding error message to the user. (Note: The binary is expected to be on the user&#x27;s path and will <em>not</em> be fully qualified to a default location such as <code>/usr/bin</code> or <code>/usr/local/bin</code> for obvious reasons to account for varying install locations.)</li>
<li>If the executed command fails for any reason at all, then <code>rg</code> will fetch the error message from that process&#x27; <code>stderr</code>, display it, and continue searching the rest of the files.</li>
</ul>
</li>
<li><p>As of right now, <code>tar</code> archives will not be supported. If they are encountered, <code>rg</code> will fail gracefully letting the user know that it is currently unsupported, before doing any decompression. I feel this is better instead of continuing with the current method of skipping binary files. Users should probably be made aware of why their <code>.tar.gz</code> or <code>.tar.xz</code> files are not being processed by <code>rg</code>.</p>
</li>
<li><p>I&#x27;m currently in favour of exposing a CLI flag similar to what <code>ag</code> does with its <code>-z</code>/<code>--search-zip</code> flag. My thought is based mostly on my use-case where I have many compressed log files in the same location as the currently being written to log file. I would want <code>rg</code> to skip the compressed files by default unless I specifically ask it to search through multiple bulky log <code>.gz</code> files. (Also the fact that searching archives will be slower is another reason we may want to go for a CLI argument. If users find that searches in some directories are suddenly slower because we&#x27;re spawning a child process internally, they might be confused. By leaving it to the user&#x27;s choice, we don&#x27;t have this problem.)</p>
</li>
<li><p>My idea is to have the detection and decompression of files in a separate module so that it&#x27;ll be easier to change when Rust gets its own decompression libraries. (We have some WIPs already, with the most famous one being <a href="https://github.com/alexcrichton/flate2-rs/">flate</a> which does pull in C bindings, but there&#x27;s work being done on a <a href="https://crates.io/crates/miniz_oxide">pure-Rust</a> lib.) With the actual decompression code currently planned for being somewhat lightweight and exposing a <code>Read</code> instance by default, we should have no issues replacing it with a library which also provides us with a <code>Read</code> instance.</p>
</li>
<li><p>Also another thought I had is that the current line of implementation will not have any adverse impact on <code>rg</code>&#x27;s processing speed or parallel capabilities, outside of the performance loss we get from invoking the decompression in a sub-process, which is expected. Seeing as this feature will be implemented as part of the <code>worker</code> itself, which to my understanding is invoked by the parallel walker in case of multiple files. So we should be OK on this.</p>
</li>
<li><p><strong>Windows Support</strong>: This one&#x27;s a bit of a challenge. I tried building <code>rg</code> with my trivial hack to see whether it can work on a Windows 10 machine I have.</p>
<ul>
<li>Good news is that because we&#x27;re using Rust&#x27;s own <code>Command</code> and <code>Pipe</code> capabilities, they work out of the box.</li>
<li>The challenge is detection of binaries. If I simply use <code>bunzip</code> and I have the binary installed by &quot;Git for Windows&quot; on the Path, it still fails saying <em>It is not a valid Win32 application</em>. I tried building with Rust-Gnu as well to no avail. I have a feeling this could be made to work with some manouvering, as long as the binary itself is available on the user&#x27;s path. I&#x27;ll see what I can do.</li>
</ul>
</li>
</ul>
<p>I can&#x27;t think of any more UX/code-maintencance/platform-support related issues, though I&#x27;m sure I will start discovering them as I begin working on the feature. If this sounds good to you, I can begin working on this right away. (I&#x27;ll mostly put effort into this over nights and weekends.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lnicola">@lnicola</a> on 2018-01-03 19:04</div>
            <div class="timeline-body"><blockquote>
<p>The challenge is detection of binaries. If I simply use bunzip and I have the binary installed by &quot;Git for Windows&quot; on the Path, it still fails saying It is not a valid Win32 application. I tried building with Rust-Gnu as well to no avail. I have a feeling this could be made to work with some manouvering, as long as the binary itself is available on the user&#x27;s path. I&#x27;ll see what I can do.</p>
</blockquote>
<p>I no longer have Windows to test this, but that sounds like a 32/64-bit mismatch. You should check Event Viewer for any errors in the Application section, or maybe try <code>depends</code>. It might be that you have a DLL twice in your <code>PATH</code> and <code>bunzip</code> is loading the wrong one.</p>
<p>In any case, this should probably be left for the user to handle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/okdana">@okdana</a> on 2018-01-03 19:42</div>
            <div class="timeline-body"><blockquote>
<p>Going forward, when rg encounters any file ending with .bz2, .gz, .xz or .lzma, it will automatically use the corresponding decompressors (bunzip2, gunzip, unxz or unlzma) to perform the decompression as a child process.</p>
</blockquote>
<p>Other compression-only formats to think about:</p>
<ul>
<li>Brotli (<code>.br</code>, <code>brotli -d</code>)</li>
<li>Compress (<code>.Z</code>, <code>uncompress</code>)</li>
<li>LZ4 (<code>.lz4</code>, <code>lz4cat</code> or <code>unlz4</code>)</li>
<li>LZO (<code>.lzo</code>, <code>lzop -d</code>)</li>
</ul>
<p>Of those, Compress and LZ4 are the most common i believe. <code>uncompress</code> is installed on most UNIX systems by default, and although <code>lz4</code> isn&#x27;t it&#x27;s used for compressing Linux kernel images, core dumps, &amp;c. Doubt any of them are as commonly used for text as the others you mentioned tho</p>
<blockquote>
<p>As of right now, tar archives will not be supported. If they are encountered, rg will fail gracefully letting the user know that it is currently unsupported, before doing any decompression.</p>
</blockquote>
<p>Only if they&#x27;re supplied directly on the command line, i assume? Or in the debug messages maybe? It would be irksome if <code>rg</code> were to flood you with routine notices about not supporting files it encounters in the directory tree</p>
<blockquote>
<p>I&#x27;m currently in favour of exposing a CLI flag similar to what ag does with its -z/--search-zip flag.</p>
</blockquote>
<p>I agree, i think it would make sense to have a flag that toggles compressed-file support as a whole on or off. That would surely be relevant no matter how the feature may be implemented in the future. (I suppose that users will still be able to ignore files with <code>-g</code>, but if there&#x27;s going to be support for several different formats that might be tedious ‚Äî¬†and this ties in with the following)</p>
<hr>
<p>I wonder also about how <code>rg</code> should handle files that <em>look</em> like they&#x27;re compressed but aren&#x27;t. e.g., if i incorporate the LZ4 library into a project maybe i&#x27;ll have something like <code>README.lz4</code> in my repository ‚Äî¬†the <code>.lz4</code> here doesn&#x27;t indicate compression, it&#x27;s just a convention to append things to <code>README</code>. LZ4 is perhaps a bad example since <code>lz4cat</code> actually has the <code>-f</code> option to make it pass uncompressed files through as-is ‚Äî most other decompression tools don&#x27;t have anything like that though</p>
<p>I assume that scenario doesn&#x27;t come up often, but a possibility to consider</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/balajisivaraman">@balajisivaraman</a> on 2018-01-06 08:37</div>
            <div class="timeline-body"><blockquote>
<p>Only if they&#x27;re supplied directly on the command line, i assume? Or in the debug messages maybe? It would be irksome if rg were to flood you with routine notices about not supporting files it encounters in the directory tree</p>
</blockquote>
<p>I was thinking the errors would be output when the user specifically asks to search in archive files using the new <code>-Z/--search-zip</code> flag. If we&#x27;re not going the CLI flag route, then we definitely should do what you suggested and only output the error when specifically asked to search a <code>tar</code> file.</p>
<blockquote>
<p>I wonder also about how rg should handle files that look like they&#x27;re compressed but aren&#x27;t. e.g., if i incorporate the LZ4 library into a project maybe i&#x27;ll have something like README.lz4 in my repository ‚Äî the .lz4 here doesn&#x27;t indicate compression, it&#x27;s just a convention to append things to README. LZ4 is perhaps a bad example since lz4cat actually has the -f option to make it pass uncompressed files through as-is ‚Äî most other decompression tools don&#x27;t have anything like that though</p>
</blockquote>
<p>One option to circumvent this issue is to use the <a href="https://github.com/robo9k/rust-magic">magic</a> crate suggested earlier in this thread, which is the equivalent of running the <code>file</code> command on the file. That way we can safely assume that the file contains the type of data the extension says it contains.</p>
<blockquote>
<p>I no longer have Windows to test this, but that sounds like a 32/64-bit mismatch. You should check Event Viewer for any errors in the Application section, or maybe try depends. It might be that you have a DLL twice in your PATH and bunzip is loading the wrong one.</p>
</blockquote>
<p>Thanks for the suggestion. I&#x27;ll cleanup my Windows installation of Rust and the binaries that I have to recheck this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/balajisivaraman">@balajisivaraman</a> on 2018-01-07 17:00</div>
            <div class="timeline-body"><p>@BurntSushi, I&#x27;ve begun working on this on a <a href="https://github.com/balajisivaraman/ripgrep/tree/fix_539">branch</a> in my fork, going with the simpler file extension based detection instead of the fancier <code>magic</code> based detection. Please let me know your thoughts on whether we&#x27;re OK with <code>rg</code> having CLI flag for this as mentioned above or not, and I&#x27;ll incorporate that into the code accordingly. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-07 17:21</div>
            <div class="timeline-body"><blockquote>
<p>If the expected binary itself is not available, rg will gracefully exit and output a corresponding error message to the user. (Note: The binary is expected to be on the user&#x27;s path and will not be fully qualified to a default location such as /usr/bin or /usr/local/bin for obvious reasons to account for varying install locations.)</p>
</blockquote>
<p>(It occurs to be that by &quot;gracefully exit,&quot; you mean, &quot;continue searching.&quot; Apologies if I misunderstood! But I&#x27;ll leave the text below as I wrote it before I realize the potential misunderstanding.)</p>
<p>This is definitely not OK. ripgrep must not stop working just because an external program isn&#x27;t installed. If the binary isn&#x27;t available, then there are two reasonable choices I can see:</p>
<ol>
<li>Emit a debug message explaining why decompression didn&#x27;t happen. Otherwise, continue searching.</li>
<li>Emit a warning message explaining why decompression didn&#x27;t happen. Otherwise, continue searching.</li>
</ol>
<p>My preference is (1). It&#x27;s the most conservative change and is pretty consistent with ripgrep&#x27;s general behavior of silently ignoring files that it thinks is irrelevant. In the future, we may of course elect to do (2).</p>
<blockquote>
<p>If the executed command fails for any reason at all, then rg will fetch the error message from that process&#x27; stderr, display it, and continue searching the rest of the files.</p>
</blockquote>
<p>This is good. Notably, I don&#x27;t think this should be a debug message, but rather, an actual warning emitting to stderr. This is in contrast to how a missing binary is handled.</p>
<blockquote>
<p>As of right now, tar archives will not be supported. If they are encountered, rg will fail gracefully letting the user know that it is currently unsupported, before doing any decompression. I feel this is better instead of continuing with the current method of skipping binary files. Users should probably be made aware of why their .tar.gz or .tar.xz files are not being processed by rg.</p>
</blockquote>
<p>I would like to see this be a debug message. In particular, it&#x27;s consistent with how we handle other files that are ignored.</p>
<blockquote>
<p>I&#x27;m currently in favour of exposing a CLI flag similar to what ag does with its -z/--search-zip flag. My thought is based mostly on my use-case where I have many compressed log files in the same location as the currently being written to log file. I would want rg to skip the compressed files by default unless I specifically ask it to search through multiple bulky log .gz files. (Also the fact that searching archives will be slower is another reason we may want to go for a CLI argument. If users find that searches in some directories are suddenly slower because we&#x27;re spawning a child process internally, they might be confused. By leaving it to the user&#x27;s choice, we don&#x27;t have this problem.)</p>
</blockquote>
<p>I agree with adding this flag, and by implication, making decompression opt-in.</p>
<blockquote>
<p>My idea is to have the detection and decompression of files in a separate module so that it&#x27;ll be easier to change when Rust gets its own decompression libraries. (We have some WIPs already, with the most famous one being flate which does pull in C bindings, but there&#x27;s work being done on a pure-Rust lib.) With the actual decompression code currently planned for being somewhat lightweight and exposing a Read instance by default, we should have no issues replacing it with a library which also provides us with a Read instance.</p>
</blockquote>
<p>:+1:</p>
<blockquote>
<p>Also another thought I had is that the current line of implementation will not have any adverse impact on rg&#x27;s processing speed or parallel capabilities, outside of the performance loss we get from invoking the decompression in a sub-process, which is expected. Seeing as this feature will be implemented as part of the worker itself, which to my understanding is invoked by the parallel walker in case of multiple files. So we should be OK on this.</p>
</blockquote>
<p>There is definitely a potential performance impact here by shelling out to another process as opposed to using a library, but that is certainly part of the trade off of doing things this way. Otherwise, yeah, fully agreed. :+1:</p>
<blockquote>
<p>Windows Support: This one&#x27;s a bit of a challenge. I tried building rg with my trivial hack to see whether it can work on a Windows 10 machine I have.</p>
</blockquote>
<p>Aye. I think my recommendation here is to start with something that doesn&#x27;t do anything platform specific. That is, even if the implementation is always incorrect on Windows, we should be covered by the aforementioned error handling.</p>
<hr>
<p>@okdana</p>
<blockquote>
<p>I wonder also about how rg should handle files that look like they&#x27;re compressed but aren&#x27;t. e.g., if i incorporate the LZ4 library into a project maybe i&#x27;ll have something like README.lz4 in my repository ‚Äî the .lz4 here doesn&#x27;t indicate compression, it&#x27;s just a convention to append things to README. LZ4 is perhaps a bad example since lz4cat actually has the -f option to make it pass uncompressed files through as-is ‚Äî most other decompression tools don&#x27;t have anything like that though</p>
</blockquote>
<p>That is interesting scenario! I think I&#x27;d suggest ignoring it for now, and fixing it if and when somebody files a bug for it. Then we can try and fix it from there. I&#x27;m somewhat more encouraged to say this is OK since this decompression behavior will be opt-in. @balajisivaraman I&#x27;d probably avoid <code>magic</code> and such for now, but certainly, we may elect to use something like that in the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-07 17:23</div>
            <div class="timeline-body"><p>@balajisivaraman Thanks so much for the detailed specification that you wrote! Truly a great example to follow. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/balajisivaraman">@balajisivaraman</a> on 2018-01-08 16:49</div>
            <div class="timeline-body"><p>@BurntSushi, Yeah, I meant that <code>rg</code> will do what it&#x27;s meant to do and exit normally. (I can see now that what I wrote was very confusing.) Thank you for the clarifications and suggestions. I&#x27;ll incorporate them when I&#x27;m working on it. üëç</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dieken">@Dieken</a> on 2018-01-28 14:59</div>
            <div class="timeline-body"><p>Repeat comment in #225,  @BurntSushi @wavexx</p>
<p>You can set environment variable <code>GREP</code> to &quot;rg&quot;, then use <code>zgrep/bzgrep/xzgrep -Hn</code> to uncompress and search on .gz/.bz2/.xz/.lzma/.lzo with <code>rg</code>,  I feel this is somewhat enough :-)</p>
<p>Notice <code>/usr/bin/bz*grep</code> and <code>/usr/bin/z*grep</code> on Mac OS X don&#x27;t support environment variable <code>GREP</code>, BSD tools suck...  You need install <code>gzip</code> and <code>xz</code> with Homebrew.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wavexx">@wavexx</a> on 2018-01-28 21:49</div>
            <div class="timeline-body"><p>On Sun, Jan 28 2018, Liu Yubao wrote:</p>
<blockquote>
<p>Repeat comment in #225, @BurntSushi @wavexx</p>
<p>You can set environment variable GREP to &quot;rg&quot;, then use
zgrep/bzgrep/xzgrep -Hn to uncompress and search on
.gz/.bz2/.xz/.lzma/.lzo with rg, I feel this is somewhat enough :-)</p>
</blockquote>
<p>I don&#x27;t generally know what sort of compressed files I&#x27;m dealing with.
But setting this aside, this bypasses the directory walking mechanism in
rg itself which has larger implications.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dieken">@Dieken</a> on 2018-01-29 05:19</div>
            <div class="timeline-body"><p><code>xz*grep</code> from package <code>xz</code> (or <code>xz-utils</code>) supports xz/lzma/gzip/bzip2/lzop, I guess this is enough for most people.</p>
<p>Usually searching compressed files is only required to handle log files or some archive files, no need to support language types, gitignore etc,  the bottleneck in combination of <code>find + xargs -P + zgrep + rg</code> probably isn&#x27;t <code>find</code>.  Even if you want languge types/gitignore etc, you can use <code>rg --files -t xxx</code> to replace <code>find</code>.</p>
<p>Certainly, it would be great if ripgrep can directly support compressed file and tar files,  my workaround is just <em>somewhat enough</em> before tons of work to port and optimize those C decompression libraries to Rust.</p>
<p>BTW, after so many years,  GNU grep doesn&#x27;t support compressed files and tar files too, it&#x27;s a UNIX philosophy to combine and reuse existed little utilities.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-29 12:20</div>
            <div class="timeline-body"><p>@Dieken Thanks for pointing out a clever work around. I&#x27;m sure some people will find it useful. Let&#x27;s continue to push forward with #751 (which I still need to review), which is a nice intermediate step between &quot;a hack using existing tools&quot; and &quot;port all the things to Rust.&quot;</p>
<blockquote>
<p>BTW, after so many years, GNU grep doesn&#x27;t support compressed files and tar files too, it&#x27;s a UNIX philosophy to combine and reuse existed little utilities.</p>
</blockquote>
<p>Let&#x27;s try to avoid this type of argumentation. Appealing to the UNIX philosophy kills debates instead of letting them thrive. Reality will dictate. The inherent nature of a tool that does recursive search is that it <em>must</em> violate the UNIX philosophy because it is combining multiple distinct tasks (directory walking and line oriented searching) into one. We create this coupling for UX and performance reasons, and there is no turning back now.</p>
<p>(The irony is that, aesthetically speaking, I am someone that very much appreciates the UNIX philosophy  but I simultaneously maintain a tool that unquestionably violates it. The key is that the UNIX philosophy is a <em>means to an end</em>, not an end itself.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-30 14:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2019-03-21 17:38</div>
            <div class="timeline-body"><p>It looks like the <code>decompress</code> module is pretty easy to extend; would you mind if I open a pull request incorporating <code>unzip</code> support?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-03-21 17:54</div>
            <div class="timeline-body"><p>@BatmanAoD I very much doubt it&#x27;s as easy as you claim, since zips are <em>archives</em> and not just decompression.</p>
<p>Please move discussion to <a href="https://github.com/BurntSushi/ripgrep/issues/1112">BurntSushi/ripgrep#1112</a> which is more similar to zip support than this ticket is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2019-03-21 19:48</div>
            <div class="timeline-body"><p>True. I hadn&#x27;t realized <code>7z</code> and the like are not themselves archive formats.</p>
<p>Using <code>unzip</code> to pipe decompressed data into the search <em>is</em> trivial, but as noted in #1112 the line number and file name info wouldn&#x27;t necessarily be helpful. However, if #1112 were implemented, I would expect it to be useful in conjunction with <code>--search-zip</code>, so that e.g. <code>.tar.gz</code> files would be extracted and decompressed if both options are used, but <code>--search-zip</code> on its own would (continue to) only decompress the archive without extracting it.</p>
<p>So to me, at least, it seems reasonable to implement simple decompression without extraction, since it can be a useful feature on its own.</p>
<p>This should be fairly easy to let users implement for themselves using <code>--pre</code> (albeit awkward, since <code>unzip</code> needs arguments in order to pipe its output). But the same is true of the other decompression utilities, so I think it makes more sense to just include <code>unzip</code> without (yet) supporting extraction.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-21 21:20</div>
            <div class="timeline-body"><blockquote>
<p>I hadn&#x27;t realized 7z and the like are not themselves archive formats.</p>
</blockquote>
<p>I don&#x27;t know where you got the impression that <code>7z</code> isn&#x27;t an archive format.</p>
<p><code>7z</code> is an archive format built around the LZMA compression algorithm, just as <code>zip</code> is an archive format built around the DEFLATE compression algorithm. (And optionally others too.)</p>
<p>The <code>gzip</code>-like &quot;LZMA a single file&quot; formats are <code>.lzma</code>, <code>.xz</code>, and <code>.lz</code>. (<code>.lzma</code> is the precursor to <code>.xz</code> and <code>.lz</code> was created by someone who <a href="http://www.nongnu.org/lzip/xz_inadequate.html">identified major flaws in <code>.xz</code></a>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2019-03-23 00:33</div>
            <div class="timeline-body"><p>@ssokolow Simply because <code>7z</code> is already supported by this RipGrep feature, so I figured that if archive formats were verboten, then none of the existing formats were archive formats.</p>
<p>Andrew, does the fact that we already have an archive format being decompressed but not extracted by the <code>-z</code> flag change your opinion on whether adding <code>unzip</code> would be appropriate?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2019-04-17 18:08</div>
            <div class="timeline-body"><p>@BurntSushi Since RipGrep already supports decompressing-but-not-extracting LZMA, would you object to the same behavior (at least for now) for <code>unzip</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-04-17 18:10</div>
            <div class="timeline-body"><p>I&#x27;d rather not, sorry. Please use <code>--pre</code> (and perhaps <code>--pre-glob</code>) as a work-around for now.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:04 UTC
    </footer>
</body>
</html>
