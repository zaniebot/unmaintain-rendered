<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support non-utf-8 file names - BurntSushi/ripgrep #210</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support non-utf-8 file names</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/210">#210</a>
        opened by <a href="https://github.com/bluss">@bluss</a>
        on 2016-11-01 16:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/bluss">@bluss</a></div>
            <div class="timeline-body"><p>File names on linux are just bags of bytes. Regular shell tools work with them no problem:</p>
<pre><code>$ cat broken� 
hi
$ ls -d broken�
broken?
$ grep &quot;hi&quot; -n broken� 
1:hi
</code></pre>
<p>The main annoyance is that it poisons the whole directory with ripgrep:</p>
<pre><code>$ rg hi *
Argument 'broken�' is not valid UTF-8. Use hex escape sequences to match arbitrary bytes in a pattern (e.g., \xFF).
</code></pre>
<p>Doing the right thing should be easy - an argument is always an OsStr when it enters the rust program, which is losslessly converted to a <code>Path</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-01 16:18</div>
            <div class="timeline-body"><p>Yup, this is a silly bug. Note that if you run <code>rg hi</code> instead of <code>rg hi *</code>, then it works. The specific problem is this very ill-advised code in <code>src/args.rs</code>:</p>
<pre><code class="language-rust">    pub fn parse() -&gt; Result&lt;Args&gt; {
        // Get all of the arguments, being careful to require valid UTF-8.
        let mut argv = vec![];
        for arg in env::args_os() {
            match arg.into_string() {
                Ok(s) =&gt; argv.push(s),
                Err(s) =&gt; {
                    errored!(&quot;Argument '{}' is not valid UTF-8. \
                              Use hex escape sequences to match arbitrary \
                              bytes in a pattern (e.g., \\xFF).&quot;,
                              s.to_string_lossy());
                }
            }
        }
        let mut raw: RawArgs =
            Docopt::new(USAGE)
                .and_then(|d| d.argv(argv).version(Some(version())).decode())
                .unwrap_or_else(|e| e.exit());
</code></pre>
<p>The specific reason why I did this was to catch invalid UTF-8 in <em>patterns</em>, but of course, this catches invalid UTF-8 everywhere.</p>
<p>Finally, Docopt has this:</p>
<pre><code>    fn get_argv() -&gt; Vec&lt;String&gt; {
        // Hmm, we should probably handle a Unicode decode error here... ---AG
        ::std::env::args().skip(1).collect()
    }
</code></pre>
<p>... and the argv parser is built around <code>&amp;str</code> instead of <code>&amp;OsStr</code>.</p>
<p>Sigh. I should probably fix this inside of Docopt, but I also want to switch to clap. See #136.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @BurntSushi on 2016-11-01 16:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluss">@bluss</a> on 2016-11-01 16:25</div>
            <div class="timeline-body"><p>Yes, clap makes it possible to do this correctly, it's nice that way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluss">@bluss</a> on 2016-11-01 16:27</div>
            <div class="timeline-body"><p>The reason I got to this point was that I'm trying to make a way to list matches in rg in latest-modified-first order. First trying to just feed it files in that order.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-01 16:28</div>
            <div class="timeline-body"><p>Oh interesting. You'll also need to pass <code>-j1</code>. If you do that, then the results should come back in the order you gave them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2016-11-18 01:22</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:41:52 UTC
    </footer>
</body>
</html>
