<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expose submatches in `Sink::matched` somehow - BurntSushi/ripgrep #2858</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Expose submatches in <code>Sink::matched</code> somehow</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2858">#2858</a>
        opened by <a href="https://github.com/federicotdn">@federicotdn</a>
        on 2024-07-21 20:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/federicotdn">@federicotdn</a></div>
            <div class="timeline-body"><p>Hi! I&#x27;ve been playing around with ripgrep the last days, using it as a library in Rust. I&#x27;ve implemented a <code>MySink</code> struct that implements the <code>Sink</code> trait. I&#x27;ve noticed however that the <code>SinkMatch</code>es provided to the sink via the <code>matched</code> method do not contain information about where specifically the match (or matches) was found in the line (I think these are referred to as &#x27;submatches&#x27; in ripgrep).</p>
<p>I looked around in the rest of the codebase and I noticed that both <code>StandardSink</code> and <code>JSONSink</code> run some logic specific to extracting these submatches from the matching lines. In both cases, there&#x27;s two functions being used: <code>find_iter_at_in_context</code> and <code>trim_line_terminator</code> (called by the first one). These two functions are not public, however, so if an implementor of <code>Sink</code> wanted to have the same handy behaviour as with the two mentioned <code>Sink</code>s, one would need to copy the code over. It is also not possible to access the internal state of these two <code>Sink</code>s in order to extract the submatch information (I think!).</p>
<p>I did notice though however the comment in <code>find_iter_at_in_context</code>, which makes me think that maybe exposing this function as part of the ripgrep library may not be something your are planning on doing. Curious to hear your thoughts! Maybe there&#x27;s other better ways of exposing the submatch data.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-07-21 20:48</div>
            <div class="timeline-body"><p>It wouldn&#x27;t be appropriate to expose submatches on <code>SinkMatch</code> because submatches aren&#x27;t known at that point. It is very intentional that not all searches will look for submatches because they are expensive to compute. So doing it when you don&#x27;t need to is not a good idea. Moreover, indeed, the location of the match itself isn&#x27;t even provided because the <code>Searcher</code> might not even know it! All it might know is that there is a match somewhere. Finding the full match is also more expensive <em>and</em> is not always needed, so it to would not be appropriate to expose in <code>SinkMatch</code> because it specifically isn&#x27;t known.</p>
<p>The <code>find_iter_at_in_context</code> routine is <em>not</em> in <code>grep-searcher</code>. It&#x27;s in <code>grep-printer</code>. So it is not possible for it to be using any internal state that you can&#x27;t get at.</p>
<p>There is a fair amount of logic in <code>grep-printer</code> used to hook up the output of a <code>Searcher</code> with the actual results emitted to end users. I don&#x27;t have plans of exposing that logic. There are too many assumptions being made and it would make the crate abstractions even more complicated than they already are.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/federicotdn">@federicotdn</a> on 2024-07-21 20:56</div>
            <div class="timeline-body"><p>That makes sense, thanks. The internal state I was referring to was the values already computed by <code>find_iter_at_in_context</code>, for <code>StandardSink</code> or <code>JSONSink</code>. But I see your point that the function itself operates on <code>Sink</code> state that is available to users of the library. I think I will take a look at how the function works internally and see if I can apply the same logic for my <code>Sink</code> implementation üëçüèª</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/federicotdn">@federicotdn</a> on 2024-07-21 20:56</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:14 UTC
    </footer>
</body>
</html>
