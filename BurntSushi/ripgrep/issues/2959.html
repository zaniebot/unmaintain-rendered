<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>running ripgrep on a 500GB directory causes ripgrep to use a lot of memory - BurntSushi/ripgrep #2959</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>running ripgrep on a 500GB directory causes ripgrep to use a lot of memory</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2959">#2959</a>
        opened by <a href="https://github.com/bananafirestorm">@bananafirestorm</a>
        on 2025-01-02 14:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/bananafirestorm">@bananafirestorm</a></div>
            <div class="timeline-body">Please tick this box to confirm you have reviewed the above.
<ul>
<li>[X] I have a different issue.</li>
</ul>
What version of ripgrep are you using?
<p>14.1.1</p>
How did you install ripgrep?
<p>Uploaded from releases</p>
What operating system are you using ripgrep on?
<p>Windows 10</p>
Describe your bug.
<p>When the search result exceeds the memory capacity, the program breaks.</p>
What are the steps to reproduce the behavior?
<p>Open the 500GB folder find (find a large number of lines, more than the amount of memory) for example: all non-null lines. Redirect the output to write to a file.</p>
What is the actual behavior?
<p>destruction of the Windows machine</p>
What is the expected behavior?
<p>Make an option to write to a file in parts and disable output to the screen (so that you can select the size of the parts). Then there will be writing to the file in parts, while freeing up memory. And the ability to work with any volume.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-02 16:19</div>
            <div class="timeline-body"><p>From the man page:</p>
<pre><code>       ripgrep may use a large amount of memory depending on a few fac‐
       tors.  Firstly,  if ripgrep uses parallelism for search (the de‐
       fault), then the entire  output  for  each  individual  file  is
       buffered into memory in order to prevent interleaving matches in
       the  output. To avoid this, you can disable parallelism with the
       -j1 flag. Secondly, ripgrep always needs to have at least a sin‐
       gle line in memory in order to execute a search. A file  with  a
       very  long  line  can thus cause ripgrep to use a lot of memory.
       Generally, this only occurs when searching binary data with  the
       -a/--text  flag enabled. (When the -a/--text flag isn&#x27;t enabled,
       ripgrep will replace all NUL bytes with line terminators,  which
       typically  prevents exorbitant memory usage.) Thirdly, when rip‐
       grep searches a large file using a memory map, the process  will
       likely report its resident memory usage as the size of the file.
       However,  this does not mean ripgrep actually needed to use that
       much heap memory; the operating  system  will  generally  handle
       this for you.
</code></pre>
<p>It is <em>not</em> a foregone conclusion that merely running ripgrep on 500GB of data will cause it to use a ton of memory.</p>
<p>The main way for a huge memory spike to happen is if you&#x27;re running with multiple threads (the default) <em>and</em> your regex pattern matches nearly everything. Because of the use of parallelism, ripgrep has to buffer the output <em>per file</em> in memory. So if you have five 100GB files in that directory, ripgrep could conceivably try to use 500GB of memory. The only way around this is to disable parallelism. Then ripgrep will <em>stream</em> the output to stdout without buffering the entire contents into memory first.</p>
<p>The somewhat less common way for a huge memory spike to happen is if you have files with very long lines. Like, GBs long. This is very unlikely to happen unless <code>-a/--text</code> is given, but is theoretically possible. (The <code>-a/--text</code> flag matters, because, without it, NUL bytes are turned into line terminators by ripgrep. This eliminates the largest source of long lines: long runs of NUL terminators in binary data. But when <code>-a/--text</code> is given, ripgrep searches the data as-is and no NUL replacement is done. Which increases the chances of seeing a very long line.)</p>
<blockquote>
<p>Make an option to write to a file in parts and disable output to the screen (so that you can select the size of the parts). Then there will be writing to the file in parts, while freeing up memory. And the ability to work with any volume.</p>
</blockquote>
<p>I don&#x27;t know what you mean by &quot;disable output to the screen.&quot;</p>
<p>ripgrep is not going to grow an option for &quot;writing to a file in parts.&quot; I&#x27;m not even sure what that means, and it doesn&#x27;t even necessarily solve the problem. Indeed, it&#x27;s impossible to say <em>why</em> ripgrep is using up a ton of memory in your use case because there is no MRE. For that reason, this issue isn&#x27;t actually actionable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-02 16:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Inability to work with large amounts of data.&quot; to &quot;running ripgrep on a 500GB directory causes ripgrep to use a lot of memory&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-02 16:20</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:14 UTC
    </footer>
</body>
</html>
