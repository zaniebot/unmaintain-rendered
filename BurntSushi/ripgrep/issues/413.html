<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ripgrep binaries are an order of magnitude larger than they need to be - BurntSushi/ripgrep #413</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ripgrep binaries are an order of magnitude larger than they need to be</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/413">#413</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2017-03-19 14:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>This discussion started in #412.</p>
<p>The problem is that when you compile ripgrep today, you get big binaries. Both the <code>cargo install</code> approach and installing Linux binaries from the Github releases yield large binaries.</p>
<p>To address the inconsistency concern in the abstract: there are <em>many</em> inconsistencies between the ripgrep releases and what&#x27;s installed with <code>cargo install</code>, and these inconsistencies will always be there. For example, <code>cargo install</code> doesn&#x27;t provide easy access to a man page, license info or to the various auto-completion scripts. So the fact that there is yet another inconsistency doesn&#x27;t really bother me. Namely, <code>cargo install</code> is <em>not</em> the recommended way to install ripgrep, so I&#x27;m less sympathetic to issues that people have using it. It&#x27;s provided on a best effort basis because it&#x27;s occasionally convenient for folks who are otherwise Rust programmers.</p>
<p>Secondly, I will describe why I have <code>debug = true</code> for release builds. Perhaps there is some other solution that I haven&#x27;t thought of.</p>
<p>There are two primary benefits I perceived when setting <code>debug = true</code>:</p>
<ol>
<li>A large fraction of time I spend developing ripgrep is with it compiled in release mode because I want to inspect its runtime performance. Release mode by default doesn&#x27;t include debug symbols, so this makes profiling harder. If <code>debug = false</code> were committed to source control, then I would have to constantly be changing around that value in the <code>Cargo.toml</code> during development, which is a huge pain. I don&#x27;t want to do it.</li>
<li>If and when ripgrep panics and the bug is hard to reproduce, the reporter can set <code>RUST_BACKTRACE=1</code> on some systems and get a useful stack trace if and only if debug symbols are in the binary.</li>
</ol>
<p>(2) is interesting, because ripgrep hardly ever panics, so it actually has not turned out to be as useful as I would have thought. In the case where it does happen, we could ask the user to compile ripgrep on their own---which is probably what most projects do---but I had wanted to make it as effortless as possible to report a bug. Nevertheless, since it rarely happens, it seems weird to optimize for that case.</p>
<p>With all that said, it seems like this is an argument in favor of stripping debug info from the binaries released in Github, but to retain the <code>debug = true</code> in <code>Cargo.toml</code>. Is there another solution? Can Cargo&#x27;s config do something to help me out here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-19 14:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sfackler">@sfackler</a> on 2017-03-19 17:18</div>
            <div class="timeline-body"><p>As of the 1.16 release, you can set <code>debug = 1</code> or <code>debug = 2</code> to select the level of debuginfo you want in addition to <code>debug = true</code> (which acts like <code>debug = 2</code>). I believe level 1 debuginfo includes everything necessary for backtraces and profiling? Not sure what the size difference is though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/XAMPPRocky">@XAMPPRocky</a> on 2017-03-19 18:32</div>
            <div class="timeline-body"><p>I definitely feel the same with having to worry about making sure to not to publish with <code>debug = true</code>, one possible solution I was thinking was if there was another cargo profile. A way to differentiate between a <code>cargo install</code> and <code>cargo build --release</code>. With the install profile restricted in what it can override, maybe it can only toggle debug.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pftbest">@pftbest</a> on 2017-03-28 06:55</div>
            <div class="timeline-body"><p>Please also note that when debuginfo is enabled frame pointers are not eliminated.
<a href="https://github.com/rust-lang/rust/issues/11906">rust-lang/rust#11906</a>
This may (or may not) have some impact on a performance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DoumanAsh">@DoumanAsh</a> on 2017-04-02 12:08</div>
            <div class="timeline-body"><p>You can also consider to add <code>lto = true</code> for published builds.
As far as i know it is not a default for release builds.
But it requires testing.
It didn&#x27;t give much difference on msvc toolchain for me</p>
<p>On other hand you can have debug symbols separately (cargo build even produces <code>pdb</code> for binaries), but i&#x27;m not sure if it possible to tell cargo to produce them separately instead of bundling together?
Since <code>cargo build</code> is capable (need confirmation on linux) it should be possible?
Most profiling tools accept loading of symbols in the same directory as your binary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-04-04 15:34</div>
            <div class="timeline-body"><p>Using <code>lto = true</code> was discussed in BurntSushi/ripgrep#325 with the problem being compile times suffer for little gain (performance). However, quoting @BurntSushi</p>
<blockquote>
<p>If someone wanted this then I&#x27;d be open to adding it only in CI when the final release artifact is produced.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/retep998">@retep998</a> on 2017-04-18 03:09</div>
            <div class="timeline-body"><p>Enabling debuginfo for msvc during <code>cargo install</code> provides no benefit because the .pdb is thrown away so you couldn&#x27;t get a sane backtrace anyway. If you manually distribute compiled binaries with the .pdb then the debuginfo becomes valuable.</p>
<blockquote>
<p>It didn&#x27;t give much difference on msvc toolchain for me</p>
</blockquote>
<p>This is because what you&#x27;re seeing is LTO stripping unreferenced functions which ld is actually <em>really</em> bad at while link.exe is amazing at it. As a result LTO is just bringing the size of gnu binaries <em>closer</em> to where msvc binaries already are. LTO is still useful to maximize inlining potential though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/scottchiefbaker">@scottchiefbaker</a> on 2017-04-18 23:53</div>
            <div class="timeline-body"><p>I didn&#x27;t know debug info was enabled and while I was doing a casual comparison of <code>ag</code> vs <code>rg</code> and I noticed the file sizes were <strong>drastically</strong> different.</p>
<p><code>ag</code> is 244KB
<code>rg</code> is 25<strong>MB</strong></p>
<p>I think it send the wrong message if you&#x27;re 100x larger than the competition. The majority of people using ripgrep will never use the debug information so it&#x27;s wasteful in both bandwidth and disk space.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-19 00:40</div>
            <div class="timeline-body"><p>Why does it matter? If you care about a few megs of disk space, then I&#x27;m willing to bet that&#x27;s a pretty specialized use case. In that case, just strip the binary yourself.</p>
<p>I don&#x27;t know what &quot;wrong message&quot; you are referring to. Could you please be more specific?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/retep998">@retep998</a> on 2017-04-19 03:28</div>
            <div class="timeline-body"><p>Wow, the difference between msvc and gnu is pretty huge. For the latest release x86_64-pc-windows-gnu is 24,228,086 bytes while x86_64-pc-windows-msvc is 2,445,312 bytes, almost exactly an order of magnitude difference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kaushalmodi">@kaushalmodi</a> on 2017-05-09 21:28</div>
            <div class="timeline-body"><p><a href="https://gist.github.com/17f03efe2e57265d90c48d39f5dabc27">Setting <code>debug</code> to <code>false</code></a> reduced built <code>rg</code> binary size on RHEL 6.6 from 25 MB to 5.8 MB.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/luser">@luser</a> on 2017-05-22 15:32</div>
            <div class="timeline-body"><p>One thing that might be feasible in the future is using ELF compressed sections. For example:</p>
<pre><code>$ ls -l /tmp/rg
-rwxr-xr-x 1 luser docker 21233872 May 22 11:23 /tmp/rg
$ objcopy --compress-debug-sections /tmp/rg
$ ls -l /tmp/rg
-rwxr-xr-x 1 luser docker 6196568 May 22 11:24 /tmp/rg
</code></pre>
<p>Unfortunately libbacktrace doesn&#x27;t support reading them yet, so this breaks their usefulness in Rust backtraces. If that got fixed it&#x27;d be a nice easy win (DWARF is pretty verbose).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-23 22:07</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:03 UTC
    </footer>
</body>
</html>
