<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart search seems to ignore some directories - BurntSushi/ripgrep #534</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Smart search seems to ignore some directories</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/534">#534</a>
        opened by <a href="https://github.com/ltratt">@ltratt</a>
        on 2017-06-30 09:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ltratt">@ltratt</a></div>
            <div class="timeline-body"><p>I get confusing behaviour (at least to me!) with the default settings, where a directory doesn't appear to be searched for non-obvious reasons:</p>
<pre><code>$ pwd
/home/ltratt/w/pliss/llvm
$ rg IndexVec src
src/lib/Analysis/LoopAccessAnalysis.cpp
1498:  auto &amp;IndexVector = Accesses.find(Access)-&gt;second;
1501:  transform(IndexVector,
$ rg IndexVec .
$ 
</code></pre>
<p>Note that I haven't changed directory between those two searches: I've simply specified either a sub-dir or the current dir. There doesn't appear to be anything about the current directory that would suggest that things shouldn't be searched:</p>
<pre><code>$ ls -la
total 32
drwxr-xr-x   4 ltratt  ltratt   512 May 19 07:22 .
drwxr-xr-x   4 ltratt  ltratt   512 May 19 08:25 ..
drwxr-xr-x  15 ltratt  ltratt   512 May 19 07:23 release
drwxr-xr-x  16 ltratt  ltratt  1024 May 19 07:21 src
$
</code></pre>
<p>There is a <code>.gitignore</code> file in <code>src/</code> but a) it doesn't mention anything in the <code>lib/</code> subdir b) I'm not sure why specifying <code>.</code> vs <code>src</code> would make any difference.</p>
<p>It's possible that I'm simply being an idiot with respect to my expectations for smart search, but I must admit that I'm a bit baffled! Happens with both ripgrep 0.5.2 and ripgrep b6f1e5db. [FWIW, <code>ag</code> doesn't seem to suffer from the same issue, but it may have different smart searching rules.]</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-30 10:54</div>
            <div class="timeline-body"><p>Given what you've told me, this also seems weird, but there actually isn't enough information here to know for sure:</p>
<ol>
<li>Is the code your searching publicly accessible so that others can try to reproduce it?</li>
<li>Can you show the output of both of your <code>rg</code> commands, but with the <code>--debug</code> flag given?</li>
<li>Do you have any global gitignore settings? e.g., In <code>$HOME/.config/git/ignore</code>? Or do you have any repo wide gitignore settings? e.g., In <code>./.git/info/exclude</code>? (ripgrep will read both of these.)</li>
</ol>
<p>Invariably, the <code>--debug</code> flag will spew a bunch of output, but it should tell you why specific things are being ignored.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ltratt">@ltratt</a> on 2017-06-30 11:53</div>
            <div class="timeline-body"><p>Thanks for the quick reply, especially as it's probably something stupid that I'm doing!</p>
<ol>
<li><p>It's the LLVM repository (or a minor fork of it IIRC), although if I clone it in <code>/tmp/</code> I don't get this behaviour. If it's useful I can probably work out how to get you a copy.</p>
</li>
<li><p>Here's both commands with <code>--debug</code>:</p>
</li>
</ol>
<pre><code>$ pwd
/home/ltratt/w/pliss/llvm
$ rg --debug IndexVec .
DEBUG:grep::search: regex ast:
Literal {
    chars: [
        'I',
        'n',
        'd',
        'e',
        'x',
        'V',
        'e',
        'c'
    ],
    casei: false
}
DEBUG:grep::literals: literal prefixes detected: Literals { lits: [Complete(IndexVec)], limit_size: 250, limit_class: 10 }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.sw[klmnop]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.sw[klmnop]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Literal('s'), Literal('w'), Class { negated: false, ranges: [('k', 'k'), ('l', 'l'), ('m', 'm'), ('n', 'n'), ('o', 'o'), ('p', 'p')] }]) }
DEBUG:globset: built glob set; 0 literals, 0 basenames, 1 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 1 regexes
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.DCOPserver*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.DCOPserver.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('D'), Literal('C'), Literal('O'), Literal('P'), Literal('s'), Literal('e'), Literal('r'), Literal('v'), Literal('e'), Literal('r'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.zsh_history*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.zsh_history.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('z'), Literal('s'), Literal('h'), Literal('_'), Literal('h'), Literal('i'), Literal('s'), Literal('t'), Literal('o'), Literal('r'), Literal('y'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.recently-used*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.recently\\-used.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('r'), Literal('e'), Literal('c'), Literal('e'), Literal('n'), Literal('t'), Literal('l'), Literal('y'), Literal('-'), Literal('u'), Literal('s'), Literal('e'), Literal('d'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.serverauth.*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.serverauth\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('s'), Literal('e'), Literal('r'), Literal('v'), Literal('e'), Literal('r'), Literal('a'), Literal('u'), Literal('t'), Literal('h'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.texlive_201*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.texlive_201.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('t'), Literal('e'), Literal('x'), Literal('l'), Literal('i'), Literal('v'), Literal('e'), Literal('_'), Literal('2'), Literal('0'), Literal('1'), ZeroOrMore]) }
DEBUG:globset: built glob set; 0 literals, 166 basenames, 1 extensions, 0 prefixes, 1 suffixes, 0 required extensions, 5 regexes
DEBUG:ignore::walk: ignoring ./src: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;src&quot;, actual: &quot;**/src&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring ./release/bin: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;bin&quot;, actual: &quot;**/bin&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring ./release/utils/unittest/CMakeFiles/gtest.dir/googletest/src: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;src&quot;, actual: &quot;**/src&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring ./release/utils/unittest/CMakeFiles/gtest.dir/googlemock/src: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;src&quot;, actual: &quot;**/src&quot;, is_whitelist: false, is_only_dir: false })))
$ rg --debug IndexVec src
DEBUG:grep::search: regex ast:
Literal {
    chars: [
        'I',
        'n',
        'd',
        'e',
        'x',
        'V',
        'e',
        'c'
    ],
    casei: false
}
DEBUG:grep::literals: literal prefixes detected: Literals { lits: [Complete(IndexVec)], limit_size: 250, limit_class: 10 }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.sw[klmnop]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.sw[klmnop]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Literal('s'), Literal('w'), Class { negated: false, ranges: [('k', 'k'), ('l', 'l'), ('m', 'm'), ('n', 'n'), ('o', 'o'), ('p', 'p')] }]) }
DEBUG:globset: built glob set; 0 literals, 0 basenames, 1 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 1 regexes
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.DCOPserver*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.DCOPserver.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('D'), Literal('C'), Literal('O'), Literal('P'), Literal('s'), Literal('e'), Literal('r'), Literal('v'), Literal('e'), Literal('r'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.zsh_history*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.zsh_history.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('z'), Literal('s'), Literal('h'), Literal('_'), Literal('h'), Literal('i'), Literal('s'), Literal('t'), Literal('o'), Literal('r'), Literal('y'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.recently-used*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.recently\\-used.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('r'), Literal('e'), Literal('c'), Literal('e'), Literal('n'), Literal('t'), Literal('l'), Literal('y'), Literal('-'), Literal('u'), Literal('s'), Literal('e'), Literal('d'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.serverauth.*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.serverauth\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('s'), Literal('e'), Literal('r'), Literal('v'), Literal('e'), Literal('r'), Literal('a'), Literal('u'), Literal('t'), Literal('h'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.texlive_201*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.texlive_201.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('t'), Literal('e'), Literal('x'), Literal('l'), Literal('i'), Literal('v'), Literal('e'), Literal('_'), Literal('2'), Literal('0'), Literal('1'), ZeroOrMore]) }
DEBUG:globset: built glob set; 0 literals, 166 basenames, 1 extensions, 0 prefixes, 1 suffixes, 0 required extensions, 5 regexes
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.*.sw?&quot;, re: &quot;(?-u)^(?:/?|.*/)\\..*\\.sw.$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), ZeroOrMore, Literal('.'), Literal('s'), Literal('w'), Any]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/.sw?&quot;, re: &quot;(?-u)^(?:/?|.*/)\\.sw.$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('.'), Literal('s'), Literal('w'), Any]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/projects/*&quot;, re: &quot;(?-u)^(?:/?|.*/)projects/[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('p'), Literal('r'), Literal('o'), Literal('j'), Literal('e'), Literal('c'), Literal('t'), Literal('s'), Literal('/'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/projects/*.*&quot;, re: &quot;(?-u)^(?:/?|.*/)projects/[^/]*\\.[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('p'), Literal('r'), Literal('o'), Literal('j'), Literal('e'), Literal('c'), Literal('t'), Literal('s'), Literal('/'), ZeroOrMore, Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/runtimes/*&quot;, re: &quot;(?-u)^(?:/?|.*/)runtimes/[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('r'), Literal('u'), Literal('n'), Literal('t'), Literal('i'), Literal('m'), Literal('e'), Literal('s'), Literal('/'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/runtimes/*.*&quot;, re: &quot;(?-u)^(?:/?|.*/)runtimes/[^/]*\\.[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('r'), Literal('u'), Literal('n'), Literal('t'), Literal('i'), Literal('m'), Literal('e'), Literal('s'), Literal('/'), ZeroOrMore, Literal('.'), ZeroOrMore]) }
DEBUG:globset: built glob set; 19 literals, 6 basenames, 2 extensions, 0 prefixes, 13 suffixes, 0 required extensions, 6 regexes
DEBUG:ignore::walk: ignoring src/.svn: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring src/.clang-format: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring src/.gitignore: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring src/.clang-tidy: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring src/.arcconfig: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring src/test/.clang-format: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: whitelisting src/projects/LLVMBuild.txt: Whitelist(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;!projects/*.*&quot;, actual: &quot;**/projects/*.*&quot;, is_whitelist: true, is_only_dir: false })))
DEBUG:ignore::walk: whitelisting src/projects/CMakeLists.txt: Whitelist(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;!projects/*.*&quot;, actual: &quot;**/projects/*.*&quot;, is_whitelist: true, is_only_dir: false })))
DEBUG:ignore::walk: whitelisting src/runtimes/Components.cmake.in: Whitelist(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;!runtimes/*.*&quot;, actual: &quot;**/runtimes/*.*&quot;, is_whitelist: true, is_only_dir: false })))
DEBUG:ignore::walk: whitelisting src/runtimes/CMakeLists.txt: Whitelist(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;!runtimes/*.*&quot;, actual: &quot;**/runtimes/*.*&quot;, is_whitelist: true, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/unittest/googlemock/src: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;src&quot;, actual: &quot;**/src&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/unittest/googletest/src: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;src&quot;, actual: &quot;**/src&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/llvm-build/llvmbuild/__init__.pyc: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;*.pyc&quot;, actual: &quot;**/*.pyc&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/llvm-build/llvmbuild/main.pyc: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;*.pyc&quot;, actual: &quot;**/*.pyc&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/llvm-build/llvmbuild/componentinfo.pyc: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;*.pyc&quot;, actual: &quot;**/*.pyc&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/llvm-build/llvmbuild/util.pyc: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;*.pyc&quot;, actual: &quot;**/*.pyc&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/llvm-build/llvmbuild/configutil.pyc: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;src/.gitignore&quot;), original: &quot;*.pyc&quot;, actual: &quot;**/*.pyc&quot;, is_whitelist: false, is_only_dir: false })))
DEBUG:ignore::walk: ignoring src/utils/lit/tests/.coveragerc: Ignore(IgnoreMatch(Hidden))
src/lib/Analysis/LoopAccessAnalysis.cpp
1498:  auto &amp;IndexVector = Accesses.find(Access)-&gt;second;
1501:  transform(IndexVector,
$
</code></pre>
<ol start="3">
<li>I do have a <code>.gitignore_global</code>:</li>
</ol>
<pre><code>$ cat /home/ltratt/.gitignore_global 
*.sw[klmnop]
*.bak
$
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-30 12:35</div>
            <div class="timeline-body"><p>Right, OK, so if you carefully scrutinize the debug output of the first command, you'll see this:</p>
<pre><code>DEBUG:ignore::walk: ignoring ./src: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;/home/ltratt/.gitignore&quot;), original: &quot;src&quot;, actual: &quot;**/src&quot;, is_whitelist: false, is_only_dir: false })))
</code></pre>
<p>Basically, that says <code>./src</code> is being ignored because your <code>/home/ltratt/.gitignore</code> file contains an entry called <code>src</code>. The main problem with &quot;smart search&quot; in my experience is that if you're in a directory that has an ancestor with a <code>.gitignore</code>, then that <code>.gitignore</code> file is applied to all children directories. Note though, that this only applies to child directories that are themselves not <code>.git</code> checkouts. Is your llvm source a git clone with its own <code>.git</code> directory?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-30 12:36</div>
            <div class="timeline-body"><p>This also explains why a checkout in <code>/tmp</code> doesn't exhibit this behavior, since <code>/home/ltratt</code> isn't an ancestor of <code>/tmp</code>.</p>
<p>Also, the silver searcher doesn't exhibit this behavior because it doesn't actually implement the <code>gitignore</code> rules correctly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ltratt">@ltratt</a> on 2017-06-30 13:16</div>
            <div class="timeline-body"><p>Ug, I should have guessed! No, the LLVM dir is a download not a clone (so no <code>.git</code> dir).</p>
<p>So one final question before I close this issue and hang my head in shame. The gitignore check only ignores files that are children of things I pass on the command-line? i.e. if I do <code>rg b searchstring</code> then <code>b</code> is searched regardless of whether it's referenced in an upper <code>.gitignore</code> file or not. But if my directory structure is <code>a/b</code> and I do <code>rg a searchstring</code> then <code>b</code> won't be searched if it's referenced in an upper <code>.gitignore</code> file? [I think this is perfectly reasonable behaviour, but it's not something that has a direct analogy in git itself, so I thought it might be worth checking!]</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-30 13:22</div>
            <div class="timeline-body"><blockquote>
<p>hang my head in shame</p>
</blockquote>
<p>You really shouldn't! You aren't the first person to struggle with this. There is even a special cased error message in ripgrep that gets triggered when you run <code>rg pattern</code> and no files get searched. You didn't happen to trip it in this case, but if you did, the error message suggests running with <code>--debug</code>, which usually clears up the problem if you look at the output closely enough. This particular failure mode occurs because lots of folks---myself included---put their <code>$HOME</code> in git, and use <code>.gitignore</code> to ignore everything by default and un-ignore certain things. But if you search in a non-git sub-directory of <code>$HOME</code> (like you are), then <code>$HOME/.gitignore</code> is still in play, and it's probably the case that everything gets ignored. (The first line of my <code>$HOME/.gitignore</code> is <code>*</code>.)</p>
<blockquote>
<p>The gitignore check only ignores files that are children of things I pass on the command-line?</p>
</blockquote>
<p>Correct. The idea here is that if you explicitly give a file path, then you are expressing knowledge that should supersede any other &quot;automatic&quot; smarts saying that something should be ignored.</p>
<p>But yeah, smart searching is nice until it's <em>too</em> smart, and then it just becomes opaque and frustrating. It's a tough balance. Ideas for making failure modes more explicit would be most welcome. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ltratt">@ltratt</a> on 2017-06-30 13:29</div>
            <div class="timeline-body"><p>Thanks for the detailed explanation! I must admit, I have absolutely no idea what a good failure message is. In an ideal world, I suppose it would be preferable if <code>.gitignore</code> anchored patterns to the directory the <code>.gitignore</code> file is in by default, but that ship has long sailed. If I think of anything, I'll shout. But, until then, I'll close this issue and thank you again for your time!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ltratt on 2017-06-30 13:29</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:13 UTC
    </footer>
</body>
</html>
