<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ripgrep is slower than LTREP matching `[A-Z][A-Z]+` - BurntSushi/ripgrep #2819</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ripgrep is slower than LTREP matching <code>[A-Z][A-Z]+</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2819">#2819</a>
        opened by <a href="https://github.com/Bricktech2000">@Bricktech2000</a>
        on 2024-05-26 07:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Bricktech2000">@Bricktech2000</a></div>
            <div class="timeline-body">Please tick this box to confirm you have reviewed the above.
<ul>
<li>[X] I have a different issue.</li>
</ul>
What version of ripgrep are you using?
<pre><code>ripgrep 14.1.0 (rev 35160a1cdb)

features:-pcre2
simd(compile):+SSE2,-SSSE3,-AVX2
simd(runtime):+SSE2,+SSSE3,+AVX2

PCRE2 is not available in this build of ripgrep.
</code></pre>
How did you install ripgrep?
<p>From source.</p>
What operating system are you using ripgrep on?
<p>NixOS 23.05 x86_64</p>
Describe your bug.
<p>ripgrep is slower than LTREP (a wrapper around my toy regex engine <a href="https://github.com/Bricktech2000/LTRE">LTRE</a>) when matching for <code>[A-Z][A-Z]+</code>. LTRE has no literal optimizations and so always takes 1.3s to match against enwik9 on my machine. ripgrep is faster than LTRE until <code>[A-J][A-J]+</code> (takes 0.6s against enwik9) but becomes slower from <code>[A-K][A-K]+</code> onwards (takes 1.5s against enwik9).</p>
What are the steps to reproduce the behavior?
<p>Download then unzip enwik9 from <a href="https://mattmahoney.net/dc/textdata.html">https://mattmahoney.net/dc/textdata.html</a>.</p>
<pre><code>git clone https://github.com/Bricktech2000/LTRE
cd LTRE/
git checkout 1297041
make ltrep # -O2 on GCC 12.2.0
time bin/ltrep -c &#x27;[A-Z][A-Z]+&#x27; enwik9
# 1212981
# real	0m1.309s
# user	0m1.275s
# sys	0m0.034s
</code></pre>
<pre><code>git clone https://github.com/BurntSushi/ripgrep
cd ripgrep
git checkout 35160a1
cargo build --release
time target/release/rg --debug -c &#x27;[A-Z][A-Z]+&#x27; enwik9
# rg: DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
# rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1083: number of paths given to search: 1
# rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1094: is_one_file? true
# rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1269: found hostname for hyperlink configuration: nixos
# rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1279: hyperlink format: &quot;&quot;
# rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 1 thread(s)
# rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
# 1212981
# real	0m1.529s
# user	0m1.495s
# sys	0m0.034s
</code></pre>
What is the actual behavior?
<p>ripgrep is slower than LTREP.</p>
What is the expected behavior?
<p>ripgrep to be faster than LTREP.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-05-26 11:46</div>
            <div class="timeline-body"><p>Nice find. At first I thought this might be a case of the latency of the regex engine playing a role here (because it generally has more overhead than <a href="https://github.com/Bricktech2000/LTRE/blob/12970412082b14cd4b44e9c857b004d5e67ddc51/ltre.c#L631-L636">what you have here</a>). But some other examples reveal this probably isn&#x27;t the case?</p>
<pre><code>$ time rg -c &#x27;[A-Z]+&#x27; enwik9
7421426

real    0.604
user    0.547
sys     0.057
maxmem  959 MB
faults  0

$ time ltrep-1297041 -c &#x27;[A-Z]+&#x27; enwik9
7421426

real    0.904
user    0.843
sys     0.060
maxmem  954 MB
faults  0

$ time rg -c &#x27;[A-Z][A-Z]+&#x27; enwik9
1212981

real    1.141
user    1.077
sys     0.063
maxmem  959 MB
faults  0

$ time ltrep-1297041 -c &#x27;[A-Z][A-Z]+&#x27; enwik9
1212981

real    0.925
user    0.884
sys     0.040
maxmem  954 MB
faults  0
</code></pre>
<p>So I think this probably warrants some investigation.</p>
<p>Also, just because something is a toy doesn&#x27;t mean it is expected to never be faster than something that isn&#x27;t a non-toy. For example, this is the &quot;toy&quot; version of <code>memchr</code>:</p>
<pre><code>fn memchr(needle: u8, haystack: &amp;[u8]) -&gt; Option&lt;usize&gt; {
    haystack.iter().position(|&amp;b| b == needle)
}
</code></pre>
<p>But sometimes this will be faster than a SIMD optimized version. Because the SIMD optimized version needs a preamble, a fallback for the case when the haystack is smaller than the vector size, creating the vector and so on. And the SIMD version might not get inlined if it&#x27;s using AVX2 and the surrounding code wasn&#x27;t compiled with AVX2 enabled. (Which is the common case, although the rise of things like <code>x86-64-v3</code> is changing that.)</p>
<p>And like, despite your regex engine being a toy, your search code is still very tight and about as good as you can do with a DFA: you transition from state to state and report whether a match state was seen. ripgrep&#x27;s regex engine basically does the same, <a href="https://github.com/rust-lang/regex/blob/ddeb85eaa3bdf79d6306cc92a9d8bd89d839b5cd/regex-automata/src/dfa/search.rs#L83-L125">but with more frills</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-05-26 14:27</div>
            <div class="timeline-body"><p>My hypothesis here is that your toy regex engine is benefiting precisely from the coupling that comes from the nature of it being a toy. That is, in your grep, the code for searching the input and the code for walking the DFA are effectively intertwined. That generally isn&#x27;t true for a general purpose regex engine: there&#x27;s usually an abstraction boundary that separates them. To test this, I generated a file with the same number of lines as <code>enwik9</code> but where every line was just <code>AZ</code>:</p>
<pre><code>use std::io::Write;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let lines = 13_147_025;
    let mut out = std::io::stdout().lock();
    for _ in 0..lines {
        writeln!(out, &quot;AZ&quot;)?;
    }
    Ok(())
}
</code></pre>
<p>Then I benchmarked ripgrep, ltrep and GNU grep with <code>hyperfine</code>:</p>
<pre><code>$ hyperfine --output pipe &quot;LC_ALL=C grep -E -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals&quot; &quot;rg --no-config -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals&quot; &quot;ltrep-1297041 -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals&quot;
Benchmark 1: LC_ALL=C grep -E -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals
  Time (mean ± σ):     112.7 ms ±   2.5 ms    [User: 110.7 ms, System: 2.2 ms]
  Range (min … max):   110.5 ms … 120.4 ms    25 runs

Benchmark 2: rg --no-config -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals
  Time (mean ± σ):     327.9 ms ±   1.5 ms    [User: 326.3 ms, System: 1.7 ms]
  Range (min … max):   325.4 ms … 331.0 ms    10 runs

Benchmark 3: ltrep-1297041 -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals
  Time (mean ± σ):      22.5 ms ±   3.4 ms    [User: 20.6 ms, System: 2.0 ms]
  Range (min … max):    16.0 ms …  31.3 ms    91 runs

Summary
  ltrep-1297041 -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals ran
    5.00 ± 0.76 times faster than LC_ALL=C grep -E -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals
   14.55 ± 2.20 times faster than rg --no-config -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals
</code></pre>
<p>ltrep doesn&#x27;t just beat ripgrep, it also beats GNU grep. GNU grep doesn&#x27;t have as much abstraction as ripgrep, but it has more than ltrep. Also, at a certain point, the feature support has a role to play here. As the features and optimizations and use cases grow, so to does the abstractions.</p>
<p>But ltrep&#x27;s advantage here is data dependent. Your particular implementation examines every byte of input, and in exchange, your code is simpler but potentially significantly slower. For example, I wrote this program to generate a similar file as above, but with an extra 100 bytes after the initial <code>AZ</code>:</p>
<pre><code>use std::io::Write;

fn main() -&gt; anyhow::Result&lt;()&gt; {
    let lines = 13_147_025;
    let mut out = std::io::stdout().lock();
    let filler = &quot;az&quot;.repeat(100);
    for _ in 0..lines {
        write!(out, &quot;AZ&quot;)?;
        write!(out, &quot;{filler}&quot;)?;
        writeln!(out, &quot;&quot;)?;
    }
    Ok(())
}
</code></pre>
<p>Then I re-ran the benchmarks:</p>
<pre><code>$ hyperfine --output pipe &quot;LC_ALL=C grep -E -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler&quot; &quot;rg --no-config -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler&quot; &quot;ltrep-1297041 -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler&quot;
Benchmark 1: LC_ALL=C grep -E -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler
  Time (mean ± σ):     330.5 ms ±   7.5 ms    [User: 161.5 ms, System: 168.8 ms]
  Range (min … max):   321.7 ms … 341.6 ms    10 runs

Benchmark 2: rg --no-config -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler
  Time (mean ± σ):     531.5 ms ±  11.2 ms    [User: 460.0 ms, System: 71.1 ms]
  Range (min … max):   502.5 ms … 544.9 ms    10 runs

Benchmark 3: ltrep-1297041 -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler
  Time (mean ± σ):      2.294 s ±  0.019 s    [User: 2.238 s, System: 0.055 s]
  Range (min … max):    2.261 s …  2.312 s    10 runs

Summary
  LC_ALL=C grep -E -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler ran
    1.61 ± 0.05 times faster than rg --no-config -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler
    6.94 ± 0.17 times faster than ltrep-1297041 -c &#x27;[A-Z][A-Z]&#x27; enwik9-two-capitals-with-filler
</code></pre>
<p>Both GNU grep and ripgrep know to stop searching on each line after seeing the <code>AZ</code>. But ltrep continues. Your code is less branchy because of it, but now it&#x27;s doing a bunch of wasted work.</p>
<p>I think there&#x27;s overall room for ripgrep to improve here, but I&#x27;d consider this difference to be &quot;overall small.&quot; And once the abstraction genie is out of the box, it&#x27;s hard to roll it back.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-05-26 14:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-05-26 14:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Bricktech2000">@Bricktech2000</a> on 2024-05-26 21:30</div>
            <div class="timeline-body"><p>Short-circuiting out when on an accepting state in the middle of a partial match is such a low-hanging fruit I can&#x27;t believe I didn&#x27;t think of it. In the general case I believe this boils down to preprocessing the DFA by flagging states which either always or never reach an accepting state. And I wouldn&#x27;t be surprised if the additional compare and branch needed in the hot loop nullified LTRE&#x27;s &quot;head start&quot;.</p>
<p>Thanks for taking the time to provide such a great response.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:14 UTC
    </footer>
</body>
</html>
