<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[Feature request] Support \&lt; and \&gt; as an alias to \b - BurntSushi/ripgrep #872</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[Feature request] Support &lt; and &gt; as an alias to \b</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/872">#872</a>
        opened by <a href="https://github.com/bstaletic">@bstaletic</a>
        on 2018-03-30 19:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/bstaletic">@bstaletic</a></div>
            <div class="timeline-body"><h4>What version of ripgrep are you using?</h4>
<p>ripgrep 0.8.1
-SIMD -AVX</p>
<h4>What operating system are you using ripgrep on?</h4>
<p>Gentoo linux</p>
<h4>Describe your question, feature request, or bug.</h4>
<p>The <code>\&lt;</code> and <code>\&gt;</code> style word boundaries come from Vi (ex?) and work in grep. A reason to have these supported is to allow seamless use of Vim's regexes when a Vim user has <code>set grepprg=ripgrp\ --vimgrep</code>. The most annoying use case is the following:</p>
<ul>
<li>User has the cursor over a <code>word</code> he would like to search for in the file and presses <code>*</code>.</li>
<li>After looking through the file, user decides to search the whole project for that word.</li>
<li>User types <code>:grep &lt;C-r&gt;/</code> and is greeted with <code>:grep -r  \&lt;word\&gt;</code>.</li>
<li>User presses enter.</li>
<li>At this point user might expect the pattern to work, but is greeted with an error.</li>
</ul>
<p>Yes, there are workarounds for this, but it would be realy nice if Vim's word boundary matching &quot;just worked&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-03-30 22:31</div>
            <div class="timeline-body"><p>In principle, I am not opposed to this, but I will put these things out there:</p>
<ul>
<li><code>\&lt;</code> and <code>\&gt;</code> are very explicitly <em>not</em> aliases of <code>\b</code>, but rather, match only the beginning and end of words, respectively. <code>\b</code> matches any word boundary, either beginning or end.</li>
<li>This isn't really something that is implemented in ripgrep, but rather, in the <a href="https://github.com/rust-lang/regex">regex engine</a>.</li>
<li>It is quite likely that even if I agree to add this, it will be a very very long time before I personally work on it. Moreover, the way word boundaries work in the current regex engine is quite brittle and is a source of (outstanding) bugs, and therefore complicating it further in its current form would be a bad idea IMO.</li>
</ul>
<p>Given the above, I suggest you find a way to make peace with their absence for now. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/okdana">@okdana</a> on 2018-03-30 22:57</div>
            <div class="timeline-body"><p>Also, adding non-alphanumeric escape sequences to the regex syntax would be a break from Perl-style syntaxes, where any escaped non-word character is always equivalent to the literal character (<code>\.</code> is literal <code>.</code>, <code>\/</code> is literal <code>/</code>, <code>\#</code> is literal <code>#</code>, &amp;c.). <code>regex</code> doesn't support that currently (it's an error if the escaped character is not a recognised meta-character), but you do have the option to add it, without breaking BC, in the future — if you implement <code>\&lt;</code> <code>\&gt;</code> you'll be committing yourself to the (rather confusing, IMO) notion that escaped non-alphanumerics are sometimes literal and sometimes not.</p>
<p>Not sure if that would bother you at all (and it doesn't sound immediately relevant anyway), but it was something that occurred to me when i saw this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bstaletic">@bstaletic</a> on 2018-03-30 23:06</div>
            <div class="timeline-body"><blockquote>
<p><code>\&lt;</code> and <code>\&gt;</code> are very explicitly <em>not</em> aliases of <code>\b</code></p>
</blockquote>
<p>Strictly speaking, that's true. My thoughts were &quot;it's close enough&quot;.</p>
<blockquote>
<p>This isn't really something that is implemented in ripgrep, but rather, in the regex engine.</p>
</blockquote>
<p>I wasn't aware regex engine is a separate project.</p>
<blockquote>
<p>Moreover, the way word boundaries work in the current regex engine is quite brittle and is a source of (outstanding) bugs, and therefore complicating it further in its current form would be a bad idea IMO.</p>
</blockquote>
<p>We have all fought messy code before, so your point of view is more than reasonable.</p>
<blockquote>
<p>Given the above, I suggest you find a way to make peace with their absence for now. :-)</p>
</blockquote>
<p>I've been using ripgrep, ag and grep without knowing that grep supports <code>\&lt;</code> until recently, so I can live without that support, but I must admit that it would be very convenient.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-03-30 23:46</div>
            <div class="timeline-body"><p>@okdana Ah good point! The escaping strategy used in <code>regex</code> was intentionally designed that way, exactly for cases like these where we can add new escape sequences in a backwards compatible way. :-)</p>
<p>I hadn't considered the notion about escaping non-alphanumerics being confusing though, that's an interesting point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-03-30 23:48</div>
            <div class="timeline-body"><p>@bstaletic One thought here, for your sake: if your use case revolves around one very specific type of invocation of ripgrep in your vim workflow, you might be able to write a wrapper script that replaces <code>\&lt;</code> and <code>\&gt;</code> with <code>\b</code>. I realize that's a pain of course, and I don't necessarily suggest it to the exclusion of adding proper support for <code>\&lt;</code> and <code>\&gt;</code>, but as a way to hold you over.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bstaletic">@bstaletic</a> on 2018-03-31 05:54</div>
            <div class="timeline-body"><p>Heh, why didn't I think of making some sort of key binding that would replace <code>\&lt;</code> and <code>\&gt;</code> with <code>\b</code>? Thanks for the suggestion.</p>
<p>I have managed to rebind enter to do this substitution. The <code>TODO:</code> below doesn't bother me too much as I never use <code>:vimgrep</code>.</p>
<pre><code class="language-viml">function! slash#SubstituteWordBoundaries() abort
	let l:cmd = getcmdline()
	&quot; TODO: make sure this is calling grep, not vimgrep
	return substitute(l:cmd, '\\[&lt;&gt;]', '\\\\b', 'g')
endfunction

function! slash#callBlink() abort
	if getcmdtype() == '/' || getcmdtype() == '?'
		return &quot;\&lt;cr&gt;:call slash#blink(3, 100)\&lt;cr&gt;&quot;
	else
		if &amp;grepprg != 'grep'
			return &quot;\&lt;C-\&gt;eslash#SubstituteWordBoundaries()\&lt;cr&gt;\&lt;cr&gt;&quot;
		endif
		return &quot;\&lt;cr&gt;&quot;
	endif
endfunction
</code></pre>
<p>The above snippet is straight from my <code>.vim/autoload/slash.vim</code>, which isn't properly named now when I fiddle with <code>:</code> and not only with <code>/</code>.</p>
<p>The function above gets called from my <code>.vimrc</code> like this: <code>cnoremap &lt;silent&gt; &lt;expr&gt; &lt;enter&gt; slash#callBlink()</code>. The only downside - it actually changes what was typed, so history doesn't contain what the user typed, but something similar.</p>
<p>@BurntSushi Thanks for the suggestion. If you decide not to allow <code>\&lt;</code> and <code>\&gt;</code>, feel free to close this feature request.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-04-23 23:46</div>
            <div class="timeline-body"><p>I've opened an issue against the regex crate: https://github.com/rust-lang/regex/issues/469</p>
<p>This feature is basically entirely contained in the regex crate, so I'm not going to track it here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2018-04-23 23:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @BurntSushi on 2018-04-23 23:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2018-04-23 23:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/toonn">@toonn</a> on 2018-08-06 23:27</div>
            <div class="timeline-body"><p>Could you add something to the man page about this? Currently searching the manpage for either <code>word boundary</code> or just <code>boundary</code> doesn't turn up <em>any</em> results. It's also somewhat hard to google for turning up a bunch of results about <code>-w</code> which don't seem related, i.e. I wanted to use boundaries in a larger regexp so <code>-w</code> was not an option.</p>
<p>Ideally &quot;word boundary&quot; and &quot;&lt;&quot; and &quot;&gt;&quot; would all turn up at least one result in the man page.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-06 23:33</div>
            <div class="timeline-body"><p>@toonn The man page should direct you to the description of the regex syntax, which can be found here: https://docs.rs/regex/1.0.2/regex/#syntax</p>
<p>With that said, yes, it would be nice to be in the man page. Actually, it would be nice if the entire regex syntax were documented in the man page, but that's a lot of documentation to have duplicated. Although, it shouldn't change very often.</p>
<p>I would be OK with a new section, <code>REGULAR EXPRESSION SYNTAX</code> that included the aforementioned link and any additional callouts that might be useful to folks, in particular, differences from other regex engines, in lieu of including the full syntax description.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bstaletic">@bstaletic</a> on 2018-08-07 02:59</div>
            <div class="timeline-body"><p>Another option would be creating a completely new man page for the syntax and then creating a script that would convert the page above into the man page.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-07 11:49</div>
            <div class="timeline-body"><p>@bstaletic Neat idea. I'd be open to that.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:30 UTC
    </footer>
</body>
</html>
