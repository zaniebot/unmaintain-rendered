<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[perf] rg does not use globs to prune recursion when it can - BurntSushi/ripgrep #2789</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[perf] rg does not use globs to prune recursion when it can</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2789">#2789</a>
        opened by <a href="https://github.com/BGR360">@BGR360</a>
        on 2024-04-25 01:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BGR360">@BGR360</a></div>
            <div class="timeline-body">Please tick this box to confirm you have reviewed the above.
<ul>
<li>[X] I have a different issue.</li>
</ul>
What version of ripgrep are you using?
<p>ripgrep 14.1.0</p>
How did you install ripgrep?
<p>Build from source with the following patch applied:</p>
<pre><code>diff --git a/crates/core/flags/hiargs.rs b/crates/core/flags/hiargs.rs
index e027a2c..140f006 100644
--- a/crates/core/flags/hiargs.rs
+++ b/crates/core/flags/hiargs.rs
@@ -896,6 +896,7 @@ impl HiArgs {
             .ignore_case_insensitive(self.ignore_file_case_insensitive);
         if !self.no_ignore_dot {
             builder.add_custom_ignore_filename(&quot;.rgignore&quot;);
+            builder.add_custom_ignore_filename(&quot;.hgignore&quot;);
         }
         // When we want to sort paths lexicographically in ascending order,
         // then we can actually do this during directory traversal itself.
</code></pre>
What operating system are you using ripgrep on?
<p>Linux 5.15.0-60-generic #66~20.04.1-Ubuntu SMP x86_64 GNU/Linux</p>
Describe your bug.
<p>I&#x27;m trying to search through a massive corpus of log files (~10M files), on a remote NFS mount, to see if a particular string is present <strong>in a certain type of log file</strong>. I have a glob that filters down to the log files I care about. The key point is that the files that match my glob are <strong>a small subset of all the files</strong>.</p>
<p>The corpus looks like this:</p>

Expand for preview of corpus

<pre><code>.
├── Customer1
│   ├── cluster1
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-03-03
│   │   │   └── ...lots-of-logs
│   │   └── ...many-more-dates
│   ├── cluster2
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   ├── ...lots-of-logs
│   │   │   └── perf_123
│   │   │       └── profile
│   │   │           └── 0-trigger
│   │   │               └── oplogs
│   │   │                   └── SOME-INTERESTING-LOGS
│   │   ├── 2024-03-03
│   │   │   └── ...lots-of-logs
│   │   └── ...many-more-dates
│   └── cluster3
│       ├── 2024-01-01
│       │   └── ...lots-of-logs
│       ├── 2024-02-02
│       │   └── ...lots-of-logs
│       ├── 2024-03-03
│       │   └── ...lots-of-logs
│       └── ...many-more-dates
├── Customer2
│   ├── cluster1
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-03-03
│   │   │   ├── ...lots-of-logs
│   │   │   └── perf_456
│   │   │       └── profile
│   │   │           └── 0-trigger
│   │   │               └── oplogs
│   │   │                   └── SOME-INTERESTING-LOGS
│   │   └── ...many-more-dates
│   ├── cluster2
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-03-03
│   │   │   └── ...lots-of-logs
│   │   └── ...many-more-dates
│   └── cluster3
│       ├── 2024-01-01
│       │   └── ...lots-of-logs
│       ├── 2024-02-02
│       │   └── ...lots-of-logs
│       ├── 2024-03-03
│       │   └── ...lots-of-logs
│       └── ...many-more-dates
├── ...a-few-hundred-more
</code></pre>


<p>With my glob being <code>*/*/*/perf_*/profile/0-trigger/oplogs/*.log</code>.</p>
<p>The problem is that ripgrep is <strong>not limiting its recursive walk to only the paths that definitely match the glob.</strong> It is enumerating directories that could not possibly match the glob, and the number of files that end up being considered really adds up. It&#x27;s considering far more files than it needs to.</p>
What are the steps to reproduce the behavior?
<p>Create the following directory tree. It mimics my corpus.</p>
<pre><code>$ tree
.
├── 0-many
│   ├── blah
│   │   ├── 0-lots
│   │   ├── 1-of
│   │   └── 2-files
│   └── GOOD
│       └── COOL.log
└── 1-dirs
    ├── blah
    │   ├── 0-lots
    │   ├── 1-of
    │   └── 2-files
    └── GOOD
        └── COOL.log
</code></pre>
<p>Use the following glob search. It mimics my search. I only want to search through the directories I know will contain my interesting files.</p>
<pre><code>$ rg --debug --files -g &#x27;*/GOOD/*.log&#x27;
</code></pre>
What is the actual behavior?
<p>ripgrep recurses into the <code>*/blah/</code> directories when there&#x27;s no chance that they could match the glob.</p>
<p>Problematic lines emphasized with <code>&gt;&gt;&gt;</code></p>
<pre><code>$ rg --debug --files -g &#x27;*/GOOD/*.log&#x27;
rg: DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1100: using heuristics to determine whether to read from stdin or search ./ (is_readable_stdin=false, stdin_consumed=false, mode=Files)
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1110: heuristic chose to search ./
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1261: found hostname for hyperlink configuration: timmy
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1271: hyperlink format: &quot;&quot;
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 0 basenames, 0 extensions, 0 prefixes, 0 suffixes, 1 required extensions, 0 regexes
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 12 thread(s)
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 3 basenames, 0 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./1-dirs/blah/2-files: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./1-dirs/blah/1-of: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./1-dirs/blah/0-lots: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./1-dirs/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
1-dirs/GOOD/COOL.log
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./0-many/blah/2-files: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./0-many/blah/1-of: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./0-many/blah/0-lots: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./0-many/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
0-many/GOOD/COOL.log
</code></pre>
<p>Same result if I try <code>/*/GOOD/*.log</code></p>
What is the expected behavior?
<p>Ripgrep should skip recursing into directories that do not match the glob.</p>
<p>Something like this:</p>
<pre><code>$ rg --debug --files -g &#x27;/*/GOOD/*.log&#x27;
rg: DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1100: using heuristics to determine whether to read from stdin or search ./ (is_readable_stdin=false, stdin_consumed=false, mode=Files)
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1110: heuristic chose to search ./
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1261: found hostname for hyperlink configuration: timmy
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1271: hyperlink format: &quot;&quot;
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 0 basenames, 0 extensions, 0 prefixes, 0 suffixes, 1 required extensions, 0 regexes
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 12 thread(s)
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 3 basenames, 0 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs: ignoring ./1-dirs/blah/: does not match glob
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./1-dirs/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;/*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
1-dirs/GOOD/COOL.log
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs: ignoring ./0-many/blah/: does not match glob
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./0-many/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;/*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
0-many/GOOD/COOL.log
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-04-25 01:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-04-25 01:18</div>
            <div class="timeline-body"><p>I thought there was already an open issue for this, but I couldn&#x27;t find it.</p>
<p>This is a rather difficult optimization to do and is blocked on a rewrite of <code>globset</code> and probably <code>ignore</code>. It&#x27;s something I&#x27;ve been working on off-and-on for a while now, but it&#x27;s unlikely to land any time soon. I&#x27;m not even 100% certain it&#x27;s possible unless the <code>--no-ignore</code> flag is also passed. The interaction point between <code>-g/--glob</code> and ignore files will need to be carefully considered for something like this.</p>
<p>Your best bet is to use some other tool to filter out files first. Possibly even using your shell&#x27;s glob support. Although those could in theory end up being slower than ripgrep even when ripgrep visits more than it needs to. It depends.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BGR360">@BGR360</a> on 2024-04-25 01:32</div>
            <div class="timeline-body"><p>Alright, thanks for clarifying. Using <code>fd</code> to write all of the interesting filepaths to a file and then <code>xargs</code>-ing that into <code>rg</code> got me results way faster!</p>
<p>It would be neat if <code>rg</code> supported piping in filenames from stdin. So I wouldn&#x27;t have to wait for <code>fd</code> to finish its scan. Should I post another enhancement issue for that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-04-25 01:42</div>
            <div class="timeline-body"><p>That&#x27;s #273. But you shouldn&#x27;t need it. You should be able to pipe the output of <code>fd</code> straight into ripgrep with <code>xargs</code> without writing to an intermediate file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BGR360">@BGR360</a> on 2024-04-25 01:43</div>
            <div class="timeline-body"><p>I can use xargs yes but ripgrep won&#x27;t start searching any of those paths until the <code>fd</code> scan completes.</p>
<p>EDIT: oh nvm i can make xargs chunk it up into multiple <code>rg</code> invocations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Bluesman74">@Bluesman74</a> on 2024-10-07 17:25</div>
            <div class="timeline-body"><p>@BGR360
The FD readme at Github says that you can use -x to invoke the command when it finds the match, and -X which is when it passes all the matches to the executed program.</p>
<p>Were you using -X, as that would explain it?</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:13 UTC
    </footer>
</body>
</html>
