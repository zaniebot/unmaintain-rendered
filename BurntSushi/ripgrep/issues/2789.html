<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[perf] rg does not use globs to prune recursion when it can - BurntSushi/ripgrep #2789</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[perf] rg does not use globs to prune recursion when it can</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2789">#2789</a>
        opened by <a href="https://github.com/BGR360">@BGR360</a>
        on 2024-04-25 01:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BGR360">@BGR360</a></div>
            <div class="timeline-body"><h3>Please tick this box to confirm you have reviewed the above.</h3>
<ul>
<li>[X] I have a different issue.</li>
</ul>
<h3>What version of ripgrep are you using?</h3>
<p>ripgrep 14.1.0</p>
<h3>How did you install ripgrep?</h3>
<p>Build from source with the following patch applied:</p>
<pre><code class="language-diff">diff --git a/crates/core/flags/hiargs.rs b/crates/core/flags/hiargs.rs
index e027a2c..140f006 100644
--- a/crates/core/flags/hiargs.rs
+++ b/crates/core/flags/hiargs.rs
@@ -896,6 +896,7 @@ impl HiArgs {
             .ignore_case_insensitive(self.ignore_file_case_insensitive);
         if !self.no_ignore_dot {
             builder.add_custom_ignore_filename(&quot;.rgignore&quot;);
+            builder.add_custom_ignore_filename(&quot;.hgignore&quot;);
         }
         // When we want to sort paths lexicographically in ascending order,
         // then we can actually do this during directory traversal itself.
</code></pre>
<h3>What operating system are you using ripgrep on?</h3>
<p>Linux 5.15.0-60-generic #66~20.04.1-Ubuntu SMP x86_64 GNU/Linux</p>
<h3>Describe your bug.</h3>
<p>I'm trying to search through a massive corpus of log files (~10M files), on a remote NFS mount, to see if a particular string is present <strong>in a certain type of log file</strong>. I have a glob that filters down to the log files I care about. The key point is that the files that match my glob are <strong>a small subset of all the files</strong>.</p>
<p>The corpus looks like this:</p>
<details>
<summary>Expand for preview of corpus</summary>

<pre><code>.
├── Customer1
│   ├── cluster1
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-03-03
│   │   │   └── ...lots-of-logs
│   │   └── ...many-more-dates
│   ├── cluster2
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   ├── ...lots-of-logs
│   │   │   └── perf_123
│   │   │       └── profile
│   │   │           └── 0-trigger
│   │   │               └── oplogs
│   │   │                   └── SOME-INTERESTING-LOGS
│   │   ├── 2024-03-03
│   │   │   └── ...lots-of-logs
│   │   └── ...many-more-dates
│   └── cluster3
│       ├── 2024-01-01
│       │   └── ...lots-of-logs
│       ├── 2024-02-02
│       │   └── ...lots-of-logs
│       ├── 2024-03-03
│       │   └── ...lots-of-logs
│       └── ...many-more-dates
├── Customer2
│   ├── cluster1
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-03-03
│   │   │   ├── ...lots-of-logs
│   │   │   └── perf_456
│   │   │       └── profile
│   │   │           └── 0-trigger
│   │   │               └── oplogs
│   │   │                   └── SOME-INTERESTING-LOGS
│   │   └── ...many-more-dates
│   ├── cluster2
│   │   ├── 2024-01-01
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-02-02
│   │   │   └── ...lots-of-logs
│   │   ├── 2024-03-03
│   │   │   └── ...lots-of-logs
│   │   └── ...many-more-dates
│   └── cluster3
│       ├── 2024-01-01
│       │   └── ...lots-of-logs
│       ├── 2024-02-02
│       │   └── ...lots-of-logs
│       ├── 2024-03-03
│       │   └── ...lots-of-logs
│       └── ...many-more-dates
├── ...a-few-hundred-more
</code></pre>
</details>

<p>With my glob being <code>*/*/*/perf_*/profile/0-trigger/oplogs/*.log</code>.</p>
<p>The problem is that ripgrep is <strong>not limiting its recursive walk to only the paths that definitely match the glob.</strong> It is enumerating directories that could not possibly match the glob, and the number of files that end up being considered really adds up. It's considering far more files than it needs to.</p>
<h3>What are the steps to reproduce the behavior?</h3>
<p>Create the following directory tree. It mimics my corpus.</p>
<pre><code>$ tree
.
├── 0-many
│   ├── blah
│   │   ├── 0-lots
│   │   ├── 1-of
│   │   └── 2-files
│   └── GOOD
│       └── COOL.log
└── 1-dirs
    ├── blah
    │   ├── 0-lots
    │   ├── 1-of
    │   └── 2-files
    └── GOOD
        └── COOL.log
</code></pre>
<p>Use the following glob search. It mimics my search. I only want to search through the directories I know will contain my interesting files.</p>
<pre><code>$ rg --debug --files -g '*/GOOD/*.log'
</code></pre>
<h3>What is the actual behavior?</h3>
<p>ripgrep recurses into the <code>*/blah/</code> directories when there's no chance that they could match the glob.</p>
<p>Problematic lines emphasized with <code>&gt;&gt;&gt;</code></p>
<pre><code>$ rg --debug --files -g '*/GOOD/*.log'
rg: DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1100: using heuristics to determine whether to read from stdin or search ./ (is_readable_stdin=false, stdin_consumed=false, mode=Files)
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1110: heuristic chose to search ./
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1261: found hostname for hyperlink configuration: timmy
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1271: hyperlink format: &quot;&quot;
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 0 basenames, 0 extensions, 0 prefixes, 0 suffixes, 1 required extensions, 0 regexes
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 12 thread(s)
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 3 basenames, 0 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./1-dirs/blah/2-files: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./1-dirs/blah/1-of: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./1-dirs/blah/0-lots: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./1-dirs/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
1-dirs/GOOD/COOL.log
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./0-many/blah/2-files: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./0-many/blah/1-of: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1799: ignoring ./0-many/blah/0-lots: Ignore(IgnoreMatch(Override(Glob(UnmatchedIgnore))))
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./0-many/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
0-many/GOOD/COOL.log
</code></pre>
<p>Same result if I try <code>/*/GOOD/*.log</code></p>
<h3>What is the expected behavior?</h3>
<p>Ripgrep should skip recursing into directories that do not match the glob.</p>
<p>Something like this:</p>
<pre><code>$ rg --debug --files -g '/*/GOOD/*.log'
rg: DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1100: using heuristics to determine whether to read from stdin or search ./ (is_readable_stdin=false, stdin_consumed=false, mode=Files)
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1110: heuristic chose to search ./
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1261: found hostname for hyperlink configuration: timmy
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1271: hyperlink format: &quot;&quot;
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 0 basenames, 0 extensions, 0 prefixes, 0 suffixes, 1 required extensions, 0 regexes
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 12 thread(s)
rg: DEBUG|globset|crates/globset/src/lib.rs:453: built glob set; 0 literals, 3 basenames, 0 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs: ignoring ./1-dirs/blah/: does not match glob
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./1-dirs/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;/*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
1-dirs/GOOD/COOL.log
&gt;&gt;&gt;rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs: ignoring ./0-many/blah/: does not match glob
rg: DEBUG|ignore::walk|crates/ignore/src/walk.rs:1802: whitelisting ./0-many/GOOD/COOL.log: Whitelist(IgnoreMatch(Override(Glob(Matched(Glob { from: None, original: &quot;/*/GOOD/*.log&quot;, actual: &quot;*/GOOD/*.log&quot;, is_whitelist: false, is_only_dir: false })))))
0-many/GOOD/COOL.log
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @BurntSushi on 2024-04-25 01:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-04-25 01:18</div>
            <div class="timeline-body"><p>I thought there was already an open issue for this, but I couldn't find it.</p>
<p>This is a rather difficult optimization to do and is blocked on a rewrite of <code>globset</code> and probably <code>ignore</code>. It's something I've been working on off-and-on for a while now, but it's unlikely to land any time soon. I'm not even 100% certain it's possible unless the <code>--no-ignore</code> flag is also passed. The interaction point between <code>-g/--glob</code> and ignore files will need to be carefully considered for something like this.</p>
<p>Your best bet is to use some other tool to filter out files first. Possibly even using your shell's glob support. Although those could in theory end up being slower than ripgrep even when ripgrep visits more than it needs to. It depends.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BGR360">@BGR360</a> on 2024-04-25 01:32</div>
            <div class="timeline-body"><p>Alright, thanks for clarifying. Using <code>fd</code> to write all of the interesting filepaths to a file and then <code>xargs</code>-ing that into <code>rg</code> got me results way faster!</p>
<p>It would be neat if <code>rg</code> supported piping in filenames from stdin. So I wouldn't have to wait for <code>fd</code> to finish its scan. Should I post another enhancement issue for that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-04-25 01:42</div>
            <div class="timeline-body"><p>That's #273. But you shouldn't need it. You should be able to pipe the output of <code>fd</code> straight into ripgrep with <code>xargs</code> without writing to an intermediate file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BGR360">@BGR360</a> on 2024-04-25 01:43</div>
            <div class="timeline-body"><p>I can use xargs yes but ripgrep won't start searching any of those paths until the <code>fd</code> scan completes.</p>
<p>EDIT: oh nvm i can make xargs chunk it up into multiple <code>rg</code> invocations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Bluesman74">@Bluesman74</a> on 2024-10-07 17:25</div>
            <div class="timeline-body"><p>@BGR360
The FD readme at Github says that you can use -x to invoke the command when it finds the match, and -X which is when it passes all the matches to the executed program.</p>
<p>Were you using -X, as that would explain it?</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:48 UTC
    </footer>
</body>
</html>
