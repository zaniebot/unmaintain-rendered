<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`rg` cannot traverse arbitrarily deep directories like GNU `grep`. - BurntSushi/ripgrep #3259</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>rg</code> cannot traverse arbitrarily deep directories like GNU <code>grep</code>.</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/3259">#3259</a>
        opened by <a href="https://github.com/collinfunk">@collinfunk</a>
        on 2026-01-07 05:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/collinfunk">@collinfunk</a></div>
            <div class="timeline-body"><p>Here is how you can reproduce:</p>
<pre><code>$ rg --version | head -n 1
ripgrep 15.1.0 (rev 0a88cccd51)
$ grep --version | head -n 1
grep (GNU grep) 3.12.14-071a
$ mkdir -p `yes a/ | head -n $((32 * 1024)) | tr -d '\n'`
$ while cd $(yes a/ | head -n 1024 | tr -d '\n'); do :; done 2&gt;/dev/null
$ pwd | tr '/' '\n' | wc -l
32771
$ echo hello | tee $(seq 100) &gt; /dev/null
$ (cd $HOME &amp;&amp; grep -r '^hello$' a | wc -l)
100
$ (cd $HOME &amp;&amp; rg '^hello$' a)
rg: [trimmed long file name]: File name too long (os error 36)
</code></pre>
<p>It also seems that <code>rg</code> unnecessarily computes the current working
directory for each file processed. That becomes inefficient when
<code>ENAMETOOLONG</code> is returned and the <code>openat (dirfd, &quot;..&quot;, ...)</code> to root
fallback has to be used. This can be seen below from the same directory:</p>
<pre><code>$ pwd | tr '/' '\n' | wc -l
32771
$ time grep -r '^hello$' | wc -l
100

real	0m0.004s
user	0m0.001s
sys	0m0.005s
$ time rg --no-heading --line-number '^hello$' | wc -l

thread '&lt;unknown&gt;' (1405793) has overflowed its stack
fatal runtime error: stack overflow, aborting
100

real	2m59.479s
user	0m22.209s
sys	19m10.741s
</code></pre>
<p>I am not sure where the stack overflow is from. Probably a large item on
the stack, instead of deep recursion?</p>
<p>Also, during that test you can see that lots of memory is allocated
seemingly only for the file names:</p>
<pre><code>$ (ulimit -v $(($(numfmt --from=iec 9G) / 1024)) &amp;&amp; rg --no-heading --line-number '^hello$')
memory allocation of 63663 bytes failed
Aborted                    (core dumped) ( ulimit -v $(($(numfmt --from=iec 9G) / 1024)) &amp;&amp; rg --no-heading --line-number '^hello$' )
</code></pre>
<p>Note that creating a directory this deep might depend on your file
system, and shells other than <code>bash</code> or <code>zsh</code> will almost certainly fail
to <code>cd</code> this deep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2026-01-07 13:35</div>
            <div class="timeline-body"><p>Thanks for the report!</p>
<p>This is unfortunately a difficult bug to fix because it requires somewhat invasive changes to <code>walkdir</code> (single threaded directory traversal) and <code>ignore</code> (multi-threaded directory traversal). See https://github.com/BurntSushi/walkdir/issues/181 and https://github.com/BurntSushi/walkdir/issues/23. I started a journey a few years to fix this, but was never able to finish it. It's pretty low priority for me.</p>
<blockquote>
<p>It also seems that rg unnecessarily computes the current working directory for each file processed.</p>
</blockquote>
<p>If ripgrep is actually doing this, then that's a bug that should be fixed independent of the long file path issue. ripgrep should only be asking for the CWD once:</p>
<p>https://github.com/BurntSushi/ripgrep/blob/0a88cccd5188074de96f54a4b6b44a63971ac157/crates/core/flags/hiargs.rs#L1292-L1312</p>
<p>The CWD is used for matching gitignore patterns in some cases. (Something that GNU grep does not do.) It should probably be the case that if ripgrep doesn't <em>need</em> the CWD, then it shouldn't ask for it. So, e.g., you should be able to run <code>rg --no-ignore</code> and have it not ask for the CWD. But ripgrep isn't smart enough for that today.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @BurntSushi on 2026-01-07 13:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/collinfunk">@collinfunk</a> on 2026-01-08 02:31</div>
            <div class="timeline-body"><blockquote>
<p>Thanks for the report!</p>
<p>This is unfortunately a difficult bug to fix because it requires somewhat invasive changes to <code>walkdir</code> (single threaded directory traversal) and <code>ignore</code> (multi-threaded directory traversal). See <a href="https://github.com/BurntSushi/walkdir/issues/181">BurntSushi/walkdir#181</a> and <a href="https://github.com/BurntSushi/walkdir/issues/23">BurntSushi/walkdir#23</a>. I started a journey a few years to fix this, but was never able to finish it. It's pretty low priority for me.</p>
</blockquote>
<p>I agree with your analysis in those bug reports. You certainly do not
want to use <code>chdir</code>, especially when the library is used by
multi-threaded programs. The correct thing to do is <code>openat</code> file
descriptors, and use the other <code>*at</code> functions where needed. My
understanding, which is very possibly outdated, is that Rust does not
have a stabilized interface for those. So it would require you using
<code>libc</code> and dealing with them directly.</p>
<p>For context, I help maintain GNU coreutils. There we use the <code>fts</code> APIs
which originated in 4.4BSD for <code>chmod</code>, <code>chown</code>, <code>du</code>, etc. [1]. The
tiny catch there is that the version from 4.4BSD and in glibc use
<code>chdir</code> and/or <code>fchdir</code>. GNU coreutils, findutils, and grep import a
version from Gnulib which implements the additional option to use
<code>openat</code> and friends. Obviously, none of those programs use multiple
threads, so you have a bit more to consider.</p>
<blockquote>
<blockquote>
<p>It also seems that rg unnecessarily computes the current working directory for each file processed.</p>
</blockquote>
<p>If ripgrep is actually doing this, then that's a bug that should be fixed independent of the long file path issue. ripgrep should only be asking for the CWD once:</p>
<p>[...]</p>
<p>The CWD is used for matching gitignore patterns in some cases. (Something that GNU grep does not do.) It should probably be the case that if ripgrep doesn't <em>need</em> the CWD, then it shouldn't ask for it. So, e.g., you should be able to run <code>rg --no-ignore</code> and have it not ask for the CWD. But ripgrep isn't smart enough for that today.</p>
</blockquote>
<p>Makes sense, certainly a separate issue and a very uncommon one. I had a
patch for GNU grep to check version control ignores, mostly copied from
<code>tar --exclude-vcs-ignores</code>, but it wasn't fully completed. I think I
used <code>open</code> with the relative path, but getting the current working
directory once is fine.</p>
<p>[1] https://man7.org/linux/man-pages/man3/fts_open.3.html</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2026-01-08 02:43</div>
            <div class="timeline-body"><p>Yeah there is a branch on the walkdir repository with an in progress refactor to use openat. And yes, indeed, it has to use libc directly.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:44:01 UTC
    </footer>
</body>
</html>
