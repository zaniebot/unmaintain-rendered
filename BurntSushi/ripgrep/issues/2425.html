<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add shell completion to the binary itself as one of the options - BurntSushi/ripgrep #2425</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add shell completion to the binary itself as one of the options</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2425">#2425</a>
        opened by <a href="https://github.com/nyurik">@nyurik</a>
        on 2023-02-21 05:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/nyurik">@nyurik</a></div>
            <div class="timeline-body"><h4>Describe your feature request</h4>
<p>Managing separate shell-complete files is tedious, and requires manual steps.  Many tools offer a way to generate shell completion files by running the utility directly, e.g. <code>kubectl completion bash</code> - so I can just add <code>source &lt;(kubectl completion ${SHELL_NAME})</code> to the <code>.shell_defaults</code>.</p>
<p>Could we have something similar please?  Thanks for the best util on the planet :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-02-21 12:01</div>
            <div class="timeline-body"><p>It's an interesting idea. I'm not sure about it though. Are there any cons to doing this? One I can see is that it encourages spawning a new sub-process every time you open an interactive shell. That might not be an issue if it's only one of them, but if every tool does it, then that's probably not great. Of course, you can always put the completions in a file and then source that.</p>
<p>It would indeed remove the need to ruffle through Cargo's target directory, which is not a great experience.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2023-02-21 12:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nyurik">@nyurik</a> on 2023-02-21 17:46</div>
            <div class="timeline-body"><p>@BurntSushi spawning 10-15 processes that each exit within a millisecond is not that big of a deal nowadays, but you are right - it is not optimal.  BUT -- users don't need to -- most of the time, people just call it once during installation (this would be part of the <code>--help</code>):   <code>kubectl completion bash | sudo tee /etc/bash_completion.d/kubectl &gt; /dev/null</code>  (this line is part of the documentation too)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-02-21 18:08</div>
            <div class="timeline-body"><p>It's very very unlikely that a process will actually spawn and exit within a single millisecond. Maybe the process itself only runs for that long, but the actual amount of time you're spent waiting for the process to spawn and exit is usually quite a bit more than 1 millisecond. For example, <code>time cat &lt; /dev/null</code> on my system takes 5 milliseconds, and that's about as fast as it gets. You get 15 of those and you're looking at something that is human perceptible. I've personally found that more than a couple sub-process executions in my shell prompt is too much, and beyond that, I start really noticing the lag.</p>
<blockquote>
<p>BUT -- users don't need to -- most of the time, people just call it once during installation</p>
</blockquote>
<p>Well yes, I said pretty much exactly that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-11-22 19:54</div>
            <div class="timeline-body"><p>This will be closed by #2649.</p>
<p>I actually had forgotten about this request. I was working on removing the dependency on Clap (arg parser) and needed to come up with something different for generating shell completions. I ended up deciding on just having ripgrep do it itself instead of at build time. When it's done at build time, it has to be done as part of the build script, which means some portion of ripgrep needs to be compiled into the build script and then again into the final binary. And then of course, actually <em>finding</em> the files it generates is an unmitigated disaster. I had gone this route with Clap originally because I don't believe it exposed a way to query flag metadata. In any case, with my own custom handling of flags, I was far less restricted and thought it would be operationally much simpler to just have something like <code>rg --generate complete-bash</code> do the right thing. And I did this for the man page too.</p>
<p>So... this will be in the next release!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @BurntSushi on 2023-11-22 21:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rollup</span> added by @BurntSushi on 2023-11-22 21:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2023-11-25 20:03</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:37 UTC
    </footer>
</body>
</html>
