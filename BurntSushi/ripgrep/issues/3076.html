<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`--max-count` not working properly with `--multiline` if matches are on consecutive lines - BurntSushi/ripgrep #3076</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>--max-count</code> not working properly with <code>--multiline</code> if matches are on consecutive lines</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/3076">#3076</a>
        opened by <a href="https://github.com/underflow00">@underflow00</a>
        on 2025-06-24 15:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/underflow00">@underflow00</a></div>
            <div class="timeline-body">Please tick this box to confirm you have reviewed the above.
<ul>
<li>[x] I have a different issue.</li>
</ul>
What version of ripgrep are you using?
<p>ripgrep 14.1.1 (rev 4649aa9700)</p>
<p>features:+pcre2</p>
<p>PCRE2 10.43 is available (JIT is unavailable)</p>
How did you install ripgrep?
<p>Download from https://github.com/BurntSushi/ripgrep/releases/tag/14.1.1</p>
What operating system are you using ripgrep on?
<p>Windows 11</p>
Describe your bug.
<p>For the purpose of limiting count by <code>--max-count</code>, with the mutiline flag, the program seems to be counting matches on consecutive lines as a single match, resulting in extra matches.</p>
What are the steps to reproduce the behavior?
<ol>
<li>Create a file with contents</li>
</ol>
<pre><code>line 2
line 3 x
line 2
line 3
</code></pre>
<ol>
<li>Run <code>rg --max-count=1 -U &quot;line 2\nline 3&quot; &lt;file&gt; --stats --debug</code>.</li>
</ol>
What is the actual behavior?
<pre><code>rg: DEBUG|rg::flags::parse|crates/core\flags\parse.rs:97: no extra arguments found from configuration file
rg: DEBUG|rg::flags::hiargs|crates/core\flags\hiargs.rs:1083: number of paths given to search: 1
rg: DEBUG|rg::flags::hiargs|crates/core\flags\hiargs.rs:1094: is_one_file? true
rg: DEBUG|rg::flags::hiargs|crates/core\flags\hiargs.rs:1269: found hostname for hyperlink configuration: d1
rg: DEBUG|rg::flags::hiargs|crates/core\flags\hiargs.rs:1279: hyperlink format: &quot;&quot;
rg: DEBUG|rg::flags::hiargs|crates/core\flags\hiargs.rs:174: using 1 thread(s)
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: gzip: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: gzip: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: bzip2: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: bzip2: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: xz: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: xz: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: lz4: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: xz: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: brotli: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: zstd: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: zstd: could not find executable in PATH
rg: DEBUG|grep_cli::decompress|crates\cli\src\decompress.rs:502: uncompress: could not find executable in PATH
1:line 2
2:line 3 x
3:line 2
4:line 3

2 matches
4 matched lines
1 files contained matches
1 files searched
38 bytes printed
29 bytes searched
0.000346 seconds spent searching
0.014687 seconds
</code></pre>
What is the expected behavior?
<p>Output only the first 2 lines (1 match).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-06-24 15:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fspv">@fspv</a> on 2025-07-06 16:33</div>
            <div class="timeline-body"><p>It seems like this is intentional: https://github.com/BurntSushi/ripgrep/blob/3b7fd442a6f3aa73f650e763d7cbb902c03d700e/crates/searcher/src/searcher/glue.rs#L237</p>
<p>Matches on the adjacent lines are grouped together and they&#x27;re passed to the sink only after all the matches are found.</p>
<p>If we simply change this condition from &quot;&gt;=&quot; to &quot;&gt;&quot; it works as expected.</p>
<p>If we do that all the tests pass except for this one:</p>
<pre><code>failures:

---- standard::tests::replacement_multi_line stdout ----

thread &#x27;standard::tests::replacement_multi_line&#x27; panicked at crates/printer/src/standard.rs:3432:9:

printed outputs differ!

expected:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1:hello?world?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

got:
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1:hello?
2:world?

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
</code></pre>
<p>This is the test introduced in the issue mentioned in the comment in the code: <a href="https://github.com/BurntSushi/ripgrep/issues/1311">BurntSushi/ripgrep#1311</a></p>
<p>So the fix is simple, but it will break that other use case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fspv">@fspv</a> on 2025-07-06 17:03</div>
            <div class="timeline-body"><p>Just some more thoughts.</p>
<p>Seems like <code>--max-count</code>, which is later referred as <code>max_matches</code> in the code is only used in the sink. But if we merge matches together sink can&#x27;t control how many matches will be passed to it and can only react to the sinked matches. So if we go over the limit, there is nothing that sink can do here.</p>
<p>One way to tackle this issue would be to expose <code>max_matches</code> to the <code>MultiLine</code> Searcher object, count matches there as well and stop early when we reached <code>max_matches</code> even though there might be some more matches on the next line.</p>
<p>This approach should work, but I&#x27;m not sure if it is a good idea from the design point of view.</p>
<p>Example fix: <a href="https://github.com/BurntSushi/ripgrep/pull/3094">BurntSushi/ripgrep#3094</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rollup</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-09-18 19:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-09-20 01:08</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:14 UTC
    </footer>
</body>
</html>
