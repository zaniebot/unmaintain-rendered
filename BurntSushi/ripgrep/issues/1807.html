<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Non-deterministic number of results - BurntSushi/ripgrep #1807</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Non-deterministic number of results</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/1807">#1807</a>
        opened by <a href="https://github.com/minad">@minad</a>
        on 2021-02-26 16:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/minad">@minad</a></div>
            <div class="timeline-body"><h4>What version of ripgrep are you using?</h4>
<p>ripgrep 0.10.0
-SIMD -AVX (compiled)
+SIMD +AVX (runtime)</p>
<h4>How did you install ripgrep?</h4>
<p>apt-get on Debian buster</p>
<h4>What operating system are you using ripgrep on?</h4>
<p>Debian buster on x86_65, Linux 5.4.88</p>
<h4>Describe your bug.</h4>
<p>Give a high level description of the bug.</p>
<h4>What are the steps to reproduce the behavior?</h4>
<ul>
<li>Running <code>rg -j 1 . -e test | sort | uniq | wc</code> always yields the same number of results</li>
<li>In contrast, running <code>rg -j 2 . -e test | sort | uniq | wc</code> yields a different number each time</li>
</ul>
<p>(big corpus)</p>
<h4>What is the actual behavior?</h4>
<p>Non deterministic number of matches</p>
<h4>What is the expected behavior?</h4>
<p>Non deterministic ordering of matches, but deterministic number of matches, no matches should be lost</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-02-26 16:40</div>
            <div class="timeline-body"><p>This isn't actionable without a reproduction. Please find a way to reproduce the problem on a corpus we both have access to.</p>
<p>Also, your version of ripgrep is almost 2.5 years old. I don't provide support for anything other than the most recent version. So you might try the most recent version of ripgrep, although I'm not aware of any changes between the 0.10.0 and 12.1 releases that would impact this particular sort of issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/minad">@minad</a> on 2021-02-26 16:43</div>
            <div class="timeline-body"><p>That's understandable. I see if I can test an updated version. However given that you are not aware of any changes which would affect that I wonder if something like this has been observed before? I mean this looks like a serious threading issue. It could also be a bug on some other layer, kernel, fs or memory problems.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-02-26 16:53</div>
            <div class="timeline-body"><p>It could be a threading issue. Dunno. Or a problem with the parallel file searcher terminating too early. The easiest thing is to try a newer version. If it's fixed, well, then nothing more to do. If not, then yeah, I'll need a repro to do anything about it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-02-26 16:54</div>
            <div class="timeline-body"><p>The github releases for this repo contain a binary debian package you can try. Or even just a the x86_64 tarball has a statically linked executable. No need to compile from source.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/minad">@minad</a> on 2021-02-26 17:05</div>
            <div class="timeline-body"><blockquote>
<p>Or a problem with the parallel file searcher terminating too early.</p>
</blockquote>
<p>Yes, I suspected something like this too. I am trying to narrow down a bit where the problem could be. I am comparing with grep, some of the files are recognized as binary by grep and not counted. In contrast ripgrep counts them. I am not familiar with the ripgrep internals, does it split files in chunks and then distribute the chunks over the threads? Maybe this creates problems with the detection of binary files?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/minad">@minad</a> on 2021-02-26 17:14</div>
            <div class="timeline-body"><p>I am observing this issue for example when running rg on my &quot;.emacs.d/elpa&quot; folder. When running <code>rg -j2</code> the string &quot;test&quot; matches some info files, which are recognized as binary by grep. Exactly the same files are ignored by <code>rg -j1</code>, since probably rg also recognizes them as binary. But in the multithreaded version the second chunk could match before the first thread detects that the file is binary. Does that sound plausible?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-02-26 19:42</div>
            <div class="timeline-body"><p>No, ripgrep's parallelism only happens at the granularity of files. Parallelism does not exist within a file.</p>
<p>With that said, binary detection is a bit subtle and can change based on the method of searching. For example, ripgrep can search using standard <code>read</code> syscalls or via memory maps, and the binary detection between them differs. However, when doing recursive search, ripgrep should always use standard <code>read</code> syscalls.</p>
<p>Binary detection shouldn't be impacted by parallelism.</p>
<p>If you pass <code>--binary --no-mmap</code> to ripgrep, then it should behave like grep. It should also rule out memory maps being responsible for different binary detection algorithms being employed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/minad">@minad</a> on 2021-02-26 20:16</div>
            <div class="timeline-body"><p>I don't have <code>--binary</code> since my version is too old I guess. With <code>--text</code> I get deterministic results with <code>-j&lt;n&gt;</code> for different <code>n</code>. Using <code>--mmap</code> or <code>--no-mmap</code> does not make a difference. The problem in any case seems to be the binary detection. But I wonder how this can be broken, if as you say, parallelism is done at file granularity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-02-26 21:04</div>
            <div class="timeline-body"><p>Ah I see. Yeah I can't think of anything that would explain what you're
seeing. But my mental model of a 2.5 year old ripgrep is pretty weak. I
think at this point I have to insist that you try the latest release. It
should be easy to do and not require any compilation.</p>
<p>On Fri, Feb 26, 2021, 15:16 Daniel Mendler <a href="mailto:notifications@github.com">notifications@github.com</a> wrote:</p>
<blockquote>
<p>I don't have --binary since my version is too old I guess. With --text I
get deterministic results with -j<n> for different n. Using --mmap or
--no-mmap does not make a difference. The problem in any case seems to be
the binary detection. But I wonder how this can be broken, if as you say,
parallelism is done at file granularity.</p>
<p>â€”
You are receiving this because you commented.
Reply to this email directly, view it on GitHub
<a href="https://github.com/BurntSushi/ripgrep/issues/1807#issuecomment-786871678">https://github.com/BurntSushi/ripgrep/issues/1807#issuecomment-786871678</a>,
or unsubscribe
<a href="https://github.com/notifications/unsubscribe-auth/AADPPYQPAE5PNUVLMKXWMJTTA76TVANCNFSM4YIXV3RQ">https://github.com/notifications/unsubscribe-auth/AADPPYQPAE5PNUVLMKXWMJTTA76TVANCNFSM4YIXV3RQ</a>
.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-01 00:17</div>
            <div class="timeline-body"><p>Closing due to inactivity. Happy to re-open given actionable data.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2021-06-01 00:17</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:18 UTC
    </footer>
</body>
</html>
