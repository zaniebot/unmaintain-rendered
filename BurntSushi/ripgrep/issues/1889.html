<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add `perl` to the benchmarks - BurntSushi/ripgrep #1889</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add <code>perl</code> to the benchmarks</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/1889">#1889</a>
        opened by <a href="https://github.com/NightMachinery">@NightMachinery</a>
        on 2021-06-11 14:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/NightMachinery">@NightMachinery</a></div>
            <div class="timeline-body"><p><code>perl</code> can be used to emulate <code>grep</code>, and it is, well, much more powerful than tools like <code>rg</code> (e.g., we can do the boolean patterns like <code>perl -lne &#x27;/x/ &amp;&amp; !/y/ &amp;&amp; print&#x27;</code>). I was wondering how their performance matches up though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 14:23</div>
            <div class="timeline-body"><p>I don&#x27;t know Perl personally, and I don&#x27;t have any plans to learn it. In theory, if someone wanted to contribute benchmarks for it, then that would be fine. <em>But</em>, given my ignorance, it would be very difficult (or rather, time intensive) for me to be able to check that it&#x27;s an appropriate apples-to-apples comparison.</p>
<p>So I&#x27;d say, if someone wanted to contribute Perl to the benchsuite, then that would be fine. But I think I would want a write-up to come with it that justifies why it&#x27;s apples-to-apples. Even among grep tools, apples-to-apples comparisons are non-trivial and require careful scrutiny of which flags are used: https://github.com/BurntSushi/ripgrep/blob/master/benchsuite/runs/2020-10-14-archlinux-frink/raw.csv</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 14:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 14:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NightMachinery">@NightMachinery</a> on 2021-06-11 14:26</div>
            <div class="timeline-body"><p>Perhaps <code>ack</code> can be used as a stand-in for <code>perl</code>?</p>
<p>Since I don&#x27;t know either <code>perl</code> or <code>ack</code> all that well, I can&#x27;t contribute the benchmark. Hopefully, someone who does will come around.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 14:31</div>
            <div class="timeline-body"><p>ack is too slow. Probably perl is too. From <a href="https://blog.burntsushi.net/ripgrep/">my blog post</a>:</p>
<blockquote>
<p>Notably absent from this list is ack. I chose not to benchmark it because, at the time of writing, ack was much slower than the other tools in this list. However, ack 3 is now in beta and includes some performance improvements, sometimes decreasing search times by half.</p>
</blockquote>
<p><code>ack</code> is also included in the first README benchmark, and you can see that the difference is about an order of magnitude.</p>
<p>If <code>ack</code> is seen as a decent approximation for the speed of <code>perl</code>, then I think this issue is satisfied until someone can show a difference with <code>perl</code> directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 14:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NightMachinery">@NightMachinery</a> on 2021-06-11 14:49</div>
            <div class="timeline-body"><p>It&#x27;s possible <code>ack</code> is not a good stand-in, after all. My naive test shows <code>perl</code> outperforming <code>ripgrep</code>.</p>
<p>Tested on https://github.com/NightMachinary/r_HPfanfiction/tree/master/posts:</p>
<pre><code>arr0 * | time xargs -0 perl -ne &#x27;/time.?loop\b/ &amp;&amp; !/wasteland/ &amp;&amp; print&#x27;

4.32s user 9.65s system 39% cpu 35.761 total; max RSS 3532
</code></pre>
<pre><code>time ( command rg &#x27;time.?loop\b&#x27; | command rg -v &#x27;wasteland&#x27;; )  

2.21s user 13.69s system 22% cpu 1:10.11 total; max RSS 28572
</code></pre>
<pre><code>arr0 * | time (xargs -0 rg &#x27;time.?loop\b&#x27; | command rg -v &#x27;wasteland&#x27;; )

2.53s user 13.60s system 22% cpu 1:11.19 total; max rss 8812
</code></pre>
<pre><code>arr0 * | time (xargs -0 rg &#x27;time.?loop\b&#x27; | cat)  

2.51s user 13.45s system 23% cpu 1:08.77 total; max RSS 8384
</code></pre>
<p>What is strange is that <code>GNU grep</code> is faster than <code>rg</code>, too:</p>
<pre><code>arr0 * | time (xargs -0 ggrep -P &#x27;time.?loop\b&#x27; | cat)  

2.83s user 5.56s system 28% cpu 29.764 total; max RSS 1752
</code></pre>
<hr>
<pre><code>arr0 () { # outputs its ARGV separated by the null char
	print -nr -- &quot;${(pj.\0.)@}&quot;
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 15:41</div>
            <div class="timeline-body"><p>I can&#x27;t reproduce:</p>
<pre><code>$ find ./ -type f -print0 | (time xargs -0 perl -ne &#x27;/time.?loop\b/ &amp;&amp; !/wasteland/ &amp;&amp; print&#x27;) | wc -l

real    2.805
user    2.024
sys     0.756
maxmem  8 MB
faults  0
415
$ find ./ -type f -print0 | (time (xargs -0 rg -j1 &#x27;time.?loop\b&#x27; | rg -v &#x27;wasteland&#x27;)) | wc -l

real    1.230
user    0.523
sys     0.685
maxmem  8 MB
faults  0
415
$ find ./ -type f -print0 | (time (xargs -0 rg &#x27;time.?loop\b&#x27; | rg -v &#x27;wasteland&#x27;)) | wc -l

real    0.880
user    0.802
sys     1.063
maxmem  8 MB
faults  0
415
</code></pre>
<p>And similarly for your commands verbatim:</p>
<pre><code>$ arr0 * | time xargs -0 perl -ne &#x27;/time.?loop\b/ &amp;&amp; !/wasteland/ &amp;&amp; print&#x27; | wc -l
Can&#x27;t open  100,000 word well written HP fic that made you cry at the end..8eznmp.org: No such file or directory at -e line 1, &lt;&gt; line 996.
Can&#x27;t open  Alright bois, let&#x27;s find this war veteran harry.a0eha9.org: No such file or directory at -e line 1, &lt;&gt; line 207375.
Can&#x27;t open  FREE TODAY  Hogwarts Watches - Just pay shipping click here 10 more left...4ou0zj.org: No such file or directory at -e line 1, &lt;&gt; line 22426.
Can&#x27;t open  Please link fics that are about Dumbledore being a mentor to Harry and stuff and teaching him actual stuff like dueling and also new spells.a4fc7p.org: No such file or directory at -e line 1, &lt;
&gt; line 313.
415

real    2.980
user    2.025
sys     0.660
maxmem  8 MB
faults  0

real    2.979
user    0.000
sys     0.004
maxmem  8 MB
faults  0

$ time ( command rg &#x27;time.?loop\b&#x27; | command rg -v &#x27;wasteland&#x27;; ) | wc -l
415

real    0.123
user    0.476
sys     0.604
maxmem  8 MB
faults  0

real    0.122
user    0.002
sys     0.000
maxmem  8 MB
faults  0
</code></pre>
<p>Some other baseline benchmarks:</p>
<pre><code>$ find ./ -type f -print0 | (time (xargs -0 perl -ne &#x27;/ZQZQZQZQZQ/ &amp;&amp; print&#x27;)) | wc -l

real    2.671
user    1.959
sys     0.688
maxmem  8 MB
faults  0
0
$ find ./ -type f -print0 | (time (xargs -0 rg -j1 ZQZQZQZQZQ)) | wc -l

real    1.184
user    0.482
sys     0.683
maxmem  8 MB
faults  0
0
$ time rg ZQZQZQZQZQ

real    0.127
user    0.382
sys     0.592
maxmem  8 MB
faults  0
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2021-06-11 15:43</div>
            <div class="timeline-body"><p>Is your time output saying that it&#x27;s taking 30-60s to search that directory? Are you sure you aren&#x27;t just benchmark disk read times?</p>
<p>Which version of ripgrep are you using?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NightMachinery">@NightMachinery</a> on 2021-06-11 15:55</div>
            <div class="timeline-body"><p>@BurntSushi Yes, it takes around one minute. I have that dir on my external HDD.</p>
<p>Rerunning the tests on my MBP&#x27;s SSD:</p>
<pre><code>❯ find ./ -type f -print0 | (time xargs -0 perl -ne &#x27;/time.?loop\b/ &amp;&amp; !/wasteland/ &amp;&amp; print&#x27;) | wc -l    

xargs -0 perl -ne &#x27;/time.?loop\b/ &amp;&amp; !/wasteland/ &amp;&amp; print&#x27;  4.96s user 8.43s system 24% cpu 53.939 total; max RSS 3436
     415
</code></pre>
<pre><code>❯ find ./ -type f -print0 | (time (xargs -0 rg -j1 &#x27;time.?loop\b&#x27; | rg -v &#x27;wasteland&#x27;)) | wc -l         
( xargs -0 rg -j1 &#x27;time.?loop\b&#x27; | rg -v &#x27;wasteland&#x27;; )  2.32s user 9.48s system 23% cpu 50.950 total; max RSS 8920
     415
</code></pre>
<p>So you&#x27;re right, it seems the benchmarks are problematic on my computer. (The SSD is not that faster, and it still takes almost a minute.)</p>
<hr>
<pre><code>❯ rg --version                                                                                           
ripgrep 12.1.1
-SIMD -AVX (compiled)
+SIMD +AVX (runtime)
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:11 UTC
    </footer>
</body>
</html>
