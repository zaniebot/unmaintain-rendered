<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reading fifo: Output is buffered until fifo writer closes - BurntSushi/ripgrep #2122</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Reading fifo: Output is buffered until fifo writer closes</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2122">#2122</a>
        opened by <a href="https://github.com/spencerwilson">@spencerwilson</a>
        on 2022-01-11 18:39
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/spencerwilson">@spencerwilson</a></div>
            <div class="timeline-body"><h4>What version of ripgrep are you using?</h4>
<p>ripgrep 13.0.0
-SIMD -AVX (compiled)</p>
<h4>How did you install ripgrep?</h4>
<p>brew install ripgrep</p>
<h4>What operating system are you using ripgrep on?</h4>
<p>macOS 11.3
Darwin Kernel Version 20.4.0: Fri Mar  5 01:14:02 PST 2021; root:xnu-7195.101.1~3/RELEASE_ARM64_T8101</p>
<h4>Describe your bug.</h4>
<p>When reading a fifo file and instructed to buffer output by line, ripgrep buffers its output neither by line (as expected) nor by block (as it otherwise supports), but rather until the other end of the fifo is closed.</p>
<p>My use case: I have a large stream (probably hundreds of GB; it's <code>jq --stream -c</code> output on a 13 GB JSON object) that I'm teeing into multiple fifos, each with a single ripgrep reader. I was alerted to this bug when I noticed ever-growing resident set size on the ripgrep processes and delayed output from the ripgreps (their output appeared only when tee closed its end of the fifo).</p>
<h4>What are the steps to reproduce the behavior?</h4>
<pre><code class="language-sh">rm -f yesfifo
mkfifo yesfifo
yes &gt; yesfifo &amp;
rg --line-buffered . yesfifo &gt; rgout &amp;

# Let rg process more than a block worth of input (13 MB on my system)
# During this time, rg never writes to stdout.
# Expectation is that it writes once per line of input.
sleep 0.25

# Terminate `yes`, closing the write end of the FIFO.
# Now rg writes its accumulated output to stdout.
kill %1
</code></pre>
<p>You can increase the sleep duration (but increase disk consumption) to make it easier confirm the lack of stdout writes during the sleep.</p>
<p>I've not verified any issues regarding buffered output when reading regular files.</p>
<h4>What is the actual behavior?</h4>
<p>rg buffers its output until the fifo writer closes.</p>
<h4>What is the expected behavior?</h4>
<p>Behavior described in the manual: rg decides buffering strategy based the terminal environment by default, but that can be overridden with options like <code>--line-buffered</code>. In the example above my expectation is that the output is line buffered.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2022-01-11 19:09</div>
            <div class="timeline-body"><p>I notice that you're also including <code>.</code> in your search. If you remove that, what happens? Similarly, what happens if you pass <code>-j1</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spencerwilson">@spencerwilson</a> on 2022-01-11 20:02</div>
            <div class="timeline-body"><p>Oh, I was under the impression that <code>.</code> is playing the role of the regex pattern, in this argument format:</p>
<pre><code>       rg [OPTIONS] PATTERN [PATH...]
</code></pre>
<p>If I remove <code>.</code> and run <code>rg --line-buffered yesfifo</code> it searches $PWD for the pattern <code>yesfifo</code>. I believe the argument format it's using is the same as above.</p>
<p>If I add <code>-j1</code> I get my &quot;expected behavior&quot;.</p>
<p>These sentences in the manual explains everything:</p>
<pre><code>       ripgrep may use a large amount of memory depending on a few
       factors. Firstly, if ripgrep uses parallelism for search (the
       default), then the entire output for each individual file is
       buffered into memory in order to prevent interleaving matches in
       the output. To avoid this, you can disable parallelism with the -j1
       flag.
</code></pre>
<p>ü§¶‚Äç‚ôÇÔ∏è I'd read this yesterday in a different context and thought &quot;cool, makes sense&quot;. I just failed to recall it when I was working on a subsequent problem.</p>
<p>Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @spencerwilson on 2022-01-11 20:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2022-01-11 20:17</div>
            <div class="timeline-body"><p>Ah I misread your command, whoops. The thing is, if ripgrep is only given a single file (or stream), then it should behave as if you provided <code>-j1</code> automatically. So I think there may actually be a bug here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @BurntSushi on 2022-01-11 20:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-11-24 20:06</div>
            <div class="timeline-body"><p>As far as I can tell, ripgrep is entering into single threaded mode correctly when only one path is given to it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2023-11-24 20:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">invalid</span> added by @BurntSushi on 2023-11-24 20:06</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:30 UTC
    </footer>
</body>
</html>
