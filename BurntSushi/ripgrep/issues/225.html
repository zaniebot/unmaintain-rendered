<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>support searching compressed files using in-process decompression - BurntSushi/ripgrep #225</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>support searching compressed files using in-process decompression</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/225">#225</a>
        opened by <a href="https://github.com/danbst">@danbst</a>
        on 2016-11-08 18:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/danbst">@danbst</a></div>
            <div class="timeline-body"><p>I'd like to use ripgrep for grepping log files, because it's faster then grep. But my logs are gzipped, and if I <code>zcat | rg</code> them I'll loose log filenames in output.</p>
<p>Also, would be great if bzip2 and xz decompressors will be supported too with automatic archive type detection.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2016-11-09 22:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-09 22:34</div>
            <div class="timeline-body"><p>I'm torn on this one for both pragmatic and philosophical reasons.</p>
<p>Philosophically, this is making ripgrep do a lot more than just &quot;open a file and search it.&quot; I don't actually believe that ripgrep should do everything, even though it already does a lot. Nevertheless, it's hard to argue with the usefulness of this feature.</p>
<p>Practically speaking, there are two primary issues as I see it:</p>
<ol>
<li>If we wanted to implement this right now, we'd need to bring in C libraries. While there's no hard requirement against doing this (to my knowledge, as long as the three main platforms are supported), I would like to actively discourage it in the interest of keeping ripgrep pure Rust.</li>
<li>This requires some kind of UX design. How does ripgrep detect compressed files? When it finds them, does it always search them or does a user explicitly need to enable it? How are decompression options, if they exist, controlled? What is &quot;automatic archive type detection&quot;?</li>
</ol>
<p>I think that if we were to do this, it is <em>at least</em> blocked on some initial implementation of #1, since supporting additional text encodings has a lot of overlap with decompressing files before searching in terms of making the core search routines work with it.</p>
<p>With that said, I don't personally see myself working on this any time soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alejandro5042">@alejandro5042</a> on 2016-11-10 05:26</div>
            <div class="timeline-body"><p><em>Brainstorming here...</em></p>
<p>Instead of <code>rg</code> constantly playing catching up on every type of compressed file option, an alternative is to have a plugin system whereby the user can decide what <code>rg</code> does when it encounters a file. For example, <code>rg</code> can look up the extension in a configuration file (or the glob in a <code>.gitattributes</code>-type of file), execute the <code>preprocessor</code> step, runs the search on the results, then deletes it. Alternatively, it can simply stream the output of the command in memory and skip the file writes. Seems like quite a bit of work though....</p>
<p>Anyway, this could also be used to search Word, binary, XML, or other complicated formats; if for example you could turn the complicated format into plain-text format that <code>rg</code> can happily parse.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-10 11:30</div>
            <div class="timeline-body"><p>As the maintainer, I'm not particularly interested in the plugin path, sorry.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danbst">@danbst</a> on 2016-11-11 09:38</div>
            <div class="timeline-body"><p>Ok, I see. Also, I don't think that <code>ripgrep -z</code> will perform much better then zgrep, because decompression takes time and levels the ripgrep speed (unless Rust can magically do faster decompression).</p>
<p>Now, none of <code>ag</code>, <code>rg</code> and <code>zgrep</code> can replace each other - zgrep is faster then ag on compressed files and beats rg, ag can do searches in <code>gzip</code>, <code>zip</code>, <code>lzma</code> and <code>xz</code> (with autodetection), which none of zgrep and rg do, and rg is fastest when no compression is used and your regex feats declared expressivity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-11-11 11:34</div>
            <div class="timeline-body"><blockquote>
<p>I don't think that ripgrep -z will perform much better then zgrep</p>
</blockquote>
<p>That <em>might</em> be true on single files (it really depends on what proportion of time is spent in decompression), but ripgrep can certainly get wins with parallelism.</p>
<blockquote>
<p>Now, none of ag, rg and zgrep can replace each other</p>
</blockquote>
<p>Can we not use this as motivation for adding new features please? I ask this because it will <em>always</em> be true. For example, if you need a POSIX compliant search tool, then neither ripgrep nor ag will suffice. If you need backreferences or lookaround, then ripgrep won't work but <code>grep -P</code> and and <code>ag</code> will. I don't think that will <em>ever</em> change. ripgrep will never be everything to everyone and that's OK.</p>
<p>With that said, it's certainly reasonable to expect some convergence of features. For example, I specifically built ripgrep so that folks could use it for both the &quot;search a large repo of code&quot; and &quot;search very large files&quot; use cases.</p>
<p>I think my initial comment on this issue still stands: this feature is a possibility, but has a few philosophical and practical problems with it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wavexx">@wavexx</a> on 2017-02-02 14:37</div>
            <div class="timeline-body"><p>I would expect at least basic unix stream compressors to be supported (.gz/.bz2/.xz). All editors decompress (and often recompress) those on the fly.</p>
<p>Debian ships share/doc/* files in compressed form when doing so results in space savings. I couldn't do a quick search there, and searching through docs is something I do often. It makes perfect sense to have documentation compressed.</p>
<p>Source is sometimes compressed too. Emacs compresses .el files by default on install as well. Ironically, using emacs ripgrep package I cannot search into an installed emacs lisp files ;)</p>
<p>I expect a performance hit when searching through compressed files, so I don't think that's a problem. My main concern is that I could miss a match because one of the files has been compressed. For text data files, this happens frequently, especially in repositories that need to float over the network.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-02-02 14:41</div>
            <div class="timeline-body"><p>@wavexx I don't think there's any question that this is a desirable feature. Thank you for sharing your use cases though, they're helpful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/moorereason">@moorereason</a> on 2017-02-06 23:17</div>
            <div class="timeline-body"><p>I'm troubleshooting a cups server issue (for 3 days now), and I wish I could use a feature like this.  Some files within the cups installation are gzipped while others are not, and they're scattered all of the place.  So far I've been doing <code>find . -type f -name &quot;*.gz&quot; | xargs zgrep needle</code>, but I'm not finding what I expect to see and feel like I may be missing something.</p>
<p>Regarding the issues Andrew brought up earlier:  1) I'd rather not have ripgrep linked to C libs :-1: and 2) for the UX design, I'd just offer a <code>-z</code> option and have ripgrep work in &quot;zip-only&quot; mode.  That would be good enough for my use.</p>
<p>I'm a nobody, but my vote is to freeze this issue until pure-Rust compression libs are available and then re-evaluate this idea at that point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">icebox</span> added by @BurntSushi on 2017-03-13 01:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rik">@rik</a> on 2017-03-21 14:21</div>
            <div class="timeline-body"><p>On macOS, zgrep is the 2.5.1 BSD version. <a href="http://jlebar.com/2012/11/28/GNU_grep_is_10x_faster_than_Mac_grep.html">BSD grep is noticeably slower than GNU grep</a>. I haven't found a way to easily install the GNU version so it would be nice to have a fast and convenient to grep directories of compressed log files.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-23 10:57</div>
            <div class="timeline-body"><p>@rik I think you can install the GNU tools through <code>brew</code>? (I'm not a Mac user though, so don't take my word for it. I think you wind up needing to use <code>ggrep</code> for GNU grep, for example.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rik">@rik</a> on 2017-03-23 11:33</div>
            <div class="timeline-body"><p>Sorry, I should have mentioned that I've looked into <a href="https://github.com/Homebrew/homebrew-dupes">Homebrew/homebrew-dupes</a>. Yes you can do that but that only installs <code>grep</code>, not <code>zgrep</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Xenofex">@Xenofex</a> on 2017-04-20 04:52</div>
            <div class="timeline-body"><p>I use ag and sift for my everyday search, not rg just because it doesn't support gzip. This UX issue matters a lot when I do a lot of log search as a sysadmin. Generally log files are larger than code files. Now I have 3.6GB gzipped log files to search frequently, where the raw speed of a search tool really shines. As of my code, I don't really matter if it is ag, sift or rg, because every of them gives me the result fast enough.</p>
<p>As a search utility focusing on speed, I think log file search should be its target use case, where your effort devoted really helps.</p>
<p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wavexx">@wavexx</a> on 2017-07-04 13:09</div>
            <div class="timeline-body"><p>To follow up on my previous comment, and to make a recommendation, it would be nice if ripgrep would just use readily available stream compressors directly as a co-process instead of embedding a decompression library. Although for small files the fork might incur in some penalty, it's unlikely ripgrep will ever be faster than pbzip2, with the advantage that you gain instant access to all common unix formats at once (you only need an extension/compressor map). You could always specialize z/gz later on to gain advantage for small scattered files.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lnicola">@lnicola</a> on 2017-07-04 13:11</div>
            <div class="timeline-body"><p>@wavexx Please don't. Not everyone is on Linux etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wavexx">@wavexx</a> on 2017-07-04 13:23</div>
            <div class="timeline-body"><p>On Tue, Jul 04 2017, Laurentiu Nicola wrote:</p>
<blockquote>
<p>@wavexx Please don't. Not everyone is on Linux etc.</p>
</blockquote>
<p>My suggestion does not preclude an embedded library. But it does have a
massive advantage on unix systems. There are several variants of popular
stream compressors with varying tradeoffs of memory/speed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-07-04 13:52</div>
            <div class="timeline-body"><p>@wavexx Thanks for the suggestion. I'm somewhat attracted to it. Since this ticket seems to be tracking general decompression support, I've created a more focused implementation specific ticket: #539. I'm not sure when I personally will be able to work on it, but I would be happy to mentor it. I think anyone with some Rust experience could probably do it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2017-09-24 03:59</div>
            <div class="timeline-body"><p>@BurntSushi This ticket and #539 have been stagnant for a while. Earlier in this thread you mentioned:</p>
<blockquote>
<p>If we wanted to implement this right now, we'd need to bring in C libraries. While there's no hard requirement against doing this (to my knowledge, as long as the three main platforms are supported), I would like to actively discourage it in the interest of keeping ripgrep pure Rust.</p>
</blockquote>
<p>Yet, given how long this feature has been stalled, should you not just bite the bullet and pull in the libraries?</p>
<p>This feature is a deal-breaker for myself, others that I know, and some in this very thread. It doesn't seem that keeping ripgrep &quot;pure Rust&quot; is worth the trouble at this point, esp. considering that this could have been implemented already.</p>
<p>Just my 2¢.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 04:24</div>
            <div class="timeline-body"><p>You aren't considering the maintenance burden of bringing in C code. I'm not inclined to change course at this time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2017-09-24 04:50</div>
            <div class="timeline-body"><p>@BurntSushi But it would be a small amount, no? Does Rust not support an FFI to C to ease this sort of thing?</p>
<p>Also, as an aside, I believe that the &quot;burden&quot; of C is <em>very much</em> overstated these days. It's not as bad as most people make it sound...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lnicola">@lnicola</a> on 2017-09-24 06:57</div>
            <div class="timeline-body"><p>@BurntSushi Maybe soon: https://github.com/alexcrichton/flate2-rs/issues/67</p>
<p>@ylluminarious</p>
<blockquote>
<p>Also, as an aside, I believe that the &quot;burden&quot; of C is very much overstated these days. It's not as bad as most people make it sound...</p>
</blockquote>
<p>You're probably right, but some people oppose to it on principle. Also, on Windows, it's still somewhat awkward at times (but those are bugs of course, and could/should be fixed).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jdanford">@jdanford</a> on 2017-09-24 07:12</div>
            <div class="timeline-body"><p>@ylluminarious</p>
<blockquote>
<p>But it would be a small amount, no?</p>
</blockquote>
<p>You're probably right, so why don't you just submit a pull request that adds the necessary libraries and glue code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 11:11</div>
            <div class="timeline-body"><p>I did not say it would be hard to implement. I said it would increase
<em>maintenance</em> costs. Right now, the build process is simple because
everything is in Rust.</p>
<p>I'm not opposed to this on principle. I'm on mobile so I don't have a link,
but someone has already tried to add support for this in a PR. There's some
discussion on that PR that I would encourage you to read.</p>
<p>On Sep 24, 2017 3:12 AM, &quot;Jordan Danford&quot; <a href="mailto:notifications@github.com">notifications@github.com</a> wrote:</p>
<blockquote>
<p>@ylluminarious <a href="https://github.com/ylluminarious">https://github.com/ylluminarious</a></p>
<p>But it would be a small amount, no?</p>
<p>You're probably right, so why don't you just submit a pull request that
adds the necessary libraries and glue code?</p>
<p>—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub
<a href="https://github.com/BurntSushi/ripgrep/issues/225#issuecomment-331692068">https://github.com/BurntSushi/ripgrep/issues/225#issuecomment-331692068</a>,
or mute the thread
<a href="https://github.com/notifications/unsubscribe-auth/AAb34s80eT9ArGfGN0c8wGrfkhwF3G4Bks5slgDkgaJpZM4KsvZm">https://github.com/notifications/unsubscribe-auth/AAb34s80eT9ArGfGN0c8wGrfkhwF3G4Bks5slgDkgaJpZM4KsvZm</a>
.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 11:14</div>
            <div class="timeline-body"><p>@jdanford</p>
<blockquote>
<p>You're probably right, so why don't you just submit a pull request that adds the necessary libraries and glue code?</p>
</blockquote>
<p>Let us please try to keep things friendly here. I would rather someone not put in the work to add this unless it has a good chance of getting merged (unless they are explicitly okay with doing it regardless of the result).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 12:57</div>
            <div class="timeline-body"><p>I'd like to note that #539 exists as an implementation path, and the amount of work required to implement that is roughly on par with bringing in C libraries IMO.</p>
<p>See PR #305, which has more details.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2017-09-24 18:04</div>
            <div class="timeline-body"><p>@jdanford</p>
<blockquote>
<p>why don't you just submit a pull request[...]?</p>
</blockquote>
<p>As @BurntSushi mentioned, I do not want to put in time for such a feature unless it's likely to get accepted and merged.</p>
<hr />
<p>@lnicola Thanks a lot for sharing https://github.com/alexcrichton/flate2-rs/issues/67 -- intriguing stuff with obvious usefulness here.</p>
<p>Also, yes, it is possible that things could be awkward on Windoze, but as you mention, hopefully that can be worked around / fixed.</p>
<hr />
<p>@BurntSushi Thanks for adding that extra information on #305 and for your thoughts on #539. I had presumed that adding support via C would be easier at this point than via Rust, but that seems incorrect now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jdanford">@jdanford</a> on 2017-09-24 20:36</div>
            <div class="timeline-body"><p>Sorry for my snarky comment! It wasn't constructive, and it seems like everyone's on the same page now anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2017-09-24 20:37</div>
            <div class="timeline-body"><p>@jdanford No offense taken -- it was a valid question.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dieken">@Dieken</a> on 2018-01-28 14:57</div>
            <div class="timeline-body"><p>You can set environment variable <code>GREP</code> to &quot;rg&quot;, then use <code>zgrep/bzgrep/xzgrep -Hn</code> to uncompress and search on .gz/.bz2/.xz/.lzma/.lzo with <code>rg</code>,  I feel this is somewhat enough :-)</p>
<p>Notice <code>/usr/bin/bz*grep</code> and <code>/usr/bin/z*grep</code> on Mac OS X don't support environment variable <code>GREP</code>, BSD tools suck...  You need install <code>gzip</code> and <code>xz</code> with Homebrew.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-30 14:16</div>
            <div class="timeline-body"><p>For anyone watching this issue, the next release of ripgrep will have support for searching compressed files using the <code>-z/--search-zip</code> flag by shelling out to <code>gzip</code>/<code>xz</code>/<code>lzma</code>/<code>bzip2</code> for decompression. Thanks to @balajisivaraman for implementing this! (See #751 and #767.)</p>
<p>I am going to keep this issue open to track in-process decompression, since I suspect we will ultimately want to move to that. However, I don't expect that to happen any time soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Support decompression on the fly" to "support searching compressed files using in-process decompression" by @BurntSushi on 2018-01-30 14:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Boscop">@Boscop</a> on 2018-01-30 15:49</div>
            <div class="timeline-body"><p>Does it work on windows too when 7z is installed?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2018-01-30 16:06</div>
            <div class="timeline-body"><p>@BurntSushi Thanks for the news!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-30 16:08</div>
            <div class="timeline-body"><p>@Boscop I don't know. You need the <code>xz</code>, <code>gzip</code> and <code>bzip2</code> binaries. If they don't exist, then decompression doesn't happen. I tested this in a cygwin environment and it works. If a normal Windows environment requires additional binaries, then someone will need to put in the work to add that support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2018-01-30 16:11</div>
            <div class="timeline-body"><p>@BurntSushi</p>
<blockquote>
<p>You need the xz, gzip and bzip2 binaries.</p>
</blockquote>
<p>We don't need <em>all</em> of those programs for <em>any</em> compressed file, do we? I assume you mean that we need a respective decompression program for a given file type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-30 16:23</div>
            <div class="timeline-body"><p>@ylluminarious Yes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Boscop">@Boscop</a> on 2018-01-30 18:01</div>
            <div class="timeline-body"><p>7z.exe supports all of those.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/albfan">@albfan</a> on 2018-02-20 17:31</div>
            <div class="timeline-body"><p>As maintainer make this configurable can give you lot of headaches, can resist to propose:</p>
<p>https://github.com/BurntSushi/ripgrep/blob/597bf04a56d43aa9c0eb0f8fbb90c9d51c53656c/src/decompressor.rs#L37
https://github.com/BurntSushi/ripgrep/blob/597bf04a56d43aa9c0eb0f8fbb90c9d51c53656c/src/decompressor.rs#L53</p>
<p>so you can config new files to decompress:</p>
<pre><code>--zip-command=&quot;jar:gzip -d -c&quot;</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-21 00:37</div>
            <div class="timeline-body"><p><a href="https://github.com/BurntSushi/ripgrep/issues/225#issuecomment-361605938">On second thought</a>, I'm just going to close this issue, since there isn't much value in tracking it at this point. It will likely be a long time before in-process decompression happens.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2018-02-21 00:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ylluminarious">@ylluminarious</a> on 2018-02-21 05:17</div>
            <div class="timeline-body"><p>@BurntSushi You should probably update your <a href="https://blog.burntsushi.net/ripgrep/#anti-pitch">Anti-Pitch</a> for <code>ripgrep</code> on your blog, saying that search decompression is now possible through external utilities.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:41:53 UTC
    </footer>
</body>
</html>
