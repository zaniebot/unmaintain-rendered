<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carriage return handling on Windows - BurntSushi/ripgrep #416</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Carriage return handling on Windows</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/416">#416</a>
        opened by <a href="https://github.com/BatmanAoD">@BatmanAoD</a>
        on 2017-03-21 17:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BatmanAoD">@BatmanAoD</a></div>
            <div class="timeline-body"><p>On Windows, I noticed two surprising things about carriage returns (<code>\r</code>):</p>
<ul>
<li>They aren&#x27;t treated as word-boundaries (i.e. they won&#x27;t cause the <code>\b</code> anchor to match). This means that <code>rg -w foo</code> fails to find <code>foo</code> at the end of a line in a file with Windows line-endings.</li>
<li>They aren&#x27;t included in the end-of-line anchor <code>$</code>, which makes using the anchor more difficult.</li>
</ul>
<p>I realize that this <em>could</em> be by design, since RipGrep may be using some standard definition of <code>\b</code> that explicitly does not include <code>\r</code>. That seems unintuitive, though, and I don&#x27;t think I&#x27;ve seen that behavior in other regex engines running on Windows (e.g. in Python on Windows).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-21 17:24</div>
            <div class="timeline-body"><blockquote>
<p>They aren&#x27;t treated as word-boundaries (i.e. they won&#x27;t cause the \b anchor to match). This means that rg -w foo fails to find foo at the end of a line in a file with Windows line-endings.</p>
</blockquote>
<p>This doesn&#x27;t seem right. Could you please provide a minimal reproducible example? e.g., This works fine for me:</p>
<pre><code>$ echo -e &#x27;foo\n&#x27; | rg -w foo
1:foo
$ echo -e &#x27;foo\r\n&#x27; | rg -w foo
1:foo
</code></pre>
<blockquote>
<p>They aren&#x27;t included in the end-of-line anchor <code>$</code>, which makes using the anchor more difficult.</p>
</blockquote>
<p>I think GNU grep handles this by stripping <code>\r</code> characters and dealing with the fallout. This seems hard, or at best, very annoying.</p>
<p>The semantics of the regex engine aren&#x27;t going to change, sorry.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-21 17:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-03-21 18:32</div>
            <div class="timeline-body"><p>Hm, you&#x27;re right, I&#x27;m having trouble reproducing the <code>\b</code> issue with test files; I&#x27;ll have to see if I can find out why I&#x27;m having issues with the file I was searching when I discovered the issue.</p>
<p>Regarding <code>$</code>, though, isn&#x27;t the anchor essentially useless on Windows if <code>\r</code> causes a mismatch? <code>echo -e &quot;foo\r\n&quot; | &lt;greptool&gt; &#x27;foo$&#x27;</code> seems to me like it should <em>always</em> match, regardless of the system. (I&#x27;ve checked that on Debian, GNU grep and ack both handle this case appropriately.)</p>
<p>Why not just let the anchor match when a character other than <code>\r</code> is followed by <code>\n</code> <em>or</em> <code>\r\n</code>? (I think you&#x27;re right that this approach is not the one taken by grep, so I realize that there may be a good reason not to take this approach.)</p>
<p>I&#x27;m guessing that this behavior is due to the current behavior of rust-lang/regex ? If so, I can open an issue there, which seems like a more appropriate place (even though you&#x27;re the primary author/contributor on that project as well).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-21 18:39</div>
            <div class="timeline-body"><p>The issue already exists: <a href="https://github.com/rust-lang/regex/issues/244">rust-lang/regex#244</a></p>
<blockquote>
<p>Why not just let the anchor match when a character other than \r is followed by \n or \r\n?</p>
</blockquote>
<p>If you know how to implement this efficiently in a DFA, then please teach me. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-21 20:44</div>
            <div class="timeline-body"><p>Just to be clear, I think the state of affairs is, indeed, unfortunate. It&#x27;s just hard to fix. I can&#x27;t say that it will <em>never</em> get fixed, but I wouldn&#x27;t expect something any time soon.</p>
<p>In the mean time, there are not-ideal workarounds. e.g., <code>echo -e &#x27;foo\r\n&#x27; | rg &#x27;foo\r?$&#x27;</code> works if you&#x27;re in a bind.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-03-21 20:51</div>
            <div class="timeline-body"><p>I was thinking about that--how opposed would you be to introducing an option (possibly via config-file) to automatically replace <code>$</code> in search patterns with <code>\r?$</code>, possibly only under certain conditions (e.g. only when running on Windows, or when the last two characters in the first candidate file are <code>\r\n</code>)? I think this would only cause unintended side-effects when paired with a flag (such as <code>-o</code>) that changes the output text depending on whether or not the <code>\r</code> is included in the match.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-21 21:12</div>
            <div class="timeline-body"><p>ripgrep doesn&#x27;t have a config file. I&#x27;d rather folks work around it for now. I&#x27;m not strongly against your heuristic, but we&#x27;d need to be careful that it doesn&#x27;t introduce any additional weirdness.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-03-22 17:29</div>
            <div class="timeline-body"><p>Makes sense. Thanks for considering this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-03-23 08:06</div>
            <div class="timeline-body"><p>Ah, I&#x27;ve figured out my issue with word-boundaries--for some reason I was expecting <code>\b</code> to zero-length match between <code>(</code> and <code>\r</code>. I found that <code>rg -w &#x27;&lt;pattern&gt;\(&#x27;</code> wasn&#x27;t finding anything whereas I <em>did</em> find what I was looking for without the <code>-w</code> flag. But of course left-paren isn&#x27;t a word character.</p>
<p>/shame</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-23 10:44</div>
            <div class="timeline-body"><p>@BatmanAoD No worries, word boundaries are hard. See also #389.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-03-31 06:12</div>
            <div class="timeline-body"><p>I&#x27;m looking into modifying the regex crate to handle <code>\r</code> and <code>\r\n</code> as newlines, but I&#x27;ve discovered that in the current implementation, <code>^$</code> actually matches the newline at the end of a file, probably because the end-of-line flag is set whenever the iterator reaches the end of the file, regardless of the actual final bytes in the file--and of course <code>\n</code> causes the beginning-of-line flag to be set. (At least, I <em>think</em> that&#x27;s why it&#x27;s happening--I haven&#x27;t actually done anything to verify that this explanation is correct.)</p>
<p>Would you consider this a bug in <code>regex</code>? If so, I believe it can probably be fixed by tweaking the end-of-file flag-setting logic. (An off-the-cuff suggestion: perhaps the start-of-line flag needs to be prohibited at end-of-file, regardless of what the last byte is. I&#x27;m not sure what the value is in having <code>^</code> match when there&#x27;s nothing left to read in the file.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2017-03-31 06:57</div>
            <div class="timeline-body"><p>Somewhat related: I&#x27;m not sure I understand exactly what the &quot;reverse&quot; matching logic is for or how it works. Is it just what&#x27;s described in rust-lang/regex#190? Does the engine construct a DFA designed (guaranteed?) to find the same matches when applied backwards that the &quot;normal&quot; DFA would find when applied forwards?</p>
<p>If so, then with regard to this particular issue, it might actually make my proposed fix infeasible (or at least more complicated than I&#x27;d like), unless I&#x27;m misunderstanding something. When running the DFA forward, <code>$</code> should anchor immediately before the current character-index if the character is <code>\n</code> and the previous character <em>isn&#x27;t</em> <code>\r</code>, but in reverse, <code>$</code> should anchor after <code>\n</code> unless the <em>next</em> character to be observed (i.e. the one right before <code>\n</code> in the input file) isn&#x27;t <code>\r</code>. Based on the precedent set by the word-boundary logic, the way to handle this multi-character anchor dependency is via a special flag in <code>StateFlags</code>. But the actual logic to assign the flags for the typical case is in <code>exec_byte</code>, which (as far as I can tell) is intentionally designed not to have any special behavior for the reverse match. Moreover, there&#x27;s not really any way that I can see to look <em>ahead</em> in the search, which I think would be necessary in the reverse case.</p>
<p>Tangentially: I haven&#x27;t taken even a cursory look at the code to answer this for myself, but how is ripgrep processing input before feeding it to the regex crate? I&#x27;ve previously assumed that the reason <code>ack</code> can&#x27;t support multi-line matching is because it reads a single line at a time and applies the search pattern to each line individually, and ripgrep has the same restriction--but if ripgrep were doing the line-splitting, I&#x27;d have expected you to suggest modifying <em>that</em> logic somehow to resolve the <code>$</code> issue (or possibly to explain why that wouldn&#x27;t work--though maybe that&#x27;s what you meant when you mentioned that unilaterally stripping <code>\r</code> from input seems &quot;hard, or at best, very annoying&quot;).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-31 09:26</div>
            <div class="timeline-body"><p>It sounds like you are understanding why this is hard to fix in the regex engine. I&#x27;d prefer if we discussed the regex engine on the regex repo.</p>
<blockquote>
<p>Tangentially: I haven&#x27;t taken even a cursory look at the code to answer this for myself, but how is ripgrep processing input before feeding it to the regex crate?</p>
</blockquote>
<p>http://blog.burntsushi.net/ripgrep/#mechanics</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-08 00:21</div>
            <div class="timeline-body"><blockquote>
<p>I did test that this doesn&#x27;t match Perl&#x27;s behavior. And for a grep tool like ripgrep, it is simply wrong, because finding empty lines is sometimes useful, and a false positive at the end of every file is not helpful. That doesn&#x27;t mean that the behavior of this crate needs to change, since ripgrep could simply work around the issue, but you did direct me this way when I mentioned it on the ripgrep issue tracker... ðŸ˜• Either way, I am strongly of the opinion that ripgrep&#x27;s behavior should match grep&#x27;s for this case.</p>
</blockquote>
<p>Please motivate this with use cases and examples. Reasoning about this in the abstract will probably never convince me that anything needs to be changed. (This also seems orthogonal to <code>\r\n</code> handling, so it should probably get a new issue, please.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-08 00:30</div>
            <div class="timeline-body"><p>@BatmanAoD I created #441</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">icebox</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 22:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-25 20:27</div>
            <div class="timeline-body"><p>@BatmanAoD I think I see how this might be fixed for most use cases, at least in ripgrep. It won&#x27;t hit everything, but:</p>
<ol>
<li>Take your idea of replacing <code>$</code> with <code>(?:\r?$)</code> (except done at the HIR level). Semantically, this should never turn something that was a match into a non-match, but could turn non-matches into a match (which is, of course, the intended effect).</li>
<li>When matches are reported, if the match ends with a <code>\r</code>, then trim it.</li>
</ol>
<p>I think I might be able to roll this into libripgrep. In particular, I am also going to try and take a crack at #389, and the solutions have a similarish feel.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2018-06-25 23:30</div>
            <div class="timeline-body"><p>Note, of course, that in order to be entirely correct, <code>\r</code> should only be trimmed if it was matched due to <code>$</code> rather than with <code>.</code>, a literal <code>\r</code>, or something else along those lines. I&#x27;m not sure how difficult that part is, or whether it really matters.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-25 23:52</div>
            <div class="timeline-body"><p>@BatmanAoD In line oriented mode, a <code>.</code> can never match a <code>\n</code>, and this is enforced. Similarly, you cannot search for a literal <code>\n</code> either (try <code>rg &#x27;\n&#x27;</code>), so we should probably do the same for <code>\r</code> which seems fine to me. (This will be an opt-in in a new crate I&#x27;m building as part of libripgrep.)</p>
<p>Getting this right in multiline mode (again, will be a new thing part of libripgrep, it&#x27;s already implemented) is trickier since matching <code>\n</code> (or <code>\r</code>) is explicitly allowed. But I think we&#x27;ll either need to choose to sacrifice correctness or raise an error if this special CRLF handling and multi line mode are enabled at the same time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2018-06-28 21:27</div>
            <div class="timeline-body"><p>Is libripgrep being developed in a separate repository? Perhaps I could try implementing that solution?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-28 22:28</div>
            <div class="timeline-body"><p>@BatmanAoD That&#x27;s probably not a good idea. As far as my open source work goes, I basically don&#x27;t like collaborating when code is in a nascent state. There is just waaaaay too much context in my brain. It would take days to unload, and everything could switch at a moment&#x27;s notice as I&#x27;m developing. I think this blog packages my thoughts in a neat little bow: http://habitatchronicles.com/2004/04/you-cant-tell-people-anything/</p>
<p>With that said, I do occasionally push my progress to the ag/libripgrep branch: https://github.com/BurntSushi/ripgrep/tree/ag/libripgrep --- Beware though, I sometimes force push!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-06-28 22:57</div>
            <div class="timeline-body"><p>And I have made sure to incorporate CRLF stripping as well: https://github.com/BurntSushi/ripgrep/blob/4d6fba44d3b5786517225aa6dcb20a0035be82f9/grep-regex/src/strip.rs#L8-L10</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2018-06-29 20:32</div>
            <div class="timeline-body"><p>I believe I understand!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-16 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">libripgrep</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-16 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">icebox</span> removed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-16 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-16 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;libripgrep&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-16 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-20 11:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sergeevabc">@sergeevabc</a> on 2020-02-27 11:34</div>
            <div class="timeline-body"><p>Being a Windows user with ripgrep 11.0.2 on board, Iâ€™m a bit confused about this CRLF thing.</p>
<pre><code>printf &quot;1931. Arrowsmith&quot; | rg &quot;(\d+)..(.*)&quot; -r &quot;$2 $1&quot;
Arrowsmith 1931               &lt;--- as expected, but printf is not a part of Windows 

echo 1931. Arrowsmith | rg &quot;(\d+)..(.*)&quot; -r &quot;$2 $1&quot;
 1931smith                    &lt;--- weird misplacement

echo 1931. Arrowsmith | rg &quot;(\d+)..(.*)&quot; -r &quot;$2 $1&quot; --crlf
Arrowsmith  1931              &lt;--- extra space in between
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-02-27 12:30</div>
            <div class="timeline-body"><p>I cannot reproduce on Linux:</p>
<pre><code>$ printf &quot;1931. Arrowsmith&quot; | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27;
Arrowsmith 1931

$ echo 1931. Arrowsmith | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27;
Arrowsmith 1931

$ echo 1931. Arrowsmith | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27; --crlf
Arrowsmith 1931
</code></pre>
<p>OK, so I&#x27;m assuming that <code>echo</code> on Windows probably emits a <code>\r\n</code> as a new line, so let&#x27;s try that:</p>
<pre><code>$ printf &quot;1931. Arrowsmith\r\n&quot; | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27;
 1931smith
</code></pre>
<p>It&#x27;s quite likely here that <code>(.*)</code> is matching the <code>\r</code> so the replacement actually winds up being <code>Arrowsmith\r 1931</code>. We can confirm this by looking at the hex output:</p>
<pre><code>$ printf &quot;1931. Arrowsmith\r\n&quot; | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27; | xxd
00000000: 4172 726f 7773 6d69 7468 0d20 3139 3331  Arrowsmith. 1931
00000010: 0a
</code></pre>
<p>You can see the <code>0d</code> in there, which corresponds to <code>\r</code>. The strange output is actually what one expects:</p>
<pre><code>$ echo &#x27;Arrowsmith\r 1931&#x27;
 1931smith
</code></pre>
<p>Because <code>\r</code> will move the cursor position back to the beginning of the line. Subsequent printing then overwrites characters that were already printed. e.g.,</p>
<pre><code>$ echo &#x27;Arrowsmith\r 1931X&#x27;
 1931Xmith

$ echo &#x27;Arrowsmith\r 1931XX&#x27;
 1931XXith

$ echo &#x27;Arrowsmith\r 1931XXX&#x27;
 1931XXXth
</code></pre>
<p>Adding the <code>--crlf</code> flag seemingly gets this right:</p>
<pre><code>$ printf &quot;1931. Arrowsmith\r\n&quot; | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27; --crlf
Arrowsmith 1931
</code></pre>
<p>Confirming with <code>xxd</code> that there is a single space:</p>
<pre><code>$ printf &quot;1931. Arrowsmith\r\n&quot; | rg &#x27;(\d+)..(.*)&#x27; -r &#x27;$2 $1&#x27; --crlf | xxd
00000000: 4172 726f 7773 6d69 7468 2031 3933 310d  Arrowsmith 1931.
00000010: 0a
</code></pre>
<p>Notice that there is only one <code>0x20</code> byte there. So I can&#x27;t reproduce your issue, at least on Linux, and in theory, the above should be equivalent to what you&#x27;re doing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sergeevabc">@sergeevabc</a> on 2020-02-27 12:56</div>
            <div class="timeline-body"><p>@BurntSushi, I guess, Linux <code>echo</code> is different from Windows <code>echo</code>, thatâ€™s whyyouâ€™re partly unable to reproduce the issue. Thatâ€™s unfortunate for me, because the third example <a href="https://github.com/BurntSushi/ripgrep/issues/416#issuecomment-591925122">shows</a> <code>--crlf</code> produces unexpected extra space in the middle. Also let me provide the output of <code>xxd</code>.</p>
<pre><code>echo 1931. Arrowsmith | rg &quot;(\d+)..(.*)&quot; -r &quot;$2 $1&quot; --crlf | xxd
00000000: 4172 726f 7773 6d69 7468 2020 3139 3331  Arrowsmith  1931
00000010: 0d0a                                     ..
                                                              ^ that weird extra space
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-02-27 13:04</div>
            <div class="timeline-body"><p>It will have to wait until I have a chance to debug this on Windows. Or else someone else should feel free to debug it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-02-27 13:07</div>
            <div class="timeline-body"><p>Also not sure why you&#x27;re reporting bugs on closed tickets. This makes it impossible to track. I created #1500 for you. Please just do that next time.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:03 UTC
    </footer>
</body>
</html>
