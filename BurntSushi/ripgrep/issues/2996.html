<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bytes_searched is inaccurate - BurntSushi/ripgrep #2996</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>bytes_searched is inaccurate</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2996">#2996</a>
        opened by <a href="https://github.com/amorey">@amorey</a>
        on 2025-02-23 05:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amorey">@amorey</a></div>
            <div class="timeline-body"><h3>Please tick this box to confirm you have reviewed the above.</h3>
<ul>
<li>[x] I have a different issue.</li>
</ul>
<h3>What version of ripgrep are you using?</h3>
<p>ripgrep 14.1.1</p>
<h3>How did you install ripgrep?</h3>
<p>homebrew</p>
<h3>What operating system are you using ripgrep on?</h3>
<p>macOS 15.3.1</p>
<h3>Describe your bug.</h3>
<p>I'm trying to get an accurate reading for <code>bytes_searched</code> but I noticed that it increments in large steps as I adjust <code>--max-count</code>. Is this behavior expected? If so, is there a way to return an accurate value for <code>bytes_searched</code>?</p>
<h3>What are the steps to reproduce the behavior?</h3>
<p>Search for a string in a file and adjust <code>--max-count</code> upwards.</p>
<h3>What is the actual behavior?</h3>
<p>Here are some results for the attached file (<a href="https://github.com/user-attachments/files/18928300/loggen.log">loggen.log</a>):</p>
<pre><code class="language-console">$ rg --stats -m --debug 30 &quot;about&quot; loggen.log
rg: DEBUG|rg::flags::parse|crates/core/flags/parse.rs:97: no extra arguments found from configuration file
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1083: number of paths given to search: 1
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1094: is_one_file? true
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1269: found hostname for hyperlink configuration: mac.lan
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:1279: hyperlink format: &quot;&quot;
rg: DEBUG|rg::flags::hiargs|crates/core/flags/hiargs.rs:174: using 1 thread(s)
rg: DEBUG|grep_regex::config|/private/tmp/ripgrep-20240910-8913-ej3fe9/ripgrep-14.1.1/crates/regex/src/config.rs:175: assembling HIR from 1 fixed string literals
...
30 matches
30 matched lines
1 files contained matches
1 files searched
6088 bytes printed
0 bytes searched
0.000255 seconds spent searching
0.001128 seconds

$ rg --stats -m 31 &quot;about&quot; loggen.log
...
31 matches
31 matched lines
1 files contained matches
1 files searched
6315 bytes printed
65432 bytes searched
0.000245 seconds spent searching
0.001430 seconds

$ rg --stats -m 45 &quot;about&quot; loggen.log
...
45 matches
45 matched lines
1 files contained matches
1 files searched
9290 bytes printed
65432 bytes searched
0.000661 seconds spent searching
0.001768 seconds
</code></pre>
<h3>What is the expected behavior?</h3>
<p>I expected <code>bytes_searched</code> to return the byte position after the last match found in these examples.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-02-23 12:44</div>
            <div class="timeline-body"><p>&quot;bytes searched&quot; is for how many bytes have been searched. It isn't for returning the last position of the match. Moreover, <code>--stats</code> are meant to be summary statistics for diagnostic purposes. They may be inaccurate. The docs should be updated to mention this.</p>
<p>As far as I can tell, the current behavior is correct/intended. Your MRE is not as simple as it could be, but I tried this:</p>
<pre><code>$ rg --stats -m 1 . loggen.log
1:2025-02-07T13:32:24.851999698Z stdout F 78.21.94.129 - - [07/02/2025:13:32:24] &quot;POST /api/v1/settings HTTP/1.1&quot; 200 162 &quot;-&quot; &quot;Mozilla/5.0 (iPhone13,2; U; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Mobile/15E148 Safari/602.1&quot;

268 matches
1 matched lines
1 files contained matches
1 files searched
271 bytes printed
269 bytes searched
0.000030 seconds spent searching
0.000527 seconds
</code></pre>
<p>And then increased the number of matches by 1:</p>
<pre><code>$ rg --stats -m 2 . loggen.log
1:2025-02-07T13:32:24.851999698Z stdout F 78.21.94.129 - - [07/02/2025:13:32:24] &quot;POST /api/v1/settings HTTP/1.1&quot; 200 162 &quot;-&quot; &quot;Mozilla/5.0 (iPhone13,2; U; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) Version/10.0 Mobile/15E148 Safari/602.1&quot;
2:2025-02-07T13:32:26.441555379Z stdout F 123.25.44.1 - - [07/02/2025:13:32:26] &quot;GET /settings HTTP/1.1&quot; 200 162 &quot;-&quot; &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/12.246&quot;

512 matches
2 matched lines
1 files contained matches
1 files searched
518 bytes printed
514 bytes searched
0.000064 seconds spent searching
0.000805 seconds
</code></pre>
<p>Getting the length of the second line and adding it to the number of bytes searched from the first example gives the same result as ripgrep:</p>
<pre><code>&gt;&gt;&gt; len('2025-02-07T13:32:26.441555379Z stdout F 123.25.44.1 - - [07/02/
2025:13:32:26] &quot;GET /settings HTTP/1.1&quot; 200 162 &quot;-&quot; &quot;Mozilla/5.0 (Window
s NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.
0.2311.135 Safari/537.36 Edge/12.246&quot;\n')
245
&gt;&gt;&gt; 269 + 245
514
</code></pre>
<p>(Note: the <code>len</code> function only works for our purposes here because the string is all ASCII. If it had non-ASCII, you'd want an <code>encode('utf-8')</code> at the end.)</p>
<p>It is technically true that ripgrep could stop searching after finding that first match based on the options provided. However, this is not actually the case here, because for me, I have colors enabled. And so ripgrep does actually search the entire line to figure out what it should highlight. Having the &quot;bytes searched&quot; statistic match what ripgrep does precisely here does not seem worth the trouble and I'm unlikely to make such a change.</p>
<p>If you're looking for the offset of the last match, you might be interested in using <code>--json</code>. You can also use the <code>--byte-offset</code> flag.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2025-02-23 12:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amorey">@amorey</a> on 2025-02-23 14:15</div>
            <div class="timeline-body"><p>Thanks! <code>--byte-offset</code> is exactly what I was looking for. Sorry I missed it in the flag descriptions.</p>
<p>I have some related questions (happy to post elsewhere if that's more appropriate):</p>
<ol>
<li><p>I'm working on a docker log search tool where log lines are stored in JSON or in a text format like this: <code>&lt;ISO8601 timestamp&gt; stdout F &lt;message&gt;</code>. When performing a search I only want to match on <code>&lt;message&gt;</code> but I want to send the original line to the sink. Does <code>rg</code> have a built-in way to do this? I have it working with a custom <code>Matcher</code> that wraps <code>RegexMatcher</code> but maybe there's a better way.</p>
</li>
<li><p>Does <code>rg</code> have a built-in way to search line-by-line backwards through a file?</p>
</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-02-23 14:33</div>
            <div class="timeline-body"><blockquote>
<p>Does rg have a built-in way to search line-by-line backwards through a file?</p>
</blockquote>
<p>No. You probably want <code>tac</code> for this.</p>
<blockquote>
<p>I'm working on a docker log search tool where log lines are stored in JSON or in a text format like this: <code>&lt;ISO8601 timestamp&gt; stdout F &lt;message&gt;</code>. When performing a search I only want to match on <code>&lt;message&gt;</code> but I want to send the original line to the sink. Does <code>rg</code> have a built-in way to do this? I have it working with a custom <code>Matcher</code> that wraps <code>RegexMatcher</code> but maybe there's a better way.</p>
</blockquote>
<p>Nothing beyond just using regex. So if you have a pattern <code>p</code> to match on <code>messasge</code>, you would create a new pattern <code>[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z stdout F {p}</code>, where <code>{p}</code> is substituted by the actual pattern you want to match against <code>message</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amorey">@amorey</a> on 2025-02-23 16:33</div>
            <div class="timeline-body"><blockquote>
<p>Nothing beyond just using regex. So if you have a pattern p to match on messasge, you would create a new pattern [0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}Z stdout F {p}, where {p} is substituted by the actual pattern you want to match against message.</p>
</blockquote>
<p>I wanted to avoid using regex for the prefix for performance reasons. In my current implementation I'm using <code>memchr</code> to find &quot;stdout F&quot; and then sending the rest to a RegexMatcher like this:</p>
<pre><code class="language-rust">use grep::{
    matcher::{self, Match, Matcher},
    regex::{self, RegexMatcher, RegexMatcherBuilder},
};
use memchr::memmem;

pub struct LogFileRegexMatcher {
    inner: RegexMatcher,
}

impl LogFileRegexMatcher {
    pub fn new(inner_pattern: &amp;str) -&gt; Result&lt;LogFileRegexMatcher, regex::Error&gt; {
        let inner = RegexMatcherBuilder::new()
            .line_terminator(Some(b'\n'))
            .case_smart(false)
            .case_insensitive(false)
            .build(inner_pattern)?;
        Ok(LogFileRegexMatcher { inner })
    }
}

impl Matcher for LogFileRegexMatcher {
    type Captures = regex::RegexCaptures;
    type Error = matcher::NoError;

    fn find_at(&amp;self, haystack: &amp;[u8], start: usize) -&gt; Result&lt;Option&lt;Match&gt;, Self::Error&gt; {
        // Start + 19 starts looking after the non-decimal part of ISO8601 timestamp
        if let Some(offset) = find_log_message_start(haystack, start + 19) {
            self.inner.find_at(haystack, offset)
        } else {
            Ok(None)
        }
    }

    fn new_captures(&amp;self) -&gt; Result&lt;Self::Captures, Self::Error&gt; {
        self.inner.new_captures()
    }
}

fn find_log_message_start(haystack: &amp;[u8], start: usize) -&gt; Option&lt;usize&gt; {
    if start &gt;= haystack.len() {
        return None;
    }

    // Define the literal part that follows the timestamp.
    // The prefix is: &quot;&lt;ISO8601 timestamp&gt; stdout f &quot;
    // We assume the timestamp is of variable length and we just search for &quot; stdout f &quot;.
    let literal = b&quot; stdout F &quot;;
    // Search for the literal in the haystack.
    memmem::find(&amp;haystack[start..], literal).map(|pos| start + pos + literal.len())
}
</code></pre>
<p>It seems to work but I'm not sure if I'll run into problems with edge cases. Does this approach look ok to you? Could I do something similar with JSON logs and unwrap them before sending the inner message to a <code>RegexMatcher</code> instance?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-02-23 16:53</div>
            <div class="timeline-body"><blockquote>
<p>I wanted to avoid using regex for the prefix for performance reasons.</p>
</blockquote>
<p>Could you actually see a perf difference? For a regex like that with a literal, it <em>should</em> be very fast.</p>
<p>I think your code looks okay? I'm not really context switched into ripgrep's internals enough to say with confidence though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amorey">@amorey</a> on 2025-02-23 21:27</div>
            <div class="timeline-body"><p>Nonscientifically, on my MacBook Air M3 searching for a non-existent phrase in a 1GB file I'm seeing:</p>
<ul>
<li>using single regex: ~1.3 sec</li>
<li>using find_log_message_start(): ~0.3 sec</li>
</ul>
<p>Note that I modified <code>find_log_message_start()</code> so it looks for the first empty space and then jumps ahead past &quot;stdout F&quot; which should be slightly faster than the previous version.</p>
<p>Here's the code for the single regex:</p>
<pre><code class="language-rust">use std::process::ExitCode;

use grep::cli::stdout;
use grep::printer::StandardBuilder;
use grep::regex::RegexMatcherBuilder;
use grep::searcher::SearcherBuilder;
use grep_searcher::MmapChoice;
use termcolor::ColorChoice;

pub fn run(path: &amp;str, query: &amp;str, first: &amp;u64) -&gt; ExitCode {
    let prefix = &quot;Z.*stdout F &quot;;
    let combined_pattern = format!(r&quot;{}.*{}&quot;, prefix, query);
    let matcher = RegexMatcherBuilder::new()
        .line_terminator(Some(b'\n'))
        .case_smart(false)
        .case_insensitive(false)
        .build(&amp;combined_pattern)
        .unwrap();

    let mut searcher = SearcherBuilder::new()
        .line_number(false)
        .memory_map(MmapChoice::never())
        .build();

    let stdout = stdout(ColorChoice::Never);

    let mut printer = StandardBuilder::new()
        .max_matches(Some(*first))
        .byte_offset(true)
        .build(stdout);

    let mut sink = printer.sink(&amp;matcher);

    let _ = searcher.search_path(&amp;matcher, path, &amp;mut sink);

    ExitCode::SUCCESS
}
</code></pre>
<p>For JSON log lines, could I extract the message from the JSON and then send that as the <code>haystack</code> to the inner <code>RegexMatcher</code>?</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:54 UTC
    </footer>
</body>
</html>
