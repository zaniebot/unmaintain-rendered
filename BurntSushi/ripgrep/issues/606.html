<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Filtering on the presence or absence of captures - BurntSushi/ripgrep #606</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Filtering on the presence or absence of captures</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/606">#606</a>
        opened by <a href="https://github.com/chocolateboy">@chocolateboy</a>
        on 2017-09-17 20:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chocolateboy">@chocolateboy</a></div>
            <div class="timeline-body"><blockquote>
<p>ðŸ’¡ [This trick] relies on your ability to inspect Group 1 captures (at least in the generic flavor), so it will not work in a non-programming environment, such as a text editor&#x27;s search-and-replace function <strong>or a grep command</strong> -- <a href="http://www.rexegg.com/regex-best-trick.html">The Best Regex Trick</a></p>
</blockquote>
TL;DR
<p>Select all lines which match <code>\bTarzan\b</code> but not <code>&quot;Tarzan&quot;</code>:</p>
<pre><code>$ rg -w &#x27;&quot;Tarzan&quot;|(Tarzan)&#x27; --defined &#x27;$1&#x27;</code></pre>
<p>AKA</p>
<pre><code>$ rg -w &#x27;&quot;Tarzan&quot;|(Tarzan)&#x27; -d &#x27;$1&#x27;</code></pre>
<hr>
<p>Suppose I want to select all lines which contain the unquoted word <code>Tarzan</code> i.e. <code>\bTarzan\b</code> but not <code>&quot;Tarzan&quot;</code> e.g. the first 4 lines of:</p>
test.txt
<pre><code>&quot;Tarzan and Jane&quot;
&quot;Jane and Tarzan&quot;
Me Tarzan, you Jane
Tarzan vs &quot;Tarzan&quot;
This line doesn&#x27;t mention him
He&#x27;s moved to Tarzania
He&#x27;s no &quot;Tarzan&quot;!</code></pre>
<p>It can be done with a pipeline e.g.:</p>
<pre><code>$ rg -w &#x27;Tarzan&#x27; test.txt | rg -v &#x27;&quot;Tarzan&quot;&#x27;</code></pre>
<p>But that particular example rejects lines which contain both, which is not what we want in this case. The same would be true if ripgrep added e.g. an <code>-E</code> (<code>--no-regexp</code>) option to complement <code>-e</code>/<code>--regexp</code>:</p>
<pre><code>$ rg -we &#x27;Tarzan&#x27; -E &#x27;&quot;Tarzan&quot;&#x27; test.txt</code></pre>
<p>It can be done in one pass with PCRE-flavored greps such as GNU grep and ack, with varying degrees of <a href="http://www.rexegg.com/regex-best-trick.html#typical">difficulty/unreadability</a>, by using negative lookahead/look-behind assertions e.g.:</p>
<pre><code>$ grep -P &#x27;^(?:(?!&quot;Tarzan&quot;|Tarzan\w+)(Tarzan|.))+$&#x27; test.txt</code></pre>
<p>That&#x27;s already pretty gnarly for a single exclusion, and quickly becomes impractical/incomprehensible for multiple exclusions. It also matches lines which don&#x27;t contain <code>Tarzan</code> and, again, excludes lines which contain both patterns.</p>
<p>In programming languages, there&#x27;s a common pattern for performing exclusions in a simple, readable way without multiple passes:</p>
<ol>
<li>match and discard the exclusions</li>
<li>match and capture the inclusion</li>
<li>test for its existence</li>
</ol>
<p>e.g.:</p>
JavaScript
<pre><code>[ &#x27;&#x27;, &#x27;&quot;Tarzan&quot;&#x27;, &#x27;Tarzan&#x27;, &#x27;Tarzania&#x27;, &#x27;Tarzan vs &quot;Tarzan&quot;&#x27; ].filter(it =&gt; {
    const m = it.match(/&quot;Tarzan&quot;|\b(Tarzan)\b/)
    return m &amp;&amp; m[1]
}) // [ &#x27;Tarzan&#x27;, &#x27;Tarzan vs &quot;Tarzan&quot;&#x27; ]
</code></pre>
ES.next<a href="https://github.com/tc39/proposal-optional-chaining#syntax">[1]</a>
<pre><code>[ &#x27;&#x27;, &#x27;&quot;Tarzan&quot;&#x27;, &#x27;Tarzan&#x27;, &#x27;Tarzania&#x27;, &#x27;Tarzan vs &quot;Tarzan&quot;&#x27; ].filter(it =&gt; {
    return it.match(/&quot;Tarzan&quot;|\b(Tarzan)\b/)?.[1]
}) // [ &#x27;Tarzan&#x27;, &#x27;Tarzan vs &quot;Tarzan&quot;&#x27; ]
</code></pre>
Ruby
<pre><code>[ &#x27;&#x27;, &#x27;&quot;Tarzan&quot;&#x27;, &#x27;Tarzan&#x27;, &#x27;Tarzania&#x27;, &#x27;Tarzan vs &quot;Tarzan&quot;&#x27; ].select { |it|
    it[/&quot;Tarzan&quot;|\b(Tarzan)\b/, 1]
} # =&gt; [ &#x27;Tarzan&#x27;, &#x27;Tarzan vs &quot;Tarzan&quot;&#x27; ]
</code></pre>
<pre><code>$ ruby -ne &#x27;print if $_[/&quot;Tarzan&quot;|\b(Tarzan)\b/, 1]&#x27; test.txt</code></pre>
<p>etc.</p>
<p>This isn&#x27;t available in any greps I&#x27;m aware of, but since the machinery is already there to capture and reference subexpressions by index and name, it seems like a small step to use them in predicates to reproduce the flexibility and simplicity of this pattern on the command line e.g.:</p>
<pre><code>$ rg -w &#x27;&quot;Tarzan&quot;|(Tarzan)&#x27; -d &#x27;$1&#x27; test.txt</code></pre>
output
<pre><code>&quot;Tarzan and Jane&quot;
&quot;Jane and Tarzan&quot;
Me Tarzan, you Jane
Tarzan vs &quot;Tarzan&quot;
</code></pre>
Notes
<p>1) I assume that the predicate can be inverted e.g.:</p>
<pre><code>$ rg --not-defined &#x27;$1&#x27;</code></pre>
<p>AKA</p>
<pre><code>$ rg -D &#x27;$1&#x27;</code></pre>
<p>There aren&#x27;t many single-letter options left. The last remaining pairs are -<code>d</code>/<code>-D</code>, <code>-y</code>/<code>-Y</code> and <code>-z</code>/<code>-Z</code>. The latter are commonly used to denote null/zero values, so they could be used instead, with the meaning of <code>-d</code> and <code>-D</code> inverted e.g.:</p>
<pre><code>$ rg -z &#x27;$1&#x27; # AKA rg --not-defined &#x27;$1&#x27;
$ rg -Z &#x27;$1&#x27; # AKA rg --defined &#x27;$1&#x27;</code></pre>
<p>2) I assume that indices increment across multiple patterns, and that multiple <code>-d</code> and <code>-D</code> options can be combined e.g.:</p>
<pre><code>$ rg -e &#x27;Foo|(Bar)&#x27; -e &#x27;(Baz|(Quux))&#x27; -d &#x27;$1&#x27; -D &#x27;$3&#x27;</code></pre>
<p>3) I also assume that numbered and named captures can be mixed e.g.:</p>
<pre><code>$ rg -e &#x27;Foo|(Bar)&#x27; -e &#x27;Baz|(?P&lt;name&gt;Quux)&#x27; -d &#x27;$1&#x27; -D &#x27;$name&#x27;</code></pre>
<p>4) The full version of the matching command would currently be:</p>
<pre><code>rg &#x27;^.*?(?:&quot;Tarzan&quot;|\b(Tarzan)\b).*$&#x27; -d &#x27;$1&#x27; test.txt</code></pre>
<p>Hopefully some of that boilerplate can be removed e.g. via #389 or #593.</p>
<p>5) For clarity, <code>&quot;Tarzan&quot; vs Tarzan</code> is omitted from the examples. Handling it only slightly complicates the regex:</p>
<pre><code>$ rg &#x27;^(?:&quot;Tarzan&quot;|\b(Tarzan)\b|.)*$&#x27; -d &#x27;$1&#x27; test.txt</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 12:50</div>
            <div class="timeline-body"><p>Thanks for this very thorough write up!</p>
<p>I kind of feel like that semantics of this are too complex, which will probably lead to a feature that almost nobody uses. By that, I don&#x27;t mean that the flags <code>--not-defined</code> and <code>--defined</code> are themselves complex, but using them effectively---as you&#x27;ve demonstrated here---requires some ingenuity in crafting the regex.</p>
<p>With that said, I&#x27;d be willing to adopt a feature like this because I do agree that it could be useful, but I&#x27;d have to <strong>strongly</strong> insist on the following:</p>
<ol>
<li>It should not begin life with short flags. I used short flags whenever the flags are common, or if there was a precedent for their existence in other tools. For a feature like this, that is neither common nor familiar, I would like to hold off on adding short flags. If I&#x27;m wrong and it becomes popular, then we can revisit it.</li>
<li>The maintenance burden of the feature needs to be low. That means adding the feature shouldn&#x27;t require any significant complications and it should be reasonably well tested.</li>
<li>Since the use case motivating the existence of these flags is somewhat complicated, I would like the documentation to be clear. It should be concise, but contain an example usage. (Perhaps a condensed version of the example in this ticket.)</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 12:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-24 12:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">icebox</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-10-21 22:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2018-09-21 19:05</div>
            <div class="timeline-body"><p>Now that PRCE is (optionally) supported, can either of you think of a use-case for this that isn&#x27;t handled by lookahead and lookbehind? I <em>think</em> this would be strictly more powerful than negative <em>lookbehind</em>, since lookbehind can&#x27;t contain variable-length patterns, but that&#x27;s the only advantage I can see. (Granted, that&#x27;s an advantage I think I would occasionally find useful.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-04-03 13:18</div>
            <div class="timeline-body"><p>I think it could be possible to define a simpler UX than needing to resort to look-around.</p>
<p>With that said, it&#x27;s a good point and I was never a big fan of adding this feature anyway. So I&#x27;m going to close this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-04-03 13:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chocolateboy">@chocolateboy</a> on 2020-09-20 14:51</div>
            <div class="timeline-body"><p>Lookaround assertions still have the issues mentioned above. For anyone looking for a clean solution to this with the PCRE engine, the <a href="https://pcre.org/current/doc/html/pcre2pattern.html#SEC29">backtracking-control verbs</a><a href="https://www.rexegg.com/backtracking-control-verbs.html">^1</a><a href="https://perldoc.perl.org/perlre.html#Special-Backtracking-Control-Verbs">^3</a> are your friends:</p>
Input
<pre><code>&quot;Tarzan and Jane&quot;
&quot;Jane and Tarzan&quot;
Me Tarzan, you Jane
Tarzan vs &quot;Tarzan&quot;
&quot;Tarzan&quot; vs Tarzan
This line doesn&#x27;t mention him
He&#x27;s moved to Tarzania
He&#x27;s no &quot;Tarzan&quot;!
</code></pre>
Command
<pre><code>$ rg --pcre2 &#x27;(?:&quot;Tarzan&quot;)(*SKIP)(*FAIL)|\bTarzan\b&#x27; test.txt
</code></pre>
Output
<pre><code>&quot;Tarzan and Jane&quot;
&quot;Jane and Tarzan&quot;
Me Tarzan, you Jane
Tarzan vs &quot;Tarzan&quot;
&quot;Tarzan&quot; vs Tarzan
</code></pre>
<p>Or, to exclude lines which contain <code>&quot;Tarzan&quot;</code>:</p>
Command
<pre><code>$ rg --pcre2 &#x27;(?:.*?&quot;Tarzan&quot;.*)(*SKIP)(*FAIL)|\bTarzan\b&#x27; test.txt
$ rg --pcre2 &#x27;(?:.*?&quot;Tarzan&quot;.*)(*COMMIT)(*FAIL)|\bTarzan\b&#x27; test.txt
</code></pre>
Output
<pre><code>&quot;Tarzan and Jane&quot;
&quot;Jane and Tarzan&quot;
Me Tarzan, you Jane
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BatmanAoD">@BatmanAoD</a> on 2020-09-20 15:42</div>
            <div class="timeline-body"><p>@chocolateboy Wow, I had never heard of those before. Thanks for sharing.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:04 UTC
    </footer>
</body>
</html>
