```yaml
number: 2795
title: "The same `LineTerminator` is being used for searching and printing"
type: issue
state: closed
author: ltrzesniewski
labels:
  - wontfix
assignees: []
created_at: 2024-05-01T16:00:09Z
updated_at: 2025-10-16T11:37:17Z
url: https://github.com/BurntSushi/ripgrep/issues/2795
synced_at: 2026-01-12T16:13:24Z
```

# The same `LineTerminator` is being used for searching and printing

---

_@ltrzesniewski_

### Please tick this box to confirm you have reviewed the above.

- [X] I have a different issue.

### What version of ripgrep are you using?

ripgrep 14.1.0

features:-simd-accel,+pcre2
simd(compile):+SSE2,-SSSE3,-AVX2
simd(runtime):+SSE2,+SSSE3,+AVX2

PCRE2 10.43 is available (JIT is available)

### How did you install ripgrep?

`cargo install ripgrep --features pcre2`

### What operating system are you using ripgrep on?

Ubuntu 22.04.4 LTS on WSL

### Describe your bug.

I noticed that ripgrep could insert CR characters into its output on Linux, which I didn't expect.

I took a quick look out of curiosity, and saw that the same `LineTerminator` is being used for searching *and* for printing, which I thought could be an oversight, so I figured I'd report it just in case. I don't think this has a real impact on anything though, so feel free to simply close this issue if that's ok for you.

I tracked down the culprit to this function: https://github.com/BurntSushi/ripgrep/blob/bb8601b2bafb5e68181cbbb84e6ffa4f7a72bf16/crates/printer/src/standard.rs#L1493-L1495



### What are the steps to reproduce the behavior?

```bash
$ echo hello | rg hello --no-config --count --no-crlf | xxd
00000000: 310a                                     1.

$ echo hello | rg hello --no-config --count --crlf | xxd
00000000: 310d 0a                                  1..
```



### What is the actual behavior?

The output changes between `--crlf` and `--no-crlf`.

Even on Linux, a CRLF end-of-line (`0d 0a`) is emitted when `--crlf` is used. I used `--count` to force `write_line_term()` to be called, but other flags such as `--pretty` work just as well.


### What is the expected behavior?

I expected the outputs of the two commands to be the same.


---

_Comment by @BurntSushi on 2025-07-12 15:38_

This was definitely intentional as written. The issue of line terminators is quite a tricky one. But there are cases where you have to _choose_ the line terminator. The summary printer is one such example. Another example is adding a line terminator at the end of output that doesn't otherwise contain a line terminator. Or when `-o` is used.

So how do you make the choice? There's no guarantee that the input uses line terminators consistently. So ripgrep has an internal notion of what the line terminator "ought" to be. When you use `--null-data`, that's `\x00`. When you use `--crlf`, that's `\r\n`.

Maybe there is a better way to handle this, but I don't think it should be attacked piecemeal.

I'm going to close this for now because I don't see many (if any) reports of actual issues folks are running into with how ripgrep does things now. I remember spending significant time mulling over this when building out `grep-printer`. I don't remember all of the corners, but I'd rather not change things here without something more compelling.

---

_Closed by @BurntSushi on 2025-07-12 15:38_

---

_Label `wontfix` added by @BurntSushi on 2025-07-12 15:39_

---

_Comment by @ltrzesniewski on 2025-10-13 20:05_

@BurntSushi I actually got bitten by this yesterday because I had `--crlf` in my config, so I thought I'd give you a real example.

I wanted to rename a bunch of files, and used ripgrep for generating the script:

```bash
$ touch foo.utf16.c bar.utf8.c

$ ls
bar.utf8.c  foo.utf16.c

$ ls | rg '(^.*).utf(\d+).c' -r 'mv $0 $1.${2}bit.c' --no-config --crlf
mv bar.utf8.c bar.8bit.c
mv foo.utf16.c foo.16bit.c

$ ls | rg '(^.*).utf(\d+).c' -r 'mv $0 $1.${2}bit.c' --no-config --crlf | sh

$ ls
'bar.8bit.c'$'\r'  'foo.16bit.c'$'\r'

$ ls --zero | xxd
00000000: 6261 722e 3862 6974 2e63 0d00 666f 6f2e  bar.8bit.c..foo.
00000010: 3136 6269 742e 630d 00                   16bit.c..
```

<sup>(of course, I didn't type `--no-config --crlf`, that's just for reproducibility)</sup>

I ended up with files with a CR in their name! Oops.

---

The `--help` for `--crlf` starts with the following:
> When enabled, ripgrep will treat CRLF (\r\n) as a line terminator instead of just \n.

It's unclear to me if this means the *output* will end with CRLF, but given the text that follows, I understood it to mean the behavior of *regex matching* is impacted. I didn't think it would impact the output, especially only of those lines generated by ripgrep itself (headings, replaces, etc). You can still get a mixed LF/CRLF output depending on the matched lines terminators and what ripgrep adds on top.

Because of this, I'd suggest always using either LF or NUL in the *standard printer* (just drop CRLF), especially since LF is used even on Windows by default. I had written [this change](https://github.com/ltrzesniewski/ripgrep/commit/cdfe0854ac21c22f8d86a383744bfec2a5aa4195#diff-9edc643fe15c729d9ad9528b23556005eb27db181e25f5f260962e5ed468b9dd) back when I sent #2805, I can double-check and turn it into a PR if you'd like. In any case, thank you for considering it.


---

_Comment by @BurntSushi on 2025-10-13 20:31_

The problem IMO is that you are in a context where you specifically want LF terminators. But what if you want CRLF terminators? I grant that `--crlf` is coupling both search time understanding of line terminators and printing, but I don't really see a better way (and I don't want to add more flags for this, which I think will be difficult to understand and use correctly).

You can technically, I believe, get search time CRLF support without changing the printer's notion of the line terminator. You can do that by adding `(?R)` to the beginning of your regex pattern.

And yes, you can 100% get mixed line terminators. I don't know how to avoid that without forcefully normalizing all line terminators in the output.

---

_Comment by @ltrzesniewski on 2025-10-13 21:17_

> But what if you want CRLF terminators?

That seems like a strange requirement to me, even on Windows (where most of the tools support LF, even Notepad). But you can get normalized CRLF output by piping the ripgrep output to the `unix2dos` tool if you have it installed, or to `sed -E 's/\r?$/\r/'` otherwise.

> You can do that by adding `(?R)` to the beginning of your regex pattern.

That's cumbersome to be honest. I prefer having `--crlf` in the config, so that matching `\r` is implicit by default.

> I don't know how to avoid that without forcefully normalizing all line terminators in the output.

I'd say that's OK, maybe even preferable. I'm merely suggesting the decoupling of searching and printing, especially since ripgrep uses LF by default.


---

_Comment by @BurntSushi on 2025-10-13 21:25_

> That seems like a strange requirement to me

I'm not a Windows user, but I imagine I'd be annoyed if my file had CRLF line terminators and ripgrep printed it out with LF line terminators.

I fairly strongly disagree with the idea of line terminator normalization because it's changing the contents of the file. Wherever possible, ripgrep should not change any byte in the file in the output. Even if you don't use the `--crlf` flag, ripgrep will preserve CRLF line terminators:

```
$ printf 'foo\r\n' | rg '\w' | xxd
00000000: 666f 6f0d 0a                             foo..
```

> I'm merely suggesting the decoupling of searching and printing

Right. That's why I mentioned `(?R)`. But I don't want to add a new flag for this. It's too subtle and too niche IMO.

---

_Comment by @ltrzesniewski on 2025-10-13 21:37_

> I fairly strongly disagree with the idea of line terminator normalization because it's changing the contents of the file.

Oh, looks like I was unclear, sorry. I'm absolutely not asking for it. I think it's preferable to use the file content as-is, just like ripgrep does today.

If you need normalization, you can use `unix2dos`/`dos2unix` by yourself to do it easily outside of ripgrep.

> But I don't want to add a new flag for this.

I didn't ask for this either.

I basically just suggested to always use LF instead of CRLF in `write_line_term` (see the [commit I mentioned](https://github.com/ltrzesniewski/ripgrep/commit/cdfe0854ac21c22f8d86a383744bfec2a5aa4195)), so that additional lines added by ripgrep (such as replacement results in this case) end with LF or NUL and are independent of `--crlf`.


---

_Comment by @BurntSushi on 2025-10-13 21:56_

Yeah I get that. But that just goes back to my earlier concern about users _wanting_ CRLF and not LF. So if `--crlf` only twiddles the search time line terminator, then users who want CRLF are left without an option. Hence discussion of line terminator normalization and new flags.

I honestly don't really know how to evaluate what the right choice is here. My sense is just that if you're using `--crlf`, then you're probably searching data with CRLF line terminators and thus want to stick with CRLF line terminators. But I grant that assumption isn't always true, as in your case. For me, I don't use `--crlf` unless I know I specifically need it.

---

_Comment by @BurntSushi on 2025-10-13 21:57_

I believe it's also possible for `--crlf` to inhibit at least some optimizations. But I'd need to check that.

---

_Comment by @ltrzesniewski on 2025-10-13 22:23_

I think I put `--crlf` by default because I work with both CRLF and LF files, and wanted the regexes to behave the same for both. I simply don't want to care about the EOLs. That may not have been the best choice as I don't use `$` very often, but when I do, I'd easily forget I'd need to add `--crlf` or write `\r?$` instead of `$`.

I'll stop bothering you about this now, thanks for your time. ðŸ™‚


---

_Comment by @ltrzesniewski on 2025-10-16 09:20_

Well, #3100 actually fixed the issue I had with `-r`. ðŸ™‚

(thanks @IsaacOscar, and of course thanks @BurntSushi for ripgrep v15)


---

_Comment by @BurntSushi on 2025-10-16 11:37_

Oh, cool! w00t.

---
