<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ripgrep matching on and printing part of the URL in osc8 hyperlinked text - BurntSushi/ripgrep #2911</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ripgrep matching on and printing part of the URL in osc8 hyperlinked text</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2911">#2911</a>
        opened by <a href="https://github.com/gdrapala">@gdrapala</a>
        on 2024-10-15 14:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/gdrapala">@gdrapala</a></div>
            <div class="timeline-body">Please tick this box to confirm you have reviewed the above.
<ul>
<li>[X] I have a different issue.</li>
</ul>
What version of ripgrep are you using?
<p>; rg --version
ripgrep 14.1.1</p>
<p>features:+pcre2
simd(compile):+NEON
simd(runtime):+NEON</p>
<p>PCRE2 10.43 is available (JIT is available)</p>
How did you install ripgrep?
<p>Homebrew</p>
What operating system are you using ripgrep on?
<p>macos</p>
Describe your bug.
<p>When using ripgrep on text with osc8-style hyperlinks, rg seems to match on the URL itself and include the matched part of the URL in the outputted text.</p>
<p>Since OSC8 URLs are not printed in a terminal, I expected rg to neither match on nor print the URL contents.</p>
<p>Let me know if there&#x27;s a different hyperlink-format mode to enable this functionality.</p>
What are the steps to reproduce the behavior?
<pre><code>; printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27;
; printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27; | rg --hyperlink-format=default _a_link
; printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27; | rg --hyperlink-format=default _a_
</code></pre>
What is the actual behavior?
<p>Here&#x27;s the above commands with the actual output. The last command produces an unexpected output:</p>
<pre><code>; printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27;
This_is_a_link
; printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27; | rg --hyperlink-format=default _a_link
This_is_a_link
; printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27; | rg --hyperlink-format=default _a_
_a_pageThis_is_a_link
</code></pre>
What is the expected behavior?
<p>The expected output for the last command is &quot;This_is_a_link&quot;, same as the previous two commands.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-10-15 16:29</div>
            <div class="timeline-body"><p>So firstly, I&#x27;m getting different output in my terminal for the initial basic command:</p>
<pre><code>$ printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27;
This_is_a_link
&#x27;This_is_a_link
&#x27;This_is_a_link
</code></pre>
<p>I don&#x27;t know why it&#x27;s different from yours. I don&#x27;t understand why <code>This_is_a_link</code> is repeated three times, with the second two times starting with a <code>&#x27;</code>.</p>
<p>Otherwise, I don&#x27;t seem to be able to reproduce your problem:</p>
<pre><code>$ printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27; | rg --hyperlink-format=default _a_
This_is_a_link
&#x27; | rg --hyperlink-format=default _a_This_is_a_link
&#x27; | rg --hyperlink-format=default _a__a_pageThis_is_a_link
$ printf &#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27; | rg _a_
This_is_a_link
&#x27; | rg _a_This_is_a_link
&#x27; | rg _a__a_pageThis_is_a_link
</code></pre>
<p>In general, mixing ANSI escape sequences from an input source with ANSI escape sequences with the output from another tool (like what ripgrep does) usually doesn&#x27;t lead to good results. And there really isn&#x27;t anything to be done about it. We aren&#x27;t dealing with semantic markup here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gdrapala">@gdrapala</a> on 2024-10-15 17:28</div>
            <div class="timeline-body"><p>Hmm, I&#x27;m also not sure why printf is behaving differently on your system.  You might try a different shell (e.g., tcsh) or  python as shown below.</p>
<pre><code>; python -c &quot;print(&#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27;, end=&#x27;&#x27;)&quot;
This_is_a_link
</code></pre>
<p>But I see your point about terminal text not being a full-fledged markup format.</p>
<p>One minor point is that grep seems to behave as desired on this example (i.e., grep on the visible text, preserve the URL, not insert any of the URL in the output):</p>
<pre><code>; python -c &quot;print(&#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27;, end=&#x27;&#x27;)&quot; | /opt/homebrew/bin/rg --hyperlink-format=default _a_
0m_a_pageThis_is_a_link

; python -c &quot;print(&#x27;\033]8;;http://example.com/this_is_a_page\033\\This_is_a_link\033]8;;\033\\\n&#x27;, end=&#x27;&#x27;)&quot; | /usr/bin/grep _a_
This_is_a_link

; /usr/bin/grep --version
grep (BSD grep, GNU compatible) 2.6.0-FreeBSD
</code></pre>
<p>To compare with ANSI colors though, some weirdness is expected. For example:</p>
<pre><code>; python -c &#x27;import click; print(click.style(&quot;abc&quot;, fg=&quot;red&quot;) + click.style(&quot;def&quot;, fg=&quot;blue&quot;))&#x27;
abcdef
; python -c &#x27;import click; print(click.style(&quot;abc&quot;, fg=&quot;red&quot;) + click.style(&quot;def&quot;, fg=&quot;blue&quot;))&#x27; | rg cd
&lt;prints nothing&gt;
</code></pre>
<p>Even though &quot;cd&quot; are printed back-to-back in the terminal, ripgrep for &quot;cd&quot; doesn&#x27;t find any matching lines because of the non-printed ANSI color sequences involved.  With ANSI color, upstream tools are expected to either detect if stdout is not tty and disable ANSI or give users the ability to forcibly disable ANSI color output.</p>
<p>I suppose the same is expected of OSC8 ANSI sequences generated by upstream tools.</p>
<p>But, in practice, grep/ripgrep happen to work well on ANSI colorized text when the search pattern is fully enclosed in a single ANSI color block.</p>
<p>Anyhoo, that&#x27;s a long winded way to say that a ripgrep update to ignore the non-visible URL parts is a potential enhancement.  No idea if it&#x27;s generally feasible, but if it is we would be able to leave osc8 ON most of the time when piping output through rg and would only have to turn osc8 OFF when rg&#x27;ing for text that spans a URL boundary (which is similar to ansi color today).</p>
<p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ltrzesniewski">@ltrzesniewski</a> on 2024-10-15 18:45</div>
            <div class="timeline-body"><p>I think there&#x27;s something unclear here:</p>
<blockquote>
<p>When using ripgrep on text with osc8-style hyperlinks, rg seems to match on the URL itself and include the matched part of the URL in the outputted text.</p>
</blockquote>
<p>Yes, that&#x27;s because ripgrep doesn&#x27;t filter its input text. Generally, you should provide input text without any ANSI/OSC8 codes, as ripgrep will output any matching sequence, and insert its own codes over the matching input. If anything from an escape sequence matches, the result can be garbled text.</p>
<blockquote>
<p>Let me know if there&#x27;s a different hyperlink-format mode to enable this functionality.</p>
</blockquote>
<p>That&#x27;s where your confusion comes from I suppose. The <code>--hyperlink-format</code> parameter controls ripgrep&#x27;s <em>output</em>, it doesn&#x27;t filter its input. It sets the URL format you want ripgrep to use to display the matches it found.</p>
<p>For example, when using <code>--hyperlink-format=vscode</code>, ripgrep will wrap the line numbers in its output in hyperlinks which will open the matching file in VS Code and place the cursor at the matching location.</p>
<blockquote>
<p>With ANSI color, upstream tools are expected to either detect if stdout is not tty and disable ANSI or give users the ability to forcibly disable ANSI color output.</p>
<p>I suppose the same is expected of OSC8 ANSI sequences generated by upstream tools.</p>
</blockquote>
<p>Yes, exactly.</p>
<blockquote>
<p>Anyhoo, that&#x27;s a long winded way to say that a ripgrep update to ignore the non-visible URL parts is a potential enhancement.</p>
</blockquote>
<p>I think that would be better done by an external filter. I found <code>ansi2txt</code> for instance (but haven&#x27;t tested it, there should be other ones if necessary):</p>
<pre><code>your-upstream-tool | ansi2txt | rg your-pattern
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gdrapala">@gdrapala</a> on 2024-10-15 22:50</div>
            <div class="timeline-body"><blockquote>
<p>That&#x27;s where your confusion comes from I suppose. The --hyperlink-format parameter controls ripgrep&#x27;s output, it doesn&#x27;t filter its input. It sets the URL format you want ripgrep to use to display the matches it found.</p>
</blockquote>
<p>Thank you for clearing up my confusion. I was not clear on the exact details of that parameter.</p>
<blockquote>
<p>Generally, you should provide input text without any ANSI/OSC8 codes, as ripgrep will output any matching sequence, and insert its own codes over the matching input. If anything from an escape sequence matches, the result can be garbled text.</p>
</blockquote>
<p>I better understand that ripgrep is capable of producing OSC8, which is awesome. Based on my experience with other programs before and after OSC8 support (mostly &quot;less&quot; pre and post v566), I was expecting OSC8 compatibility to mean at both input and output, without having to externally strip the OSC8 tags, but looking for feedback on that expectation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-10-15 23:00</div>
            <div class="timeline-body"><p>ripgrep definitely does not do any ANSI input sanitization and never will. It would tank performance. ripgrep searches what you give it. That is its purpose. It doesn&#x27;t understand the semantic structure of documents other than newlines.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-10-15 23:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-10-15 23:01</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:14 UTC
    </footer>
</body>
</html>
