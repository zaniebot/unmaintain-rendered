<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RipGrep does not search files where Size on Disk == 0 - BurntSushi/ripgrep #464</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>RipGrep does not search files where Size on Disk == 0</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/464">#464</a>
        opened by <a href="https://github.com/trs4ece">@trs4ece</a>
        on 2017-04-27 18:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/trs4ece">@trs4ece</a></div>
            <div class="timeline-body"><p>Our IT department runs Dedupe on our network share which causes files &gt; 32 KB to have a Size on Disk of 0. This appears to cause RipGrep to skip over these files. This issue exists on all versions of RipGrep from 0.5.2 through at least 0.3.2.</p>
<p>Related: <a href="https://github.com/Microsoft/vscode/issues/24968">[Visual Studio Code] Global search is only searching open/viewed files #24968</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-27 18:51</div>
            <div class="timeline-body"><p>Can you help me figure out how to reproduce the issue? Can you see what happens when running <code>--no-mmap</code> and <code>--mmap</code>? Do other tools, like <code>grep</code> or <code>ag</code> (the silver searcher) or <code>sift</code> or <code>pt</code> (the platinum searcher) work for you?</p>
<p>Note that there is no specific logic in ripgrep that causes it to skip files with a file size of zero.</p>
<p>cc @retep998</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 19:07</div>
            <div class="timeline-body"><p>To reproduce the issue, you would need to enable Data Deduplication on a drive, have several copies of a file &gt; 32 KB on that drive, and then run Data Deduplication. There is a <a href="https://blogs.technet.microsoft.com/canitpro/2013/04/29/step-by-step-enabling-data-deduplication-on-windows-server-2012-volumes/">TechNet Blog</a> that describes how to enable dedupe.</p>
<p>Using PowerShell&#x27;s Get-ChildItem piped into Select-String seems to work fine. I haven&#x27;t tried the other tools yet. I&#x27;ll try them out and let you know.</p>
<p>Here are the commands that you requested:</p>
<pre><code>λ  E:\bin\rg.exe -i --mmap &#x27;function Connect-TFSProject&#x27; --debug
DEBUG:grep::search: regex ast:
Literal {
    chars: [
        &#x27;f&#x27;,
        &#x27;u&#x27;,
        &#x27;n&#x27;,
        &#x27;c&#x27;,
        &#x27;t&#x27;,
        &#x27;i&#x27;,
        &#x27;o&#x27;,
        &#x27;n&#x27;,
        &#x27; &#x27;,
        &#x27;C&#x27;,
        &#x27;o&#x27;,
        &#x27;n&#x27;,
        &#x27;n&#x27;,
        &#x27;e&#x27;,
        &#x27;c&#x27;,
        &#x27;t&#x27;,
        &#x27;-&#x27;,
        &#x27;T&#x27;,
        &#x27;F&#x27;,
        &#x27;S&#x27;,
        &#x27;P&#x27;,
        &#x27;r&#x27;,
        &#x27;o&#x27;,
        &#x27;j&#x27;,
        &#x27;e&#x27;,
        &#x27;c&#x27;,
        &#x27;t&#x27;
    ],
    casei: true
}
DEBUG:grep::literals: required literals found: [Cut(FUNCT), Cut(fUNCT), Cut(FuNCT), Cut(fuNCT), Cut(FUnCT), Cut(fUnCT), Cut(FunCT), Cut(funCT), Cut(FUNcT), Cut(fUNcT), Cut(FuNcT), Cut(fuNcT), Cut(FUncT), Cut(fUncT), Cut(FuncT), Cut(funcT), Cut(FUNCt), Cut(fUNCt), Cut(FuNCt), Cut(fuNCt), Cut(FUnCt), Cut(fUnCt), Cut(FunCt), Cut(funCt), Cut(FUNct), Cut(fUNct), Cut(FuNct), Cut(fuNct), Cut(FUnct), Cut(fUnct), Cut(Funct), Cut(funct)]
DEBUG:rg::args: will try to use memory maps
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*output/*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*output/[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;o&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;/&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*bin/GitPortable*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*bin/GitPortable[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;b&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;/&#x27;), Literal(&#x27;G&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;P&#x27;), Literal(&#x27;o&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), ZeroOrMore]) }DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.vscode*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.vscode.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;v&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;o&#x27;), Literal(&#x27;d&#x27;), Literal(&#x27;e&#x27;), ZeroOrMore]) }
DEBUG:globset: built glob set; 0 literals, 1 basenames, 11 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 3 regexes
DEBUG:ignore::walk: ignoring ./.git: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./.gitattributes: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./.gitignore: Ignore(IgnoreMatch(Hidden))
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;e&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;i&#x27;), Literal(&#x27;n&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;O&#x27;, &#x27;O&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }, Literal(&#x27;b&#x27;), Literal(&#x27;j&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;T&#x27;, &#x27;T&#x27;), (&#x27;t&#x27;, &#x27;t&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;t&#x27;), Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;t&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;u&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;d&#x27;), Class { negated: false, ranges: [(&#x27;L&#x27;, &#x27;L&#x27;), (&#x27;l&#x27;, &#x27;l&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(&#x27;R&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;S&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;r&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harper$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Class { negated: false, ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;r&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(&#x27;T&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.ncrunch*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.ncrunch.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;E&#x27;, &#x27;E&#x27;), (&#x27;e&#x27;, &#x27;e&#x27;)] }, Literal(&#x27;x&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;s&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Class { negated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;~&#x27;), Literal(&#x27;$&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;B&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;k&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;p&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.py[co]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.py[co]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;y&#x27;), Class { negated: false, ranges: [(&#x27;c&#x27;, &#x27;c&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }]) }
DEBUG:globset: built glob set; 3 literals, 38 basenames, 43 extensions, 0 prefixes, 10 suffixes, 10 required extensions, 15 regexes
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitattributes: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitignore: Ignore(IgnoreMatch(Hidden))
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPublic&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPublic$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;P&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;c&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;e&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleases&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleases$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;i&#x27;), Literal(&#x27;n&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;O&#x27;, &#x27;O&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }, Literal(&#x27;b&#x27;), Literal(&#x27;j&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;T&#x27;, &#x27;T&#x27;), (&#x27;t&#x27;, &#x27;t&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;t&#x27;), Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;t&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;u&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;d&#x27;), Class { negated: false, ranges: [(&#x27;L&#x27;, &#x27;L&#x27;), (&#x27;l&#x27;, &#x27;l&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPS$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;P&#x27;), Literal(&#x27;S&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleasePS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleasePS$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;P&#x27;), Literal(&#x27;S&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_Chutzpah*&quot;, re: &quot;(?-u)^(?:/?|.*/)_Chutzpah.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;z&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;h&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(&#x27;R&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;S&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;r&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harper$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Class { negated: false, ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;r&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(&#x27;T&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_NCrunch_*&quot;, re: &quot;(?-u)^(?:/?|.*/)_NCrunch_.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(&#x27;N&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;_&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.mm.*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.mm\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;E&#x27;, &#x27;E&#x27;), (&#x27;e&#x27;, &#x27;e&#x27;)] }, Literal(&#x27;x&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;s&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/packages/*&quot;, re: &quot;(?-u)^(?:/?|.*/)packages/[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;p&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;k&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;/&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Cc]ache$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;e&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*\\.[Cc]ache$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;e&#x27;)]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Class { negated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;~&#x27;), Literal(&#x27;$&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;B&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;k&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;p&#x27;), ZeroOrMore]) }
DEBUG:globset: built glob set; 4 literals, 28 basenames, 45 extensions, 0 prefixes, 15 suffixes, 9 required extensions, 23 regexes
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitattributes: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitignore: Ignore(IgnoreMatch(Hidden))
</code></pre>
<pre><code>λ  E:\bin\rg.exe -i --no-mmap &#x27;function Connect-TFSProject&#x27; --debug                                                  
DEBUG:grep::search: regex ast:                                                                                       
Literal {                                                                                                            
    chars: [                                                                                                         
        &#x27;f&#x27;,                                                                                                         
        &#x27;u&#x27;,                                                                                                         
        &#x27;n&#x27;,                                                                                                         
        &#x27;c&#x27;,                                                                                                         
        &#x27;t&#x27;,                                                                                                         
        &#x27;i&#x27;,                                                                                                         
        &#x27;o&#x27;,                                                                                                         
        &#x27;n&#x27;,                                                                                                         
        &#x27; &#x27;,                                                                                                         
        &#x27;C&#x27;,                                                                                                         
        &#x27;o&#x27;,                                                                                                         
        &#x27;n&#x27;,                                                                                                         
        &#x27;n&#x27;,                                                                                                         
        &#x27;e&#x27;,                                                                                                         
        &#x27;c&#x27;,                                                                                                         
        &#x27;t&#x27;,                                                                                                         
        &#x27;-&#x27;,                                                                                                         
        &#x27;T&#x27;,                                                                                                         
        &#x27;F&#x27;,                                                                                                         
        &#x27;S&#x27;,                                                                                                         
        &#x27;P&#x27;,                                                                                                         
        &#x27;r&#x27;,                                                                                                         
        &#x27;o&#x27;,                                                                                                         
        &#x27;j&#x27;,                                                                                                         
        &#x27;e&#x27;,                                                                                                         
        &#x27;c&#x27;,                                                                                                         
        &#x27;t&#x27;                                                                                                          
    ],                                                                                                               
    casei: true                                                                                                      
}                                                                                                                    
DEBUG:grep::literals: required literals found: [Cut(FUNCT), Cut(fUNCT), Cut(FuNCT), Cut(fuNCT), Cut(FUnCT), Cut(fUnCT
), Cut(FunCT), Cut(funCT), Cut(FUNcT), Cut(fUNcT), Cut(FuNcT), Cut(fuNcT), Cut(FUncT), Cut(fUncT), Cut(FuncT), Cut(fu
ncT), Cut(FUNCt), Cut(fUNCt), Cut(FuNCt), Cut(fuNCt), Cut(FUnCt), Cut(fUnCt), Cut(FunCt), Cut(funCt), Cut(FUNct), Cut
(fUNct), Cut(FuNct), Cut(fuNct), Cut(FUnct), Cut(fUnct), Cut(Funct), Cut(funct)]                                     
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*output/*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*output/[^/]*$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Litera
l(&#x27;o&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;/&#x27;), ZeroOrMore]) }           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*bin/GitPortable*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*bin/GitPortabl
e[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Ze
roOrMore, Literal(&#x27;b&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;/&#x27;), Literal(&#x27;G&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;
P&#x27;), Literal(&#x27;o&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.vscode*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.vscode.*$&quot;, opts: Glob
Options { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;
.&#x27;), Literal(&#x27;v&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;o&#x27;), Literal(&#x27;d&#x27;), Literal(&#x27;e&#x27;), ZeroOrMore]) }              
DEBUG:globset: built glob set; 0 literals, 1 basenames, 11 extensions, 0 prefixes, 0 suffixes, 0 required extensions,
 3 regexes                                                                                                           
DEBUG:ignore::walk: ignoring ./.git: Ignore(IgnoreMatch(Hidden))                                                     
DEBUG:ignore::walk: ignoring ./.gitattributes: Ignore(IgnoreMatch(Hidden))                                           
DEBUG:ignore::walk: ignoring ./.gitignore: Ignore(IgnoreMatch(Hidden))                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOption
s { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, rang
es: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;)]) }                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;e&#x27;
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;i&#x27;), Literal(&#x27;n&#x27;)]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[(&#x27;O&#x27;, &#x27;O&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }, Literal(&#x27;b&#x27;), Literal(&#x27;j&#x27;)]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/
]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class 
{ negated: false, ranges: [(&#x27;T&#x27;, &#x27;T&#x27;), (&#x27;t&#x27;, &#x27;t&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;t&#x27;), Class { negated: fals
e, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;t&#x27;), ZeroOrMo
re]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;u&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;d&#x27;), Class { n
egated: false, ranges: [(&#x27;L&#x27;, &#x27;L&#x27;), (&#x27;l&#x27;, &#x27;l&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Lite
ral(&#x27;R&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;S&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;
r&#x27;), ZeroOrMore]) }                                                                                                  
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harpe
r$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOr
More, Literal(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Class { negated: false,
 ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;r
&#x27;)]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(
&#x27;T&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.ncrunch*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.ncrunch.*$&quot;, opts: Gl
obOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal
(&#x27;.&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), ZeroOrMore])
 }                                                                                                                   
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [(&#x27;E&#x27;, &#x27;E&#x27;), (&#x27;e&#x27;, &#x27;e&#x27;)] }, Literal(&#x27;x&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;s&#x27;
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Class { n
egated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { c
ase_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;~&#x27;), Literal(&#x27;$&#x27;), Zero
OrMore]) }                                                                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOpti
ons { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;B&#x27;), Literal(&#x27;a&#x27;)
, Literal(&#x27;c&#x27;), Literal(&#x27;k&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;p&#x27;), ZeroOrMore]) }                                             
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.py[co]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.py[co]$&quot;, opts: GlobOpt
ions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;)
, Literal(&#x27;p&#x27;), Literal(&#x27;y&#x27;), Class { negated: false, ranges: [(&#x27;c&#x27;, &#x27;c&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }]) }                         
DEBUG:globset: built glob set; 3 literals, 38 basenames, 43 extensions, 0 prefixes, 10 suffixes, 10 required extensio
ns, 15 regexes                                                                                                       
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitattributes: Ignore(IgnoreMatch(Hidden))                         
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitignore: Ignore(IgnoreMatch(Hidden))                             
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOption
s { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, rang
es: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;)]) }                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPublic&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPublic$&quot;, opts
: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated:
 false, ranges: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;P&#x27;), Lit
eral(&#x27;u&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;c&#x27;)]) }                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;e&#x27;
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleases&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleases$&quot;, opts: Glob
Options { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false
, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;
e&#x27;), Literal(&#x27;s&#x27;)]) }                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;i&#x27;), Literal(&#x27;n&#x27;)]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[(&#x27;O&#x27;, &#x27;O&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }, Literal(&#x27;b&#x27;), Literal(&#x27;j&#x27;)]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/
]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class 
{ negated: false, ranges: [(&#x27;T&#x27;, &#x27;T&#x27;), (&#x27;t&#x27;, &#x27;t&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;t&#x27;), Class { negated: fals
e, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;t&#x27;), ZeroOrMo
re]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [(&#x27;B&#x27;, &#x27;B&#x27;), (&#x27;b&#x27;, &#x27;b&#x27;)] }, Literal(&#x27;u&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;d&#x27;), Class { n
egated: false, ranges: [(&#x27;L&#x27;, &#x27;L&#x27;), (&#x27;l&#x27;, &#x27;l&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPS$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [(&#x27;D&#x27;, &#x27;D&#x27;), (&#x27;d&#x27;, &#x27;d&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;b&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;P&#x27;), Literal(&#x27;S&#x27;
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleasePS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleasePS$&quot;, opts: Gl
obOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: fal
se, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;s&#x27;), Literal
(&#x27;e&#x27;), Literal(&#x27;P&#x27;), Literal(&#x27;S&#x27;)]) }                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_Chutzpah*&quot;, re: &quot;(?-u)^(?:/?|.*/)_Chutzpah.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(
&#x27;C&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;z&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;h&#x27;), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Lite
ral(&#x27;R&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;S&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;
r&#x27;), ZeroOrMore]) }                                                                                                  
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harpe
r$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOr
More, Literal(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;R&#x27;, &#x27;R&#x27;), (&#x27;r&#x27;, &#x27;r&#x27;)] }, Literal(&#x27;e&#x27;), Class { negated: false,
 ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;h&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;r
&#x27;)]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(
&#x27;T&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;i&#x27;), Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_NCrunch_*&quot;, re: &quot;(?-u)^(?:/?|.*/)_NCrunch_.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;_&#x27;), Literal(
&#x27;N&#x27;), Literal(&#x27;C&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;n&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;_&#x27;), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.mm.*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.mm\\..*$&quot;, opts: GlobOpti
ons { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;),
 Literal(&#x27;m&#x27;), Literal(&#x27;m&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }                                                            
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [(&#x27;E&#x27;, &#x27;E&#x27;), (&#x27;e&#x27;, &#x27;e&#x27;)] }, Literal(&#x27;x&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;r&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;s&#x27;
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/packages/*&quot;, re: &quot;(?-u)^(?:/?|.*/)packages/[^/]*$&quot;, opts: Gl
obOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;p&#x27;), Litera
l(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;k&#x27;), Literal(&#x27;a&#x27;), Literal(&#x27;g&#x27;), Literal(&#x27;e&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;/&#x27;), ZeroOrMore]
) }                                                                                                                  
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Cc]ache$&quot;, opts: Glo
bOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(
&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), Literal(&#x27;
e&#x27;)]) }                                                                                                              
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*\\.[Cc]ache$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Litera
l(&#x27;.&#x27;), Class { negated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;a&#x27;), Literal(&#x27;c&#x27;), Literal(&#x27;h&#x27;), Literal
(&#x27;e&#x27;)]) }                                                                                                            
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [(&#x27;S&#x27;, &#x27;S&#x27;), (&#x27;s&#x27;, &#x27;s&#x27;)] }, Literal(&#x27;t&#x27;), Literal(&#x27;y&#x27;), Literal(&#x27;l&#x27;), Literal(&#x27;e&#x27;), Class { n
egated: false, ranges: [(&#x27;C&#x27;, &#x27;C&#x27;), (&#x27;c&#x27;, &#x27;c&#x27;)] }, Literal(&#x27;o&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;.&#x27;), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { c
ase_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal(&#x27;~&#x27;), Literal(&#x27;$&#x27;), Zero
OrMore]) }                                                                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOpti
ons { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal(&#x27;B&#x27;), Literal(&#x27;a&#x27;)
, Literal(&#x27;c&#x27;), Literal(&#x27;k&#x27;), Literal(&#x27;u&#x27;), Literal(&#x27;p&#x27;), ZeroOrMore]) }                                             
DEBUG:globset: built glob set; 4 literals, 28 basenames, 45 extensions, 0 prefixes, 15 suffixes, 9 required extension
s, 23 regexes                                                                                                        
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitattributes: Ignore(IgnoreMatch(Hid
den))                                                                                                                
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitignore: Ignore(IgnoreMatch(Hidden)
)                                                                                                                    
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-27 19:10</div>
            <div class="timeline-body"><p>OK, thanks! Keep in mind that I don&#x27;t really know much about Windows, so unfortunately most of your helpful hints aren&#x27;t things I can follow easily. :-) I dare say that someone else may need to investigate this and find out the problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 19:14</div>
            <div class="timeline-body"><p>Well good/bad news: none of the other searchers are working either. I could only find Windows binaries for Silver Searcher, Sift, and Platinum Searcher, but they all came up empty.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/retep998">@retep998</a> on 2017-04-27 19:18</div>
            <div class="timeline-body"><p>@trs4ece Can you run <code>file.metdata().unwrap().len()</code> on the files which report their size on disk as 0 despite having actual contents to see what numbers it is reporting?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 19:32</div>
            <div class="timeline-body"><p>I&#x27;m not sure of how to run that on Windows, but I got the Length and Attributes properties from the file in PowerShell:</p>
<pre><code>(Get-Item .\Library\TFS.psm1) | select Attributes,Length

                       Attributes Length
                       ---------- ------
Archive, SparseFile, ReparsePoint  77970
</code></pre>
<p>After I edit the file, its Size on Disk changes from 0 to 80 KB and its attributes also change:</p>
<pre><code>(Get-Item .\Library\TFS.psm1) | select Attributes, Length

Attributes Length
---------- ------
   Archive  77970
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/retep998">@retep998</a> on 2017-04-27 20:03</div>
            <div class="timeline-body"><p>So the file is actually a reparse point to the real file. That definitely has the potential to cause issues, especially if it is neither <code>IO_REPARSE_TAG_SYMLINK</code> nor <code>IO_REPARSE_TAG_MOUNT_POINT</code> but rather some other type of reparse point. I&#x27;d be very interested in what <code>DeviceIoControl</code> with <code>FSCTL_GET_REPARSE_POINT</code> has to say about it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 20:13</div>
            <div class="timeline-body"><p>I&#x27;d love to get that info for you, but most resources I&#x27;m finding suggest that I go write a C++ program to grab that data. Do you know of a way to grab this info from the command line?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 21:30</div>
            <div class="timeline-body"><p>This bug is unfortunate, but I don&#x27;t think it&#x27;s reasonable for me to track issues like this. Not only do I not use Windows, but I don&#x27;t know anything about reparse points or Dedupe. On top of that, this sounds like a pretty bad bug in Dedupe, and I&#x27;m not sure it&#x27;s ripgrep&#x27;s responsibility to fix it at all.</p>
<p>I&#x27;m going to close this, but if someone can come up with a <em>simple</em> patch to make this work (and even better, a regression test), the I think I&#x27;d be willing to maintain that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 21:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:04 UTC
    </footer>
</body>
</html>
