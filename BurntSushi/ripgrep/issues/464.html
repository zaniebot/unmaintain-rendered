<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RipGrep does not search files where Size on Disk == 0 - BurntSushi/ripgrep #464</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>RipGrep does not search files where Size on Disk == 0</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/464">#464</a>
        opened by <a href="https://github.com/trs4ece">@trs4ece</a>
        on 2017-04-27 18:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/trs4ece">@trs4ece</a></div>
            <div class="timeline-body"><p>Our IT department runs Dedupe on our network share which causes files &gt; 32 KB to have a Size on Disk of 0. This appears to cause RipGrep to skip over these files. This issue exists on all versions of RipGrep from 0.5.2 through at least 0.3.2.</p>
<p>Related: <a href="https://github.com/Microsoft/vscode/issues/24968">[Visual Studio Code] Global search is only searching open/viewed files #24968</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-27 18:51</div>
            <div class="timeline-body"><p>Can you help me figure out how to reproduce the issue? Can you see what happens when running <code>--no-mmap</code> and <code>--mmap</code>? Do other tools, like <code>grep</code> or <code>ag</code> (the silver searcher) or <code>sift</code> or <code>pt</code> (the platinum searcher) work for you?</p>
<p>Note that there is no specific logic in ripgrep that causes it to skip files with a file size of zero.</p>
<p>cc @retep998</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 19:07</div>
            <div class="timeline-body"><p>To reproduce the issue, you would need to enable Data Deduplication on a drive, have several copies of a file &gt; 32 KB on that drive, and then run Data Deduplication. There is a <a href="https://blogs.technet.microsoft.com/canitpro/2013/04/29/step-by-step-enabling-data-deduplication-on-windows-server-2012-volumes/">TechNet Blog</a> that describes how to enable dedupe.</p>
<p>Using PowerShell's Get-ChildItem piped into Select-String seems to work fine. I haven't tried the other tools yet. I'll try them out and let you know.</p>
<p>Here are the commands that you requested:</p>
<pre><code>λ  E:\bin\rg.exe -i --mmap 'function Connect-TFSProject' --debug
DEBUG:grep::search: regex ast:
Literal {
    chars: [
        'f',
        'u',
        'n',
        'c',
        't',
        'i',
        'o',
        'n',
        ' ',
        'C',
        'o',
        'n',
        'n',
        'e',
        'c',
        't',
        '-',
        'T',
        'F',
        'S',
        'P',
        'r',
        'o',
        'j',
        'e',
        'c',
        't'
    ],
    casei: true
}
DEBUG:grep::literals: required literals found: [Cut(FUNCT), Cut(fUNCT), Cut(FuNCT), Cut(fuNCT), Cut(FUnCT), Cut(fUnCT), Cut(FunCT), Cut(funCT), Cut(FUNcT), Cut(fUNcT), Cut(FuNcT), Cut(fuNcT), Cut(FUncT), Cut(fUncT), Cut(FuncT), Cut(funcT), Cut(FUNCt), Cut(fUNCt), Cut(FuNCt), Cut(fuNCt), Cut(FUnCt), Cut(fUnCt), Cut(FunCt), Cut(funCt), Cut(FUNct), Cut(fUNct), Cut(FuNct), Cut(fuNct), Cut(FUnct), Cut(fUnct), Cut(Funct), Cut(funct)]
DEBUG:rg::args: will try to use memory maps
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*output/*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*output/[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('o'), Literal('u'), Literal('t'), Literal('p'), Literal('u'), Literal('t'), Literal('/'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*bin/GitPortable*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*bin/GitPortable[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('b'), Literal('i'), Literal('n'), Literal('/'), Literal('G'), Literal('i'), Literal('t'), Literal('P'), Literal('o'), Literal('r'), Literal('t'), Literal('a'), Literal('b'), Literal('l'), Literal('e'), ZeroOrMore]) }DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.vscode*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.vscode.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Literal('v'), Literal('s'), Literal('c'), Literal('o'), Literal('d'), Literal('e'), ZeroOrMore]) }
DEBUG:globset: built glob set; 0 literals, 1 basenames, 11 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 3 regexes
DEBUG:ignore::walk: ignoring ./.git: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./.gitattributes: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./.gitignore: Ignore(IgnoreMatch(Hidden))
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('e')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('B', 'B'), ('b', 'b')] }, Literal('i'), Literal('n')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('O', 'O'), ('o', 'o')] }, Literal('b'), Literal('j')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('T', 'T'), ('t', 't')] }, Literal('e'), Literal('s'), Literal('t'), Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('s'), Literal('u'), Literal('l'), Literal('t'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('B', 'B'), ('b', 'b')] }, Literal('u'), Literal('i'), Literal('l'), Literal('d'), Class { negated: false, ranges: [('L', 'L'), ('l', 'l')] }, Literal('o'), Literal('g'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal('R'), Literal('e'), Literal('S'), Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('r'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harper$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Class { negated: false, ranges: [('S', 'S'), ('s', 's')] }, Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('r')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal('T'), Literal('e'), Literal('a'), Literal('m'), Literal('C'), Literal('i'), Literal('t'), Literal('y'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.ncrunch*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.ncrunch.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Literal('n'), Literal('c'), Literal('r'), Literal('u'), Literal('n'), Literal('c'), Literal('h'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('E', 'E'), ('e', 'e')] }, Literal('x'), Literal('p'), Literal('r'), Literal('e'), Literal('s'), Literal('s')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('S', 'S'), ('s', 's')] }, Literal('t'), Literal('y'), Literal('l'), Literal('e'), Class { negated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('o'), Literal('p'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('~'), Literal('$'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('B'), Literal('a'), Literal('c'), Literal('k'), Literal('u'), Literal('p'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.py[co]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.py[co]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Literal('p'), Literal('y'), Class { negated: false, ranges: [('c', 'c'), ('o', 'o')] }]) }
DEBUG:globset: built glob set; 3 literals, 38 basenames, 43 extensions, 0 prefixes, 10 suffixes, 10 required extensions, 15 regexes
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitattributes: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitignore: Ignore(IgnoreMatch(Hidden))
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPublic&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPublic$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g'), Literal('P'), Literal('u'), Literal('b'), Literal('l'), Literal('i'), Literal('c')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('e')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleases&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleases$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('e'), Literal('s')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('B', 'B'), ('b', 'b')] }, Literal('i'), Literal('n')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('O', 'O'), ('o', 'o')] }, Literal('b'), Literal('j')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('T', 'T'), ('t', 't')] }, Literal('e'), Literal('s'), Literal('t'), Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('s'), Literal('u'), Literal('l'), Literal('t'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('B', 'B'), ('b', 'b')] }, Literal('u'), Literal('i'), Literal('l'), Literal('d'), Class { negated: false, ranges: [('L', 'L'), ('l', 'l')] }, Literal('o'), Literal('g'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPS$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g'), Literal('P'), Literal('S')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleasePS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleasePS$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('e'), Literal('P'), Literal('S')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_Chutzpah*&quot;, re: &quot;(?-u)^(?:/?|.*/)_Chutzpah.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal('C'), Literal('h'), Literal('u'), Literal('t'), Literal('z'), Literal('p'), Literal('a'), Literal('h'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal('R'), Literal('e'), Literal('S'), Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('r'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harper$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Class { negated: false, ranges: [('S', 'S'), ('s', 's')] }, Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('r')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal('T'), Literal('e'), Literal('a'), Literal('m'), Literal('C'), Literal('i'), Literal('t'), Literal('y'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_NCrunch_*&quot;, re: &quot;(?-u)^(?:/?|.*/)_NCrunch_.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal('N'), Literal('C'), Literal('r'), Literal('u'), Literal('n'), Literal('c'), Literal('h'), Literal('_'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.mm.*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.mm\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Literal('m'), Literal('m'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('E', 'E'), ('e', 'e')] }, Literal('x'), Literal('p'), Literal('r'), Literal('e'), Literal('s'), Literal('s')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/packages/*&quot;, re: &quot;(?-u)^(?:/?|.*/)packages/[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('p'), Literal('a'), Literal('c'), Literal('k'), Literal('a'), Literal('g'), Literal('e'), Literal('s'), Literal('/'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Cc]ache$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Class { negated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('a'), Literal('c'), Literal('h'), Literal('e')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*\\.[Cc]ache$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'), Class { negated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('a'), Literal('c'), Literal('h'), Literal('e')]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: [('S', 'S'), ('s', 's')] }, Literal('t'), Literal('y'), Literal('l'), Literal('e'), Class { negated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('o'), Literal('p'), Literal('.'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('~'), Literal('$'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('B'), Literal('a'), Literal('c'), Literal('k'), Literal('u'), Literal('p'), ZeroOrMore]) }
DEBUG:globset: built glob set; 4 literals, 28 basenames, 45 extensions, 0 prefixes, 15 suffixes, 9 required extensions, 23 regexes
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitattributes: Ignore(IgnoreMatch(Hidden))
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitignore: Ignore(IgnoreMatch(Hidden))
</code></pre>
<pre><code>λ  E:\bin\rg.exe -i --no-mmap 'function Connect-TFSProject' --debug                                                  
DEBUG:grep::search: regex ast:                                                                                       
Literal {                                                                                                            
    chars: [                                                                                                         
        'f',                                                                                                         
        'u',                                                                                                         
        'n',                                                                                                         
        'c',                                                                                                         
        't',                                                                                                         
        'i',                                                                                                         
        'o',                                                                                                         
        'n',                                                                                                         
        ' ',                                                                                                         
        'C',                                                                                                         
        'o',                                                                                                         
        'n',                                                                                                         
        'n',                                                                                                         
        'e',                                                                                                         
        'c',                                                                                                         
        't',                                                                                                         
        '-',                                                                                                         
        'T',                                                                                                         
        'F',                                                                                                         
        'S',                                                                                                         
        'P',                                                                                                         
        'r',                                                                                                         
        'o',                                                                                                         
        'j',                                                                                                         
        'e',                                                                                                         
        'c',                                                                                                         
        't'                                                                                                          
    ],                                                                                                               
    casei: true                                                                                                      
}                                                                                                                    
DEBUG:grep::literals: required literals found: [Cut(FUNCT), Cut(fUNCT), Cut(FuNCT), Cut(fuNCT), Cut(FUnCT), Cut(fUnCT
), Cut(FunCT), Cut(funCT), Cut(FUNcT), Cut(fUNcT), Cut(FuNcT), Cut(fuNcT), Cut(FUncT), Cut(fUncT), Cut(FuncT), Cut(fu
ncT), Cut(FUNCt), Cut(fUNCt), Cut(FuNCt), Cut(fuNCt), Cut(FUnCt), Cut(fUnCt), Cut(FunCt), Cut(funCt), Cut(FUNct), Cut
(fUNct), Cut(FuNct), Cut(fuNct), Cut(FUnct), Cut(fUnct), Cut(Funct), Cut(funct)]                                     
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*output/*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*output/[^/]*$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Litera
l('o'), Literal('u'), Literal('t'), Literal('p'), Literal('u'), Literal('t'), Literal('/'), ZeroOrMore]) }           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*bin/GitPortable*&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*bin/GitPortabl
e[^/]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Ze
roOrMore, Literal('b'), Literal('i'), Literal('n'), Literal('/'), Literal('G'), Literal('i'), Literal('t'), Literal('
P'), Literal('o'), Literal('r'), Literal('t'), Literal('a'), Literal('b'), Literal('l'), Literal('e'), ZeroOrMore]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.vscode*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.vscode.*$&quot;, opts: Glob
Options { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('
.'), Literal('v'), Literal('s'), Literal('c'), Literal('o'), Literal('d'), Literal('e'), ZeroOrMore]) }              
DEBUG:globset: built glob set; 0 literals, 1 basenames, 11 extensions, 0 prefixes, 0 suffixes, 0 required extensions,
 3 regexes                                                                                                           
DEBUG:ignore::walk: ignoring ./.git: Ignore(IgnoreMatch(Hidden))                                                     
DEBUG:ignore::walk: ignoring ./.gitattributes: Ignore(IgnoreMatch(Hidden))                                           
DEBUG:ignore::walk: ignoring ./.gitignore: Ignore(IgnoreMatch(Hidden))                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOption
s { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, rang
es: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g')]) }                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('e'
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[('B', 'B'), ('b', 'b')] }, Literal('i'), Literal('n')]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[('O', 'O'), ('o', 'o')] }, Literal('b'), Literal('j')]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/
]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class 
{ negated: false, ranges: [('T', 'T'), ('t', 't')] }, Literal('e'), Literal('s'), Literal('t'), Class { negated: fals
e, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('s'), Literal('u'), Literal('l'), Literal('t'), ZeroOrMo
re]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [('B', 'B'), ('b', 'b')] }, Literal('u'), Literal('i'), Literal('l'), Literal('d'), Class { n
egated: false, ranges: [('L', 'L'), ('l', 'l')] }, Literal('o'), Literal('g'), Literal('.'), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('_'), Lite
ral('R'), Literal('e'), Literal('S'), Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('
r'), ZeroOrMore]) }                                                                                                  
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harpe
r$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOr
More, Literal('.'), Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Class { negated: false,
 ranges: [('S', 'S'), ('s', 's')] }, Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('r
')]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal(
'T'), Literal('e'), Literal('a'), Literal('m'), Literal('C'), Literal('i'), Literal('t'), Literal('y'), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.ncrunch*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.ncrunch.*$&quot;, opts: Gl
obOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal
('.'), Literal('n'), Literal('c'), Literal('r'), Literal('u'), Literal('n'), Literal('c'), Literal('h'), ZeroOrMore])
 }                                                                                                                   
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [('E', 'E'), ('e', 'e')] }, Literal('x'), Literal('p'), Literal('r'), Literal('e'), Literal('s'), Literal('s'
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [('S', 'S'), ('s', 's')] }, Literal('t'), Literal('y'), Literal('l'), Literal('e'), Class { n
egated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('o'), Literal('p'), Literal('.'), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { c
ase_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('~'), Literal('$'), Zero
OrMore]) }                                                                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOpti
ons { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('B'), Literal('a')
, Literal('c'), Literal('k'), Literal('u'), Literal('p'), ZeroOrMore]) }                                             
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.py[co]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.py[co]$&quot;, opts: GlobOpt
ions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.')
, Literal('p'), Literal('y'), Class { negated: false, ranges: [('c', 'c'), ('o', 'o')] }]) }                         
DEBUG:globset: built glob set; 3 literals, 38 basenames, 43 extensions, 0 prefixes, 10 suffixes, 10 required extensio
ns, 15 regexes                                                                                                       
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitattributes: Ignore(IgnoreMatch(Hidden))                         
DEBUG:ignore::walk: ignoring ./HPWarranty-master\.gitignore: Ignore(IgnoreMatch(Hidden))                             
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebug&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebug$&quot;, opts: GlobOption
s { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, rang
es: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g')]) }                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPublic&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPublic$&quot;, opts
: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated:
 false, ranges: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g'), Literal('P'), Lit
eral('u'), Literal('b'), Literal('l'), Literal('i'), Literal('c')]) }                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]elease&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]elease$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('e'
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleases&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleases$&quot;, opts: Glob
Options { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false
, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal('
e'), Literal('s')]) }                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]in&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]in$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[('B', 'B'), ('b', 'b')] }, Literal('i'), Literal('n')]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Oo]bj&quot;, re: &quot;(?-u)^(?:/?|.*/)[Oo]bj$&quot;, opts: GlobOptions { 
case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, ranges: 
[('O', 'O'), ('o', 'o')] }, Literal('b'), Literal('j')]) }                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Tt]est[Rr]esult*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Tt]est[Rr]esult[^/
]*$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class 
{ negated: false, ranges: [('T', 'T'), ('t', 't')] }, Literal('e'), Literal('s'), Literal('t'), Class { negated: fals
e, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('s'), Literal('u'), Literal('l'), Literal('t'), ZeroOrMo
re]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Bb]uild[Ll]og.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Bb]uild[Ll]og\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [('B', 'B'), ('b', 'b')] }, Literal('u'), Literal('i'), Literal('l'), Literal('d'), Class { n
egated: false, ranges: [('L', 'L'), ('l', 'l')] }, Literal('o'), Literal('g'), Literal('.'), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Dd]ebugPS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Dd]ebugPS$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [('D', 'D'), ('d', 'd')] }, Literal('e'), Literal('b'), Literal('u'), Literal('g'), Literal('P'), Literal('S'
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Rr]eleasePS&quot;, re: &quot;(?-u)^(?:/?|.*/)[Rr]eleasePS$&quot;, opts: Gl
obOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: fal
se, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Literal('l'), Literal('e'), Literal('a'), Literal('s'), Literal
('e'), Literal('P'), Literal('S')]) }                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_Chutzpah*&quot;, re: &quot;(?-u)^(?:/?|.*/)_Chutzpah.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal(
'C'), Literal('h'), Literal('u'), Literal('t'), Literal('z'), Literal('p'), Literal('a'), Literal('h'), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_ReSharper*&quot;, re: &quot;(?-u)^(?:/?|.*/)_ReSharper[^/]*$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('_'), Lite
ral('R'), Literal('e'), Literal('S'), Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('
r'), ZeroOrMore]) }                                                                                                  
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Rr]e[Ss]harper&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Rr]e[Ss]harpe
r$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOr
More, Literal('.'), Class { negated: false, ranges: [('R', 'R'), ('r', 'r')] }, Literal('e'), Class { negated: false,
 ranges: [('S', 'S'), ('s', 's')] }, Literal('h'), Literal('a'), Literal('r'), Literal('p'), Literal('e'), Literal('r
')]) }                                                                                                               
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_TeamCity*&quot;, re: &quot;(?-u)^(?:/?|.*/)_TeamCity.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal(
'T'), Literal('e'), Literal('a'), Literal('m'), Literal('C'), Literal('i'), Literal('t'), Literal('y'), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/_NCrunch_*&quot;, re: &quot;(?-u)^(?:/?|.*/)_NCrunch_.*$&quot;, opts: GlobO
ptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('_'), Literal(
'N'), Literal('C'), Literal('r'), Literal('u'), Literal('n'), Literal('c'), Literal('h'), Literal('_'), ZeroOrMore]) 
}                                                                                                                    
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.mm.*&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.mm\\..*$&quot;, opts: GlobOpti
ons { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal('.'),
 Literal('m'), Literal('m'), Literal('.'), ZeroOrMore]) }                                                            
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ee]xpress&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ee]xpress$&quot;, opts: GlobOp
tions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Class { negated: false, 
ranges: [('E', 'E'), ('e', 'e')] }, Literal('x'), Literal('p'), Literal('r'), Literal('e'), Literal('s'), Literal('s'
)]) }                                                                                                                
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/packages/*&quot;, re: &quot;(?-u)^(?:/?|.*/)packages/[^/]*$&quot;, opts: Gl
obOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('p'), Litera
l('a'), Literal('c'), Literal('k'), Literal('a'), Literal('g'), Literal('e'), Literal('s'), Literal('/'), ZeroOrMore]
) }                                                                                                                  
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.[Cc]ache$&quot;, opts: Glo
bOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(
'.'), Class { negated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('a'), Literal('c'), Literal('h'), Literal('
e')]) }                                                                                                              
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.[Cc]ache&quot;, re: &quot;(?-u)^(?:/?|.*/)[^/]*\\.[Cc]ache$&quot;, opts: 
GlobOptions { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Litera
l('.'), Class { negated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('a'), Literal('c'), Literal('h'), Literal
('e')]) }                                                                                                            
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/[Ss]tyle[Cc]op.*&quot;, re: &quot;(?-u)^(?:/?|.*/)[Ss]tyle[Cc]op\\..*$
&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Class { 
negated: false, ranges: [('S', 'S'), ('s', 's')] }, Literal('t'), Literal('y'), Literal('l'), Literal('e'), Class { n
egated: false, ranges: [('C', 'C'), ('c', 'c')] }, Literal('o'), Literal('p'), Literal('.'), ZeroOrMore]) }          
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/~$*&quot;, re: &quot;(?-u)^(?:/?|.*/)\\~\\$.*$&quot;, opts: GlobOptions { c
ase_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, Literal('~'), Literal('$'), Zero
OrMore]) }                                                                                                           
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/Backup*&quot;, re: &quot;(?-u)^(?:/?|.*/)Backup[^/]*$&quot;, opts: GlobOpti
ons { case_insensitive: false, literal_separator: true }, tokens: Tokens([RecursivePrefix, Literal('B'), Literal('a')
, Literal('c'), Literal('k'), Literal('u'), Literal('p'), ZeroOrMore]) }                                             
DEBUG:globset: built glob set; 4 literals, 28 basenames, 45 extensions, 0 prefixes, 15 suffixes, 9 required extension
s, 23 regexes                                                                                                        
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitattributes: Ignore(IgnoreMatch(Hid
den))                                                                                                                
DEBUG:ignore::walk: ignoring ./Manual\SMS\sms\employee-directory-csharp-master\.gitignore: Ignore(IgnoreMatch(Hidden)
)                                                                                                                    
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-04-27 19:10</div>
            <div class="timeline-body"><p>OK, thanks! Keep in mind that I don't really know much about Windows, so unfortunately most of your helpful hints aren't things I can follow easily. :-) I dare say that someone else may need to investigate this and find out the problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 19:14</div>
            <div class="timeline-body"><p>Well good/bad news: none of the other searchers are working either. I could only find Windows binaries for Silver Searcher, Sift, and Platinum Searcher, but they all came up empty.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/retep998">@retep998</a> on 2017-04-27 19:18</div>
            <div class="timeline-body"><p>@trs4ece Can you run <code>file.metdata().unwrap().len()</code> on the files which report their size on disk as 0 despite having actual contents to see what numbers it is reporting?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 19:32</div>
            <div class="timeline-body"><p>I'm not sure of how to run that on Windows, but I got the Length and Attributes properties from the file in PowerShell:</p>
<pre><code>(Get-Item .\Library\TFS.psm1) | select Attributes,Length

                       Attributes Length
                       ---------- ------
Archive, SparseFile, ReparsePoint  77970
</code></pre>
<p>After I edit the file, its Size on Disk changes from 0 to 80 KB and its attributes also change:</p>
<pre><code>(Get-Item .\Library\TFS.psm1) | select Attributes, Length

Attributes Length
---------- ------
   Archive  77970
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/retep998">@retep998</a> on 2017-04-27 20:03</div>
            <div class="timeline-body"><p>So the file is actually a reparse point to the real file. That definitely has the potential to cause issues, especially if it is neither <code>IO_REPARSE_TAG_SYMLINK</code> nor <code>IO_REPARSE_TAG_MOUNT_POINT</code> but rather some other type of reparse point. I'd be very interested in what <code>DeviceIoControl</code> with <code>FSCTL_GET_REPARSE_POINT</code> has to say about it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trs4ece">@trs4ece</a> on 2017-04-27 20:13</div>
            <div class="timeline-body"><p>I'd love to get that info for you, but most resources I'm finding suggest that I go write a C++ program to grab that data. Do you know of a way to grab this info from the command line?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-05-08 21:30</div>
            <div class="timeline-body"><p>This bug is unfortunate, but I don't think it's reasonable for me to track issues like this. Not only do I not use Windows, but I don't know anything about reparse points or Dedupe. On top of that, this sounds like a pretty bad bug in Dedupe, and I'm not sure it's ripgrep's responsibility to fix it at all.</p>
<p>I'm going to close this, but if someone can come up with a <em>simple</em> patch to make this work (and even better, a regression test), the I think I'd be willing to maintain that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2017-05-08 21:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:10 UTC
    </footer>
</body>
</html>
