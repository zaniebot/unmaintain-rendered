<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Low performance on whitespace-delimited data - BurntSushi/ripgrep #3167</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Low performance on whitespace-delimited data</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/3167">#3167</a>
        opened by <a href="https://github.com/LarsHadidi">@LarsHadidi</a>
        on 2025-10-04 15:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/LarsHadidi">@LarsHadidi</a></div>
            <div class="timeline-body"><p><strong>Ripgrep</strong> demonstrates performance comparable to that of <strong>ugrep</strong>, but when applied to whitespace-delimited data such as MPS files, its performance appears to be several times slower.</p>
Steps to reproduce:
<ol>
<li>Build ugrep from source:
<code>./build.sh</code></li>
<li>Build ripgrep from source:
<code>RUSTFLAGS=&quot;-Ctarget-cpu=native&quot; cargo build --release --features &#x27;pcre2&#x27;</code></li>
<li>Download and extract textfile:
https://miplib.zib.de/WebData/instances/hawaiiv10-130.mps.gz</li>
<li>Benchmark ugrep:
<code>hyperfine &#x27;ug --mmap -n -P \&#x27;^\w+$\&#x27; hawaiiv10-130.mps &gt; out&#x27;</code></li>
<li>Benchmark ripgrep:
<code>hyperfine &#x27;rg --mmap -n \&#x27;^\w+$\&#x27; hawaiiv10-130.mps &gt; out&#x27;</code></li>
</ol>
My results:
<p><img alt="Image" src="https://github.com/user-attachments/assets/2907ba27-4e45-486d-8b96-13f2923a4288"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-10-07 00:42</div>
            <div class="timeline-body"><p>Nice find! Note though that you&#x27;re using PCRE2 with ugrep and not with ripgrep. Not really sure why to be honest, given that the regex you&#x27;re using is pretty basic and not specific to any one engine. PCRE2 in particular seems to optimize this particular regex quite well. However, ripgrep and ugrep seem to use PCRE2 differently. You can make ripgrep have ugrep&#x27;s speed here by using PCRE2 and enabling multi-line support:</p>
<pre><code>$ hyperfine --output pipe \
    &quot;rg -c &#x27;^\w+$&#x27; hawaiiv10-130-small.mps&quot; \
    &quot;rg -c --no-unicode &#x27;^\w+$&#x27; hawaiiv10-130-small.mps&quot; \
    &quot;rg -c -P &#x27;^\w+$&#x27; hawaiiv10-130-small.mps&quot; \
    &quot;rg -c -P -U &#x27;^\w+$&#x27; hawaiiv10-130-small.mps&quot; \
    &quot;ugrep-7.5.0 -c &#x27;^\w+$&#x27; hawaiiv10-130-small.mps&quot; \
    &quot;ugrep-7.5.0 -c -P &#x27;^\w+$&#x27; hawaiiv10-130-small.mps&quot;
Benchmark 1: rg -c &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
  Time (mean ± σ):      1.022 s ±  0.006 s    [User: 1.004 s, System: 0.017 s]
  Range (min … max):    1.014 s …  1.031 s    10 runs

Benchmark 2: rg -c --no-unicode &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
  Time (mean ± σ):     288.9 ms ±   2.7 ms    [User: 270.9 ms, System: 17.4 ms]
  Range (min … max):   285.2 ms … 292.1 ms    10 runs

Benchmark 3: rg -c -P &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
  Time (mean ± σ):     415.3 ms ±   7.8 ms    [User: 397.1 ms, System: 17.4 ms]
  Range (min … max):   397.4 ms … 426.8 ms    10 runs

Benchmark 4: rg -c -P -U &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
  Time (mean ± σ):     127.1 ms ±  17.2 ms    [User: 108.3 ms, System: 18.5 ms]
  Range (min … max):   104.6 ms … 150.4 ms    22 runs

Benchmark 5: ugrep-7.5.0 -c &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
  Time (mean ± σ):     415.8 ms ±   6.1 ms    [User: 361.0 ms, System: 54.1 ms]
  Range (min … max):   410.7 ms … 429.9 ms    10 runs

Benchmark 6: ugrep-7.5.0 -c -P &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
  Time (mean ± σ):     171.1 ms ±   5.0 ms    [User: 118.8 ms, System: 51.9 ms]
  Range (min … max):   155.6 ms … 179.5 ms    17 runs

Summary
  rg -c -P -U &#x27;^\w+$&#x27; hawaiiv10-130-small.mps ran
    1.35 ± 0.19 times faster than ugrep-7.5.0 -c -P &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
    2.27 ± 0.31 times faster than rg -c --no-unicode &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
    3.27 ± 0.45 times faster than rg -c -P &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
    3.27 ± 0.45 times faster than ugrep-7.5.0 -c &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
    8.05 ± 1.09 times faster than rg -c &#x27;^\w+$&#x27; hawaiiv10-130-small.mps
</code></pre>
<p>I also added a run above with ripgrep&#x27;s default regex engine that disables Unicode. In particular, when Unicode is disabled, the <code>regex</code> crate is able to optimize the pattern a little differently than it can with Unicode mode enabled.</p>
<p>Aside from making the <code>regex</code> crate do whatever PCRE2 is doing for this regex, the main issue here I think is why you need to enable multi-line mode to get the most out of PCRE2 here in ripgrep but not for ugrep. IIRC, the reason for this is that with multi-line mode disabled, ripgrep falls back to its slow line-at-a-time search since it cannot be sure that PCRE2 won&#x27;t match across a line. In particular, the fast line search works by feeding the regex engine a bunch of lines all at once without parsing out each individual line. This works <em>especially</em> well when there are few matches relative to the haystack size, as is the case here.</p>
<p>The <code>regex</code> crate exposes some lower level APIs that permit analysis of the regex to make inferences about what it&#x27;s allowed to match. Or even <em>change</em> the pattern to make it impossible for it to match through a line terminator by construction. PCRE2 doesn&#x27;t allow this, so I&#x27;m not sure what ugrep is doing here exactly. In particular, ugrep does seem to avoid having PCRE2 match through a line terminator in at least this basic case:</p>
<pre><code>$ cat simple-test
abc
xyz
$ ugrep-7.5.0 -P &#x27;\w+\s+\w+&#x27; simple-test
$
</code></pre>
<p>Buuuuuuuuuuuut... if I change the pattern up a little bit......</p>
<pre><code>$ ugrep-7.5.0 -P &#x27;\w+[\x09-\x20]+\w+&#x27; simple-test
abc
xyz
</code></pre>
<p>I don&#x27;t know if this is intended behavior on ugrep&#x27;s part. In contrast, ripgrep preserves line oriented matching semantics in all cases unless you specifically opt out of it:</p>
<pre><code>$ rg -P &#x27;\w+[\x09-\x20]+\w+&#x27; simple-test
$ rg -P -U &#x27;\w+[\x09-\x20]+\w+&#x27; simple-test
1:abc
2:xyz
</code></pre>
<p>Since ripgrep is more conservative about applying this sort of optimization, it&#x27;s slower in your specific case but correct in other cases.</p>
<p>With that said, ugrep&#x27;s default regex engine seems to have similar behavior here:</p>
<pre><code>$ ugrep-7.5.0 &#x27;\w+[\x09-\x20]+\w+&#x27; simple-test
abc
xyz
$ ugrep-7.5.0 &#x27;\w+\s+\w+&#x27; simple-test
</code></pre>
<p>OK, looking at ugrep&#x27;s README, I see this:</p>
<blockquote>
<p>full Unicode extended regex pattern syntax with multi-line pattern matching without any special command-line options</p>
</blockquote>
<p>And <a href="https://github.com/Genivia/ugrep?tab=readme-ov-file#matching-multiple-lines-of-text">this</a>.</p>
<p>This seems weird to me especially because of <code>\s</code>, where since ugrep has no explicit opt-in, I guess it always has to remove <code>\n</code> from the <code>\s</code> character class? Let&#x27;s try some other examples:</p>
<pre><code>$ ugrep-7.5.0 &#x27;\w+[[:space:]]+\w+&#x27; simple-test
$
</code></pre>
<p>So that means <code>\n</code> is removed from <code>[[:space:]]</code> as well. And this seems to happen even if we attempt to match a <code>\n</code> elsewhere in the pattern:</p>
<pre><code>$ ugrep-7.5.0 &#x27;\w+\n?[[:space:]]+\w+&#x27; simple-test
$
</code></pre>
<p>Is <code>\n</code> removed from <code>\W</code> or other character class negations?</p>
<pre><code>$ ugrep-7.5.0 &#x27;\w+[^a-z]+\w+&#x27; simple-test
$ ugrep-7.5.0 &#x27;\w+\W+\w+&#x27; simple-test
abc
xyz
$ rg &#x27;\w+\W+\w+&#x27; simple-test
$ rg &#x27;\w+[^a-z]+\w+&#x27; simple-test
$
</code></pre>
<p>... so, sometimes yes, sometimes no. Odd. I tried looking in ugrep&#x27;s source to see how this is implemented, but couldn&#x27;t find it after 5 minutes of searching (my C++ is only barely passable).</p>
<p>So from what I can tell, ugrep is generally behaving as it is described on the tin. By making multi-line searching effectively always enabled by virtue of what the pattern matches (with some changes to the definitions of classes like <code>\s</code> to presumably behave as most might expect in <em>common</em> cases), ugrep can run PCRE2 without fear on big batches of lines. ripgrep can do the same, but it requires you to opt into multi-line mode.</p>
<p>Since I have no plans of adopting ugrep&#x27;s mutli-line behavior here (I <em>like</em> that there is a special opt-in flag for it), I think this performance difference between <code>rg -P</code> and <code>ugrep -P</code> is probably working as intended. As for the perf difference between the <code>regex</code> crate and PCRE2, I created <a href="https://github.com/rust-lang/regex/issues/1301">rust-lang/regex#1301</a> to track that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-10-07 00:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wontfix</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-10-07 00:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/LarsHadidi">@LarsHadidi</a> on 2025-10-12 15:07</div>
            <div class="timeline-body"><p>Thanks a lot for the thorough and insightful explanation. It was engaging and quite educational to follow your deep dive into how ripgrep and ugrep handle PCRE2 differently and why multiline mode affects performance.</p>
<p>Knowing the right combination of flags makes ripgrep the fastest one.
I really appreciate the time and effort you put into this detailed investigation.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:14 UTC
    </footer>
</body>
</html>
