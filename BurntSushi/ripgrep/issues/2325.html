<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show capturing groups in `--json` mode - BurntSushi/ripgrep #2325</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Show capturing groups in <code>--json</code> mode</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2325">#2325</a>
        opened by <a href="https://github.com/pmkap">@pmkap</a>
        on 2022-10-07 21:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/pmkap">@pmkap</a></div>
            <div class="timeline-body"><p>I couldn't find any way to show capturing groups in <code>--json</code> mode.</p>
<p>Motivation:
Sometimes I'm interested in a group. After parsing the json, I need to filter the group in an additional step. Possibly with the same regex as in the first step. In such cases it would be nice if this was directly supported.</p>
<p>Example how this feature could look like:</p>
<p><code>echo 'Hello! !World! !foo!' | rg --json '!(\w+?)!' | jq</code></p>
<pre><code class="language-json">&quot;submatches&quot;: [
  {
    &quot;match&quot;: {
      &quot;text&quot;: &quot;!World!&quot;
    },
    &quot;groups&quot; : [
      {
        &quot;1&quot;: &quot;World&quot;
      }
    ]
  },
  {
    &quot;match&quot;: {
      &quot;text&quot;: &quot;!foo!&quot;
    },
    &quot;groups&quot; : [
      {
        &quot;1&quot;: &quot;foo&quot;
      }
    ]
  }
]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2022-10-07 21:13</div>
            <div class="timeline-body"><p>Related #1872</p>
<p>Could you please provide an end-to-end use case where you'd want this? My suspicion is that it isn't necessary. The other issue here is that resolving capturing groups can be slow, so it would need to be behind a flag, i.e., <code>--json-captures</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @BurntSushi on 2022-10-07 21:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2022-10-07 21:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pmkap">@pmkap</a> on 2022-10-07 22:46</div>
            <div class="timeline-body"><p>Thank you for your help!</p>
<p>Like you suspected, I actually did find a solution (without the <code>--json</code> flag).</p>
<p>My use case was the following:
I am using <a href="https://github.com/logseq/logseq">Logseq</a> for taking notes. It has pages that can reference each other with either <code>[[ref]]</code> of <code>#ref</code>. The idea that I'm playing around with is to search a directory for all those references with <code>rg</code> and hook the results into vim's completion.</p>
<p>The solution I now have is <code> rg -o -e '\[\[(?P&lt;g1&gt;.+?)\]\]' -e '#(?P&lt;g2&gt;[^\s#]+)' -r '$g1$g2'</code></p>
<p>I stumbled upon the <code>--json</code> flag in the manpage and thought it was a good idea to use...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @pmkap on 2022-10-07 22:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/acheronfail">@acheronfail</a> on 2023-06-21 01:48</div>
            <div class="timeline-body"><p>I'd like to consider re-opening this issue, since I have a use case for it!
I have built a tool that wraps <code>ripgrep</code> - it's called <code>repgrep</code>: https://github.com/acheronfail/repgrep/.</p>
<p>If we could somehow provide capturing groups in the JSON output (don't mind if it's gated behind a flag or something) then it would enable using <code>repgrep</code> to replace capturing groups, so users could match on something like <code>foo (\w+)</code> and then, when replacing with <code>repgrep</code>, they could use something like <code>bar $1</code> to use the capturing group in the replacement text.</p>
<hr />
<p>I suppose the only way I could work around this, is if I used <code>ripgrep</code> as a <code>lib</code> (which still seems to be in the experimental phase). That would require a significant refactor of my tool, though - and until <code>libripgrep</code> is stable, I don't think it's a good idea for <code>repgrep</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-06-21 20:43</div>
            <div class="timeline-body"><p>@acheronfail Is it possible for you to just re-run the regex on the matched lines to get capture groups?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/acheronfail">@acheronfail</a> on 2023-06-22 09:49</div>
            <div class="timeline-body"><p>@BurntSushi that is a possible workaround, yes.</p>
<p>In fact, it does seem like this is the strategy that VSCode uses:</p>
<ul>
<li><a href="https://github.com/microsoft/vscode/blob/main/src/vs/workbench/services/search/node/ripgrepFileSearch.ts">runs ripgrep when it's using the <code>node</code> backend</a></li>
<li><a href="https://github.com/microsoft/vscode/blob/main/src/vs/workbench/services/search/common/replace.ts#L103">when replacing, uses JavaScript regexes to perform replacements</a></li>
</ul>
<p>So, my program doesn't depend on any regular expression functionality right now, so including a regex crate and using that to match on the lines would definitely be a solution to the issue. I can't imagine it would be that hard, perhaps the only thing is detecting whether a regular expression with groups was passed... I imagine a regex crate would be able to tell me this in some way.</p>
<p>In terms of a performance trade off - I don't think it would be that bad. Since I only need to perform the regular expression matches on visible lines (<code>repgrep</code> is a terminal user interface) I can make it fast enough.</p>
<p>The main bottleneck in performance in <code>repgrep</code> though, <a href="https://github.com/acheronfail/repgrep/tree/master/benches">is reading the JSON output itself </a>, but that's only really fixed by using <code>ripgrep</code> as a lib.</p>
<p>Long story short: @BurntSushi I think it makes sense for <code>repgrep</code> just to re-run a regular expression on each matched line as needed! Forget about my comment, but I really appreciate you taking the time to humour me! :heart:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CabalCrow">@CabalCrow</a> on 2024-05-18 10:29</div>
            <div class="timeline-body"><p>I would like to reopen the issue since I also have a use case for it.</p>
<p>I'm using nushell to parse strings into structured data, but I want to use rg for the actual regex. The parsing requires the capture groups numbers &amp; names, as well as what they actually capture to structure the data (each capture group number/name represent a column &amp; each row is a match). Having a <code>--json-captures</code> flag would help a lot with this, since I could just parse the json instead to create that structured data. Currently I'm trying to just manually obtain the captured group names (via a regex checking the regex given to rg) &amp; numbering to then programically create <code>-or '1: $1\n...name:$name\n..'</code> output for rg to then parse. This is obviously not the best solution - it would be more sensible to directly get the capture group names &amp; what their contain directly from rg.</p>
<p>Additionally <code>--json-captures</code> is going to be very useful for debugging purposes when using rg.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:43:34 UTC
    </footer>
</body>
</html>
