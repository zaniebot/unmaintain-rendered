<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Patterns may affect each other when multiple patterns are provided - BurntSushi/ripgrep #2480</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Patterns may affect each other when multiple patterns are provided</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2480">#2480</a>
        opened by <a href="https://github.com/gofri">@gofri</a>
        on 2023-03-29 15:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/gofri">@gofri</a></div>
            <div class="timeline-body">What version of ripgrep are you using?
<p>13.0.0</p>
How did you install ripgrep?
<p>brew</p>
What operating system are you using ripgrep on?
<p>MacOS M1</p>
Describe your bug.
<p>When providing multiple patterns via either <code>-e</code> or <code>-f</code>,
specified flags affect all following patterns.</p>
What are the steps to reproduce the behavior?
<pre><code>Text
</code></pre>
What is the actual behavior?
<p>rg respect the case-insensitive flag <code>(?i)</code> from the first pattern in the second pattern as well.</p>
<pre><code>DEBUG|globset|crates/globset/src/lib.rs:421: built glob set; 0 literals, 0 basenames, 12 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
Text
</code></pre>
<p>Same goes for:
<code>echo &#x27;MyText&#x27; | rg -f &lt;(printf &#x27;(?i)notintext\ntext&#x27;)</code></p>
What is the expected behavior?
<p>Empty result (the case-insensitive flag should not affect the second pattern).</p>
What do you think ripgrep should have done?
<p>Treat each pattern independently.
Specifically, for these pattern, I&#x27;d expect the merged pattern to be:
<code>&#x27;(?:(?i)notintext&#x27;)|(?:&#x27;text&#x27;)</code>
rather than:
<code>&#x27;(?i)notintext&#x27;|&#x27;text&#x27;</code></p>
Side notes:
<ol>
<li>Works as expected if I manually wrap each pattern as <code>(?:PATTERN)</code></li>
<li>Works as expected if I replace the first pattern with <code>(?i:notintext)</code></li>
<li>Works as expected if I replace the order of the patterns (because the effect of the flag only applies &quot;to the right&quot;)</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-03-29 15:11</div>
            <div class="timeline-body"><p>Yeah so you are indeed correct that ripgrep just does a simple join with <code>|</code> as the delimiter: https://github.com/BurntSushi/ripgrep/blob/041544853c86dde91c49983e5ddd0aa799bd2831/crates/core/args.rs#L703</p>
<p>ripgrep could make the situation much better by wrapping each pattern in a <code>(?:&lt;pattern&gt;)</code>. It would resolve your specific problem for example. And this would be easy to do I think. And it would work for PCRE2. So we should do that.</p>
<p>But it doesn&#x27;t quite make things completely independent. Because you could still do things like <code>-e foo)(?i)bar(</code> to sneakily insert a <code>(?i)</code> (for example). Fixing <em>that</em> probably requires trying to parse each pattern individually and ensuring each pattern is itself valid. A little more work, but not a huge deal to do. However, that won&#x27;t work for PCRE2 unless you go and actually try to compile every pattern individually. (Because PCRE2 doesn&#x27;t expose its own parser.) That is potentially a lot more work. Another possibility is to just write a simple little mini parser that just makes sure parentheses are balanced. I think you&#x27;d just have to account for escapes and character classes, which should be... somewhat simple?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-03-29 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gofri">@gofri</a> on 2023-04-11 10:01</div>
            <div class="timeline-body"><p>I wrote the following code that should act as the mini parser you mentioned.
If it looks legit to you (or somewhat legit) I can try to create a PR to use it there (with testing, documentation, etc.).</p>
<p>The guiding principles:</p>
<ol>
<li>we only try to detect cases where invalid balance would affect later patterns, and may result in a valid joined pattern constructed from invalid patterns.</li>
<li>assume that any other pattern invalidity would fail the validity check of the combined pattern (i.e., including negative balance, e.g. <code>ab)c</code> / <code>ab]c</code>)
O(n); optimize for valid patterns (and simplicity); do not try to fail early for invalid patterns.</li>
</ol>
<p>p.s. the code here is just for sanity check and we can discuss details in the PR, shall there be one.
p.s.2. The code for the kind/error is trivial so I left it out for this comment.</p>
<pre><code>fn validate_subpattern_safety(pattern: &amp;str) -&gt; Result&lt;(), BalanceError&gt; {
    let (mut escape, mut round_depth, mut square_depth) = (false, 0, 0);

    for c in pattern.chars() {
        if escape {
            // escape takes precedence over all states; render the current char literal
            escape = false;
        } else if c == &#x27;\\&#x27; {
            // escape takes precedence over all states; move to escape state
            escape = true;
        } else if square_depth &gt; 0 {
            // character classes take precedence over round brackets
            match c {
                &#x27;[&#x27; =&gt; square_depth += 1,
                &#x27;]&#x27; =&gt; square_depth -= 1,
                _ =&gt; {} // any char is literal inside character classes (balance-wise)
            }
        } else if round_depth &gt; 0 &amp;&amp; c == &#x27;)&#x27; {
            // only acconut for round bracket closures for balance correctness
            round_depth -= 1;
        } else {
            // the ground state: move to a higher state or ignore
            match c {
                &#x27;(&#x27; =&gt; round_depth += 1,
                &#x27;[&#x27; =&gt; square_depth += 1,
                _ =&gt; {} // ignore literal chars and bracket closers
            };
        }
    }

    let kind = if escape {
        Some(ErrUnbalanceKind::TrailingBackslash)
    } else if square_depth &gt; 0 {
        Some(ErrUnbalanceKind::UnbalancedSquareBrackets)
    } else if round_depth &gt; 0 {
        Some(ErrUnbalanceKind::UnbalanceRoundBrackets)
    } else {
        None
    };

    match kind {
        Some(kind) =&gt; BalanceError::new(kind, pattern.to_string()),
        None =&gt; Ok(()),
    }
}

fn join_patterns_safely(patterns: &amp;[String]) -&gt; Result&lt;String, BalanceError&gt; {
    match patterns.len() {
        0 =&gt; Ok(&quot;&quot;.to_string()),
        1 =&gt; Ok(patterns.first().unwrap().to_owned()),
        _ =&gt; patterns // note: can apply to all but the last
            .iter()
            .map(|p| {
                validate_subpattern_safety(p)?;
                Ok(format!(&quot;(?:{})&quot;, p))
            })
            .collect::&lt;Result&lt;Vec&lt;String&gt;, BalanceError&gt;&gt;()
            .map(|ps| ps.join(&quot;|&quot;)),
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-04-11 11:10</div>
            <div class="timeline-body"><p>Thanks for the effort! Unfortunately, it&#x27;s just not <em>quite</em> right. It doesn&#x27;t account for the fact that <code>[[]</code> and <code>[\[]</code> are equivalent, for example. Honestly, there&#x27;s probably other stuff. And especially so for PCRE2, which has a fair bit more syntax than the default engine.</p>
<p>After thinking on it some more, I think for now, I&#x27;d rather just add the <code>(?:&lt;pattern&gt;)</code> wrapping and call that good enough. If folks end up running into problems there, then we can re-evaluate later. But I might just end up marking it as <code>wontfix</code>.</p>
<p>Also, one small note: the perf for something like a routine for what you wrote is basically insignificant. Consider how much work a regex engine needs to do to compile a regex into a matcher. It&#x27;s <em>a lot</em> more work than a simple parser like that. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gofri">@gofri</a> on 2023-04-11 11:36</div>
            <div class="timeline-body"><p>Thanks for the quick response!</p>
<blockquote>
<p>It doesn&#x27;t account for the fact that [[] and [[] are equivalent, for example.</p>
</blockquote>
<p>I actually tested for unescaped brackets inside char-class and got a parse error:</p>
<pre><code>echo &#x27;\[&#x27; | rg &#x27;[[]&#x27;
regex parse error:
    [[]
     ^^
error: unclosed character class
</code></pre>
<p>But I tested now with <code>--engine pcre2</code> and it does work there, as you said.</p>
<p>I looked for other cases in PCRE2 now and didn&#x27;t find a particular problem.
Specifically, since names can&#x27;t include curly/round brackets, we can ignore <code>&lt;&gt;</code> because it&#x27;s within the constraints (i.e. an invalid pattern can&#x27;t lead to a valid combined pattern).</p>
<p>I feel you on going with the <code>(?:&lt;pattern&gt;)</code> wrapping, but I think that fixing the <code>[[]</code> issue shouldn&#x27;t be too hard at this point.
So, let me know if you&#x27;d consider merging it if I fixed that part (or otherwise, if you can think of other uncovered cases that I missed, and I&#x27;ll just quit the attempt anyway)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-04-11 11:42</div>
            <div class="timeline-body"><p>Whoops, I meant that <code>[]]</code> and <code>[\]]</code> are equivalent.</p>
<p>For now, I&#x27;d rather go with the <code>(?:pattern)</code> approach and just stop there. It&#x27;s simple and fixes the most pressing problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-07-08 22:52</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:13 UTC
    </footer>
</body>
</html>
