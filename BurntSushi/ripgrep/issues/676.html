<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Request: Binaries for ARM / Raspberry Pi - BurntSushi/ripgrep #676</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Request: Binaries for ARM / Raspberry Pi</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/676">#676</a>
        opened by <a href="https://github.com/n8henrie">@n8henrie</a>
        on 2017-11-12 20:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/n8henrie">@n8henrie</a></div>
            <div class="timeline-body"><p>Ripgrep is so fast and lightweight that it really seems like it would shine on low-resources devices like the Raspberry Pi. Unfortunately, the current binaries don&#x27;t include an ARM compatible release. Additionally, the process for cross-compiling with Rust from OSX to ARM seems <a href="https://github.com/Ragnaroek/rust-on-raspberry-docker">more complicated than I anticipated</a> (at least compared to Go), and installing Rust on the Pi seems like a little more work than I&#x27;d hope for just to be able to install ripgrep.</p>
<p>If there&#x27;s any way the <code>armv7-unknown-linux-gnueabihf</code> target could be added as one of the binaries you provide for easy download, I bet it would see a decent amount of use from fellow Raspberry Pi users.  As someone unfamiliar with Rust, trying to figure out rustup and cross compiling is currently taking up a lot of my day, and a simple <code>wget</code> and <code>tar xzf</code> certainly sounds appealing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jeffvandyke">@jeffvandyke</a> on 2017-11-20 16:39</div>
            <div class="timeline-body"><p>I&#x27;m actually pretty interested in a &quot;Rust -&gt; LLVM -&gt; anything else&quot; build process, so in the next week or so I might investigate getting that to work with ripgrep. Can&#x27;t promise anything though!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-22 12:13</div>
            <div class="timeline-body"><p>I will say two things:</p>
<ol>
<li>In general, I am in favor of this.</li>
<li>The release process is already a slog for me. I don&#x27;t have any easy way of testing ARM release artifacts. If this somehow increases the release burden for me in any appreciable way, then I probably won&#x27;t do it. In that case, someone else will need to step up. However, I am willing to try it.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-22 12:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-22 12:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-22 12:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/n8henrie">@n8henrie</a> on 2017-11-23 22:13</div>
            <div class="timeline-body"><p>Thanks for considering! I would think this should just add an additional target to however Rust does its builds, as long as you&#x27;re on Linux (which seems to have better options for ARM cross compiling than MacOS). I don&#x27;t know if there is a (free) CI that has ARM support, if so that might be helpful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-12-18 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/n8henrie">@n8henrie</a> on 2018-02-12 18:56</div>
            <div class="timeline-body"><p>Was excited to test these out after seeing the 0.8.0 release notes and remembering your limited ability to test per this conversation. The release at https://github.com/BurntSushi/ripgrep/releases/download/0.8.0/ripgrep-0.8.0-arm-unknown-linux-gnueabihf.tar.gz seems to work great on my RPi 3 -- thank you!</p>
<p>Unfortunately I get</p>
<pre><code>$ ./rg --version
Illegal instruction
</code></pre>
<p>on my Pi Zero, which is armv6.</p>
<p>Are you sure the release labeled <code>ripgrep-0.8.0-arm-unknown-linux-gnueabihf</code> is actually <code>arm-unknown-linux-gnueabihf</code> and not <code>armv7-unknown-linux-gnueabihf</code> (which I had mentioned above)?</p>
<p>When I cross-compile on my Pi3, <code>cargo build --release --target arm-unknown-linux-gnueabihf</code> produces a build that works on both the ARMv6 Pi Zero and ARMv7 Pi3, but the <code>armv7-unknown-linux-gnueabihf</code> target produces a build that results in the <code>Illegal instruction</code> like I&#x27;m seeing with the new release, so it makes me wonder.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-12 19:06</div>
            <div class="timeline-body"><p>@n8henrie TL;DR - I have no idea. :-)</p>
<p>An illegal instruction usually pops up when someone tries to run a binary that was compiled for more advanced CPU features than their system has. But the <a href="https://github.com/BurntSushi/ripgrep/blob/81afe8c5a0a04960353b68731a0c6d31436da04e/ci/before_deploy.sh#L10-L17">ARM build does not add any additional CPU features since it isn&#x27;t considered an SSSE3 target</a> (which makes sense, since SSSE3 is an x86 thing).</p>
<p>Basically, someone else will need to debug this. I did actually try running the CI build on my machine, but installing the requisite cross compiler required me to build from source on Archlinux, and I don&#x27;t feel like doing that. But basically, the compilers being used are in the <code>.travis.yml</code> here: https://github.com/BurntSushi/ripgrep/blob/81afe8c5a0a04960353b68731a0c6d31436da04e/.travis.yml#L40-L43 And the <code>$TARGET</code> used is here: https://github.com/BurntSushi/ripgrep/blob/81afe8c5a0a04960353b68731a0c6d31436da04e/.travis.yml#L36 which is <code>arm-unknown-linux-gnueabihf</code>, which seems to be what you want.</p>
<p>So... I don&#x27;t know. :-/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/n8henrie">@n8henrie</a> on 2018-02-22 07:12</div>
            <div class="timeline-body"><p>Also running Arch as my primary Linux box -- took a little figuring out, but seems to be sufficient to install <code>arm-linux-gnueabihf-gcc</code> from AUR and set <code>~/.cargo/config</code> to</p>
<pre><code>[target.arm-unknown-linux-gnueabihf]                                                                                                                                                                                          
linker = &quot;arm-linux-gnueabihf-gcc&quot;                                                                                                                                                                                            

[target.armv7-unknown-linux-gnueabihf]                                                                                                                                                                                        
linker = &quot;arm-linux-gnueabihf-gcc&quot;   
</code></pre>
<p>With <code>cargo build --release --target=arm-unknown-linux-gnueabihf</code>, I get a version that runs fine on my armv6 Pi Zero. With <code>cargo build --release --target=armv7-unknown-linux-gnueabihf</code>, I get <code>Illegal instruction</code>, just like with the version from the 0.8 release (which works on my armv7 machines). Very odd.</p>
<p>Wonder if it may be <a href="https://raspberrypi.stackexchange.com/a/58986">related to this SO answer</a> saying that the <code>armhf</code> packages available in Debian-based distros may not work for armv6.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/n8henrie">@n8henrie</a> on 2018-02-22 21:08</div>
            <div class="timeline-body"><p>I got an AWS Ubuntu instance to see if I could reproduce this issue. Interestingly, I also have to manually install <code>gcc</code>, which I don&#x27;t see in the travis file (and isn&#x27;t pre-installed AFAIK), and I just used the <code>gcc-arm-linux-gnueabihf</code> package instead of the individual ones you&#x27;re using.</p>
<pre><code>sudo apt -y install gcc gcc-arm-linux-gnueabihf
</code></pre>
<p>After that, I can compile <code>armv7-unknown-linux-gnueabihf</code> and <code>arm-unknown-linux-gnueabihf</code> versions which -- just like the others -- both work on my armv7 RPi3, but not on my armv6 RPi Zero.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-22 21:16</div>
            <div class="timeline-body"><p>@n8henrie Bummer. Thanks for looking into this though! Is this a bug in the Ubuntu packages, or are there additional/different gcc compilers that should be installed?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/n8henrie">@n8henrie</a> on 2018-03-09 15:56</div>
            <div class="timeline-body"><p>Looks like this confirms a problem with the Ubuntu package being armv7 specific: <a href="https://github.com/rust-lang/rust/issues/38570">rust-lang/rust#38570</a></p>
<p>Everything I&#x27;m seeing recommends using https://github.com/raspberrypi/tools, which I imagine may make a RPi-specific binary. If I figured out how to do this on Travis, would you be willing to accept a PR to that effect?</p>
<p>While it is an official repo (so I figure should be somewhat reliable), it looks like there are no releases or tags, so I imagine it would involve downloading the master branch and using that to cross-compile and releasing a version specific for RPi.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-03-09 16:05</div>
            <div class="timeline-body"><blockquote>
<p>If I figured out how to do this on Travis, would you be willing to accept a PR to that effect?</p>
</blockquote>
<p>Yes, as long as the build times are reasonable. If you have to build the compiler, then I expect the build times would become unreasonable.</p>
<p>(And my usual caveat applies. If I&#x27;m trying to do a release and the ARM build fails, then I won&#x27;t spend much time on trying to fix it. If it does fail, I&#x27;ll make the release anyway, and would be happy to try a subsequent patch release if the problem with the ARM build got fixed.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/n8henrie">@n8henrie</a> on 2018-03-18 22:27</div>
            <div class="timeline-body"><p>It doesn&#x27;t need to build the compiler, just cloning from the official <a href="https://github.com/raspberrypi/tools">raspberrypi/tools</a> and set that as the linker.</p>
<p>On my AWS Ubuntu testbox, the following script installs a binary that works on my armv6 and armv7 Raspberry Pis (like building on Arch).</p>
<pre><code>#! /bin/bash

set -e

BUILDDIR=&quot;${HOME}/build-rpi&quot;
mkdir -p &quot;${BUILDDIR}&quot;
test -d &quot;${BUILDDIR}/tools&quot; || git -C &quot;${BUILDDIR}&quot; clone --depth=1 https://github.com/raspberrypi/tools.git
test -d &quot;${BUILDDIR}/ripgrep&quot; || git -C &quot;${BUILDDIR}&quot; clone --depth=1 --branch=0.8.1 https://github.com/BurntSushi/ripgrep.git

sudo apt update &amp;&amp; sudo apt install -y gcc

PATH=&quot;${HOME}/.cargo/bin:${PATH}&quot;
rustc --version || curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain=&quot;stable&quot;

rustup target add arm-unknown-linux-gnueabihf

cat &lt;&lt;EOF &gt; &quot;${HOME}&quot;/.cargo/config
[target.arm-unknown-linux-gnueabihf]
linker = &quot;${HOME}/build-rpi/tools/arm-bcm2708/arm-linux-gnueabihf/bin/arm-linux-gnueabihf-gcc&quot;
EOF

pushd &quot;${BUILDDIR}/ripgrep&quot;
cargo build --release --target=arm-unknown-linux-gnueabihf
popd
</code></pre>
<p>Assuming the ripgrep repo is already cloned and that gcc and rustup are already installed (since the Travis environment will already have those), it takes 5m34s to add the <code>arm-unknown-linux-gnueabihf</code> target, clone the linker, and build the rpi release on the AWS nano instance. If I also assume the <code>arm-unknown-linux-gnueabihf</code> target is already added, it takes 5m25s. I made sure to <code>cargo clean</code> in between. I can&#x27;t say how these times on a nano instance will compare to the Travis build environment.</p>
<p>If I first run the <code>armv7-unknown-linux-gnueabihf</code> target (after installing the <code>addons</code> you&#x27;ve included for arm), it takes 4m12s, so I guess there are some intermediates that can be reused.</p>
<p>I&#x27;d be happy to work on a PR, but I&#x27;m not sure how to change the <code>TARGET</code> envvar without conflicting with the current ARM target, which is probably more appropriate for generic ARM architectures (this would probably be best released as <code>arm-rpi-</code> or something of the sort, since I don&#x27;t know if the toolchain will work on other non-rpi devices, but it still uses <code>--target=arm-unknown-linux-gnueabihf</code> which I assume would overwrite the other ARM release).</p>
<p>The other ARM release could be specified as the ARMV7 target (since that what it seems to work on), and <code>arm-unknown-linux-gnueabihf</code> could be used for this one, but that still wouldn&#x27;t help point out to users that this one may be rpi specific.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:05 UTC
    </footer>
</body>
</html>
