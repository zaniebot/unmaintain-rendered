<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support `-1` for single-result matching - BurntSushi/ripgrep #1348</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support <code>-1</code> for single-result matching</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/1348">#1348</a>
        opened by <a href="https://github.com/alexmv">@alexmv</a>
        on 2019-08-14 03:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/alexmv">@alexmv</a></div>
            <div class="timeline-body"><h4>What version of ripgrep are you using?</h4>
<pre><code>mycon ~ $ rg --version
ripgrep 11.0.2 (rev 3de31f7527)
-SIMD -AVX (compiled)
-SIMD -AVX (runtime)
</code></pre>
<h4>How did you install ripgrep?</h4>
<p>apt package from Releases.</p>
<h4>What operating system are you using ripgrep on?</h4>
<pre><code>mycon ~ $ lsb_release -d
Description:	Ubuntu 16.04.5 LTS
</code></pre>
<h4>Describe your question, feature request, or bug.</h4>
<p>Searching in a large number of files for the only file that can match is may be slower than it needs to be.  As an example, my inciting use case is looking for the location of a mail message in a reasonably-sized (9G, 400k files) Maildir, given the <code>Message-Id</code>.  In this case, only one file will possibly match; while <code>-m 1</code> limits to one result per file, no flag exists to abort after the first overall result.  Unfortunately, adding <code>| head -n1</code> does not help because no further output is seen from <code>rg</code> to send it the SIGPIPE to abort:</p>
<pre><code>mycon ~/Mail $ time rg -m 1 -l --hidden redacted-message-id
.Trash/cur/some-redacted-path

real	0m1.388s
user	0m3.662s
sys	0m6.730s
mycon ~/Mail $ time rg -m 1 -l --hidden redacted-message-id | head -n1
.Trash/cur/some-redacted-path

real	0m1.467s
user	0m3.556s
sys	0m6.871s
</code></pre>
<p>The 1.4s is after loading everything into caches; before doing so, searching took more than 3 minutes, despite the result being found in the first 0.13s:</p>
<pre><code>mycon ~/Mail $ time rg -m 1 -l --hidden redacted-message-id | ts -s %.s
0.126295 .Trash/cur/some-redacted-path

real	3m8.019s
user	0m4.593s
sys	0m9.705s
</code></pre>
<p><code>ack</code> uses the <code>-1</code> flag for this, which is useful, particularly in conjunction with <code>-l</code>.  This finds results an order of magnitude faster than empty-caches <code>rg</code> -- but an order of magnitude slower than an <code>rg</code> which could quick-abort:</p>
<pre><code>mycon ~/Mail $ time ack -1 -l redacted-message-id
.Trash/cur/some-redacted-path

real	0m3.872s
user	0m3.328s
sys	0m0.562s
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-08-14 10:33</div>
            <div class="timeline-body"><p>Folks have proposed this feature (or something like it) in the past, and I've historically been against it. In particular, the order in which files are searched is not only not specified, but it is technically non-deterministic. It is non-deterministic even when ripgrep is single threaded, although in practice, file systems generally return a consistent ordering across multiple calls. The only way to cause ripgrep's output to be deterministic is to use <code>--sort path</code>, but this disables parallelism and incurs the overhead of sorting directory entries as they are traversed.</p>
<p>Because of the non-determinism, the fundamental problem with &quot;only show me the top N results&quot; is that the top N results can <em>change</em> from run to run. It's quite misleading and can, I imagine, result in non-obvious bugs where folks might assume that the top N results don't change.</p>
<p>Now, your case is a little different since you know there is exactly one match. So the search can stop as soon as it's found and the output will always be the same from run to run. However, still, the fact that there is a noticeable performance improvement by limiting oneself to a single match is pretty much nothing but luck. ripgrep does not guarantee the order in which it searches files, so it could very well be that your match isn't found until ripgrep searches the very last file. You could make a compelling probabilistic argument here by saying that the odds of the last file (or even near the last file) being searched containing the match are fairly rare.</p>
<p>So basically, in summary, my reservations are the following:</p>
<ul>
<li>Adding a flag like this might give folks the false impression that the top N results are invariant given the same inputs, but they are not.</li>
<li>The performance improvements you desire are effectively down to chance, since it depends on <em>when</em> ripgrep searches the file.</li>
<li>I'm hesitant about allocating <code>-1</code> for this, since short flags are in short supply. Perhaps <code>--max-hits</code> would be more appropriate here.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2019-08-14 10:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alexmv">@alexmv</a> on 2019-08-14 17:25</div>
            <div class="timeline-body"><blockquote>
<p>Adding a flag like this might give folks the false impression that the top N results are invariant given the same inputs, but they are not.</p>
</blockquote>
<p>Yeah -- I added and then removed a comment to the effect of &quot;this result may, of course, be non-deterministic&quot; but I removed it because it seemed obvious, based on the fact that I'd observed that the result ordering was already non-deterministic.</p>
<p>Anyone who is <em>currently</em> post-processing the results should be aware that the ordering is not invariant; this is currently lightly documented under <code>--sort</code> but maybe bears a little more prominence.</p>
<p>Phrasing as &quot;stop after only only one result; this result may not be consistent unless used with <code>--sort</code>&quot; seems like it adequately documents this.</p>
<blockquote>
<p>The performance improvements you desire are effectively down to chance, since it depends on <em>when</em> ripgrep searches the file.</p>
</blockquote>
<p>Sure.  The expectation is, of course, 50% faster -- though in many cases might be better than that, if it's run multiple times and gets the advantage of finding a result while still looking in data loaded from disk caches.</p>
<blockquote>
<p>I'm hesitant about allocating <code>-1</code> for this, since short flags are in short supply. Perhaps <code>--max-hits</code> would be more appropriate here.</p>
</blockquote>
<p>I suggested <code>-1</code> because of the prior art, but I'm in no way wedded to it.  I guess I was assuming that &quot;exit after one result&quot; was slightly easier to imply the non-determinism on than the more general &quot;exit after /N/ results&quot; -- but the greater generality potentially outweighs the increased clarity, yes.</p>
<p><code>--max-hits</code> doesn't seem to contrast well with <code>--max-count</code>, in that it's not clear from their names which is per-file, and which is overall.  <code>--total-count</code> ?  <code>--i-accept-non-determinism-top-n</code> ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-08-14 17:41</div>
            <div class="timeline-body"><p>Yeah, point taken about the flag name. I did want to still try and keep it short though. <code>--total-count</code> is serviceable. Anything shorter?</p>
<p>I <em>think</em> you might have sold me on this. I'll keep noodling. I <em>think</em> this should be straight-forward to implement. Mostly plumbing. There might be some complexity in handling this correctly in the parallel searcher. I'd guess you'd want to <a href="https://github.com/BurntSushi/ripgrep/blob/ef0e7af56a9b1afce7be46db87b3ff3709187ee2/src/main.rs#L169">return <code>WalkState::Quit</code></a> here, but you have to be a little careful not to race with other threads.</p>
<p>Also, <code>--total-count</code> (or whatever we pick) also need to <em>imply</em> <code>--max-count</code> with the same value too.</p>
<p>And now I've realized a complication. If you request <code>--total-count 5</code>, and you search two files, one with <code>4</code> matches and another with <code>3</code> matches, then it's pretty tricky to print <em>just</em> <code>5</code> of those matches. We might need to settle for &quot;<code>--total-count</code> <em>approximately</em> limits the total number of matches to <code>N</code>.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alexmv">@alexmv</a> on 2019-08-14 17:51</div>
            <div class="timeline-body"><p>I can't come up with anything shorter off the top of my head, especially without renaming <code>--max-count</code>, which isn't possible.</p>
<p>Mmm.  Does the printer know how many records it has output, in the stats object?  Can the searcher return approximately the right number of results, and instead enforce a stricter limitation during output, which is probably not parallel?  I've only briefly kicked around in the code, so take with an appropriate grain of salt.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-08-14 19:39</div>
            <div class="timeline-body"><p>The printer will tell you the number of matches, yes. The problem is that the printer writes its output as-is and there's no easy way to cut that off after it has been written. You could re-configure the printer to only print <code>k</code> matches (where <code>k = N - already-printed</code>), but there's still a race.</p>
<p>The only thing that isn't parallel is dumping the output of the printer to <code>stdout</code>. By the time you get there, the output has already been prepared in an in-memory buffer.</p>
<p>(Getting this fully correct for single threaded search is possible though.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alexmv">@alexmv</a> on 2019-08-14 20:07</div>
            <div class="timeline-body"><p>Hm, got it.  Just saying &quot;<em>approximately</em> limits&quot; seems a little weasel-wordy -- and it seems worth calling out somehow that using <code>--sort file</code> will make the result both stable and correct, at the cost of parallelism.  Maybe something like:</p>
<blockquote>
<p><code>--total-count</code> attempts to limit the total number of results output; contrast to <code>--max-count</code>, which is a per-file limit.  This is best-effort; ripgrep may output more than the requested number of results if parallelism is used (the default; see <code>-j</code>).  Which results are output is also non-deterministic unless <code>--sort</code> is used (which also disables parallelism).</p>
</blockquote>
<p>Writing it out like that, it does seem like a bucket of caveats, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/genivia-inc">@genivia-inc</a> on 2020-01-20 20:19</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>I'm hesitant about allocating <code>-1</code> for this, since short flags are in short supply. Perhaps <code>--max-hits</code> would be more appropriate here.</p>
</blockquote>
<p>I suggested <code>-1</code> because of the prior art, but I'm in no way wedded to it. I guess I was assuming that &quot;exit after one result&quot; was slightly easier to imply the non-determinism on than the more general &quot;exit after /N/ results&quot; -- but the greater generality potentially outweighs the increased clarity, yes.</p>
</blockquote>
<p>My 2c from &quot;lessons learned&quot;: as you know there are two commonly-referenced &quot;standards&quot; with respect to command-line options:</p>
<ol>
<li><a href="https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html">POSIX</a> permits numeric (one digit) command-line options</li>
<li><a href="https://www.gnu.org/software/libc/manual/html_node/Getopt-Long-Options.html">GNU getopt</a> also considers numeric options as valid and other characters as a GNU extension, although legacy usage is restricted to letters only.</li>
</ol>
<p>On the other hand, consider this: concatenated options may cause ambiguity, as for example <code>-a1</code> could mean <code>-a</code> with the value 1 or the two options <code>-a -1</code> combined. Or worse, <code>-a10</code> which could be <code>-a</code> with the value 10 or the three options <code>-a -1 -0</code> combined. That's why numeric short options are uncommon and perhaps should be avoided in practice and were never used by legacy unix utilities.</p>
<blockquote>
<p><code>--max-hits</code> doesn't seem to contrast well with <code>--max-count</code>, in that it's not clear from their names which is per-file, and which is overall. <code>--total-count</code> ? <code>--i-accept-non-determinism-top-n</code> ?</p>
</blockquote>
<p>What about <code>--max-files=1</code> combined with <code>-m1</code> to produce only one hit for the first file found?</p>
<pre><code>-m NUM, --max-count=NUM
        Stop reading the input after NUM matches for each file processed.
--max-files=NUM
        If -R or -r is specified, restrict the number of files matched to
        NUM.  Specify -J1 to produce replicable results by ensuring that
        files are searched in the same order as specified.
</code></pre>
<p>This is <a href="https://github.com/Genivia/ugrep#max">documented and implemented in ugrep</a>. I think the caveat included in the description is a fair warning (<code>-J1</code> sequentializes the search), as it refers to &quot;the same order as specified&quot;, leaving it up to the order of the command line arguments and the order in which the OS lists directory contents.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hustcer">@hustcer</a> on 2023-08-12 12:33</div>
            <div class="timeline-body"><p>+1 for this feature</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/xaocon">@xaocon</a> on 2024-02-22 21:29</div>
            <div class="timeline-body"><p>Maybe the arg could be <code>--first</code> which wouldn't take an argument instead? It's less flexible but maybe gets the point across better?   It would be great to have some kind of option to short circuit the search when you need a single piece of info.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wshanks">@wshanks</a> on 2024-03-13 15:46</div>
            <div class="timeline-body"><p>Here is a slightly different use case from the original suggestion of knowing ahead of time that there is exactly one match: I would like to search a series of directories to classify them based on whether or not a certain pattern occurs within them. I don't need deep analysis of where and how that pattern is used (maybe there is a different tool I should be using). <code>--first</code> would be a good fit for the name for this use case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/giladbarnea">@giladbarnea</a> on 2024-10-18 18:15</div>
            <div class="timeline-body"><p>Would be great to have this feature</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/buergi">@buergi</a> on 2025-09-16 11:26</div>
            <div class="timeline-body"><p>Just missed this as well, especially to only output the first match.
Update: Ah sorry, this is targets a single result in multiple files. I was looking for first result in each file, which is exactly what <code>--max-count</code> does, as far as I understand it.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:59 UTC
    </footer>
</body>
</html>
