<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ripgrep doesn't stop when its pipe is closed - BurntSushi/ripgrep #200</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ripgrep doesn&#x27;t stop when its pipe is closed</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/200">#200</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2016-10-29 12:58
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>For example, the following two <code>rg</code> commands take the same amount of time, but the second one should be much shorter:</p>
<pre><code>[andrew@Cheetah subtitles] ls -lh OpenSubtitles2016.raw.en 
-rw-r--r-- 1 andrew users 9.3G Sep 10 11:51 OpenSubtitles2016.raw.en
[andrew@Cheetah subtitles] time rg &#x27;Sherlock Holmes&#x27; OpenSubtitles2016.raw.en | wc -l
5107

real    0m1.602s
user    0m1.250s
sys     0m0.350s
[andrew@Cheetah subtitles] time rg &#x27;Sherlock Holmes&#x27; OpenSubtitles2016.raw.en | head -n1
You read Sherlock Holmes to deduce that?

real    0m1.626s
user    0m1.247s
sys     0m0.377s
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-29 12:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-30 02:06</div>
            <div class="timeline-body"><p>This one isn&#x27;t going to be fun to fix. This is what I get for ignoring any errors that occur when printing to <code>stdout</code>. (And I really should know better, I handle this correctly in <code>xsv</code>.) The issue is that a write to <code>stdout</code> in this case will fail with a pipe error, at which point, we should stop searching and quit.</p>
<p>The primary difficulty at present is bubbling up an error from the printing code all the way through the search code. Both the search/print code assume no errors can happen. We could just thread an error through everything.</p>
<p>My question for this in terms of UX is: do we treat all IO errors equally when writing output? Should we do something different if we see a pipe error versus, say, a permission error? Maybe any type of error causes ripgrep to stop whatever it&#x27;s doing, but a pipe error indicates normal termination where as anything else results in a non-zero exit code and the error being printed to stderr.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2016-10-30 02:09</div>
            <div class="timeline-body"><p>I might elect to forgo fixing this until I factor the search code out into a separate crate. (Which will be a while. My guess is at least a month.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;libripgrep&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-10 02:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;libripgrep&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-10 02:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">libripgrep</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-01-11 03:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danr">@danr</a> on 2017-02-08 09:57</div>
            <div class="timeline-body"><p>I upgraded yesterday from rg 0.3.2-1 to 0.4 and now these commands are essentially useless:</p>
<pre><code>rg --files | head
rg --files | fzf</code></pre>
<p>This is too bad, since I use rg+fzf in my workflow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-02-18 21:37</div>
            <div class="timeline-body"><p>@danr There was no regression. This bug was in <code>0.3.2</code> as well.</p>
<p>&quot;useless&quot; sounds like a bit of an exaggeration.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danr">@danr</a> on 2017-02-27 09:37</div>
            <div class="timeline-body"><p>Sorry, I really did not mean to sound harsh. Thank you for your work on <code>ripgrep</code>!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kpp">@kpp</a> on 2017-03-31 19:45</div>
            <div class="timeline-body"><p>This is how grep acts:</p>
<pre><code>$ strace grep Holmes subtitles/OpenSubtitles2016.raw.en 2&gt;grep.log  | head -n 1

...
read(3, &quot;s\nWell, Watson, what about him?\n&quot;..., 32768) = 32768
write(1, &quot;Roy Holmes.\nThen Simon Harrison &quot;..., 4096) = 4096
read(3, &quot;me, because he married against h&quot;..., 32768) = 32768
...
read(3, &quot;uch.\nWell, you built a real nice&quot;..., 32768) = 32768
write(1, &quot; a swamp.\nMr. Holmes, do not rea&quot;..., 4096) = -1 EPIPE (Broken pipe)
--- SIGPIPE {si_signo=SIGPIPE, si_code=SI_USER, si_pid=11211, si_uid=1000} ---
+++ killed by SIGPIPE +++
</code></pre>
<p>This is how rg acts:</p>
<pre><code>$ strace rg Holmes subtitles/OpenSubtitles2016.raw.en 2&gt;rg.log  | head -n 1 

...
write(1, &quot;Roy Holmes.\n&quot;, 12)           = 12
write(1, &quot;Then Simon Harrison killing Barr&quot;..., 80) = -1 EPIPE (Broken pipe)
--- SIGPIPE {si_signo=SIGPIPE, si_code=SI_USER, si_pid=11310, si_uid=1000} ---
write(1, &quot;Then Simon Harrison killing Barr&quot;..., 80) = -1 EPIPE (Broken pipe)
--- SIGPIPE {si_signo=SIGPIPE, si_code=SI_USER, si_pid=11310, si_uid=1000} ---
write(1, &quot;Then Simon Harrison killing Barr&quot;..., 80) = -1 EPIPE (Broken pipe)
--- SIGPIPE {si_signo=SIGPIPE, si_code=SI_USER, si_pid=11310, si_uid=1000} ---
...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-31 19:47</div>
            <div class="timeline-body"><p>@kpp Right, this bug is understood, it&#x27;s just a pain to fix. Please do not fix it. I would like to fix it personally when I refactor this code into a separate crate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kpp">@kpp</a> on 2017-03-31 19:50</div>
            <div class="timeline-body"><p><code>grep</code> is faster than <code>rg</code>! This issue is the proof! All hail <code>grep</code>! <code>grep</code>, <code>grep</code>, <code>grep</code>!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/glandium">@glandium</a> on 2017-03-31 22:07</div>
            <div class="timeline-body"><p>Actually, what that strace says is that grep does an explicit &quot;panic&quot; of some sort (it raises SIGPIPE) when it gets a EPIPE error from write. It doesn&#x27;t bubble the error up or anything, which is what your proposed fix needs refactoring for.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-03-31 22:14</div>
            <div class="timeline-body"><p>@glandium Right. Rust&#x27;s standard library (IIRC) suppresses the <code>SIGPIPE</code> signal so that consumers need to explicitly handle it. The downside of that design is precisely that bugs like this occur, but the upside is that you get a bit more control. I was just being stupid when I wrote down the initial printer code. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2017-08-24 19:56</div>
            <div class="timeline-body"><p>Could we just <code>libc::signal(libc::SIGPIPE, libc::SIG_DFL)</code> somewhere early in <code>main()</code>, if we wanted an easy workaround for the short term? Not sure what the Windows equivalent is though. Maybe the more portable thing would be to <code>std::process::exit</code> on write errors? Gross in library code, but anyway just until the error plumbing is there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-08-27 19:01</div>
            <div class="timeline-body"><p>@oconnor663 Graciously submitted a PR implementing the <code>libc::signal</code> idea, which means this is fixed for now on Unix. I&#x27;m going to leave this open to track a proper fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/junegunn">@junegunn</a> on 2017-09-27 03:36</div>
            <div class="timeline-body"><p>@BurntSushi Hi, any plans for a patch release including the fix? Many users, myself included, would want to install ripgrep using Homebrew/Linuxbrew, and use it with a secondary filter like <a href="https://github.com/junegunn/fzf">fzf</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-09-27 10:27</div>
            <div class="timeline-body"><p>@junegunn Sure, I can do that. Hopefully soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/junegunn">@junegunn</a> on 2017-10-23 02:37</div>
            <div class="timeline-body"><p>Confirmed fixed in 0.7.1 on macOS. Thanks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpnova">@dpnova</a> on 2017-11-01 01:20</div>
            <div class="timeline-body"><p>@junegunn it&#x27;s still an issue for me on 0.7.1 on ubuntu - did you use a binary release?</p>
<p>Using this command:</p>
<pre><code>export FZF_DEFAULT_COMMAND=&#x27;rg --files --hidden --follow --glob &quot;!.git/*&quot; --glob &quot;!target/*&quot;&#x27;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-01 01:27</div>
            <div class="timeline-body"><p>@dpnova Could you please provide a reproducible example on a corpus that is public without using fzf? I&#x27;ve tested this myself on Linux and it works fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpnova">@dpnova</a> on 2017-11-01 02:04</div>
            <div class="timeline-body"><p>Just confirming... to repro I should be able to run</p>
<p><code>rg --files --hidden --follow --glob &quot;&quot; --glob &#x27;!target/*&#x27;</code> in the same folder I&#x27;m starting vim (with the fzf.vim plugin)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpnova">@dpnova</a> on 2017-11-01 10:06</div>
            <div class="timeline-body"><p>FWIW I can&#x27;t repro without fzf. My test case is simply running the command. I&#x27;m sure I&#x27;m missing something though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pbogut">@pbogut</a> on 2017-11-01 10:17</div>
            <div class="timeline-body"><p>Do you have any big file in your repo? I had this problem when there was like 2GB sql file in my folder. Once I&#x27;ve added this file to <code>.gitignore</code> it started to work without an issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-01 11:06</div>
            <div class="timeline-body"><p>@pbogut The <code>rg</code> command in question is using <code>--files</code>, which means it isn&#x27;t searching files.</p>
<p>@dpnova I don&#x27;t see how that is a complete test case. Could you <strong>please</strong> provide more details? This bug doesn&#x27;t impact the correctness of ripgrep (so whether you&#x27;re able to &quot;run&quot; an <code>rg</code> command or not is not relevant). Rather, you need to check whether <code>rg ... | head -n1</code> is noticeably faster than simply <code>rg ...</code>. For this to make any sense at all, the <code>rg ...</code> command needs to run over a directory tree that is somewhat larger, otherwise you&#x27;re unlikely to see a difference anyway.</p>
<p>For example, if I run <code>rg --files | wc -l</code> in a checkout of the Chromium repository (<code>git://github.com/nwjs/chromium.src</code>), then it takes <code>0.320</code> seconds to complete. But if I run <code>rg --files | head -n1 | wc -l</code> in the same repository, then it takes <code>0.023</code> seconds to complete. Before this fix landed, the latter command would always take the same amount of time as the former command because ripgrep wouldn&#x27;t quit when its output pipe closed.</p>
<p>People, please, I&#x27;m begging you. Don&#x27;t simply stop at &quot;it doesn&#x27;t work.&quot; <em>Describe</em> what you observe in as much detail as possible so that other people can diagnose your problem. Please, understand that not everyone uses FZF, so saying, &quot;here&#x27;s this FZF config and it doesn&#x27;t work&quot; will not get us anywhere.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpnova">@dpnova</a> on 2017-11-01 21:39</div>
            <div class="timeline-body"><p>Sorry I wasn&#x27;t clear enough that I was asking for help to repro, I didnt get a response, so I tried <em>something</em>. Now I have a concrete case, thanks.</p>
<p>I&#x27;m currently waiting for the chromium repo to clone (yay Australian broadband).</p>
<p>In my own repo where I&#x27;m seeing the issue in fzf.vim the two cases look like this:</p>
<pre><code>( rg --files; )  0.01s user 0.01s system 129% cpu 0.017 total
( rg --files | head -n1; )  0.01s user 0.01s system 119% cpu 0.015 total

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpnova">@dpnova</a> on 2017-11-01 21:49</div>
            <div class="timeline-body"><p>This is running it in my home directory (fairly new formatted machine).</p>
<pre><code>( rg --files; )  0.10s user 0.16s system 116% cpu 0.222 total
( rg --files | head -n1; )  0.00s user 0.00s system 116% cpu 0.008 total
</code></pre>
<p>To me this says this specific github issue isn&#x27;t the case I&#x27;m talking about, despite the fzf github referencing this one. I&#x27;ll take my discussion back over there. Sorry for any confusion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-02 11:54</div>
            <div class="timeline-body"><p>@dpnova I agree with your conclusion. :-) Thanks for sticking it out and confirming that this particular bug isn&#x27;t it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ghost">@ghost</a> on 2017-12-04 07:46</div>
            <div class="timeline-body"><p>@BurntSushi : Can you have a look at this issue that use rg with fzf?. I can&#x27;t find a way to reproduce it without fzf.
<a href="https://github.com/junegunn/fzf.vim/issues/539">junegunn/fzf.vim#539</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/junegunn">@junegunn</a> on 2017-12-04 08:32</div>
            <div class="timeline-body"><p>@tuyenpm9 If you read the thread, you can see that this issue is not related to your problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ghost">@ghost</a> on 2017-12-04 08:38</div>
            <div class="timeline-body"><p>Yes, sorry about that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-08-20 11:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bpstahlman">@bpstahlman</a> on 2020-04-21 00:01</div>
            <div class="timeline-body"><p>Although the fix definitely seems to have helped, ripgrep can still take a <em>long</em> time to notice SIGPIPE. I haven&#x27;t looked at the source, but the behavior I&#x27;m seeing leads me to suspect that ripgrep doesn&#x27;t notice the pipe has closed until the next time it attempts to write to it. This is problematic in a long-running search that has entered a phase in which matches are found infrequently (or not at all). I first noticed the problem with an <code>rg | fzf</code> pipeline on a large directory tree, but I can reproduce it with a simple shell script that just forwards its stdin to stdout after setting up a signal trap that allows me to tell it when to close the pipe. If I instruct the script to close when ripgrep is finding lots of matches, ripgrep terminates almost immediately, but if I wait until ripgrep is no longer finding matches (but hasn&#x27;t yet finished the search), the pipeline continues to run (presumably until ripgrep finds another match or the search is complete). Obviously, the time during which the pipeline is effectively hung is highly dependent on the search parameters and the size of the directory tree being searched. Given that some very common use cases for ripgrep involve pipelines (e.g., <code>vim $(rg --files-with-matches foo | fzf)</code>), this seems like a significant issue. Does the Rust framework make it inordinately difficult to handle SIGPIPE asynchronously?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-04-21 00:49</div>
            <div class="timeline-body"><p>@bpstahlman It would help if you could provide a more concrete reproduction that I can try. With that said, the behavior you&#x27;re describing makes sense and it&#x27;s what I would expect to happen.</p>
<blockquote>
<p>but the behavior I&#x27;m seeing leads me to suspect that ripgrep doesn&#x27;t notice the pipe has closed until the next time it attempts to write to it</p>
</blockquote>
<p>That is correct and expected. That&#x27;s when a pipe error occurs: https://github.com/BurntSushi/ripgrep/blob/73103df6d982da1a0dc775e9b7a03f5bb8cfd7fb/crates/core/main.rs#L95-L98</p>
<blockquote>
<p>this seems like a significant issue</p>
</blockquote>
<p>AFAIK, you are the first one to report this as a significant problem.</p>
<blockquote>
<p>Does the Rust framework make it inordinately difficult to handle SIGPIPE asynchronously?</p>
</blockquote>
<p>ripgrep does not use any Rust &quot;framework.&quot;</p>
<p>For more context, Rust by default ignores SIGPIPE: <a href="https://github.com/rust-lang/rust/issues/62569">rust-lang/rust#62569</a> (I make an appearance in that thread asking for something to be done, but there hasn&#x27;t been any movement on that issue AFAIK.)</p>
<p>This means that pipe errors are only detected once an actual write occurs. At that point, the pipe error is reported &quot;in band&quot; instead of as a signal.</p>
<p>It is <a href="https://github.com/BurntSushi/ripgrep/pull/586/files">trivial to stop ignoring SIGPIPE</a>. This would make ripgrep behave like a &quot;normal&quot; C UNIX application. SIGPIPE gets sent to the process, and since there is no signal handler for it, the process (by default) will terminate immediately. This likely achieves the behavior you want.</p>
<p>ripgrep currently does not do that because it&#x27;s not portable. I&#x27;m not a Windows expert, but AFAIK, there is no SIGPIPE on Windows. So ripgrep <em>has</em> to deal with in-band pipe errors correctly anyway for compatibility with Windows. Dealing with these types of errors has been subtle and difficult to get right. For that reason, I don&#x27;t really want to support <em>both</em> in-band (synchronous) and out-of-band (asynchronous) ways of terminating on pipe errors. Because now I won&#x27;t be dog-fooding the handling of in-band pipe errors on Unix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bpstahlman">@bpstahlman</a> on 2020-04-21 15:29</div>
            <div class="timeline-body"><p>I understand your reasoning and appreciate the detailed explanation. I suspect the reason for the lack of complaints regarding the status quo is that for small to medium-sized projects with suitable .gitignore files, the ripgrep search will often complete before the fzf user has finished making his file selection. And if fzf occasionally appears to hang after Enter is pressed, a user is unlikely to bother reporting unless it happens often or the delays are exceptionally long. I don&#x27;t recall noticing the issue until I started using ripgrep on my home directory (which is fairly large and doesn&#x27;t have a .gitignore).</p>
<p>As for the desire to avoid maintaining both in and out-of-band SIGPIPE handling logic... I wouldn&#x27;t think it would be necessary to remove the &quot;in-band&quot; logic to add Linux-only &quot;out-of-band&quot; SIGPIPE handling. The &quot;in-band&quot; logic needed for Windows could still be tested in a Linux build compiled without the &quot;out-of-band&quot; logic, while the &quot;out-of-band&quot; logic would simply be compiled out of the Windows build. E.g.,</p>
<ul>
<li><strong>Windows Release:</strong> in-band only</li>
<li><strong>Linux Release:</strong> out-of-band / in-band (optional)</li>
<li><strong>Linux for Windows Test:</strong> in-band only</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-04-21 15:53</div>
            <div class="timeline-body"><blockquote>
<p>I wouldn&#x27;t think it would be necessary to remove the &quot;in-band&quot; logic</p>
</blockquote>
<p>It isn&#x27;t. The fact is that now two error paths need to be tested. That was my point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bpstahlman">@bpstahlman</a> on 2020-04-25 16:32</div>
            <div class="timeline-body"><p>@BurntSushi @junegunn</p>
<blockquote>
<p>This means that pipe errors are only detected once an actual write occurs. At that point, the pipe error is reported &quot;in band&quot; instead of as a signal.</p>
</blockquote>
<blockquote>
<p>It is trivial to stop ignoring SIGPIPE. This would make ripgrep behave like a &quot;normal&quot; C UNIX application. SIGPIPE gets sent to the process, and since there is no signal handler for it, the process (by default) will terminate immediately. This likely achieves the behavior you want.</p>
</blockquote>
<p>Having looked into this a bit more, I&#x27;m not convinced that a change to SIGPIPE handling would have any impact on the behavior I&#x27;m seeing. IIUC, SIGPIPE isn&#x27;t even generated until the writer process attempts to write to the closed pipe, which is too late. And I&#x27;m not even sure there&#x27;s a way for a writer process to check for a closed pipe without attempting to write. I&#x27;ve tried using select(), fstat(), write() of 0 bytes, etc., and the only thing that gave any indication that stdout had closed was an attempt to write actual data to it. I would have expected there would be some way - even if it involved a relatively costly system call - for a writer process to check the status of a pipe without writing unwanted data if it happens to be open.</p>
<p>I&#x27;m not sure exactly how the fzf Vim plugin creates the <code>rg|fzf</code> pipeline, but I doubt it&#x27;s possible for the plugin to force early termination, since it would have know way of knowing when the user&#x27;s selection has been made. The fzf executable knows when the selection has been made, but may not have a clean way to kill the process at the write end of its pipeline. Ah well, perhaps the solution is to ensure that everything I want to search with <code>rg|fzf</code> has a good .ignore file...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Quaddroo">@Quaddroo</a> on 2023-11-23 06:29</div>
            <div class="timeline-body"><p>I believe some people that find this issue (in relation to rg | fzf) will find their woes relieved by this issue:
<a href="https://github.com/junegunn/fzf/issues/2288">junegunn/fzf#2288</a>
check the &quot;process substitution&quot; answer. Fixed what I wanted.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:02 UTC
    </footer>
</body>
</html>
