<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IO speed vs grep or ag - BurntSushi/ripgrep #696</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>IO speed vs grep or ag</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/696">#696</a>
        opened by <a href="https://github.com/alok">@alok</a>
        on 2017-11-29 08:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/alok">@alok</a></div>
            <div class="timeline-body"><p>I was reading this</p>
<p>https://github.com/junegunn/fzf.vim/issues/488#issuecomment-347714322</p>
<p>And the last few comments about how ag apparently can output IO 5 times faster than ripgrep stood out. Is that true? If so, are there any plans to speed it up, or is the case described in the issue outside of what you consider normal usage?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-29 10:25</div>
            <div class="timeline-body"><p>Please provide a test case independent of fzf.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-29 14:14</div>
            <div class="timeline-body"><p>My suspicion is that something else funky is going on here, and that &quot;ripgrep has slow output&quot; is probably neither true nor the cause.</p>
<p>On a simple search in a checkout of the Linux kernel, for example, it&#x27;s not even close:</p>
<pre><code>$ time rg . | wc -l
19100836

real    0m0.779s
user    0m7.396s
sys     0m1.002s
$ time ag . | wc -l
22093481

real    0m35.207s
user    0m35.783s
sys     0m3.725s
</code></pre>
<p>Note that a <a href="http://blog.burntsushi.net/ripgrep/#everything">similar case</a> made an appearance in my benchmarks:</p>
<pre><code>$ time rg &#x27;.*&#x27; | wc -l
22094380

real    0m1.080s
user    0m11.359s
sys     0m1.100s
$ time ag &#x27;.*&#x27; | wc -l
55940

real    0m2.857s
user    0m6.704s
sys     0m1.914s
</code></pre>
<p>In this case, <code>ag</code> doesn&#x27;t even print every result (probably a bug) and it&#x27;s still slower than ripgrep.</p>
<p>Note that the output of running <code>rg .</code> in the Linux root is about 1.3GB.</p>
<p>I&#x27;ve also tried comparing the timings when using the <code>--files</code> flag, and ripgrep is always as fast or faster than ag.</p>
<p>Bottom line: we need more data.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-29 14:24</div>
            <div class="timeline-body"><p>Colors don&#x27;t appear to be the issue either:</p>
<pre><code>$ time ag --color void &gt; /tmp/results.ag

real    0m4.030s
user    0m5.284s
sys     0m1.966s
$ time rg --color=always void &gt; /tmp/results.rg

real    0m0.154s
user    0m0.853s
sys     0m0.618s
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-29 14:25</div>
            <div class="timeline-body"><p>If anything, what I&#x27;m discovering here is that ag&#x27;s output is the one that is incredibly slow. If you run <code>ag</code> on a query with a lot of matches (e.g., <code>ag a</code>), then it runs obscenely slowly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2017-11-29 17:01</div>
            <div class="timeline-body"><p>I will look into this, thanks. I agree that these are curious results!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-11-29 17:09</div>
            <div class="timeline-body"><p>To confirm that <code>ag</code>&#x27;s printing is the slow part (not its searching), compare the timing of <code>ag -c . | wc -l</code> and <code>ag . | wc -l</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2017-12-02 21:00</div>
            <div class="timeline-body"><p>I confirmed that rg is blazing fast when used for feeding FZF in vim, except when color=always. which sort of sucks because the way FZF works in vim does show colors, which is visually helpful.</p>
<p>I&#x27;m actually unsure of the actual code involved here. FZF is a terminal application and it may be the case that running it in vim brings an entire terminal emulator/PTY layer within Vim into the mix.</p>
<p>It is no longer clear at all that the issue is on ripgrep&#x27;s side. Looking at fzf.vim code, there appears to be a rather lot of stuff &quot;geared toward&quot; ag, not sure if it is responsible for the difference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-12-02 21:53</div>
            <div class="timeline-body"><p>@unphased Yeah basically in order for this to be a problem with ripgrep, I need to see a case that I can reproduce without fzf. I did test ripgrep and ag with colors (see above), but it didn&#x27;t make any appreciable difference. Thanks for investigating! Please do let me know if you come up with anything!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2017-12-02 22:10</div>
            <div class="timeline-body"><p>yeah I tried fzf a while ago but it tries to do things that are too smart (messing with tmux windows) when run directly from the shell.</p>
<p>Lately I have found it tremendously powerful as a replacement for ctrlP in vim, and plus when you invoke it on a fresh system it very helpfully downloads the executable for you. So, I use fzf exclusively in vim now... I will revisit this another day when I really want colors inside fzf, but for the time being <em>nothing</em> beats non-colored rg&#x27;s speed for feeding fzf</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-31 02:26</div>
            <div class="timeline-body"><p>It is possible that #764 is the culprit here, although I am still perplexed at why I can&#x27;t reproduce this in a terminal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-01-31 02:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wsdjeg">@wsdjeg</a> on 2018-02-09 03:35</div>
            <div class="timeline-body"><p>I will create an example base on Vim&#x27;s async API to confirm this issue.</p>
<p>when run rg or grep command, if I want only the first stdout data. grep is much faster than ag/rg etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-09 05:48</div>
            <div class="timeline-body"><p>well, it looks like whatever dependency ripgrep uses causes the colors to be assembled in an almost worst case method where multiple color codes are emitted for every single character. It&#x27;s a bit like immediate mode OpenGL geometry, it&#x27;s just absurd overhead, despite technically producing correct results. It totally makes sense to me that we see this effect if the terminals you test on are significantly more efficient at handling the color state changes than vim&#x27;s builtin terminal emulator is.</p>
<p>Two problems afoot: 1) make ripgrep stop producing laughably inefficient ANSI color codes 2) make vim&#x27;s terminal emulation less inefficient</p>
<p>both would be good to have, but either one should go a long way toward improving the perf.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-09 11:55</div>
            <div class="timeline-body"><blockquote>
<p>well, it looks like whatever dependency ripgrep uses causes the colors to be assembled in an almost worst case method where multiple color codes are emitted for every single character</p>
</blockquote>
<p>@unphased This characterization is imprecise. ripgrep emits distinct color codes <em>for every match</em>. If every match is a single character, and every single character is a match (e.g., <code>rg .</code>), then it degrades to the very bad case of emitting color codes for every character printed to the terminal. The optimization that ripgrep lacks is that it doesn&#x27;t detect <em>adjacent matches</em> and merge the color codes.</p>
<p>Knowing this, can anyone reliably reproduce the issue without fzf? Failing that, could someone say something about what ripgrep commands <code>fzf</code> is running?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-09 17:15</div>
            <div class="timeline-body"><p>It seems that searching for <code>.</code> is a bad way to use the tool in this situation. I use <code>-v &#x27;^$&#x27;</code>. Don&#x27;t know if that also causes insane ANSI color spew also. I can confirm though that the performance indicates that it does still end up a huge amount slower than not using colors. I&#x27;ll try to test this and see what the output looks like.</p>
<p>Yes I can accept the argument that ripgrep shouldnt be expected to &quot;resolve&quot; unnecessary color state changes in its output. that would probably be being <em>too</em> smart about things.</p>
<pre><code>command! -bang FLines call fzf#vim#grep(
     \ &quot;rg --color=never --line-number --no-heading --ignore-case --hidden --ignore-file &quot;.glob(&quot;~/.vim/rg.gitignore&quot;).&quot; -v &#x27;^$&#x27;&quot;,
     \ 1,
     \ {&#x27;options&#x27;: &#x27;--reverse --prompt &quot;FLines&gt; &quot;&#x27;})
</code></pre>
<p>^ from my vimrc</p>
<p>when the <code>--color=never</code> is taken out, the performance drops a lot, but only when seen in fzf in vim (I haven&#x27;t tested fzf not in vim). I&#x27;ll test it outside of fzf and see what is going on with the color codes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-09 17:59</div>
            <div class="timeline-body"><p>@unphased <code>-v &#x27;^$&#x27;</code> avoids the color spew problem. In fact, any usage of <code>-v</code> would since there is no match for ripgrep to highlight.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-09 18:35</div>
            <div class="timeline-body"><p>It still ends up being unexplainably slow compared to configured for no colors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-09 18:56</div>
            <div class="timeline-body"><p>Hmmm that suggests #764 may not be the culprit. :-/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-10 08:29</div>
            <div class="timeline-body"><p>Upon testing in Linux, i do not see much of a slowdown at all comparing color to non colored here. But on my 2017 MacBook Pro there is a ~5 or so factor speed difference. Which now I think i would prefer to get the color and live with it being slower. It indexes 4 million lines (my home directory) within a tolerable amount of time. I don&#x27;t even understand how that is possible, it&#x27;s like probably on the order of close to a gigabyte of data getting crunched.</p>
<p>Looking at htop, when this runs, with <code>color=always</code>, fzf is at 130% cpu, and rg is at about 25-40% cpu. When <code>color=never</code>, fzf is 138% cpu and rg is 130% cpu. This makes me blame fzf instead of vim.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-12 18:06</div>
            <div class="timeline-body"><p>OK more information. in a linux vm in a macbook (a 2015 model this time) the speed difference is also very present.</p>
<p>I did some more tests...</p>
<pre><code>~/util ❯❯❯ time rg --color=always --no-heading --hidden -v &#x27;^$&#x27; &gt; rg_test_color                                                                                           master ◼
rg --color=always --no-heading --hidden -v &#x27;^$&#x27; &gt; rg_test_color  0.35s user 0.17s system 198% cpu 0.267 total
~/util ❯❯❯ rm rg_test_color
remove rg_test_color? y
~/util ❯❯❯ time rg --color=never --no-heading --hidden -v &#x27;^$&#x27; &gt; rg_test
rg --color=never --no-heading --hidden -v &#x27;^$&#x27; &gt; rg_test  0.25s user 0.17s system 182% cpu 0.230 total
</code></pre>
<p>as we expect it seems rg is only marginally slower at producing the output.</p>
<p>when i then take these saved outputs to feed to fzf like this:</p>
<p><code>cat rg_test_color | .vim/plugged/fzf/bin/fzf --ansi</code></p>
<p>the additional slowdown is not very noticeable, certainly not ~5x slower.</p>
<p>I&#x27;m going to look in the vim fzf plugin for its invocation, since it doesnt seem to be that slow using just <code>--ansi</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-12 18:40</div>
            <div class="timeline-body"><p>Well i&#x27;ve reproduced the same commands being sent into fzf that vim does..</p>
<pre><code>rg --color=always --no-heading --hidden -v &#x27;^$&#x27; | ../.vim/plugged/fzf/bin/fzf &#x27;--ansi&#x27; &#x27;--prompt&#x27; &#x27;Rg&gt; &#x27; &#x27;--multi&#x27; &#x27;--bind&#x27; &#x27;alt-a:select-all,alt-d:deselect-all&#x27; &#x27;--color&#x27; &#x27;hl:68,hl+:110&#x27; --reverse --prompt &quot;FLines&gt; &quot; --expect=ctrl-v,ctrl-s,ctrl-t --height=29
</code></pre>
<p>when i take the ansi flag out (and feed it ansi colored rg output) it is just as fast as when non colored output is fed in (with or without the ansi flag). That indicates to me that the ansi color parsing itself is the bottleneck.</p>
<p>again this is more or less what we could have guessed but now i am more confident about it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-02-12 21:42</div>
            <div class="timeline-body"><p>@unphased Excellent investigation! Does this explain why rg is slow but ag is fast when using fzf?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-12 23:00</div>
            <div class="timeline-body"><p>That is the one thing this doesn’t explain yet and I have to assemble some output that is comparable with which to do that!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-12 23:30</div>
            <div class="timeline-body"><p>OK heres another more methodical set of data, now, i dont have a way to time how long fzf takes to index the input, but i can eyeball it. working with around 50MB of input (the colors dont bloat the size of input much...</p>
<pre><code>-rw-r--r--     1 slu   staff  46974160 Feb 12 12:51 rg_test
-rw-r--r--     1 slu   staff  49710421 Feb 12 12:56 rg_test_color
</code></pre>
<p>comparing these 4</p>
<pre><code>rg --color=never --no-heading --hidden -v &#x27;^$&#x27; | ../.vim/plugged/fzf/bin/fzf &#x27;--ansi&#x27; &#x27;--prompt&#x27; &#x27;Rg&gt; &#x27; &#x27;--multi&#x27; &#x27;--bind&#x27; &#x27;alt-a:select-all,alt-d:deselect-all&#x27; &#x27;--color&#x27; &#x27;hl:68,hl+:110&#x27; --reverse --prompt &quot;FLines&gt; &quot; --expect=ctrl-v,ctrl-s,ctrl-t --height=29
rg --color=always --no-heading --hidden -v &#x27;^$&#x27; | ../.vim/plugged/fzf/bin/fzf &#x27;--ansi&#x27; &#x27;--prompt&#x27; &#x27;Rg&gt; &#x27; &#x27;--multi&#x27; &#x27;--bind&#x27; &#x27;alt-a:select-all,alt-d:deselect-all&#x27; &#x27;--color&#x27; &#x27;hl:68,hl+:110&#x27; --reverse --prompt &quot;FLines&gt; &quot; --expect=ctrl-v,ctrl-s,ctrl-t --height=29
cat ../rg_test | ../.vim/plugged/fzf/bin/fzf &#x27;--ansi&#x27; &#x27;--prompt&#x27; &#x27;Rg&gt; &#x27; &#x27;--multi&#x27; &#x27;--bind&#x27; &#x27;alt-a:select-all,alt-d:deselect-all&#x27; &#x27;--color&#x27; &#x27;hl:68,hl+:110&#x27; --reverse --prompt &quot;FLines&gt; &quot; --expect=ctrl-v,ctrl-s,ctrl-t --height=29
cat ../rg_test_color | ../.vim/plugged/fzf/bin/fzf &#x27;--ansi&#x27; &#x27;--prompt&#x27; &#x27;Rg&gt; &#x27; &#x27;--multi&#x27; &#x27;--bind&#x27; &#x27;alt-a:select-all,alt-d:deselect-all&#x27; &#x27;--color&#x27; &#x27;hl:68,hl+:110&#x27; --reverse --prompt &quot;FLines&gt; &quot; --expect=ctrl-v,ctrl-s,ctrl-t --height=29
</code></pre>
<p>Which are respectively: 1. rg producing no colors piped to fzf 2. rg producing colors piped to fzf 3. (1) but cached to disk 4. (2) but cached to disk</p>
<p>The timing looks like:</p>
<ol>
<li>0.9 sec</li>
<li>1.5 sec</li>
<li>0.8 sec</li>
<li>1.5 sec</li>
</ol>
<p>From doing the same thing inside my ubuntu 14.04 vm on same machine:</p>
<ol>
<li>1.2 sec</li>
<li>2.0 sec</li>
<li>1.2 sec</li>
<li>2.0 sec</li>
</ol>
<p>Grain of salt with these times, probably not accurate to more than ~0.25 sec, i did not use a stopwatch.</p>
<p>Now I don&#x27;t know how my factor of 5 changed to a factor of barely 2. There does seem to be a &#x27;caching&#x27; aspect to this. running it a second and subsequent times, fzf indexes a good bit faster.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-02-12 23:45</div>
            <div class="timeline-body"><p>I did the same procedure with <code>ag</code> and it takes a good 2 seconds just to run itself, and its color output does produce more colors (the entire match is highlighted) and this does lead to (as expected) about as much extra time for fzf to handle it. Heres what <code>ag --color</code> looks like in comparison to <code>rg --color=always</code>:</p>
<p><img src="https://user-images.githubusercontent.com/1542910/36126044-bb866e5e-1024-11e8-8b82-0a84c99a1308.png" alt="image"></p>
<p>I tested it through fzf inside vim and it is exactly as fast as running fzf independently of vim.</p>
<p>At this point it doesn&#x27;t seem like there are any &quot;issues&quot; to speak of that are left... not using colors is going to make for a snappier result, but it won&#x27;t be as pleasant to look at and sift through. Them&#x27;s the breaks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 16:41</div>
            <div class="timeline-body"><p>Since this issue hasn&#x27;t seen any activity for a while and @unphased&#x27;s fastidious investigation didn&#x27;t turn up anything obvious, I&#x27;m going to close this in the absence of additional data. I think #764 is still an issue though that I&#x27;d like to fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/unphased">@unphased</a> on 2018-07-22 17:19</div>
            <div class="timeline-body"><p>fwiw, I have been using <code>rg --color=always</code>, using it a lot (started a new job recently, new codebase) and although it might take 5 seconds for fzf in vim to fully index the 2 million lines... It&#x27;s fine! Works great! I&#x27;d be happy to take a stopwatch to it and run some more trials inside vs outside vim and so on, and with other codebases. It still amazes me that fzf can take that much input in stride.  But I won&#x27;t really have much occasion to care about this performance without a 10x larger codebase to scan.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-07-22 17:23</div>
            <div class="timeline-body"><p>@unphased I&#x27;ve never used fzf before, so it&#x27;s hard for me to know whether that&#x27;s too slow or not. I guess it kind of depends on how other similar tools perform. e.g., Maybe compare <code>grep -r</code> with <code>rg -j1</code> or something.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gee19">@Gee19</a> on 2019-08-16 09:17</div>
            <div class="timeline-body"><p>I still run into this issue, let me know if/how I can help debug any further.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2019-08-16 11:43</div>
            <div class="timeline-body"><p>@Gee19 With #764 fixed, I don&#x27;t think there are any other obvious problems for this.</p>
<p>Could you please write a detailed report of what exactly is happening, preferably in enough detail such that others can reproduce it? Ideally, all inputs and corpora are open so that others can try the exact same procedure.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:05 UTC
    </footer>
</body>
</html>
