<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>bug/ignore: potential memory leak - BurntSushi/ripgrep #2493</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>bug/ignore: potential memory leak</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/2493">#2493</a>
        opened by <a href="https://github.com/Chaostheorie">@Chaostheorie</a>
        on 2023-04-17 20:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Chaostheorie">@Chaostheorie</a></div>
            <div class="timeline-body">What version of ignore are you using?
<ul>
<li><code>0.4.20</code> and directly <code>master</code> with stable rust (<code>1.68.2</code>)</li>
<li>System/ Platform: Linux 6.2.10 NixOS SMP PREEMPT_DYNAMIC x86_64 GNU/Linux</li>
</ul>
Describe your bug.
<p><code>ignore::walk::Walk</code> appears to be leaking memory during <code>walk</code> by valgrinds analysis. I haven&#x27;t been able to identify specifically where or if it&#x27;s an invalid detection. It might also be related to the <code>walkdir</code> crate.</p>
What are the steps to reproduce the behavior?
<p>Use the <a href="https://github.com/BurntSushi/ripgrep/blob/041544853c86dde91c49983e5ddd0aa799bd2831/crates/ignore/examples/walk.rs">example</a> code in any directory. Tested so far with both v0.4.20 and using the crate from <code>master</code>, see <a href="https://gitlab.cobalt.rocks/cobalt/walk-test">the full test</a> and inspect the execution with <code>valgrind</code>.</p>
<ul>
<li>Example with <code>0.4.20</code>: <a href="https://gitlab.cobalt.rocks/cobalt/walk-test/-/jobs/5291">CI run</a> / <a href="https://gitlab.cobalt.rocks/cobalt/walk-test">repo</a></li>
<li>Example with master@0415448: <a href="https://gitlab.cobalt.rocks/cobalt/walk-test/-/jobs/5290">CI run</a> / <a href="https://gitlab.cobalt.rocks/cobalt/walk-test/-/tree/ignore-git?ref_type=heads">repo</a></li>
</ul>
<p>Excerpt of relevant part of valgrind output:</p>
<pre><code>...
==1277== 9,242 (80 direct, 9,162 indirect) bytes in 1 blocks are definitely lost in loss record 29 of 29
==1277==    at 0x483877F: malloc (vg_replace_malloc.c:307)
==1277==    by 0x150F9E: ignore::dir::IgnoreBuilder::build (in /builds/cobalt/walk-test/target/release/walk-test)
==1277==    by 0x152A36: ignore::walk::WalkBuilder::build (in /builds/cobalt/walk-test/target/release/walk-test)
==1277==    by 0x142FA4: ignore::walk::Walk::new (in /builds/cobalt/walk-test/target/release/walk-test)
==1277==    by 0x147D8C: walk_test::main (in /builds/cobalt/walk-test/target/release/walk-test)
==1277==    by 0x143082: std::sys_common::backtrace::__rust_begin_short_backtrace (in /builds/cobalt/walk-test/target/release/walk-test)
==1277==    by 0x143378: _ZN3std2rt10lang_start28_$u7b$$u7b$closure$u7d$$u7d$17h3ded7372003c0822E.llvm.4739356907723970547 (in /builds/cobalt/walk-test/target/release/walk-test)
==1277==    by 0x20DECB: call_once&lt;(), (dyn core::ops::function::Fn&lt;(), Output=i32&gt; + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe)&gt; (function.rs:287)
==1277==    by 0x20DECB: do_call&lt;&amp;(dyn core::ops::function::Fn&lt;(), Output=i32&gt; + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe), i32&gt; (panicking.rs:483)
==1277==    by 0x20DECB: try&lt;i32, &amp;(dyn core::ops::function::Fn&lt;(), Output=i32&gt; + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe)&gt; (panicking.rs:447)
==1277==    by 0x20DECB: catch_unwind&lt;&amp;(dyn core::ops::function::Fn&lt;(), Output=i32&gt; + core::marker::Sync + core::panic::unwind_safe::RefUnwindSafe), i32&gt; (panic.rs:140)
==1277==    by 0x20DECB: {closure#2} (rt.rs:148)
==1277==    by 0x20DECB: do_call&lt;std::rt::lang_start_internal::{closure_env#2}, isize&gt; (panicking.rs:483)
==1277==    by 0x20DECB: try&lt;isize, std::rt::lang_start_internal::{closure_env#2}&gt; (panicking.rs:447)
==1277==    by 0x20DECB: catch_unwind&lt;std::rt::lang_start_internal::{closure_env#2}, isize&gt; (panic.rs:140)
==1277==    by 0x20DECB: std::rt::lang_start_internal (rt.rs:148)
==1277==    by 0x148E24: main (in /builds/cobalt/walk-test/target/release/walk-test)
==1277== 
==1277== LEAK SUMMARY:
==1277==    definitely lost: 80 bytes in 1 blocks
==1277==    indirectly lost: 9,162 bytes in 57 blocks
==1277==      possibly lost: 0 bytes in 0 blocks
==1277==    still reachable: 32 bytes in 1 blocks
==1277==         suppressed: 0 bytes in 0 blocks
==1277== Reachable blocks (those to which a pointer was found) are not shown.
==1277== To see them, rerun with: --leak-check=full --show-leak-kinds=all
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Chaostheorie">@Chaostheorie</a> on 2023-04-17 20:56</div>
            <div class="timeline-body"><p>Note: ripgrep doesn&#x27;t appear to have any leakage issues on the same machine in the same testing environment. If this is just a problem with my usage of <code>ignore</code> any help would be welcome.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-04-17 21:12</div>
            <div class="timeline-body"><p>I think I need better evidence than a valgrind report to be honest. In the past, these sorts of things have been false positives. In particular, I don&#x27;t believe valgrind distinguishes between &quot;memory grows without bound&quot; and &quot;something was allocated but never freed.&quot; The latter is not actually a problem and it is not something I would consider a bug.</p>
<p>So basically, if all you have is a valgrind report then that isn&#x27;t really good enough for me absent other evidence.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Chaostheorie">@Chaostheorie</a> on 2023-04-17 22:33</div>
            <div class="timeline-body"><p>Maybe it is just a false-positive/ false detection. That&#x27;s why the issue is titled &quot;potential&quot; memory leak. English is not my native language and I&#x27;m sorry if I missed some nuance there.</p>
<p>What kind of tooling would you recommend for digging deeper?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-04-17 22:36</div>
            <div class="timeline-body"><p>I don&#x27;t think there is any tooling that can distinguish between the two classes of leaks I mentioned. The difference is semantic and in how the memory is used and whether it scales with the size of the input.</p>
<p>So basically what has to happen is you need to trace the valgrind leaks back to a point in the source code and determine what kind of leak it is. Sometimes doing this is tricjy. IIRC certain memory allocators like jemalloc will trigger false positives, so it might be good to run valgrind under different allocators.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Chaostheorie">@Chaostheorie</a> on 2023-04-17 22:42</div>
            <div class="timeline-body"><p>Okay, thank you for the quick response. I&#x27;ll try looking into it tomorrow and will close the issue for now. I will reopen it if anything specific can be identified.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/Chaostheorie">@Chaostheorie</a> on 2023-04-17 22:42</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:13 UTC
    </footer>
</body>
</html>
