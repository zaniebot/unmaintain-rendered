<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>support escaping meta characters in glob patterns - BurntSushi/ripgrep #526</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>support escaping meta characters in glob patterns</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/526">#526</a>
        opened by <a href="https://github.com/gabebw">@gabebw</a>
        on 2017-06-22 22:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/gabebw">@gabebw</a></div>
            <div class="timeline-body"><p>I have the following in <a href="https://github.com/gabebw/dotfiles/blob/master/.gitignore">my global <code>.gitignore</code></a>:</p>
<pre><code># ...other things...
[
]
# ...other things...
</code></pre>
<p>This is because my text editor sometimes creates files with these exact names, and I want to ignore them. However, ripgrep is (I think!) parsing these lines as part of a regex:</p>
<pre><code>$ rg anything
/Users/gbwilliams/.gitignore: line 56: error parsing glob &#x27;[&#x27;: unclosed character class; missing &#x27;]&#x27;
./.gitignore: line 2: error parsing glob &#x27;[&#x27;: unclosed character class; missing &#x27;]&#x27;
No files were searched, which means ripgrep probably applied a filter you didn&#x27;t expect. Try running again with --debug.
</code></pre>
<hr>
<p>To reproduce:</p>
<ol>
<li><code>mkdir test_dir</code></li>
<li><code>cd test_dir</code></li>
<li><code>echo [ &gt; .gitignore</code></li>
<li><code>echo ] &gt;&gt; .gitignore</code></li>
<li><code>rg anything</code></li>
<li>See an error</li>
</ol>
<p>Version:</p>
<pre><code>$ rg -V
ripgrep 0.5.2
</code></pre>
<p>Debug output:</p>
<pre><code>$ rg --debug anything
DEBUG:grep::search: regex ast:
Literal {
    chars: [
        &#x27;a&#x27;,
        &#x27;n&#x27;,
        &#x27;y&#x27;,
        &#x27;t&#x27;,
        &#x27;h&#x27;,
        &#x27;i&#x27;,
        &#x27;n&#x27;,
        &#x27;g&#x27;
    ],
    casei: false
}
DEBUG:grep::literals: literal prefixes detected: Literals { lits: [Complete(anything)], limit_size: 250, limit_class: 10 }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.sw[po]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.sw[po]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;w&#x27;), Class { negated: false, ranges: [(&#x27;p&#x27;, &#x27;p&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.py[co]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.py[co]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;y&#x27;), Class { negated: false, ranges: [(&#x27;c&#x27;, &#x27;c&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }]) }
DEBUG:globset: built glob set; 1 literals, 25 basenames, 2 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 2 regexes
DEBUG:ignore::dir: /Users/gbwilliams/.gitignore: line 56: error parsing glob &#x27;[&#x27;: unclosed character class; missing &#x27;]&#x27;
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.sw[po]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.sw[po]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;s&#x27;), Literal(&#x27;w&#x27;), Class { negated: false, ranges: [(&#x27;p&#x27;, &#x27;p&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }]) }
DEBUG:globset: glob converted to regex: Glob { glob: &quot;**/*.py[co]&quot;, re: &quot;(?-u)^(?:/?|.*/).*\\.py[co]$&quot;, opts: GlobOptions { case_insensitive: false, literal_separator: false }, tokens: Tokens([RecursivePrefix, ZeroOrMore, Literal(&#x27;.&#x27;), Literal(&#x27;p&#x27;), Literal(&#x27;y&#x27;), Class { negated: false, ranges: [(&#x27;c&#x27;, &#x27;c&#x27;), (&#x27;o&#x27;, &#x27;o&#x27;)] }]) }
DEBUG:globset: built glob set; 1 literals, 25 basenames, 2 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 2 regexes
/Users/gbwilliams/.gitignore: line 56: error parsing glob &#x27;[&#x27;: unclosed character class; missing &#x27;]&#x27;
DEBUG:globset: built glob set; 0 literals, 1 basenames, 0 extensions, 0 prefixes, 0 suffixes, 0 required extensions, 0 regexes
./.gitignore: line 2: error parsing glob &#x27;[&#x27;: unclosed character class; missing &#x27;]&#x27;
DEBUG:ignore::walk: ignoring ./.gitignore: Ignore(IgnoreMatch(Hidden))
No files were searched, which means ripgrep probably applied a filter you didn&#x27;t expect. Try running again with --debug.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/okdana">@okdana</a> on 2017-06-23 07:35</div>
            <div class="timeline-body"><p>From <a href="https://git-scm.com/docs/gitignore"><code>gitignore(5)</code></a>:</p>
<blockquote>
<p>Otherwise, Git treats the pattern as a shell glob suitable for consumption by fnmatch(3) with the FNM_PATHNAME flag</p>
</blockquote>
<p>From <a href="http://man7.org/linux/man-pages/man7/glob.7.html"><code>glob(7)</code></a>:</p>
<blockquote>
<p>A string is a wildcard pattern if it contains one of the characters &#x27;?&#x27;, &#x27;*&#x27; or &#x27;[&#x27;.... An expression &quot;[...]&quot; where the first character after the leading &#x27;[&#x27; is not an &#x27;!&#x27; matches a single character, namely any of the characters enclosed by the brackets.... One can remove the special meaning of &#x27;?&#x27;, &#x27;*&#x27; and &#x27;[&#x27; by preceding them by a backslash, or, in case this is part of a shell command line, enclosing them in quotes.</p>
</blockquote>
<p>From <a href="http://man7.org/linux/man-pages/man3/fnmatch.3.html"><code>fnmatch(3)</code></a>:</p>
<blockquote>
<p>RETURN VALUE Zero if string matches pattern, FNM_NOMATCH if there is no match or another nonzero value if there is an error.</p>
</blockquote>
<p>I made a simple C program to call <code>fnmatch()</code> with the pattern <code>[</code> and see what it returns ‚Äî it gives <code>2</code>, which is one of those other non-zero error values (<code>FNM_NOMATCH</code> is equal to <code>1</code>).</p>
<p>And here is how git itself handles the <code>gitignore</code> pattern <code>[</code>:</p>
<pre><code>heartswap:/tmp % mkdir repo &amp;&amp; cd repo
heartswap:repo % git init
Initialized empty Git repository in /private/tmp/repo/.git/
heartswap:repo % touch &#x27;[&#x27;

# Without .gitignore
heartswap:repo % git status -s
?? [

# With [ in .gitignore
heartswap:repo % echo &#x27;[&#x27; &gt; .gitignore
heartswap:repo % git status -s
?? .gitignore
?? [

# With \[ in .gitignore
heartswap:repo % echo &#x27;\[&#x27; &gt; .gitignore
heartswap:repo % git status -s
?? .gitignore
</code></pre>
<p>Sooo... i think git is behaving as documented: It treats <code>[</code> as an invalid pattern, just like <code>fnmatch()</code> would. <code>rg</code> behaves the same way, with one difference ‚Äî it actually <em>tells you</em> that it&#x27;s invalid. Personally i think the feedback is kind of nice.</p>
<p>In any case, you can fix the problem by escaping the pattern like this: <code>\[</code></p>
<p>Note that <code>]</code> is NOT an invalid pattern ‚Äî it is treated literally by <code>fnmatch()</code>, git, and <code>rg</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-23 11:32</div>
            <div class="timeline-body"><p>@okdana&#x27;s analysis is almost correct (thank you!). The only thing you missed is that ripgrep doesn&#x27;t actually support the <code>\[</code> formulation. Instead, you&#x27;d have to write <code>[[]</code>.</p>
<p>I think if <code>fnmatch</code> and <code>git</code> support the <code>\[</code> formulation, then we probably should too (similarly for other meta characters). I think this bug fix would be entirely confined to the <code>globset</code> crate, which has its own glob parser.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;rg tries to parse `[` and `]` in gitignore&quot; to &quot;support escaping meta characters in glob patterns&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-23 11:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-23 11:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-06-23 11:32</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/okdana">@okdana</a> on 2017-06-23 19:36</div>
            <div class="timeline-body"><p>Oh, i didn&#x27;t actually test <code>\[</code> in <code>rg</code>, just the others. Oops.</p>
<p>So, i <em>believe</em> i&#x27;ve got <a href="https://github.com/BurntSushi/ripgrep/compare/9e51b18...okdana:feature/globset/escaping?expand=1">a solution</a> that works fine on UNIX... but it occurred to me that this has implications for Windows: It looks like <code>globset</code> tries to support (un-escaped) <code>\</code> as a path separator on that platform, and that seems fundamentally incompatible with consistent escaping behaviour.</p>
<p>Does <em>git</em> support <code>\</code> as a path separator in <code>.gitignore</code> on Windows? I don&#x27;t have access to a Windows machine to test, but a cursory Google search and a glance at <a href="https://github.com/git/git/blob/master/wildmatch.c">the source</a> seem to suggest it doesn&#x27;t... i think.</p>
<p>Not sure what to do ü§î</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gabebw">@gabebw</a> on 2017-06-23 22:22</div>
            <div class="timeline-body"><p>@okdana Thank you for the in-depth analysis of what gitignore does with brackets! That&#x27;s super cool to know!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/elirnm">@elirnm</a> on 2017-06-24 05:19</div>
            <div class="timeline-body"><p>@okdana From (non-exhaustively) testing git 2.13.0 on Windows 7 it doesn&#x27;t appear to support <code>\</code> as a path separator.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/elirnm">@elirnm</a> on 2017-06-25 20:39</div>
            <div class="timeline-body"><p>@okdana Except there might be other repercussions if globset doesn&#x27;t treat <code>\</code> as a path separator on Windows? If globset is used to parse the globs given by the <code>-g</code> option as well as the .gitignore globs, then could cause issues with <code>\</code> because tab-completion of paths on Windows terminals completes with <code>\</code>, even if <code>/</code> was typed by the user earlier.</p>
<p>So if globset is used to parse the <code>-g</code> option then not treating <code>\</code> as a path separator would essentially break terminal filepath completion on Windows. If globset isn&#x27;t used for <code>-g</code> then this doesn&#x27;t matter, of course.</p>
<p>The <a href="https://github.com/SLaks/Minimatch/">C# glob matcher</a> that I&#x27;m familiar with has an <code>AllowWindowsPaths</code> option that disables all escape characters but treats <code>\</code> as a path separator, but introducing that here might be unwanted or beyond the scope of this issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/okdana">@okdana</a> on 2017-06-25 22:35</div>
            <div class="timeline-body"><p>I suppose you could do something like have it check to see if the character following <code>\</code> is a meta-character, and, if not, normalise it to <code>/</code> on Windows like it does now. That way, if you passed <code>-g &#x27;path\to\file.ext&#x27;</code> it would match as expected.</p>
<p>Most glob meta-characters are illegal in Windows file paths anyway, so there would probably never be a situation where you were trying to match a file name containing a literal <code>*</code> or whatever. I don&#x27;t think brackets are illegal, though, so in cases like this one it might get weird ‚Äî if you had a file path like <code>dir\subdir\[</code>, you would have to do <code>-g &#x27;dir\subdir\\\[</code>.</p>
<p>I suspect that Windows user + glob containing sub-directory + file name containing meta-character is an exceptionally unlikely set of circumstances, so it&#x27;d probably work out <em>most</em> of the time in the real world. It does feel a little weird though ‚Äî it certainly is non-standard, and it might give users the false impression that git supports this behaviour.</p>
<p>FWIW, i looked into how other projects handle globs on Windows:</p>
<ul>
<li><p>Mercurial&#x27;s <code>hgignore</code> globbing, Ruby&#x27;s <code>File.fnmatch()</code>, Perl&#x27;s <code>File::FnMatch</code>, and PHP&#x27;s <code>fnmatch()</code> all use <code>\</code> for escaping and <code>/</code> for path separators. (The Perl package doesn&#x27;t work on Windows at all since it defers to the system <code>fnmatch()</code>.)</p>
</li>
<li><p>Python&#x27;s <code>fnmatch</code> module is poorly named, since its functions don&#x27;t work like <code>fnmatch()</code> at all. None of them support escaping. <em>Some</em> of them normalise slashes.</p>
</li>
<li><p>PHP&#x27;s <code>glob()</code> supports both <code>/</code> and <code>\</code> on Windows. It seems to handle this by simply disabling escaping on that platform.</p>
</li>
</ul>
<p>If i were a Windows user i think i&#x27;d just deal with the tab-completion not working ‚Äî¬†presumably it already fails to work, as it does on UNIX, in several cases: when you&#x27;re doing negation (<code>!</code>), when you&#x27;ve given an &#x27;absolute&#x27; path (leading <code>/</code>), or when you&#x27;ve got actual wild-cards in the pattern. But that&#x27;s me ü§∑‚Äç‚ôÄÔ∏è</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/elirnm">@elirnm</a> on 2017-06-26 05:11</div>
            <div class="timeline-body"><p>@okdana Absolute paths do complete, on Powershell at least (the leading <code>\</code> or <code>/</code> is replaced with <code>C:\</code> or whatever the current drive is), but the other situations fail to work. I would personally be fine with tab completion not working in globs, but I also don&#x27;t use paths in globs to ripgrep very much anyway.</p>
<p>I guess the real potential issue with changing the behavior of <code>\</code> in the <code>-g</code> argument is not the loss of tab completion but the failure (and maybe not for obvious reasons to a user) of paths separated with <code>\</code> in the <code>-g</code> option, even if typed that way by the user. But then, the behavior would match with how git parses globs and how you have to match <code>\</code> in regexes, so it might not be a big issue (especially if it&#x27;s documented behavior). I don&#x27;t think there&#x27;s necessarily any problem with saying &quot;<code>\</code> in paths in globs isn&#x27;t supported because ripgrep parses globs in a way that&#x27;s essentially industry-standard for cross-platform programs&quot; (though I&#x27;m sure there&#x27;s people out there who think otherwise). And even the programs that do support <code>\</code> in paths usually do so simply by having a &quot;Windows mode&quot; where escaping is completely disabled, not by being clever in some way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/okdana">@okdana</a> on 2017-06-26 05:37</div>
            <div class="timeline-body"><blockquote>
<p>Absolute paths do complete, on Powershell at least (the leading \ or / is replaced with C:\ or whatever the current drive is)</p>
</blockquote>
<p>Sorry, i meant <code>gitignore</code>-style &#x27;absolute&#x27; paths, where the leading <code>/</code> represents the root of the repository or search path, not the root of the file system. In that case i believe the tab-completion will fail, unless your CWD is the file-system root or you happen to have a file structure on the file-system root that mirrors your search directory.</p>
<blockquote>
<p>I guess the real potential issue with changing the behavior of \ in the -g argument is not the loss of tab completion but the failure (and maybe not for obvious reasons to a user) of paths separated with \ in the -g option, even if typed that way by the user.</p>
</blockquote>
<p>Yeah, i can certainly see how it would be confusing if (from the user&#x27;s perspective) the glob just silently failed to work. This tool was recommended to me in the first place because i found <code>ag</code>&#x27;s glob-handling confusing and esoteric, so i obv wouldn&#x27;t want that inflicted on anyone else.</p>
<p>I suppose <code>rg</code> could print an informational warning on Windows if someone supplies a glob where <code>\</code> precedes a non-meta-character... but then i imagine you would have to implement partial parsing in <code>rg</code> (since printing warning messages doesn&#x27;t seem like <code>globset</code>&#x27;s job), and maybe some users would find it irritating and want to turn it off, so you&#x27;d need to deal with that....</p>
<p>idk. At this point i feel like i&#x27;m getting out into the weeds over-analysing this so i&#x27;ll shut up for a bit :|</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jakwings">@jakwings</a> on 2017-10-16 05:20</div>
            <div class="timeline-body"><p>Currently, if you want <code>**</code> to work for Windows paths, you have to replace all backslashes in the path with <code>/</code>. And if you do so, this is a reason to support backslash escaping. (I prefer to escape any character after <code>\</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-03-10 14:31</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:04 UTC
    </footer>
</body>
</html>
