<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Library version of ripgrep really slow - BurntSushi/ripgrep #1090</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Library version of ripgrep really slow</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/1090">#1090</a>
        opened by <a href="https://github.com/dessalines">@dessalines</a>
        on 2018-10-22 17:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dessalines">@dessalines</a></div>
            <div class="timeline-body"><p>So I'm trying to use ripgrep as a library, with the following code, copy-pasted from the official docs.</p>
<pre><code class="language-rust">fn search_file(file: File, query: &amp;str) -&gt; Result&lt;Vec&lt;String&gt;, Box&lt;Error&gt;&gt; {
  let pattern = query.replace(&quot; &quot;, &quot;.*&quot;);

  let matcher = RegexMatcher::new(&amp;pattern)?;
  let mut matches: Vec&lt;String&gt; = vec![];
  Searcher::new().search_file(
    &amp;matcher,
    &amp;file,
    UTF8(|_lnum, line| {
      matches.push(line.to_string());
      Ok(true)
    }),
  )?;

  Ok(matches)
}
</code></pre>
<p>For some reason this takes sometimes 10 seconds, while the command line version of ripgrep takes ~ 100ms. What could be the reason?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-10-22 18:10</div>
            <div class="timeline-body"><p>This isn't an actionable ticket. Please provide a fully reproducible example that I can re-create. Otherwise, it's not possible for me to analyze the performance characteristics of your specific situation.</p>
<p>One possible way in which your example program could be slower than ripgrep proper is if your query has a lot of matches and/or your corpus is very large. Firstly, your program is counting line numbers, and ripgrep doesn't necessarily do that (although it probably does, it's not possible to know since you haven't provided a reproducible example). Secondly, your program is using the <code>UTF8</code> sink, which is <a href="https://github.com/BurntSushi/ripgrep/blob/fb622666206089cf7092ae116612898ac358c91c/grep-searcher/src/sink.rs#L473-L487">explicitly documented to do a UTF-8 validation check</a>, which ripgrep doesn't necessarily do by default (but again, it may, but you haven't provided an example so it's not possible for me to know).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2018-10-22 18:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dessalines">@dessalines</a> on 2018-10-22 18:30</div>
            <div class="timeline-body"><p>The example is from your docs.rs for using grep as a library, <a href="https://docs.rs/grep-searcher/0.1.1/grep_searcher/index.html">here</a>. I'm not sure if that's the preferred way or not.  I just need to know the proper way to use the library version of ripgrep so that its as fast as the command line version. I don't need line numbers.</p>
<p>I have a repo that has the 300 MB file I'm searching, I could list out git commands that clone the repo so you can replicate it locally, if you wish.</p>
<p>I've also changed the above <code>UTF8</code> sink to <code>Lossy</code>, and that doesn't seem to make a difference.</p>
<p>I'll do this shortly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dessalines">@dessalines</a> on 2018-10-22 18:55</div>
            <div class="timeline-body"><p>Okay, here's the comparison. Same query, one using the library version from the official docs, the other using the command line.</p>
<pre><code class="language-sh">git clone -b library_ripgrep https://gitlab.com/dessalines/torrents.csv
cd torrents.csv/server/service
cargo test -- --nocapture
time rg -q -i &quot;sherlock&quot; ../../torrents.csv
</code></pre>
<p>And the output:</p>
<pre><code class="language-sh">running 1 test
Query took PT4.906661570S seconds.
test tests::test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

Î» rg -q -i &quot;sherlock&quot; ../../torrents.csv

real	0m0.005s
user	0m0.003s
sys	0m0.003s

</code></pre>
<p>The relevant function is <code>search_file</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2018-10-22 20:00</div>
            <div class="timeline-body"><p>Thanks for providing me with an example. In the future, please isolate your code more. If I have to compile a web server to try out your code, then you're making it harder for me to help you.</p>
<blockquote>
<p>I've also changed the above UTF8 sink to Lossy, and that doesn't seem to make a difference.</p>
</blockquote>
<p>They both do UTF-8 validation, so I really wouldn't expect there to be a difference. If you want to avoid UTF-8 validation, then you need to use the <code>Bytes</code> sink.</p>
<blockquote>
<p><code>cargo test -- --nocapture</code></p>
</blockquote>
<p>If you're doing the timing in a test, then <code>cargo test</code> will compile without optimizations by default. Try using <code>cargo test --release -- --nocapture</code> instead.</p>
<blockquote>
<p><code>time rg -q -i &quot;sherlock&quot; ../../torrents.csv</code></p>
</blockquote>
<p>This is not equivalent to your code using the ripgrep library. I'd say <code>time rg -n sherlock ../../torrents.csv &gt; /tmp/out</code> is closer. I can see a measurable difference between <code>-n</code> and <code>-N</code> here, so counting lines actually has a cost in your case. The convenience sinks provided for you require counting lines. The performance overhead is very small, but if you don't want it, then you'll need to provide your own implementation of the <code>Sink</code> trait.</p>
<p>Try this instead to get bytes:</p>
<pre><code class="language-rust">fn search_file_bytes(file: File, query: &amp;str) -&gt; Result&lt;Vec&lt;Vec&lt;u8&gt;&gt;, Box&lt;Error&gt;&gt; {
  let pattern = query.replace(&quot; &quot;, &quot;.*&quot;);

  let matcher = RegexMatcher::new_line_matcher(&amp;pattern)?;
  let mut matches: Vec&lt;Vec&lt;u8&gt;&gt; = vec![];

  let mut searcher = SearcherBuilder::new()
    .binary_detection(BinaryDetection::quit(b'\x00'))
    // .line_number(false)
    .build();

  searcher.search_file(
    &amp;matcher,
    &amp;file,
    Bytes(|_lnum, line| {
      matches.push(line.to_vec());
      Ok(true)
    }),
  )?;

  Ok(matches)
}
</code></pre>
<p>After doing this and using <code>--release</code>, I get comparable times.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dessalines">@dessalines</a> on 2018-10-22 22:13</div>
            <div class="timeline-body"><p>Thanks, this did it! The main difference was the release flag. It might be a good idea to add these two methods to the <a href="https://docs.rs/grep-searcher/0.1.1/grep_searcher/">docs</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dessalines on 2018-10-22 22:13</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:43 UTC
    </footer>
</body>
</html>
