<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support Basic Regular Expression (BRE) syntax common to vim, gnu grep, and git grep - BurntSushi/ripgrep #542</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support Basic Regular Expression (BRE) syntax common to vim, gnu grep, and git grep</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/BurntSushi/ripgrep/issues/542">#542</a>
        opened by <a href="https://github.com/RedBeard0531">@RedBeard0531</a>
        on 2017-07-06 19:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/RedBeard0531">@RedBeard0531</a></div>
            <div class="timeline-body"><p>Part of what prevents <code>rg</code> from feeling like a drop in replacement for gnu grep or git grep is that some parts of the regex syntax behave differently. These are the ones that seem to bite me the most. The first two could probably be always available, but the last would require a flag to activate &quot;basic&quot; mode.</p>
<ol>
<li>Support <code>$</code> as a literal in the middle of the pattern and only give it special meaning at the end of a sub-pattern. With today's syntax I don't think the pattern <code>$cmd</code> will ever match any input so it is probably not what the user wants. Ditto for <code>^</code> anywhere other than the beginning, but that is less annoying because it is used much less often in code.</li>
<li>Support <code>\&lt;</code> and <code>\&gt;</code> zero-width assertions of begin and end of word. This is the pattern that vim uses when you search for current word by hitting <code>*</code> or <code>#</code>. These can probably just be made synonyms of <code>\b</code>, which is what <a href="https://github.com/mileszs/ack.vim/blob/6ef28a1/autoload/ack.vim#L70-L71">ack.vim</a> does.</li>
<li>Add a mode where every character except <code>.*[\</code> and <code>^$</code> at start and end of pattern is considered a literal, and require <code>\</code> to activate the special meaning.  I know that the basic syntax is more slash-heavy when writing complex regexes, but I find myself wanting to use a literal <code>(</code> or <code>{</code> much more often than using the regex meanings.</li>
</ol>
<p>If you'd prefer, I can split this up and make 3 separate tickets.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-07-06 23:23</div>
            <div class="timeline-body"><p>@RedBeard0531 Thanks for filing this issue. Unfortunately, my short answer here is probably: no to everything.</p>
<p>The longer answer has three prongs to it.</p>
<p>Philosophically, I very much dislike BREs. They feel like a legacy to me, and from my own personal experience and from hearing about the experience of others, have led to a lot of confusion. At least conceptually speaking, I'd rather support one syntax instead of one syntax and one legacy syntax that is almost-but-not-quite-like the other syntax.</p>
<p>Motivation wise, ripgrep was never, is never, and will never be a drop-in replacement for any of the standard Unix tools like grep or sed. While there's a lot to be said for keeping behavior similarish because it corresponds to what people know, I'm generally not in favor of adding things to ripgrep <em>just because</em> that's how some other tools does it. I think the features need to stand on their own. With that said, I do sympathize with your annoyances and can see how BREs can be more convenient in some cases. In my experience, the <code>-F</code> flag (which just interprets the pattern as a literal with no regexes at all) goes a long way to fixing most of them. The only cases it doesn't cover is when you do want to sprinkle a bit of regex with your literal. The problem with BREs is that you need to keep a bunch of special rules in your head; some meta characters need to be escaped while others don't. So it's kind of annoyance either way, although I can appreciate that folks have different preferences.</p>
<p>Finally, and perhaps most importantly, the features you've requested here basically have two possible implementation paths. Either they get added to the upstream <a href="https://github.com/rust-lang/regex"><code>regex-syntax</code></a> parser (which I myself maintain) or ripgrep grows its own regex parser or ripgrep somehow hacks these features by doing a translation step at the level of concrete syntax (which is roughly equivalent to writing a parser). Any of these feels like a lot of work to me.</p>
<p>Adding these features to <code>regex-syntax</code> proper feels a bit out of place since having support for BREs at the code level has a much less compelling argument, since you're less likely to be typing ad hoc patterns on the fly like you would with <code>grep</code>. Adding this on top of <code>regex-syntax</code> inside ripgrep isn't really possible, because the <code>regex-syntax</code> parser doesn't actually produce a faithful AST. Instead, it produces something akin to a high level intermediate representation that can be compiled to opcodes easily. So things like &quot;a literal <code>$</code> was used&quot; end up getting lost in translation (a <code>$</code> can yield either a <code>EndLine</code> or a <code>EndText</code>, depending on whether the <code>m</code>/&quot;multi line&quot; flag is set).</p>
<p>Some features (like <code>$</code> should be a literal <code>$</code> unless it is at the end up a sub-pattern) really require a full parser to implement, which means there's no way to hack that on top of the <code>regex-syntax</code> parser without writing your own parser. And I will say this: there's <strong>no way</strong> ripgrep is getting its own regex parser. Never. Never. Never. :-)</p>
<hr />
<p>With all that said, I am in the process of rewriting the <code>regex-syntax</code> crate to provide a more faithful AST representation of a regex pattern, and then a separate explicit translation step to something like the HIR that we have now. If we had a faithful AST, then I believe one could write a transformation on top of that that implements all of the features you wanted here. (There would be tricky parts, for example, unwinding a <code>(re)+</code> expression to a <code>(re)\+</code>, but it seems possible.) But, this rewrite has already been months in the making. I've made a ton of progress, but it will take a while yet before it's ready for us.</p>
<p>So... I will say this. If the new <code>regex-syntax</code> parser does indeed make these transformations easy and it is easy to maintain, then this is probably something I'd be willing to add to ripgrep. But if this somehow adds an explosion of implementation complexity that I'm not able to see right now, then the outlook will not look so rosy. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @BurntSushi on 2017-07-06 23:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">icebox</span> added by @BurntSushi on 2017-07-06 23:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @BurntSushi on 2017-07-06 23:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2017-10-22 01:24</div>
            <div class="timeline-body"><p>I'm going to close this. I think my conclusion in my previous comment still stands, but I don't see any reason to track this. If an industrious individual wants to do this after the new regex parser lands (which is still a ways away), then we can revisit this ticket.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2017-10-22 01:24</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:42:14 UTC
    </footer>
</body>
</html>
