<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>regression: ruff deletes imports; successive checks fail due to missing import - astral-sh/ruff #14698</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>regression: ruff deletes imports; successive checks fail due to missing import</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/14698">#14698</a>
        opened by <a href="https://github.com/WhyNotHugo">@WhyNotHugo</a>
        on 2024-12-01 11:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/WhyNotHugo">@WhyNotHugo</a> on 2024-12-01 11:41</div>
            <div class="timeline-body"><p>Running <code>ruff check --force-exclude --fix --exit-non-zero-on-fix</code> on my repository deletes some imports that are actually used.</p>
<p>The next time that I run <code>ruff check .</code>, it fails because of missing imports. The missing imports are the ones deleted by ruff.</p>
<h2>Reproduction steps</h2>
<ul>
<li>git clone https://github.com/WhyNotHugo/django-afip/</li>
<li>cd django-afip</li>
<li>ruff check --force-exclude --fix --exit-non-zero-on-fix</li>
</ul>
<h2>Observed result</h2>
<p><code>ruff</code> deletes imports which are in the <code>if TYPE_CHECKING</code> block:</p>
<pre><code class="language-diff">diff --git a/django_afip/serializers.py b/django_afip/serializers.py
index 34fa8b4..bc2eb57 100644
--- a/django_afip/serializers.py
+++ b/django_afip/serializers.py
@@ -11,13 +11,6 @@ if TYPE_CHECKING:
     from datetime import date
     from datetime import datetime
 
-    from django.db.models import QuerySet
-
-    from django_afip.models import AuthTicket
-    from django_afip.models import Optional
-    from django_afip.models import Receipt
-    from django_afip.models import Tax
-    from django_afip.models import Vat
 
 
</code></pre>
<p>Running <code>ruff check</code> now fails:</p>
<pre><code class="language-sh">&gt; ruff check
django_afip/serializers.py:43:30: F821 Undefined name `AuthTicket`
   |
42 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
43 | def serialize_ticket(ticket: AuthTicket):  # noqa: ANN201
   |                              ^^^^^^^^^^ F821
44 |     return f.FEAuthRequest(
45 |         Token=ticket.token,
   |

django_afip/serializers.py:52:43: F821 Undefined name `QuerySet`
   |
51 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
52 | def serialize_multiple_receipts(receipts: QuerySet[Receipt]):  # noqa: ANN201
   |                                           ^^^^^^^^ F821
53 |     receipts = receipts.all().order_by(&quot;receipt_number&quot;)
   |

django_afip/serializers.py:52:52: F821 Undefined name `Receipt`
   |
51 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
52 | def serialize_multiple_receipts(receipts: QuerySet[Receipt]):  # noqa: ANN201
   |                                                    ^^^^^^^ F821
53 |     receipts = receipts.all().order_by(&quot;receipt_number&quot;)
   |

django_afip/serializers.py:69:32: F821 Undefined name `Receipt`
   |
68 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
69 | def serialize_receipt(receipt: Receipt):  # noqa: ANN201
   |                                ^^^^^^^ F821
70 |     taxes = receipt.taxes.all()
71 |     vats = receipt.vat.all()
   |

django_afip/serializers.py:128:24: F821 Undefined name `Tax`
    |
127 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
128 | def serialize_tax(tax: Tax):  # noqa: ANN201
    |                        ^^^ F821
129 |     return f.Tributo(
130 |         Id=tax.tax_type.code,
    |

django_afip/serializers.py:139:24: F821 Undefined name `Vat`
    |
138 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
139 | def serialize_vat(vat: Vat):  # noqa: ANN201
    |                        ^^^ F821
140 |     return f.AlicIva(
141 |         Id=vat.vat_type.code,
    |

django_afip/serializers.py:148:34: F821 Undefined name `Optional`
    |
147 | @typing.no_type_check  # zeep's dynamic types cannot be type-checked
148 | def serialize_optional(optional: Optional):  # noqa: ANN201
    |                                  ^^^^^^^^ F821
149 |     return f.Opcional(
150 |         Id=optional.optional_type.code,
    |

Found 7 errors.
</code></pre>
<h2>Expected results</h2>
<p>No change; ruff should not delete imports which are being used.</p>
<h2>Additional details</h2>
<ul>
<li>Using <code>ruff 0.8.1</code> from PyPI</li>
<li>The issue is not reproducible with ruff 0.7.3</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/WhyNotHugo">@WhyNotHugo</a> on 2024-12-01 11:43</div>
            <div class="timeline-body"><p>Also not an issue on <code>ruff 0.8.0</code>; only <code>0.8.1</code> is affected.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-01 11:52</div>
            <div class="timeline-body"><p>Looks like this regression was caused by #14615</p>
<p>If you remove the <code>@no_type_check</code> decorator, then <code>F401</code> stops triggering for those imports.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-12-01 12:49</div>
            <div class="timeline-body"><p>Is this incorrect? The spec says that &quot;Functions with the <code>@no_type_check</code> decorator should be treated as having no annotations.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2024-12-01 12:58</div>
            <div class="timeline-body"><blockquote>
<p>The spec says that &quot;Functions with the <code>@no_type_check</code> decorator should be treated as having no annotations.&quot;</p>
</blockquote>
<p>I think what it means is that we should treat its parameters (and return type) as <code>Any</code>. Consider this snippet, in which <code>Foo</code> and <code>Bar</code> are used in instantiations, the results of which are possibly inspected at runtime:</p>
<pre><code class="language-python">from typing import no_type_check
from library import Foo, Bar  # Magic classes

@no_type_check
def f(v: Foo()) -&gt; Bar(): ...

def frobnicate(f):  # More magic
	...; inspect.signature(f); ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-01 12:59</div>
            <div class="timeline-body"><blockquote>
<p>Is this incorrect? The spec says that &quot;Functions with the <code>@no_type_check</code> decorator should be treated as having no annotations.&quot;</p>
</blockquote>
<p>What the typing spec says is irrelevant in this case, since the annotations will still be stored by the compiler and will be accessible at runtime. So the annotations should only really be ignored as far as type checkers are concerned.</p>
<p>Now, why you would annotate a function that is marked with <code>@no_type_check</code>, is an entirely different question. It does seem like a strange thing to do, but it doesn't really change that Ruff is causing runtime errors if it pretends the annotations don't exist at all and ends up removing unused imports, that aren't actually unused.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-12-01 13:03</div>
            <div class="timeline-body"><blockquote>
<p>What the typing spec says is irrelevant in this case, since the annotations will still be stored by the compiler and will be accessible at runtime. So the annotations should only really be ignored as far as type checkers are concerned.</p>
</blockquote>
<p>I don't really agree, but from a practical standpoint, is does seem wrong to be removing imports here. I'm not sure where to draw the line though. Should <em>this</em> raise a lint error? That was the initiating use-case.</p>
<pre><code>from typing import no_type_check

@no_type_check
def f(v: Foo) -&gt; Bar: ...  # Foo and Bar don't exist. Should we raise a lint error?
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-01 13:06</div>
            <div class="timeline-body"><blockquote>
<p>I don't really agree, but from a practical standpoint, is does seem wrong to be removing imports here. I'm not sure where to draw the line though. Should <em>this</em> raise a lint error? That was the initiating use-case.</p>
<pre><code>from typing import no_type_check

@no_type_check
def f(v: Foo) -&gt; Bar: ...  # Foo and Bar don't exist. Should we raise a lint error?
</code></pre>
</blockquote>
<p>Yes, absolutely it should. You could maybe argue that it shouldn't if you use <code>from __future__ import annotations</code> or are on Python 3.14, but even then it is somewhat questionable. But in most cases this will cause a <code>NameError</code> at runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-12-01 13:07</div>
            <div class="timeline-body"><p>Does your opinion change given:</p>
<pre><code>from typing import no_type_check

@no_type_check
def f(v: &quot;Foo&quot;) -&gt; &quot;Bar&quot;: ...  # Foo and Bar don't exist. Should we raise a lint error?
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-01 13:09</div>
            <div class="timeline-body"><p>This is functionally equivalent to the <code>from __future__ import annotations</code> case. You could certainly make a case for it, but I don't think you will find many people that would find that behavior useful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-01 13:27</div>
            <div class="timeline-body"><p>While annotations were originally intended as a general purpose feature, the typing use-case is now so prevalent, that you can't really expect to use them for anything else without using <code>typing.Annotated</code>, since otherwise you will cause interoperability issues with runtime and static type checkers and make linters less powerful, since they now cannot make any assumptions about what's a forward reference and what isn't.</p>
<p>Using <code>no_type_check</code> to get around that seems like a fragile hack to me. The recommended way to do this, would be to use <code>Annotated[Any, &quot;not_a_forward_reference&quot;]</code>. I know that rubs some people the wrong way,  because of how verbose it is, and there have been some attempts to propose alternate syntax because of it. Which I think is the more productive way forward, rather than encourage patterns that may cause friction with the rest of the ecosystem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/WhyNotHugo">@WhyNotHugo</a> on 2024-12-01 14:40</div>
            <div class="timeline-body"><blockquote>
<p>[...] why you would annotate a function that is marked with @no_type_check, is an entirely different question.</p>
</blockquote>
<p>In this particular case, some of the variables used in this function are runtime-generated types, so there is no correct annotation for them. The type hints are hints for developers, so they understand what types these functions take as parameters.</p>
<p>These hints also get rendered into generated documentation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-01 15:31</div>
            <div class="timeline-body"><p>We should align Ruff's behavior with what other type checkers do for best compatibility.</p>
<p>Pyright does not raise any error for the example given by @charliermarsh (<a href="https://pyright-play.net/?code=GYJw9gtgBALgngBwJYDsDmUkQWEMopgD68CApkQMYAWZlA1gLABQLAAoSYhTXU8wBMywKMAAUANwBcUAGJgwASigBaAHxQAQgEMQMgHSGoUAMRyFUbSgFbdUAWBQByfGQAeSAM4x9UAMrUYACuADY2AO5kUCDaXlHaUCGoriDgIAD8QA">playground</a>)</p>
<pre><code>from typing import no_type_check

@no_type_check
def f(v: Foo) -&gt; Bar: ...  # Foo and Bar don't exist. Should we raise a lint error?
</code></pre>
<p>which matches my expectations after reading the specification. But we should definitely avoid removing imports if they're referenced from functions annotated with <code>no_type_check</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @MichaReiser on 2024-12-01 15:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-01 16:16</div>
            <div class="timeline-body"><p>@MichaReiser Ruff in many ways captures much more detailed semantic state when it comes to things other than types compared to other type checkers. As far as I am aware all other type checkers currently ignore runtime/typing context, as in they consider everything to be in the same context. A lot of the lint rules rely on statically inferrable behavior based on the object model, rather than the type system. Type checkers typically rely on linters to detect some of these other issues.</p>
<p>As such I don't think it is sufficient to look at what other type checkers do here. You're hiding a statically detectable <code>NameError</code>, that would otherwise be caught by pyflakes.</p>
<p>But rereading the docs, I've come around on the case where forward references are used either implicitly or explicitly. <code>typing.get_type_hints</code> will explicitly ignore any classes or functions that have been decorated with <code>no_type_check</code> and return an empty dictionary, so there's no danger of a <code>NameError</code> and it is even explicitly mentioned in conjunction with <code>Annotated</code> that it allows arbitrary annotations to be used.</p>
<p>In order to avoid bad interactions with other rules I would still recommend treating them like normal forward references, just with the caveat, that no F821 will be emitted for missing bindings. I.e. a narrow exception to the rule, rather than changing the state of the semantic model by not visiting those nodes at all. The additional state for making the more narrow exception is already being tracked through the <code>NO_TYPE_CHECK</code> flag. So it would only be a matter of reverting the change to <code>visit_type_definition</code> and adding additional code to F821 to detect these kinds of forward references.</p>
<p>Edit: It might also be feasible to switch from skipping to calling <code>visit_non_type_definition</code> to reduce the chance of interacting badly with type definition related rules, but that might cause issues for things like:</p>
<pre><code class="language-python">from typing import no_type_check, TYPE_CHECKING

if TYPE_CHECKING:
    from foo import Foo

@no_type_check
def bar(a: list[&quot;Foo&quot;]) -&gt; None: ...
</code></pre>
<p>So it's probably not really a good idea to do that either, since you're just changing where the problem may occur. There's similar kinds of issues in <code>flake8-type-checking</code> with deciding whether or not to flag something as requiring a forward reference or not where we have soft-references to deal with that sort of thing. With a soft reference we always assume the code is correct and don't emit an error in either direction, i.e. it's both considered a reference for things that check for references and not a reference for things that check for references that don't point anywhere in a given context.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/eli-schwartz">@eli-schwartz</a> on 2024-12-01 16:24</div>
            <div class="timeline-body"><p>It's not clear to me whether the discussion thus far has accounted for the fact that the imports which are deleted are inside of a <code>if TYPE_CHECKING:</code> block.</p>
<p>I would personally find it a bit surprising to see imports which cannot be resolved at runtime due to being imported under <code>TYPE_CHECKING</code>, which are simultaneously used as <code>@no_type_checking</code>. Deleting the imports won't produce NameError any way you slice it.</p>
<p>If they're not used for typing, and they're not used for <em>not-typing</em>, then semantically speaking, what precisely are they used for?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-02 08:26</div>
            <div class="timeline-body"><p>@Daverball I don't think it's important whether Ruff's model is more or less complicated than that of type checkers. What's important is that Ruff's behavior matches users' expectations and, to some extent, the typing spec. The typing spec isn't very clear about most details when it comes to <code>no_type_checking</code> and the user expectation is mainly defined by what existing tools with <code>@no_type_check</code> support do. <a href="https://github.com/PyCQA/pyflakes/issues/595">Pyflakes</a> does not support for <code>@no_type_check</code>.</p>
<blockquote>
<p>As such I don't think it is sufficient to look at what other type checkers do here. You're hiding a statically detectable NameError, that would otherwise be caught by pyflakes.</p>
</blockquote>
<p>That's true, but that's the decorator's intent. It's a very broad <code>noqa</code> suppression that applies to typing errors throughout the function. And it should probably be handled the same where some rules test if they're in a <code>no_type_check</code> block and, if so, don't emit their diagnostic (or skip running entirely)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-02 09:10</div>
            <div class="timeline-body"><blockquote>
<p>That's true, but that's the decorator's intent. It's a very broad <code>noqa</code> suppression that applies to typing errors throughout the function. And it should probably be handled the same where some rules test if they're in a <code>no_type_check</code> block and, if so, don't emit their diagnostic (or skip running entirely)</p>
</blockquote>
<p>That's only true as far as type errors are concerned. A <code>NameError</code> is not a type error, the only reason type checkers still tend to highlight most of them, is because it's free for them to do so. They don't know what the type is without being able to look it up, so they might as well emit an error, rather than silently infer <code>Any</code>. But type checkers generally don't go out of their way to ensure that all potential <code>NameError</code>s are highlighted, since they know there are already linters that cover that part well enough.</p>
<p>So I agree that the decorator's intent is to silence any errors relating to the validity of those annotations as types, but annotations are a general purpose construct and they can store arbitrary expressions. It just so happens that that space has mostly been taken over by type hints.</p>
<p>So semantically a name lookup still occurs if there are no forward references, so removing that fact from the semantic model is a bug, plain and simple. The case with forward references is more subtle. Implicit forward references look like regular code, so I think people's expectation is that the load is still simulated, even if it may never happen at runtime. If you want to put an actual plain string into the annotation, then use a string, don't abuse an implicit forward reference for that.</p>
<p>With explicit forward references I'm fine with skipping the load, but I think it's still more robust to do it anyways and just silence any errors related to failed name lookups (or invalid type expressions). That preserves the annotations as pure documentation without enforcement use-case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-02 09:16</div>
            <div class="timeline-body"><p>I get the feeling that we're saying the same but are talking past each other :)</p>
<ul>
<li>Keep analysing type annotations in <code>@no_type_check</code> blocks as we did before #14615</li>
<li>Stop emitting specific diagnostics inside <code>@no_type_check</code> blocks. E.g. any diagnostic related to invalid type annotations, or even possible <code>NameError</code>s</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-02 12:11</div>
            <div class="timeline-body"><p>We should probably revert this change and redo the implementation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-02 13:15</div>
            <div class="timeline-body"><p>Edit: For some reason Eli's comment is rendered at the bottom of this issue for me, so I apologize if this confusion had already been cleared up in the meantime.</p>
<p>@eli-schwartz This was addressed implicitly through discussion about the desired semantics of <code>@no_type_check</code> with the involvement of implicit/explicit forward references.</p>
<p>In the given example the annotations are still used for documentation. If you remove the imports entirely, you now would have to guess what these symbols mean. That's counter-intuitive, especially with an implicit forward reference introduced through <code>from __future__ import annotations</code>, which still reads like a regular python expression, rather than a string. With explicit string annotations it would be easier to justify, but it also seems unnecessary, since we can stop F821/F722 from triggering without changing the semantics of annotation expressions within <code>@no_type_check</code>.</p>
<p>You generally probably wouldn't want ruff to destroy an explicit reference, just because there's a chance it will never be used. An explicit reference is always better than no reference at all, since it makes the code easier to understand.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-12-02 13:28</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:35:55 UTC
    </footer>
</body>
</html>
