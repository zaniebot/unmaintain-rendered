<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fuzz proposal: fuzz target for formatting - astral-sh/ruff #9169</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Fuzz proposal: fuzz target for formatting</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/9169">#9169</a>
        opened by <a href="https://github.com/manunio">@manunio</a>
        on 2023-12-17 15:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/manunio">@manunio</a></div>
            <div class="timeline-body"><p>Hi, Would be interested in  a fuzz target that formates the code twice and checks for inconsistencies between them, something which is done here:
https://github.com/astral-sh/ruff/blob/c944d23053fe84e63a7515c75a50ce46b63dc2e0/crates/ruff_python_formatter/tests/fixtures.rs#L213</p>
<p>For example something like this:</p>
<pre><code>#![no_main]

use libfuzzer_sys::{fuzz_target, Corpus};
use ruff_python_formatter::{format_module_source, PyFormatOptions};
use similar::TextDiff;


fn assert_difference(formatted: &amp;str, reformatted: &amp;str) {
    if reformatted != formatted {
        let diff = TextDiff::from_lines(formatted, reformatted)
            .unified_diff()
            .header(&quot;Formatted once&quot;, &quot;Formatted twice&quot;)
            .to_string();
        panic!(
            r#&quot;Reformatting the formatted code a second time resulted in formatting changes.
---
{diff}---

Formatted once:
---
{formatted}---

Formatted twice:
---
{reformatted}---&quot;#,);
    }
}


fn do_fuzz(case: &amp;[u8]) -&gt; Corpus {
    // throw away inputs which aren&#x27;t utf-8
    let Ok(code) = std::str::from_utf8(case) else {
        return Corpus::Reject;
    };

    // format code twice
    let formatted = match format_module_source(code, PyFormatOptions::default()) {
        Ok(formatted) =&gt; formatted,
        Err(_) =&gt; return Corpus::Reject,
    };

    let reformatted = match format_module_source(formatted.as_code(), PyFormatOptions::default()) {
        Ok(reformatted) =&gt; reformatted,
        Err(_) =&gt; return Corpus::Reject,
    };

    assert_difference(formatted.as_code(), reformatted.as_code());

    Corpus::Keep
}


fuzz_target!(|case: &amp;[u8]| -&gt; Corpus { do_fuzz(case) });
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-18 03:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fuzzer</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-18 03:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-18 03:18</div>
            <div class="timeline-body"><p>@qarmin did some fuzzing of the formatter in the past. See <a href="https://github.com/astral-sh/ruff/issues/7433">astral-sh/ruff#7433</a></p>
<p>I don&#x27;t know if the script they used is available somewhere.</p>
<p>Overall,  we&#x27;ve found fuzzing a useful tool to improve Ruff&#x27;s stability and it helped us find many stability issues before releasing ruff&#x27;s formatter. However, fuzzers also discover issues that are very rare or close to non-existent in practice. That&#x27;s why reporting and fixing all of them isn&#x27;t necessary impactful for our users and is the reason why we prioritize real-world issues or new features over fuzzer issues (but this depends on the fuzzer issue).</p>
<p>What&#x27;s most helpful for us is a list of triaged fuzzer issues. But I think triaging is hard to impossible without understanding how our formatter works. Having a way to run the fuzzer (by someone who can triage issues but doesn&#x27;t know how fuzzing works) could, therefore, be helpful, if we can integrate it into our exsiting fuzzer infrastructure (see <code>fuzzer</code> directory).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-18 03:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/manunio">@manunio</a> on 2023-12-18 08:57</div>
            <div class="timeline-body"><blockquote>
<p>@qarmin did some fuzzing of the formatter in the past. See <a href="https://github.com/astral-sh/ruff/issues/7433">astral-sh/ruff#7433</a></p>
<p>I don&#x27;t know if the script they used is available somewhere.</p>
<p>Overall,  we&#x27;ve found fuzzing a useful tool to improve Ruff&#x27;s stability and it helped us find many stability issues before releasing ruff&#x27;s formatter. However, fuzzers also discover issues that are very rare or close to non-existent in practice. That&#x27;s why reporting and fixing all of them isn&#x27;t necessary impactful for our users and is the reason why we prioritize real-world issues or new features over fuzzer issues (but this depends on the fuzzer issue).</p>
<p>What&#x27;s most helpful for us is a list of triaged fuzzer issues. But I think triaging is hard to impossible without understanding how our formatter works. Having a way to run the fuzzer (by someone who can triage issues but doesn&#x27;t know how fuzzing works) could, therefore, be helpful, if we can integrate it into our exsiting fuzzer infrastructure (see <code>fuzzer</code> directory).</p>
</blockquote>
<p>Hi @MichaReiser thanks for your reply, I&#x27;m a bit confused here do you want me to add above code in fuzz directory so that it can be used by traigers who knows about how formatter works but doesn&#x27;t know how fuzzing works?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-18 09:55</div>
            <div class="timeline-body"><p>Yeah, go for it if you&#x27;re interested in adding it to our existing fuzzer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/manunio">@manunio</a> on 2023-12-22 18:33</div>
            <div class="timeline-body"><p>After running the above <code>fuzz_target</code> (which formats the code twice) for some time, I found a difference between two versions. In this case, the input gets parsed by the AST but throws a <code>NameError</code> in the REPL.</p>
<pre><code>&gt;&gt;&gt; print(ast.dump(ast.parse(&quot;z = V, z = z = V, zxV, = z = V, z = z = V, = z = V, VV,&quot;), indent=4))
Module(
    body=[
        Assign(
            targets=[
                Name(id=&#x27;z&#x27;, ctx=Store()),
                Tuple(
                    elts=[
                        Name(id=&#x27;V&#x27;, ctx=Store()),
                        Name(id=&#x27;z&#x27;, ctx=Store())],
                    ctx=Store()),
                Name(id=&#x27;z&#x27;, ctx=Store()),
                Tuple(
                    elts=[
                        Name(id=&#x27;V&#x27;, ctx=Store()),
                        Name(id=&#x27;zxV&#x27;, ctx=Store())],
                    ctx=Store()),
                Name(id=&#x27;z&#x27;, ctx=Store()),
                Tuple(
                    elts=[
                        Name(id=&#x27;V&#x27;, ctx=Store()),
                        Name(id=&#x27;z&#x27;, ctx=Store())],
                    ctx=Store()),
                Name(id=&#x27;z&#x27;, ctx=Store()),
                Tuple(
                    elts=[
                        Name(id=&#x27;V&#x27;, ctx=Store())],
                    ctx=Store()),
                Name(id=&#x27;z&#x27;, ctx=Store())],
            value=Tuple(
                elts=[
                    Name(id=&#x27;V&#x27;, ctx=Load()),
                    Name(id=&#x27;VV&#x27;, ctx=Load())],
                ctx=Load()))],
    type_ignores=[])
&gt;&gt;&gt;

</code></pre>
<pre><code>‚ùØ i=&quot;z = V, z = z = V, zxV, = z = V, z = z = V, = z = V, VV,&quot;;\
  echo &quot;\nInput:\n $i&quot;;\
  ff=$(echo $i | ruff format -); echo &quot;\nFirst Format:\n$ff&quot;;\
  sf=$(echo $ff | ruff format -); echo &quot;\nSecond Format:\n$sf&quot;;


Input:
 z = V, z = z = V, zxV, = z = V, z = z = V, = z = V, VV,

First Format:
z = (
    V, z
) = (
    z
) = (
    (
        V,
        zxV,
    )
) = z = V, z = z = (V,) = z = (
    V,
    VV,
)

Second Format:
z = (V, z) = z = (
    V,
    zxV,
) = z = V, z = z = (V,) = z = (
    V,
    VV,
)

</code></pre>
<blockquote>
<p>However, fuzzers also discover issues that are very rare or close to non-existent in practice. That&#x27;s why reporting and fixing all of them isn&#x27;t necessary impactful for our users and is the reason why we prioritize real-world issues or new features over fuzzer issues (but this depends on the fuzzer issue).</p>
</blockquote>
<p>@MichaReiser Did you mean this type of report?</p>
<p>The input <code>z = V, z = z = V, zxV, = z = V, z = z = V, = z = V, VV,</code> passes fine through the Ruff parser, Python&#x27;s ast.parse(), and even works with py_compile, but it just throws an error at runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/addisoncrump">@addisoncrump</a> on 2024-01-03 01:00</div>
            <div class="timeline-body"><p>Was this ever added? Formatter idempotency has proven to be super useful for bug detection in other projects (see @jasikpark&#x27;s work with Prettier, my work with boa and Biome).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/addisoncrump">@addisoncrump</a> on 2024-01-03 11:53</div>
            <div class="timeline-body"><p>I slept on it; I actually think both this and a <a href="https://github.com/biomejs/biome/blob/main/fuzz/fuzz_targets/rome_common.rs#L61-L165">format validity fuzzer</a> which <a href="https://github.com/biomejs/biome/blob/main/fuzz/README.md#rome_format_">fuzzes to check that the formatter does not introduce linter errors</a> would be good to add.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/addisoncrump">@addisoncrump</a> on 2024-01-03 11:56</div>
            <div class="timeline-body"><p>@manunio: I think your fuzzer is a good start here, but the reformatting should never fail (instead should <code>panic!</code>) as we have a safety guarantee from the formatter to produce valid syntax. Do you want to open a PR? We can discuss further changes there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/manunio">@manunio</a> on 2024-01-03 13:06</div>
            <div class="timeline-body"><blockquote>
<p>@manunio: I think your fuzzer is a good start here, but the reformatting should never fail (instead should <code>panic!</code>) as we have a safety guarantee from the formatter to produce valid syntax. Do you want to open a PR? We can discuss further changes there.</p>
</blockquote>
<p>Hi @addisoncrump thanks for the feedback, I&#x27;ll open a pr here as soon as I have access to my system.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-01-08 08:23</div>
            <div class="timeline-body"><blockquote>
<p>I slept on it; I actually think both this and a <a href="https://github.com/biomejs/biome/blob/main/fuzz/fuzz_targets/rome_common.rs?rgh-link-date=2024-01-03T11%3A53%3A08Z#L61-L165">format validity fuzzer</a> which <a href="https://github.com/biomejs/biome/blob/main/fuzz/README.md?rgh-link-date=2024-01-03T11%3A53%3A08Z#rome_format_">fuzzes to check that the formatter does not introduce linter errors</a> would be good to add.</p>
</blockquote>
<p>This sounds interesting. Especially to discover incompatibilities that aren&#x27;t obvious. Although we may need to have a ignore list of rules that we know are not compatible.</p>
<blockquote>
<p>Was this ever added? Formatter idempotency has proven to be super useful for bug detection in other projects (see @jasikpark&#x27;s work with Prettier, my work with boa and Biome).</p>
</blockquote>
<p>Honestly, I&#x27;m not sure but I think it would be valuable to have.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/manunio">@manunio</a> on 2024-01-11 18:04</div>
            <div class="timeline-body"><p>Closing this now as <a href="https://github.com/astral-sh/ruff/pull/9448">astral-sh/ruff#9448</a> has been merged.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/manunio">@manunio</a> on 2024-01-11 18:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:48 UTC
    </footer>
</body>
</html>
