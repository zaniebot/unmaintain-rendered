```yaml
number: 4857
title: (ðŸŽ) New rule for suspect dict comprehension with static key
type: issue
state: closed
author: KotlinIsland
labels:
  - rule
assignees: []
created_at: 2023-06-05T05:28:14Z
updated_at: 2023-06-09T02:06:36Z
url: https://github.com/astral-sh/ruff/issues/4857
synced_at: 2026-01-10T01:56:47Z
```

# (ðŸŽ) New rule for suspect dict comprehension with static key

---

_Issue opened by @KotlinIsland on 2023-06-05 05:28_

I recently ran into some code where the developer was expecting a create a dict with a single key and a value created by a generator comprehension. Instead they ended up with a dict comprehension with a single entry for the value:
```py
data = ["some", "Data"]
out = {"key": value.upper() for value in data}
print(out)
```


Could a new inspection be added that detects the presence of a static key within a dict comprehension?

# Expected:
```py
data = ["some", "Data"]
out = {"key": value.upper() for value in data}  # error: Static value for key in dict comprehension.
print(out)
```

---

_Label `rule` added by @charliermarsh on 2023-06-05 15:52_

---

_Comment by @charliermarsh on 2023-06-05 15:52_

Looks reasonable to me.

---

_Comment by @Skylion007 on 2023-06-05 20:41_

This feels like it would be a good flake8-bugbear check. Consider suggesting it there https://github.com/PyCQA/flake8-bugbear/issues as well and then we will implement it when it's implemented there anyway.

---

_Comment by @KotlinIsland on 2023-06-05 22:50_

> This feels like it would be a good flake8-bugbear check. Consider suggesting it there https://github.com/PyCQA/flake8-bugbear/issues as well and then we will implement it when it's implemented there anyway.

Seems like a giant waste of effort? Why can't Ruff just do it's own thing and make it's own inspections?

---

_Comment by @Skylion007 on 2023-06-05 22:59_

@KotlinIsland Ruf does it have its own inspections (RUFF), but they are way less likely to be used since they have no grouping by category, intent, or are enabled by default.

Putting it under flake8-bugbear would mean they would be transparently added to the default list of rules as well as for any users who use bugbear. Also it would allow people who still only use flake8 for some reason to benefit for the check and improve the quality of code in the entire Python ecosystem. It also provides credibility through their use as popular plugins that already trusted by maintainers (like bugbear, flake8-comprehensions, etc).

---

_Comment by @charliermarsh on 2023-06-06 00:33_

So we can definitely add it to `RUF`. But we won't add it to the flake8-bugbear category unless it's implemented upstream (if we start deviating from the upstream rulesets in those kinds of re-implemented plugins, it makes it impossible to retain parity in the future). Adding it to the flake8-bugbear category has the advantage that more users have it enabled. But it doesn't have to stop us from implementing it, since we can add it to the Ruff-specific category.

To complete the picture... eventually, we will likely recategorize _all_ rules under semantically meaningful categories, rather than tying our categorization to other plugins. (And the thinking is that we'll provide automated tooling to migrate from this flake8-compatibility encoding to a Ruff-first encoding.) But this isn't being worked on right now, we're prioritizing some other stuff above it for now.


---

_Referenced in [astral-sh/ruff#4929](../../astral-sh/ruff/pulls/4929.md) on 2023-06-07 14:23_

---

_Closed by @charliermarsh on 2023-06-09 02:06_

---

_Referenced in [PyCQA/flake8-bugbear#391](../../PyCQA/flake8-bugbear/issues/391.md) on 2023-06-09 19:43_

---
