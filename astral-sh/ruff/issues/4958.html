<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[behavior-change] RUF010 delete unnecessary `str()` - astral-sh/ruff #4958</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[behavior-change] RUF010 delete unnecessary <code>str()</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/4958">#4958</a>
        opened by <a href="https://github.com/smackesey">@smackesey</a>
        on 2023-06-08 12:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/smackesey">@smackesey</a> on 2023-06-08 12:32</div>
            <div class="timeline-body"><p>IIUC, these two expressions are exactly equivalent:</p>
<pre><code>f&quot;{str(x)}&quot;  # (1)
f&quot;{x}&quot;  # (2)
</code></pre>
<p>The <code>str</code> is superfluous in (1). But instead of RUF010 removing the <code>str</code> call, instead it autofixes to <code>f&quot;{x!s}&quot;</code>-- but the <code>!s</code> here is still superfluous-- the only time it makes sense to use <code>!s</code> is if there is an additional format specifier, e.g. <code>f&quot;{x!s:20}&quot;</code> (in this case <code>str</code> is applied <em>before</em> the format specifier, whereas without <code>!s</code> it is applied after the format specifier).</p>
<p>So IMO RUF010 should remove <code>str()</code> unless there is a format specifier, in which case it converts to <code>!s</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @charliermarsh by @charliermarsh on 2023-06-08 17:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @charliermarsh on 2023-06-08 17:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-06-08 18:44</div>
            <div class="timeline-body"><p>@charliermarsh I can take this up unless you've already started working on it :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-08 18:44</div>
            <div class="timeline-body"><p>It’s ok, I’ve already started on it :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-06-08 20:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2023-06-20 20:36</div>
            <div class="timeline-body"><p>@charliermarsh @smackesey I believe this is wrong, and thus #4971 should be reverted. See below:</p>
<pre><code class="language-python">class Test:
    def __str__(self) -&gt; str:
        return &quot;str&quot;
    
    def __format__(self, __format_spec: str) -&gt; str:
        return &quot;format&quot;
    
print(f&quot;{Test()} {str(Test())} {Test()!s} {Test()!s:6} {Test():6}&quot;)
# gives: format       str         str         str         format
</code></pre>
<p>so, i.e. even the stdlib's StrEnum will not work correctly after such an auto &quot;fix&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-20 20:42</div>
            <div class="timeline-body"><p>(Taking a look.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-20 20:46</div>
            <div class="timeline-body"><p>Can you include an example to illustrate the behavior you're describing with <code>StrEnum</code>? In my testing, including or omitting <code>!s</code> yields the same result in that case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2023-06-20 21:22</div>
            <div class="timeline-body"><blockquote>
<p>Can you include an example to illustrate the behavior you're describing with <code>StrEnum</code>? In my testing, including or omitting <code>!s</code> yields the same result in that case.</p>
</blockquote>
<p>ah, sorry, my bad. I was using my &quot;polyfill&quot; in 3.10 which apparently doesn't match 3.11 stdlib exactly. Anyways, the <code>{value}</code> calls <code>value.format()</code>, so the check and fix that was implemented here is not correct.</p>
<p>Here is another example with enums in 3.11:</p>
<pre><code class="language-python">from enum import StrEnum, Enum


class Test(StrEnum):
    VALUE = &quot;value&quot;


class NonStrEnum(str, Enum):
    VALUE = &quot;value&quot;

    def __str__(self) -&gt; str:
        return str(self.value)

    def __format__(self, format_spec: str) -&gt; str:
        return repr(self)


print(f&quot;{Test.VALUE} {Test.VALUE!s}&quot;)  # prints &quot;value value&quot;
print(f&quot;{NonStrEnum.VALUE} {NonStrEnum.VALUE!s}&quot;)  # prints &quot;&lt;NonStrEnum.VALUE: 'value'&gt; value&quot;

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-20 21:31</div>
            <div class="timeline-body"><p>All good. Just to be totally clear, I'm not trying to &quot;disprove&quot; the claim here, I think you're right that these aren't equivalent (it looks like f-strings by default are calling <code>__format__</code>, and we're assuming they're calling <code>__str__</code>), I'm just trying to assess the blast radius :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2023-06-20 21:43</div>
            <div class="timeline-body"><p>sure, no problem. Sorry for confusion with StrEnum, it just happened to be something I was (re)implementing in one of my commercial projects in 3.10 that is impacted. Can't think of an easy way to estimate the impact here, probably not a lot of custom format functions out there. But my gut tells me that introducing silent non-100%-compatible changes is not what users of Ruff expect. Since Ruff (at least originally) was supposed to lint, not &quot;optimize&quot; code, at least I expect it to retain everything (just like black), without any possible side-effects.</p>
<p>Since Ruff is so fast and I bet 80%+ just have auto-fix for most of the rules, most won't even notice such a small &quot;benign&quot; change, which may hit at some point if custom formatting is applied... but ultimately it's your call.</p>
<p>I personally would have to make a mental notice to either wait for a release that reverts this or remember to disable auto-fix for this rule...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-20 23:12</div>
            <div class="timeline-body"><p>A couple quick comments (a little tight on time but want to keep this convo going, sorry for brevity):</p>
<ul>
<li>Python is so dynamic that it's hard for us to implement almost <em>any</em> fixes with complete, 100% certainty. Even reordering imports is not a completely &quot;safe&quot; operation, but I think most users would expect Ruff to support import sorting. So we have to draw various lines around what we're comfortable fixing and what we're not.</li>
<li>One way we're trying to improve this is by introducing autofix levels: automatic, suggested, and manual. Automatic would always be fixed, suggested would require <code>--fix-unsafe</code> (instead of <code>--fix</code>), and manual would never be autofixed. We've actually added these annotations to almost all of the fixes, but they're not yet respected on the CLI. (So, at the very least, using <code>--fix</code> would &quot;guarantee&quot; that we make no behavioral changes, or at least are very confident in the fixes.)</li>
<li>In practice this seems really rare...</li>
<li>But I actually agree that we should revert it, mostly because it will be hard to detect/notice when this <em>does</em> do the wrong thing (unlike, e.g., removing an unused import that's actually used in some capacity). Here, it's pretty likely that nothing would break at parse-time or at run-time or even in tests, which feels dangerous to me.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2023-06-21 00:20</div>
            <div class="timeline-body"><p>no worries, that’s actually a lot of great details, appreciate you taking the time.</p>
<ul>
<li>you’re totally right rgd dynamicity. Haven’t even thought about import order, but now as you’ve said it, I even know specific examples where order matters (basically with any packages that mingle with import machinery).</li>
<li>classifying fixes is an awesome approach. Hopefully it gets into a release sooner rather then later</li>
<li>In terms of impact and/or how to classify this a fix: something that may go unnoticed and at the same time is not a lot of value (like this issue) makes more sense under <code>—fix-unsafe</code>. Things like import sort that (a) not enabled by default in Ruff (b) probably will create an immediate failure in tests or downstream (c) add a lot of value (e.g. stable git diffs) - may be considered as regular <code>—fix</code>.</li>
<li>For this specific case - another justification here. I suspect if someone did add <code>!s</code> or <code>str()</code> inside f-expression, it may have been done because of unexpected <code>__format__</code> behavior. Most devs probably do not even think/know about <code>!s\r\a</code> modifiers, so wouldn’t use them unless they stumbled upon an issue.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2023-06-26 18:00</div>
            <div class="timeline-body"><p>Nice catch @mishamsk, I wasn't even aware <code>__format__</code> existed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2023-06-26 21:29</div>
            <div class="timeline-body"><p>@smackesey thanks!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:30:22 UTC
    </footer>
</body>
</html>
