<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[REQUEST] Package standalone `ruff` binary &amp; include in GitHub releases - astral-sh/ruff #2330</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[REQUEST] Package standalone <code>ruff</code> binary &amp; include in GitHub releases</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/2330">#2330</a>
        opened by <a href="https://github.com/rahul-theorem">@rahul-theorem</a>
        on 2023-01-29 23:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/rahul-theorem">@rahul-theorem</a></div>
            <div class="timeline-body"><p><strong>Context for the request</strong>
I just came across <code>ruff</code> and it looks like a very promising pyflakes/isort replacement. We use Bazel to manage a large Python monorepo, and this seems like it could help shorten some critical dev loops and lead to a perf improvement in CI.</p>
<p>However, given the way that ruff is packaged (ie. the main python entrypoint just shells out to the <code>ruff</code> binary under the hood), it doesn&#x27;t seem like we&#x27;ll be able to use <code>rules_python</code> + the <code>entry_point</code> macro from pip-parse to include ruff as a tool in our build (see <a href="https://github.com/bazelbuild/rules_python/issues/1000">bazelbuild/rules_python#1000</a> for more discussion)</p>
<p><strong>Request</strong>
OTOH, if ruff were available as a standalone binary (along w/ the source tgz/zip) as part of the GitHub release, we can pull this into our build w/ <code>http_archive</code>/set it up as an executable tool. This seems like it should be fairly straightforward to bake into the release process as a <a href="https://docs.github.com/en/rest/releases/assets">release asset</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rahul-theorem">@rahul-theorem</a> on 2023-01-29 23:44</div>
            <div class="timeline-body"><p>@charliermarsh I&#x27;d be happy to contribute this so we can run <code>ruff</code> as an aspect in our Bazel project if this is a contribution you&#x27;d be willing to accept.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-29 23:51</div>
            <div class="timeline-body"><p>@rahul-theorem - Yeah I&#x27;m happy to include the binaries in the GitHub release. My only hesitation is that right now, our release process only includes building the Python wheels (which themselves package the per-platform binaries), so it may require more work than merely adding the wheels to the release (unless that works too?).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rahul-theorem">@rahul-theorem</a> on 2023-01-29 23:54</div>
            <div class="timeline-body"><p>Thanks for the quick reply @charliermarsh!</p>
<p>I just took a look through <code>ruff.yaml</code> &amp; also saw the same; does the <code>maturin</code> action also have the ability to build a standalone binary, or will it only emit a wheel? If attaching the wheel to the GH release is the only thing that&#x27;s possible, then we can continue to use <code>rules_python</code> to download the wheel and hack around this bazel limitation in some other way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-29 23:59</div>
            <div class="timeline-body"><p><code>maturin build</code> should build the binary as a side-effect:</p>
<pre><code>&gt; rm target/debug/ruff
&gt; maturin build
&gt; ls target/debug/ruff
target/debug/ruff
</code></pre>
<p>(In release, that would be <code>target/release/ruff</code>, just using <code>debug</code> for expediency.)</p>
<p>So, without looking at the YAML deeply, I think it should be enough to just wire those built binaries up to the final GitHub release -- we&#x27;re already building them, and they exist in the filesystem after running <code>maturin</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rahul-theorem">@rahul-theorem</a> on 2023-01-30 00:01</div>
            <div class="timeline-body"><p>Ah nice. Happy to take a swing at this later today or tomorrow - from some basic testing (without running it as part of our build) it&#x27;s pretty mind-blowing how quickly it can lint our mono-repo!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-30 00:03</div>
            <div class="timeline-body"><p>That&#x27;s what I like to hear :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">release</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-30 00:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/messense">@messense</a> on 2023-01-30 03:08</div>
            <div class="timeline-body"><p>Note that we should name the artifact something like <code>ruff-&lt;rustc target name&gt;.tar.gz/zip</code>, for example <code>ruff-x86_64-unknown-linux-gnu.tar.gz</code>, so that <a href="https://github.com/cargo-bins/cargo-binstall">cargo-binstall</a> and <a href="https://github.com/taiki-e/install-action">taiki-e/install-action</a> will also be able to use them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rahul-theorem">@rahul-theorem</a> on 2023-01-30 15:42</div>
            <div class="timeline-body"><p>@messense is that something that <code>maturin</code> could handle during the <code>maturin build</code> step? Not quite familiar with how it names the compiled binary. See the linked PR, can incorporate your suggestions to name them correctly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/messense">@messense</a> on 2023-01-31 01:40</div>
            <div class="timeline-body"><blockquote>
<p>is that something that <code>maturin</code> could handle during the <code>maturin build</code> step?</p>
</blockquote>
<p>No, maturin is for building python wheels so I don&#x27;t think this is suitable to include in it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-03 20:57</div>
            <div class="timeline-body"><p><a href="https://blog.axo.dev/2023/02/cargo-dist"><code>cargo dist</code></a> would be interesting for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-11 03:13</div>
            <div class="timeline-body"><p>My current thinking is that we&#x27;ll just copy <a href="https://github.com/BurntSushi/ripgrep/blob/master/.github/workflows/release.yml">ripgrep&#x27;s release workflow</a>, except instead of creating the GitHub Release, we&#x27;ll trigger the workflow by the creation of a GitHub Release.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-15 17:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lopopolo">@lopopolo</a> on 2023-05-10 22:17</div>
            <div class="timeline-body"><p>@rahul-theorem I&#x27;m intrigued by the ruff aspect you mentioned for your Python Bazel project. Is this setup something you could share? I&#x27;d like to do the same.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jwnimmer-tri">@jwnimmer-tri</a> on 2025-10-23 19:22</div>
            <div class="timeline-body"><p>FYI on a related topic, I have recently published <code>ruff</code> binaries to the Bazel Central Registry:</p>
<ul>
<li>https://registry.bazel.build/modules/ruff_prebuilt</li>
<li>https://github.com/astral-sh/ruff/discussions/20672</li>
</ul>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:31 UTC
    </footer>
</body>
</html>
