<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[SIM401] Produces false-positive when the `else` value is not constant - astral-sh/ruff #8390</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[SIM401] Produces false-positive when the <code>else</code> value is not constant</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/8390">#8390</a>
        opened by <a href="https://github.com/sshishov">@sshishov</a>
        on 2023-10-31 20:07
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sshishov">@sshishov</a></div>
            <div class="timeline-body"><p>The easy example to reproduce:</p>
<pre><code>value = mydict[&#x27;attr&#x27;] if &#x27;attr&#x27; in mydict else instance.some_value
</code></pre>
<p>the rule is saying to transform it to dict&#x27;s <code>get()</code></p>
<pre><code>value = mydict.get(&#x27;attr&#x27;, instance.some_value)
</code></pre>
<p>The second example produces <code>AttributeError</code> even if <code>attr</code> is inside dict.
The problem is dict&#x27;s default value is evaluated always when the ternary&#x27;s <code>...if...else...</code> else block is executed only if the condition is falsy.</p>
<p>The same issue is applied if expensive computation is done in <code>else</code> block, or some other logic which is not plain constant.</p>
<p>Similar issue on &quot;parent&quot; repo: <a href="https://github.com/MartinThoma/flake8-simplify/issues/177">MartinThoma/flake8-simplify#177</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-31 21:42</div>
            <div class="timeline-body"><p>We do avoid flagging <code>SIM401</code> is the <code>else</code> value has a side effect -- for example, if it&#x27;s a function call, we don&#x27;t flag <code>SIM401</code>:</p>
<pre><code>value = mydict[&#x27;attr&#x27;] if &#x27;attr&#x27; in mydict else instance.some_value()
</code></pre>
<p>But we don&#x27;t consider attribute accesses to be effectful... They <em>are</em>, but they&#x27;re almost always fine, and it&#x27;s kind of a tradeoff with regards to how conservative we want to be.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-31 21:42</div>
            <div class="timeline-body"><p>I think this is okay because it&#x27;s already marked as an unsafe edit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-01 03:54</div>
            <div class="timeline-body"><p>I agree with Charlie, attribute access is <em>sometimes</em> expensive in Python but I would highly recommend not writing code with expensive attribute access (i.e. properties that do significant computation).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-11-01 04:06</div>
            <div class="timeline-body"><p>FWIW, using cached property is somewhat common if the computation is expensive. Either using the <code>@functools.cached_property</code> or <code>self._cached_value: T | None</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sshishov">@sshishov</a> on 2023-11-01 08:40</div>
            <div class="timeline-body"><p>That is okay for us, guys.
We will just mark it <code># noqa: SIM401</code> if the resolution is to ignore / be okay with this.</p>
<p>I was just flagging that the suggestion is not always correct and can produce false positive.
In my original case let&#x27;s assume the following:</p>
<ul>
<li><code>mydict</code> does have <code>attr</code> key</li>
<li><code>instance</code> does not have <code>some_attr</code> attribute/property</li>
</ul>
<pre><code>1. value = mydict[&#x27;attr&#x27;] if &#x27;attr&#x27; in mydict else instance.some_attr
2. value = mydict.get(&#x27;attr&#x27;, instance.some_attr)
</code></pre>
<p>In this situation 1st example will not cause any problems and work without errors, The 2nd example will crash with AttributeError. And therefore you have to ignore this <code>SIM401</code> rule. That is why I recommed to apply this SIM401 only for <code>constant</code> types</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-11-01 13:27</div>
            <div class="timeline-body"><p>Totally understand. There&#x27;s a tradeoff to make... Right now I feel like flagging attributes is correct, but we&#x27;ll definitely revisit that decision if we see more of these issues in the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-11-01 13:27</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:45 UTC
    </footer>
</body>
</html>
