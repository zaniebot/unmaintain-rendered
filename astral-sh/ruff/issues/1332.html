<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[feature-request] enhanced first-party detection - astral-sh/ruff #1332</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[feature-request] enhanced first-party detection</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/1332">#1332</a>
        opened by <a href="https://github.com/smackesey">@smackesey</a>
        on 2022-12-22 11:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/smackesey">@smackesey</a> on 2022-12-22 11:55</div>
            <div class="timeline-body"><p>Probably the most common use-case for marking a package as a &quot;known first party&quot; import is when you have an associated test package. In the world of <code>pytest</code>, the associated test package is typically called <code>&lt;TARGET_PKG&gt;_tests</code>. It would be cool if auto-first-party detection was smart enough to understand this.</p>
<p>For example:</p>
<pre><code>### foo_tests/test_foo.py

from foo import bar  # this import should be first-party because it's from `foo`
</code></pre>
<p>This could be implemented by a <code>tool.ruff.isort</code> option called something like <code>first-party-grouping-suffixes</code> (certainly not wedded to the name). The idea would be that any package matching a suffix is treated identically to its &quot;stem&quot; for purposes of first-party grouping. So:</p>
<pre><code>[tool.ruff.isort]

# This causes any package matching &quot;&lt;STEM&gt;_tests&quot; to be treated identically to &quot;&lt;STEM&gt;&quot; for the purposes of first-party grouping.
first-party-grouping-suffixes = [&quot;_tests&quot;]
</code></pre>
<p>IMO <code>[&quot;_tests&quot;]</code> would be a reasonable default for this option. There might also be other suffixes to include used by other test frameworks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @charliermarsh on 2022-12-23 03:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andersk">@andersk</a> on 2022-12-26 01:48</div>
            <div class="timeline-body"><p><code>foo</code> is detected as first-party anyway as long as it exists in one of the paths in <a href="https://github.com/charliermarsh/ruff#src"><code>src</code></a> (defaults to <code>[&quot;.&quot;]</code>, for the typical case where <code>foo</code> is in the same directory as <code>pyproject.toml</code>). Is that not sufficient? It seems better for this classification to rely on facts than heuristics.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2022-12-26 13:35</div>
            <div class="timeline-body"><p>Hi @andersk, we disagree here.</p>
<blockquote>
<p>foo is detected as first-party anyway as long as it exists in one of the paths in <a href="https://github.com/charliermarsh/ruff#src">src</a></p>
</blockquote>
<p>Unless something changed very recently, this is only true if the package is a direct child of one of the paths on src.</p>
<blockquote>
<p>the typical case where foo is in the same directory as pyproject.toml</p>
</blockquote>
<p>While this might be typical, it is not necessarily the most common design for large projects using monorepos. I work on the large monorepo <a href="https://github.com/dagster-io/dagster">Dagster</a>. Our python packages are not siblings of <code>pyproject.toml</code>.</p>
<blockquote>
<p>It seems better for this classification to rely on facts than heuristics.</p>
</blockquote>
<p>There's nothing ambiguous about a setting that tells ruff to classify packages as first-party depending on a suffix.</p>
<p>Also, I think by your definition Ruff is already using a heuristic that works 99% of the time for first-party detection (i.e. for non-namespace packages), which is to trace <code>__init__.py</code> files up the directory hierarchy to identify the root package for a module, and match against this root package to determine first-party status. The feature requested here is an addition to that functionality.</p>
<p>FWIW, I requested that functionality specifically to support situations where there are many python packages in a monorepo but one doesn't want to add a <code>pyproject.toml</code> for each one. I can understand an argument in favor of requiring explicit config here, but that is just a philosophical difference-- in the vast majority of cases, if I have <code>foo_tests</code> next to <code>foo</code>, <code>foo</code> should be first-party in <code>foo_tests</code>. It makes sense to achieve this with minimal configuration using a clear rule, given that first-party auto-detection already happens.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andersk">@andersk</a> on 2022-12-26 19:27</div>
            <div class="timeline-body"><p>My goal here isn’t to agree or disagree, just to figure out whether the existing mechanisms are sufficient and where they fall short.</p>
<p>Looking at your monorepo, it seems to me that you should be able to configure</p>
<pre><code class="language-toml">[tool.ruff]
src = [
    &quot;docs/dagit-screenshot&quot;,
    &quot;examples/*&quot;,
    &quot;helm/dagster/schema&quot;,
    &quot;integration_tests/python_modules/*&quot;,
    &quot;python_modules/*&quot;,
    &quot;python_modules/libraries/*&quot;,
]
</code></pre>
<p>which seems manageable?</p>
<p>Meanwhile, your proposed <code>_tests</code> heuristic would fail to capture that <code>foo</code> should also be first-party within <em>itself</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2022-12-27 21:31</div>
            <div class="timeline-body"><p>The <code>src</code> config you posted would have the effect of making all packages captured by <code>src</code> first-party in every other package, which I'm trying to avoid-- only <code>foo</code> should be first-party inside of <code>foo</code>.</p>
<blockquote>
<p>Meanwhile, your proposed _tests heuristic would fail to capture that foo should also be first-party within itself.</p>
</blockquote>
<p>See my previous comment-- ruff already detects <code>foo</code> is first-party within itself:</p>
<blockquote>
<p>I think by your definition Ruff is already using a heuristic that works 99% of the time for first-party detection (i.e. for non-namespace packages), which is to trace <strong>init</strong>.py files up the directory hierarchy to identify the root package for a module, and match against this root package to determine first-party status. The feature requested here is an addition to that functionality.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andersk">@andersk</a> on 2022-12-27 21:53</div>
            <div class="timeline-body"><p>Ah, my apologies for misreading—I hadn’t noticed that update (#1266).</p>
<p>It seems to me that if we’re going to trace up the <code>__init__.py</code> chain to find <code>project-root/foo</code>, then we might as well detect <code>project-root/*.py</code> and <code>project-root/*/__init__.py</code> as first-party, not just <code>project-root/foo</code> itself. That would solve your issue, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> removed by @charliermarsh on 2022-12-31 18:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by @charliermarsh on 2022-12-31 18:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/condemil">@condemil</a> on 2023-03-02 06:29</div>
            <div class="timeline-body"><p>I have a similar problem with bazel monorepo setup, where <code>pyproject.toml</code> file is located in the root of the monorepo. I don't have <code>__init__.py</code> files, but project root could be identified by <code>BUILD</code> or <code>BUILD.bazel</code> files. Probably the solution could be a configuration variable in <code>pyproject.toml</code> that allows to specify filenames that marks project root?</p>
<p>Example (variable name could be better):</p>
<pre><code class="language-toml">[tool.ruff]
root-file = [&quot;BUILD&quot;, &quot;BUILD.bazel&quot;]
</code></pre>
<p>Example structure:</p>
<pre><code>.
├── app
│   └── project1
│       └── backend
│           ├── BUILD.bazel
│           └── main.py
├── lib
│   └── util
│       ├── BUILD.bazel
│       └── log.py
└── pyproject.toml
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-02 16:10</div>
            <div class="timeline-body"><p>@condemil - Oh yeah that's an interesting use-case. Is it possible to solve with <code>src</code>, and wildcarding? Like:</p>
<pre><code>[tool.ruff]
src = [
  &quot;app/*&quot;,
  &quot;lib/*&quot;,
]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/condemil">@condemil</a> on 2023-03-02 16:56</div>
            <div class="timeline-body"><p>Unfortunately, the solution you mentioned isn't working. I don't know the exact reason, but I may guess it is because of the following:</p>
<ol>
<li>The <code>&quot;app/*&quot;</code> wildcard doesn't support folding, and in monorepo the project could be under <code>app/project1/subproject</code>. Folding could be solved by introducing some wildcard pattern like <code>&quot;app/**/*&quot;</code>.</li>
<li>When projects is specified under <code>src</code>, all of those is threated as a first-party imports for each other instead of being threated as a third-party imports.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-02 17:05</div>
            <div class="timeline-body"><p>Ah yeah that makes sense -- I didn't realize that you wanted each package to consider each other package as third-party (which is reasonable but not always the case for monorepos). Lemme try a few things out before I make any other suggestions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">isort</span> added by @charliermarsh on 2023-08-03 19:56</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:28:39 UTC
    </footer>
</body>
</html>
