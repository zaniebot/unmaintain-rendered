<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Autofix for flake8-logging-format (G) rules - astral-sh/ruff #15555</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Autofix for flake8-logging-format (G) rules</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/15555">#15555</a>
        opened by <a href="https://github.com/justinchuby">@justinchuby</a>
        on 2025-01-17 17:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/justinchuby">@justinchuby</a></div>
            <div class="timeline-body"><p>Hi! I was wondering if there are any plans to create autofix for (G) rules? We have a lot of violations that prevents enabling the rule. Having autofix capabilities (even if unsafe) would greatly help with adoption of the (G) rules in our codebase.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-17 17:48</div>
            <div class="timeline-body"><p>Are you looking for a specific rule or is it really all rules? The format fixes tend to be rather difficult to implement because of all the edge cases and adding more fixes isn&#x27;t a priority for us right now (not saying that it wouldn&#x27;t be great to have them, it&#x27;s just there are so many other improvements)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fixes</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-17 17:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/justinchuby">@justinchuby</a> on 2025-01-17 17:51</div>
            <div class="timeline-body"><p>The current rule we need the most in microsoft/onnxruntime is G004. Because everything else can be turned into an f-string first.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-01-24 18:39</div>
            <div class="timeline-body"><p>I will second really only needing an autofix for G004.</p>
<p>~~G001 looks trivial as both logging methods and <code>str.format</code> use <code>string.Formatter</code>.
G002 could involve transforming to <code>str.format</code> first, then trivially converting to the logging call.~~
EDIT: actually it&#x27;s slightly different. And of course keyword arguments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bmos">@bmos</a> on 2025-02-27 03:41</div>
            <div class="timeline-body"><p>If we&#x27;re just talking about G004, it seems like it should be pretty easy to copy the fix for EM102 with small changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-02-27 23:44</div>
            <div class="timeline-body"><blockquote>
<p>If we&#x27;re just talking about G004, it seems like it should be pretty easy to copy the fix for EM102 with small changes.</p>
</blockquote>
<p>I thought the same thing when I looked into this a few weeks ago, but the point of G004 is not simply to move the f-string out of the <code>logging</code> call, it&#x27;s to avoid formatting the string at all when the log level is set high enough. See this part of the rule docs in particular:</p>
<blockquote>
<p>Using f-strings to format a logging message requires that Python eagerly format the string, even if the logging statement is never executed (e.g., if the log level is above the level of the logging statement), whereas using the extra keyword argument defers formatting until required.</p>
</blockquote>
<p>Moving the f-string out of the <code>logging</code> call like in EM102 just eagerly formats the string a little earlier.</p>
<p>Properly fixing G004 requires inspecting the contents of the f-string and converting them to the appropriate <code>logging</code> method call with printf-style arguments and placeholders, at least as far as I can tell.</p>
<p>Now, if you simply want to defeat the rule, moving the f-string out of the <code>logging</code> call <em>does</em> help because the rule doesn&#x27;t do any type inference on its argument. It only checks for literal f-strings and other formatting calls. But at that point you might as well <code>noqa</code> or ignore the rule entirely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-02-28 02:43</div>
            <div class="timeline-body"><p>So what I&#x27;m hearing is that this is a valid fix?</p>
<pre><code>if self.log.isEnabledFor(logging.DEBUG):
    self.log.debug(f&quot;{name=}&quot;)
</code></pre>
<p>/s</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/justinchuby">@justinchuby</a> on 2025-02-28 03:42</div>
            <div class="timeline-body"><p>Is it possible to just use <code>%s</code> as placeholders? (unless if there are format specifier, but should still be straightforward)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-02-28 18:11</div>
            <div class="timeline-body"><blockquote>
<p>Is it possible to just use <code>%s</code> as placeholders? (unless if there are format specifier, but should still be straightforward)</p>
</blockquote>
<p>Hmm, that&#x27;s a good point. The logging module eventually just calls <code>format_string % args</code> <a href="https://github.com/python/cpython/blob/ab11c097052757b79060c75dd4835c2431e752b7/Lib/logging/__init__.py#L468">here</a>, and without format specifiers, the f-string and <code>format</code> docs say:</p>
<blockquote>
<p>A general convention is that an empty format specification produces the same result as if you had called <a href="https://docs.python.org/3/library/stdtypes.html#str">str()</a> on the value.</p>
</blockquote>
<p>That also sounds equivalent to the entry in the <a href="https://docs.python.org/3/library/stdtypes.html#old-string-formatting">old string formatting</a> table:</p>
<blockquote>
<p>| Conversion | Meaning |Notes |
| --|--|--|
| &#x27;s&#x27;  | String (converts any Python object using <a href="https://docs.python.org/3/library/stdtypes.html#str">str()</a>). | (5) |</p>
</blockquote>
<p>So yeah, based on my reading of those docs, <code>&quot;%s other contents&quot;, arg</code> should be a suitable (unsafe) fix for <code>f&quot;{arg} other contents&quot;</code>, which might be the most common case anyway?</p>
<p>Maybe I will take another look at this! I&#x27;d really like to offer a fix here, at least for simple cases.</p>
<p>Contributions would be welcome here too, of course. I&#x27;m not sure how soon I could work on it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-02-28 19:40</div>
            <div class="timeline-body"><p>And <code>f&quot;{thing!r}</code> is equivalent to calling <code>repr()</code> and <code>f&quot;{thing=}&quot;</code> is equivalent to <code>&quot;thing=%s&quot;, thing</code>. There&#x27;s a bunch of low hanging fruit, it&#x27;s just when it gets into things like left justification, pad character, etc. does the whole string formatting thing get hairy. But starting with the default formatting and <code>!r</code> specifier would hit 95+% of the 5k+ errors I have.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aristidebm">@aristidebm</a> on 2025-06-20 01:41</div>
            <div class="timeline-body"><p>In the mean time I have implemented an autofix like feature for <a href="https://docs.astral.sh/ruff/rules/logging-f-string/">G004</a>  with ast-grep transformation rules https://ast-grep.github.io/reference/yaml/rewriter.html#transform, you may find it useful, it is not prefect but it works for my use case.</p>
<pre><code>id: no-fstring-in-logging
language: python
rule:
  any:
    - pattern: $LOGGER.$METHOD($IDENTS)
    - pattern: $LOGGER.$METHOD($IDENTS, $$$KWARGS)
constraints:
  METHOD:
    regex: ^(trace|debug|info|warning|warn|error|log)$
  LOGGER:
    any:
      - kind: identifier
      - kind: attribute
  IDENTS:
    regex: &#x27;f&quot;[^&quot;]*&quot;&#x27;
rewriters:
- id: rewrite-identifier
  rule:
    pattern: $VAR
    any:
      - kind: identifier
      - kind: attribute
  fix: $VAR
transform:
  ARGS:
    rewrite:
      rewriters: [rewrite-identifier]
      source: $IDENTS
      joinBy: &quot;, &quot;
  MESSAGE:
    replace:
      source: $IDENTS
      replace: &#x27;f&quot;([^&quot;]*)&quot;&#x27;
      by: &#x27;&quot;$1&quot;&#x27;
  FINAL_MESSAGE:
    replace:
      source: $MESSAGE
      replace: &#x27;\{[^}]+\}&#x27;
      by: &#x27;%s&#x27;
fix: $LOGGER.$METHOD($FINAL_MESSAGE, $ARGS, $$$KWARGS)
</code></pre>
<p>just run the following command, assuming you have stored the rule above in  <code>/path/to/rules.yml</code></p>
<pre><code>$AST_GREP_COMMAND scan --interactive --rule /path/to/rules.yml
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-06-20 15:16</div>
            <div class="timeline-body"><p>I had hoped that t-strings would save us a lot here, but they don&#x27;t do lazy evaluation anymore.</p>
<p>Maybe it&#x27;s best to just do explicit lazy evaluation in the cases it matters and accept the lower performance.</p>
<pre><code>class LazyLog:
    def __init__(self, func: Callable[[], object]) -&gt; None:
        self.func = func
    def __format__(self, fmt: str) -&gt; str:
        val = self.func()
        return val.__format__(fmt)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spaceone">@spaceone</a> on 2025-09-10 21:15</div>
            <div class="timeline-body"><p>When autofix for this rule would be available, a lot of time would be saved.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-09-10 23:01</div>
            <div class="timeline-body"><p>There is now a <a href="https://github.com/astral-sh/ruff/pull/19303">preview autofix</a> for simple cases of G004 if you want to try it out! As of Ruff 0.12.11, ~2 weeks ago</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spaceone">@spaceone</a> on 2025-09-10 23:10</div>
            <div class="timeline-body"><p>I already used G004 fixer from 0.12.11, but it did not fix much cases (4 of several hundreds):</p>
<p>I now started with the approach of @aristidebm and took:
<code>ast-grep scan  --rule log.yaml  -U</code> plus <code>ruff check --select COM819,E202 --fix </code></p>
<pre><code>id: no-fstring-in-logging
language: python
rule:
  any:
    - pattern: $LOGGER.$METHOD($IDENTS)
    - pattern: $LOGGER.$METHOD($IDENTS, $$$KWARGS)
constraints:
  METHOD:
    regex: ^(trace|debug|info|process|warning|warn|error|log|exception)$
  LOGGER:
    any:
      - kind: identifier
      - kind: attribute
  IDENTS:
    regex: &quot;f([&#x27;\&quot;]).*?[&#x27;\&quot;]&quot;
rewriters:
- id: rewrite-identifier
  rule:
    pattern: $VAR
    any:
      - kind: identifier
      - kind: attribute
  fix: $VAR
transform:
  ARGS:
    rewrite:
      rewriters: [rewrite-identifier]
      source: $IDENTS
      joinBy: &quot;, &quot;
  MESSAGE:
    replace:
      source: $IDENTS
      replace: &quot;f([&#x27;\&quot;])(.*)[&#x27;\&quot;]&quot;
      by: &#x27;&quot;$2&quot;&#x27;
  MESSAGE_R:
    replace:
      source: $MESSAGE
      replace: &quot;\\{([^}]+)!r\\}&quot;
      by: &quot;%r&quot;
  FINAL_MESSAGE:
    replace:
      source: $MESSAGE_R
      replace: &quot;\\{[^}]+\\}&quot;
      by: &quot;%s&quot;
fix: $LOGGER.$METHOD($FINAL_MESSAGE, $ARGS, $$$KWARGS)
</code></pre>
<pre><code>id: no-format-in-logging
language: python
rule:
  any:
    - pattern: $LOGGER.$METHOD($MESSAGE.format($$$ARGS))
    - pattern: $LOGGER.$METHOD($MESSAGE.format($$$ARGS), $$$KWARGS)
constraints:
  METHOD:
    regex: ^(trace|debug|info|process|warning|warn|error|log|exception)$
  LOGGER:
    any:
      - kind: identifier
      - kind: attribute
  MESSAGE:
    kind: string
rewriters:
- id: rewrite-arg
  rule:
    pattern: $VAR
    any:
      - kind: identifier
      - kind: attribute
      - kind: subscript
      - kind: call
  fix: $VAR
transform:
  ARGS_REWRITTEN:
    rewrite:
      rewriters: [rewrite-arg]
      source: $$$ARGS
      joinBy: &quot;, &quot;
  MESSAGE_R:
    replace:
      source: $MESSAGE
      replace: &quot;\\{([^}]*)!r\\}&quot;
      by: &quot;%r&quot;
  MESSAGE_S:
    replace:
      source: $MESSAGE_R
      replace: &quot;\\{([^}]*)!s\\}&quot;
      by: &quot;%s&quot;
  MESSAGE_A:
    replace:
      source: $MESSAGE_S
      replace: &quot;\\{([^}]*)!a\\}&quot;
      by: &quot;%a&quot;
  FINAL_MESSAGE:
    replace:
      source: $MESSAGE_A
      replace: &quot;\\{[^}]*\\}&quot;
      by: &quot;%s&quot;
fix: $LOGGER.$METHOD($FINAL_MESSAGE, $ARGS_REWRITTEN, $$$KWARGS)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-09-11 13:23</div>
            <div class="timeline-body"><p>Ah interesting! Do you know which kinds of f-strings the autofix didn&#x27;t fix? Based on the ast-grep rule, it looks like ones with <code>!r</code>, <code>!s</code>, and <code>!a</code> format directives? I suggested only handling the simplest <code>{var}</code> -&gt; <code>%s</code> cases in the first PR (I assumed that would be most common), but these should be straightforward to handle too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-09-11 19:31</div>
            <div class="timeline-body"><p>It seems to not handle anything that isnt a simple name lookup as well.</p>
<p>Interesting that the one thing that was implemented is not even technically correct. <code>%s</code> is not equivalent to passing <code>None</code> to <code>__format__</code> except by convention.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-09-11 19:44</div>
            <div class="timeline-body"><p>That is interesting, thanks for pointing that out. I guess we should make the fix unsafe in this case, if there&#x27;s no precise equivalent. Only a case like <code>{var!s}</code> would technically be safe to convert to <code>%s</code>, if I understand correctly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spaceone">@spaceone</a> on 2025-09-16 16:23</div>
            <div class="timeline-body"><blockquote>
<p>Ah interesting! Do you know which kinds of f-strings the autofix didn&#x27;t fix?</p>
</blockquote>
<p>Yes, we often use <code>!r</code> for logging user input.
I did a workaround, we actually have everything as <code>%</code>-formatter (so we actually need <code>G002</code> more than <code>G004</code>).  So I used the pyupgrade UP rules, to convert them to f-strings and <code>.format()</code>-strings. And then applied the G004 fixer / that ast-rewrite-workaround-with-many-bugs.</p>
<p>We have:</p>
<pre><code># noqa: CPY001
import logging
log = logging.getLogger()
foo = bar = &#x27;foo&#x27;
baz = (foo, bar)
log.info(&#x27;foo %s&#x27; % foo)
log.info(&#x27;foo %s&#x27; % (foo,))
log.info(&#x27;foo %s %s&#x27; % (foo, bar))
log.info(&#x27;foo %s %%s&#x27; % foo, bar)  # caution!
log.info(&#x27;foo %s %s&#x27; % baz)  # caution!
log.info(&#x27;foo %r&#x27; % foo)
log.info(&#x27;foo %r&#x27; % (foo,))
log.info(&#x27;foo %r %r&#x27; % (foo, bar))
log.info(&#x27;foo %d&#x27; % len(foo))
log.info(&#x27;foo %d&#x27; % (len(foo),))
log.info(&#x27;foo %d %d&#x27; % (len(foo), len(bar)))
log.info(&#x27;foo %0.3f&#x27; % len(foo))
log.info(&#x27;foo %0.3f&#x27; % (len(foo),))
log.info(&#x27;foo %0.3f %0.3f&#x27; % (len(foo), len(bar)))
log.info(f&#x27;foo {foo}&#x27;)
log.info(f&#x27;foo {foo} {bar}&#x27;)
log.info(f&#x27;foo {foo!r}&#x27;)
log.info(f&#x27;foo {foo!r} {bar!r}&#x27;)
log.info(f&#x27;foo {len(foo):0.3f}&#x27;)
log.info(f&#x27;foo {len(foo):0.3f}&#x27;)
log.info(f&#x27;foo {len(foo):0.3f} {len(bar):0.3f}&#x27;)
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:49:19 UTC
    </footer>
</body>
</html>
