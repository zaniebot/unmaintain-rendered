```yaml
number: 16490
title: TC004 diagnostics/docs should clarify that type hints can be executed at run-time
type: issue
state: open
author: nathanjmcdougall
labels:
  - help wanted
  - diagnostics
assignees: []
created_at: 2025-03-04T08:30:54Z
updated_at: 2025-12-31T07:55:51Z
url: https://github.com/astral-sh/ruff/issues/16490
synced_at: 2026-01-10T01:56:55Z
```

# TC004 diagnostics/docs should clarify that type hints can be executed at run-time

---

_Issue opened by @nathanjmcdougall on 2025-03-04 08:30_

### Summary

For me, `TC004` fairly consistently gives false positives when the guarded import is used for return types.

For example:

```
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import abc


def bar() -> abc.ABC | None:
    return None
```

Running ` ruff check --isolated --select TC004` gives the following output:

```
main.py:4:12: TC004 Move import `abc` out of type-checking block. Import is used for more than type hinting.
  |
3 | if TYPE_CHECKING:
4 |     import abc
  |            ^^^ TC004
  |
  = help: Move out of type-checking block

Found 1 error.
No fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option).
```


### Version

ruff 0.9.9 (091d0af2a 2025-02-28)

---

_Comment by @MichaReiser on 2025-03-04 09:37_

This looks correct to me because you aren't using `from __future__ import annotations`

From the `from __future__ import annotations` [PEP](https://peps.python.org/pep-0563/)

> type hints are executed at module import time, which is not computationally free.

You can also reproduce this by copying your code snippet into a REPL

```py
>>> from typing import TYPE_CHECKING
...
... if TYPE_CHECKING:
...     import abc
...
...
... def bar() -> abc.ABC | None:
...     return None
...
Traceback (most recent call last):
  File "<python-input-6>", line 7, in <module>
    def bar() -> abc.ABC | None:
                 ^^^
NameError: name 'abc' is not defined. Did you mean: 'abs'? Or did you forget to import 'abc'?
```

However, I do think that the diagnostic could be more helpful or we should at least clarify this case in the rule's documentation

---

_Label `help wanted` added by @MichaReiser on 2025-03-04 09:37_

---

_Label `diagnostics` added by @MichaReiser on 2025-03-04 09:37_

---

_Renamed from "TC004 False Positive in return type" to "TC004 diagnositics/docs should clarify that type hints can be executed at run-time" by @nathanjmcdougall on 2025-03-04 11:03_

---

_Renamed from "TC004 diagnositics/docs should clarify that type hints can be executed at run-time" to "TC004 diagnostics/docs should clarify that type hints can be executed at run-time" by @AlexWaygood on 2025-03-04 11:37_

---

_Comment by @sebastiancruzg on 2025-06-13 16:46_

Is it necessary to add `from __future__ import annotations` even if working on Python 3.12?

---

_Comment by @nathanjmcdougall on 2025-06-13 23:00_

It is necessary if you want deferred evaluation of annotations. [It is planned that in Python 3.14](https://docs.python.org/3.14/whatsnew/3.14.html#pep-649-and-749-deferred-evaluation-of-annotations), this will become the default behaviour.

---

_Referenced in [sagemath/sage#40897](../../sagemath/sage/pulls/40897.md) on 2025-09-29 18:09_

---

_Comment by @spaceone on 2025-10-16 14:53_

But that would be optional. I think `TC004`, etc should evaluate [target-version](https://docs.astral.sh/ruff/settings/#target-version) to detect if `from __future__ import annotations` is required to be in there.

---

_Comment by @MichaReiser on 2025-10-20 07:38_

@spaceone Right, this is now optional when targeting Python 3.14 (CC: @dylwil3)

---

_Comment by @dylwil3 on 2025-10-20 14:39_

> I think TC004, etc should evaluate [target-version](https://docs.astral.sh/ruff/settings/#target-version) to detect if from __future__ import annotations is required to be in there.

Yes, this already happens implicitly because of the way our semantic model interprets type hints when the `target-version` is 3.14+.

```console
❯ cat tc004.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import abc


def bar() -> abc.ABC | None:
    return None

❯ ruff check --no-cache --isolated --select TC004 --target-version py313 tc004.py
TC004 Move import `abc` out of type-checking block. Import is used for more than type hinting.
 --> tc004.py:4:12
  |
3 | if TYPE_CHECKING:
4 |     import abc
  |            ^^^
  |
help: Move out of type-checking block

Found 1 error.
No fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option).

❯ ruff check --no-cache --isolated --select TC004 --target-version py314 tc004.py
All checks passed!
```

---

_Comment by @ntBre on 2025-12-30 19:25_

I came across this issue today and couldn't resist prototyping a diagnostic with a secondary annotation. Here's what I came up with (without modifying the original message):

```
TC004 [*] Move import `datetime` out of type-checking block. Import is used for more than type hinting.
  --> app.py:9:12
   |
 8 | if TYPE_CHECKING:
 9 |     import datetime  # TC004
   |            ^^^^^^^^
10 |     from array import array  # TC004
   |
  ::: app.py:20:25
   |
19 | @app.put("/datetime")
20 | def set_datetime(value: datetime.datetime):
   |                         -------- This use is required at runtime
21 |     pass
   |
help: Move out of type-checking block
```

This seems like a good use for a secondary annotation or a sub-diagnostic since the import and use are likely to be far apart. I don't think that fully resolves the issue, but it might help a little.

Storing this information in `ImportBinding` doesn't necessarily feel like the best approach, but here's the diff I threw together in case we want to pursue this in the future.

<details><summary>Details</summary>
<p>

```diff
diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs b/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs
index 2f4abad7d2..2cc606855f 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs
@@ -1,4 +1,4 @@
-use ruff_python_semantic::{AnyImport, Binding, ResolvedReferenceId};
+use ruff_python_semantic::{AnyImport, Binding, ResolvedReference, ResolvedReferenceId};
 use ruff_text_size::{Ranged, TextRange};
 
 /// An import with its surrounding context.
@@ -15,6 +15,7 @@ pub(crate) struct ImportBinding<'a> {
     pub(crate) parent_range: Option<TextRange>,
     /// Whether the binding needs `from __future__ import annotations` to be imported.
     pub(crate) needs_future_import: bool,
+    pub(crate) runtime_reference: Option<&'a ResolvedReference>,
 }
 
 impl Ranged for ImportBinding<'_> {
diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs b/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs
index e96b3b7bc6..010a3c4eeb 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs
@@ -123,11 +123,12 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &Checker, scope: &S
         };
 
         if binding.context.is_typing()
-            && binding.references().any(|reference_id| {
+            && let Some(runtime_reference) = binding.references().find_map(|reference_id| {
                 let reference = checker.semantic().reference(reference_id);
 
-                reference.in_runtime_context()
-                    && !(ignore_dunder_all_references && reference.in_dunder_all_definition())
+                (reference.in_runtime_context()
+                    && !(ignore_dunder_all_references && reference.in_dunder_all_definition()))
+                .then_some(reference)
             })
         {
             let Some(node_id) = binding.source else {
@@ -141,6 +142,7 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &Checker, scope: &S
                 range: binding.range(),
                 parent_range: binding.parent_range(checker.semantic()),
                 needs_future_import: false, // TODO(brent) See #19359.
+                runtime_reference: Some(runtime_reference),
             };
 
             if checker.rule_is_ignored(Rule::RuntimeImportInTypeCheckingBlock, import.start())
@@ -197,6 +199,7 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &Checker, scope: &S
                     import,
                     range,
                     parent_range,
+                    runtime_reference,
                     ..
                 } in imports
                 {
@@ -207,6 +210,12 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &Checker, scope: &S
                         },
                         range,
                     );
+                    if let Some(runtime_reference) = runtime_reference {
+                        diagnostic.secondary_annotation(
+                            "This use is required at runtime",
+                            runtime_reference,
+                        );
+                    }
                     if let Some(range) = parent_range {
                         diagnostic.set_parent(range.start());
                     }
diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs b/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs
index f1918596b1..f6032d184f 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs
@@ -374,6 +374,7 @@ pub(crate) fn typing_only_runtime_import(
             range: binding.range(),
             parent_range: binding.parent_range(checker.semantic()),
             needs_future_import,
+            runtime_reference: None,
         };
 
         if checker.rule_is_ignored(rule_for(import_type), import.start())
```

</p>
</details> 

---

_Comment by @MichaReiser on 2025-12-31 07:55_

This looks nice!

---

_Referenced in [astral-sh/ruff#17203](../../astral-sh/ruff/issues/17203.md) on 2025-12-31 14:46_

---
