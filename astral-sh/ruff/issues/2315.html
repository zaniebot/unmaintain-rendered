<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Potential New Lint Check: Alphabetized Enums - astral-sh/ruff #2315</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Potential New Lint Check: Alphabetized Enums</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/2315">#2315</a>
        opened by <a href="https://github.com/traviscook21">@traviscook21</a>
        on 2023-01-29 00:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/traviscook21">@traviscook21</a></div>
            <div class="timeline-body"><p>Hi there - thanks for the great repo.  I've been continually amazed by how many checks have been included and how fast <code>ruff</code> is.  The work y'all are doing is amazing.</p>
<p>I'm interesting in adding a new set of linter checks around alphabetized enums.  In the variety of corporate repos I work in, there are some use cases with very long lists of values in an enum, like log types, slack channel names, etc.  We've been enforcing that these stay in alphabetical order via PR, but obviously enforcing via a lint check would be easier, especially if it can be auto fixed.  I've tried to find flake8 extensions that have a similar behavior but I have yet to find anything that does this exactly.  I'm a python developer without any Rust experience (yet) but would be interested in implementing in <code>ruff</code> if this is deemed appropriate as a new kind of check.</p>
<p>Some examples:</p>
<p><strong>:one: Alphabetize non-auto string values based on the enum attribute names.</strong></p>
<p>Bad:</p>
<pre><code class="language-python">from enum import Enum

class Animals(Enum): 
     DOG = &quot;dog&quot;
     CAT = &quot;cat&quot;
</code></pre>
<p>Good:</p>
<pre><code class="language-python">from enum import Enum

class Animals(Enum): 
     CAT = &quot;cat&quot;
     DOG = &quot;dog&quot;
</code></pre>
<p><strong>:two: Order non-auto integer values based on the enum values</strong></p>
<p>It's fairly common to use enums to handle priority order, so I think the clearest thing to do is to sort these on the values, not on the attribute names.  This could also be sorted on the attribute names.</p>
<p>Bad:</p>
<pre><code class="language-python">from enum import Enum

class Priority(Enum):
    THIRD_PARTY = 3
    PUBLIC = 1
    INTERNAL = 2
</code></pre>
<p>Good:</p>
<pre><code class="language-python">from enum import Enum

class Priority(Enum):
    PUBLIC = 1    
    INTERNAL = 2
    THIRD_PARTY = 3
</code></pre>
<p><strong>:three: Alphabetize auto values based on the <code>StrEnum</code> attribute names.</strong></p>
<p>When using a <code>StrEnum</code>, <code>auto</code> will set the values to <code>name.lower()</code> so changing the order will have no impact.</p>
<p>Bad:</p>
<pre><code class="language-python">from enum import StrEnum, auto

class Animals(StrEnum):
    DOG = auto()
    CAT = auto()
</code></pre>
<p>Good:</p>
<pre><code class="language-python">from enum import StrEnum, auto

class Animals(StrEnum):
    CAT = auto()
    DOG = auto()
</code></pre>
<p><strong>:four: Do Nothing with regular enums that use <code>auto()</code></strong>
Because regular enum <code>auto()</code> assigns integer values, changing the order will change the integer values that get assigned.  Assuming all of the uses are internal, this might not cause issues, but if the values are written to a database, used outside the application, or any comparisons happen directly to the integer values, this could cause problems.  As a result, I think it's better to leave enums that look like this alone</p>
<pre><code class="language-python">from enum import Enum, auto

class Animals(Enum):
    DOG = auto()
    CAT = auto()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-31 04:33</div>
            <div class="timeline-body"><p>I think this is overall a reasonable suggestion. It'll take some care to preserve comments, if that's something that we care about.</p>
<p>The main blockers here, IMO, are: (1) we're a little behind on defining the criteria for inclusion new checks (#2257), and (2) we need better mechanisms for categorizing these novel rules (we can put them in <code>RUF</code>, but I'd rather they go in some more experimental section -- see #1774).</p>
<p>I'm hoping to write something up to kickstart the discussion on (1) by the end of the week.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @charliermarsh on 2023-01-31 04:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ngnpope">@ngnpope</a> on 2023-01-31 20:34</div>
            <div class="timeline-body"><p>For this particular one it would be nice if it's possible to so something like the following:</p>
<pre><code class="language-python">class Animals(Enum):
    CAT = auto()
    DOG = auto()
    PIG = auto()

    UNIDENTIFIED = auto()  # noqa: ENU001
</code></pre>
<p>Or whatever... Sometimes there is a special value that we don't want to sort, but I guess I'd expect the violation to normally be raised against the <code>class Animals(Enum):</code> line so flagging this could be awkward.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/michaeloliverx">@michaeloliverx</a> on 2023-02-07 11:02</div>
            <div class="timeline-body"><p>This is great suggestion! Something related would be the ability to sort collections that use enums as keys similar to the undocumented <code>isort</code> options to sort collections with string keys. I do this manually in many places which is always a pain.</p>
<p>Being able to opt out an entire enum rather than each member with a comment would be useful also.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Quasar6X">@Quasar6X</a> on 2024-11-26 15:55</div>
            <div class="timeline-body"><p>Hi there - please do excuse me for resurrecting this old issue.</p>
<p>First of all, I belive that this is a great idea, however I'd like to propoe a bit different sorting scheme and present an edge case which makes this difficult for Flag enums.</p>
<h3>My proposal</h3>
<p>I think that natural sorting would be a better fit than strictly lexicographical sorting, as the latter would result in a sorting like this:</p>
<pre><code class="language-python">class E(Enum):
    VAR1 = auto()
    VAR10 = auto()
    VAR2 = auto()
    VAR3 = auto()
    VAR4 = auto()
    VAR5 = auto()
    VAR6 = auto()
    VAR7 = auto()
    VAR8 = auto()
    VAR9 = auto()
</code></pre>
<p>Where, the intent was to have an ascending numbering scheme for the variants. However, there's a catch when the intent is to have a descending scheme. I propose to make this an option, with the default value being 'ascending' with the option to enable both.</p>
<p>Example:</p>
<pre><code class="language-toml">[tool.ruff.lint.&lt;enum-sort-order-lint-key-here&gt;]
sort-order = [&quot;ascending&quot;, &quot;descending&quot;]  # default: &quot;ascending&quot;
</code></pre>
<p>The drawback of this option is that the lint cannot be auto-fixable. I feel that this is a small drawback compared to the greater flexibility provided by it, thus making the lint applicable for more use-cases.</p>
<p>I think that this approach would also fit #7220</p>
<h3>The edge case</h3>
<p>Consider this Flag enum (also holds true for <code>IntFlag</code>):</p>
<pre><code class="language-python">class E(Flag):
    B = auto()
    A = auto()
</code></pre>
<p>Now flag enum variants can be combined with <code>__or__</code> and <code>__xor__</code>. Given the definition above, the following statement</p>
<pre><code class="language-python">print((E.A | E.B).name, (E.B | E.A).name, (E.A ^ E.B).name, (E.B ^ E.A).name)
</code></pre>
<p>prints: <code>B|A B|A B|A B|A</code> for python versions <code>&gt;= 3.11</code>. This is because the operators need to keep commutativity in mind, thus the order is determined by the definition order of the variants. Sorting such enum variants in <strong>any</strong> ordering could break code where variant names are compared against strings.</p>
<p>I believe that making Flag type enums unfixable in either &quot;ascending&quot; or &quot;descending&quot; options is sufficient, however the risk here is much greater making me lean towards extracting this part into another lint.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-11-27 07:30</div>
            <div class="timeline-body"><p>@Quasar6X Thanks for writing this up! Reading the original proposal, I think the rules would only look at enums that are &quot;safe&quot; to re-order i.e, it should avoid the edge case that you've mentioned and the one in your proposal. I'm curious to know if the example mentioned in your proposal is something that you've seen in a real codebase.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Quasar6X">@Quasar6X</a> on 2024-11-27 08:14</div>
            <div class="timeline-body"><p>I have yet to come across this in a python code base but I had seen this pattern in a C code base before.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/r-barnes">@r-barnes</a> on 2025-07-03 00:02</div>
            <div class="timeline-body"><p>Relatedly: there are often lists/dicts/other structures where the user might desire the contents to remain alphabetical.</p>
<p>For instance, the code might contain a set of users privileged to access a resource - maintaining alphabetical order in that last increases readability.</p>
<p>Perhaps a <code># qa: desc-sort</code> and <code># qa: asc-sort</code> that applies to the current block would be a general purpose way of allowing the user to request linted enforcement of ordering?</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:46:15 UTC
    </footer>
</body>
</html>
