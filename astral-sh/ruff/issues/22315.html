<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANN201 Incorrect autofix return type for raise in loop - astral-sh/ruff #22315</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ANN201 Incorrect autofix return type for raise in loop</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/22315">#22315</a>
        opened by <a href="https://github.com/spaceby">@spaceby</a>
        on 2025-12-31 10:47
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/spaceby">@spaceby</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>https://play.ruff.rs/f2c7c8a3-1e38-425f-b1e5-0068e6f8b67b</p>
<pre><code class="language-python">class Test:
    items_list = []

    def method(self):
        for item in self.items_list:
            raise Exception(item)


t = Test()
t.method()
</code></pre>
<p>This code returns None.
However, autofix substitutes in method NoReturn</p>
<pre><code class="language-python">from typing import NoReturn
class Test:
    items_list = []

    def method(self) -&gt; NoReturn:
        for item in self.items_list:
            raise Exception(item)


t = Test()
t.method()
</code></pre>
<h3>Version</h3>
<p>0.14.10</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "ANN201 Incorrect autofix" to "ANN201 Incorrect autofix return type for raise in loop" by @spaceby on 2025-12-31 10:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-31 15:27</div>
            <div class="timeline-body"><p>Thanks for the report!</p>
<p>This is related to the same code Micha mentions in https://github.com/astral-sh/ruff/issues/15975#issuecomment-2639121847. It looks like we treat loops as always being entered.</p>
<p>We do hope to have more general control-flow analysis at some point (https://github.com/astral-sh/ruff/issues/17065), but maybe there's something we can improve here in the meantime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @ntBre on 2025-12-31 15:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/11happy">@11happy</a> on 2026-01-10 10:51</div>
            <div class="timeline-body"><p>Hii @ntBre , for the above issue as you mentioned loops are assumed to always execute atleast once, which causes for the above tests case to result in <code>Terminal::Raise</code> behaviour eventually returning <code>NoReturn</code> , for solution could we check if iterable in <code>for</code> &amp; <code>while</code> stmt  is guranteed to be non-empty something along these lines:</p>
<pre><code>fn nonempty_tmep_check(iter: &amp;Expr) -&gt; bool {
    match iter {
        Expr::List(ast::ExprList { elts, .. }) =&gt; !elts.is_empty(),
        Expr::Tuple(ast::ExprTuple { elts, .. }) =&gt; !elts.is_empty(),
        Expr::Set(ast::ExprSet { elts, .. }) =&gt; !elts.is_empty(),
        Expr::Dict(ast::ExprDict { items, .. }) =&gt; !items.is_empty(),
        Expr::StringLiteral(ast::ExprStringLiteral { value, .. }) =&gt; !value.is_empty(),
        Expr::BytesLiteral(ast::ExprBytesLiteral { value, .. }) =&gt; !value.is_empty(),
        _ =&gt; false,
    }
}
</code></pre>
<p>&amp; then in <code>Terminal::from_body</code> we can only apply terminal behaviour if we know the loops executes, however how do we make sure for function calls or other variables ? What do you think of this approach please let me know.</p>
<p>Also while exploring the codebase I noticed both <code>sometimes_break</code> &amp; <code>always_break</code> have same doc comments, I think <code>always_break</code> should have correct doc comment.</p>
<pre><code>/// Returns `true` if the body may break via a `break` statement.
fn sometimes_breaks(stmts: &amp;[Stmt]) -&gt; bool 

 /// Returns `true` if the body may break via a `break` statement.
fn always_breaks(stmts: &amp;[Stmt]) -&gt; bool

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/close2code-palm">@close2code-palm</a> on 2026-01-11 11:18</div>
            <div class="timeline-body"><p>Hello. As I researched, we need to decide, if <code>test</code> in while \ for loop expression node are always falsy \ empty. One approach is to assume they are not excepted to be always truthy or non-empty, and this should solve the problem, but currently this is hard as this needs some kind of heavy analysis, and it still wont be correct sometimes, we'll just revert the situation. If you believe itâ€™s better for fixes to miss some cases rather than produce incorrect results, we could consider modifying <code>Terminal::from_function</code> changes, the most simple to say is to take into account all parent nodes before to make a decision - we can return(upd - pass to and_then. By the way, &quot;Terminal::Return&quot; seems impossible by Rust code flow) just <code>Terminal::RaiseOrReturn</code> instead <code>Terminal::Raise</code> when there is at least one loop(later it will be loop on which we are not sure if it is iterated at least once) in ancestors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2026-01-12 15:47</div>
            <div class="timeline-body"><p>Thank you both for looking into this! I would probably lean toward not implementing anything for this rule specifically and instead waiting for more general control-flow analysis in Ruff.</p>
<p>Checking the length/truthiness of the loop iterable does sound somewhat promising, but I think there will be tricky edge cases there too. The snippet in this issue is a good example of that because the <code>items_list</code> field could be modified outside the class (or even outside the file). So I think it's probably not worth any added complexity in the rule, especially since this is already an unsafe fix.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:53:44 UTC
    </footer>
</body>
</html>
