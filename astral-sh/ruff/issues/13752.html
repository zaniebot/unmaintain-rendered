<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[C416 unnecessary-comprehension] Suggests a fix leading to RecursionError - astral-sh/ruff #13752</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[C416 unnecessary-comprehension] Suggests a fix leading to RecursionError</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/13752">#13752</a>
        opened by <a href="https://github.com/echoix">@echoix</a>
        on 2024-10-14 14:58
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/echoix">@echoix</a> on 2024-10-14 14:58</div>
            <div class="timeline-body"><!--
Thank you for taking the time to report an issue! We're glad to have you involved with Ruff.

If you're filing a bug report, please consider including the following information:

* List of keywords you searched for before creating this issue. Write them down here so that others can find this issue more easily and help provide feedback.
  e.g. "RUF001", "unused variable", "Jupyter notebook"
* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `ruff /path/to/file.py --fix`), ideally including the `--isolated` flag.
* The current Ruff settings (any relevant sections from your `pyproject.toml`).
* The current Ruff version (`ruff --version`).
-->

<p>Rule <a href="https://docs.astral.sh/ruff/rules/unnecessary-comprehension/#unnecessary-comprehension-c416">unnecessary-comprehension (C416)</a> suggests replacing comprehensions by the constructor instead. However, in some cases, when the replacement is done in code inside or called by <code>__len__</code>, it causes a recursion error.</p>
<p>After searching a bit on SO, the list constructor calls <code>__len__</code> as an optimization when available, https://stackoverflow.com/questions/41474829/why-does-list-ask-about-len https://github.com/python/cpython/blob/67f6e08147bc005e460d82fcce85bf5d56009cf5/Objects/listobject.c#L1164</p>
<p>What I would expect:</p>
<ul>
<li>(Easier) A mention of general cases where the rule is unsafe in the docs, rather than suggesting that the rule is unsafe only because of comments possibly lost</li>
<li>(Harder, but not absolutely required) Track if the change to calling list constructor is done inside the <code>__len__</code> method of the same object that the list is called on.</li>
<li>(Hardest) Also track through function calls, not only inside the same method.</li>
</ul>
<h3>List of keywords searched:</h3>
<p><code>C416</code>, <code>list len</code> (all open and open closed issues for all keywords)</p>
<h3>A stripped-down repro:</h3>
<ul>
<li>File is named: <code>c416_recursionerror.py</code></li>
<li>The command you invoked: <code>ruff check --isolated c416_recursionerror.py --select C416 --fix --unsafe-fixes</code></li>
</ul>
<p>Take note that some other instances of the same problem in our project is wrapping some wxPython, not files, and can't directly be reshaped in a pythonic way easily, in order to store the items in the class and cache the length; it needs to iterate. Stripped down an easier case here, but the others had <code>def __len__(self):  return len([layer for layer in self])</code> but I couldn't isolate it.</p>
<details><summary>File c416_recursionerror.py</summary>
<p>

<pre><code class="language-python">from abc import abstractmethod
from os import listdir
from os.path import join, isdir
import fnmatch


def is_valid(value, path, type):
    &quot;&quot;&quot;Private function to check the correctness of a value.&quot;&quot;&quot;
    return True


def return_bool(argument):
    return True


def always_true_for_repro():
    return True


class Mapset:
    def __init__(self, mapset=&quot;&quot;, location=&quot;&quot;, gisdbase=&quot;&quot;):
        self.gisdbase = gisdbase
        self.location = location
        self.name = mapset


class LocationBase:
    &quot;&quot;&quot;Location object ::

        &gt;&gt;&gt; from grass.script.core import gisenv
        &gt;&gt;&gt; location = Location()
        &gt;&gt;&gt; location                                      # doctest: +ELLIPSIS
        Location(...)
        &gt;&gt;&gt; location.gisdbase == gisenv()['GISDBASE']
        True
        &gt;&gt;&gt; location.name == gisenv()['LOCATION_NAME']
        True

    ..
    &quot;&quot;&quot;

    def __init__(self, location=&quot;&quot;, dbase_path=&quot;.&quot;):
        self.name = location
        self.path = join(dbase_path, self.name)

    # def __getitem__(self, mapset):
    #     if mapset in self.mapsets():
    #         return Mapset(mapset)
    #     raise KeyError(&quot;Mapset: %s does not exist&quot; % mapset)

    def __iter__(self):
        lpath = self.path
        return (
            m
            for m in listdir(lpath)
            if (
                always_true_for_repro()
                or (isdir(join(lpath, m)) and is_valid(m, lpath, &quot;MAPSET&quot;))
            )
        )

    def __len__(self):
        return len(self.mapsets())

    @abstractmethod
    def mapsets(self, pattern=None, permissions=True) -&gt; list[str]:
        &quot;&quot;&quot;Return a list of the available mapsets.

        :param pattern: the pattern to filter the result
        :type pattern: str
        :param permissions: check the permission of mapset
        :type permissions: bool
        :return: a list of mapset's names
        :rtype: list of strings

        ::

            &gt;&gt;&gt; location = Location()
            &gt;&gt;&gt; sorted(location.mapsets())                # doctest: +ELLIPSIS
            [...]

        &quot;&quot;&quot;


class LocationOk(LocationBase):
    def mapsets(self, pattern=None, permissions=True):
        mapsets = [mapset for mapset in self]  # Should add noqa: C416
        # mapsets = list(self)  # Causes RecursionError
        if permissions:
            mapsets = [mapset for mapset in mapsets if return_bool(mapset)]
        if pattern:
            return fnmatch.filter(mapsets, pattern)
        return mapsets


class LocationC416(LocationBase):
    def mapsets(self, pattern=None, permissions=True):
        # mapsets = [mapset for mapset in self]  # Should add noqa: C416
        mapsets = list(self)  # Causes RecursionError
        if permissions:
            mapsets = [mapset for mapset in mapsets if return_bool(mapset)]
        if pattern:
            return fnmatch.filter(mapsets, pattern)
        return mapsets


if __name__ == &quot;__main__&quot;:
    print(&quot;in main&quot;)
    a = LocationOk()
    b = LocationC416()
    print(f&quot;a is: {a!r}&quot;)
    print(f&quot;a is: {b!r}&quot;)
    print(a.path)
    print(b.path)
    print(len(a))
    print(len(b))
    print(&quot;end main&quot;)

</code></pre>
</p>
</details> 

<h3>Ruff version:</h3>
<pre><code class="language-shell">$ ruff --version
ruff 0.6.9
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../OSGeo/grass/pulls/4514.html">OSGeo/grass#4514</a> on 2024-10-14 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">documentation</span> added by @MichaReiser on 2024-10-14 16:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-14 16:40</div>
            <div class="timeline-body"><p>Thanks for the detailed write up.</p>
<p>Extending the documentation seems reasonable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @MichaReiser on 2024-10-14 16:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DataEnggNerd">@DataEnggNerd</a> on 2024-10-17 07:21</div>
            <div class="timeline-body"><p>@MichaReiser Can you assign this issue to me?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-17 08:04</div>
            <div class="timeline-body"><p>Sure. The goal isn't to detect recursions but to update the documentation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @DataEnggNerd by @MichaReiser on 2024-10-17 08:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:14 UTC
    </footer>
</body>
</html>
