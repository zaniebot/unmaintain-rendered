```yaml
number: 16527
title: "F821: False positive with Pydantic's `BaseModel.model_fields`"
type: issue
state: closed
author: yury-fedotov
labels:
  - question
  - rule
assignees: []
created_at: 2025-03-06T00:42:15Z
updated_at: 2025-03-06T14:52:32Z
url: https://github.com/astral-sh/ruff/issues/16527
synced_at: 2026-01-10T01:56:55Z
```

# F821: False positive with Pydantic's `BaseModel.model_fields`

---

_Issue opened by @yury-fedotov on 2025-03-06 00:42_

### Summary

## MRE

```python
from typing import Annotated

from pydantic import BaseModel, Field


class User(BaseModel):
    name: Annotated[str, Field(min_length=1)]
    age: Annotated[int, Field(ge=0)]


class PartialUser(BaseModel):
    name: User.model_fields["name"].annotation
```

## Current behavior

Lint error on the last line:

```
F821 Undefined name `name`
```

## Expected behavior

Treat "name" as a string and do not complain that it's an undefined variable.

### Version

0.7.1

---

_Comment by @MichaReiser on 2025-03-06 08:05_

@carljm can you help me out on this whether Ruff's interpretation of `"name"` in `User.model_fields["name"]` as a name and not a string literal is correct here?

---

_Label `question` added by @MichaReiser on 2025-03-06 08:05_

---

_Label `rule` added by @MichaReiser on 2025-03-06 08:05_

---

_Comment by @dhruvmanila on 2025-03-06 09:26_

I'd say that the interpretation is correct here because it's a string annotation but this seems like a special case similar to how `Literal["foo"]` is (`"foo"` is a string literal and not a string annotation).

If this is the recommended way to do this, we might have to special case `User.model_fields` similar to `typing.Literal`. For now, assuming that this pattern is to avoid having same annotations multiple times, you could define a type alias and use that in both places if that works with Pydantic.

---

_Comment by @Daverball on 2025-03-06 12:44_

`User.model_fields["name"].annotation` is not a valid type expression. While this would do the right thing at runtime, any static type checker would complain about that annotation.

With type inference we could detect that `User.model_fields["name"]` is not a generic subscript, and thus `name` is not a forward reference. We could be more conservative and only treat known generic subscripts in type expressions as type expressions, but that would probably lead to too many false positives/negatives in the more common cases.

So I'd say this works as intended. If you want to reuse the same annotation use a type alias or use inheritance to reuse the field (i.e. derive `User` from `PartialUser`)

---

_Comment by @yury-fedotov on 2025-03-06 14:52_

I agree, thank you very much for explanations!

---

_Closed by @yury-fedotov on 2025-03-06 14:52_

---
