<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allow Self-Assignment of variable in TYPE_CHECKING block - astral-sh/ruff #15526</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Allow Self-Assignment of variable in TYPE_CHECKING block</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/15526">#15526</a>
        opened by <a href="https://github.com/spacemanspiff2007">@spacemanspiff2007</a>
        on 2025-01-16 08:21
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/spacemanspiff2007">@spacemanspiff2007</a> on 2025-01-16 08:21</div>
            <div class="timeline-body"><p>I have subclasses which implement different behavior or restrict the data types of the base class.
Additionally I have a docstring on the class which describes the behavior and the instance variables.
Sphinx can only document the instance variable type if it's imported into the module.
To prevent automatic deletion of the (falsely marked as unused) import I self assign the data type in the TYPE_CHECKING block.</p>
<p>Example.:</p>
<p>a.py:</p>
<pre><code class="language-python">from decimal import Decimal

class MyComplexBaseClass:
    def __init__(self) -&gt; None:
        self.var: Decimal = Decimal('1.3')
</code></pre>
<p>b.py</p>
<pre><code class="language-python">from decimal import Decimal  # &lt;-- Must be imported otherwise sphinx fails
from typing import TYPE_CHECKING

from a import MyComplexBaseClass

if TYPE_CHECKING:
    Decimal = Decimal  # &lt;-- Self assign to prevent removal during import optimation

# sphinx uses the datatype of ivar, if it is not imported if fails
class MyClass1(MyComplexBaseClass):
    &quot;&quot;&quot;
    :ivar Decimal value: Some instance var with description
    &quot;&quot;&quot;
</code></pre>
<p>This works well, however it triggers <a href="https://docs.astral.sh/ruff/rules/self-assigning-variable/">PLW0127</a></p>
<pre><code class="language-text">b.py:8:5: PLW0127 Self-assignment of variable `Decimal`
  |
6 | if TYPE_CHECKING:
7 |     Decimal = Decimal
  |     ^^^^^^^ PLW0127
</code></pre>
<p>How about allowing Self-assignment in the <code>TYPE_CHECKING</code> block?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @MichaReiser on 2025-01-16 09:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-16 09:15</div>
            <div class="timeline-body"><p>Thanks for the detailed write-up.</p>
<p>The main issue here seems to be that ruff doesn't understand the use of <code>Decimal</code> in the docstring. That's why I'm leaning against making this, also somewhat obscure and hard to discover, exception and instead prefer teaching Ruff to understand docstrings better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-01-16 09:35</div>
            <div class="timeline-body"><p>I personally feel that importing symbols purely for use in docstrings, is a bit of a code-smell. Shouldn't you be able to instead use the fully qualified name <code>decimal.Decimal</code> in the docstring? Or potentially <code>~decimal.Decimal</code> so it's still rendered as <code>Decimal</code>. That seems like a better solution to me.</p>
<p>But I agree that Ruff could do a better job here. Detecting the case where an import is only used for its use inside a docstring could then easily become its own rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacemanspiff2007">@spacemanspiff2007</a> on 2025-01-16 09:51</div>
            <div class="timeline-body"><blockquote>
<p>Shouldn't you be able to instead use the fully qualified name <code>decimal.Decimal</code> in the docstring? Or potentially <code>~decimal.Decimal</code> so it's still rendered as <code>Decimal</code>. That seems like a better solution to me.</p>
</blockquote>
<p>I'm not sure if this works.
However <code>Decimal</code> is only a placeholder (I needed something that has to be imported) and the value is in my case typically a custom datatype. If I import the module my IDE properly refactors the import when I move the implementation around in my project which will not be the case if I use the fully qualified name.</p>
<blockquote>
<p>That's why I'm leaning against making this, also somewhat obscure and hard to discover, exception</p>
</blockquote>
<p>I agree it's not very nice.
However PyCharm does also not discover this properly, too.
I have to do it anyway if I don't want PyCharm to flag it as an unused import.
ðŸ˜•</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-01-17 00:03</div>
            <div class="timeline-body"><p>Idk if you can do so in PyCharm, but in VSCode I disable organization and removal of unused imports.</p>
<p>That way my linter (here Ruff's <code>I</code> group) takes care of it on save instead. And I can noqa it.</p>
<p>https://github.com/python/typeshed/pull/13363</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-01-17 02:23</div>
            <div class="timeline-body"><p>For the record, PyCharm's support for reStructuredText/Sphinx in general <a href="https://youtrack.jetbrains.com/issue/PY-73814">is pretty bad</a>, and <a href="https://youtrack.jetbrains.com/issue/PY-73814#focus=Comments-27-10865300.0-0">it won't be improved anytime soon</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">docstring</span> added by @dhruvmanila on 2025-01-17 05:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacemanspiff2007">@spacemanspiff2007</a> on 2025-01-30 04:41</div>
            <div class="timeline-body"><p>I'm don't think this is related to docstring only.</p>
<p>There are many use cases that requires where one would want to import an module or object that normally would be moved to the <code>TYPE_CHECKING</code> block or that even would be removed during import sort.
E.g.</p>
<ul>
<li>if I access something dynamically (e.g. through <code>getattr</code> or <code>globals()</code>)</li>
<li>if I want to resolve type hints and further work with the resolved types</li>
</ul>
<p>The most easy and consistent way to achieve this is to keep a self-assignment in the <code>TYPE_CHECKING</code> block.
That's why I still think it's a good idea to make an exception for the <code>TYPE_CHECKING</code> block and allow the self assignment there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-01-30 07:01</div>
            <div class="timeline-body"><p>I respectfully disagree. When static analysis gets something wrong, due to how  dynamic of a language Python is, the solution isn't to add some hack to your code, the solution is to add a <code>noqa</code> comment, that's what they're for.</p>
<p>Self-assignment in type checking blocks is non-idiomatic, and besides you, nobody will understand what it's supposed to do, or that it can/should go away, once it's no longer needed to avoid the import related violation.</p>
<p>Only once <code>noqa</code> isn't enough, because there's a whole cascade of issues that would require their own suppression comments, should you really be tempted to reach towards trickery using <code>TYPE_CHECKING</code> and even then you should ask yourself if a refactor of your code wouldn't serve you better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacemanspiff2007">@spacemanspiff2007</a> on 2025-01-30 07:33</div>
            <div class="timeline-body"><p>Thank you for your response. I agree that dynamically accessing module imports is somewhat hacky and a good candidate for refactoring. For this use case a <code>noqa</code> is sufficient because it doesn't happen often.</p>
<p>However I think you only addressed one point of my argument:
Resolving type hints to the corresponding type and accessing it is something that is quite common and both done during testing and during code execution.
Pseudo example using pydantic, but this works the same for any class:</p>
<p>file a:</p>
<pre><code class="language-python">class MyValue1(BaseModel):
    type: Literal['MyValue1Type']
    ...

class MyValue2(BaseModel):
    type: Literal['MyValue2Type']
    ...
</code></pre>
<p>file b:</p>
<pre><code class="language-python">from a import MyValue1, MyValue2

class MyOuterValue(BaseModel):
    event: MyValue1 | MyValue2
    ...
</code></pre>
<p>If I want to build a list of types that are allowed for <code>MyOuterValue</code> I can programmatically get that from the class with <code>typing.get_origin()</code> and <code>typing.get_args()</code>.
Accessing the type hints for further processing is something quite common when working with these models.
However to make it work the import has to be available and a self assignment in the <code>TYPE_CHECKING</code> block is the common way to consistently achieve this across all checkers and IDEs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-01-30 10:36</div>
            <div class="timeline-body"><p>@spacemanspiff2007 In order to support pydantic and other kinds of libraries that need to access type information at runtime there are settings like <a href="https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-base-classes">runtime-evaluated-base-classes</a> and <a href="https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-decorators">runtime-evaluated-decorators</a>, which can give you the desired effect.</p>
<p>It's not a complete solution and there are still some other required runtime uses that are difficult/impossible to detect statically (there are also cases where we can't statically know either way, like forward references to models in SQLAlchemy's <code>Mapped</code>). I am actively working to make <code>flake8-type-checking</code> more flexible and support more use-cases, but it's never going to be able to be the right tool for absolutely everyone. If it's not the right fit, it's better to just disable the <code>TC</code> rules, or at least the ones that are causing issues for you.</p>
<p>But either way, any solutions should ideally only rely on configuration and noqa directives, not on some magical piece of Python code.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:54 UTC
    </footer>
</body>
</html>
