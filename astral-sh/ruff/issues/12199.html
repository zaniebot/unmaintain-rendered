<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Formatter: inconsistent amount of added empty lines around an inner function - astral-sh/ruff #12199</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Formatter: inconsistent amount of added empty lines around an inner function</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/12199">#12199</a>
        opened by <a href="https://github.com/flying-sheep">@flying-sheep</a>
        on 2024-07-05 08:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2024-07-05 08:14</div>
            <div class="timeline-body"><!--
Thank you for taking the time to report an issue! We're glad to have you involved with Ruff.

If you're filing a bug report, please consider including the following information:

* List of keywords you searched for before creating this issue. Write them down here so that others can find this issue more easily and help provide feedback.
  e.g. "RUF001", "unused variable", "Jupyter notebook"
* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `ruff /path/to/file.py --fix`), ideally including the `--isolated` flag.
* The current Ruff settings (any relevant sections from your `pyproject.toml`).
* The current Ruff version (`ruff --version`).
-->

<p>Input:</p>
<pre><code class="language-py">    if header[0] == &quot;Package&quot;:
        def strengthen(k: str) -&gt; str:
            return f&quot;&lt;strong&gt;{k}&lt;/strong&gt;&quot;
    else:
        pass
</code></pre>
<p>Ruff’s output:</p>
<pre><code class="language-py">    if header[0] == &quot;Package&quot;:

        def strengthen(k: str) -&gt; str:
            return f&quot;&lt;strong&gt;{k}&lt;/strong&gt;&quot;
    else:
        pass
</code></pre>
<p>Black’s output:</p>
<pre><code class="language-py">    if header[0] == &quot;Package&quot;:

        def strengthen(k: str) -&gt; str:
            return f&quot;&lt;strong&gt;{k}&lt;/strong&gt;&quot;

    else:
        pass
</code></pre>
<p>I would personally prefer no empty lines to be inserted here, but matching Black’s behavior at least creates a consistent result.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by @MichaReiser on 2024-07-05 08:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-05 08:50</div>
            <div class="timeline-body"><p>My nemesis, Black's empty line rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2024-07-05 08:51</div>
            <div class="timeline-body"><p>I’m sorry! :sweat_smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @MichaReiser on 2024-07-05 08:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-05 09:15</div>
            <div class="timeline-body"><p>Okay, I think the problem is that the following code only runs between statements:</p>
<p>https://github.com/astral-sh/ruff/blob/549cc1e437479ec7fde0dcf3e7360fb95d06076d/crates/ruff_python_formatter/src/statement/suite.rs#L165-L216</p>
<p>But the code path is not executed before a clause header.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">breaking</span> added by @MichaReiser on 2024-07-05 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-05 09:34</div>
            <div class="timeline-body"><p>Okay, I don't think we can fix this bug right now because it would change formatting of existing code.</p>
<p>My naive approach of duplicating some of the logic into the <code>FormatClauseHeader</code> causes instability. We need to look into this more closely when working on the next preview style</p>
<pre><code class="language-patch">Index: crates/ruff_python_formatter/src/statement/clause.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/statement/clause.rs b/crates/ruff_python_formatter/src/statement/clause.rs
--- a/crates/ruff_python_formatter/src/statement/clause.rs	(revision 1e07bfa3730db9461f51b877bf71ea31e7dd56e4)
+++ b/crates/ruff_python_formatter/src/statement/clause.rs	(date 1720171838242)
@@ -1,5 +1,5 @@
 use ruff_formatter::{write, Argument, Arguments, FormatError};
-use ruff_python_ast::AnyNodeRef;
+use ruff_python_ast::{AnyNodeRef, Stmt};
 use ruff_python_ast::{
     ElifElseClause, ExceptHandlerExceptHandler, MatchCase, StmtClassDef, StmtFor, StmtFunctionDef,
     StmtIf, StmtMatch, StmtTry, StmtWhile, StmtWith, Suite,
@@ -23,7 +23,10 @@
     Class(&amp;'a StmtClassDef),
     Function(&amp;'a StmtFunctionDef),
     If(&amp;'a StmtIf),
-    ElifElse(&amp;'a ElifElseClause),
+    ElifElse {
+        clause: &amp;'a ElifElseClause,
+        last_prev_body_statement: Option&lt;&amp;'a Stmt&gt;,
+    },
     Try(&amp;'a StmtTry),
     ExceptHandler(&amp;'a ExceptHandlerExceptHandler),
     TryFinally(&amp;'a StmtTry),
@@ -47,7 +50,7 @@
         let end = match self {
             ClauseHeader::Class(class) =&gt; Some(last_child_end.unwrap_or(class.name.end())),
             ClauseHeader::Function(function) =&gt; Some(last_child_end.unwrap_or(function.name.end())),
-            ClauseHeader::ElifElse(_)
+            ClauseHeader::ElifElse { .. }
             | ClauseHeader::Try(_)
             | ClauseHeader::If(_)
             | ClauseHeader::TryFinally(_)
@@ -125,11 +128,15 @@
             }) =&gt; {
                 visit(test.as_ref(), visitor);
             }
-            ClauseHeader::ElifElse(ElifElseClause {
-                test,
-                range: _,
-                body: _,
-            }) =&gt; {
+            ClauseHeader::ElifElse {
+                clause:
+                    ElifElseClause {
+                        test,
+                        range: _,
+                        body: _,
+                    },
+                ..
+            } =&gt; {
                 if let Some(test) = test.as_ref() {
                     visit(test, visitor);
                 }
@@ -220,14 +227,21 @@
                 find_keyword(start_position, keyword, source)
             }
             ClauseHeader::If(header) =&gt; find_keyword(header.start(), SimpleTokenKind::If, source),
-            ClauseHeader::ElifElse(ElifElseClause {
-                test: None, range, ..
-            }) =&gt; find_keyword(range.start(), SimpleTokenKind::Else, source),
-            ClauseHeader::ElifElse(ElifElseClause {
-                test: Some(_),
-                range,
+            ClauseHeader::ElifElse {
+                clause: ElifElseClause {
+                    test: None, range, ..
+                },
+                ..
+            } =&gt; find_keyword(range.start(), SimpleTokenKind::Else, source),
+            ClauseHeader::ElifElse {
+                clause:
+                    ElifElseClause {
+                        test: Some(_),
+                        range,
+                        ..
+                    },
                 ..
-            }) =&gt; find_keyword(range.start(), SimpleTokenKind::Elif, source),
+            } =&gt; find_keyword(range.start(), SimpleTokenKind::Elif, source),
             ClauseHeader::Try(header) =&gt; find_keyword(header.start(), SimpleTokenKind::Try, source),
             ClauseHeader::ExceptHandler(header) =&gt; {
                 find_keyword(header.start(), SimpleTokenKind::Except, source)
@@ -347,6 +361,73 @@
 
 impl&lt;'ast&gt; Format&lt;PyFormatContext&lt;'ast&gt;&gt; for FormatClauseHeader&lt;'_, 'ast&gt; {
     fn fmt(&amp;self, f: &amp;mut Formatter&lt;PyFormatContext&lt;'ast&gt;&gt;) -&gt; FormatResult&lt;()&gt; {
+        match self.header {
+            ClauseHeader::ElifElse {
+                clause: elif,
+                last_prev_body_statement,
+            } =&gt; {
+                let needs_empty_line = {
+                    // Find nested class or function definitions that need an empty line after them.
+                    //
+                    // ```python
+                    // def f():
+                    //     if True:
+                    //
+                    //         def double(s):
+                    //             return s + s
+                    //
+                    //     print(&quot;below function&quot;)
+                    // ```
+                    std::iter::successors(
+                        last_prev_body_statement.map(AnyNodeRef::from),
+                        AnyNodeRef::last_child_in_body,
+                    )
+                    .take_while(|last_child|
+                        // If there is a comment between preceding and following the empty lines were
+                        // inserted before the comment by preceding and there are no extra empty lines
+                        // after the comment.
+                        // ```python
+                        // class Test:
+                        //     def a(self):
+                        //         pass
+                        //         # trailing comment
+                        //
+                        //
+                        // # two lines before, one line after
+                        //
+                        // c = 30
+                        // ````
+                        // This also includes nested class/function definitions, so we stop recursing
+                        // once we see a node with a trailing own line comment:
+                        // ```python
+                        // def f():
+                        //     if True:
+                        //
+                        //         def double(s):
+                        //             return s + s
+                        //
+                        //         # nested trailing own line comment
+                        //     print(&quot;below function with trailing own line comment&quot;)
+                        // ```
+                        !f.context().comments().has_trailing_own_line(*last_child))
+                    .any(|last_child| {
+                        matches!(
+                            last_child,
+                            AnyNodeRef::StmtFunctionDef(_) | AnyNodeRef::StmtClassDef(_)
+                        )
+                    })
+                };
+
+                if needs_empty_line {
+                    empty_line().fmt(f)?;
+                }
+            }
+            ClauseHeader::ExceptHandler(handler) =&gt; {}
+            ClauseHeader::TryFinally(finally) =&gt; {}
+            // ClauseHeader::OrElse(else_clause)
+            _ =&gt; {}
+        }
+
         if let Some((leading_comments, last_node)) = self.leading_comments {
             leading_alternate_branch_comments(leading_comments, last_node).fmt(f)?;
         }
Index: crates/ruff_python_formatter/src/statement/stmt_if.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/statement/stmt_if.rs b/crates/ruff_python_formatter/src/statement/stmt_if.rs
--- a/crates/ruff_python_formatter/src/statement/stmt_if.rs	(revision 1e07bfa3730db9461f51b877bf71ea31e7dd56e4)
+++ b/crates/ruff_python_formatter/src/statement/stmt_if.rs	(date 1720171815065)
@@ -1,5 +1,5 @@
 use ruff_formatter::{format_args, write};
-use ruff_python_ast::AnyNodeRef;
+use ruff_python_ast::{AnyNodeRef, Stmt};
 use ruff_python_ast::{ElifElseClause, StmtIf};
 use ruff_text_size::Ranged;
 
@@ -39,10 +39,10 @@
             ]
         )?;
 
-        let mut last_node = body.last().unwrap().into();
+        let mut last_node = body.last().unwrap();
         for clause in elif_else_clauses {
             format_elif_else_clause(clause, f, Some(last_node))?;
-            last_node = clause.body.last().unwrap().into();
+            last_node = clause.body.last().unwrap();
         }
 
         Ok(())
@@ -54,7 +54,7 @@
 pub(crate) fn format_elif_else_clause(
     item: &amp;ElifElseClause,
     f: &amp;mut PyFormatter,
-    last_node: Option&lt;AnyNodeRef&gt;,
+    last_node: Option&lt;&amp;Stmt&gt;,
 ) -&gt; FormatResult&lt;()&gt; {
     let ElifElseClause {
         range: _,
@@ -70,7 +70,10 @@
         f,
         [
             clause_header(
-                ClauseHeader::ElifElse(item),
+                ClauseHeader::ElifElse {
+                    clause: item,
+                    last_prev_body_statement: last_node
+                },
                 trailing_colon_comment,
                 &amp;format_with(|f: &amp;mut PyFormatter| {
                     f.options()
Index: crates/ruff_python_formatter/src/lib.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/lib.rs b/crates/ruff_python_formatter/src/lib.rs
--- a/crates/ruff_python_formatter/src/lib.rs	(revision 1e07bfa3730db9461f51b877bf71ea31e7dd56e4)
+++ b/crates/ruff_python_formatter/src/lib.rs	(date 1720169741546)
@@ -188,13 +188,13 @@
     #[test]
     fn quick_test() {
         let source = r#&quot;
-def main() -&gt; None:
-    if True:
-        some_very_long_variable_name_abcdefghijk = Foo()
-        some_very_long_variable_name_abcdefghijk = some_very_long_variable_name_abcdefghijk[
-            some_very_long_variable_name_abcdefghijk.some_very_long_attribute_name
-            == &quot;This is a very long string abcdefghijk&quot;
-        ]
+def test():
+    if header[0] == &quot;Package&quot;:
+        def strengthen(k: str) -&gt; str:
+            return f&quot;&lt;strong&gt;{k}&lt;/strong&gt;&quot;
+    else:
+        pass
+
 
 &quot;#;
         let source_type = PySourceType::Python;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @konstin by @konstin on 2024-07-10 09:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/12294.html">astral-sh/ruff#12294</a> on 2024-07-12 08:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2024-07-15 10:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2024-07-15 10:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2024-07-20 10:09</div>
            <div class="timeline-body"><p>@konstin thank you!</p>
<p>btw. the world is small: you’re in Munich, I’m in Munich, and I’m just leaving a conference in China where I met fellow people from Munich.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:13 UTC
    </footer>
</body>
</html>
