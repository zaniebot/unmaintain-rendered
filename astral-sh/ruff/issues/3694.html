<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Make calling ruff programmatically slightly faster - astral-sh/ruff #3694</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Make calling ruff programmatically slightly faster</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/3694">#3694</a>
        opened by <a href="https://github.com/samuelcolvin">@samuelcolvin</a>
        on 2023-03-23 20:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-03-23 20:22</div>
            <div class="timeline-body"><p>(this is low priority, but maybe interesting)</p>
<p>I using ruff in <a href="https://github.com/pydantic/pytest-examples">pytest-examples</a> to lint and fix code examples.</p>
<p>Currently I have to write a <code>ruff.toml</code> config file, then write the python file, then call ruff by <code>subprocess</code>.</p>
<p>I guess if ruff had someway to set all config via cli arguments, then receive the python code via stdin, I could avoid needing to write to files.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-23 21:28</div>
            <div class="timeline-body"><blockquote>
<p>...then receive the python code via stdin.</p>
</blockquote>
<p>If helpful in the interim: Ruff <em>can</em> take code via stdin:</p>
<pre><code>ruff on main [$!?] is ğŸ“¦ v0.0.259 via ğŸ v3.11.0 (.venv) via ğŸ¦€ v1.67.1
â¯ cat foo.py
â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
       â”‚ File: foo.py
â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   1   â”‚ def f():
   2   â”‚     x = 1
â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

ruff on main [$!?] is ğŸ“¦ v0.0.259 via ğŸ v3.11.0 (.venv) via ğŸ¦€ v1.67.1
â¯ cat foo.py | ruff - --stdin-filename=foo.py
foo.py:2:5: F841 [*] Local variable `x` is assigned to but never used
Found 1 error.
[*] 1 potentially fixable with the --fix option.

ruff on main [$!?] is ğŸ“¦ v0.0.259 via ğŸ v3.11.0 (.venv) via ğŸ¦€ v1.67.1
â¯ cat foo.py | ruff - --stdin-filename=foo.py --fix
def f():
    pass
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by @charliermarsh on 2023-03-23 21:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wishlist</span> added by @charliermarsh on 2023-03-23 21:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wishlist</span> removed by @charliermarsh on 2023-03-23 21:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-23 21:29</div>
            <div class="timeline-body"><p>(But there's no way to provide configuration programmatically. You could write to a tempfile and pass it in as <code>--config /path/to/file.toml</code> if easier, but nothing better than that sadly.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-03-23 21:50</div>
            <div class="timeline-body"><p>Thanks for the pointer on <code>--stdin-filename</code>.</p>
<blockquote>
<p>(But there's no way to provide configuration programmatically. You could write to a tempfile and pass it in as <code>--config /path/to/file.toml</code> if easier, but nothing better than that sadly.)</p>
</blockquote>
<p>yup, that's what I'm doing now.</p>
<p>BTW, it's slightly surprising that <code>line-length</code> can be set via the command line.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-23 21:54</div>
            <div class="timeline-body"><p>Haha it's hidden! We deprecated it but it's still possible :D</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-03-23 22:40</div>
            <div class="timeline-body"><p>ha, thanks for the pointer about stdin, that's working well (seems with stdin, you have to manually define the config file).</p>
<p>It would amazing if config could be set via an (albeit) very ugly command line flag, perhaps base64 encoded to avoid newline weirdnesses.</p>
<p>My solution still involves writing the config on every test which is slowing things down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pydantic/pytest-examples/pulls/4.html">pydantic/pytest-examples#4</a> on 2023-03-23 22:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DanCardin">@DanCardin</a> on 2023-03-24 14:09</div>
            <div class="timeline-body"><p>Idk if this sounds crazy or not, but if ruff were to support file-level configuration comments akin to the noqa ones (but also for selection) i.e. <code># ruff: ignore: N, E5</code> / <code># ruff: select: N, E5</code>, then for this particular usecase you could(?) pipe some comment configuration ahead of the code you're piping in.</p>
<p>With the extra benefit that the new behavior would be cross functional for things outside this usecase.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-03-24 14:17</div>
            <div class="timeline-body"><p>I would refrain from adding new features to ruff only to make programmatically calling ruff via the CLI slightly faster. The proper solution in my view is to add a python API to lint a file given its content as a string and the settings</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DanCardin">@DanCardin</a> on 2023-03-24 14:21</div>
            <div class="timeline-body"><p>I would think file-level configuration comments (which enable both selecting and ignoring) would be a generally useful feature. given that you can already <code>noqa</code> specific violation types.</p>
<p>...and it just so happens that it would enable you to avoid writing files (even if it's somewhat of a hack for you). Although i absolutely agree, an actual programmatic API would make more sense trying to address this specific problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-03-24 15:09</div>
            <div class="timeline-body"><blockquote>
<p>I would think file-level configuration comments (which enable both selecting and ignoring) would be a generally useful feature. given that you can already noqa specific violation types.</p>
</blockquote>
<p>I'm sorry. My intention wasn't to say that this feature isn't useful or that I consider it a hack. The only thing I wanted to convey is that I don't recommend any new features with no practical use other than speeding up ruff's programmatic CLI invocation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-03-24 20:48</div>
            <div class="timeline-body"><blockquote>
<p>I would refrain from adding new features to ruff only to make programmatically calling ruff via the CLI slightly faster. The proper solution in my view is to add a python API to lint a file given its content as a string and the settings</p>
</blockquote>
<p>That's exactly what I'm trying to do, but since Ruff doesn't build with pyo3 whatsoever, adding a formal python interface is a massive change.</p>
<p>Hence allowing full functionality via subprocess without touching the filesystem might be the best solution IMHO.</p>
<p>Also @charliermarsh, I've run into a problem using stdin - when using <code>--fix</code> I get back the reformatted content which is great, but there's no way to get error messages in this case.</p>
<p>Surely the formatted python is going to <code>stdout</code>, error messages should be piped to <code>stderr</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-24 21:06</div>
            <div class="timeline-body"><p>Hmm yeah, perhaps they should be included as <code>stderr</code> -- it's just a bit strange because there's no other context in which we write diagnostics to <code>stderr</code> (then again, there's no other context in which we write &quot;fixed&quot; content to <code>stdout</code>).</p>
<p>If you're looking to parse the diagnostics, you could also consider using <code>--format=json</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-03-24 22:33</div>
            <div class="timeline-body"><p>Currently I'm just using a regex to fix the file name and line number, when printing.</p>
<p>Would be great if stderr could get the diagnostics in this case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pydantic/pytest-examples/pulls/5.html">pydantic/pytest-examples#5</a> on 2023-03-26 15:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-03-26 15:29</div>
            <div class="timeline-body"><blockquote>
<p>I've run into a problem using stdin - when using <code>--fix</code> I get back the reformatted content which is great, but there's no way to get error messages in this case.</p>
</blockquote>
<p>For anyone else running into this problem, my fix is to run ruff again without <code>--fix</code> and use the error from that run, see https://github.com/pydantic/pytest-examples/pull/5.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/5102.html">astral-sh/ruff#5102</a> on 2023-06-14 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-07-10 08:30</div>
            <div class="timeline-body"><p>See #5102 for another use case where an option to pass the configuration (they propose to pass the config as JSON string) would enable more advanced workflows.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @MichaReiser on 2023-07-10 08:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-07-17 21:02</div>
            <div class="timeline-body"><p>It probably doesn't satisfy all your needs and we don't make any stability guarantees but an alternative is to run ruff's wasm version. I don't know how fast https://github.com/wasmerio/wasmer-python is... could as well be slower than spawning a new process</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Finkregh">@Finkregh</a> on 2023-09-12 09:55</div>
            <div class="timeline-body"><p>This would also help when providing pre-commit hooks to others. I'd like to allow others to use prepared hooks to get a consistant linting/formatting without having to add additional config files to their repository.
Currently this excludes setting e.g. <code>pydocstyle</code> as pre-commit only allows setting arguments, not copying files from other repositories.</p>
<p>This also applies to CI jobs, but there you could just copy a config file from somewhere else, of course.</p>
<p>(Thanks for this great tool!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../python-trio/trio/pulls/2795.html">python-trio/trio#2795</a> on 2023-09-21 00:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-12-21 13:44</div>
            <div class="timeline-body"><p>@charliermarsh any progress on this?</p>
<p>This problem get's worse now that we have <code>ruff format</code> which has to be run separately from <code>ruff check --fix</code> - instead of invoking one process for each snippet, we now have to invoke two to use just ruff.</p>
<ol>
<li>It would be awesome if there was a way to run code through ruff without having to create a new process each time - for me this doesn't need to be a python library, just a way to stream multiple files to ruff, then later stream another etc.</li>
<li>(and I assume this is already on your roadmap) it would be nice if there was a way to get all the stuff done by <code>check --fix</code> in the same process as <code>format</code>.</li>
</ol>
<p>:pray: thank you.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-12-21 14:35</div>
            <div class="timeline-body"><p>Hey Samuel!</p>
<ol>
<li>We're interested in porting <code>ruff-lsp</code> to Rust which would give you a persistent process you could call (https://github.com/astral-sh/ruff-lsp/issues/300), I wonder if that would work for you.</li>
<li>We are planning a single command; see #8232</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-21 14:42</div>
            <div class="timeline-body"><p>I donâ€™t know that the LSP rewrite will help here â€” would need to look deeperâ€¦ Since youâ€™ll still have subprocess overhead when calling from Python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-12-21 14:51</div>
            <div class="timeline-body"><p>I think ruff-lsp might work, creating one subprocess is absolutely fine if we can use it for all tests.</p>
<p>The problem in our case is creating one process (two now we're using <code>ruff format</code> not black for formatting) for every code example in markdown and docstrings while running tersts.</p>
<p>Timing examples:</p>
<ul>
<li>running <code>pdm run pytest tests/test_docs.py</code> runs 478 tests in 7.93s (16ms/test) - that's basically running, linting and formatting for ever code snippet in the code base using <code>pytest-examples</code>, I think much of that time is spent spinning up the (currently) one ruff process per case</li>
<li>for comparison, running <code>pdm run pytest tests/test_types.py</code> runs 754 tersts in 1.42s (1.9ms/test)</li>
</ul>
<p>Those timings roughly match my intuition that launching a rust process takes ~10ms.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-12-21 15:03</div>
            <div class="timeline-body"><p>We do support formatting of docstring code snippets now :) perhaps what you really want is linter support for code snippets without extracting them yourself.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2023-12-21 15:08</div>
            <div class="timeline-body"><p>ye, quite possibly.</p>
<p>A few questions:</p>
<ul>
<li>can this work in markdown files too?</li>
<li>do you provide a way for magic markdown classes to disable linting, like <a href="https://github.com/pydantic/pydantic/blob/19fa86cbfcc7b64c5d59c04c38fa80b497f275a2/docs/concepts/alias.md?plain=1#L27">this</a></li>
<li>(I guess this is possible by disabling some linting rule), we use <code>#&gt;</code> to identify print output which is automatically inserted into snippets</li>
</ul>
<p>Sorry to derail this discussions, just interested in whether we could get rid of the linting inside pytest-examples, it would make it much simpler.</p>
<p>cc @davidhewitt</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-02-23 21:43</div>
            <div class="timeline-body"><p>The latest release provides a way to <a href="https://github.com/astral-sh/ruff/pull/9599">set arbitrary configuration options via the CLI</a>, and you can pass the file content on via stdin. Could you let me know if this is enough for your use case?</p>
<p>Also, @snowsignal is working on our LSP rewrite in rust. Stay tuned.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pydantic/pydantic/issues/10083.html">pydantic/pydantic#10083</a> on 2024-08-08 13:54</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:08 UTC
    </footer>
</body>
</html>
