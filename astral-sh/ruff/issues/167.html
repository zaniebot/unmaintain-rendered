<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enforce import from `__all__` (at least locally) - astral-sh/ruff #167</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Enforce import from `__all__` (at least locally)</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/167">#167</a>
        opened by <a href="https://github.com/samuelcolvin">@samuelcolvin</a>
        on 2022-09-12 10:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2022-09-12 10:29</div>
            <div class="timeline-body"><p>I understand that ruff can't check imports are valid in a general way, but it would be great if ruff could check local (relative) imports only import things listed in <code>__all__</code> where <code>__all__</code> is defined.</p>
<h2>Example of what I want</h2>
<p><strong>foo.py</strong>:</p>
<pre><code class="language-py">__all__ = ('public_thing',)

def public_thing():
    pass

def private_thing():
    pass
</code></pre>
<p><strong>bar.py</strong>:</p>
<pre><code class="language-py">from .foo import public_thing # üëç

from .foo import private_thing # üëé FXXX 'private_thing' not declared in __all__
</code></pre>
<hr />
<p>This would only apply where <code>__all__</code> is defined in the module scope obviously.</p>
<p>Any chance ruff could be extended to support this?</p>
<p>This get's fairly important in big packages. But I don't currently know of a tool which enforces <code>__all__</code> and I'm resisting the the impulse to build one myself.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @charliermarsh on 2022-09-12 13:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-16 17:13</div>
            <div class="timeline-body"><p>Do you know if Mypy enforces this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2022-09-16 17:28</div>
            <div class="timeline-body"><p>Nope.</p>
<p>It does some checks, but not full support.</p>
<p>I'll try to check and report back here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-16 17:34</div>
            <div class="timeline-body"><p>Only if convenient, not a big deal :) This would be great to support, though obviously requires some significant changes to the model (since we're no longer checking files in isolation), so won't happen immediately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2022-09-16 19:56</div>
            <div class="timeline-body"><p>The problem is that according the the formal rules (and runtime behaviour), importing <code>private_thing</code> should be fine. All that <code>__all__</code> actually does is mean that <code>private_thing</code> wouldn't be imported if I used <code>from .foo import *</code>.</p>
<p>What I'm really looking for is a way to enforce (ideally at runtime as well as in static analysis) the equivalent of <code>export</code> in TypeScript/JS - e.g. a way to white list which attributes of a module can be accessed, but sadly (and IMHO very strangely) it seems to be impossible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-16 20:51</div>
            <div class="timeline-body"><p>Ugh, yeah, I‚Äôd love to have something like ESM or module visibility modifiers in Python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-16 20:52</div>
            <div class="timeline-body"><p>Mypy does have a ‚Äúno implicit re-export‚Äù setting which helps a bit with the <strong>all</strong> thing, IIRC.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samuelcolvin">@samuelcolvin</a> on 2022-09-16 21:34</div>
            <div class="timeline-body"><p>Agreed, problem is, even with that, if you put code in a private module, then re-export it through a public one, even with <code>__all__</code> set, pycharm tries to import from the private module.</p>
<p>In short, enforcing a public API/private logic divide is virtually impossible with python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-09 15:15</div>
            <div class="timeline-body"><p>This is really similar (identical?) to #1107. I think this import / export enforcement is something I want to do soon (maybe after I improve config resolution).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2022-12-20 23:58</div>
            <div class="timeline-body"><p><code>pyright</code> enforces something similar but with some tweaks-- I believe if <code>ruff</code> implements this it should follow pyright's publicity rules, which are also in a <a href="https://github.com/python/typing/blob/master/docs/source/libraries.rst#library-interface-public-and-private-symbols">document</a> in the <code>python/typing</code> repo (though not in a PEP to my knowledge):</p>
<blockquote>
<p>If a py.typed module is present, a type checker will treat all modules within that package (i.e. all files that end in .py or .pyi) as importable unless the file name begins with an underscore. These modules comprise the supported interface for the library.</p>
<p>Each module exposes a set of symbols. Some of these symbols are considered &quot;private‚Äù ‚Äî implementation details that are not part of the library‚Äôs interface. Type checkers can use the following rules to determine which symbols are visible outside of the package.</p>
<ul>
<li>Symbols whose names begin with an underscore (but are not dunder names) are considered private.</li>
<li>Imported symbols are considered private by default. If they use the import A as A (a redundant module alias), from X import A as A (a redundant symbol alias), or from . import A forms, symbol A is not private unless the name begins with an underscore. If a file <strong>init</strong>.py uses form from .A import X, symbol A is treated likewise. If a wildcard import (of the form from X import *) is used, all symbols referenced by the wildcard are not private.</li>
<li>A module can expose an <strong>all</strong> symbol at the module level that provides a list of names that are considered part of the interface. This overrides all other rules above, allowing imported symbols or symbols whose names begin with an underscore to be included in the interface.
Local variables within a function (including nested functions) are always considered private.</li>
</ul>
</blockquote>
<p>Basically a symbol is public if it:</p>
<ul>
<li>is defined inside the module and doesn't have a leading <code>_</code></li>
<li>is a redundantly aliased import</li>
<li>is listed in <code>__all__</code></li>
</ul>
<p>More generally, I'm curious whether ruff ever seeks to depend on a Python environment for import resolution info in the way a tool like <code>pyright</code> does?</p>
<p>My own opinion here is that <code>ruff</code> should probably forgo any rules dependent on import resolution and signature knowledge unless it wants to get fully into the type-checking game. Pylint implements pseudo typechecking and I mostly find it a source of confusion/false positives. Also, figuring out how to implement and configure import resolution is no joke and a significant source of confusion for users.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> removed by @charliermarsh on 2022-12-31 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @charliermarsh on 2022-12-31 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sanmai-NL">@sanmai-NL</a> on 2023-10-04 12:54</div>
            <div class="timeline-body"><p>Publicity rules are perhaps the work of a PR bureau, these things are often named visibility rules in this domain.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2023-10-04 14:44</div>
            <div class="timeline-body"><blockquote>
<p>Publicity rules are perhaps the work of a PR bureau, these things are often named visibility rules in this domain.</p>
</blockquote>
<p>Take it up with the maintainers of python/typing: https://github.com/python/typing/blob/master/docs/source/libraries.rst#library-interface-public-and-private-symbols</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbdchd">@sbdchd</a> on 2024-01-07 03:05</div>
            <div class="timeline-body"><p>I was thinking of an additional feature of this rule where if a variable, type, function isn't referenced in the module and isn't in <code>__all__</code> then it would also be considered unused ‚Äì¬†then <code>ruff</code> would be able to automatically mark and delete the code</p>
<p>Like you can mark all your stuff with <code>_</code> but honestly not ideal, I think using <code>__all__</code> as import / export visibility would be nice</p>
<pre><code class="language-python"># some_module.py
from dataclasses import dataclass

__all__ = ['does_something']


@dataclass
class Result: # unused
     ok: bool
     result: str

def does_something() -&gt; bool: ...

def foo() -&gt; None: ... # unused
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pypa/setuptools/issues/4385.html">pypa/setuptools#4385</a> on 2024-07-08 14:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rsxdalv">@rsxdalv</a> on 2024-07-10 00:37</div>
            <div class="timeline-body"><p>Case in point - this broke torch and setuptools &gt;=70.0.0 installations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">multifile-analysis</span> added by @MichaReiser on 2024-07-10 07:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by @MichaReiser on 2024-10-24 14:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">multifile-analysis</span> removed by @MichaReiser on 2024-10-24 14:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/19559.html">astral-sh/ruff#19559</a> on 2025-07-25 19:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:48 UTC
    </footer>
</body>
</html>
