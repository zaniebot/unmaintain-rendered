<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Not sure I agree with PIE807 - astral-sh/ruff #10141</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Not sure I agree with PIE807</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/10141">#10141</a>
        opened by <a href="https://github.com/ezyang">@ezyang</a>
        on 2024-02-26 20:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/ezyang">@ezyang</a> on 2024-02-26 20:57</div>
            <div class="timeline-body"><p>When I say <code>lambda: {}</code>, it is clear that this callable takes no arguments, and I will raise an error if you pass me arguments. When you transform this into <code>dict</code>, now I could potentially take arguments, and I can only rely on an appropriate type signature to prevent people from inappropriately feeding arguments into this lambda.</p>
<p>cc @Skylion007</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-02-26 23:10</div>
            <div class="timeline-body"><p>Could you provide a full example so people know what this looks like in context?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ezyang">@ezyang</a> on 2024-02-27 04:33</div>
            <div class="timeline-body"><p>Sure thing:</p>
<pre><code>def trace_structured(
    name: str,
    # NB: metadata expected to be dict so adding more info is forward compatible
    # Tuple[str, int] is a special case for string interning
    metadata_fn: Callable[[], Union[Dict[str, Any], Tuple[str, int]]] = dict,
    *,
    payload_fn: Callable[[], Optional[Union[str, object]]] = lambda: None,
    suppress_context: bool = False,
):  
    &quot;&quot;&quot; 
    metadata is an arbitrary JSON compatible struct, but it's expected to not be
    too long (e.g., less than 1MB)
        
    payload is an arbitrary string, which can be arbitrarily long (but expected to have
    newlines so no lines are too long)
    &quot;&quot;&quot; 
    assert &quot;name&quot; not in [&quot;rank&quot;, &quot;frame_id&quot;, &quot;frame_compile_id&quot;, &quot;attempt&quot;]
    assert callable(
        metadata_fn
    ), f&quot;metadata_fn should be callable, but got {type(metadata_fn)}&quot;
    assert callable(
        payload_fn
    ), f&quot;payload_fn should be callable, but got {type(payload_fn)}&quot;
    if trace_log.isEnabledFor(logging.DEBUG):
        record: Dict[str, object] = {}
        record[name] = metadata_fn()
</code></pre>
<p><code>metadata_fn</code> default is the relevant spot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-02-27 08:51</div>
            <div class="timeline-body"><p>Playground for the provided example: <a href="https://play.ruff.rs/1c40b272-2e86-4f11-8dd6-067ffa1969ca">link</a></p>
<p>What I understand is that changing <code>metadata_fn = lambda: {}</code>  to <code>metadata_fn = dict</code> changes the inferred type of <code>metadata_fn</code> from <code>Callable[[], Dict[str, Any]]</code> to whatever signature <code>dict</code> has. This is problematic because:</p>
<ul>
<li>It changes what arguments can be passed when calling the function (only types with the same signature are now valid). Disclaimer: That's what I assume with my TypeScript knowledge, maybe it's different for Python type checkers?</li>
<li>It changes how <code>metadata_fn</code> can be used in the function's body.</li>
</ul>
<p>Ideally, we would only offer the transform when:</p>
<ul>
<li>In a typed code base: If the parameter has a type annotation</li>
<li>In an untyped code base: Always? Although @ezyang has a good point, the function could now be called with arguments.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-02-27 10:53</div>
            <div class="timeline-body"><blockquote>
<p>Hmm...I don't think it changes the inferred type. <code>lambda: {}</code> vs <code>dict</code> is TMU basically the same from the type checker's point of view. You can verify this using <code>reveal_type</code> (mypy).</p>
</blockquote>
<p>@mikeleppane, they're not identical when you're using them as callback functions. You can see here in this mypy playground gist that mypy (correctly) rejects arbitrary keywords being passed to <code>lambda x: {}</code>, whereas it (correctly) accepts arbitrary keywords being passed to <code>dict</code>: https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=3876729523c28764df349c9657bff865</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-02-27 11:02</div>
            <div class="timeline-body"><p>Interestingly, <code>lambda: {}</code> seems, if anything, to be slightly faster, even though it's a pure-Python function whereas the <code>dict</code> constructor is written in C? I assume this is because the <code>dict</code> constructor has to do some pretty complex argument parsing, whereas <code>lambda: {}</code> does not.</p>
<pre><code class="language-sh">% py -m timeit -n 50000000 -s &quot;x = dict&quot; &quot;x()&quot;                            ~/dev
50000000 loops, best of 5: 18.8 nsec per loop
% py -m timeit -n 50000000 -s &quot;x = lambda: {}&quot; &quot;x()&quot;                      ~/dev
50000000 loops, best of 5: 18.2 nsec per loop
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-02-27 11:09</div>
            <div class="timeline-body"><p>I still feel like I prefer <code>dict</code> and <code>list</code> from an aesthetic point of view to <code>lambda: {}</code> and <code>lambda: []</code>, and these are often options that Python programmers forget. So I do feel like PIE807 provides some value here. The performance difference is absolutely tiny, and I'm guessing the difference in the callback signature is <em>probably</em> only going to matter to you if you're the kind of person who's already using type annotations -- in which case, the transformation is likely safe, since if you want to enforce a narrower signature for the callback function, you can easily use type annotations to do so.</p>
<p>That's my opinion -- but the points raised here were definitely interesting to think about. I can definitely see the argument that <code>lambda: {}</code> is more explicit to readers of the code that you should never pass any arguments to the callback function.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ezyang">@ezyang</a> on 2024-02-28 05:12</div>
            <div class="timeline-body"><p>As a Haskeller, I don't mind doing eta reduction as long as the expressions actually mean the same thing... which they don't in this case. I am sympathetic to the defaultdict(lambda: []) case though, which I do agree is far more idiomatic as defaultdict(list). When the lambda is a default argument for the function, I feel matters are different, since it's in a contravariant position rather than a covariant position.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ThiefMaster">@ThiefMaster</a> on 2024-02-28 22:44</div>
            <div class="timeline-body"><p>I disabled <code>PIE807</code> in my codebase for a similar reason: <code>lambda: {}</code> and <code>lambda: []</code> are clear ways of indicating that I'm providing a callable that returns an empty (mutable) object.  In places like Marshmallow schemas (<code>load_default=lambda: []</code> etc.) this is much clearer than <code>load_default=dict</code> which this rule would want me to use.</p>
<p>Is that rule enabled by default though? If not (and I don't think it is!) there's no problem with it IMHO. In my project I explicitly opted into <code>PIE</code>, and I then disabled this particular rule because I don't like it. Seems reasonable to me. If someone likes this suggestion, they are welcome to keep that rule enabled / opt into it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2024-02-29 16:34</div>
            <div class="timeline-body"><p>It's only faster on Python 3.12; on 3.11:</p>
<pre><code class="language-console">$ python3.11 -m timeit -n 50000000 -s &quot;x = dict&quot; &quot;x()&quot;
50000000 loops, best of 5: 45.5 nsec per loop
$ python3.11 -m timeit -n 50000000 -s &quot;x = lambda: {}&quot; &quot;x()&quot;
50000000 loops, best of 5: 48.3 nsec per loop
</code></pre>
<p>On 3.12, it is a bit faster:</p>
<pre><code class="language-console">$ python3.12 -m timeit -n 50000000 -s &quot;x = dict&quot; &quot;x()&quot;
50000000 loops, best of 5: 49.4 nsec per loop
$ python3.12 -m timeit -n 50000000 -s &quot;x = lambda: {}&quot; &quot;x()&quot;
50000000 loops, best of 5: 44.7 nsec per loop
</code></pre>
<p>It might be taking advantage of the fact that <code>{}</code> is about twice as fast as <code>dict()</code> as it avoids the function lookup overhead (like how <code>f&quot;{x}&quot;</code> is faster than <code>str(x)</code>), it seems 3.12 optimizes on the lambda just a bit better, perhaps. Also benchmarks at this level are pretty tricky.</p>
<p>For fun, I checked 3.13a3 with nogil and JIT enabled, and it seems the dict one has gone up:</p>
<pre><code class="language-console">$ PYTHON_CONFIGURE_OPTS='--enable-optimizations --with-lto --enable-experimental-jit --disable-gil' PYTHON_CFLAGS='-march=native -mtune=native' pyenv install 3.13.0a3
$ ~/.pyenv/versions/3.13.0a3/bin/python -m timeit -n 50000000 -s &quot;x = dict&quot; &quot;x()&quot;
50000000 loops, best of 5: 62.9 nsec per loop
$ ~/.pyenv/versions/3.13.0a3/bin/python -m timeit -n 50000000 -s &quot;x = lambda: {}&quot; &quot;x()&quot;
50000000 loops, best of 5: 49.1 nsec per loop
</code></pre>
<p>I like &quot;dict&quot; better (once you get used to functions as objects), just was curious when I saw the perf comparison.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-02-29 16:37</div>
            <div class="timeline-body"><blockquote>
<p>For fun, I checked 3.13a3 with nogil and JIT enabled</p>
</blockquote>
<p>heh, I think the JIT might still make things <em>slower</em> on <code>main</code> -- be careful there ;) I think Brandt deliberately merged a very basic JIT to start off with so that we could have something in CPython that we could incrementally improve and optimize</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-03-11 17:40</div>
            <div class="timeline-body"><p>Is the open question here whether we should reduce the scope of <code>PIE807</code>? What specific case would we no longer enforce?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @zanieb on 2024-03-11 17:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @zanieb on 2024-03-11 17:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:12 UTC
    </footer>
</body>
</html>
