<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement flake8-type-checking - astral-sh/ruff #1785</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement flake8-type-checking</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/1785">#1785</a>
        opened by <a href="https://github.com/nstarman">@nstarman</a>
        on 2023-01-11 18:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/nstarman">@nstarman</a></div>
            <div class="timeline-body"><p>It&#x27;s a useful tool for determining which imports aren&#x27;t run-time required, reducing import time. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">plugin</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-12 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mkniewallner">@mkniewallner</a> on 2023-01-12 08:01</div>
            <div class="timeline-body"><p>Note that the project was renamed to <a href="https://pypi.org/project/flake8-type-checking/">flake8-type-checking</a> (https://github.com/snok/flake8-type-checking).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/schrockn">@schrockn</a> on 2023-01-19 14:14</div>
            <div class="timeline-body"><p>Came here to file this exact same issue. I had no idea it was supported in flake8. This would be huge for us! cc: cc @smackesey</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Implement flake8-typing-only-imports&quot; to &quot;Implement flake8-type-checking&quot; by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-19 16:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-19 19:10</div>
            <div class="timeline-body"><p>I&#x27;d be very happy to take an initial stab at porting the library. I think most error codes can be auto-fixed, so the ported version might be significantly more useful in this form.</p>
<p>Are there any docs or resources I should read up on before diving into the ruff source code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-19 22:27</div>
            <div class="timeline-body"><p>Awesome! We have some high-level docs on adding new rules in the <a href="https://github.com/charliermarsh/ruff/blob/main/CONTRIBUTING.md#example-adding-a-new-lint-rule">contributing guide</a>. Those are mostly helpful for guiding you on the mechanics of defining the rule, navigating the various files, etc. We&#x27;ll also want to add a module in <code>src/rules/flake8_type_checking</code> to define the rules and settings (you could look at <code>src/rules/flake8_bugbear</code> as an example of the preferred structure).</p>
<p>Beyond the rule logic, I suspect we&#x27;ll also need to adjust <code>src/checkers/ast.rs</code> to track some additional state -- that file is kind of a jumbo AST visitor that calls out to the various rule implementations at the appropriate time, and tracks a bunch of state (e.g., bindings, imports, scopes). For example, I&#x27;m guessing we need to track whether every import usage takes place within a type annotation or not? We already have state on the <code>Checker</code> for detecting whether we&#x27;re <em>in</em> an annotation, and we already have used and unused import tracking, so hopefully those pieces can be leveraged in some way.</p>
<p>My suggestion, just to get familiar with the abstractions and conventions, would be to start with maybe the empty type-checking block rule? It seems like that wouldn&#x27;t require any significant changes to the <code>Checker</code> apart from calling out to <code>src/rules/flake8_type_checking/rules/non_empty_type_checking_block.rs</code> when we process a <code>StmtKind::If</code>. So it&#x27;ll mostly give you a chance to focus on how it all fits together, and lay the groundwork for the plugin itself.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ofek">@ofek</a> on 2023-01-20 16:23</div>
            <div class="timeline-body"><p>Let me know if I can help, I&#x27;m competent in Rust but I&#x27;m not familiar with the code base. This would be an awesome feature and would reduce a lot of cognitive overhead for me personally because for Hatch I painstakingly use conditional and/or lazy imports to reduce CLI startup time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-20 16:26</div>
            <div class="timeline-body"><p>I‚Äôm happy to do a first PR today to lay some of the groundwork here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ofek">@ofek</a> on 2023-01-20 16:34</div>
            <div class="timeline-body"><p>That would be neat since I&#x27;m going to cut a release in a few days which will generate projects that use Ruff and it would be nice to enable this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-20 18:32</div>
            <div class="timeline-body"><p>It might be worth discussing whether the rules are worth porting 1:1 and whether any APIs should change.</p>
<p>For example, <code>TC006</code> has not been as helpful as I&#x27;d hoped. Pycharm&#x27;s built-in type checker (not sure about other IDEs) struggles to understand that stringified imports still need to be there when type checking, so will remove the imports related to casts if you run the auto-clean imports command. I don&#x27;t think I would have accepted that rule had I known about this ahead of time.</p>
<p>The <code>TC</code> error code also conflicts with another plugin, called <a href="https://github.com/guilatrova/tryceratops/tree/main/docs/violations">tryceratops</a>, so it might be nice to opt for another error code here; although it would mean it&#x27;s not a complete drop-in replacement.</p>
<p>I was thinking I&#x27;d sit down an take a stab at a first rule tomorrow. I agree, the empty type checking block is probably a good candidate. If you&#x27;ve already started though @charliermarsh, feel free to go ahead and I&#x27;ll try to get involved after the groundwork has been done :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-20 19:44</div>
            <div class="timeline-body"><p>A couple things:</p>
<ul>
<li>Would definitely like to learn from your experience regarding which rules are reliable or not. Seems like we should omit <code>TC006</code> based those comments.</li>
<li>There&#x27;s some precedent for changing the rule code prefixes. For example, we use <code>TID</code> for <code>flake8-tidy-imports</code>, so that it doesn&#x27;t conflict with the <code>isort</code> rules (under <code>I</code>). We typically do it if a plugin uses a single-letter prefix which is very likely to cause conflicts, or if a plugin conflicts with something we&#x27;ve already implemented (e.g., we used <code>COM</code> for <code>flake8-commas</code> since <code>C</code> conflicts with <code>flake8-comprehensions</code>). In this case, I&#x27;m open to either choice. We could use <code>TC</code>, and then expect <code>tryceratops</code> to use a different code (like <code>TRY</code>) if it gets implemented. Or we could use something like <code>TYP</code>.</li>
</ul>
<p>I <em>may</em> get started on this tonight (at least to setup the plugin scaffolding), but either way, I&#x27;ll post here at the end of the day so that you know whether there&#x27;s any overlap!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-21 03:41</div>
            <div class="timeline-body"><p>@sondrelg - I went ahead and added the scaffolding for the plugin in #2048, along with a basic implementation of <code>TC005</code>. Let me know if you have any questions on that PR.</p>
<p>I think the biggest thing to figure out is what additional state we need to track in <code>Checker</code> to support those other checks. We already track a <code>Binding</code> for every import, which tracks usages (and powers our unused-import check). We probably need to extend that in some way to detect whether the usages occurred in a type definition or not?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-21 09:27</div>
            <div class="timeline-body"><p>The way the plugin works today is by exhaustively checking every element <em>except</em> annotations, then matching imports to &quot;<a href="https://github.com/snok/flake8-type-checking/blob/main/flake8_type_checking/checker.py#L396">uses</a>&quot;. IIRC, most uses are either <code>ast.Value</code>, <code>ast.Name</code>, or <code>ast.Constant</code>. Since annotation slot attributes can be, e.g., <code>ast.Name</code>, we return early when we&#x27;re in an annotation node, in the visitor.</p>
<p>It&#x27;s also important to map the line start/end of all type checking blocks, since use of a guarded import within the scope of that guard, is fine:</p>
<pre><code>from typing import TYPE_CHECKING as some_alias

if some_alias:
    import pandas as pd

    df = pd.DataFrame()  # this is fine

df = pd.DataFrame()  # this is not
</code></pre>
<p>Then we need a good way of normalizing aliases, if possible. Identifying whether <code>pd.DataFrame</code> means the <code>pandas</code> import was used or not really just boils down to identifying that the pandas import is aliased, then matching that string. Imports, the <code>typing</code> module, and the <code>TYPE_CHECKING</code> value can all be aliased.</p>
<p>Finally there&#x27;s minor things like keeping track of futures imports, function scopes, and classifying imports as local or remote. The exhaustive list of plugin state can be found here: https://github.com/snok/flake8-type-checking/blob/main/flake8_type_checking/checker.py#L372:L434</p>
<p>I&#x27;ll read over the PR now :slightly_smiling_face:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-21 12:37</div>
            <div class="timeline-body"><blockquote>
<p>Then we need a good way of normalizing aliases, if possible. Identifying whether pd.DataFrame means the pandas import was used or not really just boils down to identifying that the pandas import is aliased, then matching that string. Imports, the typing module, and the TYPE_CHECKING value can all be aliased.</p>
</blockquote>
<p>Cool -- we have support for and a pattern for this (<code>checker.resolve_call_path(...)</code> will detect aliases and normalize to the imported path, like <code>[&quot;pd&quot;, &quot;DataFrame&quot;]</code>).</p>
<blockquote>
<p>Finally there&#x27;s minor things like keeping track of futures imports, function scopes, and classifying imports as local or remote.</p>
</blockquote>
<p>üëç We do track future imports and function scopes as <code>Checker</code> state, and we do have logic for classifying imports via stuff in the <code>isort</code> directory. So hopefully we can leverage all that :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-21 19:51</div>
            <div class="timeline-body"><p>Yeah I noticed, that&#x27;s great!</p>
<p>What do you think about import classification? The plugin uses <a href="https://github.com/asottile/classify-imports">classify-imports</a> to distinguish between local imports, builtin imports, and library imports. The rationale behind that mainly being that only local application imports lead to import circularity issues, so for some users it might be nice to limit the linting to that class of imports.</p>
<p>I was thinking I might start taking a stab at porting the import classification logic we need as rust code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-21 20:06</div>
            <div class="timeline-body"><p>Our import classification logic is actually a port of <code>classify-imports</code>, for the most part! (It might deviate in some small ways at this point.) Though we also have support for <code>isort</code>-style <code>known-first-party</code>, etc. That code is in <code>src/rules/isort/categorize.rs</code>, if helpful.</p>
<p>The other question is whether we want to have separate rules for different import classes, as in your existing plugin. I don&#x27;t feel strongly! If we have the ability to categorize imports, then it makes sense to me to support different rules. But I&#x27;m curious if people turns those on and off in practice, what&#x27;s your sense from issues, etc.?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-22 18:55</div>
            <div class="timeline-body"><p>@sondrelg - I realize it&#x27;s probably unhelpful for me to just keep saying &quot;We have something that does X&quot; üòÖ so let me take a second to outline how this plugin might be implemented in a bit of detail... If you&#x27;re still interested, definitely let me know. If not, no worries at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-22 19:17</div>
            <div class="timeline-body"><p>So, for the rules around whether an import should / shouldn&#x27;t be a in <code>TYPE_CHECKING</code> block, we need a few pieces of information:</p>
<ol>
<li>Was the import itself in a type-checking block?</li>
<li>Was the import used in a type annotation?</li>
<li>Was the import used outside of a type annotation? (If an import isn&#x27;t used at all, I think the plugin avoids flagging it?)</li>
</ol>
<p>We probably want to have this information available to use when we run <code>check_dead_scopes</code>, which is also where we flag unused imports.</p>
<p>One way to implement this would be as follows:</p>
<ol>
<li>Add a <code>type_checking_blocks</code> field to <code>Checker</code>. This could be <code>Vec&lt;&amp;&#x27;a Stmt&gt;</code>, or <code>Vec&lt;Range&gt;</code>, and would contain references to the if-blocks or their ranges.</li>
<li>In <code>src/ast/types.rs</code>, we have a <code>Binding</code> struct that represents all bindings, and tracks usages. We could split that into two fields, <code>used_runtime</code> and <code>used_annotation</code>, or even some kind of <code>Usages</code> struct that has <code>runtime</code> and <code>annotation</code> fields, to track the most recent usage at runtime and as an annotation. Alternatively, we could make that a vector, and store all usages. Lots of options... (Note that we have <code>checker.in_annotation</code>, which we can leverage when setting those fields.)</li>
<li>In <code>check_dead_scopes</code>, iterate over all import bindings (see the <code>if self.settings.rules.enabled(&amp;Rule::UnusedImport) { ... }</code> block for an example). For each binding, check its runtime and annotation usages, then check if the binding was created within a type-checking block. (Every <code>Binding</code> has a <code>range</code> field that tells you where it was defined, so we can check if that range is within any of the type-checking blocks, or whatever the exact logic should be).</li>
</ol>
<p>(All of this ignores how we should treat redefinitions, i.e., modules that are imported multiple times.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-23 17:58</div>
            <div class="timeline-body"><p>That seems great.</p>
<blockquote>
<p>If an import isn&#x27;t used at all, I think the plugin avoids flagging it?</p>
</blockquote>
<p>This is true, but has been a bit of a pain to get right. We essentially try to shadow pyflake&#x27;s <code>F401</code> and avoid flagging an error if we suspect <code>F401</code> would have been reported already. This way a user, using default flake8 settings would get one error instead of two. The trade-off is that this requires us to track all annotation values, which we wouldn&#x27;t otherwise have to do iirc.</p>
<blockquote>
<p>Add a <code>type_checking_blocks</code> field to <code>Checker</code></p>
</blockquote>
<p>I think there might also be a need to track function scopes, but perhaps the functionality that hinges on that information can be added later, or done in another way. Essentially I think we handle this case by tracking function scopes:</p>
<pre><code>if TYPE_CHECKING:
    from pandas import DataFrame

foo: DataFrame  # this is fine

def bar():
    from pandas import DataFrame

    baz = DataFrame()  # this is also fine, but only because of the function-scoped import
</code></pre>
<p>This is a bit of a contrived example, but there are cases where this type of behavior can happen; typically in large files with circular import problems.</p>
<hr>
<p>Did you say there is tooling to classify imports as stdlib/application/third-party/future already as well? I know the futures import is mapped :+1:</p>
<p>You are probably familiar, but <code>TC001</code>, <code>TC002</code>, and <code>TC003</code> are the same error, just for different classes of imports.</p>
<hr>
<p>Lastly, I&#x27;d be very happy to write some or most of the code, but to be realistic I think I&#x27;m down to being able to contribute 3-4 hours a week. If that&#x27;s fine, I&#x27;m happy to commit to giving that a go, but if you or anyone else wants to jump on this and get it done, then I&#x27;d of course be happy to help wherever I can, but let you do most of the work :slightly_smiling_face:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-23 18:50</div>
            <div class="timeline-body"><blockquote>
<p>Did you say there is tooling to classify imports as stdlib/application/third-party/future already as well?</p>
</blockquote>
<p>Yeah, it&#x27;s all in <code>src/rules/isort/categorize.rs</code>. It&#x27;s only used for import-sorting right now, but could be extracted out and generalized for this check!</p>
<blockquote>
<p>Lastly, I&#x27;d be very happy to write some or most of the code, but to be realistic I think I&#x27;m down to being able to contribute 3-4 hours a week.</p>
</blockquote>
<p>No prob at all. I may get to it, I may not -- if I do, I&#x27;ll comment here so that we don&#x27;t duplicate work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ngnpope">@ngnpope</a> on 2023-01-24 12:10</div>
            <div class="timeline-body"><blockquote>
<p>For example, TC006 has not been as helpful as I&#x27;d hoped. Pycharm&#x27;s built-in type checker (not sure about other IDEs) struggles to understand that stringified imports still need to be there when type checking, so will remove the imports related to casts if you run the auto-clean imports command. I don&#x27;t think I would have accepted that rule had I known about this ahead of time.</p>
</blockquote>
<p>Yeah. Sorry about that rule @sondrelg. In principle it was a nice idea, but there are certainly problems as you&#x27;ve mentioned that we perhaps didn&#x27;t foresee.</p>
<p>The main thing it trying to achieve was to reduce the runtime performance hit from building complex types when they&#x27;re only relevant for static type checking. An alternative approach is to use type aliases in global scope to avoid the hit for building these complex types repetitively in every function call, loop, or whatever. As such <code>TC006</code> could be ignored for this port, but I wonder if there is some way we can still gain some benefit by highlighting that a cast type is &quot;overly complex&quot; and may benefit from being shoved in a type alias?</p>
<p>Ah, sweet hindsight...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-24 12:58</div>
            <div class="timeline-body"><p>It&#x27;s really only the lack of IDE support that makes it hard to work with in my experience. The rationale for the rule itself was great haha :clap:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-25 04:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-25 04:50</div>
            <div class="timeline-body"><p>Okay, I just knocked this out in #2146 and #2147. It&#x27;ll go out as soon as we can release again (we&#x27;re blocked by PyPI limits right now and waiting for an exemption -- see #2136).</p>
<p>The current version doesn&#x27;t include any autofix capabilities (it&#x27;s challenging because we need to remove imports from one part of the AST and re-add them elsewhere), but I tested on Dagster and the inference seems reliable.</p>
<p>\cc @schrockn @smackesey @ofek</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-25 20:42</div>
            <div class="timeline-body"><p>My only hesitation here is that I used <code>TYP</code> as the prefix, but the codes conflict with <a href="https://github.com/asottile/flake8-typing-imports"><code>flake8-typing-imports</code></a>. I don&#x27;t intend to implement that plugin, but it is weird to have overlapping rule codes. Any other suggestions here? We <em>could</em> use <code>TC</code>, since we used <code>TRY</code> for <code>tryceratops</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-25 20:53</div>
            <div class="timeline-body"><p>On second thought: <code>TC</code> causes the same issue, since it conflicts with the <em>actual</em> <code>tryceratops</code>. So <code>noqa: TC002</code> would be interpreted incorrectly in the wild.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-25 21:23</div>
            <div class="timeline-body"><p>I&#x27;m going to rename to <code>TYC</code>, which is an uglier prefix, but it avoids all of the possible conflicts. I&#x27;ve added a redirect from <code>TYP</code> to <code>TYC</code> for now (with a warning), since a few users are already using <code>TYP</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sondrelg">@sondrelg</a> on 2023-01-25 21:39</div>
            <div class="timeline-body"><p>I originally used TCH. Not sure if that&#x27;s taken, but could be appropriate. Ugliest candidate yet though :smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-25 21:46</div>
            <div class="timeline-body"><p>Oh, cool. If you used that originally, let&#x27;s go with that over <code>TYC</code>. Neither seems to be used.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2023-03-10 20:40</div>
            <div class="timeline-body"><p>Nice to see all the progress on this. We haven&#x27;t turned it on yet because I think autofix is essential here (to avoid annoying scenario where you are writing type annotations, import something via auto-complete, then have to go fix a lint error and manually move into a <code>TYPE_CHECKING</code> block). But if this gets autofix and works smoothly, it will provide huge value for us.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/eli-schwartz">@eli-schwartz</a> on 2023-04-27 02:03</div>
            <div class="timeline-body"><blockquote>
<p>Yeah. Sorry about that rule @sondrelg. In principle it was a nice idea, but there are certainly problems as you&#x27;ve mentioned that we perhaps didn&#x27;t foresee.</p>
<p>The main thing it trying to achieve was to reduce the runtime performance hit from building complex types when they&#x27;re only relevant for static type checking. An alternative approach is to use type aliases in global scope to avoid the hit for building these complex types repetitively in every function call, loop, or whatever. [...]</p>
</blockquote>
<p>Please don&#x27;t apologize, I&#x27;m quite fond of that rule and am not worried about pycharm since I don&#x27;t use it. :P</p>
<p>(I would be interested in using it from ruff, if it was implemented. It seems useful to avoid the runtime hit even once.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-03 04:04</div>
            <div class="timeline-body"><p>FYI: autofix for these rules will be enabled in the next release.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/messense">@messense</a> on 2023-07-04 07:16</div>
            <div class="timeline-body"><p>It seems that this doesn&#x27;t work well with <a href="https://github.com/Fatal1ty/mashumaro">mashumaro</a>, I got <code>mashumaro.exceptions.UnresolvedTypeReferenceError</code> when running auto-fixed code.</p>
<pre><code>&lt;string&gt;:2: in to_dict
    ???
.venv/lib/python3.10/site-packages/mashumaro/core/meta/code/builder.py:884: in add_pack_method
    self._add_pack_method_lines(method_name)
.venv/lib/python3.10/site-packages/mashumaro/core/meta/code/builder.py:674: in _add_pack_method_lines
    field_types = self.field_types
.venv/lib/python3.10/site-packages/mashumaro/core/meta/code/builder.py:155: in field_types
    return self.__get_field_types()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = &lt;mashumaro.core.meta.code.builder.CodeBuilder object at 0x7effba8e02e0&gt;, recursive = True, include_extras = False

    def __get_field_types(
        self, recursive: bool = True, include_extras: bool = False
    ) -&gt; typing.Dict[str, typing.Any]:
        fields = {}
        try:
            field_type_hints = typing_extensions.get_type_hints(
                self.cls, include_extras=include_extras
            )
        except NameError as e:
            name = get_name_error_name(e)
&gt;           raise UnresolvedTypeReferenceError(self.cls, name) from None
E           mashumaro.exceptions.UnresolvedTypeReferenceError: Class CrossValidatedModel has unresolved type reference Self in some of its fields
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Fatal1ty">@Fatal1ty</a> on 2023-07-04 08:54</div>
            <div class="timeline-body"><blockquote>
<p>It seems that this doesn&#x27;t work well with <a href="https://github.com/Fatal1ty/mashumaro">mashumaro</a>, I got <code>mashumaro.exceptions.UnresolvedTypeReferenceError</code> when running auto-fixed code.</p>
</blockquote>
<p>That‚Äôs interesting. Can you share the original and auto-fixed reproducible code? I think it‚Äôs worth to create a separate issue for that <a href="https://github.com/Fatal1ty/mashumaro/issues">here</a>.</p>
<p>P.S. From what I‚Äôve read, putting imports to <code>if TYPE_CHECKING</code> block will be a problem not only for mashumaro but for other libraries that operate with types at runtime:</p>
<blockquote>
<p>The plugin assumes that the imports you only use for type hinting are not required at runtime.</p>
</blockquote>
<p>This assumption can‚Äôt be applied to all the existing code, so this dangerous feature in auto-fixing must be disabled by default.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:29 UTC
    </footer>
</body>
</html>
