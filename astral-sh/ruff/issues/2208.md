```yaml
number: 2208
title: "B020 false positive: for foo.bar in baz"
type: issue
state: open
author: spaceone
labels:
  - rule
  - needs-decision
assignees: []
created_at: 2023-01-26T17:57:29Z
updated_at: 2025-10-06T10:23:37Z
url: https://github.com/astral-sh/ruff/issues/2208
synced_at: 2026-01-10T01:56:45Z
```

# B020 false positive: for foo.bar in baz

---

_Issue opened by @spaceone on 2023-01-26 17:57_

```
for server, struct in self.versions(start, end, for_mirror_list):
    for struct.arch in sorted(struct.ARCHS):
        yield struct.deb(server)
```
is false-positive reported as B020 loop-variable-overrides-iterator.

---

_Comment by @sciyoshi on 2023-01-26 18:50_

Could be fixed for this example by skipping `Attribute`s in the B020 name finder, but I would argue that this iteration pattern is unclear and would warrant a linter warning. See also upstream discussion here: https://github.com/PyCQA/flake8-bugbear/issues/248

---

_Label `question` added by @charliermarsh on 2023-01-26 21:27_

---

_Renamed from "B020 false positive" to "B020 false positive: for foo.bar in baz" by @spaceone on 2023-02-22 12:08_

---

_Referenced in [astral-sh/ruff#3022](../../astral-sh/ruff/pulls/3022.md) on 2023-02-22 12:08_

---

_Comment by @matthewlloyd on 2023-02-22 17:58_

Here's a proposal for how to address this.

If we think about a `for` loop target as being like an assignment, we need a rule that triggers if and only if the assignment could change the value of the thing being iterated over (ignoring side effects and other things that would be hard to detect).

Note that Python captures the value of the iterator when it starts the loop, so overwriting it doesn't actually change the behavior and is valid (even common) Python. For example:

```python
In [1]: a = [1, 2, 3]

In [2]: for a in a:
   ...:     print(a)
   ...:
1
2
3
```

Here are some real-world examples where B020 currently triggers. These all look like valid warnings to me:

```python
# corpus/bokeh/src/bokeh/command/subcommands/serve.py
            for path, _, files in os.walk(path):  # unclear code, B020 worthy
                for name in files:

# corpus/bokeh/src/bokeh/plotting/_figure.py
        for kw in double_stack(stackers, "x1", "x2", **kw):  # yikes, B020 please
            result.append(self.harea(**kw))

# corpus/diffusers/src/diffusers/pipelines/stable_diffusion_safe/pipeline_stable_diffusion_safe.py:355
              for idx, has_nsfw_concept in enumerate(has_nsfw_concept):  # unclear code, B020
                    if has_nsfw_concept:

# corpus/pandas/scripts/no_bool_in_generic.py:42
            elif isinstance(value, list):
                for value in reversed(value):  # unclear code, mixes types, merits a B020
                    if isinstance(value, ast.AST):
                        nodes.append((next_in_annotation, value))

# corpus/scipy/scipy/special/_generate_pyx.py:728
            outp = re.sub(r'\*.*', '', ret) + outarg
            ret = ret.replace('*', '')
            for inp, outp in iter_variants(inarg, outp):  # merits B020
                add_variant(func_name, inarg, outarg, ret, inp, outp)

# corpus/scipy/scipy/optimize/_shgo.py:1028
                v = self.HC.V[xl]
                v_near = v.star()
                for v in v.nn:  # merits B020, unclear code
                    v_near = v_near.union(v.nn)

# corpus/scipy/scipy/optimize/_linprog_rs.py:358
    for iteration in range(iteration, maxiter):  # questionable, but I'd say B020 here too; start_iter would be better
```

Given that, and comparing against the false-positive above, I would propose triggering if the target is equal to, or a prefix of, the iterable itself _or_ any components of the iterable (e.g. function arguments, a callee, etc.) that could conceivably be changed by assigning to the target. For example:

```python
# no error
    for struct.arch in sorted(struct.ARCHS):

# B020
for a in a:
    pass

# B020; assigning to a does change a.i
for a in a.i:
    pass

# no error; assigning to a.i does not change a
for a.i in a:
    pass

# B020; no way to know whether fn returns a, and in any case unclear
for a in fn(a):

# B020; target appears as a prefix of a function argument
for a.i in fn(a.i.j):

# all B020
for a in fn(a):
for a in fn(*a):
for a in fn(**a):

# no error
for a.i.j in fn(a.i):

# B020; target appears as a callee
for a in a(ruff):

# B020; target appears as the prefix of a callee
for a.i in a.i.j(ruff):

# no error
for a.i in self.a.i(ruff):

# no error
for self.a in self.b:

# B020
for self in self.b:

# B020
for a[i] in a[i][j]:
for a[i] in fn(**a[i].a[i].ruff[j]):
```

---

_Label `question` removed by @charliermarsh on 2023-07-10 01:20_

---

_Label `rule` added by @charliermarsh on 2023-07-10 01:20_

---

_Label `needs-decision` added by @charliermarsh on 2023-07-10 01:20_

---

_Comment by @ebbek on 2025-10-06 10:23_

Here is an example where the B020 is just plain wrong:
```
"""Ruff bug demo."""

import pathlib.Path


class Scan:
   """Demonstrate what I consider a bug in ruff."""

   def __init__( self, file_name: str ) -> None:
      # Create list of lines from file to be processed
      file = pathlib.Path( file_name )
      self.input_lines = file.read_text().split( "\n" )
      # Current line - used in other member methods
      self._line: str = ""
      # Current line number - used in other member methods
      self._current_line = 0

   def process_file( self ) -> None:
      """
      Scan file line by line.

      The current line (self._line) is used in other member functions
      that are not included here. Ruff complains about:
      "B020 Loop control variable `self` overrides iterable it iterates"
      """
      for self._line in self.input_lines:
         self._current_line += 1
```
Command line:
`ruff check bugdemo.py`

Well, yes, technically it does modify `self`. But not in a way that interacts with the list the `for` loop iterates over.

[bugdemo.py](https://github.com/user-attachments/files/22720010/bugdemo.py)

---
