<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explore alternatives to RustPython for Python AST parsing - astral-sh/ruff #286</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Explore alternatives to RustPython for Python AST parsing</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/286">#286</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2022-09-29 19:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><p>RustPython has been a good foundation, but Ruff is currently limited by what the RustPython parser does and does not support. See: #282, #54, #245.</p>
<p>Since we <em>only</em> need the parser (and RustPython is more ambitious -- they&#x27;re trying to build an entire runtime / interpreter), there may be better options. RustPython is also going to be limited by their use of an LL(1) parser.</p>
<p>We could consider using the following:</p>
<ul>
<li>https://github.com/tree-sitter/tree-sitter-python</li>
<li>https://github.com/pest-parser/pest</li>
<li>https://github.com/kevinmehall/rust-peg</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-29 19:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-30 13:01</div>
            <div class="timeline-body"><p>Alternatively, could we use the CPython AST parser directly? It&#x27;s written in C, AFAIK it should be very fast (perhaps even faster than the RustPython parser).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-30 13:34</div>
            <div class="timeline-body"><p><em>Alternatively</em>, we could try to continue merging improvements back to RustPython.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-30 19:50</div>
            <div class="timeline-body"><p><em>Alternatively</em>, we could revisit the use of LibCST.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-30 22:18</div>
            <div class="timeline-body"><p>LibCST will also likely be <em>required</em> for auto-formatting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-01 21:02</div>
            <div class="timeline-body"><p>tree-sitter is an interesting option (demo in #295). It produces a CST, so we could use it to power auto-formatting. It&#x27;s slower than RustPython but still quite fast (~350ms to iterate over the CPython codebase vs. ~230ms with RustPython). Because it&#x27;s based on S-expressions, it has a whole <a href="https://tree-sitter.github.io/tree-sitter/using-parsers#pattern-matching-with-queries">pattern-matching syntax built-in</a>, which we could use to power plugins...</p>
<p>I think the ergonomics on our end won&#x27;t be great, because it just exposes a single Node type with a <code>kind: &amp;str</code> field, and so we&#x27;d have to do all pattern-matching on string identifiers rather than encoding the AST in a type system. It also may not map 1:1 with the <a href="https://docs.python.org/3/library/ast.html">abstract grammar</a>, I&#x27;m not certain.</p>
<p>Going to explore a few other options, but I&#x27;m intrigued...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-03 21:26</div>
            <div class="timeline-body"><p>There&#x27;s also <a href="https://github.com/ProgVal/rust-python-parser">rust-python-parser</a>, which is based on <a href="https://github.com/Geal/nom">nom</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-03 22:27</div>
            <div class="timeline-body"><p>There&#x27;s also <a href="https://github.com/hydro-project/rust-sitter">rust-sitter</a>, which sits on top of tree-sitter and lets you define the grammar on the Rust side via macros. In return, you get semantically meaningful structs when you generate the parse tree. The downside is that we&#x27;d have to re-write the Python grammar ourselves.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-03 22:28</div>
            <div class="timeline-body"><p>If we were to use tree-sitter, we <em>may</em> want to write code to transform the generated tree into AST types on the Rust side, similar to the <code>RustPython</code> AST. (That would have to be closer to a CST, though.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-05 19:54</div>
            <div class="timeline-body"><p><a href="https://github.com/ProgVal/rust-python-parser">rust-python-parser</a> takes ~480ms (vs. 280ms for RustPython&#x27;s parser) and fails on these files:</p>
<pre><code>resources/test/cpython/Lib/_compression.py
resources/test/cpython/Lib/ast.py
resources/test/cpython/Lib/contextlib.py
resources/test/cpython/Lib/distutils/tests/test_sysconfig.py
resources/test/cpython/Lib/idlelib/colorizer.py
resources/test/cpython/Lib/idlelib/idle_test/mock_tk.py
resources/test/cpython/Lib/idlelib/pyparse.py
resources/test/cpython/Lib/idlelib/replace.py
resources/test/cpython/Lib/idlelib/run.py
resources/test/cpython/Lib/importlib/_bootstrap.py
resources/test/cpython/Lib/lib2to3/tests/data/py3_test_grammar.py
resources/test/cpython/Lib/linecache.py
resources/test/cpython/Lib/logging/__init__.py
resources/test/cpython/Lib/test/coding20731.py
resources/test/cpython/Lib/test/test_asyncio/test_locks.py
resources/test/cpython/Lib/test/test_asyncio/test_pep492.py
resources/test/cpython/Lib/test/test_asyncio/test_server.py
resources/test/cpython/Lib/test/test_contextlib_async.py
resources/test/cpython/Lib/test/test_coroutines.py
resources/test/cpython/Lib/test/test_dis.py
resources/test/cpython/Lib/test/test_format.py
resources/test/cpython/Lib/test/test_pkgutil.py
resources/test/cpython/Lib/test/test_sys_settrace.py
resources/test/cpython/Lib/test/test_types.py
resources/test/cpython/Lib/test/test_typing.py
resources/test/cpython/Lib/unittest/test/testmock/testasync.py
resources/test/cpython/Lib/zoneinfo/_zoneinfo.py
resources/test/cpython/Tools/c-analyzer/c_parser/preprocessor/__init__.py
resources/test/cpython/Tools/scripts/stable_abi.py
resources/test/cpython/Tools/unicode/makeunicodedata.py
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Replace RustPython for Python AST parsing&quot; to &quot;Explore alternatives to RustPython for Python AST parsing&quot; by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-18 21:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 01:37</div>
            <div class="timeline-body"><p>Ok, time for me to revive this thread and start thinking on the right long-term parser strategy. We need to support the 3.10 constructs!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 02:32</div>
            <div class="timeline-body"><p>I&#x27;m strongly considering writing a new parser atop <a href="https://github.com/kevinmehall/rust-peg">rust-peg</a> or <a href="https://github.com/Geal/nom">nom</a> that adheres to the RustPython AST interface.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 03:33</div>
            <div class="timeline-body"><p>@Seamooo - Do you have any thoughts on or interest in working on this too?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Seamooo">@Seamooo</a> on 2022-11-22 04:29</div>
            <div class="timeline-body"><p>Definitely have some interest in this area. A couple of comments as I&#x27;ve been going down various rabbit holes of python parser implementations:</p>
<ul>
<li>The parser should be built from the CPython PEG, directly transpiled into either an equivalent grammar or used via proc_macro to generate the parser<ul>
<li>Run into a lot of grammar specifications with weird FIXMEs about multiple edge cases because their grammar attempted to be a superset of CPython&#x27;s, that didn&#x27;t quite reduce down to the same grammar.</li>
</ul>
</li>
<li>proc_macro gives the ability to generate a perfect hash function for a set of keywords at compile time</li>
<li>rust-peg seems to be an excellent compromise between exploiting the lower-bound time complexity for Packrat parsers without explicitly requiring caching every match, allowing multiple matches rather than lookups for manual performance tuning</li>
<li>rust-peg also has the necessary extensions to the formalised PEG grammar such that implementing the python grammar is possible</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Seamooo">@Seamooo</a> on 2022-11-22 04:32</div>
            <div class="timeline-body"><p>Ideally when <a href="https://github.com/charliermarsh/ruff/pull/742">charliermarsh/ruff#742</a> becomes mergeable, implementing those traits for the IR output by the parser would make it immediately useable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 04:52</div>
            <div class="timeline-body"><p>Yeah rust-peg does look good, and I believe that&#x27;s what LibCST uses. My only hesitation there is that the LibCST parser is really slow compared to the RustPython parser? But I don&#x27;t know how much, if any, of that is due to rust-peg. This is just based on the fixtures in the LibCST codebase:</p>
<pre><code>rust_python_parse/all   time:   [289.30 µs 289.96 µs 290.64 µs]
                        change: [-4.8537% -4.5331% -4.2286%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 23 outliers among 100 measurements (23.00%)
  11 (11.00%) low mild
  2 (2.00%) high mild
  10 (10.00%) high severe

parse/all               time:   [1.7676 ms 1.7953 ms 1.8408 ms]
                        change: [-7.9448% -7.2284% -6.1601%] (p = 0.00 &lt; 0.05)
                        Performance has improved.
Found 10 outliers among 100 measurements (10.00%)
  7 (7.00%) high mild
  3 (3.00%) high severe

parse_into_cst/all      time:   [2.2262 ms 2.2477 ms 2.2723 ms]
                        change: [-2.7483% -0.8482% +0.8620%] (p = 0.40 &gt; 0.05)
                        No change in performance detected.
Found 3 outliers among 100 measurements (3.00%)
  2 (2.00%) high mild
  1 (1.00%) high severe
</code></pre>
<p>(<code>rust_python_parse/all</code> is the RustPython parser, <code>parse/all</code> is the LibCST parser without inflation, and <code>parse_into_cst/all</code> is the LibCST parser with inflation.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 04:52</div>
            <div class="timeline-body"><p>(And agreed on #742.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 15:52</div>
            <div class="timeline-body"><p>Perhaps we could extend <code>pegen</code> with a Rust target based on <code>rust-peg</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/isidentical">@isidentical</a> on 2022-11-22 17:53</div>
            <div class="timeline-body"><p>CC: @davidhalter (I think you were working on a Rust-based Fast Python Parser [?])</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 19:15</div>
            <div class="timeline-body"><p>I&#x27;m going to start playing around with a straight port of pegen to Rust. (Or, more specifically, modifying pegen to output a Rust target, which IIUC will also require rewriting the Python code from <code>data/python.gram</code> in Rust.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/davidhalter">@davidhalter</a> on 2022-11-22 23:26</div>
            <div class="timeline-body"><p>Thanks for bringing this up @isidentical.</p>
<p>I have indeed written a Python parser in Rust. But I do not feel comfortable sharing it yet. While it&#x27;s faster than any other Python parser I have seen, it&#x27;s a bit rough around error recovery and few other things, but generally parses all valid 3.10 Python programs (AFAIK). So if I ever release it, I&#x27;m happy to let you guys know.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 23:43</div>
            <div class="timeline-body"><p>Thanks @davidhalter! Super cool. Would love to see it if you ever release it.</p>
<p>If you don&#x27;t mind sharing: did you write it from scratch? Or is it built atop a parser generator?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-23 04:53</div>
            <div class="timeline-body"><p>(I started on this in earnest tonight, I don&#x27;t know if it will prove to be the right approach but the lower bound is that I learn a lot.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/davidhalter">@davidhalter</a> on 2022-11-23 18:11</div>
            <div class="timeline-body"><p>@charliermarsh Yes I wrote it from scratch, it is a kind of weird mixture of LL and PEG, it&#x27;s also a parser generator. I essentially pass it a slightly modified version of the official EBNF grammar.</p>
<p>I personally love writing parser generators, so when the opportunity presented itself, I took it :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-26 15:03</div>
            <div class="timeline-body"><p>@Seamooo - Do you have any interest in collaborating w/ me on the Rust port of pegen? It&#x27;s a private repo right now but would be happy to add you and talk about how I&#x27;m iterating on it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Seamooo">@Seamooo</a> on 2022-11-27 03:00</div>
            <div class="timeline-body"><p>Definitely would be interested</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-27 03:34</div>
            <div class="timeline-body"><p>@Seamooo - Added you, repo is rough but your help is very welcome!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljodal">@ljodal</a> on 2022-12-03 19:25</div>
            <div class="timeline-body"><p>I&#x27;d love (read) access as well, if possible. I don&#x27;t think I&#x27;m much help in contributing, but I&#x27;ve been looking at <code>rust-peg</code> to generate a Python-compatible ast. My rust knowledge isn&#x27;t there yet though, so I&#x27;m finding it a bit hard to get going (I have a working POC with a few manually defined nodes, but I don&#x27;t think that&#x27;ll tell us anything useful about the performance hit).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-03 19:30</div>
            <div class="timeline-body"><p>@ljodal - Added! Would love to have any help / feedback.</p>
<p>(Anyone is welcome to be added, I&#x27;m just avoiding making it totally public while it&#x27;s still in such an incomplete state.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DimitrisJim">@DimitrisJim</a> on 2022-12-12 12:22</div>
            <div class="timeline-body"><blockquote>
<p>Anyone is welcome to be added</p>
</blockquote>
<p>I&#x27;d like to take you up on that invitation if the attempt is still ongoing :-). We&#x27;ve recently been thinking of doing the same with RustPython&#x27;s parser, porting <code>pegen</code> would just reduce the differences between grammar files between it and CPython, making syncing with it much easier. Not sure how much time I have lying around but I&#x27;d help as I could.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-12 13:42</div>
            <div class="timeline-body"><p>@DimitrisJim - Added! You&#x27;ll be able to tell from the contribution dates, but I haven&#x27;t been able to push on it as much as I&#x27;d like lately (just other Ruff work taking priority). Any / all help or feedback welcome.</p>
<p>While you&#x27;re here: to be clear, my preference would be to continue using the RustPython parser :) The goal of this task is, implicitly, to remove the parser as the bottleneck for what Ruff can support, i.e., to get us to a point where the parser can support all current language features.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fanninpm">@fanninpm</a> on 2022-12-12 21:26</div>
            <div class="timeline-body"><blockquote>
<p>Rust port of pegen</p>
</blockquote>
<p>I was thinking of adding a <code>rust_generator.py</code> file to CPython&#x27;s copy of pegen, but I didn&#x27;t quite know where to begin.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-12 21:28</div>
            <div class="timeline-body"><p>@fanninpm - I added you to my <code>rust-pegen</code> project. Feel free to collaborate there or use it as knowledge / inspiration or whatever is most useful. It adds a <code>rust_generator.py</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-12 21:29</div>
            <div class="timeline-body"><p>There&#x27;s also a PEG grammar (https://github.com/charliermarsh/rust-pegen/blob/main/pegen/data/rust.gram) (has to differ from the Python grammar because the PEG grammars include actual code). The generated code is <a href="https://github.com/charliermarsh/rust-pegen/blob/main/pegen/data/rust_parser.rs">here</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> removed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-31 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-31 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fanninpm">@fanninpm</a> on 2023-01-06 12:12</div>
            <div class="timeline-body"><p>@qingshi163 what do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-06 12:42</div>
            <div class="timeline-body"><p>As an update: my current hope here is to continue to use RustPython, especially since there&#x27;s been a lot of good progress in the parser recently, although structural pattern matching in some form is still the biggest hurdle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/LucianU">@LucianU</a> on 2023-01-27 07:29</div>
            <div class="timeline-body"><p>What would be the downside to using the CPython AST parser directly, since that is guaranteed to always be up-to-date?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2023-01-31 18:33</div>
            <div class="timeline-body"><p>The big one I think is that CPython’s AST doesn’t seem to have all the formatting information (whitespace, comments) stored. That’s why CST parsers exist, like RustPython’s and <a href="https://github.com/Instagram/LibCST">LibCST</a> (which is written in Rust, but as said <a href="https://github.com/charliermarsh/ruff/issues/286#issuecomment-1323061200">above</a>, seems to be slow). I’m pretty sure Ruff needs this information to operate on comments and to do autofixes without mangling comments and whitespace. (Actually, I think the old Parser created an intermediate CST, but the new one doesn’t anymore)</p>
<p>If a well maintained, fast CST library written in C existed, and we rephrased the question to “why not use that C library”, I think there would be two ways to do it, each with their downside:</p>
<ol>
<li>When directly using its data structures, it would be difficult to safely manipulate on the CST (necessary for auto fixes).</li>
<li>When converting its data structures to Rust, there’s Rust code to maintain again (not a big problem, the data structures shouldn’t change too much), and there’s a performance hit (probably not too big either)</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-31 19:06</div>
            <div class="timeline-body"><p>Interestingly, RustPython&#x27;s AST doesn&#x27;t include any CST-like information -- it&#x27;s very similar to the CPython AST. We get comments and other non-AST tokens from the token stream directly (comments are included in the token stream, but <em>not</em> in the AST).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-31 19:10</div>
            <div class="timeline-body"><p>To me the downsides to using the CPython AST parser are as follows:</p>
<ol>
<li>We need to figure out how to extract it from CPython as a useable standalone module (presumedly solvable but not something I&#x27;ve really investigated).</li>
<li>We need to figure out how to do the FFI between Rust and C (also presumedly solvable, but also not my strength).</li>
<li>It makes it much more difficult for us to ever use a specialized parser or AST representation for Ruff. RustPython doesn&#x27;t necessarily solve this either, but I suspect that Ruff could benefit a lot from having its own parser that was written specifically Ruff (and similar use-cases) -- perhaps something that <em>does</em> produce a CST, or something that&#x27;s optimized for the kinds of operations we perform.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/LucianU">@LucianU</a> on 2023-02-01 08:39</div>
            <div class="timeline-body"><p>So, as far as I understand, there are several things here. Ruff needs a CST representation of Python.
CPython doesn&#x27;t have one. RustPython doesn&#x27;t have one either.</p>
<p>The existing solution is LibCST which is slow. Could the reason for its slowness be the fact that it does more work?
My understanding is that a CST contains more information than an AST.</p>
<p>So, I see a new question:
Which solution is more appropriate:</p>
<ul>
<li>the current one that uses an AST parser and takes non-AST tokens from the stream OR</li>
<li>a proper CST parser?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-28 22:50</div>
            <div class="timeline-body"><p>We&#x27;ve continued to improve the RustPython parser and it&#x27;s working well for us! Some of these questions are coming up again with the autoformatter, where I have to map the AST to a CST by enriching it with information derived from the token stream.</p>
<p>In that context, I&#x27;m mostly focused right now on the CST representation itself and not the process by which it&#x27;s parsed / extracted, which I&#x27;m punting until later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-18 15:55</div>
            <div class="timeline-body"><p>I&#x27;m going to close this for now, as we&#x27;re continuing to use and contribute to the RustPython parser. Nothing actionable here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-18 15:55</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:26 UTC
    </footer>
</body>
</html>
