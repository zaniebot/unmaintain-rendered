<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TC004 diagnostics/docs should clarify that type hints can be executed at run-time - astral-sh/ruff #16490</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>TC004 diagnostics/docs should clarify that type hints can be executed at run-time</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/16490">#16490</a>
        opened by <a href="https://github.com/nathanjmcdougall">@nathanjmcdougall</a>
        on 2025-03-04 08:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/nathanjmcdougall">@nathanjmcdougall</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>For me, <code>TC004</code> fairly consistently gives false positives when the guarded import is used for return types.</p>
<p>For example:</p>
<pre><code>from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import abc


def bar() -&gt; abc.ABC | None:
    return None
</code></pre>
<p>Running <code> ruff check --isolated --select TC004</code> gives the following output:</p>
<pre><code>main.py:4:12: TC004 Move import `abc` out of type-checking block. Import is used for more than type hinting.
  |
3 | if TYPE_CHECKING:
4 |     import abc
  |            ^^^ TC004
  |
  = help: Move out of type-checking block

Found 1 error.
No fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option).
</code></pre>
<h3>Version</h3>
<p>ruff 0.9.9 (091d0af2a 2025-02-28)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-03-04 09:37</div>
            <div class="timeline-body"><p>This looks correct to me because you aren't using <code>from __future__ import annotations</code></p>
<p>From the <code>from __future__ import annotations</code> <a href="https://peps.python.org/pep-0563/">PEP</a></p>
<blockquote>
<p>type hints are executed at module import time, which is not computationally free.</p>
</blockquote>
<p>You can also reproduce this by copying your code snippet into a REPL</p>
<pre><code class="language-py">&gt;&gt;&gt; from typing import TYPE_CHECKING
...
... if TYPE_CHECKING:
...     import abc
...
...
... def bar() -&gt; abc.ABC | None:
...     return None
...
Traceback (most recent call last):
  File &quot;&lt;python-input-6&gt;&quot;, line 7, in &lt;module&gt;
    def bar() -&gt; abc.ABC | None:
                 ^^^
NameError: name 'abc' is not defined. Did you mean: 'abs'? Or did you forget to import 'abc'?
</code></pre>
<p>However, I do think that the diagnostic could be more helpful or we should at least clarify this case in the rule's documentation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @MichaReiser on 2025-03-04 09:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">diagnostics</span> added by @MichaReiser on 2025-03-04 09:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "TC004 False Positive in return type" to "TC004 diagnositics/docs should clarify that type hints can be executed at run-time" by @nathanjmcdougall on 2025-03-04 11:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "TC004 diagnositics/docs should clarify that type hints can be executed at run-time" to "TC004 diagnostics/docs should clarify that type hints can be executed at run-time" by @AlexWaygood on 2025-03-04 11:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sebastiancruzg">@sebastiancruzg</a> on 2025-06-13 16:46</div>
            <div class="timeline-body"><p>Is it necessary to add <code>from __future__ import annotations</code> even if working on Python 3.12?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nathanjmcdougall">@nathanjmcdougall</a> on 2025-06-13 23:00</div>
            <div class="timeline-body"><p>It is necessary if you want deferred evaluation of annotations. <a href="https://docs.python.org/3.14/whatsnew/3.14.html#pep-649-and-749-deferred-evaluation-of-annotations">It is planned that in Python 3.14</a>, this will become the default behaviour.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spaceone">@spaceone</a> on 2025-10-16 14:53</div>
            <div class="timeline-body"><p>But that would be optional. I think <code>TC004</code>, etc should evaluate <a href="https://docs.astral.sh/ruff/settings/#target-version">target-version</a> to detect if <code>from __future__ import annotations</code> is required to be in there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-10-20 07:38</div>
            <div class="timeline-body"><p>@spaceone Right, this is now optional when targeting Python 3.14 (CC: @dylwil3)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-10-20 14:39</div>
            <div class="timeline-body"><blockquote>
<p>I think TC004, etc should evaluate <a href="https://docs.astral.sh/ruff/settings/#target-version">target-version</a> to detect if from <strong>future</strong> import annotations is required to be in there.</p>
</blockquote>
<p>Yes, this already happens implicitly because of the way our semantic model interprets type hints when the <code>target-version</code> is 3.14+.</p>
<pre><code class="language-console">❯ cat tc004.py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import abc


def bar() -&gt; abc.ABC | None:
    return None

❯ ruff check --no-cache --isolated --select TC004 --target-version py313 tc004.py
TC004 Move import `abc` out of type-checking block. Import is used for more than type hinting.
 --&gt; tc004.py:4:12
  |
3 | if TYPE_CHECKING:
4 |     import abc
  |            ^^^
  |
help: Move out of type-checking block

Found 1 error.
No fixes available (1 hidden fix can be enabled with the `--unsafe-fixes` option).

❯ ruff check --no-cache --isolated --select TC004 --target-version py314 tc004.py
All checks passed!
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-30 19:25</div>
            <div class="timeline-body"><p>I came across this issue today and couldn't resist prototyping a diagnostic with a secondary annotation. Here's what I came up with (without modifying the original message):</p>
<pre><code>TC004 [*] Move import `datetime` out of type-checking block. Import is used for more than type hinting.
  --&gt; app.py:9:12
   |
 8 | if TYPE_CHECKING:
 9 |     import datetime  # TC004
   |            ^^^^^^^^
10 |     from array import array  # TC004
   |
  ::: app.py:20:25
   |
19 | @app.put(&quot;/datetime&quot;)
20 | def set_datetime(value: datetime.datetime):
   |                         -------- This use is required at runtime
21 |     pass
   |
help: Move out of type-checking block
</code></pre>
<p>This seems like a good use for a secondary annotation or a sub-diagnostic since the import and use are likely to be far apart. I don't think that fully resolves the issue, but it might help a little.</p>
<p>Storing this information in <code>ImportBinding</code> doesn't necessarily feel like the best approach, but here's the diff I threw together in case we want to pursue this in the future.</p>
<details><summary>Details</summary>
<p>

<pre><code class="language-diff">diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs b/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs
index 2f4abad7d2..2cc606855f 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/imports.rs
@@ -1,4 +1,4 @@
-use ruff_python_semantic::{AnyImport, Binding, ResolvedReferenceId};
+use ruff_python_semantic::{AnyImport, Binding, ResolvedReference, ResolvedReferenceId};
 use ruff_text_size::{Ranged, TextRange};
 
 /// An import with its surrounding context.
@@ -15,6 +15,7 @@ pub(crate) struct ImportBinding&lt;'a&gt; {
     pub(crate) parent_range: Option&lt;TextRange&gt;,
     /// Whether the binding needs `from __future__ import annotations` to be imported.
     pub(crate) needs_future_import: bool,
+    pub(crate) runtime_reference: Option&lt;&amp;'a ResolvedReference&gt;,
 }
 
 impl Ranged for ImportBinding&lt;'_&gt; {
diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs b/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs
index e96b3b7bc6..010a3c4eeb 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs
@@ -123,11 +123,12 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &amp;Checker, scope: &amp;S
         };
 
         if binding.context.is_typing()
-            &amp;&amp; binding.references().any(|reference_id| {
+            &amp;&amp; let Some(runtime_reference) = binding.references().find_map(|reference_id| {
                 let reference = checker.semantic().reference(reference_id);
 
-                reference.in_runtime_context()
-                    &amp;&amp; !(ignore_dunder_all_references &amp;&amp; reference.in_dunder_all_definition())
+                (reference.in_runtime_context()
+                    &amp;&amp; !(ignore_dunder_all_references &amp;&amp; reference.in_dunder_all_definition()))
+                .then_some(reference)
             })
         {
             let Some(node_id) = binding.source else {
@@ -141,6 +142,7 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &amp;Checker, scope: &amp;S
                 range: binding.range(),
                 parent_range: binding.parent_range(checker.semantic()),
                 needs_future_import: false, // TODO(brent) See #19359.
+                runtime_reference: Some(runtime_reference),
             };
 
             if checker.rule_is_ignored(Rule::RuntimeImportInTypeCheckingBlock, import.start())
@@ -197,6 +199,7 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &amp;Checker, scope: &amp;S
                     import,
                     range,
                     parent_range,
+                    runtime_reference,
                     ..
                 } in imports
                 {
@@ -207,6 +210,12 @@ pub(crate) fn runtime_import_in_type_checking_block(checker: &amp;Checker, scope: &amp;S
                         },
                         range,
                     );
+                    if let Some(runtime_reference) = runtime_reference {
+                        diagnostic.secondary_annotation(
+                            &quot;This use is required at runtime&quot;,
+                            runtime_reference,
+                        );
+                    }
                     if let Some(range) = parent_range {
                         diagnostic.set_parent(range.start());
                     }
diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs b/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs
index f1918596b1..f6032d184f 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/rules/typing_only_runtime_import.rs
@@ -374,6 +374,7 @@ pub(crate) fn typing_only_runtime_import(
             range: binding.range(),
             parent_range: binding.parent_range(checker.semantic()),
             needs_future_import,
+            runtime_reference: None,
         };
 
         if checker.rule_is_ignored(rule_for(import_type), import.start())
</code></pre>
</p>
</details> 

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-31 07:55</div>
            <div class="timeline-body"><p>This looks nice!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:52:19 UTC
    </footer>
</body>
</html>
