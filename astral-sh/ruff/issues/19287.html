<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[pyupgrade] - UP046 incorrectly erroring for constrained TypeVars being used - astral-sh/ruff #19287</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[pyupgrade] - UP046 incorrectly erroring for constrained TypeVars being used</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/19287">#19287</a>
        opened by <a href="https://github.com/cgearing">@cgearing</a>
        on 2025-07-11 15:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/cgearing">@cgearing</a> on 2025-07-11 15:49</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Hi, thanks for your hard work on Ruff!</p>
<p>We recently upgraded to the latest version and have been working through the errors generated relating to pyupgrade and the new <code>type</code> expression syntax, however we are seeing some tricky behaviour that we think might need looking at.</p>
<p>MRE below:</p>
<pre><code class="language-python">from typing import Generic, TypeVar


class One: ...


class Two: ...


EitherT = TypeVar(&quot;EitherT&quot;, One, Two)


class Test(Generic[EitherT]):...

</code></pre>
<p>Running <code>ruff check --select=UP</code> on this will give the following error:</p>
<pre><code class="language-bash">min.py:13:12: UP046 Generic class `Test` uses `Generic` subclass instead of type parameters
   |
13 | class Test(Generic[EitherT]):...
   |            ^^^^^^^^^^^^^^^^ UP046
   |
   = help: Use type parameters
</code></pre>
<p>However, TypeVars don't seem to be valid to be used in the new syntax, nor can you create reusable constrained type definitions using the new <code>type</code> expression, you would have to do the below:</p>
<pre><code class="language-python">
from typing import TypeVar, Generic

class One: ...

class Two: ...

class Test[T: (One, Two)]: ...
</code></pre>
<p>Is it intended that this error should just be ignored wherever a constrained TypeVar needs to be used across multiple sites?</p>
<h3>Version</h3>
<p>ruff 0.12.2</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-07-11 19:02</div>
            <div class="timeline-body"><p>Thanks for the kind words!</p>
<p>@AlexWaygood gave a really nice answer on a closely-related issue <a href="https://github.com/astral-sh/ruff/issues/18894#issuecomment-2996595541">here</a> with an example for a reusable type alias with bounds, but I'm not sure it extends to constrained type variables, as you point out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @ntBre on 2025-07-11 19:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-14 08:07</div>
            <div class="timeline-body"><p>I'm not very familiar with Python's type syntax and I'm sure I'm overlooking some subtle behavior but can't you use</p>
<pre><code class="language-py">class One: ...


class Two: ...


type OneOrTwo = One | Two


class Test[EitherT: OneOrTwo]: 
    def a(self, arg: EitherT): pass

    def b(self, arg: EitherT) -&gt; EitherT: pass


test: Test[One] = Test()
test.a(One())
x = test.b(Two()) # errors

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-14 08:22</div>
            <div class="timeline-body"><p>@MichaReiser no â€” that would create a TypeVar with an upper bound rather than a value-constrained TypeVar unfortunately. https://docs.python.org/3/library/typing.html#typing.TypeVar gives some details on the differences in semantics between the two</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cgearing">@cgearing</a> on 2025-07-14 11:04</div>
            <div class="timeline-body"><p>@AlexWaygood would a PR adjusting the behaviour of UP046 to not error when countering a constrained <code>TypeVar</code> be a good approach?  It seems like an oversight in PEP695 that constrained types in the new syntax should be a literal tuple expression, but unless that changes it seems that there is a genuine use-case for keeping <code>class SomeClass(Generic[SomeConstrainedType])</code>.</p>
<p>I'd be happy to have a go if so!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-14 16:45</div>
            <div class="timeline-body"><p>I agree that you can't switch from an old-style TypeVar with constraints to a PEP-695-style TypeVar with constraints without adding some degree of code duplication. That's a bit unfortunate.</p>
<p>However, as, PEP-695 <a href="https://peps.python.org/pep-0695/#points-of-confusion">explains</a>:</p>
<blockquote>
<p>The scoping rules for type variables are difficult to understand. Type variables are typically allocated within the global scope, but their semantic meaning is valid only when used within the context of a generic class, function, or type alias. A single runtime instance of a type variable may be reused in multiple generic contexts, and it has a different semantic meaning in each of these contexts. This PEP proposes to eliminate this source of confusion by declaring type parameters at a natural place within a class, function, or type alias declaration statement.</p>
</blockquote>
<p>So you could really think of the whole concept of a &quot;reusable TypeVar&quot; as being deprecated, since it very often causes confusion. Even <code>typing.AnyStr</code> (which is also a constrained TypeVar, and is perhaps the most often used &quot;reusable TypeVar&quot;) <a href="https://github.com/python/cpython/issues/105578">is now deprecated</a>. If you want to have clearly scoped TypeVars that use modern syntax, and you only support Python 3.12+, I think you should aim to use PEP-695 syntax wherever possible, even if it adds a bit of duplication to your code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2025-07-24 11:59</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:18 UTC
    </footer>
</body>
</html>
