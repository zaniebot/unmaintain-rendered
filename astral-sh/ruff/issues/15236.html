<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`line-too-long` (`E501`) - false positive on import statements from long module names where it's impossible to fix - astral-sh/ruff #15236</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>`line-too-long` (`E501`) - false positive on import statements from long module names where it's impossible to fix</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/15236">#15236</a>
        opened by <a href="https://github.com/DetachHead">@DetachHead</a>
        on 2025-01-03 06:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-01-03 06:08</div>
            <div class="timeline-body"><p>if a line contains an import statement from a very long module path, it triggers <code>E501</code>, even though there's no way to fix it as far as i know:</p>
<pre><code class="language-py">from asdfasasd.asdfasdf.asdfasdfsa.dfasdfasdfasdf.asdfasdfasdf.asdfasdfasdf.asdfasdfasdf.asdfsasdfasdf import ( # error: E501
    foo,
)
</code></pre>
<p>https://play.ruff.rs/93d32aef-cefb-41f2-8205-e05bbea8ba28?secondary=Format</p>
<p>ruff should be able to determine that this situation is unavoidable and therefore should not report the error. it already does this in some cases for example comments/docstrings with long URLs</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-03 08:17</div>
            <div class="timeline-body"><p>You can use line continuation if you really wanted to avoid the E501 violation:</p>
<pre><code class="language-python">from asdfasasd.asdfasdf.asdfasdfsa.dfasdfasdfasdf\
    .asdfasdfasdf.asdfasdfasdf.asdfasdfasdf\
    .asdfsasdfasdf import foo
</code></pre>
<p>But that's not something we want to encourage (especially because the formatter removes the line continuations again).</p>
<p>That's why I think it's correct to say that you can't change anything on the import side. However, you can change the module structure to reduce the nesting, which will make it easier to import the module.</p>
<p>I did some quick search and long parenthesized imports don't seem that common (<a href="https://sourcegraph.com/search?q=context%3Aglobal+lang%3APython+from%5Cs%2B%5Ba-zA-Z%5C.%5D%2B%5Cs%2Bimport%5Cs%2B%5C%28%5Cs%2B%23%5Cs%2Bnoqa%3A%5Cs%2BE501%5Cn%5Ba-zA-Z%2C%5Cs%5D%2B%5C%29&amp;patternType=regexp&amp;sm=0">source</a>) or my search is too strict. Suppressions for single-line imports is more common (<a href="https://sourcegraph.com/search?q=context%3Aglobal+lang%3APython+from%5Cs%2B%5Ba-zA-Z%5C.%5D%2B%5Cs%2Bimport%5Cs%2B%5Ba-zA-Z%2C%5D%2B%5Cs%2B%23%5Cs%2Bnoqa%3A%5Cs%2BE501&amp;patternType=regexp&amp;sm=0">source</a>).</p>
<p>There are many more cases where Python doesn't provide a way for splitting an expression unlike other languages.</p>
<pre><code>class AVeryLongClassNameAndTheresNothingYouCanDoAboutIt: # E501
   pass

a = (1000000000_00) # noqa: E501
</code></pre>
<p>but the import case is probably the most common.</p>
<p>Ultimately this is somewhat related to https://github.com/astral-sh/ruff/issues/8383 and raises the question if we should make E501 token aware. I think we could do so now, because we have cheap access to the token stream.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @MichaReiser on 2025-01-03 08:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-01-03 18:36</div>
            <div class="timeline-body"><p>@MichaReiser Your query is indeed too strict. <a href="https://sourcegraph.com/search?q=context:global+lang:Python+from%5Cs%2B%5Ba-zA-Z0-9_%5C.%5D%2B%5Cs%2Bimport%5Cs*%5C%28%5Cs*%23%5Cs*noqa:%5Cs*E501%5Cn%5Ba-zA-Z0-9_%2C%5Cs%5D%2B%5C%29&amp;patternType=regexp&amp;sm=0">A slightly looser one</a> returns ~800 results.</p>
<pre><code class="language-text">from\s+[a-zA-Z    \.]+\s+import\s+\(\s+#\s+noqa:\s+E501\n[a-zA-Z    ,\s]+\)

from\s+[a-zA-Z0-9_\.]+\s+import\s*\(\s*#\s*noqa:\s*E501\n[a-zA-Z0-9_,\s]+\)
#             ^^^^               ^    ^   ^       ^             ^^^^
</code></pre>
<p><a href="https://sourcegraph.com/search?q=context:global+lang:Python+from%5Cs%2B%5Ba-zA-Z0-9_%5C.%5D%2B%5Cs%2Bimport%5Cs%2B%5Ba-zA-Z0-9_%2C%5D%2B%5Cs*%23%5Cs*noqa:%5Cs*E501&amp;patternType=regexp&amp;sm=0">Same for the other query</a>.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:14 UTC
    </footer>
</body>
</html>
