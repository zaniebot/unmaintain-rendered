<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F841 &quot;Undefined name&quot; false positive in exception-nested-closure - astral-sh/ruff #6878</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>F841 &quot;Undefined name&quot; false positive in exception-nested-closure</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/6878">#6878</a>
        opened by <a href="https://github.com/ndevenish">@ndevenish</a>
        on 2023-08-25 17:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/ndevenish">@ndevenish</a> on 2023-08-25 17:09</div>
            <div class="timeline-body"><p>ruff 0.0.285.</p>
<p>Using an exception value in a nested function erroneously triggers F841 and F821, even though python is fine with the usage.</p>
<p>This same issue occurs in flake8/https://github.com/PyCQA/pyflakes/issues/265; if ruff is aiming for bug-for-bug compatibility then this is working as intended.</p>
<p>Minimal reproduction stolen from that issue as it's shorter than my example (my example was a nested-def; lambda seems to work the same):</p>
<pre><code class="language-python">try:
    assert False
except Exception as e:
    lambda: e
</code></pre>
<pre><code>% ruff t.py
t.py:3:21: F841 [*] Local variable `e` is assigned to but never used
t.py:4:13: F821 Undefined name `e`
Found 2 errors.
[*] 1 potentially fixable with the --fix option.
</code></pre>
<p>Edit: To note that since this is &quot;fixable&quot;, allowing ruff to fix will break the code by removing the <code>as e</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-25 21:25</div>
            <div class="timeline-body"><p>Interesting... I was a little surprised that this code worked at all given the semantics around bound exceptions:</p>
<pre><code class="language-python">try:
    1/0
except Exception as e:
    func = lambda: print(e)
    func()
</code></pre>
<p>But I then realized that this version <em>does</em> lead to a <code>NameError</code> (<code>NameError: name 'e' is not defined</code>):</p>
<pre><code class="language-python">try:
    1/0
except Exception as e:
    func = lambda: print(e)

func()
</code></pre>
<p>Although neither Mypy nor Pyright catch this.</p>
<p>I'm not exactly sure how to handle. I'll have to think on it. My initial reaction is that our behavior is reasonable since the variable could be unbound depending on when the lambda is called, but it would be nice not to remove the <code>as e</code> there when autofixing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @charliermarsh on 2023-08-25 21:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ndevenish">@ndevenish</a> on 2023-08-25 21:56</div>
            <div class="timeline-body"><p>This was obviously a contrived, extremely minimised example case; the linked pyflakes issue noted the same behaviour.</p>
<p>The actual code this was encountered on is below; a sub-function using <a href="https://github.com/Textualize/rich">rich</a> <a href="https://rich.readthedocs.io/en/latest/group.html">group</a> decorator to conveniently wrap a whole set of renderables into a panel - in a name that is never used outside of the exception scope:</p>
<pre><code class="language-python">try:
    ...
except requests.exceptions.HTTPError as e:

    @rich.console.group()
    def _error_output():
        yield Text(str(e), style=&quot;bold red&quot;)
        yield &quot;&quot;
        yield f&quot;The request: {e.request.url}&quot;
        req_text = e.request.body
        if e.request.headers[&quot;content-type&quot;] == &quot;application/json&quot;:
            req_text = JSON(e.request.body)
        yield Padding(req_text, (0, 0, 1, 4))
        yield &quot;Error response:&quot;
        resp_text = e.response.text
        if e.response.headers[&quot;content-type&quot;] == &quot;application/json&quot;:
            resp_text = JSON(e.response.text)
        yield Padding(resp_text, (0, 0, 1, 4))

    print(Panel(_error_output()))
</code></pre>
<p>obviously the code could be written to do this a different way. But it's definitely not an F821 undefined name, or an F841 variable assigned but not used.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-25 22:10</div>
            <div class="timeline-body"><p>Totally understand!</p>
<p>What I'm trying to convey is that it's difficult to guarantee that this is completely safe, as you have to ensure that the function or lambda is only called within the scope of the exception block.</p>
<p>Even in the example above, what if <code>@rich.console.group()</code> stores a reference to the function and executes it at a later point in time? What if <code>_error_output</code> is imported by another module?</p>
<p>Given that Python unbinds <code>e</code> as soon as the exception block exits, I would almost always recommend re-binding <code>e</code> to another variable if you're going to access it in a potentially-deferred manner. Is there any downside to that? I feel like the best we could plausibly do here is detect that <code>e</code> is used in such a context and emit a more targeted diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ndevenish">@ndevenish</a> on 2023-08-25 22:18</div>
            <div class="timeline-body"><p>I could see an “Exception-bound variable used in closure” diagnostic being potentially useful, and easily <code># ignore</code>-a-ble. Perhaps the documentation for the diagnostic could explicitly suggest passing it in as a parameter</p>
<p>That would also solve the problem of <code>—fix</code> outright breaking the code (so would still have to work out how to stop this diagnostic)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-08-26 00:58</div>
            <div class="timeline-body"><p>Interesting example! I think I'd recommend refactoring <code>error_output()</code> to <code>error_to_rich_output(e: Exception)</code> and moving it out of the exception block. Perhaps we should have coverage for this in another rule and/or as Charlie said improve the specificity of this diagnostic but I don't think this is pattern the linter should be expected to be happy with.</p>
<p>For what it's worth, there are a few duplicates reports of this issue over in pyflakes so this is a confusing thing that people encounter.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/FranciscoKnebel">@FranciscoKnebel</a> on 2025-01-03 20:42</div>
            <div class="timeline-body"><p>Had this same error: an except defining a variable, using it inside a lambda and auto-fix breaking the code.
I'm disabling this rule so it doesn't break code and re-adding the removed variable.</p>
<p>I understand it's a bad pattern and the method should be refactored, but the variable <em>exists</em>, so it is a false positive.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ewall-ot">@ewall-ot</a> on 2025-03-07 15:23</div>
            <div class="timeline-body"><p>I'm not sure if this error is related, but I'll mention here I'm seeing F841 (assigned to but never used) triggered as a false alarm in code like this:</p>
<pre><code>try:
    assert False
except Exception as e:
    print(f'Error: {e}')
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-07 17:46</div>
            <div class="timeline-body"><p>@ewall-ot this might be a different issue. In fact, I'm having some trouble triggering F841 on your example with recent versions of ruff:</p>
<pre><code class="language-python"># try.py

def f():
        try:
            assert False
        except Exception as e:
            print(f'Error: {e}')
</code></pre>
<pre><code class="language-shell"># shell output

&gt; ruff check try.py --select F841 --diff
&gt; echo $?
0
</code></pre>
<p>I can reproduce the F841 with the original issue code, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ewall-ot">@ewall-ot</a> on 2025-03-07 18:26</div>
            <div class="timeline-body"><p>Thanks for the response, @ntBre. Sorry, I thought I was on the latest version of ruff but clearly was a bit behind, because sure enough this isn't reproducible on the latest, along with a related one I had noticed (F401 &quot;unused-import&quot; if the imported module was only used inside the f-string).</p>
<p>Nice to see this product under such active development!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:31:07 UTC
    </footer>
</body>
</html>
