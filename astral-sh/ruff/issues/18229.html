<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prefer copy.replace over dataclasses.replace (3.13) - astral-sh/ruff #18229</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Prefer copy.replace over dataclasses.replace (3.13)</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/18229">#18229</a>
        opened by <a href="https://github.com/Jeremiah-England">@Jeremiah-England</a>
        on 2025-05-20 18:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/Jeremiah-England">@Jeremiah-England</a> on 2025-05-20 18:15</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Python 3.13 added the <a href="https://docs.python.org/3/library/copy.html#copy.replace"><code>copy.replace</code></a> function:</p>
<ul>
<li><a href="https://discuss.python.org/t/generalize-replace-function/28511">Discourse thread</a></li>
<li>GitHub PR: https://github.com/python/cpython/pull/108752</li>
</ul>
<p>This new function <em>can</em> replace all of these <a href="https://docs.python.org/3/whatsnew/3.13.html#copy">from What's New 3.13</a>:</p>
<p><img src="https://github.com/user-attachments/assets/4252837b-1ba8-4266-95d2-732567e5d2c5" alt="Image" /></p>
<p>I like this new feature because it consolidates the various replace interfaces. Unfortunately, it is slower in most cases <strong>except for dataclasses</strong>. So I wouldn't necessarily recommend a lint rule encourage it across the board.</p>
<p>However, a lint rule for dataclasses would help this feature gain adoption, so more people would be aware of the consolidation the <code>__replace__</code> dunder offers and use it in their codebases. And I think it is preferable in the case of dataclasses themselves to use the more general function.</p>
<details>
<summary>
Benchmark details
</summary>

<p>Note, this benchmark was generated by Gemini 2.5 pro.</p>
<pre><code>Benchmarking with 100000 iterations per test.

--- FrozenDataclass ---
dataclasses.replace: 0.132023 seconds
copy.replace:        0.132923 seconds
copy.replace is 0.99x slower than dataclasses.replace


--- NonFrozenDataclass ---
dataclasses.replace: 0.092363 seconds
copy.replace:        0.092373 seconds
copy.replace is 1.00x slower than dataclasses.replace


--- datetime.datetime object ---
datetime.replace(): 0.006441 seconds
copy.replace():     0.024414 seconds
copy.replace is 0.26x slower than datetime.replace()


--- collections.namedtuple ---
namedtuple._replace(): 0.046155 seconds
copy.replace():        0.065800 seconds
copy.replace is 0.70x slower than namedtuple._replace()


--- datetime.date object ---
datetime.date.replace(): 0.006121 seconds
copy.replace():            0.021930 seconds
copy.replace is 0.28x slower than datetime.date.replace()


--- datetime.time object ---
datetime.time.replace(): 0.006259 seconds
copy.replace():            0.022275 seconds
copy.replace is 0.28x slower than datetime.time.replace()


--- inspect.Parameter ---
inspect.Parameter.replace(): 0.058636 seconds
copy.replace():                0.079787 seconds
copy.replace is 0.73x slower than inspect.Parameter.replace()


--- inspect.Signature ---
inspect.Signature.replace(): 0.060312 seconds
copy.replace():                0.085842 seconds
copy.replace is 0.70x slower than inspect.Signature.replace()


--- types.SimpleNamespace ---
SimpleNamespace (manual copy): 0.023630 seconds
copy.replace():                  0.029961 seconds
copy.replace is 0.79x slower than manual copy


--- types.CodeType (code object) ---
types.CodeType.replace(): 0.018685 seconds
copy.replace():             0.043076 seconds
copy.replace is 0.43x slower than types.CodeType.replace()
</code></pre>
<pre><code class="language-python">import collections
import copy
import datetime
import inspect
import types
from dataclasses import dataclass
from dataclasses import replace as dc_replace
from timeit import Timer


@dataclass(frozen=True)
class FrozenDataclass:
    a: int
    b: int
    c: str
    d: float
    e: tuple[int, int]


@dataclass(frozen=False)
class NonFrozenDataclass:
    a: int
    b: int
    c: str
    d: float
    e: tuple[int, int]


# Sample records
frozen_record = FrozenDataclass(a=1, b=2, c=&quot;test&quot;, d=3.14, e=(5, 6))
non_frozen_record = NonFrozenDataclass(a=1, b=2, c=&quot;test&quot;, d=3.14, e=(5, 6))

# how many repeats in each timing
iterations = 100_000

print(f&quot;Benchmarking with {iterations} iterations per test.\n&quot;)

# --- Test FrozenDataclass ---
print(&quot;--- FrozenDataclass ---&quot;)
dc_timer_frozen = Timer(lambda: dc_replace(frozen_record, a=2))
# Assuming copy.replace is available (Python 3.13+)
cp_timer_frozen = Timer(lambda: copy.replace(frozen_record, a=2))

dc_time_frozen = dc_timer_frozen.timeit(number=iterations)
cp_time_frozen = cp_timer_frozen.timeit(number=iterations)

print(f&quot;dataclasses.replace: {dc_time_frozen:.6f} seconds&quot;)
print(f&quot;copy.replace:        {cp_time_frozen:.6f} seconds&quot;)
if cp_time_frozen != 0:
    print(
        f&quot;copy.replace is {dc_time_frozen / cp_time_frozen:.2f}x {'faster' if dc_time_frozen &gt; cp_time_frozen else 'slower'} than dataclasses.replace&quot;
    )
print(&quot;\n&quot;)

# --- Test NonFrozenDataclass ---
print(&quot;--- NonFrozenDataclass ---&quot;)
dc_timer_non_frozen = Timer(lambda: dc_replace(non_frozen_record, a=2))
cp_timer_non_frozen = Timer(lambda: copy.replace(non_frozen_record, a=2))

dc_time_non_frozen = dc_timer_non_frozen.timeit(number=iterations)
cp_time_non_frozen = cp_timer_non_frozen.timeit(number=iterations)

print(f&quot;dataclasses.replace: {dc_time_non_frozen:.6f} seconds&quot;)
print(f&quot;copy.replace:        {cp_time_non_frozen:.6f} seconds&quot;)
if cp_time_non_frozen != 0:
    print(
        f&quot;copy.replace is {dc_time_non_frozen / cp_time_non_frozen:.2f}x {'faster' if dc_time_non_frozen &gt; cp_time_non_frozen else 'slower'} than dataclasses.replace&quot;
    )
print(&quot;\n&quot;)

# --- Test datetime.datetime object ---
print(&quot;--- datetime.datetime object ---&quot;)
dt_object = datetime.datetime.now()

# Benchmark datetime.replace()
dt_native_timer = Timer(lambda: dt_object.replace(microsecond=100))
dt_native_time = dt_native_timer.timeit(number=iterations)

# Benchmark copy.replace() for datetime object
cp_dt_timer = Timer(lambda: copy.replace(dt_object, microsecond=100))
cp_dt_time = cp_dt_timer.timeit(number=iterations)

print(f&quot;datetime.replace(): {dt_native_time:.6f} seconds&quot;)
print(f&quot;copy.replace():     {cp_dt_time:.6f} seconds&quot;)
if cp_dt_time != 0:
    print(
        f&quot;copy.replace is {dt_native_time / cp_dt_time:.2f}x {'faster' if dt_native_time &gt; cp_dt_time else 'slower'} than datetime.replace()&quot;
    )
print(&quot;\n&quot;)

# --- Test collections.namedtuple ---
print(&quot;--- collections.namedtuple ---&quot;)
Point = collections.namedtuple(&quot;Point&quot;, [&quot;x&quot;, &quot;y&quot;])
nt_obj = Point(1, 2)

nt_native_timer = Timer(lambda: nt_obj._replace(x=100))
nt_native_time = nt_native_timer.timeit(number=iterations)

cp_nt_timer = Timer(lambda: copy.replace(nt_obj, x=100))
cp_nt_time = cp_nt_timer.timeit(number=iterations)

print(f&quot;namedtuple._replace(): {nt_native_time:.6f} seconds&quot;)
print(f&quot;copy.replace():        {cp_nt_time:.6f} seconds&quot;)
if cp_nt_time != 0:
    print(
        f&quot;copy.replace is {nt_native_time / cp_nt_time:.2f}x {'faster' if nt_native_time &gt; cp_nt_time else 'slower'} than namedtuple._replace()&quot;
    )
print(&quot;\n&quot;)

# --- Test datetime.date object ---
print(&quot;--- datetime.date object ---&quot;)
date_obj = datetime.date(2023, 1, 1)

date_native_timer = Timer(lambda: date_obj.replace(day=15))
dt_native_date_time = date_native_timer.timeit(number=iterations)

cp_date_timer = Timer(lambda: copy.replace(date_obj, day=15))
cp_date_time = cp_date_timer.timeit(number=iterations)

print(f&quot;datetime.date.replace(): {dt_native_date_time:.6f} seconds&quot;)
print(f&quot;copy.replace():            {cp_date_time:.6f} seconds&quot;)
if cp_date_time != 0:
    print(
        f&quot;copy.replace is {dt_native_date_time / cp_date_time:.2f}x {'faster' if dt_native_date_time &gt; cp_date_time else 'slower'} than datetime.date.replace()&quot;
    )
print(&quot;\n&quot;)

# --- Test datetime.time object ---
print(&quot;--- datetime.time object ---&quot;)
time_obj = datetime.time(12, 30, 0)

time_native_timer = Timer(lambda: time_obj.replace(minute=45))
dt_native_time_time = time_native_timer.timeit(number=iterations)

cp_time_timer = Timer(lambda: copy.replace(time_obj, minute=45))
cp_time_time = cp_time_timer.timeit(number=iterations)

print(f&quot;datetime.time.replace(): {dt_native_time_time:.6f} seconds&quot;)
print(f&quot;copy.replace():            {cp_time_time:.6f} seconds&quot;)
if cp_time_time != 0:
    print(
        f&quot;copy.replace is {dt_native_time_time / cp_time_time:.2f}x {'faster' if dt_native_time_time &gt; cp_time_time else 'slower'} than datetime.time.replace()&quot;
    )
print(&quot;\n&quot;)

# --- Test inspect.Parameter ---
print(&quot;--- inspect.Parameter ---&quot;)
param_obj = inspect.Parameter(&quot;x&quot;, inspect.Parameter.POSITIONAL_OR_KEYWORD, default=42)

param_native_timer = Timer(lambda: param_obj.replace(default=100))
param_native_time = param_native_timer.timeit(number=iterations)

cp_param_timer = Timer(lambda: copy.replace(param_obj, default=100))
cp_param_time = cp_param_timer.timeit(number=iterations)

print(f&quot;inspect.Parameter.replace(): {param_native_time:.6f} seconds&quot;)
print(f&quot;copy.replace():                {cp_param_time:.6f} seconds&quot;)
if cp_param_time != 0:
    print(
        f&quot;copy.replace is {param_native_time / cp_param_time:.2f}x {'faster' if param_native_time &gt; cp_param_time else 'slower'} than inspect.Parameter.replace()&quot;
    )
print(&quot;\n&quot;)

# --- Test inspect.Signature ---
print(&quot;--- inspect.Signature ---&quot;)
param_for_sig = inspect.Parameter(&quot;y&quot;, inspect.Parameter.POSITIONAL_ONLY)
sig_obj = inspect.Signature(parameters=[param_for_sig], return_annotation=int)
new_param_for_sig = inspect.Parameter(&quot;z&quot;, inspect.Parameter.KEYWORD_ONLY)

sig_native_timer = Timer(lambda: sig_obj.replace(parameters=[new_param_for_sig]))
sig_native_time = sig_native_timer.timeit(number=iterations)

cp_sig_timer = Timer(lambda: copy.replace(sig_obj, parameters=[new_param_for_sig]))
cp_sig_time = cp_sig_timer.timeit(number=iterations)

print(f&quot;inspect.Signature.replace(): {sig_native_time:.6f} seconds&quot;)
print(f&quot;copy.replace():                {cp_sig_time:.6f} seconds&quot;)
if cp_sig_time != 0:
    print(
        f&quot;copy.replace is {sig_native_time / cp_sig_time:.2f}x {'faster' if sig_native_time &gt; cp_sig_time else 'slower'} than inspect.Signature.replace()&quot;
    )
print(&quot;\n&quot;)

# --- Test types.SimpleNamespace ---
print(&quot;--- types.SimpleNamespace ---&quot;)
sns_obj = types.SimpleNamespace(a=1, b=&quot;test&quot;)

# Native way to create a modified copy
sns_native_timer = Timer(lambda: types.SimpleNamespace(**{**sns_obj.__dict__, &quot;a&quot;: 100}))
sns_native_time = sns_native_timer.timeit(number=iterations)

cp_sns_timer = Timer(lambda: copy.replace(sns_obj, a=100))
cp_sns_time = cp_sns_timer.timeit(number=iterations)

print(f&quot;SimpleNamespace (manual copy): {sns_native_time:.6f} seconds&quot;)
print(f&quot;copy.replace():                  {cp_sns_time:.6f} seconds&quot;)
if cp_sns_time != 0:
    print(
        f&quot;copy.replace is {sns_native_time / cp_sns_time:.2f}x {'faster' if sns_native_time &gt; cp_sns_time else 'slower'} than manual copy&quot;
    )
print(&quot;\n&quot;)

# --- Test types.CodeType (code object) ---
print(&quot;--- types.CodeType (code object) ---&quot;)


def example_func_for_code_obj(x, y):
    return x + y


code_obj = example_func_for_code_obj.__code__

# Native types.CodeType.replace()
# Replacing co_name for a simple change. Other attributes might be more complex or restricted.
code_native_timer = Timer(lambda: code_obj.replace(co_name=&quot;new_func_name&quot;))
code_native_time = code_native_timer.timeit(number=iterations)

# copy.replace() for types.CodeType
cp_code_timer = Timer(lambda: copy.replace(code_obj, co_name=&quot;new_func_name&quot;))
cp_code_time = cp_code_timer.timeit(number=iterations)

print(f&quot;types.CodeType.replace(): {code_native_time:.6f} seconds&quot;)
print(f&quot;copy.replace():             {cp_code_time:.6f} seconds&quot;)
if cp_code_time != 0:
    print(
        f&quot;copy.replace is {code_native_time / cp_code_time:.2f}x {'faster' if code_native_time &gt; cp_code_time else 'slower'} than types.CodeType.replace()&quot;
    )
print(&quot;\n&quot;)

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @ntBre on 2025-05-20 18:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @ntBre on 2025-05-20 18:48</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:17 UTC
    </footer>
</body>
</html>
