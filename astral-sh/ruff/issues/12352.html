<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature: Extend ruff configuration from external file - astral-sh/ruff #12352</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Feature: Extend ruff configuration from external file</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/12352">#12352</a>
        opened by <a href="https://github.com/yeoffrey">@yeoffrey</a>
        on 2024-07-16 21:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/yeoffrey">@yeoffrey</a> on 2024-07-16 21:02</div>
            <div class="timeline-body"><h1>TD;LR</h1>
<p>Enable the ability to import ruff.toml configurations from external sources such as URLs or git repositories.</p>
<p>âœ… I am willing to contribute to make this feature.</p>
<h1>Use Case</h1>
<p>In our own projects, we maintain multiple repositories. When we need to update our linting rules, we currently have to modify the ruff.toml file in each project individually. This process is time-consuming and prone to inconsistencies. It would be beneficial to centralize these configurations, allowing us to update rules in a single location and propagate them across all projects.</p>
<p>For our Javascript projects, we have a shared eslint configuration from a repository that is imported via a project dependency. When we make an update to the configuration, the dependency will update. It saves us a lot of time, and I think Ruff should have a similar solution available for this case.</p>
<h1>Proposed Solution</h1>
<p>Introduce support for remote imports in ruff.toml. This feature would allow users to specify an external URL or git repository from which the ruff.toml configuration can be fetched and extended. This could be implemented either as a Python dependency or directly in the ruff.toml file.</p>
<p>Example Configuration</p>
<pre><code class="language-toml"># ruff.toml
[import]
url = &quot;https://example.com/path/to/ruff.toml&quot;

# or for git repository
[import]
git = &quot;https://github.com/organization/repo&quot;
branch = &quot;main&quot;
path = &quot;path/to/ruff.toml&quot;

# Local overrides
[tool.ruff]
line-length = 88
</code></pre>
<h1>Conclusion</h1>
<p>This feature would streamline the process of sharing and updating linter configurations across multiple projects, enhancing maintainability and consistency. Centralizing configuration management would save time and reduce errors. Thank you for your continued efforts and a brilliant tool ðŸš€</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2024-07-16 23:35</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/discussions/3363#discussioncomment-7266932</p>
<blockquote>
<p>If/when this gets implemented in Ruff, I'd ask to consider a system that allows downloading the configs at install rather than at runtime to avoid issues with pre-commit.ci restrictions. (like dprint is having, see https://github.com/dprint/dprint/issues/442 )</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-17 06:32</div>
            <div class="timeline-body"><p>Thanks @yeoffrey for opening this issue and the kind words.</p>
<p>The first step for adding preset support is to create a design proposal and consensus behind it.</p>
<ul>
<li>How does it interact with <code>extend</code> (or should it be <code>extend</code>)</li>
<li>Can presets be mixed?</li>
<li>How does extending a preset work?</li>
<li>How is the configuration cached</li>
<li>What are the performance implications (having to issue HTTP downloads during file traversal is expensive)</li>
<li>How do we ensure builds are reproducible (not given when pointing to an arbitrary URL or a git branch)</li>
<li>See @Avasam comment</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yeoffrey">@yeoffrey</a> on 2024-07-18 13:56</div>
            <div class="timeline-body"><p>If the configuration needs to be available at install time and not fetching at runtime, then I think the best option would be to create a preset as a development dependency that is installed with all of the other python packages. Inside of the ruff configuration file, you could point to a dependency that exports a configuration. I see this being a way to solve the question of caching, avoiding HTTP downloads during file traversal, ensuring reproducible builds. It also just leverages python's existing package system, so it doesn't feel unintuitive to handle it this way.</p>
<pre><code class="language-shell">pip install my-ruff-config
</code></pre>
<pre><code class="language-toml"># ruff.toml
[preset]
pkg = &quot;my-ruff-config&quot;
</code></pre>
<p>The only issue I see though, is how to export a toml file out of a python package:</p>
<ul>
<li>Do we allow users to configure Ruff in a Python / Rust file?</li>
<li>Is there a way to export a toml file from a python package that I'm not aware of?</li>
</ul>
<blockquote>
<ul>
<li>How does it interact with <code>extend</code> (or should it be <code>extend</code>)</li>
<li>Can presets be mixed?</li>
<li>How does extending a preset work?</li>
</ul>
</blockquote>
<p>I think presets should be able to be extended, but based on the documentation I don't think <code>extend</code> will work for our needs since it only is extending other pyproject.toml files, and that still requires an answer as to whether than can be a dependency.</p>
<p>To make it work there should be an order of priority:</p>
<ol>
<li>Normal ruff priorities as described <a href="https://docs.astral.sh/ruff/configuration/#config-file-discovery">here</a>.</li>
<li>If a dependency is marked in a config file, then it should be overridden by local file configurations, and if those are overridden by other files then it shouldn't behave any differently.</li>
</ol>
<p>These are just my basic thoughts right now, I might have others later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-18 14:10</div>
            <div class="timeline-body"><blockquote>
<p>I don't think extend will work for our needs since it only is extending other pyproject.toml files</p>
</blockquote>
<p>I'm not sure that i understand what you mean by that. <code>extend</code> supports extending any <code>ruff.toml</code>, <code>.ruff.toml</code> or a <code>pyproject.toml</code>.</p>
<p>I like using Python packages. The main question is how to find the Python package. More specifically. How do we know where the venv is (if any)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2024-07-18 17:06</div>
            <div class="timeline-body"><blockquote>
<p>I like using Python packages. The main question is how to find the Python package. More specifically. How do we know where the venv is (if any)</p>
</blockquote>
<p>For projects like eslint and typescript it's easy: whatever environment they're run from so they can just import.</p>
<p>pyright is a non-python tool that needs to be aware of installed python packages, maybe you could take some inspiration from how it's doing it? Eric T. is generally a good reference for such standards too.</p>
<p>I see what looks like static typing efforts in Ruff (that red-knot thing?). Surely logic to statically find installed packages can be shared.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/10622.html">astral-sh/ruff#10622</a> on 2024-08-19 05:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">configuration</span> added by @MichaReiser on 2024-09-04 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/13245.html">astral-sh/ruff#13245</a> on 2024-09-04 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/13505.html">astral-sh/ruff#13505</a> on 2024-09-24 15:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/11415.html">astral-sh/ruff#11415</a> on 2024-10-11 01:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/13433.html">astral-sh/ruff#13433</a> on 2024-10-11 01:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/14443.html">astral-sh/ruff#14443</a> on 2024-11-18 20:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/8470.html">astral-sh/ruff#8470</a> on 2024-12-27 01:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ruhrohraggy">@ruhrohraggy</a> on 2025-01-17 19:26</div>
            <div class="timeline-body"><p>Hey everyone -- just curious on the status of this. We were just discussing this exact pattern and how we might achieve it so that we don't have to continue keeping up with differing configs in every <code>pyproject.toml</code>. We have some abstraction built out using <code>Make</code> but something native would be ideal where the config for ruff in <code>pyproject.toml</code> could simply point to a remote config of some sort.</p>
<p>A lot of our previous work is in Java with a pretty robust Gradle ecosystem with tons of shared build configurations and everything -- hoping to find some similar pathways in Poetry and the linters we're using</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-design</span> added by @dhruvmanila on 2025-01-20 06:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/orenm-gloat">@orenm-gloat</a> on 2025-01-22 09:36</div>
            <div class="timeline-body"><p>hi @dhruvmanila , I saw you added the <code>needs-design</code> label. We are in the process of adding ruff (and other astral tools, you rock, thanks!) and have same use cases as described here.
Is there a timeline? can we help somehow?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yeoffrey">@yeoffrey</a> on 2025-01-22 13:29</div>
            <div class="timeline-body"><p>Unfortunately I haven't had enough time to dedicate to this feature, however over the last few months I've had some other thoughts that might prove useful here.</p>
<p>Ruff already has a way to locate the virtual environment (venv), which is located in <code>ruff/crates/ruff_python_resolver/src/search.rs</code> <a href="https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_resolver/src/search.rs">link</a>. I think we can use that to fetch the location of the venv.</p>
<p>I think we need to slot that new configuration file into the priorities described here <code>ruff/crates/ruff/src/resolve.rs</code> <a href="https://github.com/astral-sh/ruff/blob/main/crates/ruff/src/resolve.rs">link</a>, which will allow us to correctly prioritize the configuration file over other configurations.</p>
<p>So if we allow the <code>extend</code> option to point to a package like <code>my-config-package</code> which has a <code>ruff.toml</code> file inside it, we look for it inside the venv, find it, and then prioritize it against the existing rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/orenm-gloat">@orenm-gloat</a> on 2025-01-22 13:39</div>
            <div class="timeline-body"><p>thanks for the quick reply @yeoffrey ! I actually tried to go into the code today and found exactly these logics and had very similar thought.
To make the search even easier we can define a strict naming convention, much like eslint does with the prefix <code>eslint-config-</code> so it will make the search and also discoverability easier.
Sounds like this should be between second and third priorities or inside the third priority**, we still want to resolve from current working dir to the root in hierarchical manner(I assume the setting will be set in the root config most of the times, although this can be a point to discuss) and then load with priority the plugin config and merge back to the working dir config.</p>
<p>** maybe this is even not in the priorities but in deeper level in the <a href="https://github.com/astral-sh/ruff/blob/main/crates/ruff_workspace/src/resolver.rs">ruff_workspace resolver.rs</a> file, when resolving a config, if it uses a preset so try to find the preset and merge from the venv</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-01-23 09:20</div>
            <div class="timeline-body"><blockquote>
<p>hi, I saw you added the <code>needs-design</code> label. We are in the process of adding ruff (and other astral tools, you rock, thanks!) and have same use cases as described here.
Is there a timeline? can we help somehow?</p>
</blockquote>
<p>Thank you for the kind words. No, we don't have any timeline regarding this feature as it's not being worked on currently. The reason I added &quot;needs-design&quot; is because this is a fairly large feature which will require some amount of discussion on a design proposal, see https://github.com/astral-sh/ruff/issues/12352#issuecomment-2232532879.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yeoffrey">@yeoffrey</a> on 2025-01-23 15:59</div>
            <div class="timeline-body"><p>@orenm-gloat cc: @dhruvmanila</p>
<p>So here is what I propose we do. Its similar to what I suggested at the beginning, but after looking at the code for a bit and drinking a few beers last night I think we can make a proposal that is more serious than my original.</p>
<h1>High-Level</h1>
<p>We use the <code>extend</code> field to link to an external <code>ruff.toml</code> file in a dependency. Currently it takes a path, but we could instead do something like this to let Ruff know that we are referring to a package in the virtual environment.</p>
<pre><code class="language-toml">[tool.ruff]
extend = &quot;pkg:ruff-config/ruff.toml&quot; # Denoted by `pkg:`
</code></pre>
<p>This design would be ideal because:</p>
<ol>
<li>No breaking changes (in the spirit of Rust).</li>
<li>Preloads the configuration, not at runtime to avoid the issue that @Avasam brought up https://github.com/astral-sh/ruff/discussions/3363#discussioncomment-7266932.</li>
<li>In the future we can also add something like <code>preset:</code> to denote a ruff preset like mentioned in https://github.com/astral-sh/ruff/discussions/3363</li>
<li>We could also add something like <code>url:</code> to just fetch a <code>toml</code> file directly from somewhere on the internet, or even a Github gist which might be really nice for people just playing around with the linter.</li>
</ol>
<p>For the rest of this I'm only referring to the <code>pkg:</code> feature though, so forget about 3 and 4 for now.</p>
<h1>Technical Implementation</h1>
<h2>File Specific</h2>
<ul>
<li><code>ruff_workspace/src/configuration.rs</code> <code>extends</code> can still be a <code>PathBuf</code>, but we might need to add some handling before that to look into the virtual environment to properly build this path.</li>
<li><code>ruff_workspace/src/resolver.rs</code> <code>fn resolve_configuration()</code> needs to order the stack properly to make sure that the package takes first priority.<ul>
<li>It seems that this is also used by the LSP (I could be wrong here) so if we correctly handle it here then I think the rest of the logic around config resolving should work. The rest of it seems to be just making sure that Ruff is using settings from the nearest config file relative to the file its linting.</li>
</ul>
</li>
</ul>
<p>Most of the errors around path resolving expect a <code>pyproject.toml</code> file, which won't be true anymore. We'll need to properly handle the error and give the user feedback that its searching for a file in a package that it can't find (for whatever reason).</p>
<h2>Security Implications</h2>
<p>I don't think theres anything here that is &quot;more risky&quot; then the risk already taken by installing packages off the internet, but its worth thinking about whether we need to sanitize the input or something just in case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-23 17:06</div>
            <div class="timeline-body"><p>I think the hard part is virtual environment discovery which neither Ruff nor Red Knot support today. We may need a setting and or some heuristic for finding it.</p>
<p>The other question is if it only supports venv or packages installed anywhere (even in system python). This would require a fully-fledged mdoule resolver. We do have that in <code>red_knot_python_semantic</code> (see <code>resolve_module</code>) but it doesn't support any non <code>py</code> extensions.</p>
<blockquote>
<p>I don't think theres anything here that is &quot;more risky&quot; then the risk already taken by installing packages off the internet, but its worth thinking about whether we need to sanitize the input or something just in case.</p>
</blockquote>
<p>Agree, reading a configuration seems pretty fine compared to a package running arbitrary code with <code>setuptools</code> during installation ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-01-23 17:20</div>
            <div class="timeline-body"><p>As a sidenote: My concerns for runtime fetching of extended configurations are still valid. But if we can at least get the url-based one first, that'd already work for all use cases where the CI isn't blocked behind a proxy (ie pre-commit.ci's free tier and some corporate setups). And I don't think those two features need to come together / block each other.</p>
<p>Something @yeoffrey didn't mention is that the config could be cached (and busted w/ <code>ruff clean</code>).
Also to &quot;pin&quot; a configuration URL, one can simply point to a specific commit, for example:</p>
<ul>
<li>Unpinned: <code>https://raw.githubusercontent.com/BesLogic/shared-configs/refs/heads/main/ruff.toml</code></li>
<li>Pinned: <code>https://raw.githubusercontent.com/BesLogic/shared-configs/1eae2e41c99aeaeb6ac21bc1109b3e305171cfb2/ruff.toml</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yeoffrey">@yeoffrey</a> on 2025-01-23 17:33</div>
            <div class="timeline-body"><blockquote>
<p>I think the hard part is virtual environment discovery which neither Ruff nor Red Knot support today. We may need a setting and or some heuristic for finding it.</p>
<p>The other question is if it only supports venv or packages installed anywhere (even in system python). This would require a fully-fledged mdoule resolver. We do have that in <code>red_knot_python_semantic</code> (see <code>resolve_module</code>) but it doesn't support any non <code>py</code> extensions.</p>
</blockquote>
<p>So I see that <code>ruff_python_resolver/src/search.rs</code> has code but it seems to be only for finding <code>site-packages</code>.</p>
<p>Eric Traut pointed me towards the way PyRight does it: <a href="https://github.com/microsoft/pyright/blob/fe0dc216f09dd61c41ec8ba3d1aa4e7995f357d4/packages/pyright-internal/src/common/fullAccessHost.ts#L27">theres a script</a> that tries to get the contents of <code>sys.path</code>.</p>
<p>I looked at the <code>resolve_module</code> code there. It's possible that we could try to just get a path from it. Otherwise we might need to just focus on a <code>url</code> option for now. @Avasam does make a good point that a url would be a lot easier to do right now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-23 17:40</div>
            <div class="timeline-body"><p>The <code>ruff_python_resolver</code> is only a prototype. It is currently unused. I would rather not write new code depending on it.</p>
<p>Yeah, the downside of URLs is that they require including an entire HTTP request library. They tend to be large, and this introduces complexity around caching, etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/silverwind">@silverwind</a> on 2025-06-04 06:58</div>
            <div class="timeline-body"><blockquote>
<p>We use the extend field to link to an external ruff.toml file in a dependency</p>
</blockquote>
<p>The <a href="https://docs.astral.sh/ruff/settings/#extend"><code>extend</code> docs</a> say that the option only accepts a <code>pyproject.toml</code> file, not a <code>ruff.toml</code> file. Would it be made to support both file formats? I guess this may not be straightforward and may require some heuristics to detect which format it is.</p>
<p>I think would make much more sense if <code>extend</code> in a <code>pyproject.toml</code> would support extending a <code>ruff.toml</code> file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-04 07:37</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>We use the extend field to link to an external ruff.toml file in a dependency</p>
</blockquote>
<p>The <a href="https://docs.astral.sh/ruff/settings/#extend"><code>extend</code> docs</a> say that the option only accepts a <code>pyproject.toml</code> file, not a <code>ruff.toml</code> file. Would it be made to support both file formats? I guess this may not be straightforward and may require some heuristics to detect which format it is.</p>
<p>I think would make much more sense if <code>extend</code> in a <code>pyproject.toml</code> would support extending a <code>ruff.toml</code> file.</p>
</blockquote>
<p>Both should be supported. If not, please open a new issue as this is slightly different from what the issue author is asking for.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/18701.html">astral-sh/ruff#18701</a> on 2025-06-16 07:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/silverwind">@silverwind</a> on 2025-06-27 12:26</div>
            <div class="timeline-body"><blockquote>
<p>Both should be supported. If not, please open a new issue as this is slightly different from what the issue author is asking for.</p>
</blockquote>
<p>You are right, I tested <code>extend = &quot;ruff1.toml&quot;</code> with the file being in <code>ruff.toml</code> format and it worked.</p>
<p>So I guess <a href="https://docs.astral.sh/ruff/settings/#extend">these docs</a> are incorrect. I made new issue https://github.com/astral-sh/ruff/issues/18983 about this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/swanysimon">@swanysimon</a> on 2025-08-10 19:21</div>
            <div class="timeline-body"><p>To clarify here (and happy to open another issue/question if that would be better): if I want to share the same base <code>ruff</code> configuration across all Python repos that I'm working on, I would need do something like the following:</p>
<ol>
<li>Create a <code>my-ruff-config</code> project</li>
<li>Put my ruff configuration into a <code>ruff.toml</code> file</li>
<li>Figure out how to add the <code>ruff.toml</code> to the build/publish for that repo (I'll figure this out when I start digging, I have confidence)</li>
</ol>
<p>Then in every repo:</p>
<ol>
<li>Add a dev dependency on <code>my-ruff-config</code></li>
<li>Add to my <code>pyproject.toml</code><pre><code class="language-toml">[tool.ruff]
extend = &quot;.venv/bin/lib/python&lt;version&gt;/site-packages/my_ruff_config/ruff.toml&quot;
</code></pre>
</li>
</ol>
<p>Is that correct? I see in the docs that <code>User home directory and environment variables will be expanded.</code>, is there a way to use these for a less brittle path?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/18983.html">astral-sh/ruff#18983</a> on 2025-08-10 19:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kkom">@kkom</a> on 2025-08-10 19:42</div>
            <div class="timeline-body"><p>@swanysimon -- to provide some validation, this is almost exactly what I have done in my projects.</p>
<p>Only that instead of referring to a file in the venv, I exposed a function which overwrites a specified path with the base config file (original is packaged with the lib).</p>
<p>This way the base config is more explicit in the project using it. You need CI checks if you want to ensure that the base file is updated on a lib version bump.</p>
<p>A more first-class way to do this would be very welcome!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/swanysimon">@swanysimon</a> on 2025-08-10 20:00</div>
            <div class="timeline-body"><blockquote>
<p>Only that instead of referring to a file in the venv, I exposed a function which overwrites a specified path with the base config file (original is packaged with the lib).</p>
</blockquote>
<p>@kkom Appreciate the validation. I was about to go this route before realizing I should check if this was supported out of the box. Already have other code generation things going on in my pre-commit config (which is much more easily shared), and I'm considering something similar for our <code>mypy</code> (maybe in the future <code>ty</code>?) configuration.</p>
<blockquote>
<p>A more first-class way to do this would be very welcome!</p>
</blockquote>
<p>100%. I liked most of the ideas in this thread, they're all better than trying to wire this together myself. But worst case, I'll wire it together myself :D</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/phillipuniverse">@phillipuniverse</a> on 2025-08-10 20:36</div>
            <div class="timeline-body"><blockquote>
<p>Only that instead of referring to a file in the venv, I exposed a function which overwrites a specified path with the base config file (original is packaged with the lib).</p>
</blockquote>
<p>@kkom could you give a bit more information on what you mean by this? Like how did you expose and invoke the function exactly?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kkom">@kkom</a> on 2025-08-10 20:41</div>
            <div class="timeline-body"><p>This is the helper defined in my package:</p>
<pre><code class="language-python">&quot;&quot;&quot;Utility function to sync configs defined in kstd.&quot;&quot;&quot;

import argparse
from pathlib import Path
from shutil import copyfileobj
from typing import Literal, get_args

_CONFIGS_DIR = Path(__file__).parent / &quot;configs&quot;

ConfigType = Literal[&quot;pyright&quot;, &quot;ruff&quot;]


def sync_config(
    config_type: ConfigType,
    destination_file_path: Path,
) -&gt; None:
    &quot;&quot;&quot;
    Sync base configuration file for a specified tool. This will overwrite the destination.

    Args:
        config_type: Type of configuration file to sync.
        destination_file_path: Destination path where the config file will be copied to.
    &quot;&quot;&quot;
    match config_type:
        case &quot;pyright&quot;:
            config_file = _CONFIGS_DIR / &quot;pyrightconfig.json&quot;
        case &quot;ruff&quot;:
            config_file = _CONFIGS_DIR / &quot;ruff.toml&quot;

    with config_file.open(&quot;r&quot;) as config_file:
        with destination_file_path.open(&quot;w&quot;) as destination_file:
            copyfileobj(config_file, destination_file)


def cli() -&gt; None:
    &quot;&quot;&quot;Command line interface for syncing the configuration files.&quot;&quot;&quot;
    parser = argparse.ArgumentParser(description=&quot;Sync configuration files&quot;)

    _ = parser.add_argument(
        &quot;config_type&quot;,
        choices=get_args(ConfigType),
        help=&quot;Type of configuration to sync&quot;,
    )

    _ = parser.add_argument(
        &quot;destination_file_path&quot;,
        type=Path,
        help=&quot;Destination path for the config file&quot;,
    )

    args = parser.parse_args()

    sync_config(args.config_type, Path(args.destination_file_path))


if __name__ == &quot;__main__&quot;:
    cli()
</code></pre>
<p>And here is how I use it with <a href="https://poethepoet.natn.io/index.html">Poe</a>:</p>
<pre><code class="language-toml">[tool.poe.tasks]
sync_config_pyright = 'uv run python -c &quot;from kstd.sync_config import cli; cli()&quot; pyright ../../pyrightconfig.json'
sync_config_ruff = 'uv run python -c &quot;from kstd.sync_config import cli; cli()&quot; ruff ../common-files/ruff_base.toml'
</code></pre>
<p>I haven't implemented dry run / check mode at the moment.</p>
<p>PS: Looking at my code again, I think I could probably invoke <code>sync_config</code> directly? I don't remember if there was a reason to go through the CLI, but I think you could bypass that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/silverwind">@silverwind</a> on 2025-09-11 10:24</div>
            <div class="timeline-body"><blockquote>
<pre><code>2. Add to my `pyproject.toml`
   [tool.ruff]
   extend = &quot;.venv/bin/lib/python&lt;version&gt;/site-packages/my_ruff_config/ruff.toml&quot;</code></pre>
<p>Is that correct? I see in the docs that <code>User home directory and environment variables will be expanded.</code>, is there a way to use these for a less brittle path?</p>
</blockquote>
<p>Maybe a syntax like this could be supported to extend from a file inside a installed python package:</p>
<pre><code class="language-toml">[tool.ruff]
extend = { package = &quot;my-ruff-config&quot;, path = &quot;ruff.toml&quot; }
</code></pre>
<p>My current workaround is via an npm package (npm package paths are stable).</p>
<pre><code class="language-toml">[tool.ruff]
extend = &quot;node_modules/ruff-config-silverwind/ruff.toml&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../astral-sh/uv/issues/15800.html">astral-sh/uv#15800</a> on 2025-09-12 02:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-09-13 01:48</div>
            <div class="timeline-body"><blockquote>
<ol start="2">
<li>Add to my <code>pyproject.toml</code>
[tool.ruff]
extend = &quot;.venv/bin/lib/python<version>/site-packages/my_ruff_config/ruff.toml&quot;</li>
</ol>
</blockquote>
<p>it should be <code>&quot;.venv/lib/python&lt;version&gt;/site-packages/my_ruff_config/ruff.toml&quot;</code></p>
<p>If you package your config as a Script, it'll go under <code>.venv/bin/my_ruff_config.toml</code>. You solve the Python version on Linux, but now it's not compatible with Windows (where the path would be <code>.venv/Scripts/my_ruff_config.toml</code>. Unless something like https://github.com/astral-sh/uv/issues/15800 is implemented first.</p>
<p>Is it possible to build a python package such that a file would end up in a consistent location across OSes ? This is really a non-issue with node &gt;.&lt;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/SamuelT-Beslogic">@SamuelT-Beslogic</a> on 2025-09-17 20:07</div>
            <div class="timeline-body"><p>I figured it out ! Using a discouraged/deprecated setuptools feature (<a href="https://setuptools.pypa.io/en/latest/references/keywords.html#keyword-data-files">data-files</a>) it's possible to install files to arbitrary location relative to the environment. This of course only works with sdists and for projects with a known virtual environment location (which is the case for uv and virtualenv out of the box)</p>
<p>Since you can't use wheels anyway and Astral may implement an official way of handling this later, I wouldn't recommend publishing and polluting PyPI, so I did it through GitHub. Here's my full solution: https://github.com/BesLogic/Beslogic-Ruff-Config</p>
<p>And it even works for my multi-venv setup (Windows + WSL) as long as my original venv has the configs !
<img width="152" height="386" alt="Image" src="https://github.com/user-attachments/assets/a83f8756-5386-45ca-9970-66dbadb77b6e" /></p>
<p>-- @Avasam (using my work account rn as I did this for work)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/PhilippAIO">@PhilippAIO</a> on 2025-09-19 16:21</div>
            <div class="timeline-body"><blockquote>
<p>Maybe a syntax like this could be supported to extend from a file inside a installed python package:</p>
<p>[tool.ruff]
extend = { package = &quot;my-ruff-config&quot;, path = &quot;ruff.toml&quot; }</p>
</blockquote>
<p>I just want to mention, that the mentioned design suggestion of @silverwind looks great to me. The pure filepath-logic of extend has many downsides when you want to use a shared ruff configuration between multiple projects and multiple developers with diverging (venv) paths / systems.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../posit-dev/air/issues/411.html">posit-dev/air#411</a> on 2025-10-06 11:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Sillocan">@Sillocan</a> on 2025-12-04 18:14</div>
            <div class="timeline-body"><p>I agree, I really like @silverwind's suggestion especially for sharing configurations within enterprise organizations. This allows a self contained <code>uv run ruff</code> to work without requiring slightly painful concepts like submodules. This also solves the runtime/install issue that was mentioned at the start for dprint.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:13 UTC
    </footer>
</body>
</html>
