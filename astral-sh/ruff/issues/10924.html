<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLE0604 mistakenly requires literal strings for __all__ - astral-sh/ruff #10924</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>PLE0604 mistakenly requires literal strings for <strong>all</strong></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/10924">#10924</a>
        opened by <a href="https://github.com/andraxin">@andraxin</a>
        on 2024-04-14 10:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/andraxin">@andraxin</a></div>
            <div class="timeline-body"><p>Compared to PyLint, Ruff has a very literal, and arguably faulty, interpretation of &quot;strings&quot;
in https://docs.astral.sh/ruff/rules/invalid-all-object/, as it only accepts LITERAL strings,
while PyLint, arguably correctly, also accepts anything that evaluates to a string.</p>
<p><em><strong>Keywords</strong>: PLE0604, false positive</em></p>
Minimal Reproduction
<pre><code>ruff --version
cd &quot;$(mktemp -d)&quot;
mkdir repro
cat &gt; repro/repro.py &lt;&lt; REPRO.PY
&quot;&quot;&quot;Minimal &#x27;repro&#x27; implementation with single &#x27;repro&#x27; method.&quot;&quot;&quot;

def repro(*args, **kwargs):
    &quot;&quot;&quot;Print with a &#x27;REPRO&#x27; prefix.&quot;&quot;&quot;
    print(&quot;REPRO&quot;, *args, **kwargs)
REPRO.PY
cat &gt; repro/__init__.py &lt;&lt; __INIT__.PY
&quot;&quot;&quot;Minimal reproduction for literal interpretation of PLE0604.&quot;&quot;&quot;
from .repro import repro

__all__ = [repro.__name__]
__INIT__.PY
pylint repro
ruff check --select PL || : should NOT fail
cd -
rm -vfr &quot;$OLDPWD&quot;
</code></pre>
Sample Execution
<pre><code>$ cd &quot;$(mktemp -d)&quot;
$ mkdir repro
$ cat &gt; repro/repro.py &lt;&lt; REPRO.PY
&quot;&quot;&quot;Minimal &#x27;repro&#x27; implementation with single &#x27;repro&#x27; method.&quot;&quot;&quot;
                        
def repro(*args, **kwargs):
    &quot;&quot;&quot;Print with a &#x27;REPRO&#x27; prefix.&quot;&quot;&quot;
    print(&quot;REPRO&quot;, *args, **kwargs)
REPRO.PY
$ cat &gt; repro/__init__.py &lt;&lt; __INIT__.PY
&quot;&quot;&quot;Minimal reproduction for literal interpretation of PLE0604.&quot;&quot;&quot;
from .repro import repro
                           
__all__ = [repro.__name__]
__INIT__.PY                        
$ pylint repro

--------------------------------------------------------------------
Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)

$ ruff check --select PL || : should NOT fail
repro/__init__.py:4:1: PLE0604 Invalid object in `__all__`, must contain only strings
Found 1 error.
$ cd -
/tmp
$ rm -vfr &quot;$OLDPWD&quot;
removed &#x27;/tmp/tmp.CgWmFYuHHn/.ruff_cache/.gitignore&#x27;
removed &#x27;/tmp/tmp.CgWmFYuHHn/.ruff_cache/CACHEDIR.TAG&#x27;
removed &#x27;/tmp/tmp.CgWmFYuHHn/.ruff_cache/0.3.7/8365786042997563538&#x27;
removed directory &#x27;/tmp/tmp.CgWmFYuHHn/.ruff_cache/0.3.7&#x27;
removed directory &#x27;/tmp/tmp.CgWmFYuHHn/.ruff_cache&#x27;
removed &#x27;/tmp/tmp.CgWmFYuHHn/repro/repro.py&#x27;
removed &#x27;/tmp/tmp.CgWmFYuHHn/repro/__init__.py&#x27;
removed directory &#x27;/tmp/tmp.CgWmFYuHHn/repro&#x27;
removed directory &#x27;/tmp/tmp.CgWmFYuHHn&#x27;
$ 
</code></pre>
<p>The relevant lines are the conflicting verdicts from PyLint and Ruff, respectively:</p>
<ul>
<li>PyLint<blockquote>
<p>Your code has been rated at 10.00/10 (previous run: 10.00/10, +0.00)</p>
</blockquote>
</li>
<li>Ruff<blockquote>
<p>repro/<strong>init</strong>.py:4:1: PLE0604 Invalid object in <code>__all__</code>, must contain only strings</p>
</blockquote>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-14 15:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">multifile-analysis</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-14 15:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-14 16:02</div>
            <div class="timeline-body"><p>Thanks for the clear issue. I think I consider dynamically setting <code>__all__</code> to be discouraged... Ideally, <code>__all__</code> is trivially analyzable. Even if tools can infer the <em>type</em>, it may be very hard for them to infer the <em>value</em> if it&#x27;s set dynamically.</p>
<p>We may support this incidentally once we support multi-file analysis and type inference, but I&#x27;m gonna close since I think our current behavior is reasonable given the rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-14 16:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andraxin">@andraxin</a> on 2024-04-14 20:59</div>
            <div class="timeline-body"><blockquote>
<p>I think I consider dynamically setting <code>__all__</code> to be discouraged...</p>
</blockquote>
<p>You&#x27;re obviously entitled to your opinion.  Personally, I like to use
the following pattern to avoid having to manually update <code>__all__</code>:</p>
<pre><code>__all__ = [item for item in dir() if not item.startswith(&#x27;_&#x27;)]
</code></pre>
<p>Of course, I can just disable this rule, and be done with it. :smirk:</p>
<blockquote>
<p>Ideally, <code>__all__</code> is trivially analyzable. Even if tools can infer the <em>type</em>, it may be very hard for them to infer the <em>value</em> if it&#x27;s set dynamically.</p>
</blockquote>
<p>I&#x27;m not sure why you&#x27;d need the value for this rule (i.e. E0604).
Granted, you <em>might</em> need it for E0603, but PyLint doesn&#x27;t care;
so, why should you?</p>
PyLint behavior

<p>For <code>__all__ = [&quot;not-repro&quot;]</code>, PyLint gives</p>
<blockquote>
<p>repro/<strong>init</strong>.py:6:11: E0603: Undefined variable name &#x27;not-repro&#x27; in <strong>all</strong> (undefined-all-variable)</p>
</blockquote>
<p>PyLint does NOT complain, when the same value is combined with dynamic parts.</p>
<pre><code>__all__ =  [&quot;not-repro&quot;] + [item for item in dir() if not item.startswith(&#x27;_&#x27;)]
</code></pre>


<p>Naturally, you could (easily) argue that PyLint is wrong and you are right.</p>
<blockquote>
<p>We may support this incidentally once we support multi-file analysis and type inference, but I&#x27;m gonna close since I think our current behavior is reasonable given the rule.</p>
</blockquote>
<p>I disagree with the latter part.  The rule (neither the original, nor yours) does NOT say
that <code>__all__</code> should only contain <em>literal</em>/<em>constant</em> strings.   Maybe it should state that,
if that&#x27;s what&#x27;s <em>actually</em> supported.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-14 21:14</div>
            <div class="timeline-body"><p>To clarify: we don&#x27;t need the value for the <em>rule</em>. But the rule is meant to encourage good practices, and once you start using dynamic values in <code>__all__</code>, you open the door to other problems. For example, I don&#x27;t think Pyright can detect that at all -- trying to use <code>foo</code> from this <code>__init__.py</code> doesn&#x27;t yield any Pyright errors, but it does error at runtime:</p>
<pre><code>from .module import foo

x = &quot;boo&quot;

__all__ = [x]
</code></pre>
<p>Whereas this correctly errors at type-checking time:</p>
<pre><code>from .constants import foo

__all__ = [&quot;boo&quot;]
</code></pre>
<p>The linter is meant to be opinionated on best practices, and requiring string literals in <code>__all__</code> seems like a good practice to me. We can update the documentation for the rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">multifile-analysis</span> removed by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-24 14:34</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:52 UTC
    </footer>
</body>
</html>
