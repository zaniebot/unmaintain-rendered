<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] fix constructor calls on classes with metaclasses - astral-sh/ruff #17462</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] fix constructor calls on classes with metaclasses</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/17462">#17462</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-04-18 15:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/carljm">@carljm</a> on 2025-04-18 15:32</div>
            <div class="timeline-body"><p>The lookup logic for <code>__new__</code> added in #16512 is faulty. It adds &quot;member lookup policies&quot; to skip <code>object.__new__</code> and <code>type.__new__</code>, and then we effectively special-case handling of an implied <code>object.__new__</code> if no <code>__new__</code> is found in the lookup. But this logic doesn't work if there is a custom metaclass: we'll still find <code>__new__</code> on the custom metaclass (after not finding it on the class itself, since we skip <code>object.__new__</code>) and then we'll wrongly try to use the metaclass <code>__new__</code>:</p>
<pre><code class="language-py">import abc

class Foo(metaclass=abc.ABCMeta): ...  

# error: No arguments provided for required parameters `bases`, `namespace` of bound method `__new__` (lint:missing-argument) [Ln 5, Col 1]
# error: Argument to this function is incorrect: Expected `str`, found `Literal[Foo]` (lint:invalid-argument-type) [Ln 5, Col 1]
Foo()
</code></pre>
<p>We need to better represent the actual runtime lookup logic here, which is that <code>object.__new__</code> does exist, therefore <code>__new__</code> will never be looked up on the metaclass at all. One approach would be to have something like a known synthetic function type for <code>object.__new__</code>, and return that instead of not-found, and then we can recognize that known method type and special-case its usage appropriately when we get it back from the lookup. That will prevent us wrongly going to try to find <code>__new__</code> on the metaclass (and should remove the need for the skip-type lookup policy.)</p>
<p>Or an alternative approach might be to replace the skip-type lookup policy with an even more general never-look-up-on-the-meta-type policy.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2025-04-18 15:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Red Knot Alpha" by @carljm on 2025-04-18 15:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/17452.html">astral-sh/ruff#17452</a> on 2025-04-18 15:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2025-04-18 15:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-18 21:22</div>
            <div class="timeline-body"><p>The original example here no longer reproduces on <code>main</code>, because https://github.com/astral-sh/ruff/commit/454ad15aee13e5ac2fc9b67ff5907658764207df added some very hacky special-casing for <code>ABCMeta</code> specifically in order to avoid a huge number of new false positives:</p>
<p>https://github.com/astral-sh/ruff/blob/8fe2dd5e031464630a7aebfdeecb8ecacbb3f3d2/crates/red_knot_python_semantic/src/types/class.rs#L872-L880</p>
<p>But it's still easy to produce these false-positive diagnostics if you use any metaclass that is not <code>type</code> or <code>ABCMeta</code>:</p>
<pre><code class="language-py">class Meta(type):
    def __new__(mcls, name, bases, namespace, /, **kwargs):
        return super().__new__(mcls, name, bases, namespace)

class Foo(metaclass=Meta): ...

Foo()  # error: No arguments provided for required parameters `bases`, `namespace` of bound method `__new__` (lint:missing-argument) [Ln 7, Col 1]
</code></pre>
<p>https://playknot.ruff.rs/27559171-aef7-42c0-8db0-9a16359f66e2</p>
<p>...And we should obviously get rid of the temporary hack as well, replacing it with a more principled solution!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2025-04-22 22:11</div>
            <div class="timeline-body"><p>oops, I've missed this one. If it is not yet fixed by next week, I can work on a permanent fix</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2025-04-28 00:18</div>
            <div class="timeline-body"><p>@sharkdp I see you are assigned here, but per @carljm suggestion I've picked it up. I'll open a PR soon.</p>
<p>so far my plan is to elevate <code>meta_class_no_type_fallback</code> to just <code>no_meta_class_fallback</code>. This seems to be easier. Gut-feeling also tells me it will be more performant than introducing a whole entire <code>Type</code> variant to only represent a &quot;magical&quot; <code>object.__new__</code> which Carl suggested as another possible solution. I kinda like the member policy thing, and it may be valuable in the future for other special cases, so using it should be a way to go.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/17662.html">astral-sh/ruff#17662</a> on 2025-04-28 01:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @mishamsk by @sharkdp on 2025-04-28 06:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @sharkdp by @sharkdp on 2025-04-28 06:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/17733.html">astral-sh/ruff#17733</a> on 2025-04-30 13:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-04-30 15:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-04-30 15:27</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:15 UTC
    </footer>
</body>
</html>
