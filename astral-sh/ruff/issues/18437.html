<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ruff format adds trailing comma after function call, silently turning return value into tuple - astral-sh/ruff #18437</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ruff format adds trailing comma after function call, silently turning return value into tuple</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/18437">#18437</a>
        opened by <a href="https://github.com/keita00">@keita00</a>
        on 2025-06-03 08:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/keita00">@keita00</a></div>
            <div class="timeline-body"><p>Ruff's formatter currently adds a trailing comma after a closing parenthesis ) of a nested function call ‚Äî even when the result is not part of an argument list, which silently converts the return value into a tuple.</p>
<p>This behavior can change the semantics of the code without warning and differs from how black handles similar cases.</p>
<hr />
<p>‚ùå Example of broken behavior:</p>
<pre><code class="language-py">result = os.path.exists(
    os.path.join(
        tmp_repo_path,
        &quot;models&quot;,
        self.model_name,
        self.model_version,
        &quot;model.tar.gz&quot;,
    ),  # ‚Üê Ruff adds this trailing comma
)
</code></pre>
<p>This turns os.path.join(...) into a tuple, and os.path.exists(...) receives a tuple instead of a string ‚Äî which breaks the logic.</p>
<hr />
<p>‚úÖ Expected (and safe) formatting:</p>
<pre><code>result = os.path.exists(
    os.path.join(
        tmp_repo_path,
        &quot;models&quot;,
        self.model_name,
        self.model_version,
        &quot;model.tar.gz&quot;,
    )
)
</code></pre>
<p>Trailing commas inside containers are fine, but not after closing a function call when the result is not part of an argument list.</p>
<hr />
<p>üîç Affected cases:</p>
<p>Ruff will apply this formatting even when:</p>
<p>The return value is assigned to a variable</p>
<p>The expression is used directly as a single argument to another call</p>
<p>The code is not inside a container</p>
<hr />
<p>üí• Why this is critical:</p>
<p>Adds semantic-breaking trailing commas silently</p>
<p>Converts values to single-element tuples ((<value>,))</p>
<p>Breaks common patterns like:</p>
<pre><code class="language-py">
result = json.load(
    open(
        os.path.join(...),
    ),  # ‚Üê breaks: open receives a tuple
)
</code></pre>
<hr />
<p>üíª Environment:</p>
<p>Ruff version: 0.11.12</p>
<p>Installed via: pre-commit with ruff-pre-commit hook</p>
<p>Config: # ruff: format = off/on tested but does not block the formatter</p>
<p>Formatter used: ruff format via pre-commit</p>
<p>Python version: 3.10.14</p>
<hr />
<p>üß™ Suggested resolution:</p>
<p>Suppress trailing comma after closing ) or ] if the value is not in a container or call argument list</p>
<p>Follow Black‚Äôs behavior (which avoids this case)</p>
<p>Or provide a configuration option to opt out of this behavior in pyproject.toml</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-info</span> added by @MichaReiser on 2025-06-03 08:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-03 08:19</div>
            <div class="timeline-body"><p>Do you have an example where the trailing comma changes the runtime semantics?</p>
<p>A trailing comma in a call expression doesn't convert the expression to a tuple. In fact, it has no runtime semantics. You can see this with:</p>
<pre><code class="language-py">def my_call(a): print(a)

my_call(1)
my_call(1,)
</code></pre>
<p>Running this program prints</p>
<pre><code>1
1
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-03 08:28</div>
            <div class="timeline-body"><pre><code class="language-result">    os.path.join(
        tmp_repo_path,
        &quot;models&quot;,
        self.model_name,
        self.model_version,
        &quot;model.tar.gz&quot;,  # ‚Üê trailing comma OK here
    )  # ‚Üê line : should **NOT** have a comma
)
</code></pre>
<p>That's the problem. Ruff tries to insert comma there.
That breaks the logic ‚Äî os.path.exists() expects a str, not a tuple.</p>
<p>I will upload full log from execution with diff to give more info in few minutes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-03 08:39</div>
            <div class="timeline-body"><p>I ran your example through the python parser (using <code>python -m ast &lt; file.py</code>) where the left is the example with a trailing comma and the right without. Both produce the exact same parsed AST (which is what python then uses to interpret your code). (<a href="https://www.diffchecker.com/YSYL5iuS/">diff</a>)</p>
<p>I think you're issue is with something else. Can you share your exact code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-03 09:06</div>
            <div class="timeline-body"><p>Diff</p>
<pre><code>+++ tests/monitoring/test_unit_monitoring.py
@@ -27,7 +27,7 @@
             (False, model_id, None),
             (True, model_id, None),
             (True, &quot;test_model_abc&quot;, ValueError),
-        ]
+        ],
     )
     def test_get_model_metadata(self, monkeypatch, spark, prod_run, model_id, exception):
         model_registry_db = &quot;discovery_ard368_mf&quot;
@@ -59,7 +59,7 @@
             (datetime(2024, 5, 20), [&quot;2024-01-24&quot;, &quot;2024-02-01&quot;, &quot;2024-02-20&quot;, &quot;2024-03-20&quot;], 0, ValueError, None),
             (datetime(2024, 1, 20), [&quot;2023-10-20&quot;, &quot;2023-11-20&quot;, &quot;2023-12-20&quot;], 0, None, &quot;2023-10-20&quot;),
             (datetime(2024, 1, 20), [&quot;2023-09-20&quot;, &quot;2023-10-20&quot;, &quot;2023-11-20&quot;, &quot;2023-12-20&quot;], 1, None, &quot;2023-09-20&quot;),
-        ]
+        ],
     )
     def test_get_prediction_date_from_given_date(self, monkeypatch, spark, monitoring, date, inference_dates, lag, exception, expected):
         monkeypatch.setattr(&quot;mddk.monitoring.monitoring.get_distinct_load_dates&quot;, lambda x, y: inference_dates)
@@ -77,7 +77,7 @@
         [
             True,
             False,
-        ]
+        ],
     )
     def test_get_prediction_results(self, monkeypatch, spark, prod_run):
         database = &quot;app_ard368_output&quot; if prod_run else &quot;discovery_ard368_output&quot;
@@ -106,7 +106,7 @@
         [
             True,
             False,
-        ]
+        ],
     )
     def test_default_classification_evaluation(self, monkeypatch, spark, prod_run):
         threshold = 0.5
@@ -155,7 +155,7 @@
             ([202402, 202403, 202404], TestDataMonitoring.metrics_data, TestDataMonitoring.metrics_result),
             (None, TestDataMonitoring.metrics_data_null_truth_dates, TestDataMonitoring.metrics_result),
             ([202402, 202403, 202404], TestDataMonitoring.metrics_data_null_values, TestDataMonitoring.metrics_result_null),
-        ]
+        ],
     )
     def test_metrics_result_to_df(self, spark, monitoring, truth_dates, expected_data, result_metrics):
 
@@ -206,7 +206,7 @@
             (True, True),
             (False, True),
             (False, False),
-        ]
+        ],
     )
     def test_run(self, monkeypatch, spark, prod_run, otv_probability):
         output_database = &quot;app_ard368_output&quot; if prod_run else &quot;discovery_ard368_output&quot;

</code></pre>
<p>Test results after suggested change.</p>
<pre><code>=========================== short test summary info ============================
FAILED tests/monitoring/test_unit_monitoring.py::TestMonitoring::test_get_prediction_results[True] - AttributeError: 'tuple' object has no attribute 'schema'
FAILED tests/monitoring/test_unit_monitoring.py::TestMonitoring::test_get_prediction_results[False] - AttributeError: 'tuple' object has no attribute 'schema'
FAILED tests/monitoring/test_unit_monitoring.py::TestMonitoring::test_join_prediction_with_truth - AttributeError: 'tuple' object has no attribute 'join'
FAILED tests/monitoring/test_unit_monitoring.py::TestMonitoring::test_add_if_not_exist_itv_otv_metrics[input_data0-input_schema0-output_data0] - AttributeError: 'tuple' object has no attribute 'filter'
FAILED tests/monitoring/test_unit_monitoring.py::TestMonitoring::test_add_if_not_exist_itv_otv_metrics[input_data1-input_schema1-output_data1] - AttributeError: 'tuple' object has no attribute 'filter'
FAILED tests/monitoring/test_unit_monitoring.py::TestMonitoring::test_add_if_not_exist_itv_otv_metrics[input_data2-input_schema2-output_data2] - AttributeError: 'tuple' object has no attribute 'filter'
====== 6 failed, 154 passed, 20 skipped, 10 warnings in 62.41s (0:01:02) =======
</code></pre>
<p>Code attached</p>
<p><a href="https://github.com/user-attachments/files/20565640/test_unit_monitoring.txt">test_unit_monitoring.txt</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-03 09:14</div>
            <div class="timeline-body"><p>Interesting. Are you sure there are no other changes?</p>
<p>I'm asking because I did the same as before. I took your example and ran both the version with and without trailing comma through the python parser and they prodcue the same AST.</p>
<p>https://www.diffchecker.com/eVPznTGs/</p>
<p>The only other thing I could think of is if pytest does source text parsing</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-03 09:18</div>
            <div class="timeline-body"><p>@AlexWaygood mentioned that this could be a bug in pytest. Let me see if I can come up with a smaller reproduction. What the formatter does here is safe under python semantics</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-03 09:20</div>
            <div class="timeline-body"><p>That's all for this file.
Happened not only in tests, but in apllication as well. Usually changing tuple to tuple of tuples, or list/dist to tuple.
I've also tried to disable formatting (fmt: off/on, fmt: skip, ruff: format = off/on). None worked and it still tried to add comma in some places.
While I agree with most of suggested fixes, this actually affected type, which is not ideal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-03 09:31</div>
            <div class="timeline-body"><p>@keita00, could you tell us:</p>
<ul>
<li>Exactly what command you're using to run your tests?</li>
<li>What version of pytest you have installed?</li>
<li>If you have any pytest plugins installed and, if so, what versions of those plugins you have installed?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-03 09:53</div>
            <div class="timeline-body"><p>Of course:
pytest-8.2.2 pytest-metadata-3.1.1 pytest_html-4.1.1 pytest_mock-3.14.0
Tests are run with this command:</p>
<pre><code>+ : 'Run tests with coverage'
+ .venv/bin/python -m coverage run --source=src -m pytest -o log_cli=true --log-level=INFO --show-capture=log -W ignore:DeprecationWarning -vv
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-04 08:26</div>
            <div class="timeline-body"><p>I created an upstream issue in pytest to figure out the next steps https://github.com/pytest-dev/pytest/issues/13489</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RonnyPfannschmidt">@RonnyPfannschmidt</a> on 2025-06-04 10:47</div>
            <div class="timeline-body"><p>Based on the provided information this is not a pytest issue</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-04 11:21</div>
            <div class="timeline-body"><p>@keita00 could you try to narrow down the problem into a smaller reproducible that doesn't depend on any of your code. Ideally, a single test that can be run without any third party dependencies and demonstrate that pytest once passes a tuple after ruff added the trailing comma</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-info</span> removed by @MichaReiser on 2025-06-04 11:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-mre</span> added by @MichaReiser on 2025-06-04 11:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-04 13:02</div>
            <div class="timeline-body"><p>I'll try to do it tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-05 11:35</div>
            <div class="timeline-body"><p>I was able to reproduce it using only one import:
from pyspark import SparkConf</p>
<pre><code>        config = SparkConf().setAll(
            [
                (&quot;spark.sql.execution.arrow.enabled&quot;, False),
                (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
                (&quot;spark.dynamicAllocation.enabled&quot;, True),
            ]
        )
</code></pre>
<p>Ruff tried to add comma:</p>
<pre><code>                 (&quot;spark.sql.execution.arrow.enabled&quot;, False),
                 (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
                 (&quot;spark.dynamicAllocation.enabled&quot;, True),
-            ]
+            ],
</code></pre>
<p>Using # ruff: format off/on didn't affect outcome and comma was still being added. This changes return value.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-05 11:48</div>
            <div class="timeline-body"><p>Can you share a few more lines. It's hard to tell what's happening given only the few lines</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-05 12:01</div>
            <div class="timeline-body"><p>@keita00, you can use Python's <code>ast</code> module in the standard library to see that the AST that Python produces is exactly the same for the two calls -- the list is not turned into a tuple because of the trailing comma being added:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; import ast
&gt;&gt;&gt; x = ast.parse(&quot;&quot;&quot;\
... config = SparkConf().setAll(
...             [
...                 (&quot;spark.sql.execution.arrow.enabled&quot;, False),
...                 (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
...                 (&quot;spark.dynamicAllocation.enabled&quot;, True),
...             ]
...         )&quot;&quot;&quot;)
&gt;&gt;&gt; y = ast.parse(&quot;&quot;&quot;\
... config = SparkConf().setAll(
...             [
...                 (&quot;spark.sql.execution.arrow.enabled&quot;, False),
...                 (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
...                 (&quot;spark.dynamicAllocation.enabled&quot;, True),
...             ],
...         )&quot;&quot;&quot;)
&gt;&gt;&gt; ast.dump(x) == ast.dump(y)
True
&gt;&gt;&gt; print(ast.dump(y, indent=2))
Module(
  body=[
    Assign(
      targets=[
        Name(id='config', ctx=Store())],
      value=Call(
        func=Attribute(
          value=Call(
            func=Name(id='SparkConf', ctx=Load())),
          attr='setAll',
          ctx=Load()),
        args=[
          List(
            elts=[
              Tuple(
                elts=[
                  Constant(value='spark.sql.execution.arrow.enabled'),
                  Constant(value=False)],
                ctx=Load()),
              Tuple(
                elts=[
                  Constant(value='spark.sql.repl.eagerEval.enabled'),
                  Constant(value=True)],
                ctx=Load()),
              Tuple(
                elts=[
                  Constant(value='spark.dynamicAllocation.enabled'),
                  Constant(value=True)],
                ctx=Load())],
            ctx=Load())]))])
</code></pre>
<p>The same applies for your original snippet in this issue:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; a = ast.parse(&quot;&quot;&quot;\
... result = os.path.exists(
...     os.path.join(
...         tmp_repo_path,
...         &quot;models&quot;,
...         self.model_name,
...         self.model_version,
...         &quot;model.tar.gz&quot;,
...     ),  # ‚Üê Ruff adds this trailing comma
... )&quot;&quot;&quot;)
&gt;&gt;&gt; b = ast.parse(&quot;&quot;&quot;\
... result = os.path.exists(
...     os.path.join(
...         tmp_repo_path,
...         &quot;models&quot;,
...         self.model_name,
...         self.model_version,
...         &quot;model.tar.gz&quot;,
...     )
... )&quot;&quot;&quot;)
&gt;&gt;&gt; ast.dump(a) == ast.dump(b)
True
&gt;&gt;&gt; print(ast.dump(b, indent=2))
Module(
  body=[
    Assign(
      targets=[
        Name(id='result', ctx=Store())],
      value=Call(
        func=Attribute(
          value=Attribute(
            value=Name(id='os', ctx=Load()),
            attr='path',
            ctx=Load()),
          attr='exists',
          ctx=Load()),
        args=[
          Call(
            func=Attribute(
              value=Attribute(
                value=Name(id='os', ctx=Load()),
                attr='path',
                ctx=Load()),
              attr='join',
              ctx=Load()),
            args=[
              Name(id='tmp_repo_path', ctx=Load()),
              Constant(value='models'),
              Attribute(
                value=Name(id='self', ctx=Load()),
                attr='model_name',
                ctx=Load()),
              Attribute(
                value=Name(id='self', ctx=Load()),
                attr='model_version',
                ctx=Load()),
              Constant(value='model.tar.gz')])]))])
</code></pre>
<p>Unless some other tool or library is somehow (inaccurately) rewriting your source code or AST before your code is executed, I don't see how the change Ruff is making here could alter the semantics of your code, unfortunately :-(</p>
<p>At runtime, both of these appear to work fine on my machine:</p>
<pre><code class="language-pycon"> % uv run --no-project --with=pyspark python
‚†ã pyspark==4.0.0                                                                                                                                                                                                        Built pyspark==4.0.0
Installed 2 packages in 11ms
Python 3.13.2 (main, Mar 17 2025, 21:26:38) [Clang 20.1.0 ] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; from pyspark import SparkConf
&gt;&gt;&gt; config = SparkConf().setAll(
...             [
...                 (&quot;spark.sql.execution.arrow.enabled&quot;, False),
...                 (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
...                 (&quot;spark.dynamicAllocation.enabled&quot;, True),
...             ]
...         )
&gt;&gt;&gt; config = SparkConf().setAll(
...             [
...                 (&quot;spark.sql.execution.arrow.enabled&quot;, False),
...                 (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
...                 (&quot;spark.dynamicAllocation.enabled&quot;, True),
...             ],
...         )
&gt;&gt;&gt;
</code></pre>
<p>You'll need to give us a <em>complete</em> snippet that shows either different AST being produced or different behaviour at runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-05 12:09</div>
            <div class="timeline-body"><p>How about this:</p>
<pre><code>    def conf(self, params: Optional[List[Tuple]] = None) -&gt; None:
        &quot;&quot;&quot;User-defined spark configuration interface.

        Args:
          params:
            Iterable of tuples. Other user-defined spark configuration variables, usually passed
            as a list of key-value pairs to set. Default value is None

        &quot;&quot;&quot;

        config = SparkConf().setAll(
            [
                (&quot;spark.sql.execution.arrow.enabled&quot;, False),
                (&quot;spark.sql.repl.eagerEval.enabled&quot;, True),
                (&quot;spark.dynamicAllocation.enabled&quot;, True),
            ]
        )

        if params:
            config.setAll(params)
        self.config = config
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by @AlexWaygood on 2025-06-05 12:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RonnyPfannschmidt">@RonnyPfannschmidt</a> on 2025-06-05 12:13</div>
            <div class="timeline-body"><p>At this point im of the impression that by deliberate censorship of the code op is accidentally hiding the real issue</p>
<p>Either tell the whole story or the issue needs to close as invalid</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keita00">@keita00</a> on 2025-06-05 12:29</div>
            <div class="timeline-body"><p>I've found out what the issue was. It's not ruff, but one of the tests was changing function attributes.
Issue was on my side. Thank you for help and advice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-05 12:31</div>
            <div class="timeline-body"><p>Glad that you fixed your issue!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-06-05 12:31</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:52:48 UTC
    </footer>
</body>
</html>
