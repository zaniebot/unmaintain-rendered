<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider deprecating UP027 or improve its docs - astral-sh/ruff #12754</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Consider deprecating UP027 or improve its docs</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/12754">#12754</a>
        opened by <a href="https://github.com/sk-">@sk-</a>
        on 2024-08-08 14:10
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sk-">@sk-</a> on 2024-08-08 14:10</div>
            <div class="timeline-body"><p>The original rule <a href="url">UP027 (unpacked-list-comprehension)</a>, implemented in <code>pyupgrade</code> does not seem to be thoroughly justified, and in fact it is actually slower. Which goes against the documentation in ruff which mentions</p>
<blockquote>
<p>which is more efficient as it avoids allocating an intermediary list</p>
</blockquote>
<p>I raised a question in <a href="https://github.com/asottile/pyupgrade/issues/961">pyupgrade</a>, showing how using generators is actually 3 times slower than unpacking a list comprehension</p>
<p><strong>System</strong>
Python 3.12.4 (main, Jun  6 2024, 18:26:44) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Mac OS Sonoma 14.5</p>
<pre><code>$ python -m timeit &quot;a,b = [i for i in range(2)]&quot;
5000000 loops, best of 5: 78.3 nsec per loop
$ python -m timeit &quot;a,b,c = [i for i in range(3)]&quot;
5000000 loops, best of 5: 86.2 nsec per loop
$ python -m timeit &quot;a,b,c,d = [i for i in range(4)]&quot;
5000000 loops, best of 5: 92.7 nsec per loop
$ python -m timeit &quot;a,b,c,d,e = [i for i in range(5)]&quot;
2000000 loops, best of 5: 114 nsec per loop

$ python -m timeit &quot;a,b = (i for i in range(2))&quot;
1000000 loops, best of 5: 225 nsec per loop
$ python -m timeit &quot;a,b,c = (i for i in range(3))&quot;
1000000 loops, best of 5: 263 nsec per loop
$python -m timeit &quot;a,b,c,d = (i for i in range(4))&quot;
1000000 loops, best of 5: 286 nsec per loop
$ python -m timeit &quot;a,b,c,d,e = (i for i in range(5))&quot;
1000000 loops, best of 5: 321 nsec per loop
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-09 01:28</div>
            <div class="timeline-body"><p>@carljm -- Do you have an opinion here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @charliermarsh on 2024-08-09 01:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @charliermarsh on 2024-08-09 01:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trim21">@trim21</a> on 2024-08-09 01:50</div>
            <div class="timeline-body"><p>should we have a reversed version as perf rule?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shoucandanghehe">@shoucandanghehe</a> on 2024-08-09 05:49</div>
            <div class="timeline-body"><p>Hi guys, I did some small tests and the results show that in python 3.6-3.12 list comprehension are faster than generator</p>
<p>| Python Version | Elements | List Comprehension (nsec per loop) | Generator (nsec per loop) | Difference (nsec) |
|----------------|----------|------------------------------------|---------------------------|-------------------|
| 3.6.13         | 2        | 315 nsec                           | 364 nsec                  | +49 nsec          |
|                | 3        | 339 nsec                           | 402 nsec                  | +63 nsec          |
|                | 4        | 368 nsec                           | 438 nsec                  | +70 nsec          |
|                | 5        | 407 nsec                           | 475 nsec                  | +68 nsec          |
| 3.7.16         | 2        | 287 nsec                           | 350 nsec                  | +63 nsec          |
|                | 3        | 321 nsec                           | 387 nsec                  | +66 nsec          |
|                | 4        | 341 nsec                           | 412 nsec                  | +71 nsec          |
|                | 5        | 374 nsec                           | 455 nsec                  | +81 nsec          |
| 3.8.19         | 2        | 269 nsec                           | 321 nsec                  | +52 nsec          |
|                | 3        | 298 nsec                           | 356 nsec                  | +58 nsec          |
|                | 4        | 324 nsec                           | 391 nsec                  | +67 nsec          |
|                | 5        | 356 nsec                           | 423 nsec                  | +67 nsec          |
| 3.9.19         | 2        | 254 nsec                           | 296 nsec                  | +42 nsec          |
|                | 3        | 287 nsec                           | 328 nsec                  | +41 nsec          |
|                | 4        | 304 nsec                           | 358 nsec                  | +54 nsec          |
|                | 5        | 345 nsec                           | 385 nsec                  | +40 nsec          |
| 3.10.14        | 2        | 272 nsec                           | 317 nsec                  | +45 nsec          |
|                | 3        | 296 nsec                           | 353 nsec                  | +57 nsec          |
|                | 4        | 327 nsec                           | 382 nsec                  | +55 nsec          |
|                | 5        | 356 nsec                           | 408 nsec                  | +52 nsec          |
| 3.11.9         | 2        | 240 nsec                           | 276 nsec                  | +36 nsec          |
|                | 3        | 264 nsec                           | 301 nsec                  | +37 nsec          |
|                | 4        | 278 nsec                           | 335 nsec                  | +57 nsec          |
|                | 5        | 320 nsec                           | 351 nsec                  | +31 nsec          |
| 3.12.4         | 2        | 112 nsec                           | 200 nsec                  | +88 nsec          |
|                | 3        | 122 nsec                           | 219 nsec                  | +97 nsec          |
|                | 4        | 136 nsec                           | 235 nsec                  | +99 nsec          |
|                | 5        | 155 nsec                           | 254 nsec                  | +99 nsec          |</p>
<p>Maybe we should remove UP027 and implement a reverse version of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-09 05:51</div>
            <div class="timeline-body"><p>I agree that the current <code>UP027</code> doesn't make any sense. Tbh I'm not a big fan of the rule in either direction; the perf difference is not massive and won't matter for most code (and may change in future as faster-cpython team have plans to improve generator perf), and I don't think there's a strong stylistic argument in either direction either. But if it makes sense to have the rule at all, it would make sense to have it in the other direction (to prefer list comprehension.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-09 15:59</div>
            <div class="timeline-body"><p>@AlexWaygood should we deprecate this rule as part of 0.6?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2024-08-12 05:33</div>
            <div class="timeline-body"><p>On the note of an inverse rule, I think that's basically what I'm asking in #11839 ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "v0.6" by @MichaReiser on 2024-08-12 06:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @MichaReiser by @MichaReiser on 2024-08-12 10:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-12 11:26</div>
            <div class="timeline-body"><blockquote>
<p>@AlexWaygood should we deprecate this rule as part of 0.6?</p>
</blockquote>
<p>Yeah, makes sense to me. I'd hold off with implementing a reverse rule, though; I agree with @carljm that there doesn't seem to be a strong argument for preferring either</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-12 11:56</div>
            <div class="timeline-body"><p>There are cases where pure generators are faster, but only when they're large enough which is way beyond the size someone would unpack ;)</p>
<pre><code>ruff on ÓÇ† ruff-0.6 [$!] is üì¶ v0.5.7 via üêç v3.12.4 via ü¶Ä v1.80.0 took 2s 
‚ùØ python -m timeit &quot;a = sum([i for i in range(1_000_000)])&quot;
10 loops, best of 5: 31.3 msec per loop

ruff on ÓÇ† ruff-0.6 [$!] is üì¶ v0.5.7 via üêç v3.12.4 via ü¶Ä v1.80.0 took 2s 
‚ùØ python -m timeit &quot;a = sum((i for i in range(1_000_000)))&quot;
10 loops, best of 5: 27 msec per loop

‚ùØ python -m timeit &quot;a = sum((i for i in range(10_000_000)))&quot;
1 loop, best of 5: 288 msec per loop

ruff on ÓÇ† ruff-0.6 [$!] is üì¶ v0.5.7 via üêç v3.12.4 via ü¶Ä v1.80.0 
‚ùØ python -m timeit &quot;a = sum([i for i in range(10_000_000)])&quot;
1 loop, best of 5: 357 msec per loop

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> removed by @MichaReiser on 2024-08-12 11:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/12843.html">astral-sh/ruff#12843</a> on 2024-08-12 11:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pypa/setuptools/pulls/4558.html">pypa/setuptools#4558</a> on 2024-08-12 12:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-08-13 15:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pypa/pip/pulls/12983.html">pypa/pip#12983</a> on 2024-09-29 10:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../asottile/pyupgrade/issues/961.html">asottile/pyupgrade#961</a> on 2024-11-08 08:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../asottile/pyupgrade/issues/257.html">asottile/pyupgrade#257</a> on 2025-02-08 10:37</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:13 UTC
    </footer>
</body>
</html>
