<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Markdown tests: merge multiple code blocks in a single section - astral-sh/ruff #15941</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Markdown tests: merge multiple code blocks in a single section</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/15941">#15941</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-02-04 15:21
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-02-04 15:21</div>
            <div class="timeline-body"><h3>Description</h3>
<p>As outlined <a href="https://github.com/astral-sh/ruff/pull/15704#issuecomment-2614068199">here</a>:</p>
<ul>
<li>concatenate all code blocks without an explicit path in a single section</li>
<li>additional checks to avoid confusion for authors of tests<ul>
<li>forbid multiple code blocks without a path in the presence of code paths with paths</li>
<li>forbid multiple code blocks without a path in the presence of code blocks with other languages (pyi, toml, …)</li>
</ul>
</li>
</ul>
<p>This would allow us to write literal tests where the prose is simply interposed in the otherwise normal flow of this specific test (which is still identified by a section heading). For example, I recently wrote this:</p>
<pre><code class="language-markdown">### Subtypes of `int`

All integer literals are subtypes of `int`:

```py
from knot_extensions import static_assert, is_subtype_of

static_assert(is_subtype_of(Literal[0], int))
static_assert(is_subtype_of(Literal[1], int))
static_assert(is_subtype_of(Literal[54165], int))
```

It is tempting to think that `int` is equivalent to the union of all integer literals,
`… | Literal[-1] | Literal[0] | Literal[1] | …`, but this is not the case. `True` and `False` are
also inhabitants of the `int` type, but they are not inhabitants of any integer literal type:

```py path=true_and_false.py
from knot_extensions import static_assert, is_subtype_of

static_assert(is_subtype_of(Literal[True], int))
static_assert(is_subtype_of(Literal[False], int))

static_assert(not is_subtype_of(Literal[True], Literal[1]))
static_assert(not is_subtype_of(Literal[False], Literal[0]))
```
</code></pre>
<p>It would be really nice if I didn't have to come up with am irrelevant file name, and if I didn't have to repeat all my includes:</p>
<pre><code class="language-markdown">### Subtypes of `int`

All integer literals are subtypes of `int`:

```py
from knot_extensions import static_assert, is_subtype_of

static_assert(is_subtype_of(Literal[0], int))
static_assert(is_subtype_of(Literal[1], int))
static_assert(is_subtype_of(Literal[54165], int))
```

It is tempting to think that `int` is equivalent to the union of all integer literals,
`… | Literal[-1] | Literal[0] | Literal[1] | …`, but this is not the case. `True` and `False` are
also inhabitants of the `int` type, but they are not inhabitants of any integer literal type:

```py
static_assert(is_subtype_of(Literal[True], int))
static_assert(is_subtype_of(Literal[False], int))

static_assert(not is_subtype_of(Literal[True], Literal[1]))
static_assert(not is_subtype_of(Literal[False], Literal[0]))
```
</code></pre>
<p>which would then render like this:</p>
<hr />
<h3>Subtypes of <code>int</code></h3>
<p>All integer literals are subtypes of <code>int</code>:</p>
<pre><code class="language-py">from knot_extensions import static_assert, is_subtype_of

static_assert(is_subtype_of(Literal[0], int))
static_assert(is_subtype_of(Literal[1], int))
static_assert(is_subtype_of(Literal[54165], int))
</code></pre>
<p>It is tempting to think that <code>int</code> is equivalent to the union of all integer literals, <code>… | Literal[-1] | Literal[0] | Literal[1] | …</code>, but this is not the case. <code>True</code> and <code>False</code> are also inhabitants of the <code>int</code> type, but they are not inhabitants of any integer literal type:</p>
<pre><code class="language-py">static_assert(is_subtype_of(Literal[True], int))
static_assert(is_subtype_of(Literal[False], int))

static_assert(not is_subtype_of(Literal[True], Literal[1]))
static_assert(not is_subtype_of(Literal[False], Literal[0]))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">testing</span> added by @sharkdp on 2025-02-04 15:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-02-04 15:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-04 15:24</div>
            <div class="timeline-body"><p>The only downside I see to this is that line numbers in diagnostics could be off. But I think that's fine. I don't forsee us writing many pros-tests that also snapshot the entire diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-02-04 16:16</div>
            <div class="timeline-body"><blockquote>
<p>The only downside I see to this is that line numbers in diagnostics could be off.</p>
</blockquote>
<p>That's a good point. If we can't patch them up, it might be difficult to debug those tests as well :slightly_frowning_face:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-04 17:50</div>
            <div class="timeline-body"><p>I think it's a good enough trade off. We do the same for jupyter notebooks. It just means that it is a deliberate choice whether one uses a prose like test or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2025-02-04 20:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15950.html">astral-sh/ruff#15950</a> on 2025-02-04 21:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-02-04 21:47</div>
            <div class="timeline-body"><p>I think I managed to make line numbers work for multi-snippet tests by ~~thinking very carefully about the problem~~ randomly adding and subtracting 1 in various places (#15950). I need to look at that again tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-04 21:52</div>
            <div class="timeline-body"><p>Interesting. We probably won't be able to do the same for full diagnostic snapshots</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-02-05 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-02-05 21:26</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:54 UTC
    </footer>
</body>
</html>
