<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PYI016 treats distinct interpolations as duplicates - astral-sh/ruff #19914</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>PYI016 treats distinct interpolations as duplicates</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/19914">#19914</a>
        opened by <a href="https://github.com/dscorbett">@dscorbett</a>
        on 2025-08-14 12:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dscorbett">@dscorbett</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p><a href="https://docs.astral.sh/ruff/rules/duplicate-union-member/"><code>duplicate-union-member</code> (PYI016)</a> treats f-strings’ and t-strings’ interpolations as duplicates whose values are duplicates but whose expressions are not. This applies to f-strings’ interpolations with <code>=</code> and to all t-strings’ interpolations. Either the fix should be marked unsafe in this case, or the rule should be suppressed in this case. <a href="https://play.ruff.rs/a0f3f060-9cd0-451e-9842-6f68e63c28cb">Example</a>:</p>
<pre><code class="language-console">$ cat &gt;pyi016.py &lt;&lt;'# EOF'
from typing import Annotated, get_args, get_origin

f: Annotated[int, f&quot;{00=}&quot;] | Annotated[int, f&quot;{000=}&quot;] | None = None
print([get_args(a)[1] for a in get_args(__annotate__(1)[&quot;f&quot;]) if get_origin(a) is Annotated])

t: Annotated[int, t&quot;{00}&quot;] | Annotated[int, t&quot;{000}&quot;] | None = None
print([get_args(a)[1].interpolations[0].expression for a in get_args(__annotate__(1)[&quot;t&quot;]) if get_origin(a) is Annotated])
# EOF

$ python3.14 pyi016.py
['00=0', '000=0']
['00', '000']

$ ruff --isolated check pyi016.py --select PYI016 --target-version py314 --preview --fix
Found 2 errors (2 fixed, 0 remaining).

$ cat pyi016.py
from typing import Annotated, get_args, get_origin

f: Annotated[int, f&quot;{0=}&quot;] | None = None
print([get_args(a)[1] for a in get_args(__annotate__(1)[&quot;f&quot;]) if get_origin(a) is Annotated])

t: Annotated[int, t&quot;{0}&quot;] | None = None
print([get_args(a)[1].interpolations[0].expression for a in get_args(__annotate__(1)[&quot;t&quot;]) if get_origin(a) is Annotated])

$ python3.14 pyi016.py
['0=0']
['0']
</code></pre>
<h3>Version</h3>
<p>ruff 0.12.8 (f51a228f0 2025-08-07)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @ntBre on 2025-08-14 13:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @ntBre on 2025-08-14 13:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-08-18 15:32</div>
            <div class="timeline-body"><p>CC: @dylwil3</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-08-18 18:49</div>
            <div class="timeline-body"><p>Both of these behaviors stem from our implementation of <code>ComparableExpr</code> which provides a coarser equivalence relation on expression AST nodes. I think it makes sense to make the comparable version of f-strings sensitive to the presence of the <code>=</code> / self-documenting expression specifier, since a user would explicitly put this in an f-string expression to modify its actual value as a string.</p>
<p>However, I'm not convinced we should do the same for template strings. While it is technically true that one can access the literal source text of an interpolation expression, this is intended for debugging/introspection purposes - it is an optional field and is only automatically populated by a non-empty string if you construct a t-string as a literal. (I can't really justify this beyond a philosophical point since <code>string.templatelib.Template</code> does not implement <code>__eq__</code>). Although it is not disallowed, I believe the intention is that any consumer of a template string should be processing it in such a way that only the value (or perhaps the AST?) of the expression is relevant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-08-19 06:31</div>
            <div class="timeline-body"><blockquote>
<p>Although it is not disallowed, I believe the intention is that any consumer of a template string should be processing it in such a way that only the value (or perhaps the AST?) of the expression is relevant</p>
</blockquote>
<p>My understanding from the discussion on discuss python was that whitespace in a debug expression isn't semantically meaningful and tools are free to change the expression's whitespace (e.g. a formatter).</p>
<p>I otherwise think that comparing t-strings should account for the debug expression (or we need to make <code>ComparableExpr</code> parametrizable because the right behavior might differ from rule to rule)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:53:12 UTC
    </footer>
</body>
</html>
