<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix for false positive on F401 breaks valid code - astral-sh/ruff #4521</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Fix for false positive on F401 breaks valid code</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/4521">#4521</a>
        opened by <a href="https://github.com/RUrlus">@RUrlus</a>
        on 2023-05-19 08:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/RUrlus">@RUrlus</a></div>
            <div class="timeline-body"><ul>
<li>ruff v0.0.269</li>
<li>CPython 3.10.9</li>
</ul>
<p><strong>Issue</strong></p>
<p>ruff flags a false positive F401 for imports that are used in <code>__all__</code> that is guarded by a conditional statement.
Running ruff with <code>--fix</code> on will result in broken imports.</p>
<p><strong>MRE</strong></p>
<pre><code>import random


def some_dependency_check():
    return random.uniform(0.0, 1.0) &gt; 0.49999

if some_dependency_check():
    import math

    __all__ = [&quot;math&quot;]
else:
    __all__ = []

</code></pre>
<pre><code>-&gt; ruff mre.py
mre.py:9:12: F401 [*] `math` imported but unused
Found 1 error.
[*] 1 potentially fixable with the --fix option.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/charliermarsh">@charliermarsh</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-19 12:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-19 12:50</div>
            <div class="timeline-body"><p>So, can and should avoid flagging this as unused...</p>
<p>I do feel obligated to mention that you should try to avoid using conditionally-defined <code>__all__</code> assignments :) They will cause issues with all sorts of tooling, since many conditions are undecidable at &quot;compile&quot; time, e.g., Pyright treats <code>x</code> as undefined if you use a wildcard import on this file:</p>
<pre><code>x = 1

if x &gt; 0:
    __all__ = [&quot;x&quot;]
else:
    __all__ = []
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-19 12:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JonathanPlasse">@JonathanPlasse</a> on 2023-05-19 12:53</div>
            <div class="timeline-body"><p>We should maybe merge all <code>__all__</code>s.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RUrlus">@RUrlus</a> on 2023-05-19 13:45</div>
            <div class="timeline-body"><p>@charliermarsh Thanks for the quick response!</p>
<p>In the example you gave, <code>x</code> is an ast.Constant and thus pyright could/ should conclude that the <code>else</code> branch is unreachable <em>at import time</em> .</p>
<blockquote>
<p>I do feel obligated to mention that you should try to avoid using conditionally-defined <strong>all</strong> assignments</p>
</blockquote>
<p>I agree, but I don&#x27;t know how to avoid it in the pattern where I encountered this.  I want to support different backends/types for dispatching without making all of them dependencies:</p>
<pre><code>from foo.backends import pandas, spark

@singledispatch
def strip_punctuation(data):
    raise NotImplementedError(f&quot;no backend with support for type {type(data)} was found&quot;)

if pandas._supported:
    strip_punctuation.register(pandas.strip_punctuation)

if spark._supported:
    strip_punctuation.register(spark.strip_punctuation)
</code></pre>
<p>Where the imports are guarded, <code>foo.backends.pandas.__init__.py</code>:</p>
<pre><code>_supported = can_import(&quot;pandas&quot;)
if _supported:
    from foo.backends.pandas.string import strip_punctuation
    
    __all__ = [&quot;strip_punctuation&quot;]
else:
    __all__ = []
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-19 14:03</div>
            <div class="timeline-body"><p>@JonathanPlasse - Yeah I think that&#x27;s probably what we need to do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JonathanPlasse">@JonathanPlasse</a> on 2023-05-19 14:05</div>
            <div class="timeline-body"><p>~I can work on it if you want.~</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-19 14:26</div>
            <div class="timeline-body"><blockquote>
<p>@JonathanPlasse - Yeah I think that&#x27;s probably what we need to do.</p>
</blockquote>
<p>I&#x27;m not sure if merging gives us the desired result in all situations:</p>
<ul>
<li>When testing for public docstrings -&gt; Merging them is what we want</li>
<li>When testing for invalid imports -&gt; Merging is unsound because it then wont flag imports that may not exist at runtime. A better approach for this use case is to explicitly determine the &quot;conditional&quot; exports and potentially warn about them (but not flag any that are in both sets)</li>
<li>others?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-19 14:38</div>
            <div class="timeline-body"><p>Yeah that&#x27;s true. Another option could be to iterate over all <code>Export</code> bindings (even those that are overridden) when we do these checks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-24 03:43</div>
            <div class="timeline-body"><p>I&#x27;m looking into this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-06 00:48</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:36 UTC
    </footer>
</body>
</html>
