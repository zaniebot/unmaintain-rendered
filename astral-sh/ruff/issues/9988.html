<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New rule: dependency specification linting - astral-sh/ruff #9988</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>New rule: dependency specification linting</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/9988">#9988</a>
        opened by <a href="https://github.com/QMalcolm">@QMalcolm</a>
        on 2024-02-14 16:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/QMalcolm">@QMalcolm</a></div>
            <div class="timeline-body">Context
<p>Working in many python projects over the years, I&#x27;ve experienced on occasion <em>bad things happening</em> ᵀᴹ due to the accidental allowance of more than one major version of a package via dependency specification. Sometimes this is known and intentional, other times it is accidental and dangerous. A recent example of this that I experienced was that I <a href="https://github.com/dbt-labs/dbt-semantic-interfaces/pull/238">upgraded dbt-semantic-interfaces</a> to support both Pydantic 1 and Pydantic 2 (intentionally). A downstream package installed alongside <code>dbt-semantic-interfaces</code> had it&#x27;s pydantic dependency specified as <code>pydantic&gt;=1.0,&lt;=2.0</code>. However, it was never intended to actually support Pydantic 2. It should have been <code>pydantic&gt;=1.0,&lt;2.0</code>, but because of the <code>&lt;=</code> it started blowing up at runtime.</p>
Desired Improvement
<p>It&#x27;d be amazing to have a rule for linting python dependencies that ensures the allowance of multiple major versions of a dependency is always known and intentional. In my mind there are a few different types of dependency major version range specification that exist: unconstrained, constrained, and singular.</p>
Singular Major Version
<p>A singular major version specification means that only one major version for a given dependency is allowed by the specification. Thus, the linter should never raise an error for singular major version specifications of dependencies. Singular major version specifications look like the following</p>
<pre><code># only ever 1.5.7, thus only major version 1
package_a == 1.5.

# Allows for versions &gt;= 1.0 and &lt; 2, thus only major version 1
package_b ~= 1.0

# Allows for exactly what it says, thus only major version 1     
package_c &gt;= 1.3.4, &lt;2
</code></pre>
Constrained Major Version
<p>A constrained major version means that there is an upper bound specification, and the major version of the upper bound specification is different that the specified or implicit lower bound specification (if a lower bound isn’t specified it is implicitly 0.0).</p>
<p>This type of version specification is dangerous because major versions are generally where large breaking changes happen. Sometimes there is compatibility between major versions or compatibility might be possible through shimming, but this should be known and intentional. Thus, the linter should raise an error for this type of dependency version specification unless there is a comment to acknowledge it like <code># ignore:constrained_range</code> or something similar. The following are examples of constrained major version specifications</p>
<pre><code># major versions allowed are [0, 1], an error should be raised
package_a &lt; 2

# major versions allowed are [1, 2, 3], an error should be raised
package_b &gt;= 1.0, &lt;= 3

# major versions allowed are [1, 2], an error should be raised
package_c &gt;= 1.0, &lt; 3
</code></pre>
<p>Again all the above should have an error raised by the linter unless an acknowledgement is made that this is intentional like the following</p>
<pre><code># major versions allowed are [1, 2]
package_a &gt;= 1.0, &lt; 3  # ignore:constrained_range
</code></pre>
Unconstrained Major Version
<p>An unconstrained major version means that lower bound is specified or implicit, but no upper bound is provided. These are incredibly dangerous as large breaking changes are normal across major versions, this type of specification allows for any new major version to be automatically included as available. This type of version specification <em>should always raise</em> an error by the linter and not be ignorable. The following are examples unconstrained major version specifications</p>
<pre><code># allows for major versions [0, 1, 2, ..., infinitey]
package_a

# allows for major versions [2, 3, 4, ..., infinitey]
package_b &gt;= 2
</code></pre>
<hr>
<p>I&#x27;m happy to help contribute this, although I&#x27;m not super well versed in Rust. I&#x27;m currently working on a prototype in python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;New rule: dependency linting&quot; to &quot;New rule: dependency specification linting&quot; by <a href="https://github.com/QMalcolm">@QMalcolm</a> on 2024-02-14 16:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-02-14 16:45</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:50 UTC
    </footer>
</body>
</html>
