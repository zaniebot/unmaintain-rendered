<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F401 false positive for forward references in TypeAliases - astral-sh/ruff #17455</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>F401 false positive for forward references in TypeAliases</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/17455">#17455</a>
        opened by <a href="https://github.com/ktbarrett">@ktbarrett</a>
        on 2025-04-17 23:25
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-04-17 23:25</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>When using forward references on the right hand side of the <code>=</code> in a type alias, ruff considers the types used in that forward reference unused and issues a F401. Interestingly, the <code>&quot;TypeAlias&quot;</code> import does not cause an issue because it's used in an annotation.</p>
<p>https://play.ruff.rs/e30129f9-c09c-4c76-9272-9aa757ece49b</p>
<p>It seems that ruff needs to be aware of type aliases and treat the right side as uses. While this isn't possible for implicit aliases (where <code>TypeAlias</code> is <em>not</em> used in the annotation of the alias), it is possible for explicit aliases.</p>
<h3>Version</h3>
<p>0.11.6</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "F401 false positive for forward references" to "F401 false positive for forward references in TypeAliases" by @ktbarrett on 2025-04-17 23:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ktbarrett">@ktbarrett</a> on 2025-04-17 23:28</div>
            <div class="timeline-body"><p>Perhaps the implicit alias can be supported, you'll just have to do a program-wide check to see if the variable on the left hand side is ever used in a type annotation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-04-18 09:08</div>
            <div class="timeline-body"><p>This happens because of the string forward reference for <code>TypeAlias</code>, ruff understands type aliases just fine without the forward reference.</p>
<p>I see two potential ways to address this:</p>
<ol>
<li><p>If the trimmed annotation only contains alphanumeric characters and dots, try to resolve that name and if it resolves to <code>{typing module}.TypeAlias</code> take the same branch as if it hadn't been a forward reference. This seems however like it might add quite a bit of overhead, since we're doing speculative work for every <code>AnnAssign</code> with a string annotation.</p>
</li>
<li><p>If we encounter <code>{typing module}.TypeAlias</code> when walking a deferred string annotation, check if the parent node is a <code>AnnAssign</code> and if so, re-walk the <code>value</code> expression of that node to collect all the string literals into <code>string_type_definitions</code> so they get parsed and walked in the next iteration of the checker loop dealing with string forward references.</p>
</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-04-18 09:15</div>
            <div class="timeline-body"><p>That being said, I think only 1. really promises correct semantics for rules like TC007 and TC008 that depend on the <code>in_annotated_type_alias</code>/<code>in_type_alias</code> checks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @ntBre on 2025-04-23 14:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pekkaklarck">@pekkaklarck</a> on 2025-04-26 12:16</div>
            <div class="timeline-body"><p>This seems to be similar to #9298.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/9298.html">astral-sh/ruff#9298</a> on 2025-04-26 12:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-04-26 15:13</div>
            <div class="timeline-body"><p>@pekkaklarck It's not really related to the other issue. The other issue is mostly about lack of type inference and multi-file analysis, so ruff doesn't know which subscripts are generics and which ones aren't. There isn't really a better solution to this than what we currently have, because if you start treating more things as generic subscripts instead of regular subscripts, you will instead start getting false positives for <code>undefined-name</code> (<code>F821</code>) and other rules that rely on the string being correctly interpreted as a string, rather than a forward reference.</p>
<p>This issue on the other hand is more of a chicken and egg problem. In order to know that this assignment is an annotated type alias we need to resolve the forward reference, but in order to correctly resolve forward references, we need to defer evaluating them until the entire module has been analyzed.</p>
<p>But once we have determined that this is indeed a type alias, it is already too late, because we already had to analyze the r.h.s. of the assignment without the knowledge that this is a type alias. If we defer the r.h.s. the references will be incorrect once we finally do walk it and if we don't defer the annotation, the references in the annotation will be incorrect.</p>
<p>So the best we can do is do, is to do the same thing we do for <code>from __future__ import annotations</code> and do a speculative lookup of the annotation to see whether or not it resolves to <code>{typing module}.TypeAlias</code>, which would require us to parse all forward references in <code>AnnAssign.annotation</code> eagerly, rather than lazily. You can still get the wrong result that way by moving the import of <code>TypeAlias</code> below its use, but that's a highly unorthodox use-case, so likely not a problem many people will encounter.</p>
<p>We may be able to get away with something simpler, like trying to interpret the annotation as a dotted name. If the text isn't a dotted name we know it can't resolve to <code>{typing module}.TypeAlias</code> and if the dotted name doesn't resolve to <code>{typing module}.TypeAlias</code> we know that it's very unlikely that it will ever resolve to it, even after we analyze the rest of the module. But doing that might be more expensive than eagerly parsing the annotation and doing the standard name matching lookup, since we need to eventually parse it anyways.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../cocotb/cocotb/pulls/4745.html">cocotb/cocotb#4745</a> on 2025-06-11 17:09</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:55 UTC
    </footer>
</body>
</html>
