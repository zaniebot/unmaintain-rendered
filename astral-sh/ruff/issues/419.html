<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Is there a design pattern that would let us more closely couple `CheckKind` and `CheckCode`? - astral-sh/ruff #419</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Is there a design pattern that would let us more closely couple `CheckKind` and `CheckCode`?</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/419">#419</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2022-10-13 13:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-13 13:31</div>
            <div class="timeline-body"><p>Right now, we have matches in each implementation that create bidirectional links between <code>CheckKind</code> and <code>CheckCode</code>. But there's nothing enforcing this behavior, and it's really tedious to implement.</p>
<p>I'd love something like (made-up syntax):</p>
<pre><code class="language-rust">CheckKind::UnusedImport(CheckCode::F401, ...)
</code></pre>
<p>...that keeps them coupled with a single definition. What's possible here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @charliermarsh on 2022-10-13 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-10-27 17:09</div>
            <div class="timeline-body"><p>We could have a <code>Check</code> trait and treat each error as its own struct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/squiddy">@squiddy</a> on 2022-12-06 20:01</div>
            <div class="timeline-body"><p>Those bidirectional links I also struggled with (or rather, forgot to update certain parts) when implementing my first check. I've been looking at rust &amp; clippy lately, and there are some interesting ideas. Some of which also related to that other ticket about updating <code>Checker</code>.</p>
<p>Short summary how this roughly works with clippy, taking the <code>REDUNDANT_FIELD_NAMES</code> lint. Declaring a lint:</p>
<pre><code class="language-rust">declare_clippy_lint! {
    /// ### What it does
    /// Checks for fields in struct literals where shorthands
    /// could be used.
    pub REDUNDANT_FIELD_NAMES,
    style,
    &quot;checks for fields in struct literals where shorthands could be used&quot;
}
</code></pre>
<p>Through some macros from rust this eventually expands into something like this:</p>
<pre><code class="language-rust">pub static REDUNDANT_FIELD_NAMES: &amp;crate::Lint = &amp;crate::Lint {
    name: &quot;clippy::REDUNDANT_FIELD_NAMES&quot;,
    desc: &quot;...snip...&quot;,
    ...snip...
};

pub(crate) static REDUNDANT_FIELD_NAMES_INFO: &amp;'static crate::LintInfo = &amp;crate::LintInfo {
    lint: &amp;REDUNDANT_FIELD_NAMES,
    category: crate::LintCategory::Style,
    explanation: &quot;... snip ...&quot;,
};
</code></pre>
<hr />
<p>Now this in itself I find valuable already, tying together everything related to a lint (or check/checkkind). We could have:</p>
<pre><code class="language-rust">declare_check! {
    /// What does this do? Why is this bad?
    MODULE_IMPORT_NOT_AT_TOP_OF_FILE,
    E402,
    Pycodestyle,
    &quot;Module level import not at top of file&quot;
}
</code></pre>
<p>Somewhere else, a global list of available checks:</p>
<pre><code class="language-rust">pub static CHECKS: &amp;'static [&amp;Check] = &amp;[MODULE_IMPORT_NOT_AT_TOP_OF_FILE, ...];
</code></pre>
<p>Using such a check (just making this up):</p>
<pre><code class="language-rust">if self.settings.enabled.contains(&amp;MODULE_IMPORT_NOT_AT_TOP_OF_FILE) {
   if self.seen_import_boundary &amp;&amp; stmt.location.column() == 0 {
       self.add_check(Check::new(
           MODULE_IMPORT_NOT_AT_TOP_OF_FILE,
           Range::from_located(stmt),
       ));
   }
}
</code></pre>
<p>Making this check like this would also lower the significance of check code in ruff's code, which, if I understood that other ticket correctly, is something you see ruff moving to.</p>
<hr />
<p>I'm happy to look further into this and come up with some proof-of-concept.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/squiddy">@squiddy</a> on 2022-12-06 20:12</div>
            <div class="timeline-body"><p>Clippy &amp; rust have traits for &quot;passes&quot;. <code>EarlyLintPass</code> for AST information, <code>LateLintPass</code> after type checking etc. <code>REDUNDANT_FIELD_NAMES</code> would use those like this (excerpt):</p>
<pre><code class="language-rust">impl EarlyLintPass for RedundantFieldNames {
    fn check_expr(&amp;mut self, cx: &amp;EarlyContext&lt;'_&gt;, expr: &amp;Expr) {
        if let ExprKind::Struct(ref se) = expr.kind {
            for field in &amp;se.fields {
                if field.is_shorthand {
                    continue;
                }
                if let ExprKind::Path(None, path) = &amp;field.expr.kind {
                    if path.segments.len() == 1
                        &amp;&amp; path.segments[0].ident == field.ident
                        &amp;&amp; path.segments[0].args.is_none()
                    {
                        span_lint_and_sugg(
                            cx,
                            REDUNDANT_FIELD_NAMES,
                            field.span,
                            &quot;redundant field names in struct initialization&quot;,
                            &quot;replace it with&quot;,
                            field.ident.to_string(),
                            Applicability::MachineApplicable,
                        );
                    }
                }
            }
        }
    }
}
</code></pre>
<p>Then there is a <code>LintStore</code> where all these passes are registered explicitely, much of which is automated by a script however.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-06 21:13</div>
            <div class="timeline-body"><p>Yeah I'd definitely be interested in a proposal or draft PR here, and I think something based on macros would make sense. My main hesitation is that the current system based on enums has really strong type-safety (apart from the non-enforced coupling between &quot;code&quot; and &quot;kind&quot;) and plays well with autocomplete, and macros tend to make code harder to work with in the editor since it requires compile-time expansion (making a fuzzy claim here but hopefully you get what I mean).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/squiddy">@squiddy</a> on 2022-12-06 22:31</div>
            <div class="timeline-body"><p>Oh yeah, I get it. Initially I also wouldn't use macros but just type it out first. Syntactic sugar/shortcuts can come later. I think in the case of clippy the usage of macros also comes from it using existing infrastructure (based on macros) from the rust compiler.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/squiddy">@squiddy</a> on 2022-12-18 06:31</div>
            <div class="timeline-body"><pre><code class="language-rust">pub struct CheckDef {
    pub name: &amp;'static str,
    pub description: &amp;'static str,
    pub code: CheckCode,
    pub category: CheckCategory,
    pub lint_source: LintSource,
}

pub struct Check {
    pub definition: &amp;'static CheckDef,
    pub location: Location,
    pub end_location: Location,
    pub fix: Option&lt;Fix&gt;,
    pub message: String,
}

// Defining new checks (these would live in the pyflakes/pycodestyle modules).

pub static RAISE_NOT_IMPLEMENTED: &amp;CheckDef = &amp;CheckDef {
    name: &quot;raise_not_implemented&quot;,
    description: &quot;`raise NotImplemented` should be `raise NotImplementedError`&quot;,
    code: CheckCode::F901,
    category: CheckCategory::Pyflakes,
    lint_source: LintSource::AST,
};

pub static AMBIGUOUS_CLASS_NAME: &amp;CheckDef = &amp;CheckDef {
    name: &quot;ambiguous_class_name&quot;,
    description: &quot;Ambigious class name: ...&quot;,
    code: CheckCode::E742,
    category: CheckCategory::Pycodestyle,
    lint_source: LintSource::AST,
};

// Implementing new checks

pub fn ambiguous_class_name(checker: &amp;mut Checker, name: &amp;str, location: Range) {
    if is_ambiguous_name(name) {
        checker.add_check(Check::new(
            AMBIGUOUS_CLASS_NAME,
            format!(&quot;Ambiguous class name: `{name}`&quot;),
            location,
        ));
    }
}

pub fn raise_not_implemented(checker: &amp;mut Checker, expr: &amp;Expr) {
    if let Some(expr) = match_not_implemented(expr) {
        let mut check = Check::new(
            RAISE_NOT_IMPLEMENTED,
            &quot;`raise NotImplemented` should be `raise NotImplementedError`&quot;.to_string(),
            Range::from_located(expr),
        );
        if checker.patch(RAISE_NOT_IMPLEMENTED) {
            check.amend(Fix::replacement(
                &quot;NotImplementedError&quot;.to_string(),
                expr.location,
                expr.end_location.unwrap(),
            ));
        }
        checker.add_check(check);
    }
}

// Check ast

if self.settings.enabled.contains(RAISE_NOT_IMPLEMENTED) {
    if let Some(expr) = exc {
        pyflakes::plugins::raise_not_implemented(self, expr);
    }
}
</code></pre>
<p>This doesn't give the same type safety guarantees as the current code though, e.g. multiple checks could map to the same error code, could reuse the same name etc. Haven't yet figured out that part.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/1685.html">astral-sh/ruff#1685</a> on 2023-01-06 11:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-07 20:53</div>
            <div class="timeline-body"><p>Greatly improved by #1685!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-01-07 20:53</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:48 UTC
    </footer>
</body>
</html>
