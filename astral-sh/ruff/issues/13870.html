<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Proper handling of empty intersections and Never. - astral-sh/ruff #13870</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Proper handling of empty intersections and Never.</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/13870">#13870</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-10-21 21:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-10-21 21:41</div>
            <div class="timeline-body"><p>I found this while creating the type <code>Literal[1, 2, 3] &amp; ~Literal[1] &amp; ~Literal[2]</code>. I was expecting to get <code>Literal[3]</code> after all simplifications were applied, but I got <code>~Literal[2] | Literal[3]</code> instead. This is clearly not optimal.</p>
<p>The reason for this behavior is the following (using <code>1</code> instead of <code>Literal[1]</code> etc): When adding the first negation, we get the following in the union-of-intersections representation:</p>
<pre><code>  (1 | 2 | 3) &amp; ~1
= (1 &amp; ~1 | 2 &amp; ~1 | 3 &amp; ~1)
</code></pre>
<p>In the second and third component, the simplification creates <code>2 &amp; ~1 = 2</code> and <code>3 &amp; ~1 = 3</code>, as expected. In the first component, the current implementation of simplification removes all positive (1) and negative (~1) components from the intersection, leaving an empty intersection:</p>
<pre><code>= (empty-intersection | 2 | 3)
</code></pre>
<p>The idea was that the <code>empty-intersection</code> would represent <code>Never</code> (similar to how <code>IntersectionBuilder::build()</code> returns <code>Never</code> for the empty-empty case). But an empty intersection should actually represent the type <code>object</code>. To represent <code>Never</code>, we would need to explicitly add <code>Never</code> to the positive side. Since we don't do that, we end up creating</p>
<pre><code>  (empty-intersection | 2 | 3) &amp; ~2
= (~2 | 2 &amp; ~2 | 3 &amp; ~2)
= ~2 | Never | 3
= ~2 | 3
</code></pre>
<p>in the second step.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @sharkdp on 2024-10-21 21:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2024-10-21 21:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2024-10-21 21:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">great writeup</span> added by @AlexWaygood on 2024-10-21 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2024-10-22 11:32</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-10-22 11:34</div>
            <div class="timeline-body"><p>Hey GitHub, I said <em>&quot;while <strong>trying</strong> to fix #13876&quot;</em> in that PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @sharkdp on 2024-10-22 11:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-10-22 13:35</div>
            <div class="timeline-body"><p>~~The fundamental problem is the following. In <code>bindings_ty</code>, we use <code>IntersectionBuilder::add_positive</code> with constraints, as if that would mean: build the intersection with the existing <code>binding_ty</code> type:~~</p>
<p>https://github.com/astral-sh/ruff/blob/7dbd8f0f8e725d05cc1d15e6ef1c6cc2ed2b2090/crates/red_knot_python_semantic/src/types.rs#L156-L161</p>
<p>~~But the intersection between <code>A &amp; B</code> is subtly different from <code>IB::new().add_positive(A).add_positive(B).build()</code>, if <code>A</code> and/or <code>B</code> are intersections themselves. For example, if <code>A = {pos = [p]; neg = []}</code> and <code>B = {pos = []; neg = [n]}</code>, using <code>.add_positive(A).add_positive(B)</code> will result in an intersection with <code>{pos = [p]; neg = [n]}</code>. However, <code>B</code> is actually <code>Never</code>, so the intersection between <code>A &amp; B</code> is also <code>Never</code>.~~</p>
<p>~~Note: Those intermediate empty positive/negative lists can appear while building up a larger intersection type (due to simplification), which is exactly what happens in the code above.~~</p>
<p>~~I will try to fix this by adding a <code>Type::intersect</code> method.~~</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Intersections with only negative contributions should be equal to Never" to "[red-knot] Proper handling of empty intersections and Never." by @sharkdp on 2024-10-22 18:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2024-10-22 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2024-10-22 19:02</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:35:30 UTC
    </footer>
</body>
</html>
