<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>invalid syntax error with something that looks like a `match` statement - astral-sh/ruff #22528</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>invalid syntax error with something that looks like a <code>match</code> statement</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/22528">#22528</a>
        opened by <a href="https://github.com/KotlinIsland">@KotlinIsland</a>
        on 2026-01-12 08:42
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/KotlinIsland">@KotlinIsland</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<pre><code class="language-py">from re import *

def main(x, y, z):
    match [x, y, z]:                        {   #&lt;--- load bearing brace
        case [0, 1, 2]: print(&quot;a&quot;),
        case [3, 4, 5]: print(&quot;b&quot;),
        case [_, _, _]: exit(1)
                                            }   #&lt;--- load bearing brace
    print(&quot;all good&quot;)

main(4, 2, 0)
</code></pre>
<p><a href="https://play.ruff.rs/516ccd06-b6b5-436a-8dd7-a86420a746c1">playground</a></p>
<p><code>Expected newline, found </code>{<code> (invalid-syntax) [Ln 4, Col 45]</code></p>
<p>finders credit to @decorator-factory</p>
<details><summary>Solution</summary>
<p>

<pre><code class="language-py">from re import match

match[0]: int  # Expected newline, found name(invalid-syntax)
</code></pre>
</p>
</details> 

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-12 08:50</div>
            <div class="timeline-body"><p>wow...</p>
<p>In case anyone else wonders as what this is supposed to parse. It's an annotated assignment (the target is a subscript expression)</p>
<pre><code>Module(
   body=[
      ImportFrom(
         module='re',
         names=[
            alias(name='*')],
         level=0),
      FunctionDef(
         name='main',
         args=arguments(
            args=[
               arg(arg='x'),
               arg(arg='y'),
               arg(arg='z')]),
         body=[
            AnnAssign(
               target=Subscript(
                  value=Name(id='match', ctx=Load()),
                  slice=Tuple(
                     elts=[
                        Name(id='x', ctx=Load()),
                        Name(id='y', ctx=Load()),
                        Name(id='z', ctx=Load())],
                     ctx=Load()),
                  ctx=Store()),
               annotation=Dict(
                  keys=[
                     Subscript(
                        value=Name(id='case', ctx=Load()),
                        slice=Tuple(
                           elts=[
                              Constant(value=0),
                              Constant(value=1),
                              Constant(value=2)],
                           ctx=Load()),
                        ctx=Load()),
                     Subscript(
                        value=Name(id='case', ctx=Load()),
                        slice=Tuple(
                           elts=[
                              Constant(value=3),
                              Constant(value=4),
                              Constant(value=5)],
                           ctx=Load()),
                        ctx=Load()),
                     Subscript(
                        value=Name(id='case', ctx=Load()),
                        slice=Tuple(
                           elts=[
                              Name(id='_', ctx=Load()),
                              Name(id='_', ctx=Load()),
                              Name(id='_', ctx=Load())],
                           ctx=Load()),
                        ctx=Load())],
                  values=[
                     Call(
                        func=Name(id='print', ctx=Load()),
                        args=[
                           Constant(value='a')]),
                     Call(
                        func=Name(id='print', ctx=Load()),
                        args=[
                           Constant(value='b')]),
                     Call(
                        func=Name(id='exit', ctx=Load()),
                        args=[
                           Constant(value=1)])]),
               simple=0),
            Expr(
               value=Call(
                  func=Name(id='print', ctx=Load()),
                  args=[
                     Constant(value='all good')]))]),
      Expr(
         value=Call(
            func=Name(id='main', ctx=Load()),
            args=[
               Constant(value=4),
               Constant(value=2),
               Constant(value=0)]))])

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @MichaReiser on 2026-01-12 08:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">parser</span> added by @MichaReiser on 2026-01-12 08:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2026-01-12 20:58</div>
            <div class="timeline-body"><p>A minimal fix for just this example would be something like this:</p>
<pre><code class="language-diff">diff --git i/crates/ruff_python_parser/src/parser/statement.rs w/crates/ruff_python_parser/src/parser/statement.rs
index 0a56768df5..ae334e8b1d 100644
--- i/crates/ruff_python_parser/src/parser/statement.rs
+++ w/crates/ruff_python_parser/src/parser/statement.rs
@@ -2449,9 +2449,14 @@ impl&lt;'src&gt; Parser&lt;'src&gt; {
 
         match self.current_token_kind() {
             TokenKind::Colon =&gt; {
-                // `match` is a keyword
+                // `match` is a keyword or annotated assignment
                 self.bump(TokenKind::Colon);
 
+                if self.current_token_kind() != TokenKind::Newline {
+                    self.rewind(checkpoint);
+                    return None;
+                }
+
                 let cases = self.parse_match_body();
 
                 Some(ast::StmtMatch {
</code></pre>
<p>But I think the correct thing to do is mimic the CPython behavior more precisely. The relevant code is here:</p>
<p>https://github.com/python/cpython/blob/66e1399311c17684c6e26f5d9d9603fbd0717d0d/Parser/parser.c#L7765-L7778</p>
<p>and I believe the logic is to revert to treating <code>match</code> as an identifier unless we &quot;match&quot; (pun intended) the pattern: <code>match</code>, followed by valid <code>subject</code>, followed by <code>:</code> and <code>Newline</code> and indent, followed by one or more valid <code>case</code>s, followed by a <code>dedent</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-12 21:25</div>
            <div class="timeline-body"><blockquote>
<p>But I think the correct thing to do is mimic the CPython behavior more precisely. The relevant code is here:</p>
</blockquote>
<p>I'm not sure that's trivial, because it seems they perform a lookahead over the entire <code>case</code> (which can be an arbitrary number of tokens).</p>
<p>Unlike Python, we also strive to still parse as much as possible even in the presence of an error. So we need to be careful not to be too strict (but obviously, also not deny valid syntax)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 22:26:04 UTC
    </footer>
</body>
</html>
