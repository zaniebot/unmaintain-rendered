<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>formater: PEP8 operator recommendations - astral-sh/ruff #18868</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>formater: PEP8 operator recommendations</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/18868">#18868</a>
        opened by <a href="https://github.com/DerWeh">@DerWeh</a>
        on 2025-06-22 21:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/DerWeh">@DerWeh</a></div>
            <div class="timeline-body"><h3>Question</h3>
<p>(Sorry, if this issue already popped up, but I didn't find anything.)
Thank you very much for this incredible formatter, which helps to end pointless discussions on stylistic choices.</p>
<p>I just have one problem, that is the spacing operators, which in fact reduces readability. And we all know:</p>
<blockquote>
<p>Readability counts.</p>
</blockquote>
<p><code>ruff</code> consistently places a single space around binary operators. <a href="https://peps.python.org/pep-0008/#other-recommendations">PEP8</a>, on the other hand, suggests:</p>
<blockquote>
<p>If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator:</p>
<pre><code class="language-python"># Correct:
i = i + 1
submitted += 1
x = x*2 - 1
hypot2 = x*x + y*y
c = (a+b) * (a-b)
</code></pre>
<pre><code class="language-python"># Wrong:
i=i+1
submitted +=1
x = x * 2 - 1
hypot2 = x * x + y * y
c = (a + b) * (a - b)
</code></pre>
</blockquote>
<p>The <code>use your own judgment</code> is, of course, not really suitable for an automatic formatter, but I am confident, that we can do better than the current default. My suggestion: don't put spaces around the highest priority operator if there are operators with different priority in the same parenthesis or line if there are no parentheses.[^1]
In my opinion, enforcing this with an automatic formatter would reduce misunderstandings, as the reader is less likely to make wrong assumptions on the operator priority.</p>
<p>Other alternatives are to always use parentheses or to always split the equation on multiple lines, but both options reduce readability due to visual clutter.</p>
<p>Currently, this issue is a showstopper for me to adopt <code>ruff</code> for numerical code. Of course, I can turn off formatting selectively for equations, but this is a rather error-prone solution that counters the purpose of automatic formatters.</p>
<details>
<summary> ðŸ”½ Note: ruff puts spaces around `**` if there are parentheses or brackets involved, else not</summary>

<pre><code class="language-python">3**2
(2 + 1) ** 2
3 ** (1 + 1)
sqrt(9) ** 2
3 ** sqrt(4)
np.finfo(np.float64).eps ** 0.25
tt[small] ** 2
</code></pre>
<p>The behavior seems a little odd to me. Is this intentional?</p>
</details>

<hr />
<details>
 <summary>In the following, I provide some more code examples from my own code base</summary>

<pre><code class="language-python"># mine
W = (0.25*U*U + 4*t*t)**0.5
E_0 = 0.5*U - W
gf_z = (0.5 + s*t/W) / (z - (E_0 + s*t))
gf_z += (0.5 - s*t/W) / (z - (U + s*t - E_0))
# ruff
W = (0.25 * U * U + 4 * t * t) ** 0.5
E_0 = 0.5 * U - W
gf_z = (0.5 + s * t / W) / (z - (E_0 + s * t))
gf_z += (0.5 - s * t / W) / (z - (U + s * t - E_0))
</code></pre>
<p>The formatted equation is very difficult to read... We have to introduce further parenthesis and reorder some expressions:</p>
<pre><code class="language-python">W = ((0.25 * U * U) + (4 * t * t)) ** 0.5
E_0 = (0.5 * U) - W
gf_z = (0.5 + (s * t / W)) / (z - (s * t + E_0))
gf_z += (0.5 - (s * t / W)) / (z - (s * t + U - E_0))
</code></pre>
<p>But it still seems too hard to read, we probably need to introduce some sub-expressions and split equations, but this in turn reduces readability...</p>
<pre><code class="language-python"># mine
denominator = 0.5 * np.pi / wn[-1]**2
# ruff
denominator = 0.5 * np.pi / wn[-1] ** 2
</code></pre>
<p>This example is not all too bad, we are used that <code>**</code> has high priority and <code>/</code> is read like a fraction.</p>
<pre><code class="language-python"># mine
self_cpa = self_cpa_re - mu + 1j*self_cpa_im  # add contribution of mu
# ruff
self_cpa = self_cpa_re - mu + 1j * self_cpa_im  # add contribution of mu
</code></pre>
<p>We are trained to read complex numbers as <code>re + 1j*im</code>. <code>re + 1j * im</code> is harder when we read left-to-right, as we see the tokens in the order <code>re</code> â†’ <code>re + 1j</code> â†’ <code>re + 1j * im</code>. Inverting the order <code>1j * im + re</code> is not a good option as we are conditioned to first get the real, then the imaginary part. <code>re + (1j * im)</code> is probably the best option, but adds visual clutter, which might be problematic for more complicated equations. Here it would be fine</p>
<pre><code class="language-python">self_cpa = (self_cpa_re - mu) + (1j * self_cpa_im)  # add contribution of mu
</code></pre>
<pre><code class="language-python"># mine
gf_z = delta_tt * (weight1*g_dft + weight2*dg_dft)
# ruff
gf_z = delta_tt * (weight1 * g_dft + weight2 * dg_dft)
# parenthesis
gf_z = delta_tt * ((weight1 * g_dft) + (weight2 * dg_dft))
</code></pre>
<pre><code class="language-python"># mine
return 0.25 * (np.pi**2 * z) * _u_ellipk(m)**2
# ruff
return 0.25 * (np.pi**2 * z) * _u_ellipk(m) ** 2
</code></pre>
<pre><code class="language-python"># mine
m = 0.5 - 0.5j*np.sqrt(eps_rel[finite]**-2 - 1)
Ksqr = _u_ellipk(m)**2
# ruff
m = 0.5 - 0.5j * np.sqrt(eps_rel[finite] ** -2 - 1)
Ksqr = _u_ellipk(m) ** 2
</code></pre>
<pre><code class="language-python"># mine
gf_d1 = (2. / half_bandwidth**2) * (1 - 1/sqrt)
# ruff
gf_d1 = (2.0 / half_bandwidth**2) * (1 - 1 / sqrt)
</code></pre>
<pre><code class="language-python"># mine 
gf_d2 = (2.0 / half_bandwidth**3) * z_rel * sqrt / (1 - z_rel**2)**2
# ruff
gf_d2 = (2.0 / half_bandwidth**3) * z_rel * sqrt / (1 - z_rel**2) ** 2
</code></pre>
<pre><code class="language-python"># mine
xi = mp.sqrt(1 - mp.sqrt(1 - z_sqr)) / mp.sqrt(1 + mp.sqrt(1 - 9*z_sqr))
k2 = 16 * xi**3 / ((1 - xi)**3 * (1 + 3*xi))
green = (1 - 9*xi**4) * (2 * mp.ellipk(k2) / mp.pi)**2 / ((1 - xi)**3 * (1 + 3*xi)) / z
# ruff
xi = mp.sqrt(1 - mp.sqrt(1 - z_sqr)) / mp.sqrt(1 + mp.sqrt(1 - 9 * z_sqr))
k2 = 16 * xi**3 / ((1 - xi) ** 3 * (1 + 3 * xi))
green = (1 - 9 * xi**4) * (2 * mp.ellipk(k2) / mp.pi) ** 2 / ((1 - xi) ** 3 * (1 + 3 * xi)) / z
</code></pre>
</details>

<p>[^1]:  One could think of augmenting this rule such that from a certain priority there are no spaces by default unless there is another higher priority operator, such that something like <code>x**y</code> has no spaces by default.</p>
<h3>Version</h3>
<p>0.12.0</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @DerWeh on 2025-06-22 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chirizxc">@chirizxc</a> on 2025-06-22 23:06</div>
            <div class="timeline-body"><p>also linter has a rule (<a href="https://docs.astral.sh/ruff/rules/missing-whitespace-around-arithmetic-operator/"><code>E226</code></a>) that completely contradicts pep8</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Tapeline">@Tapeline</a> on 2025-06-22 23:14</div>
            <div class="timeline-body"><blockquote>
<p>a rule that completely contradicts pep8</p>
</blockquote>
<p>It actually has many of them. Are there any initiatives on making ruff fully pep8 compliant?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chirizxc">@chirizxc</a> on 2025-06-22 23:18</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>a rule that completely contradicts pep8</p>
</blockquote>
<p>It actually has many of them. Are there any initiatives on making ruff fully pep8 compliant?</p>
</blockquote>
<p>idk, but it seems to me that it is pep8 that we should be following, not just porting rules from other linters that have already been made not by pep8</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-06-22 23:58</div>
            <div class="timeline-body"><p>There's extensive discussion of formatting for these kinds of operators over in the <code>scientific-python</code> repo: https://github.com/scientific-python/specs/pull/326/. I might suggest participating there -- we don't have any plans to change our own operator spacing unilaterally, and the current rules are designed to match Black.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2025-06-22 23:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Tishka17">@Tishka17</a> on 2025-06-23 00:14</div>
            <div class="timeline-body"><p>@charliermarsh it is ok to keep current rule as is, but</p>
<ol>
<li>remove notification that it is compliant with pep8</li>
<li>add new rule which is actually compliant</li>
</ol>
<p>At least you need to remove note - it is lying</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-06-23 00:17</div>
            <div class="timeline-body"><p>Sure, we can remove the mention of PEP 8. (&quot;Lying&quot; is a bit strong because it implies malicious intent -- this is just a mistake.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DerWeh">@DerWeh</a> on 2025-07-01 21:37</div>
            <div class="timeline-body"><p>@charliermarsh Thanks for the reference.</p>
<p>Could you maybe explain, what's the reasoning behind the spacing around the <code>**</code> operator? If I understood why you format it</p>
<pre><code class="language-python">f(yy) ** 2 + xx**3 + tt[small] ** 4
</code></pre>
<p>I might be bugged less by it. On the other hand, I do relate why you don't give any explanations for your formatting rules. Most is a matter of taste, and you just invite endless discussions by giving a reason.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-07 08:01</div>
            <div class="timeline-body"><p>We inherited this design from Black. The style guide doesn't go into the details on the why power operands are only sometimes spaced with one space, see https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#line-breaks-binary-operators</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:52:57 UTC
    </footer>
</body>
</html>
