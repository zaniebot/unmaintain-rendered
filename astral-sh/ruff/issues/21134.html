<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ignore ANN002 and ARG004 on __new__ - astral-sh/ruff #21134</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Ignore ANN002 and ARG004 on <strong>new</strong></h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/21134">#21134</a>
        opened by <a href="https://github.com/NorthLake">@NorthLake</a>
        on 2025-10-30 09:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/NorthLake">@NorthLake</a> on 2025-10-30 09:11</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>The special method <code>__new__</code> requires its signature (specifically the amount of [kw]args) to be the same as the signature of the <code>__init__</code> method. This means that some of the arguments on the <code>__new__</code> method may not be used, while they are still required. Therefore, it would make sense to ignore ARG004 (unused-static-method-argument) on the <code>__new__</code> method. Or better yet, check wether its signature corresponds to the signature of <code>__init__</code>.</p>
<p>Secondly, because the parameters on <code>__new__</code> may not be used, it makes sense to declare the method as <code>def __new__(cls, *args, **kwargs)</code> and only specify the specific parameters on the <code>__init__</code> method. This is why it would also make sense to me if ANN002 (missing-type-args) is ignored in this case.</p>
<p>Sample code:</p>
<pre><code class="language-python">class ThisClass:
    def __new__(cls, *args, **kwargs) -&gt; &quot;ThisClass&quot;:  # raises ARG004 and ANN002
        return super().__new__(cls)

    def __init__(self, some_argument: str) -&gt; None:
        self.some_argument = some_argument
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-10-30 18:54</div>
            <div class="timeline-body"><p>This sounds plausible to me, but in your example, shouldn't <code>*args</code> and <code>**kwargs</code> be passed along in the <code>super()__new__</code> call? Currently they appear to be genuinely unused. That only covers ARG004, though.</p>
<p>I'm curious what others think too. cc @amyreese</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @ntBre on 2025-10-30 18:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @ntBre on 2025-10-30 18:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NorthLake">@NorthLake</a> on 2025-10-30 19:16</div>
            <div class="timeline-body"><blockquote>
<p>This sounds plausible to me, but in your example, shouldn't <code>*args</code> and <code>**kwargs</code> be passed along in the <code>super()__new__</code> call? Currently they appear to be genuinely unused.</p>
</blockquote>
<p>Strangely that is not the case, as per <a href="https://docs.python.org/3/reference/datamodel.html#object.__new__">Python's datamodel reference</a>:</p>
<blockquote>
<p>If <code>__new__()</code>  is invoked during object construction and it returns an instance of cls, then the new instance’s <code>__init__</code> method will be invoked like <code>__init__(self[, ...])</code>, where self is the new instance and the remaining arguments are the same as were passed to the object constructor.</p>
</blockquote>
<p>As you can see, <code>__init__</code> is automatically called if an instance of the class in question is returned. This means that the signature of a class's <code>__new__</code> method should be the same as its <code>__init__</code> method. I now realize that it would be even better if the signature of <code>__new__</code> is compared with <code>__init__</code> and a warning is given if the signatures do not match. Not sure if this is possible or easy, though.</p>
<p>On the other hand, there is a special case:</p>
<blockquote>
<p>If <code>__new__()</code> does not return an instance of cls, then the new instance’s <code>__init__()</code> method will not be invoked.</p>
</blockquote>
<p>This means that <code>__new__</code> could technically have a different signature if you don't plan on actually returning an instance of the class in question. However, in my opinion this sounds really smelly, so I wouldn't bother checking for this.</p>
<blockquote>
<p>That only covers ARG004, though.</p>
</blockquote>
<p>That's true. As I said, you could check if the two signatures are the exact same. However, you could also argue for having a single source of truth, and not warning for a generic untyped <code>*args, **kwargs</code> signature. In hindsight, checking whether the signatures are the same sounds better than just not typing <code>__new__</code>, but it is an alternative to consider.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amyreese">@amyreese</a> on 2025-10-30 19:57</div>
            <div class="timeline-body"><blockquote>
<p>This sounds plausible to me, but in your example, shouldn't <code>*args</code> and <code>**kwargs</code> be passed along in the <code>super()__new__</code> call? Currently they appear to be genuinely unused. That only covers ARG004, though.</p>
<p>I'm curious what others think too. cc <a href="https://github.com/amyreese">@amyreese</a></p>
</blockquote>
<p>More to the point, passing anything besides <code>cls</code> to <code>object.__new__()</code> results in a type error:</p>
<pre><code>&gt;&gt;&gt; class Foo:
...     def __new__(cls, *args, **kwargs):
...         print(cls, args, kwargs)
...         super().__new__(cls, *args, **kwargs)
...
&gt;&gt;&gt; f = Foo()
&lt;class '__main__.Foo'&gt; () {}
&gt;&gt;&gt; f = Foo(value=1)
&lt;class '__main__.Foo'&gt; () {'value': 1}
Traceback (most recent call last):
  File &quot;&lt;python-input-6&gt;&quot;, line 1, in &lt;module&gt;
    f = Foo(value=1)
  File &quot;&lt;python-input-4&gt;&quot;, line 4, in __new__
    super().__new__(cls, *args, **kwargs)
    ~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^
TypeError: object.__new__() takes exactly one argument (the type to instantiate)
</code></pre>
<p>It's also unlikely that you consume all, or even any, of the arguments in <code>__new__</code>, so I do think it makes sense to ignore unused/unannotated <code>*args</code>/<code>**kwargs</code> specifically in <code>__new__</code>, but <em>not</em> ignore unused variables if they were given a name.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NorthLake">@NorthLake</a> on 2025-10-30 20:43</div>
            <div class="timeline-body"><blockquote>
<p>More to the point, passing anything besides <code>cls</code> to <code>object.__new__()</code> results in a type error:</p>
</blockquote>
<p>This is only true for <code>object.__new__</code>. If <code>class Foo</code> inherits from <code>class Bar</code>, and <code>Bar.__init__</code> expects some arguments, then <code>Bar.__new__</code> should also include those parameters. Therefore, <code>Foo.__new__</code> should call <code>Bar.__new__</code> with the additional necessary arguments.</p>
<pre><code class="language-python">class Bar:
    def __new__(cls, arg1):
        print(&quot;Bar.__new__:&quot;, arg1)
        return super().__new__(cls)

    def __init__(self, arg1):
        print(&quot;Bar.__init__:&quot;, arg1)

class Foo(Bar):
    def __new__(cls):
        print(&quot;Foo.__new__&quot;)
        return super().__new__(cls, &quot;hello&quot;)

    def __init__(self):
        print(&quot;Foo.__init__&quot;)
        super().__init__(&quot;world&quot;)

Foo()
</code></pre>
<p>Gives the following output:</p>
<pre><code>Foo.__new__
Bar.__new__: hello
Foo.__init__
Bar.__init__: world
</code></pre>
<p>And that's as much as I can think right now, as it's getting pretty late... Maybe tomorrow I'll be able to think about this some more.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NorthLake">@NorthLake</a> on 2025-10-30 21:06</div>
            <div class="timeline-body"><p>I now realize that this:</p>
<blockquote>
<p>If <code>__new__()</code> does not return an instance of cls, then the new instance’s <code>__init__()</code> method will not be invoked.</p>
</blockquote>
<p>might actually have to do with inheritance as well. If the returned object is of a subtype (and therefore not actually an instance of cls itself), then <code>__init__</code> is not called. In that case it is up to the subtype to call <code>super().__init__</code> from it's own <code>__init__</code> method.</p>
<p>Not sure about this, though.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:38:39 UTC
    </footer>
</body>
</html>
