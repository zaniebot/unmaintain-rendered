<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Devise a better system for &quot;re-releasing&quot; - astral-sh/ruff #1864</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Devise a better system for &quot;re-releasing&quot;</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/1864">#1864</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-01-14 04:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-14 04:55</div>
            <div class="timeline-body"><p>Right now, release builds are triggered by creating a release on GitHub. If the build fails, the only way to &quot;re-run&quot; is to create a new release. So we have a few versions that have just never been released. <a href="https://github.com/charliermarsh/ruff/actions/runs/3916906363/jobs/6696361593">v0.0.221</a> is one example, where I had to push a fix, then re-release as v0.0.222.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-14 04:57</div>
            <div class="timeline-body"><p>Actually, for that build, I'm going to try deleting the release + tag, and then re-creating it with the updated <code>main</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @charliermarsh on 2023-01-14 04:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/not-my-profile">@not-my-profile</a> on 2023-01-14 08:28</div>
            <div class="timeline-body"><p>(Unrelated sidenote: I don't think we need to bump the version for <code>ruff_dev</code> at all since it's just internal tooling.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bilderbuchi">@bilderbuchi</a> on 2023-01-18 10:18</div>
            <div class="timeline-body"><p>Depending on your desired workflow, you could insert an additional <code>release_prep</code> between <code>release</code> and the others it <code>uses</code> (moving those to <code>release_prep</code>).
Then, you could fire the <code>release_prep</code> either on PRs that have a <code>release</code> (or other appropriate) label, or on pushes to a <code>release</code> branch, or any other condition that you like.
When that check is successful, you can push a release commit with git tag &amp; Github release, and the full machinery should run as it does now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/stinodego">@stinodego</a> on 2023-01-19 22:04</div>
            <div class="timeline-body"><p>Creating a release also creates a tag. You can have your workflow trigger on a new tag. If anything goes wrong, you only need to update the tag to point to the new commit that fixes the issue, which will re-trigger the workflow. I think that solves your original problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bilderbuchi">@bilderbuchi</a> on 2023-01-19 22:09</div>
            <div class="timeline-body"><p>Hm, I always create and push the git tag first (manually), and then the Github release.
Also, updating the tag would mean rewriting public history, no? I guess it depends on the project if that is OK.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/stinodego">@stinodego</a> on 2023-01-19 22:13</div>
            <div class="timeline-body"><p>I figure updating a tag is fine as long as there is no associated release on PyPI yet. But as you say, I'm sure there's different philosophies there. But this issue calls for a way to re-release, which this offers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-19 22:29</div>
            <div class="timeline-body"><p>Ah yeah, interesting. So the release would create a tag, which <em>could</em> fail; then I could fix whatever bug caused it to fail; then I could push the tag again to the newer SHA, and the job would run again, and succeed. Is that right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/stinodego">@stinodego</a> on 2023-01-20 05:25</div>
            <div class="timeline-body"><p>Exactly.</p>
<p>So you would change the release workflow trigger to:</p>
<pre><code class="language-yaml">on:
  push:
    tags:
      - '**'
</code></pre>
<p>This will be triggered when you do a manual GitHub release, as it creates a new tag.</p>
<p>Then, if the workflow fails, you add a new commit with a fix, and you update the tag like so:</p>
<pre><code>git tag -f &lt;tag-name&gt; &lt;commit-hash&gt; &amp;&amp; git push -f origin &lt;tag-name&gt;
</code></pre>
<p>This will re-trigger the release workflow and now (hopefully) successfully release to PyPI.</p>
<h3>Limitations</h3>
<p>Note that the new commit, and any commits you merge between releasing and merging that fix, will not automatically be added to the release changelog of the existing release. But they will be part of the release.</p>
<p>So after updating the tag, you'd have to manually edit the existing release to re-generate the changelog. The auto-generate should pick up the new tags just fine and generate the correct changelog, so this is no issue at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-21 23:50</div>
            <div class="timeline-body"><p>I used the above strategy once, it's a bit manual for us right now (since I have to change the release files) but it works great if needed. I've also started to run a release build prior to creating the release which catches non-transient issues.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-03-21 23:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:07 UTC
    </footer>
</body>
</html>
