```yaml
number: 20579
title: "New rule from `SonarQube`: python:S1244"
type: issue
state: closed
author: chirizxc
labels: []
assignees: []
created_at: 2025-09-25T18:27:38Z
updated_at: 2025-09-25T19:29:19Z
url: https://github.com/astral-sh/ruff/issues/20579
synced_at: 2026-01-10T01:56:57Z
```

# New rule from `SonarQube`: python:S1244

---

_Issue opened by @chirizxc on 2025-09-25 18:27_

### Summary

From [SonarQube](https://cloud-ci.sgs.com/sonar/coding_rules?open=python%3AS1244&rule_key=python%3AS1244):

This rule raises an issue when direct and indirect equality/inequality checks are made on floats.

Floating point math is imprecise because of the challenges of storing such values in a binary representation.

In base 10, the fraction `1/3` is represented as `0.333…​` which, for a given number of significant digit, will never exactly be `1/3`. The same problem happens when trying to represent `1/10` in base 2, with leads to the infinitely repeating fraction `0.0001100110011…​`. This makes floating point representations inherently imprecise.

Even worse, floating point math is not associative; push a float through a series of simple mathematical operations and the answer will be different based on the order of those operation because of the rounding that takes place at each step.

Even simple floating point assignments are not simple, as can be vizualized using the format function to check for significant digits:
```python
>>> format(0.1, ".17g")
'0.10000000000000001'
```
This can also be vizualized as a fraction using the as_integer_ratio method:
```python
>>> my_float = 0.1
>>> numerator, denominator = my_float.as_integer_ratio()
>>> f"{numerator} / {denominator}"
'3602879701896397 / 36028797018963968'
```
Therefore, the use of the equality (==) and inequality (!=) operators on float values is almost always erroneous.

Fixes:
```diff
+ import math
+
 def foo(a, b):
-    return a == b - 0.1
+    return math.isclose(a, b - 0.1, rel_tol=1e-09, abs_tol=1e-09)
```

---

_Comment by @chirizxc on 2025-09-25 18:43_

I can try to implement this rule, but to which of the rule code can it be assigned?



---

_Comment by @chirizxc on 2025-09-25 18:46_

Duplicate of: https://github.com/astral-sh/ruff/issues/18154, https://github.com/astral-sh/ruff/issues/14220

---

_Comment by @ntBre on 2025-09-25 19:29_

Thanks for finding the older issues, I'll go ahead and close this in favor of #14220 to keep the discussion in one place. #14220 is labeled `type-inference`, but we could consider adding a version that relies on our basic type inference for now.

---

_Closed by @ntBre on 2025-09-25 19:29_

---
