<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F601: Repeated int keys not detected with booleans - astral-sh/ruff #12772</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>F601: Repeated int keys not detected with booleans</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/12772">#12772</a>
        opened by <a href="https://github.com/addoolit">@addoolit</a>
        on 2024-08-09 04:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/addoolit">@addoolit</a> on 2024-08-09 04:46</div>
            <div class="timeline-body"><!--
Thank you for taking the time to report an issue! We're glad to have you involved with Ruff.

If you're filing a bug report, please consider including the following information:

* List of keywords you searched for before creating this issue. Write them down here so that others can find this issue more easily and help provide feedback.
  e.g. "RUF001", "unused variable", "Jupyter notebook"
* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `ruff /path/to/file.py --fix`), ideally including the `--isolated` flag.
* The current Ruff settings (any relevant sections from your `pyproject.toml`).
* The current Ruff version (`ruff --version`).
-->

<p>The multi-value-repeated-key-literal (F601) rule doesn't detect when a key has been duplicated for <code>True</code> and <code>False</code> boolean when they duplicate a matching int literal. This is also true for the reverse where an int literal duplicates an existing bool key. This was found with ruff <code>0.5.7</code> and Python <code>3.12.2</code>.</p>
<pre><code class="language-python">mydict = {
    1: &quot;abc&quot;,
    1: &quot;def&quot;,
    True: &quot;ghi&quot;,
    0: &quot;foo&quot;,
    0: &quot;bar&quot;,
    False: &quot;baz&quot;,
}
</code></pre>
<p>Ruff detects the int literal repetition, but misses the bool repetition.</p>
<pre><code>&gt; ruff.exe check ruff_repro.py --isolated
ruff_repro.py:3:5: F601 Dictionary key literal `1` repeated
  |
1 | mydict = {
2 |     1: &quot;abc&quot;,
3 |     1: &quot;def&quot;,
  |     ^ F601
4 |     True: &quot;ghi&quot;,
5 |     0: &quot;foo&quot;,
  |
  = help: Remove repeated key literal `1`

ruff_repro.py:6:5: F601 Dictionary key literal `0` repeated
  |
4 |     True: &quot;ghi&quot;,
5 |     0: &quot;foo&quot;,
6 |     0: &quot;bar&quot;,
  |     ^ F601
7 |     False: &quot;baz&quot;,
8 | }
  |
  = help: Remove repeated key literal `0`

Found 2 errors.
</code></pre>
<p>This state of this dict is ultimately <code>{1: 'ghi', 0: 'baz'}</code>. I haven't found a stated guarantee that <code>True</code> is <em>always</em> <code>1</code>, and <code>False</code> is <em>always</em> <code>0</code>, but it appears that they are. The only thing I've seen related is this note in <a href="https://docs.python.org/3/library/stdtypes.html#typebool">Boolean type - bool</a>:</p>
<blockquote>
<p>In many numeric contexts, <code>False</code> and <code>True</code> behave like the integers 0 and 1, respectively. However, relying on this is discouraged; explicitly convert using <a href="https://docs.python.org/3/library/functions.html#int">int()</a> instead.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 05:27</div>
            <div class="timeline-body"><p>I think this makes sense because <code>bool</code> is a subtype of <code>int</code>. We might want to change this within <a href="https://github.com/astral-sh/ruff/blob/bc5b9b81dd7ea8a2364898afd0f0a1cf7adeb1d1/crates/ruff_python_ast/src/comparable.rs#L846-L881"><code>ComparableExpr</code></a> such that <code>True == 1</code> and <code>False == 0</code>. Note that <code>int</code> is a subtype of <code>float</code> which means that <code>True == 1.0</code> and <code>False == 0.0</code> is also valid.</p>
<p>I'd be wary of any side effects of this change because a lot of rules utilize the <code>ComparableExpr</code>, including the <code>HashableExpr</code> type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @dhruvmanila on 2024-08-09 05:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-09 13:19</div>
            <div class="timeline-body"><p>I'm really surprised by this. @AlexWaygood or @carljm is this specified anywhere?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-09 13:25</div>
            <div class="timeline-body"><p>Yeah, this is a really common footgun. <code>1</code>, <code>1.0</code> and <code>True</code> compare and hash the same. There's an FAQ about it IIRC.</p>
<p>(I think everybody agrees that it's terrible, but it's because early versions of Python didn't have a <code>bool</code> type, so it was implemented as a backwards-compatible subclass of <code>int</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-09 13:31</div>
            <div class="timeline-body"><p>Okay maybe not an FAQ, but there's some specification of this here: https://docs.python.org/3/library/stdtypes.html#mapping-types-dict</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-09 13:31</div>
            <div class="timeline-body"><p>Ok thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">accepted</span> added by @charliermarsh on 2024-08-09 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @charliermarsh on 2024-08-09 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2024-08-11 17:14</div>
            <div class="timeline-body"><p>Just to clarify, is the decision that we should include this identification as part of <code>ComparableExpr</code> or that we should make a more localized change?</p>
<p>I could imagine both situations where we would want to distinguish between <code>True</code> and <code>1</code> and situations where we wouldn't. (From a strict type theoretic point of view I would think that these two objects shouldn't even be comparable and one could only ask about whether <code>bool(1)==True</code> or <code>int(True)==1</code> - but such is Python.)</p>
<p>What about making a custom equivalence method on the <code>ComparableExpr</code> struct for this weaker equivalence relation? Like <code>expr1.iso(expr2)</code> (where &quot;iso&quot; is short for &quot;isomorphic&quot;).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-12 06:49</div>
            <div class="timeline-body"><p>Yeah, not quiet sure to be honest. Maybe @charliermarsh has a better sense for it. Overall, the idea of <code>ComparableExpr</code> is to compare two ASTs. I do believe we also use it in the formatter to detect if we made &quot;unwanted&quot; AST changes. Here it would be unwanted if <code>True == 1</code> would be true.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-12 12:11</div>
            <div class="timeline-body"><p>Yeah, I think it needs to be a more localized change. I donâ€™t think those AST nodes should compare as equal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/12911.html">astral-sh/ruff#12911</a> on 2024-08-15 21:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/14049.html">astral-sh/ruff#14049</a> on 2024-11-01 20:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @charliermarsh by @charliermarsh on 2024-11-03 18:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/14065.html">astral-sh/ruff#14065</a> on 2024-11-03 18:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2024-11-03 19:16</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:13 UTC
    </footer>
</body>
</html>
