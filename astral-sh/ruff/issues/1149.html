<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support baselines, i.e., ignore existing errors for incremental adoption - astral-sh/ruff #1149</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support baselines, i.e., ignore existing errors for incremental adoption</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/1149">#1149</a>
        opened by <a href="https://github.com/edgarrmondragon">@edgarrmondragon</a>
        on 2022-12-08 23:59
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/edgarrmondragon">@edgarrmondragon</a></div>
            <div class="timeline-body"><p>Baselines would allow developers to introduce Ruff to their codebase incrementally by ignoring existing errors and address them as they reappear when making changes to the code.</p>
<p>Supported by some tools in the flake8 ecosystem:</p>
<ul>
<li>Bandit: https://bandit.readthedocs.io/en/latest/start.html#baseline</li>
<li>Flakeheaven: https://wemake-python-styleguide.readthedocs.io/en/latest/pages/usage/integrations/flakeheaven.html#legacy-first-1</li>
</ul>
<p>A very basic proposal for this in ruff:</p>
In the CLI
<pre><code>ruff . --exit-zero --format baseline &gt; .ruff_baseline
ruff . --baseline .ruff_baseline  # doesn&#x27;t report any errors
</code></pre>
In pyproject.toml
<pre><code>[tool.ruff]
baseline = &quot;.ruff_baseline&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-09 04:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">configuration</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-09 04:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-09 04:47</div>
            <div class="timeline-body"><p>That&#x27;s interesting! I&#x27;ve never seen this before. I think we could support it? I&#x27;d been hoping that <code>--add-noqa</code> would serve this purpose. What do you see as the strengths of a baseline file vis-a-vis that workflow?</p>
<p>One point of confusion for me w/r/t the baseline file is that if it&#x27;s just storing errors + line numbers, then if you edit a file (e.g., add a function to the top of a file that has some ignored errors), doesn&#x27;t the baseline get invalidated? Since all the errors are pushed to new lines?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jfmengels">@jfmengels</a> on 2022-12-30 22:45</div>
            <div class="timeline-body"><p>I would recommend looking into what <a href="https://elm-review.com/"><code>elm-review</code></a> did, with its error suppression system. I described the system in this <a href="https://jfmengels.net/stop-the-bleed/">blog post</a>. The baseline doesn&#x27;t include the line numbers ‚Äî but instead counts the number of problems per file and per rule ‚Äî meaning it doesn&#x27;t suffer from the problem @charliermarsh was rightfully wary of.</p>
<p>My experience with this system is very positive. I would definitely recommend it over adding a bunch of noqa comments everywhere, because now it becomes unclear what purposefully got a <code>noqa</code> and what got one because someone used <code>--add-noqa</code> because there were too many errors. It&#x27;s also a better system than turning the rules on as &quot;warnings&quot; (which ruff doesn&#x27;t support but IMO shouldn&#x27;t) which some people tend to do when there are too many existing errors.</p>
<p>FYI, <code>elm-review</code> is a very beloved linter for the Elm language, and it supports neither <code>noqa</code> comments nor severity levels (warning/error), only ignored files through the configuration and this suppression/baseline system. And it&#x27;s working really well.
Some more information around this in its <a href="https://package.elm-lang.org/packages/jfmengels/elm-review/latest/#is-there-a-way-to-ignore-errors-">documentation</a></p>
<p>Happy to answer any questions on the topic (and linters in general üòÅ)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> removed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-31 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">configuration</span> removed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-31 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-31 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">noqa</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-12-31 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/xmo-odoo">@xmo-odoo</a> on 2023-01-17 14:32</div>
            <div class="timeline-body"><blockquote>
<p>but instead counts the number of problems per file and per rule</p>
</blockquote>
<p>That means it can&#x27;t flag an issue being moved around, or code being rewritten but reintroducing the exact same issue it removed, right?</p>
<p>(though I guess as developers learn about the new pattern they would hopefully stop introducing them entirely, and thus the odds of this occuring would diminish over time, so from a cost/benefit point of view it seems like a rather nice heuristic).</p>
<p>Although what happens if a new issue is detected, does elm-review just output all the issues of the file? It can differentiate if it&#x27;s a completely novel issue but if it&#x27;s an additional occurrence of an existing issue it can&#x27;t distinguish them can it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jfmengels">@jfmengels</a> on 2023-01-17 15:15</div>
            <div class="timeline-body"><blockquote>
<p>That means it can&#x27;t flag an issue being moved around, or code being rewritten but reintroducing the exact same issue it removed, right?</p>
</blockquote>
<p>Correct. Though it can flag an issue if it&#x27;s moved around from one file to another, just not in the same file. Also, <code>elm-review</code> updates the suppression files silently when it&#x27;s being run (to remove the pain point of having to re-run the linter to update those files, we&#x27;re trying to encourage good behavior not punish it), so if you run remove a problem, run <code>elm-review</code> (which updates the suppression files), reintroduce an error and finally run <code>elm-review</code> again, then it will actually catch the problem.</p>
<p>As you say, you can basically swap one error in one file for another. While it&#x27;s not necessarily always true (but generally is), this is fine as long as the severity of all the problems reported by a rule are the same, because you&#x27;re not making the code necessarily worse, you&#x27;re keeping it as it was before. And this is the worst scenario with this system, which IMO is a pretty good tradeoff considering the pros and cons of alternative solutions.</p>
<p>As for the &quot;moving&quot; part, I think it&#x27;s not a good thing to do things based on the line number. For instance, if I&#x27;m working on a file and adding a new function on line 100, then run the linter that tells me I now need to fix a suppressed/baseline error that was on line 500 (but is now on line 520), then that gives a very poor experience. The advice you&#x27;ll likely get will be &quot;oh you didn&#x27;t touch it, so just suppress the error once again&quot;, which leads to a common habit of suppressing errors (and I mean that in a bad way).</p>
<blockquote>
<p>Although what happens if a new issue is detected, does elm-review just output all the issues of the file?</p>
</blockquote>
<p>Exactly, it outputs all the issues of the file for that specific rule. This is what the output looks like (focus on the orange parts in this example):
<img src="https://jfmengels.net/static/e14611ccb5e17b7843300f55b75bba3a/64d87/output-when-more-errors.png" alt=""></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/xmo-odoo">@xmo-odoo</a> on 2023-01-18 06:47</div>
            <div class="timeline-body"><blockquote>
<p>As for the &quot;moving&quot; part, I think it&#x27;s not a good thing to do things based on the line number. For instance, if I&#x27;m working on a file and adding a new function on line 100, then run the linter that tells me I now need to fix a suppressed/baseline error that was on line 500 (but is now on line 520), then that gives a very poor experience. The advice you&#x27;ll likely get will be &quot;oh you didn&#x27;t touch it, so just suppress the error once again&quot;, which leads to a common habit of suppressing errors (and I mean that in a bad way).</p>
</blockquote>
<p>Oh I agree with that, you&#x27;d need to either store the <em>sequence</em> of issues which would still have false positives (when the relative ordering of different issue-types doesn&#x27;t change), or you&#x27;d need the diff information in order to adjust the line numbers which would be a lot more work, hence my mention of cost/benefit in the original comment.</p>
<blockquote>
<p>Exactly, it outputs all the issues of the file for that specific rule. This is what the output looks like (focus on the orange parts in this example):</p>
</blockquote>
<p>Makes sense, thanks for the explanations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jfmengels">@jfmengels</a> on 2023-01-18 09:56</div>
            <div class="timeline-body"><p>For more information on this, I opened a similar issue in ESLint very recently: <a href="https://github.com/eslint/eslint/issues/16755">eslint/eslint#16755</a></p>
<p>Another prior art is <a href="https://github.com/ember-template-lint/ember-template-lint/blob/master/docs/todos.md"><code>ember-template-lint&#x27;s TODO system</code></a>. A few tradeoffs that they chose went for:</p>
<ul>
<li>There is a separate file for every suppressed error, with a hash of the contents in the file name. This is great for avoiding Git conflicts (which happen more in my system with a single file)</li>
<li>The file contains some information about the error, including the position of the error in the file</li>
<li>The date of creation is in the file&#x27;s contents, which allows them to &quot;snooze&quot; errors after a set amount of time.</li>
</ul>
<p>Reasons why I didn&#x27;t go for some of these (that system is older than what <code>elm-review</code> did):</p>
<ul>
<li>Snoozing errors is IMO not a great system. Errors will show up after a set amount of time, and fail unrelated builds. If I come back to a project after6 months, I don&#x27;t want to have fix all the errors that now get reported. Instead <code>elm-review</code> have a small reminder like &quot;I found no errors, but there are still 12 suppressed errors to address&quot;.</li>
<li>Since the file contains the position, everytime the position gets changed because of unrelated changes above it, the file needs to be regenerated (and I imagine developers just do that constantly without thinking too much? I can&#x27;t see that not happening)</li>
<li>Since the files get regenerated all the time because of the previous bullet point, the date of creation also gets changed every time. Meaning that in often changed files, you&#x27;ll never get reminders for the errors in those files. Snoozing and re-creating these files with hashes are IMO features that don&#x27;t work well together.</li>
<li>I like the conflict-less parts, but I went for a single file, because it makes it easy to have an overview of the suppressed errors (which rules are suppressed, how many errors are suppressed) without having to execute the file. Having plenty of files didn&#x27;t give a good overview IMO.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/xmo-odoo">@xmo-odoo</a> on 2023-01-18 10:15</div>
            <div class="timeline-body"><blockquote>
<p>I like the conflict-less parts, but I went for a single file, because it makes it easy to have an overview of the suppressed errors (which rules are suppressed, how many errors are suppressed) without having to execute the file. Having plenty of files didn&#x27;t give a good overview IMO.</p>
</blockquote>
<p>This should be quite easy to resolve using standard shell tools though e.g.</p>
<pre><code>tail -n+1 review/suppressed/*</code></pre>
<p>will display the name of every file followed by its content, or maybe</p>
<pre><code>tail -n+1 $(find suppressed -type f)</code></pre>
<p>if intermediate subdirectories get added (<code>less</code> wants every parameter to be a file)</p>
<p>Of course it depends what you want specifically in terms of overview.</p>
<p>But maybe ruff could support both styles by accepting both baseline file and baseline directory in which case it&#x27;d merge all the JSON files?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jfmengels">@jfmengels</a> on 2023-01-18 10:48</div>
            <div class="timeline-body"><p>This is an example of a <code>.lint-todo</code> folder that I could find: https://github.com/dfreeman/ember-truncate/tree/786b812d4e7993c5ba253f5af8a984ed40976291/.lint-todo</p>
<p>I find that neither the file structure neither the file&#x27;s contents are easy to get an overview.
In comparison, this is what you get for <code>elm-review</code>: https://github.com/jfmengels/elm-spa-example/tree/46591cb15b55136afed1a25fe1a5563545a1b3de/review/suppressed</p>
<p>Here, I don&#x27;t have to run any tool, know any bash-fu, or even leave GitHub to see what&#x27;s happening. In this last example, I can clearly see which rules have been suppressed, and then I can look at those files to see how many suppressed errors there are.</p>
<p>If I review a GitHub PR, it is easy to see whether new rules are being suppressed or more errors are being suppressed, which allows me to leave a comment asking my colleague whether this was necessary, and start a conversation. We ideally want those numbers to go down, not up, so talking it out is a healthy practice IMO.</p>
<p>With <code>ember-template-lint</code>&#x27;s approach, I might see 10 removed files and +/- 10 added files, and I&#x27;m going to need to dig into all of those to see whether things got better, worse or (because they&#x27;re location-based and often re-generate) things stayed the same.</p>
<blockquote>
<p>support both styles</p>
</blockquote>
<p>I don&#x27;t think that having more choices for these things is beneficial in general, as that will make it harder to maintain things, confuse the users and split the community in how you do things. And you might end up with the worst of both worlds instead of the best of both worlds.</p>
<blockquote>
<p>by accepting both baseline file and baseline directory</p>
</blockquote>
<p>Can you clarify what you have in mind with baseline file and baseline directory?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/xmo-odoo">@xmo-odoo</a> on 2023-01-18 11:10</div>
            <div class="timeline-body"><blockquote>
<p>With <code>ember-template-lint</code>&#x27;s approach, I might see 10 removed files and +/- 10 added files, and I&#x27;m going to need to dig into all of those to see whether things got better, worse or (because they&#x27;re location-based and often re-generate) things stayed the same.</p>
</blockquote>
<p>Right but that could just be that a location-based toplevel is the wrong approach.</p>
<blockquote>
<blockquote>
<p>support both styles</p>
</blockquote>
<p>I don&#x27;t think that having more choices for these things is beneficial in general, as that will make it harder to maintain things, confuse the users and split the community in how you do things. And you might end up with the worst of both worlds instead of the best of both worlds.</p>
</blockquote>
<p>Both have advantages and drawbacks though, and justifiably so. It&#x27;s also not exactly rare, both Elm and Rust will let you split a single module file into a module directory after all.</p>
<blockquote>
<blockquote>
<p>by accepting both baseline file and baseline directory</p>
</blockquote>
<p>Can you clarify what you have in mind with baseline file and baseline directory?</p>
</blockquote>
<p>Exactly that?</p>
<p>For instance in your elm example each check has a JSON file with any number of entries, hence every two PRs which add or remove occurrences in the same category might conflict (even more so because of JSON&#x27;s trailing-comma issues).</p>
<p>However each check could be a directory then containing a file for each suppression <code>entry</code>. You&#x27;d still have a conflict if two PRs remove different occurrences in the same file, however that would significantly decrease the conflict likelihood, and the conflict in the suppression files would likely be paired with a conflict in the code file itself.</p>
<blockquote>
<p>If I review a GitHub PR, it is easy to see whether new rules are being suppressed or more errors are being suppressed, which allows me to leave a comment asking my colleague whether this was necessary, and start a conversation. We ideally want those numbers to go down, not up, so talking it out is a healthy practice IMO.</p>
</blockquote>
<p>That can be done either way, a diff (whether <code>git show</code> or github files tab) will give you pretty much the same information.</p>
<p>The ember diffs will be noisier because it has additional and possibly (probably?) unnecessary metadata (especially as it seems to update them somewhat randomly) but a diff will still tell you clearly that (check, file) entries get added or removed: https://github.com/dfreeman/ember-truncate/commit/b466413e3b531cd6245faf71466bdaa261991311</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/judson-stevens-teampay">@judson-stevens-teampay</a> on 2023-01-28 17:20</div>
            <div class="timeline-body"><p>I&#x27;m new to <code>ruff</code> (loving it so far!) but have been using <code>flakeheaven</code> and it&#x27;s predecessor <code>flakehell</code> for quite a while now. I really enjoy <code>flakeheaven</code>&#x27;s baseline feature - there&#x27;s some more information <a href="https://github.com/flakeheaven/flakeheaven/blob/main/docs/commands/baseline.md">here</a>. We&#x27;ve used it successfully on a larger code base to incrementally fix legacy issues by incorporating the <code>diff</code> command in that linked doc. We have a fairly large Python monolith at my day job, and when developers make changes they are prompted to fix issues in code they touched; an easy example of this is docstrings - in functions that do not have docstrings, if a developer modifies that function, <code>flakeheaven</code> will then identify it as needing a docstring and flag it in <code>pre-commit</code> or our CI.</p>
<p>I&#x27;m definitely not an expert in the mechanism used to generate the baseline file, but just wanted to toss in some lived experience with this functionality. I believe it is similar to what others have called out above, in that it&#x27;s <a href="https://github.com/flakeheaven/flakeheaven/blob/main/flakeheaven/_logic/_baseline.py">tied to the filename and the line numbers</a>, so we do occasionally see instances where very old legacy code is touched and multiple &quot;unrelated&quot; issues then pop up. However, in general, even on a code base with some fairly large legacy files (7k lines of Django serializers), it&#x27;s usually not so bad to get things fixed up. This incrementally modernizes and even fixes our existing code, which is great.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lengau">@lengau</a> on 2023-01-30 03:22</div>
            <div class="timeline-body"><p>One possible implementation of baselines that would handle many of the issues herein (though it would introduce at least one of its own) would be to incorporate the baseline into the file itself with the <code>noqa</code> directive. If <code>--add-noqa</code> could include extra information in the comment containing the directive, it could be used to set a baseline. Combined with rule <code>RUF100</code> and ruff&#x27;s auto-fix feature, this could provide a very user-visible version of baselines directly in the code.</p>
<p>For example, a file that contains an existing line of:</p>
<pre><code>from math import *</code></pre>
<p>could get a directive such as:</p>
<pre><code>from math import *  # noqa: F403 - Existing errors as of 2023-01-29 ignored by ruff.</code></pre>
<p>In my view it has the following advantages:</p>
<ol>
<li>No messing with line numbers, counting violations, etc.</li>
<li>The directives are very visible to the user, encouraging their fixing when touching nearby code</li>
<li>A baseline can follow a particular code snippet even if files are moved, etc. Splitting a thousand-line legacy file in two doesn&#x27;t have to come with the work of fixing all the linting errors in half that file. (After all, a linting tool is supposed to help us, not burden us.)</li>
<li>With <code>--fix</code> and rule <code>RUF100</code>, directives get automatically removed when appropriate.</li>
</ol>
<p>Of course, it also has one distinct disadvantage:</p>
<ol>
<li>Every rule-violating line of code now has an extra node in the blame layer just for adding <code>noqa</code> directives.</li>
</ol>
<p>This could be mitigated by providing an obvious separate author credit on this (commit the output of <code>--add-noqa</code> &quot;as ruff&quot;, if you will). Developers would immediately recognise this and look at previous commits, and if a standard is generated tools might begin to provide similar options.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/orsinium">@orsinium</a> on 2023-02-10 06:50</div>
            <div class="timeline-body"><p>I also have a baseline implementation for mypy as a separate tool: <a href="https://github.com/orsinium-labs/mypy-baseline">mypy-baseline</a>. As people already said in the thread, baseline doesn&#x27;t store line numbers. In case of mypy-baseline, violations are matched to the baseline based on the file name and error message:
https://github.com/orsinium-labs/mypy-baseline/blob/master/mypy_baseline/_error.py#L60-L68</p>
<p>In the case of flakehell (now flakeheaven) things were a bit easier because I could use error codes (since error messages may change):
https://github.com/life4/flakehell/blob/master/flakehell/_logic/_baseline.py#L6-L11</p>
<p>In case of a new violation being similar to the old one (the same file and the same error code), simply the last one is reported based on assumption that the new code is more often added closer to the end of the file. It may produce false-positives in theory but my teams haven&#x27;t faced it yet.</p>
<p>I think it was a good decision to keep baselines in a separate file. I also considered automatically adding <code># noqa</code> to the code but abandoned that idea:</p>
<ol>
<li>All <code># noqa</code> (or <code>typing: ignore</code> in case of mypy) comments should be used in rare occasions of legit false-poisitives when a human looked at the code and said: &quot;yep, that would be hard to work around&quot;. The baseline, on the other hand, is for the tech debt that humans haven&#x27;t looked into yet but should gradually go through and get rid of. I don&#x27;t think these two should be mixed.</li>
<li>Having the baseline in one place gives a better perspective on the work left to do. In mypy-baseline, I provide <code>history</code>, <code>plot</code>, and <code>top-files</code> commands that I often run and show the team to remind them that we should do progress resolving it.</li>
<li>Introducing a tool that just needs a single baseline file and a single config is much easier than a tool that changes something in every file.</li>
</ol>
<p>What I regret doing in flakehell is that the baseline is a collection of obscure md5 hashes. In mypy-baseline, the baseline is human-readable and we quite often use that fact to manually read and edit it.</p>
<p>I hope this perspective can be of any help.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/snmishra">@snmishra</a> on 2023-04-14 11:41</div>
            <div class="timeline-body"><blockquote>
<p>That&#x27;s interesting! I&#x27;ve never seen this before. I think we could support it? I&#x27;d been hoping that <code>--add-noqa</code> would serve this purpose. What do you see as the strengths of a baseline file vis-a-vis that workflow?</p>
<p>One point of confusion for me w/r/t the baseline file is that if it&#x27;s just storing errors + line numbers, then if you edit a file (e.g., add a function to the top of a file that has some ignored errors), doesn&#x27;t the baseline get invalidated? Since all the errors are pushed to new lines?</p>
</blockquote>
<p>flakeheaven <a href="https://github.com/flakeheaven/flakeheaven/blob/4591fd3dd04c8180d702e5eab3ec25947d7d3393/flakeheaven/_logic/_baseline.py">stores md5 hash</a> of the violation and it&#x27;s context. If performance is a concern a cheaper hash should be fine too.</p>
<p>The <code>--add-noqa</code> wouldn&#x27;t leave a way to find out if the <code>noqa</code> were never meant to be fixed, or were just added for initial adoption.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Pixel-Minions">@Pixel-Minions</a> on 2023-06-27 15:29</div>
            <div class="timeline-body"><p>Hi,</p>
<p>I wholeheartedly support the implementation of a separate baseline file as it proves to be an immensely valuable feature. Given the context of my position as the head of the department in a company with a substantial monolithic codebase, I am actively striving to enforce robust code standards. To achieve this, I have introduced linters during the code push to the repository and have provided the team with suitable tools. However, due to the sheer size of the codebase, it is not feasible to lint the entirety of it. Therefore, my objective is to exclusively lint the new code changes‚Äîthe actual differences in the codebase as it progresses forward.</p>
<p>Flakeheaven or flakehell do a great job doing this baseline, I wish ruff could bring something similar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/locnide">@locnide</a> on 2023-07-25 17:12</div>
            <div class="timeline-body"><p>Hello,</p>
<p>A structured output for ruff violations <a href="https://github.com/astral-sh/ruff/blob/cbf6085375984a1e32d5808e07496a5c54670e9f/crates/ruff/src/message/gitlab.rs#L103">with fingerprints</a> has been added for gitlab output.
Could this file or structure be used as baseline for ruff‚ÄØ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dorschw">@dorschw</a> on 2023-08-12 13:58</div>
            <div class="timeline-body"><p>As (temporary?) solution, I just released Riff <a href="https://pypi.org/project/riff">PyPi</a> / <a href="https://github.com/dorschw/riff">GitHub</a>,</p>
<p>Riff wraps Ruff, runs git diff, checks for modified lines, only fails if errors were found in modified lines.
Works as a CLI tool as well as a pre-commit hook, check it out :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2023-08-22 11:43</div>
            <div class="timeline-body"><p><a href="https://github.com/akaihola/darker">Darker</a> is a very relevant tool here (<a href="https://github.com/akaihola/darker#using-linters">which isn&#x27;t just for black</a>).</p>
<p>And for prior art, <a href="https://github.com/KotlinIsland/basedmypy">basedmypy</a> and <a href="https://www.jetbrains.com/qodana/">Qodana</a> both support baseline functionality.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carlfischerjba">@carlfischerjba</a> on 2024-02-19 15:00</div>
            <div class="timeline-body"><p>Here&#x27;s a bit of <code>jq</code> that will extract the differences between two GitLab-style reports and print it out as a Markdown snippet. Disclaimer: I&#x27;m no jq expert so there are probably better ways to do this.</p>
<pre><code>jq -nr --argfile ref gl-code-quality-report-baseline.json \
    --argfile new gl-code-quality-report.json &#x27;
# Get fingerprints in new report that are not in the old.
[ $ref, $new ]
| map([.[].fingerprint])
| (.[1] - .[0]) as $new_fingerprints
# Take the new report and select only the entries with a new fingerprint.
| $new
| .[] | select(.fingerprint | IN($new_fingerprints[]))
| &quot;- \(.description) - `\(.location.path):\(.location.lines.begin)`&quot;
&#x27;
</code></pre>
<p>I&#x27;ve added this in one of our GitLab projects while waiting for <a href="https://gitlab.com/gitlab-org/gitlab/-/issues/34982">this issue</a> to be resolved. Here&#x27;s the merge request workflow.</p>
<ol>
<li>Run ruff to create a report.</li>
<li>Download the baseline via the GitLab API.</li>
<li>Use jq to extract issues that were not present in the baseline.</li>
<li>Fail the pipeline if new issues were found.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/blablatdinov">@blablatdinov</a> on 2024-06-13 17:06</div>
            <div class="timeline-body"><p>You can use <code>ondivi</code> <a href="https://pypi.org/project/ondivi/">Pypi</a> <a href="https://github.com/blablatdinov/ondivi">Github</a>. Is a Python script filtering coding violations, identified by static analysis, only for changed lines in a Git repo. You can use it with ruff, flake8, pylint, mypy and others.</p>
<p>flakeheaven and flakehell are not supported because they rely on internal flake8 API, which can lead to compatibility issues as flake8 evolves. In contrast, ondivi uses only the text output of violations and the state of Git repository, making it more robust and easier to maintain.</p>
<blockquote>
<p>Flakeheaven: https://wemake-python-styleguide.readthedocs.io/en/latest/pages/usage/integrations/flakeheaven.html#legacy-first-1</p>
</blockquote>
<p>WPS remove this page from the docs and replace it with https://wemake-python-styleguide.readthedocs.io/en/latest/pages/usage/integrations/ondivi.html</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jedie">@jedie</a> on 2024-11-14 16:08</div>
            <div class="timeline-body"><p>Think this issue is only about to run ruff <strong>linting</strong> only on change lines, but not to run the formatter only on change lines, isn&#x27;t it?</p>
<p>The mentioned solutions like <code>ondivi</code> or <code>Riff</code> doesn&#x27;t help here. <code>ondivi</code> is only for linting, and <code>riff --fix</code> will apply formatting to all lines, see: <a href="https://github.com/dorschw/riff/issues/16">dorschw/riff#16</a></p>
<p>So i end up to wait for <a href="https://github.com/akaihola/darker/issues/521">akaihola/darker#521</a> for support &quot;Support ruff format as a formatter&quot; in darker.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2024-11-15 01:32</div>
            <div class="timeline-body"><p>basedpyright also supports baseline functionality https://docs.basedpyright.com/latest/benefits-over-pyright/baseline/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/estahn">@estahn</a> on 2024-11-27 01:10</div>
            <div class="timeline-body"><p>This is received positive feedback in terms of functionality. Is the only open question the format of the baseline data?</p>
<p>I was imagining this could be stored by hashing the filename with line of code and possibly error code, e.g. <code>MD5(CONCAT(&lt;filename&gt;, &lt;line of code&gt;, &lt;ruff error code&gt;))</code>.</p>
<p><strong>Example:</strong></p>
<p>Finding:
<code>test_foobar.py</code>:</p>
<pre><code>55 | def test_do_FooBar(api_client, authenticated_user, mock_pynamodb, mock_eventbridge_client):
   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ N802
</code></pre>
<pre><code>ruff . --exit-zero --format baseline &gt; .ruff_baseline
ruff . --baseline .ruff_baseline  # doesn&#x27;t report any errors
</code></pre>
<p><code>.ruff_baseline</code>:</p>
<pre><code>&lt;filename&gt;|&lt;md5 of line 55&gt;|&lt;error code&gt;
2af918dbc4589ec4a153761e4c9af86f
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Support baselines&quot; to &quot;Support baselines, i.e., ignore existing errors for incremental adoption&quot; by <a href="https://github.com/zanieb">@zanieb</a> on 2024-11-27 01:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/josiahcoad">@josiahcoad</a> on 2025-01-02 15:44</div>
            <div class="timeline-body"><p>Very excited for this. Is currently needed on my team.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/josiahcoad">@josiahcoad</a> on 2025-01-09 12:52</div>
            <div class="timeline-body"><p>Hey, @estahn is this still being actively worked on?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/austin-agronick">@austin-agronick</a> on 2025-05-28 06:17</div>
            <div class="timeline-body"><p>The latest riff release does not parse the relative file paths properly and fails to generate GitHub annotations for my project so I had to install from the latest commit. Here are working steps for a GitHub workflow to lint (<code>ruff check</code>) changed lines and generate GitHub annotations in the pull request changed files tab, in addition to warnings for ruff rules that are &quot;ignored&quot; in my config but I manually warn via GitHub workflow:</p>
<pre><code>- uses: actions/checkout@v4
- name: Get changed files
  id: changed-files
  uses: tj-actions/changed-files@v46.0.1
  with:
    files: |
      **.py

- name: Install riff
  run: |
    pip install \
      git+https://github.com/dorschw/riff.git@9882898eb650c617d1d7a36a37badda4ab73b815#egg=riff

- name: Warn for any non-required failed checks
  env:
    RUFF_OUTPUT_FORMAT: &quot;json&quot;
  run: |
    riff \
      --print-github-annotation \
      --base-branch=origin/${{ github.event.pull_request.base.ref }} \
      check --config ./pyproject.toml --select D100,D106,ERA001,ANN,FIX,TD,D \
      -- ${{ steps.changed-files.outputs.all_changed_files }} \
      | sed &#x27;s/^::error/::warning/&#x27;

- name: Validate there are no failed checks
  env:
    RUFF_OUTPUT_FORMAT: &quot;json&quot;
  run: |
    riff \
      --print-github-annotation \
      --base-branch=origin/${{ github.event.pull_request.base.ref }} \
      check --config ./pyproject.toml \
      -- ${{ steps.changed-files.outputs.all_changed_files }}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InsidersByte">@InsidersByte</a> on 2025-07-30 21:06</div>
            <div class="timeline-body"><p><a href="https://eslint.org/blog/2025/04/introducing-bulk-suppressions/">ESLint added support for bulk suppression a few months ago</a>.</p>
<p>Their RFC for it can be found <a href="https://github.com/eslint/rfcs/tree/main/designs/2024-baseline-support">here</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/phiresky">@phiresky</a> on 2025-10-08 12:53</div>
            <div class="timeline-body"><p>Until this is implemented here&#x27;s a one-line command that generates the <code>[tool.ruff.lint.per-file-ignores]</code> section based on the currently violated rules:</p>
<pre><code>uv run ruff check --output-format=json | jq -r &#x27;group_by(.filename) | map({(.[0].filename): ([.[].code] | unique)}) | add | to_entries | map(&quot;\&quot;&quot; + .key + &quot;\&quot; = [&quot; + (.value | map(&quot;\&quot;&quot; + . + &quot;\&quot;&quot;) | join(&quot;, &quot;)) + &quot;]&quot;) | join(&quot;\n&quot;)&#x27;
</code></pre>
<p>this generates an output like this:</p>
<pre><code>&quot;__init__.py&quot; = [&quot;E402&quot;]
&quot;path/to/file.py&quot; = [&quot;E402&quot;, &quot;TRY300&quot;]
</code></pre>
<p>which can be directly added to the pyproject.toml file under the <code>[tool.ruff.lint.per-file-ignores]</code></p>
<p>At least one rule needs to be failing otherwise jq will throw a null error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epic-64">@epic-64</a> on 2025-11-13 10:45</div>
            <div class="timeline-body"><p>Baseline support is practically a requirement for introducing linters to an existing codebase, especially in teams that are not used to static analysis. The alternative would be to allow linting to fail in CI, or use extremely watered-down rules that do not protect the codebase from new ill-structured code.</p>
<p>I use baselines very successfully in phpstan and mypy (granted, mypy-baseline is a third party package that allows you to pipe mypy output through it - I actually kinda like this separation of concerns).</p>
<p>Looking very much forward to this for Ruff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Artalus">@Artalus</a> on 2025-12-11 10:59</div>
            <div class="timeline-body"><p>PVS-Studio, a paywalled but quite capable C++ static analyzer, <a href="https://pvs-studio.com/en/docs/manual/0032/">supports</a> generating baseline files. IIRC it can store them in custom paths that can be configured with <code>--some-cli-arg</code> when running the analyzer from terminal or in CI.</p>
<p>Their baseline does something like stripping whitespace from the code line ‚Äì plus previous line, plus next line ‚Äì and hashing the result. This helps to ensure that re-indenting the problematic fragment and adding new code around does not immediately cause the baselined diagnostics to reappear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/siscia">@siscia</a> on 2025-12-12 00:07</div>
            <div class="timeline-body"><p>As I mentioned in #21907 and @ntBre described better than me.</p>
<p>A reasonable substitute for baseline would it be to allow something like RUF100 to unused <code>per-file-ignores</code></p>
<p>When introducing a new lint, we would just add the files to the <code>per-file-ignores</code> and as soon as the lint is addressed the files can be removed by the <code>per-file-ingores</code> list.</p>
<p>The file could accumulate more of those exceptions, but I don&#x27;t see it as a practical issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/edgarrmondragon">@edgarrmondragon</a> on 2025-12-12 00:10</div>
            <div class="timeline-body"><p>@siscia that&#x27;d be a nice improvement but a baseline is usually more granular than simply ignoring an entire file, like what @Artalus described</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/siscia">@siscia</a> on 2025-12-14 21:20</div>
            <div class="timeline-body"><p>Hello,</p>
<p>just for my understanding here. What&#x27;s the status?</p>
<p>Is astral on board with baseline being implemented and added to ruff?
Is astral on board with RUF100 to be available also for <code>per-file-ignores</code> being implemented and added to ruff?</p>
<p>Are we still discussing on design?</p>
<p>Are we still deciding if the feature is worth having?</p>
<p>I don&#x27;t have capacity myself to provide code in the ruff codebase (sorry about that) but I am more than open to provide examples of how we will use either features in our codebase. Provide feedback on possible designs from a user perspective. And pretty much whatever would help without require me 2+ hours of deep work on this.</p>
<p>If there is any way, I can help move this forward, please let me know.</p>
<p>Thanks a lot</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-14 22:01</div>
            <div class="timeline-body"><p>It&#x27;s on our mind, but not a top-priority feature. We plan to come back to it, but I can&#x27;t say yet when.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ofekby">@ofekby</a> on 2025-12-16 12:36</div>
            <div class="timeline-body"><p>In the meantime, try using snaplint to snapshot your current linter output and only fail CI on new issues ‚Äî it‚Äôs a simple way to track lint regressions until baseline support lands in Ruff: <a href="https://github.com/GENWAY-AI/snaplint?utm_source=chatgpt.com">https://github.com/GENWAY-AI/snaplint</a></p>
<p>Usage example:</p>
<ol>
<li>Run once and push snapshot files</li>
</ol>
<pre><code>ruff check --output-format concise | snaplint take-snapshot
</code></pre>
<ol>
<li>Then on every CI execution</li>
</ol>
<pre><code>ruff check --output-format concise | snaplint diff
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:28 UTC
    </footer>
</body>
</html>
