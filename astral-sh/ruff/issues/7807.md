```yaml
number: 7807
title: Extending Flake8Async rules to nested calls?
type: issue
state: closed
author: tasercake
labels:
  - type-inference
assignees: []
created_at: 2023-10-04T10:20:42Z
updated_at: 2024-10-24T14:34:10Z
url: https://github.com/astral-sh/ruff/issues/7807
synced_at: 2026-01-10T01:56:49Z
```

# Extending Flake8Async rules to nested calls?

---

_Issue opened by @tasercake on 2023-10-04 10:20_

Hi there!

I'm interested in adding a rule to identify blocking calls in async contexts. Being new to ruff, I'm hoping to get a sense of how big of a task this would be.

Would it be feasible to have ruff identify _indirect_ calls to blocking functions like `open()` or `requests.get()`?

Here's some examples of the cases I'd like to catch:

```python
import asyncio
import requests

async def foo():
    loop = asyncio.get_running_loop()
    return await loop.run_in_executor(None, requests.get, "https://example.com")  # OK (but AFAIK this isn't explicitly checked by ruff now)

async def bar():
    return requests.get("https://example.com")  # Error! (this is already caught by ASYNC100)

def baz():
    return requests.get("https://example.com")  # OK

def qux():
    return  # OK

async def main():
    await foo()  # OK
    await bar()  # OK
    baz()  # Error! (but this is not caught as of now)
    qux()  # OK
```

The current output looks like this:

```shellsession
$ ruff check . --select ASYNC
main.py:9:12: ASYNC100 Async functions should not call blocking HTTP methods
Found 1 error.
```

---

_Comment by @charliermarsh on 2023-10-04 14:42_

Hey, thanks for the clear issue. We _could_ support this, but it would have some limitations...

1. It wouldn't work across files. We don't support cross-file analysis right now, so e.g., if `baz` were defined in another file and imported into the above, we'd fail to catch it. We plan to support cross-file analysis in the future but it's not on the immediate roadmap (so timeline is TBD).
2. It wouldn't work for instance methods, like `x = Class(); x.baz()`. We could _probably_ support that simple case assuming the class were defined in the same file, but it would still miss other kinds of accesses.

Given the limitations, I'm torn on whether it's worth supporting right now. What do you think?


---

_Label `question` added by @charliermarsh on 2023-10-04 14:42_

---

_Comment by @tasercake on 2023-10-05 02:00_

Hey Charlie, thanks for the info!

I didn't realise ruff doesn't support cross-file analysis at the moment. My own use case involves a large codebase where most blocking functions are in different files, so I don't think this rule would add much value.

If and when cross-file analysis gets a concrete timeline I'd love to revisit this, but for now I'll explore other solutions ðŸ™‚

Please feel free to close this issue

---

_Label `question` removed by @charliermarsh on 2023-10-05 15:10_

---

_Label `multifile-analysis` added by @charliermarsh on 2023-10-05 15:10_

---

_Comment by @charliermarsh on 2023-10-05 15:10_

Sounds good -- we do plan to support this eventually since it's an unfortunate limitation, but we have a few other priorities ahead of it, since we're able to get pretty far with single-file analysis as is. I've tagged this with a label to revisit when we support multi-file analysis.

---

_Closed by @charliermarsh on 2023-10-05 15:10_

---

_Label `type-inference` added by @MichaReiser on 2024-10-24 14:34_

---

_Label `multifile-analysis` removed by @MichaReiser on 2024-10-24 14:34_

---
