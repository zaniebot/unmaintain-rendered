<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rule idea: flag literal attributes in monkeypatching/mocking APIs - astral-sh/ruff #22013</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Rule idea: flag literal attributes in monkeypatching/mocking APIs</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/22013">#22013</a>
        opened by <a href="https://github.com/woodruffw">@woodruffw</a>
        on 2025-12-16 20:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/woodruffw">@woodruffw</a> on 2025-12-16 20:49</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>This is a rough idea that probably needs refining/discussion ðŸ™‚</p>
<h2>Overview</h2>
<p>Pytest and others expose monkeypatch/mocking APIs like:</p>
<pre><code class="language-python">monkeypatch.setattr(some_module, &quot;my_important_api&quot;, replacement)
</code></pre>
<p>(and same for <code>delattr</code>.)</p>
<p>When called, this temporarily monkeypatches <code>some_module.my_important_api</code> with <code>replacement</code> (which could be an object, callable, etc.).</p>
<h2>Problem statement</h2>
<p>The above works, but has a footgun: if the user performs a refactor (e.g. from <code>my_important_api</code> to <code>my_critical_api</code>), then may miss this monkeypatch (since it's a string literal, not a usage/reference). This is particularly likely to happen with IDE/LSP refactors, since syntax-aware rename-all functionality can't look at these kinds of non-type string literals by design.</p>
<p>The impact of this depends: sometimes users notice it immediately (since their monkeypatch stops working), while other times it makes tests subtly incorrect or unreliable in ways that aren't noticed until much later.</p>
<h2>Solution statement</h2>
<p>In general, users should <em>probably</em> write:</p>
<pre><code class="language-python">monkeypatch.setattr(some_module, some_module.my_important_api.__name__, replacement)
</code></pre>
<p>That'll behave the same as above, <em>but</em> will ensure that refactors/mechanical renames propagate as expected.</p>
<h2>Problems</h2>
<ol>
<li>This won't work with dynamic attributes; not sure if this is a problem or not.</li>
<li>Using <code>__name__</code> is arguably pretty unsightly and is maybe considered unidiomatic, not sure ðŸ™‚</li>
</ol>
<h2>Alternatives</h2>
<ol>
<li><p>Do nothing.</p>
</li>
<li><p>Maybe Pytest and others with monkeypatching APIs should support functions as first-class &quot;nameable&quot; objects? In other words, Ruff could instead recommend:</p>
<pre><code class="language-python">monkeypatch.setattr(some_module, some_module.my_important_api.__name__, replacement)
</code></pre>
<p>...and Pytest would do the <code>__name__</code> access internally. This would require upstream changes, but would be a lot visually cleaner from the user's side.</p>
</li>
</ol>
<h2>Other references</h2>
<p>xref https://github.com/astral-sh/ruff/issues/12850 for another (but I think unrelated) mocking/monkeypatching feature request.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-16 20:49</div>
            <div class="timeline-body"><p>This seems like something that needs to be cross-module and have type information.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by @carljm on 2025-12-16 20:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-16 21:18</div>
            <div class="timeline-body"><p>If I understand correctly, we could get by without type inference if we're just looking for <code>monkeypatch.setattr</code> with a string as the second argument and recommending to use <code>__name__</code> instead. I think we'd only need type inference if we were trying to resolve the definition of the string. But I could definitely be missing something.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @ntBre on 2025-12-16 21:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-16 21:20</div>
            <div class="timeline-body"><p>Oh, yeah, I misunderstood the proposal. A type-aware lint rule could actually tell you when your patch is patching something that doesn't exist, but a non-type-aware rule could just tell you to not use strings.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> removed by @carljm on 2025-12-16 21:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woodruffw">@woodruffw</a> on 2025-12-16 22:13</div>
            <div class="timeline-body"><p>Yeah, sorry for the confusion! I was thinking of this as a purely naive lint, i.e. no type or actual attribute awareness.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:38:50 UTC
    </footer>
</body>
</html>
