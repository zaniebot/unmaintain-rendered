```yaml
number: 7676
title: "False positive for F812 with ``nonlocal``"
type: issue
state: open
author: DanielNoord
labels:
  - needs-decision
assignees: []
created_at: 2023-09-27T13:27:06Z
updated_at: 2023-09-27T14:16:16Z
url: https://github.com/astral-sh/ruff/issues/7676
synced_at: 2026-01-10T01:56:49Z
```

# False positive for F812 with ``nonlocal``

---

_Issue opened by @DanielNoord on 2023-09-27 13:27_

Couldn't find a previous issue for this.

The following code:
```python
def outer_func():
    variable: int

    def func():
        nonlocal variable
        variable = 1

    func()
    assert variable == 1


outer_func()
```

This executes just fine but `ruff` has an issue with it:
```console
â¯ ruff check --select=F821 test.py
test.py:9:12: F821 Undefined name `variable`
  |
8 |     func()
9 |     assert variable == 1
  |            ^^^^^^^^ F821
  |

Found 1 error.
```
Not that this code works because of `outer_func`. If `variable` was defined at module level the code fails.

---

_Comment by @charliermarsh on 2023-09-27 13:50_

Thanks for filing. This is tough to get right in the general case since you need to reason about the complete flow of the program...

It looks like Pyright _also_ flags this as unbound.

Mypy doesn't, but it's also too permissive in that it allows _this_:

```python
def outer_func() -> None:
    variable: int

    assert variable == 1


outer_func()
```

I'm tempted to close as `wontfix` since it seems rare and hard to get right. Alternatively, we could do what we do for globals and add a binding for `variable` as soon as we see the `nonlocal`, which would be closer to Mypy's behavior (and so have some false negatives instead of false positives).


---

_Label `needs-decision` added by @charliermarsh on 2023-09-27 13:50_

---

_Comment by @DanielNoord on 2023-09-27 14:12_

`pylint` also accepts this while raising on the variant where `variable` is defined outside of `outer_func` as well as raise `used-before-assignment` on the example you gave.
_Although as `pylint` maintainer I'm obviously biased :smile:_

At work we're trying to put as much of our checks in `ruff` instead of `pylint` and we had to put quite a bit of ignores for this false positive. We use this pattern in testing code to test some obscure behaviour and I would never use it in production code as I don't think it is a good pattern. That said it is valid Python and I think preferring false negatives over false positives is usually better?

---

_Comment by @zanieb on 2023-09-27 14:16_

I've used a similar pattern for testing as well, but I think I usually initialize the variable as `None` instead of just annotating it. It seems like that would generally lead to clearer error messages if things don't work as intended in your inner function.

I do agree a false negative seems a little better than a false positive.

---
