<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`FBT001` and `PLR0917` - false positive on pytest functions - astral-sh/ruff #7286</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>`FBT001` and `PLR0917` - false positive on pytest functions</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/7286">#7286</a>
        opened by <a href="https://github.com/DetachHead">@DetachHead</a>
        on 2023-09-12 04:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/DetachHead">@DetachHead</a> on 2023-09-12 04:46</div>
            <div class="timeline-body"><pre><code class="language-py"># test_foo.py
@fixture
def a():
    return True

def test_foo(a: bool): # error: FBT001
    assert a
</code></pre>
<p>also happens on hook functions</p>
<pre><code class="language-py"># conftest.py
def pytest_foo(a: bool): # error: FBT001
    ...
</code></pre>
<p>arguments to functions called by pytest are always positional, as they are called by pytest itself so this rule is not an issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @charliermarsh on 2024-01-05 04:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/9803.html">astral-sh/ruff#9803</a> on 2024-02-02 22:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`boolean-type-hint-positional-argument` (`FBT001`) false positive on pytest functions" to "`boolean-type-hint-positional-argument` (`FBT001`) - false positive on pytest functions" by @DetachHead on 2024-02-02 22:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`boolean-type-hint-positional-argument` (`FBT001`) - false positive on pytest functions" to "`FBT001` and `PLR0917` - false positive on pytest functions" by @DetachHead on 2024-02-16 10:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2024-02-16 10:05</div>
            <div class="timeline-body"><p>also <code>too-many-positional</code> (<code>PLR0917</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/10645.html">astral-sh/ruff#10645</a> on 2024-03-28 13:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15158.html">astral-sh/ruff#15158</a> on 2024-12-27 00:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-03 09:25</div>
            <div class="timeline-body"><p>I'd argue that the rules should apply to fixtures and parametrized tests because the same problem applies as when calling the function manually (assuming you agree with FBT001 and PLR0917 in the first place).</p>
<p>For example</p>
<pre><code class="language-py">@fixture
def a():
	return [(True, False, True), (False, True, False)] # this is kind of hard to read

def pytest_foo(a: bool, b: bool, c: bool): ...
</code></pre>
<p>The same is true for too many positional arguments. If you don't like too many positional arguments for regular functions because it makes the call site harder to read, then you probably also dislike it for tests.</p>
<p>In the end, a fixture return, the parametrize list or using a regular call are all just different DSLs for expressing the arguments for a function.</p>
<p>I think we should only excel functions where the signature isn't under the user's control, which doesn't apply here (as far as I can tell, except that pytest restricts you to use positional arguments, but you could, e.g., return a dict?). I also think that exempting fixtures by default makes Ruff less flexible because there's no way for users who care about enforcing those rules in tests to enable them again. On the other hand, disabling them using <code>per-file-ignores</code> or <code># ruff: noqa: FBT001</code> is straightforward enough.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> removed by @MichaReiser on 2025-01-03 09:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @MichaReiser on 2025-01-03 09:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-01-03 13:10</div>
            <div class="timeline-body"><blockquote>
<p>I'd argue that the rules should apply to fixtures and parametrized tests because the same problem applies as when calling the function manually (assuming you agree with FBT001 and PLR0917 in the first place).</p>
<p>For example</p>
<pre><code class="language-py">@fixture
def a():
  return [(True, False, True), (False, True, False)] # this is kind of hard to read

def pytest_foo(a: bool, b: bool, c: bool): ...
</code></pre>
</blockquote>
<p>i don't really understand this example. the return type of that <code>a</code> fixture is associated with the type of the <code>a</code> parameter:</p>
<pre><code class="language-py">def pytest_foo(a: list[tuple[bool, bool, bool]]):
    ...
</code></pre>
<p>and it would be equally difficult to understand what each value in the tuple represents regardless of whether <code>a</code> was a keyword or positional argument.</p>
<blockquote>
<p>The same is true for too many positional arguments. If you don't like too many positional arguments for regular functions because it makes the call site harder to read, then you probably also dislike it for tests.</p>
</blockquote>
<p>i don't think tests should be called manually either. imo if a user wants to do that, they are probably misusing pytest</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-03 13:38</div>
            <div class="timeline-body"><p>Yeah, I'm sorry. I misunderstood the fixture documentation. But I still think that <code>FBT001</code> applies. Specifically:</p>
<blockquote>
<p>The use of a boolean will also limit the function to only two possible behaviors, which makes the function difficult to extend in the future.</p>
</blockquote>
<blockquote>
<p>Calling a function with boolean positional arguments is confusing as the meaning of the boolean value is not clear to the caller and to future readers of the code.</p>
</blockquote>
<p>Where &quot;Calling&quot; is the fixture's return value position.</p>
<p>But I think it would be easiest to discuss this based on a real world example. Do you have any? Do you know if it is a common pattern to have boolean fixtures?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-01-04 01:14</div>
            <div class="timeline-body"><p>i still don't believe these are issues at all when it comes to fixtures</p>
<blockquote>
<p>The use of a boolean will also limit the function to only two possible behaviors, which makes the function difficult to extend in the future.</p>
</blockquote>
<p>take this fixture and test for example:</p>
<pre><code class="language-py">@fixture
def condition() -&gt; bool:
    ...

def test_foo(condition: bool):
    ...
</code></pre>
<p>if another fixture is added to the function in the future, it doesn't matter where the parameter appears in the signature, as long as its name matches the name of the fixture:</p>
<pre><code class="language-py">@fixture
def condition() -&gt; bool:
    ...

@fixture
def foo() -&gt; bool:
    ...

def test_foo(foo: bool, condition: bool):
    ...
</code></pre>
<blockquote>
<p>Calling a function with boolean positional arguments is confusing as the meaning of the boolean value is not clear to the caller and to future readers of the code.</p>
</blockquote>
<p>this isn't an issue either since fixtures cannot be called directly anyway. pytest is able to automatically determine how to call fixture and test functions by inspecting their parameters at runtime</p>
<blockquote>
<p>But I think it would be easiest to discuss this based on a real world example. Do you have any? Do you know if it is a common pattern to have boolean fixtures?</p>
</blockquote>
<p><a href="https://github.com/DetachHead/pytest-robotframework/blob/e9984db408922828f6e12498b78787426fd77a96/pytest_robotframework/hooks.py#L47-L54">the real world example i encountered</a> was related to hook functions rather than fixtures, but pytest behaves the same with them as well:</p>
<pre><code class="language-py">@hookspec
def pytest_robot_assertion(
    item: Item,
    expression: str,
    fail_message: object,
    line_number: int,
    assertion_error: AssertionError | None,
    explanation: str,
) -&gt; None:
    ...
</code></pre>
<p>this hook currently triggers <code>PLR0917</code>. i used to have a boolean argument there that triggered <code>FBT001</code> as well but that's since been removed. my issue with changing these arguments to be keyword only is that it's not consistent with <a href="https://docs.pytest.org/en/stable/how-to/writing_hook_functions.html#declaring-new-hooks">how all other pytest hooks are defined</a>. note that although it does say &quot;Hooks receive parameters using only keyword arguments.&quot; the examples don't define the arguments as keyword only. i've worked with many pytest plugins (including pytest's own ones) and none of them seem to do this either. it would cause unnecessary confusion for users who are used to writing hooks the normal way. specifically, the user would encounter this unhelpful error message if they forgot to make the arguments keyword only in their <code>pytest_robot_assertion</code> hook:</p>
<pre><code>pluggy._manager.PluginValidationError: Plugin 'robotframework' for hook 'pytest_robot_assertion'
hookimpl definition: pytest_robot_assertion(item: 'Item', expression: 'str', fail_message: 'object', explanation: 'str', assertion_error: 'AssertionError | None')
Argument(s) {'fail_message', 'expression', 'assertion_error', 'explanation', 'item'} are declared in the hookimpl but can not be found in the hookspec
</code></pre>
<p>imo since neither fixture, test or hook functions should ever be called manually and are only supposed to be called internally by pytest itself, it doesn't make sense to report these errors on them, since these rules are specifically designed for functions that are intended to be called by a user.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-04 12:02</div>
            <div class="timeline-body"><p>I agree that it makes sense to exclude pytest hooks for PLR0917 and FBT001 (if there are any) because the user does not control the method signatures.</p>
<p>I would exclude changing fixtures' behavior because a function with too many fixture arguments is harder to understand than one with fewer (so PLR0917 applies).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-01-05 09:57</div>
            <div class="timeline-body"><p><code>PLR0917</code> is specifically for positional arguments though, and i don't see how that makes the function harder to understand. if the user never calls it manually anyway, it makes no difference whether the arguments are positional or keyword only</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-05 10:03</div>
            <div class="timeline-body"><p>I think we can reconsider it when we have real world use cases where this is indeed a problem. I still think that e.g. having a test with 5+ fixtures can be split into either different tests or by refactoring fixtures.</p>
<p>Anyway. Let's focus on what we have agreement on and change <code>PLR0917</code> to ignore functions that match known pytest hooks by name. We can revisit fixtures separately if they're common enough to justify special handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/16867.html">astral-sh/ruff#16867</a> on 2025-09-03 17:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:51 UTC
    </footer>
</body>
</html>
