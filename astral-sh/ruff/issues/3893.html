<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static type checking √† la mypy - astral-sh/ruff #3893</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Static type checking √† la mypy</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/3893">#3893</a>
        opened by <a href="https://github.com/saada">@saada</a>
        on 2023-04-05 23:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/saada">@saada</a></div>
            <div class="timeline-body"><p>Would be amazing if Ruff had static type checking. Mypy is a well known solution in this area as well as pytype, pyre, and others.</p>
<p>As a follow up, we could have some way of auto-fixing type annotations.</p>
<p>Thank you for this incredible project üòç</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-04-13 17:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-04-13 17:29</div>
            <div class="timeline-body"><p>I will admit that I&#x27;m interested in this and it fits into the vision of what we&#x27;re trying to do, but it would be irresponsible of me to promise or commit to anything yet :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NeilGirdhar">@NeilGirdhar</a> on 2023-08-15 00:12</div>
            <div class="timeline-body"><p>I&#x27;m not sure if you are aware, but <a href="https://github.com/mtshiba/pylyzer">Pylyzer</a> is a Python type checker that&#x27;s written in Rust.  It might be worth seeing if there&#x27;s a way to have all the desired features with less effort.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-08-15 05:25</div>
            <div class="timeline-body"><p>Oh that&#x27;s interesting! It uses Erg and isn&#x27;t quite feature complete, I&#x27;m not sure if we could use it but it&#x27;s great to see another Rust Python tool.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NeilGirdhar">@NeilGirdhar</a> on 2023-08-15 07:31</div>
            <div class="timeline-body"><p>I don&#x27;t know much about Rust, but would it be possible for them to expose an API that Ruff could call into?  If so, the Ruff and Pylyzer teams could work out an API that Pylyzer exposes and Rust could call into?  Even if you don&#x27;t end up using Pylyzer, knowing the API that Ruff needs would be useful if Ruff were to implement its own type analysis.  (Just thinking out loud.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/thibaut-st">@thibaut-st</a> on 2024-02-15 08:05</div>
            <div class="timeline-body"><p>Is there any dev started on that feature? It would be so awesome to have all the essential python code quality tools in one fast as hell dependency!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nolanking90">@nolanking90</a> on 2024-04-02 23:38</div>
            <div class="timeline-body"><p>I&#x27;m interested in moving forward on this. I would like to begin working on features that could be exposed to ruff-lsp to add more of the traditional LSP capabilities, and it sounds like getting some type checking/inference working is going to be necessary before something like &#x27;textDocument/hover&#x27; can be handled (by ruff-lsp) in a useful way.</p>
<p>Some input from the maintainers about implementation would be helpful, if this is still something the core team is interested in.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-04-03 01:43</div>
            <div class="timeline-body"><p>Thanks for expressing your interest! Unfortunately the scope of this feature is far too large for external contribution, it will require major architectural changes to Ruff and extensive collaboration with our team. We&#x27;re moving in this direction though. We can mark any related issues that would be good for external contribution with a &quot;help wanted&quot; label, as I&#x27;m sure there will be lots of smaller tasks that arise.</p>
<p>We&#x27;re also recently kicked off a rewrite of <code>ruff-lsp</code> in Rust, see <a href="https://github.com/astral-sh/ruff/pull/10158">astral-sh/ruff#10158</a>. Once it&#x27;s established, I&#x27;m sure there will be issues in that project that are good for contribution.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/johnthagen">@johnthagen</a> on 2024-05-19 11:54</div>
            <div class="timeline-body"><p>For those interested, looks like initial work for this is here</p>
<ul>
<li>https://github.com/astral-sh/ruff/tree/main/crates/red_knot</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2024-07-23 03:32</div>
            <div class="timeline-body"><blockquote>
<p>√† la mypy</p>
</blockquote>
<p>please don&#x27;t make it like mypy, closer to pyright would be much more tolerable. although considering how based the maintainers are here, i&#x27;m confident they would know what they are doing</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kszlim">@kszlim</a> on 2024-07-30 19:23</div>
            <div class="timeline-body"><p>Curious if there&#x27;s a tracking issue for the progression of this feature? Would be great to gain some visibility into this (with the caveat that I certainly don&#x27;t have any expectations around the arrival date).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/leontrolski">@leontrolski</a> on 2024-11-01 12:00</div>
            <div class="timeline-body"><p>An API that I&#x27;d love to see from a future typechecker (I feel this is sorely missing with <code>mypy</code> and friends):</p>

Given a module `my.module` like:

<pre><code>class Foo:
    def call_db(self) -&gt; int:
        return 42


class Bar:
    foos: list[Foo]


def no_call_db(f: Any) -&gt; Any:
    return f


@no_call_db
def f() -&gt; None:
    bar = Bar()
    for foo in bar.foos:
        print(foo.call_db())
</code></pre>
<p>I&#x27;d like to be able to use the results of typing-checking to perform further static analysis (or maybe even insane runtime stuff/documentation generation).</p>
<p>In this case, I&#x27;d like to check there are no calls to <code>my.module.Foo.call_db</code> in any function decorated with <code>@my.module.no_call_db</code>.</p>
<p>The API would look something like this:</p>
<pre><code>from ruff.typechecker import ast_extended as ast, types, typecheck, parse_ast_with_types

top_level_types = typecheck(Path(&quot;.&quot;), use_cache=True)
assert top_level_types == {
    &quot;my.module.Foo&quot;: types.Class(methods={&quot;call_db&quot;: types.Method(...)}),
    &quot;my.module.no_call_db&quot;: types.Function(args=[types.Any], ret=types.Any),
    ...,
}
</code></pre>
<p>More useful would be coupling the above with the AST:</p>
<pre><code>node = parse_ast_with_types(Path(&quot;my/module.py&quot;), use_cache=True)
assert node == ast.FunctionDef(
    name=&quot;f&quot;,
    decorator_list=[
        ast.Name(
            id=&quot;no_call_db&quot;,
            type=types.TypeRef(&quot;my.module.no_call_db&quot;),
        )
    ],
    body=[
        ast.Assign(
            targets=[ast.Name(id=&quot;bar&quot;)],
            value=ast.Call(
                func=ast.Name(
                    id=&quot;Bar&quot;,
                    type=types.Type(types.TypeRef(&quot;my.module.Bar&quot;)),
                ),
                args=[],
                type=types.TypeRef(&quot;my.module.Bar&quot;),
            ),
            type=types.TypeRef(&quot;my.module.Bar&quot;),
        ),
        ast.For(
            target=ast.Name(
                id=&quot;foo&quot;,
                type=types.TypeRef(&quot;my.module.Foo&quot;),
            ),
            iter=ast.Attribute(
                value=ast.Name(
                    id=&quot;bar&quot;,
                    type=types.TypeRef(&quot;my.module.Bar&quot;),
                ),
                attr=&quot;foos&quot;,
                type=types.List(types.TypeRef(&quot;my.module.Foo&quot;)),
            ),
            body=[
                ast.Expr(
                    value=ast.Call(
                        func=ast.Name(id=&quot;print&quot;),
                        args=[
                            ast.Call(
                                func=ast.Attribute(
                                    value=ast.Name(id=&quot;foo&quot;),
                                    attr=&quot;call_db&quot;,
                                    type=types.MethodRef(&quot;my.module.Foo&quot;, &quot;call_db&quot;),
                                ),
                                args=[],
                                type=types.None_,
                            )
                        ],
                        type=types.TypeRef(&quot;builtins.print&quot;),
                    )
                )
            ],
        ),
    ],
)
</code></pre>
<p>A checker for &quot;no db calls where decorator disallows&quot; is then just:</p>
<pre><code>def is_decorated_no_call_db(node: ast.AST) -&gt; TypeIs[ast.FunctionDef]:
    return (
        isinstance(node, ast.FunctionDef)
        and any(d.type == types.TypeRef(&quot;my.module.no_call_db&quot;) for d in node.decorator_list)
    )

def is_call_to_call_db(node: ast.AST) -&gt; TypeIs[ast.Call]:
    return (
        isinstance(child, ast.Call)
        and child.func.type == types.MethodRef(&quot;my.module.Foo&quot;, &quot;call_db&quot;)
    )

for node in walk(module):
    if is_decorated(node) and if any(is_call_to_call_db(child) for child in walk(node)):
        yield Error(...)
</code></pre>
<p>Reliably achieving this kind of thing right now is really difficult as I can&#x27;t easily eg. hook into <code>mypy</code>&#x27;s internals.</p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/johnthagen">@johnthagen</a> on 2025-01-29 18:23</div>
            <div class="timeline-body"><p>Looks like this was officially announced</p>
<ul>
<li>https://x.com/charliermarsh/status/1884651482009477368</li>
</ul>
<blockquote>
<p>We‚Äôre building a new static type checker for Python, from scratch, in Rust.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/holmanb">@holmanb</a> on 2025-01-30 19:15</div>
            <div class="timeline-body"><blockquote>
<p>Looks like this was officially announced</p>
<pre><code>* https://x.com/charliermarsh/status/1884651482009477368</code></pre>
<blockquote>
<p>We‚Äôre building a new static type checker for Python, from scratch, in Rust.</p>
</blockquote>
</blockquote>
<p>As a potential user, I have some initial questions:</p>
<p>Will it use typeshed&#x27;s stubs or start from scratch?</p>
<p>Are there any publicly facing design docs?</p>
<p>Mypy and pyright, the two most popular open source Python type checkers, have very different semantics. Will this new project match the behavior of an existing type checker or will they add another alternative semantic implementation to the Python type checker ecosystem?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-01-30 19:42</div>
            <div class="timeline-body"><p>I definitely appreciate the questions but we&#x27;re really focused on building the thing right now -- it&#x27;s not yet ready for real-world usage. We&#x27;ll share more when we can!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/josephrubin">@josephrubin</a> on 2025-01-30 21:40</div>
            <div class="timeline-body"><p>Looks very cool. Would really appreciate hermetic approach to cache files, like Guido&#x27;s approach
<a href="https://github.com/python/mypy/pull/4759">python/mypy#4759</a>
<a href="https://github.com/python/mypy/issues/3912">python/mypy#3912</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mon-jai">@mon-jai</a> on 2025-01-31 06:06</div>
            <div class="timeline-body"><p>@charliermarsh Would you publish a placeholder package to hold the place in the PYPI repo?</p>
<p>Package name collision is very common in the JavaScript ecosystem. Not sure if it is the same for Python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-01-31 20:35</div>
            <div class="timeline-body"><p>We probably won&#x27;t use the <code>red-knot</code> name for the final product, though that&#x27;s still an open question.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kszlim">@kszlim</a> on 2025-01-31 20:42</div>
            <div class="timeline-body"><p>I&#x27;d personally prefer that it remains under ruff, one of the nice things about ruff is that it&#x27;s monolithic and you don&#x27;t get tools clobbering each other&#x27;s outputs. Ensuring that there&#x27;s only ever one universe of tools that is used is a feature in this case. At most I could see it being gated as an optional feature, but please keep it all under ruff!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/josiahcoad">@josiahcoad</a> on 2025-02-08 05:01</div>
            <div class="timeline-body"><p>I&#x27;m here because running mypy on my medium codebase froze my computer and I&#x27;m waiting for it to unfreeze. Needless to say, very excited for a fast, scalable type checker! It will make my pre-commit much less painful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pgulb">@pgulb</a> on 2025-04-09 09:41</div>
            <div class="timeline-body"><p>This is what Python world needs</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/johnthagen">@johnthagen</a> on 2025-05-07 19:04</div>
            <div class="timeline-body"><p>Looks like this has been published as <code>ty</code></p>
<ul>
<li>https://github.com/astral-sh/ty</li>
<li>https://pypi.org/project/ty/</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hauntsaninja">@hauntsaninja</a> on 2025-05-07 19:13</div>
            <div class="timeline-body"><p>Just note:</p>
<blockquote>
<p>This project is still in development and is not ready for production use.</p>
</blockquote>
<p>Also check out https://www.youtube.com/watch?v=XVwpL_cAvrw !</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:35 UTC
    </footer>
</body>
</html>
