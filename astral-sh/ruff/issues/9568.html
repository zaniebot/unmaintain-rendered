<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TCH003 incosistency - astral-sh/ruff #9568</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>TCH003 incosistency</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/9568">#9568</a>
        opened by <a href="https://github.com/LefterisJP">@LefterisJP</a>
        on 2024-01-17 19:13
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/LefterisJP">@LefterisJP</a> on 2024-01-17 19:13</div>
            <div class="timeline-body"><p>This is a bit of a weird error/question concerning TCH003.</p>
<p>In a PR to our repo we noticed that ruff requested moving <code>collections.abc.Callable</code> into a type checking block.
This is by running <code>ruff rotkehlchen/ package.py tools</code></p>
<pre><code>rotkehlchen/accounting/history_base_entries.py:2:29: TCH003 Move standard library import `collections.abc.Callable` into a type-checking block
</code></pre>
<p>This is a bit surprising as our repository uses <code>collections.abc.Callable</code> in many other places just for type checking and this rule has not hit. We import it normally in the main module code.</p>
<p>ruff version: <code>ruff 0.1.11</code></p>
<p>The question is how can we make it work on all of the code properly and why would it not work consistently?</p>
<p>Repo: https://github.com/rotki/rotki
Pyproject.toml: https://github.com/rotki/rotki/blob/8b5720fa1c5fcf5f8bd75fab68b7a9d315fe3476/pyproject.toml#L85</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-01-17 19:23</div>
            <div class="timeline-body"><p>It just entirely depends on the code in question and where <code>collections.abc.Callable</code> is used. I can take a look at a few examples from the repo.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/LefterisJP">@LefterisJP</a> on 2024-01-17 19:33</div>
            <div class="timeline-body"><blockquote>
<p>It just entirely depends on the code in question and where <code>collections.abc.Callable</code> is used. I can take a look at a few examples from the repo.</p>
</blockquote>
<p>But Callable is always used in type checking only (at least in our repo) so that's what has me wondering what the heck. Sorry I know this is more of a question and not an issue. I can also take it elsewhere if you prefer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-01-17 19:40</div>
            <div class="timeline-body"><p>Unfortunately it's a bit more complicated than that :joy: It's not just about whether it's only used in type annotations, it's about whether it's only used in typing <em>contexts</em>.</p>
<p>For example, this code does not run:</p>
<pre><code class="language-python">from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable

def func(x: Callable): ...
</code></pre>
<p>If you try, you'll get a runtime error:</p>
<pre><code>Traceback (most recent call last):
  File &quot;/Users/crmarsh/workspace/foo.py&quot;, line 6, in &lt;module&gt;
    def func(x: Callable): ...
                ^^^^^^^^
NameError: name 'Callable' is not defined. Did you mean: 'callable'?
</code></pre>
<p>Python requires type annotations to be available at runtime if they're in function definitions, or annotated assignments at the top level or in classes. So it ultimately depends on where the type is used.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-01-17 19:42</div>
            <div class="timeline-body"><p>As a counter example, this runs without issue:</p>
<pre><code class="language-python">from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from collections.abc import Callable

def func():
    x: Callable = 1

# Note: call the function at the end to ensure the body runs.
func()
</code></pre>
<p>Since Python does not evaluate annotated assignments within function bodies.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/LefterisJP">@LefterisJP</a> on 2024-01-17 19:47</div>
            <div class="timeline-body"><blockquote>
<p>As a counter example, this runs without issue:
Since Python does not evaluate annotated assignments within function bodies.</p>
</blockquote>
<p>Ah I see. Okay I think I get it then. That's the difference. I was also surprised to not see the one that ruff hit for us cause a runtime error.</p>
<p>I expected we would need to quote it. But when I saw no runtime error I thought that perhaps something changed in the way python wants type annotations at runtime.</p>
<blockquote>
<p>Python requires type annotations to be available at runtime if they're in function definitions, or annotated assignments at the top level or in classes. So it ultimately depends on where the type is used.</p>
</blockquote>
<p>This is the explanation I was seeking. Thanks. Where is that stated in the python docs btw? Would love to have it handy for next time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @LefterisJP on 2024-01-17 19:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-01-17 19:52</div>
            <div class="timeline-body"><p>In https://docs.python.org/3/reference/simple_stmts.html#annotated-assignment-statements, they say:</p>
<blockquote>
<p>For simple names as assignment targets, if in class or module scope, the annotations are evaluated and stored in a special class or module attribute <strong>annotations</strong> that is a dictionary mapping from variable names (mangled if private) to evaluated annotations... Annotations are never evaluated and stored in function scopes.</p>
</blockquote>
<p>Then in https://docs.python.org/3/reference/compound_stmts.html#function-definitions, they say:</p>
<blockquote>
<p>The annotation values are available as values of a dictionary keyed by the parametersâ€™ names in the <strong>annotations</strong> attribute of the function object. If the annotations import from <a href="https://docs.python.org/3/library/__future__.html#module-__future__"><strong>future</strong></a> is used, annotations are preserved as strings at runtime which enables postponed evaluation. Otherwise, they are evaluated when the function definition is executed. In this case annotations may be evaluated in a different order than they appear in the source code.</p>
</blockquote>
<p>This behavior exists because of <code>__annotations__</code> -- they need to populate it, so they have to evaluate the annotations. If you use <code>from __future__ import annotations</code>, this behavior doesn't exist (so Ruff will flag typing-only things much more consistently). I think the same is <em>roughly</em> true of the upcoming PEP that changes semantics again in lieu of <code>from __future__ import annotations</code> but I can't remember the details :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/LefterisJP">@LefterisJP</a> on 2024-01-17 20:10</div>
            <div class="timeline-body"><p>Thank you so much @charliermarsh. Appreciate your super quick help.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:11 UTC
    </footer>
</body>
</html>
