<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>F841 and PLE0117 don’t understand `__class__` bindings - astral-sh/ruff #18442</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>F841 and PLE0117 don’t understand <code>__class__</code> bindings</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/18442">#18442</a>
        opened by <a href="https://github.com/dscorbett">@dscorbett</a>
        on 2025-06-03 15:07
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dscorbett">@dscorbett</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>By default, <code>__class__</code> within a method definition is a free variable and its corresponding cell variable is always bound. <a href="https://docs.astral.sh/ruff/rules/unused-variable/"><code>unused-variable</code> (F841)</a> and <a href="https://docs.astral.sh/ruff/rules/nonlocal-without-binding/"><code>nonlocal-without-binding</code> (PLE0117)</a> have false positives because they don’t understand this special case. This is probably a general problem with how Ruff resolves bindings which could affect other rules.</p>
<pre><code class="language-console">$ cat &gt;f841_ple0117.py &lt;&lt;'# EOF'
class A:
    x = 1


class B:
    x = 2


class C(A, B):
    def set_class(self, cls):
        nonlocal __class__
        if cls not in type(self).__mro__:
            raise ValueError(f&quot;Invalid superclass: {cls}&quot;)
        __class__ = cls

    def get_class(self):
        return __class__

    def __getattribute__(self, attr):
        if attr in vars(type(self)):
            return object.__getattribute__(self, attr)
        if attr in vars(__class__):
            mro = type(self).__mro__
            return getattr(super(mro[mro.index(__class__) - 1], self), attr)
        return getattr(super(), attr)


c = C()
print(c.x)
c.set_class(B)
print(c.x)
# EOF

$ python f841_ple0117.py
1
2

$ ruff --isolated check --select F841,PLE0117 f841_ple0117.py --output-format concise -q
f841_ple0117.py:11:18: PLE0117 Nonlocal name `__class__` found without binding
f841_ple0117.py:14:9: F841 Local variable `__class__` is assigned to but never used

$ ruff --isolated check --select F841,PLE0117 f841_ple0117.py -s --unsafe-fixes --fix

$ python f841_ple0117.py
1
1
</code></pre>
<p>That PLE0117 diagnostic is a false positive because <code>__class__</code> does have a binding; it just isn’t explicit in the source code. That F841 diagnostic is a false positive because <code>__class__</code> is not a local variable.</p>
<h3>Version</h3>
<p>ruff 0.11.12 (aee3af0f7 2025-05-29)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @ntBre on 2025-06-03 15:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-03 15:28</div>
            <div class="timeline-body"><p>Wow, another interesting one! I assumed that <code>__class__</code> would also be bound in the class definition itself, but this is not the case:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; class C:
...     print(__class__)
...
Traceback (most recent call last):
  File &quot;&lt;python-input-6&gt;&quot;, line 1, in &lt;module&gt;
    class C:
        print(__class__)
  File &quot;&lt;python-input-6&gt;&quot;, line 2, in C
    print(__class__)
          ^^^^^^^^^
NameError: name '__class__' is not defined
</code></pre>
<p>Maybe we can add a synthetic binding for methods or something like that.</p>
<p>Nesting also works:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; class A:
...     def foo():
...         class B:
...             print(__class__)
...
&gt;&gt;&gt; A.foo()
&lt;class '__main__.A'&gt;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mikeleppane">@mikeleppane</a> on 2025-08-06 11:04</div>
            <div class="timeline-body"><p>I am currently working on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @mikeleppane by @ntBre on 2025-08-06 11:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ntBre on 2025-08-26 13:49</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:52:48 UTC
    </footer>
</body>
</html>
