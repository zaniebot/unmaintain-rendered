<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Break in compatibility with jupyterlab-lsp + python-lsp-ruff since 0.0.285 - astral-sh/ruff #6847</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Break in compatibility with jupyterlab-lsp + python-lsp-ruff since 0.0.285</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/6847">#6847</a>
        opened by <a href="https://github.com/felix-cw">@felix-cw</a>
        on 2023-08-24 09:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-08-24 09:22</div>
            <div class="timeline-body"><p>I'm not 100% sure this is the right project to raise this, since the problem comes from interaction with <code>python-lsp-ruff</code> and <code>juptyerlab-lsp</code>. I only raised it here since the issue arose from a change in ruff.</p>
<p>Since 0.0.285, the jupyterlab-lsp plugin now gives the following diagnostic message:</p>
<pre><code>SyntaxError: Expected a Jupyter Notebook (.ipynb), which must be internally stored as JSON, but found a Python source file: expected value at line 1 column 1
</code></pre>
<p>I believe this is because jupyterlab-lsp extracts the python code from the notebook cells, then python-lsp-ruff passes it to ruff via stdin, and specifies <code>--stdin-filename</code>. Since #6628, this makes ruff expect ipynb JSON, rather than python code, which causes the error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-08-25 02:41</div>
            <div class="timeline-body"><p>Hey, thanks for opening the issue!</p>
<p>First of all, your observation is spot on in that the <code>--stdin-filename</code> is used by <code>python-lsp-ruff</code><a href="https://github.com/python-lsp/python-lsp-ruff/blob/f6707dfab9c39cbab23b8bc89646341164435afc/pylsp_ruff/plugin.py#L503-L505">^1</a> and that JupyterLab is probably sending the source code as Python (instead of JSON) to the server<a href="https://jupyterlab-lsp.readthedocs.io/en/latest/Architecture.html#positioning-system">^2</a> (They have a concept of Virtual Document). Here, the server is <code>python-lsp-ruff</code> which uses the Ruff executable.</p>
<p><em>You can see the URI for the document which has an extension of <code>.ipynb</code>:</em></p>
<img width="1092" alt="Screenshot 2023-08-25 at 07 58 24" src="https://github.com/astral-sh/ruff/assets/67177269/1c3a24e1-5097-4e96-9c13-78eadb15df31">

<p>A few solutions which come to my mind:</p>
<ul>
<li><code>python-lsp-ruff</code> would always update the document URI to use <code>.py</code> extension but that would mean any <code>per-file-ignores</code> using the <code>.ipynb</code> extension won't work</li>
<li>A new CLI flag to specify the source type explicitly (similar to the <code>--parser</code> flag in Prettier):<pre><code>--parser &lt;flow|babel|babel-flow|babel-ts|typescript|acorn|espree|meriyah|css|less|scss|json|json5|json-stringify|graphql|markdown|mdx|vue|yaml|glimmer|html|angular&gt;
                         Which parser to use.
</code></pre>
</li>
</ul>
<p>Feel free to share any other suggestions :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">cli</span> added by @charliermarsh on 2023-08-25 03:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @charliermarsh on 2023-08-25 03:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-10-03 08:52</div>
            <div class="timeline-body"><p>Hi all. Sorry for posting on an old issue.  For me, I would prefer option 2: a new CLI flag, so that options such as per-file-ignores can work both in a jupyter lsp context as well as when running ruff on notebooks in command lines, pre-commit etc.</p>
<p>An example of a per-file-ignore that can definitely be scoped to ipynb files is B018.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-10-03 13:29</div>
            <div class="timeline-body"><p>Could our notebook parser (or a step upstream of it) just be updated to wrap the content in a single cell if it's not already? I don't see a <code>parser</code> option as a user-facing setting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-10-03 14:50</div>
            <div class="timeline-body"><p>I think that could work.  My concern was that since ruff output includes cell numbers, it would interfere with the part of jupyterlab-lsp which maps line numbers in the linter output back to the original cells.
However, it looks like when <code>--format=json</code> it just gives line numbers so should be fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-03 15:57</div>
            <div class="timeline-body"><p>I think the exclusion of cell numbers is a bug in the JSON format is a bug (see, e.g., https://github.com/astral-sh/ruff/pull/7664). Broadly, I'm worried that treating Python source as Jupyter could cause other problems, some unanticipated (e.g., if you accepted the code via <code>stdin</code>, we'd then output notebook JSON when formatting or autofixing).</p>
<p>Without doing deeper research, my current preferences would be something like:</p>
<ol>
<li>Figure out how to get jupyterlab-lsp to send us the full notebook. This would the most reliable and it would avoid unnecessarily converting from Jupyter to Python back to Jupyter.</li>
<li>Add a dedicated flag to determine the source type (like <code>--parser</code>). I think this is reasonable, even if only intended for LSPs and other programmatic clients.</li>
<li>If we parse a notebook, and it's not JSON, fall back to parsing as Python? This is sort of similar to Zanie's suggestion but internally we'd treat the whole thing as if it were Python rather than trying to convert it to Jupyter. This feels like a structural error though, I don't love it.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-10-03 16:05</div>
            <div class="timeline-body"><p>Agree that 1. would be preferable. 2. is fine with me if we hide it from the CLI help menu until there are more user-focused use-cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/7835.html">astral-sh/ruff#7835</a> on 2023-10-06 10:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-10-06 10:05</div>
            <div class="timeline-body"><p>Thanks everyone! I thought that it might be too complicated to get python-lsp-ruff/jupyterlab-lsp to use linters that work on notebooks directly, so I made a PR implementing the <code>--parser</code> option.  Thanks for the opportunity to contribute to such a useful and amazing project!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-10-17 03:25</div>
            <div class="timeline-body"><p>My concern with 2 is that, compared to Prettier, we don't support different parsers. I prefer a CLI flag that is more high level and instead allows overriding the file type (mime type remapping), which can be useful in other use cases other than the one mentioned here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-17 03:32</div>
            <div class="timeline-body"><p>Can you spell out in a bit more detail what this CLI flag would look like and/or how it would differ from the above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-10-17 03:51</div>
            <div class="timeline-body"><blockquote>
<p>overriding the file type (mime type remapping)</p>
</blockquote>
<p>Wouldn't that be in conflict with the inferred filetype from the filename's extension provided via <code>--stdin-filename</code>? Or, would that mean that the inference will be avoided?</p>
<p>FWIW, in <code>ruff-dev</code>, I added an option <code>--jupyter</code> which would just mean that the content of the Python file is from a Jupyter Notebook. This helped in development where I didn't need to run a Jupyter server for testing purposes. I think this is a similar case where we want to tell Ruff that the content of this file is from a different filetype.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-10-17 06:03</div>
            <div class="timeline-body"><blockquote>
<p>Wouldn't that be in conflict with the inferred filetype from the filename's extension provided via --stdin-filename? Or, would that mean that the inference will be avoided?</p>
</blockquote>
<p>What I have in mind is that you can map extensions to other files. I don't have a good python example but JSON supports different standards and a user may decide that all their <code>.json</code> files are <code>JSON5</code>. They could then configure <code>*.json</code> = <code>JSON5</code>. I guess it's similar to parser except that we define the language rather than the parser (because we don't support different Python parser).</p>
<p>We could expose the same option on the CLI and it could then be used as <code>--extension ipnby=python</code> or similar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-20 16:21</div>
            <div class="timeline-body"><p>Interesting, so <code>--extension ipynb=python</code> could be repeated?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-10-20 16:33</div>
            <div class="timeline-body"><p>I kind of like that API</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../jupyter-lsp/jupyterlab-lsp/issues/1003.html">jupyter-lsp/jupyterlab-lsp#1003</a> on 2023-10-20 22:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krassowski">@krassowski</a> on 2023-10-20 23:08</div>
            <div class="timeline-body"><p>Hi, some context from <code>jupyter-lsp</code> side:</p>
<ul>
<li>when jupyter-lsp was created the LSP protocol had exclusively support for plain text files</li>
<li>while the most recent LSP version (3.17) <em>embraced</em> notebooks, it does it in a bit convoluted way, sadly not aligned with Jupyter standards; one consequence of it is that even <strong>if</strong> jupyterlab-lsp implements support for the notebook messages from 3.17, it will still not pass the true <a href="https://nbformat.readthedocs.io/en/latest/format_description.html">notebook format</a> JSON but rather a quasi-notebook structure implementing the <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#notebookDocument"><code>NotebookDocument</code></a> interface which diverges from the Jupyter <code>ipynb</code> standard (e.g. <code>kind</code> instead of <code>cell_type</code>, <code>executionSummary.executionOrder</code> instead of <code>execution_count</code> etc) and in which the cell sources are not actually stored but abstracted out to other documents which needs to be retrieved separately.</li>
<li>there are some pros and cons for <code>jupyter-lsp</code> sending concatenated source rather than pure JSON:<ul>
<li>(+) we can piece together nested documents having different languages (e.g. ipython cells with <code>%%sql</code> can be hidden from the parent ruff server)</li>
<li>(+) we do not need to worry about stripping metadata/outputs which can weight hundreds of MB in a notebook</li>
<li>(-) we loose structure information and thus the ability to provide some cool hints such as &quot;3 empty cells&quot; or &quot;Code in a markdown cell will not be executed, did you change the cell type by accident&quot;</li>
</ul>
</li>
</ul>
<p>The last issue about loss of structure could be alleviated if Jupyter ends up formalising a canonical text-based representation of notebooks, currently being discussed from the Markdown-first perspective in https://github.com/jupyter/enhancement-proposals/issues/103 and even more if it includes a way to preserve cell-level metadata, but this has less of an impact on a discussion herein, maybe beyond naming of a future option (<code>ipynb</code> is very concrete Jupyter standard, but future Jupyter notebook serialization formats may allow other formats, so maybe it is best to avoid option names like <code>--jupyter</code> or only make them an alias for say <code>--ipynb</code>).</p>
<p><code>jupyter-lsp</code> could potentially abuse LSP protocol and send the JSON dump as if it was plain text. I would welcome PRs (in jupyterlab/jupyterlab-lsp) which explore this idea, but as of now I am not convinced how well it would work and how much work is needed to make it practical. Again, the problem with the idea that <code>ruff</code> can format notebooks is that if we want to have a quick reply times, we still need to strip the large visualisations from cell outputs and then stitch them back together (as the time 100MB travels on the wire, especially for remote servers, far outweighs the benefits of <code>ruff</code> being blazing fast); if <code>ruff</code> were to rearrange/remove/add/merge cells in reformatting this would be a bit hard to achieve (but possible if we just replaced the outputs with dummy tokens for the round trip).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-10-23 02:52</div>
            <div class="timeline-body"><blockquote>
<p>We could expose the same option on the CLI and it could then be used as <code>--extension ipnby=python</code> or similar.</p>
</blockquote>
<p>So, the mapping will be from file extension to the language (or file extension <code>ipynb=py</code>?). This means one could also do <code>py=ipynb</code> which would mean that the Python file should contain a JSON representing the Notebook. I would prefer to introduce this as a hidden flag for now until we finalize a general way of providing multi-language support.</p>
<hr />
<blockquote>
<p><code>jupyter-lsp</code> could potentially abuse LSP protocol and send the JSON dump as if it was plain text.</p>
</blockquote>
<p>Yes, we're doing this in https://github.com/astral-sh/ruff-lsp/pull/264 where the LSP creates a JSON text representing the Notebook in VSCode which is what is being sent to the Ruff CLI. This works for us as we're in control of what fields we use from the JSON format and I agree that it might be difficult to incorporate this in a general way for multiple tools.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-10-26 12:55</div>
            <div class="timeline-body"><blockquote>
<p>We could expose the same option on the CLI and it could then be used as <code>--extension ipnby=python</code> or similar.</p>
</blockquote>
<p>I've had a go at implementing this idea as a hidden flag.  Is it OK if I raise a PR for it and close the previous PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../astral-sh/ruff-lsp/pulls/264.html">astral-sh/ruff-lsp#264</a> on 2023-10-27 02:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-10-27 06:10</div>
            <div class="timeline-body"><p>I'm not exactly sure if this is going to be enough. Ruff keeps track of the cell boundaries which are used to separate import blocks in each cell. So, for example, take the following two cells:</p>
<p><strong>Cell 1:</strong></p>
<pre><code class="language-python">from math import pi
import os
</code></pre>
<p><strong>Cell 2:</strong></p>
<pre><code class="language-python">from pathlib import Path
import sys
</code></pre>
<p>Correct me if I'm wrong but the concatenated source code which Ruff would receive through Jupyterlab LSP would be:</p>
<pre><code class="language-python">from math import pi
import os
from pathlib import Path
import sys
</code></pre>
<p>The imports would be sorted as:</p>
<pre><code class="language-python">import os
import sys
from math import pi
from pathlib import Path
</code></pre>
<p>And then mapped back to the Notebook as:</p>
<p><strong>Cell 1:</strong></p>
<pre><code class="language-python">import os
import sys
</code></pre>
<p><strong>Cell 2:</strong></p>
<pre><code class="language-python">from math import pi
from pathlib import Path
</code></pre>
<p>Notice that the imports have been moved between cells. Ruff's native implementation wouldn't do that and only sort imports in <em>each</em> cell.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-10-30 11:36</div>
            <div class="timeline-body"><p>That's interesting. Are there any rules other than <code>I001</code> where the diagnostic can span multiple cells?
As far as I know, right now jupyterlab-lsp doesn't support formatting/fixing so it can't move import statements between cells.
Is the concern that this will lead to a false-positive?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-30 13:32</div>
            <div class="timeline-body"><p>@felix-cw - <code>I001</code> is the only rule whose <em>diagnostic</em> can span multiple cells, but there are multiple rules whose fixes can span multiple cells (i.e., you may need to add an import to the top of the file in order to access a new standard library module for the code edit).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-10-31 03:04</div>
            <div class="timeline-body"><blockquote>
<p>As far as I know, right now jupyterlab-lsp doesn't support formatting/fixing so it can't move import statements between cells.</p>
</blockquote>
<p>Oh, interesting! Thanks for letting us know. So, it seems that they don't support code actions / formatting which are two main ways that we would edit a Notebook content. But, they do plan to support them in the future https://github.com/jupyter-lsp/jupyterlab-lsp/issues/985.</p>
<blockquote>
<p>Is the concern that this will lead to a false-positive?</p>
</blockquote>
<p>I'm not exactly sure. My main concern is that I don't know how Jupyterlab LSP maps the location information between the actual Notebook source and the concatenated source. This would probably be updated when they plan to integrate editing cell content via code actions / formatting.</p>
<p>There does exists a documentation around their source map model (https://github.com/jupyter-lsp/jupyterlab-lsp/blob/main/docs/Architecture.ipynb) which seems to be mapping the (line, character) value between multiple types of document and concatenating the source code with 2 blank lines?</p>
<p>We could, theoretically, support diagnostics using any of the possible solutions mentioned in this issue but it might probably break when they add support for code actions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krassowski">@krassowski</a> on 2023-10-31 07:17</div>
            <div class="timeline-body"><p>I think you do not need to worry about how jupyterlab-lsp handles mapping between cells and text content, I am sure this will work well. And yes there is a branch with code actions support but I cannot test it against ruff yet because it just rejects text content on the basis of extension ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/8373.html">astral-sh/ruff#8373</a> on 2023-10-31 10:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> removed by @dhruvmanila on 2023-11-08 02:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-11-08 02:43</div>
            <div class="timeline-body"><p>Resolved in #8373</p>
<p>@felix-cw Do you mind providing the next steps required to make this integration work? Is it mostly on the user side? If so, I can update the documentation. Are there any changes required from either <code>jupyterlab-lsp</code> / <code>python-lsp-ruff</code> side?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/felix-cw">@felix-cw</a> on 2023-11-08 10:31</div>
            <div class="timeline-body"><p>Thanks for merging my pull request!</p>
<p>I think we need to add <code>--extension ipynb:python</code> to the call to ruff that <code>python-lsp-ruff</code> makes.  I'm not sure about the side effects of this, when it is used outside of <code>jupyterlab-lsp</code> though, so it might need to be behind a config option. I'll reach out to the projects.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../python-lsp/python-lsp-ruff/pulls/59.html">python-lsp/python-lsp-ruff#59</a> on 2023-11-10 10:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-11-27 16:02</div>
            <div class="timeline-body"><p>This is resolved when using <code>v2.0.0</code> of <code>python-lsp-ruff</code>, big thanks to @felix-cw for driving this change forward ðŸ¥³</p>
<p>https://github.com/python-lsp/python-lsp-ruff/releases/tag/v2.0.0</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2023-11-27 16:02</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:10 UTC
    </footer>
</body>
</html>
