<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`PLW1641` false positives for dataclasses - astral-sh/ruff #18905</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>PLW1641</code> false positives for dataclasses</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/18905">#18905</a>
        opened by <a href="https://github.com/lengau">@lengau</a>
        on 2025-06-23 22:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/lengau">@lengau</a></div>
            <div class="timeline-body">Summary
<p>When using <code>dataclasses</code> or other decorators that generate the <code>__hash__</code> method for a class, if you implement an <code>__eq__</code> method manually PLW1641 emits an error.</p>
<p>The following script shows that the classes are correctly hashable, but ruff does not detect the <code>__hash__</code> method.</p>
<pre><code>import dataclasses

@dataclasses.dataclass(frozen=True)
class TrueNegative:

    a: str
    b: int


@dataclasses.dataclass(repr=True, eq=False, frozen=False, unsafe_hash=False)
class TruePositive:

    a: str
    b: int

    def __eq__(self, other):
        return True


@dataclasses.dataclass(frozen=True)  # Implicit eq=True, generates a __hash__
class FalsePositive:

    a: str
    b: int

    def __eq__(self, other):
        return True


@dataclasses.dataclass(eq=True, frozen=True)  # Explicit eq=True, generates a __hash__
class FalsePositive1:

    a: str
    b: int

    def __eq__(self, other):
        return True


@dataclasses.dataclass(unsafe_hash=True)  # Always generates a __hash__
class FalsePositive2:

    a: str
    b: int

    def __eq__(self, other):
        return True



for cls in [TrueNegative, FalsePositive, FalsePositive1, FalsePositive2]:
    assert hash(cls(&quot;a&quot;, 1)) is not None

for cls in [TruePositive]:
    assert cls(&quot;a&quot;, 1).__hash__ is None
</code></pre>
Version
<p>0.12.0</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-23 22:30</div>
            <div class="timeline-body"><p>Nice, thanks for all of the examples! I think that pretty much covers the cases described in the <a href="https://docs.python.org/3/library/dataclasses.html#:~:text=Here%20are%20the%20rules%20governing%20implicit%20creation%20of%20a%20__hash__(">docs</a>%20method.%20Note%20that%20you%20cannot%20both%20have%20an%20explicit%20__hash__()%20method%20in%20your%20dataclass%20and%20set%20unsafe_hash%3DTrue%3B%20this%20will%20result%20in%20a%20TypeError.).</p>
<p>I think it makes sense to update the rule like this, but I&#x27;m certainly open to other thoughts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-23 22:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-23 22:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/squeaky-pl">@squeaky-pl</a> on 2025-07-01 09:39</div>
            <div class="timeline-body"><p>I also hit this when updating to 0.12.</p>
<p>Code is similar to this</p>
<pre><code>@dataclasses.dataclass(frozen=True)
class A:
    a: int

    def __eq__(self, other: object) -&gt; bool:
        match other:
            case A():
                return self.a == other.a
            case B():
                return self.a == other.b
            case _:
                return False
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/antonagestam">@antonagestam</a> on 2025-07-06 15:30</div>
            <div class="timeline-body"><p>This also applies to Pydantic models, and perhaps likely also to other similar libraries.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-08 07:24</div>
            <div class="timeline-body"><p>I&#x27;m sort of surprised that <code>dataclass</code> generates a hash function for</p>
<pre><code>@dataclasses.dataclass(frozen=True)  # Implicit eq=True, generates a __hash__
class FalsePositive:

    a: str
    b: int

    def __eq__(self, other):
        return True
</code></pre>
<p>because the generated hash function violates the contract between eq and hash where <code>a == b</code> implies that <code>hash(a) == hash(b)</code>. For the given example, all instances are equal and would require that all instances should map to the same hash value.</p>
<p>However, we should update the documentation if this reasoning makes sense to broaden why it&#x27;s recommended to override both.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:50:09 UTC
    </footer>
</body>
</html>
