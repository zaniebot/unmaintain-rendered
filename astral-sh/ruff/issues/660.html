<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handle conflicting autofix instructions - astral-sh/ruff #660</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Handle conflicting autofix instructions</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/660">#660</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2022-11-08 14:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-08 14:43</div>
            <div class="timeline-body"><p>If we have a line like:</p>
<pre><code class="language-py">x: Union[int, Option[str]]
</code></pre>
<p>Then if the relevant rules and Python version permit it, we'd like to autofix that line to:</p>
<pre><code class="language-py">x: int | str | None
</code></pre>
<p>However, as-is, that requires two overlapping fixes, which we don't support. So Ruff will fix the outer rule (to <code>x: int | Option[str]</code>), then fix the inner rule if you re-run it (<code>x: int | str | None</code>).</p>
<p>We need to implement an autofix strategy that's amenable to multiple &quot;concurrent&quot; fixes.</p>
<p>This will also apply to import sorting: we want to be able to remove unused imports <em>and</em> re-sort imports in a single pass.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @charliermarsh on 2022-11-08 14:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-08 14:47</div>
            <div class="timeline-body"><p>I don't know how to implement this yet. I need to do some research. But a few ideas come to mind:</p>
<ol>
<li>Structure it as a CRDT-like concurrent editing problem. Use CRDTs or similar to enable us to reconcile these kinds of concurrent edits.</li>
<li>Re-write rules to batch these changes. For example, above, maybe we just surface a <em>single</em> error with the autofix for the entire expression, rather than emitting an error for <code>Union</code> and an error for <code>Option</code>. This is pretty limiting, as it wouldn't work for (e.g.) the unused import + re-order import case.</li>
<li>Make the fix API more AST-aware? Enable some kind of composition semantics, such that if we know we're replacing a list of Statements with a list of Statements, then we should allow any edits of the form Statement -&gt; Statement.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Implement conflicting autofixes" to "Handle conflicting autofix instructions" by @charliermarsh on 2022-11-08 20:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljodal">@ljodal</a> on 2022-11-08 21:53</div>
            <div class="timeline-body"><p>Have you worked with LibCST? I like how that handles modification to the ast/cst. Basically you implement a visitor that takes two nodes as input, <code>node</code> and <code>updated_node</code>, and returns a node. The <code>node</code> parameter is the parsed node from source and the <code>updated_node</code> parameter is the output from the previous visitor. So depending on the rule you can decide to consider previous modifications or not completely ignore them.</p>
<p>I also think that would work fine for the example above here. You could have two visitors; one that does <code>Optional[X]</code> -&gt; <code>X | None</code> and a one that does <code>Union[A, B]</code> to <code>A | B</code>. It wouldn’t really matter what order these are run in, the output should always be the same. Either <code>Union[A, Optional[B]]</code> -&gt; <code>A | Optional[B]</code> -&gt; <code>A | B | None</code> or <code>Union[A, Optional[B]</code> -&gt; <code>Union[A, B | None]</code> -&gt; <code>A | B | None</code></p>
<p>This would probably not fix the remove unused import issue, though that could maybe be considered a separate issue? If I’m not mistaken libcst handles that through a special hook where you can mark imports as unused/potentially unused after a modification has been made. I assume those imports are then removed in a second pass, which could run before the sorting runs</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-08 22:09</div>
            <div class="timeline-body"><p>Yeah! We use LibCST internally to power some (not all) of our autofix operations. However, I think that LibCST's visitor API is entirely defined on the Python side, so I haven't used it before (we just use the CST parser and the ability to generate code from a modified CST struct)...</p>
<p>I do like what you're describing here. The main challenge, as-is, is that we don't actually create a CST for every module -- we create them eagerly, since CST generation is quite expensive. When we want to autofix something via LibCST, we extract the source code (using the delimiters defined by the AST), pass it to LibCST, generate the modified source, and then treat that source-to-source replacement as the &quot;fix&quot;.</p>
<p>In other words, as-implemented, the individual fix operations have access to a CST, but there's no concept of passing the modified code or CST from check to check. (That's not to say we can't use this approach; rather, that it would take work.)</p>
<p>I do think we probably need to do something AST-aware (or CST-aware) in order to solve this problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-08 22:12</div>
            <div class="timeline-body"><p>In the <code>Union[A, Optional[B]]</code>, another way to look at it would be as a series of sequential edits.</p>
<p>So, to get rid of the <code>Union</code>:</p>
<ul>
<li>&quot;Remove <code>Union[</code></li>
<li>&quot;Retain <code>A</code>&quot;</li>
<li>&quot;Remove <code>,</code>&quot;</li>
<li>&quot;Insert <code> |</code>&quot;</li>
<li>&quot;Retain <code> Option[B]</code>&quot;</li>
<li>&quot;Remove <code>]</code>&quot;</li>
</ul>
<p>Then, to get rid of the <code>Option</code>, you do a similar thing.</p>
<p>If fixes were defined as those kinds of atomic operations, I believe you could reconcile them using CRDT-like operations. But it may not apply as cleanly to over kinds of collisions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljodal">@ljodal</a> on 2022-11-08 22:24</div>
            <div class="timeline-body"><p>Ah, then I'd misunderstood how ruff works. I naively assumed it built up a cst of the source code and then traversed that. As a developer that's at least an interface that is great to work with and one benefit is that you can share a lot of code between linting and fixing.</p>
<p>The visitor pattern in libcst is indeed implemented in Python. It's documented <a href="https://libcst.readthedocs.io/en/latest/tutorial.html#Build-Visitor-or-Transformer">here</a> and basically mirrors the visitors from the <code>ast</code> library with extensions for modifying the tree.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-09 00:08</div>
            <div class="timeline-body"><p>Yeah, I did a bunch of exploration around using the CST everywhere, but it was ~10x slower which brought execution time into the multiple seconds range.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-09 00:09</div>
            <div class="timeline-body"><p>On CRDTs -- what I'm trying to describe is something like this:</p>
<pre><code class="language-rust">use operational_transform::OperationSeq;

pub fn main() {
    let s = &quot;Union[int, Option[str]]&quot;;
    let mut a = OperationSeq::default();
    a.delete(&quot;Union[&quot;.len() as u64);
    a.retain(&quot;int&quot;.len() as u64);
    a.delete(&quot;,&quot;.len() as u64);
    a.insert(&quot; |&quot;);
    a.retain(&quot; Option[str]&quot;.len() as u64);
    a.delete(&quot;]&quot;.len() as u64);

    let mut b = OperationSeq::default();
    b.retain(&quot;Union[int, &quot;.len() as u64);
    b.delete(&quot;Option[&quot;.len() as u64);
    b.retain(&quot;str&quot;.len() as u64);
    b.insert(&quot; | None&quot;);
    b.delete(&quot;]&quot;.len() as u64);
    b.retain(&quot;]&quot;.len() as u64);

    let (_, b_prime) = a.transform(&amp;b).unwrap();
    let ab_prime = a.compose(&amp;b_prime).unwrap();
    let s = ab_prime.apply(s).unwrap();
    println!(&quot;{}&quot;, s); // int | str | None
}
</code></pre>
<p>I'm not convinced that this is a good idea since we could easily start producing invalid Python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-09 01:49</div>
            <div class="timeline-body"><p>The way that <code>pyupgrade</code> handles this is somewhat interesting. They have a roundtrip tokenizer, and they implement all fixes as lazy transformations on the token stream. I don't see how that's completely safe, but it does work for the cases they implement.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljodal">@ljodal</a> on 2022-11-09 07:48</div>
            <div class="timeline-body"><p>Hmm, does it have to be lazy?</p>
<p>My (new) understanding is that ruff builds up an ast of the file being checked, if that's correct it would be great to be able to build both checkers and fixers on top of the ast.</p>
<p>If we can keep both the tokens and the ast in memory and link them, then it should based on my naive understanding be possible to use the ast to detect where changes are needed, get the tokens for that ast and update them, and then based on the updated tokens update the ast representation again.</p>
<p>I'm a bit rusty when it comes to compiler theory, but I assume the ast is built up from the tokens, so we should have everything available. The hard part here would probably be to deal with certain things that don't map direly to ast nodes like white space, commas etc</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/465.html">astral-sh/ruff#465</a> on 2022-11-11 00:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andersk">@andersk</a> on 2022-11-20 08:02</div>
            <div class="timeline-body"><p>Maybe we just want to apply a non-conflicting subset of the fixes, then repeatedly rerun the entire linter on the file until it converges?</p>
<p>I doubt we’re ever going to be able to guarantee that enough operations commute to make any other strategy work correctly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-20 15:07</div>
            <div class="timeline-body"><p>Yeah, I think that's very likely what we'll have to do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/866.html">astral-sh/ruff#866</a> on 2022-11-21 22:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/868.html">astral-sh/ruff#868</a> on 2022-11-22 02:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/875.html">astral-sh/ruff#875</a> on 2022-11-22 21:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-11-22 21:38</div>
            <div class="timeline-body"><p>Should be fixed by https://github.com/charliermarsh/ruff/pull/875.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2022-11-22 21:38</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:06 UTC
    </footer>
</body>
</html>
