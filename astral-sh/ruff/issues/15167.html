<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Request: Option to only apply `superfluous-else-*` on multi-statement blocks (`RET505`, `RET506`, `RET507`, `RET508`) - astral-sh/ruff #15167</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Request: Option to only apply <code>superfluous-else-*</code> on multi-statement blocks (<code>RET505</code>, <code>RET506</code>, <code>RET507</code>, <code>RET508</code>)</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/15167">#15167</a>
        opened by <a href="https://github.com/Avasam">@Avasam</a>
        on 2024-12-28 19:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Avasam">@Avasam</a></div>
            <div class="timeline-body"><p>I&#x27;m really into if-guards, and <code>superfluous-else-*</code> rules help enable that pattern.</p>
<pre><code># RET505 will catch this
def foo(bar):
    if do_early_validation(bar):
        return  # or throw
    else:
        print(bar)
        # some longer block of code
        # ...
        # ...
        # ...
        # ...
        return bar

# and turn it into that
def foo(bar):
    if do_early_validation(bar):
        return  # or throw
        # my mind will mostly ignore this part when quickly reading the method to understand what it does

    print(bar)
    # some longer block of code
    # ...
    # ...
    # ...
    # ...
    return bar
</code></pre>
<p>However, I find that for single statements (a simple &quot;if do this else do that&quot;) it doesn&#x27;t work as well and the <code>else</code> keyword could actually help with the conditional flow readability.</p>
<p>Here&#x27;s two concrete example from typeshed:</p>
<pre><code>def tests_path(distribution_name: str) -&gt; Path:
    if distribution_name == &quot;stdlib&quot;:
        return STDLIB_PATH / TESTS_DIR
    else:
        return STUBS_PATH / distribution_name / TESTS_DIR

def allowlists(distribution_name: str) -&gt; list[str]:
    prefix = &quot;&quot; if distribution_name == &quot;stdlib&quot; else &quot;stubtest_allowlist_&quot;
    version_id = f&quot;py{sys.version_info.major}{sys.version_info.minor}&quot;

    platform_allowlist = f&quot;{prefix}{sys.platform}.txt&quot;
    version_allowlist = f&quot;{prefix}{version_id}.txt&quot;
    combined_allowlist = f&quot;{prefix}{sys.platform}-{version_id}.txt&quot;
    local_version_allowlist = version_allowlist + &quot;.local&quot;

    if distribution_name == &quot;stdlib&quot;:
        return [&quot;common.txt&quot;, platform_allowlist, version_allowlist, combined_allowlist, local_version_allowlist]
    else:
        return [&quot;stubtest_allowlist.txt&quot;, platform_allowlist]
</code></pre>
<p>vs</p>
<pre><code>def tests_path(distribution_name: str) -&gt; Path:
    if distribution_name == &quot;stdlib&quot;:
        return STDLIB_PATH / TESTS_DIR
    return STUBS_PATH / distribution_name / TESTS_DIR

def allowlists(distribution_name: str) -&gt; list[str]:
    prefix = &quot;&quot; if distribution_name == &quot;stdlib&quot; else &quot;stubtest_allowlist_&quot;
    version_id = f&quot;py{sys.version_info.major}{sys.version_info.minor}&quot;

    platform_allowlist = f&quot;{prefix}{sys.platform}.txt&quot;
    version_allowlist = f&quot;{prefix}{version_id}.txt&quot;
    combined_allowlist = f&quot;{prefix}{sys.platform}-{version_id}.txt&quot;
    local_version_allowlist = version_allowlist + &quot;.local&quot;

    if distribution_name == &quot;stdlib&quot;:
        return [&quot;common.txt&quot;, platform_allowlist, version_allowlist, combined_allowlist, local_version_allowlist]
    return [&quot;stubtest_allowlist.txt&quot;, platform_allowlist]
</code></pre>
<p>So I&#x27;m suggesting that these rule could be only applied to cases where the <code>else</code> block is more than a single statement.</p>
<hr>
<p>Moreover, users of ternary conditions (like <a href="https://docs.astral.sh/ruff/rules/if-else-block-instead-of-if-exp/#if-else-block-instead-of-if-exp-sim108">if-else-block-instead-of-if-exp (SIM108)</a>) may prefer turning the single-statement cases into something like this anyway:</p>
<pre><code>def tests_path(distribution_name: str) -&gt; Path:
    return STDLIB_PATH / TESTS_DIR if distribution_name == &quot;stdlib&quot; else STUBS_PATH / distribution_name / TESTS_DIR

def allowlists(distribution_name: str) -&gt; list[str]:
    return (
        [&quot;common.txt&quot;, platform_allowlist, version_allowlist, combined_allowlist, local_version_allowlist]
        if distribution_name == &quot;stdlib&quot;
        else [&quot;stubtest_allowlist.txt&quot;, platform_allowlist]
    )
</code></pre>
<p>Granted SIM108 doesn&#x27;t currently cover that, it&#x27;d probably be a different rule (<a href="https://github.com/astral-sh/ruff/issues/13898">astral-sh/ruff#13898</a>#issuecomment-2436959490) but this is getting out of topic.</p>
<hr>
<p>More keywords: superfluous-else-return , superfluous-else-raise, superfluous-else-continue, superfluous-else-break
Ruff: 0.8.4</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-30 10:53</div>
            <div class="timeline-body"><blockquote>
<p>So I&#x27;m suggesting that these rule could be only applied to cases where the else block is more than a single statement.</p>
</blockquote>
<p>I think this would lead to too many false-negatives, making the user less useful for users who strictly prefer <code>if</code> without an else block. I could see an argument to skip over <code>if</code> that is at the end of the function, and both branches end in a return statement (without any other early returns?)</p>
<p>My worry is that this will make the rule harder to explain, and I do think that flagging your examples is in the rule&#x27;s intent. However, I do agree that explicit <code>if..else</code> branches can sometimes be useful, and the way this is done in Rust is that clippy flags:</p>
<pre><code>if cond {
	return val;
} else {
	return val2;
}
</code></pre>
<p>but the following is fine</p>
<pre><code>if cond {
	val
} else {
	val2
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-30 10:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-30 10:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Request: Option to only apply `superfluous-else-*` on single-statements (`RET505`, `RET506`, `RET507`, `RET508`)&quot; to &quot;Request: Option to only apply `superfluous-else-*` on multi-statement blocks (`RET505`, `RET506`, `RET507`, `RET508`)&quot; by <a href="https://github.com/Avasam">@Avasam</a> on 2025-06-21 03:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Anselmoo">@Anselmoo</a> on 2025-07-26 06:36</div>
            <div class="timeline-body">Additional comment about<code>RET506</code> feel too aggressive for simple two-way branches
Environment
<ul>
<li><strong>Ruff</strong>: 0.12.5</li>
<li><strong>Python</strong>: 3.11</li>
<li>Rule: <code>RET506  superfluous-else-return</code> (same family as <code>RET505/RET507/RET508</code>)</li>
</ul>
<hr>
Reproducer
<pre><code>def transform(direction: str, params: Params) -&gt; Result:
    if direction == &quot;case_a&quot;:
        return transformer.case_a(params)
    elif direction == &quot;case_b&quot;:
        return transformer.case_b(params)
    else:
        raise ValueError(f&quot;Unknown direction: {direction}&quot;)
</code></pre>
<p>Ruff reports:</p>
<p><code>Unnecessary `elif` after `return` statementRuff(RET505)</code></p>
<pre><code>[{
	&quot;resource&quot;: &quot;demo.py&quot;,
	&quot;owner&quot;: &quot;Ruff&quot;,
	&quot;code&quot;: {
		&quot;value&quot;: &quot;RET505&quot;,
		&quot;target&quot;: {
			&quot;$mid&quot;: 1,
			&quot;path&quot;: &quot;/ruff/rules/superfluous-else-return&quot;,
			&quot;scheme&quot;: &quot;https&quot;,
			&quot;authority&quot;: &quot;docs.astral.sh&quot;
		}
	},
	&quot;severity&quot;: 4,
	&quot;message&quot;: &quot;Unnecessary `elif` after `return` statement&quot;,
	&quot;source&quot;: &quot;Ruff&quot;,
	&quot;startLineNumber&quot;: 4,
	&quot;startColumn&quot;: 5,
	&quot;endLineNumber&quot;: 4,
	&quot;endColumn&quot;: 9,
	&quot;origin&quot;: &quot;extHost2&quot;
}]
</code></pre>
<hr>
Points to consider:
<ol>
<li><p><strong>Logical grouping</strong> –<br>
The three branches form one closed decision tree (<code>case_a</code> / <code>case_b</code> / “everything else<code>).   Converting the middle branch to a top-level </code>if<code>breaks that visual grouping and can make the final</code>raise` look disconnected from the decision.</p>
</li>
<li><p><strong>Maintaining the “catch-all” semantics</strong> –<br>
The trailing <code>else</code> is deliberately the error path.<br>
An <code>elif … else …</code> chain communicates that more directly than two separate <code>if …</code> blocks followed
by an unconditional <code>raise</code>.</p>
</li>
<li><p><strong>Readability in longer chains</strong> –<br>
In real code there may be several mutually-exclusive directions (<code>case_c</code>, …).<br>
Using <code>if/elif/…/else</code> makes it obvious that exactly one branch will run, while a series of
top-level <code>if</code> statements requires the reader to notice the early returns.</p>
</li>
</ol>
<blockquote>
<p>Concerning Point <strong>3</strong>, is there a <code>RUFF</code> rule to transform <code>if-elif</code> chains into the <a href="https://docs.python.org/3/whatsnew/3.10.html#pep-634-structural-pattern-matching"><code>match-case</code>-syntax</a>?</p>
</blockquote>
<hr>
Proposed change / discussion points
<ul>
<li>Provide an option (e.g. <code>superfluous-else-min-body-lines = 2</code>) so <code>RET506</code> only fires when the
<code>elif</code> block spans more than one statement, similar to the discussion in #15167.</li>
<li>Alternatively, add a project-level toggle to disable <code>RET506</code> while keeping the other
<code>superfluous-else-*</code> rules enabled.</li>
<li>Document common stylistic exceptions where keeping the <code>elif</code> is idiomatic.</li>
</ul>
<p>Thanks for considering!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:49:13 UTC
    </footer>
</body>
</html>
