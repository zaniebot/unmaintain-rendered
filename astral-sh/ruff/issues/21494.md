```yaml
number: 21494
title: "`F821`: Declared only variables"
type: issue
state: open
author: eltoder
labels:
  - bug
  - rule
assignees: []
created_at: 2025-11-17T02:20:59Z
updated_at: 2025-11-20T18:00:56Z
url: https://github.com/astral-sh/ruff/issues/21494
synced_at: 2026-01-10T01:56:57Z
```

# `F821`: Declared only variables

---

_Issue opened by @eltoder on 2025-11-17 02:20_

### Summary

Local variable annotations make annotated variables local even if there is no direct assignment. This is useful to create a local variable without an initial value. Ruff appears to not understand this usage. For example:
```python
from typing import Callable

def make_cell() -> tuple[Callable[[], int], Callable[[int], None]]:
    x: int

    def getter() -> int:
        return x

    def setter(xx: int) -> None:
        nonlocal x
        x = xx

    return getter, setter

getter, setter = make_cell()
setter(123)
print(getter())
```
(playground link: https://play.ruff.rs/3bd90cac-2c87-48b0-9cb4-64fe2a53bf72)

This runs fine and passes mypy, however ruff produces a `F821`:
```
$ ruff check --isolated t.py
F821 Undefined name `x`
 --> t.py:7:16
  |
6 |     def getter() -> int:
7 |         return x
  |                ^
8 |
9 |     def setter(xx: int) -> None:
```


### Version

0.14.5

---

_Renamed from "ruff doesn't handle local variable annotations" to "`F821`: Declared only variables" by @MichaReiser on 2025-11-17 07:14_

---

_Comment by @MichaReiser on 2025-11-17 07:17_

Thank you. Yeah, this is a bug. A variable that is declared by using an annotated assignment without a value shouldn't raise an error.

---

_Label `bug` added by @MichaReiser on 2025-11-17 07:17_

---

_Label `rule` added by @MichaReiser on 2025-11-17 07:17_

---

_Comment by @Ruchir28 on 2025-11-19 15:42_

How should this be handled?

While looking into the code, it seems we could suppress this by checking
if the annotation-only binding is inside a function and then returning
`ReadResult::Resolved(binding_id)`. But I'm not sure if returning Resolved
is the correct behavior here, since the variable may still be unassigned.

https://github.com/astral-sh/ruff/blob/fffbe5a879af0c1b36e44b65219257bcd7e54483/crates/ruff_python_semantic/src/model.rs#L467-L485


---

_Comment by @eltoder on 2025-11-19 15:47_

@Ruchir28 it's not any different than
```python
if False:
    name = something
```


---

_Comment by @ntBre on 2025-11-19 18:25_

@Ruchir28, from a very quick look, that seems like a reasonable place to mark the binding as resolved. Do other things break when you do that?

I'm also curious about the `BindingKind::Nonlocal` branch in `resolve_load`. It seems like `x` should possibly be marked as resolved after the `nonlocal` statement in `setter`, but I might be misunderstanding without playing with the code.

---

_Referenced in [astral-sh/ruff#21540](../../astral-sh/ruff/pulls/21540.md) on 2025-11-20 15:49_

---

_Comment by @Ruchir28 on 2025-11-20 15:50_

@ntBre No it doesn't break anything - and looks like it does resolve the issue 

and I checked the `BindingKind::Nonlocal` branch ,and from what i understand it is indeed marking x as resolved in setter function.


Although not related to the fix, after fixing this, the below code won't fire F821
but still there should be F823 / UnboundLocalError right (which it doesn't currently)?
Should this be addressed separately or in this issue?

```python
def annotated_local_function():
    x: int
    print(x)
```



---

_Comment by @eltoder on 2025-11-20 16:31_

@Ruchir28 `nonlocal` does not appear to mark `x` as resolved:
```python
def make_cell():
    def setter():
        nonlocal x
        print(x)
```
This produces F821. I think it would make sense to mark it as resolved, but it also does not materially change anything, because a variable declared as `nonlocal` must be already visible in the current scope (#21495).

For the F823 / UnboundLocalError -- it appears to be raised only in a very specific pattern. For example, this does not raise it:
```python
def annotated_local_function():
    if False:
        x = 1
    print(x)
```
My impression is that F823 is only raised when the issue is evident from a single statement like `+=` and does not require any control flow analysis. For the local annotation neither of the statements are wrong. You need some control flow analysis to discover that there is no assignment between the declaration and the print.

I suppose you can keep a state per variable of whether it is only declared or assigned, so you will report F823 on
```python
def annotated_local_function():
    x: int
    print(x)
```
but not on
```python
def annotated_local_function():
    x: int
    print(x)
    x = 1
```
I'm not sure how useful this is, but it is probably easy to implement.

---

_Comment by @Ruchir28 on 2025-11-20 17:59_

Interesting looking at the code it looks like it's marking the nonlocal as resolved , but this is weird https://github.com/astral-sh/ruff/issues/21495 
https://github.com/astral-sh/ruff/blob/78ce17ce8f068eb9ef42e3b992aa23a880722d09/crates/ruff_python_semantic/src/model.rs#L566-L581

Also regarding F823 i am not so sure about it and it's implemenation details rn but looks like it can be reported in both the cases here even in the second one [as the load reference will be attached to the initial BindingKind::Annotation id] so it can be detected there too

---
