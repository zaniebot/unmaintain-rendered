<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Does the Ruff formatter validate the final AST in a similar manner to Black? - astral-sh/ruff #8184</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Does the Ruff formatter validate the final AST in a similar manner to Black?</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/8184">#8184</a>
        opened by <a href="https://github.com/max-muoto">@max-muoto</a>
        on 2023-10-24 20:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/max-muoto">@max-muoto</a> on 2023-10-24 20:52</div>
            <div class="timeline-body"><p>We are looking to replace <code>black</code> with the Ruff formatter, but one question I had was does the Ruff formatter validate for an AST equivalent to the original? I know this can be disabled in <code>black</code> with the <code>--fast</code> flag but was curious if this was built into the Ruff formatter by default.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-24 20:55</div>
            <div class="timeline-body"><p>We don't have this behavior, no. We could consider adding it based on interest.</p>
<p>(Not strictly relevant to the question, but just so there's no confusion for any future readers: all benchmarks were compared against Black with <code>--fast</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/max-muoto">@max-muoto</a> on 2023-10-24 20:56</div>
            <div class="timeline-body"><p>Thanks for the info!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-24 21:01</div>
            <div class="timeline-body"><p>No problem.</p>
<p>For completeness: our test suite consists of a large set of <a href="https://github.com/astral-sh/ruff/tree/0236e0751ce0f7230a834f9afe8c747b07faf0ee/crates/ruff_python_formatter/resources/test/fixtures">fixtures</a> (including Black's own test fixtures, plus a bunch of our own), and then we also run the formatter over a selection of open source projects on CI too (<code>twine</code>, <code>django</code>, <code>transformers</code>, <code>typeshed</code>, <code>warehouse</code>, <code>zulip</code>, <code>home-assistant</code>, <code>poetry</code>, <code>cpython</code>).</p>
<p>For the fixtures, we validate output against checked-in snapshots. For the ecosystem projects, we're just diffing to assess similarity. But in both cases, we also error if:</p>
<ul>
<li>We output syntactically invalid code.</li>
<li>We fail to format any comments.</li>
<li>Running the formatter twice results in code changes (i.e., the formatter is unstable).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @MichaReiser on 2023-10-24 23:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by @MichaReiser on 2023-10-24 23:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-25 03:17</div>
            <div class="timeline-body"><p>(Will leave this open for now to see if other folks have additional feedback or questions.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-10-25 16:34</div>
            <div class="timeline-body"><p>We also have fuzzing (e.g. https://github.com/astral-sh/ruff/issues/7938) which covers a lot of strange edge cases. In recent runs i've only seen instabilities (the second formatting pass looks different than the first) but no syntax errors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tusharsadhwani">@tusharsadhwani</a> on 2023-10-26 04:57</div>
            <div class="timeline-body"><p>Validating the final AST can still help against accidental formatting changes that would change runtime behaviour.</p>
<p>A good example would be accidentally formatting <code>f&quot;{a+ 2=}&quot;</code> into <code>f&quot;{a + 2 = }&quot;</code>, which seems like just a formatting change but actually changes the string produced at runtime. The Python AST for this case contains the entire expression itself in it for the same reason.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tusharsadhwani">@tusharsadhwani</a> on 2023-10-26 04:59</div>
            <div class="timeline-body"><p>FWIW I think it should be opt-in, behind a flag to enable it, and all tests (including ones that run ruff against open source projects) should run with that flag enabled, to catch such cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-10-30 09:18</div>
            <div class="timeline-body"><blockquote>
<p>Validating the final AST can still help against accidental formatting changes that would change runtime behaviour.</p>
</blockquote>
<p>That's true, but it requires that the used AST only captures runtime semantics, which isn't the case for Ruff. For example, ruff stores (or will soon) the parts of each implicit concatenated string as individual nodes because having access to each part is useful when doing static analysis (but irrelevant for an interpreter):</p>
<pre><code class="language-python">&quot;a&quot; &quot;b&quot;

# joined
&quot;ab&quot;
</code></pre>
<ul>
<li><code>&quot;a&quot; &quot;b&quot;</code>:<code>StringList[&quot;a&quot;, &quot;b&quot;]</code></li>
<li><code>&quot;ab&quot;</code>: <code>StringList[&quot;ab&quot;]</code></li>
</ul>
<p>The runtime value of both expressions is the same, but Ruff uses a different internal representation for each.</p>
<p>I believe there are other examples around parenthesizing match cases which change the AST structure, but don't result in a semantical change.</p>
<p>Because of that, I believe using the AST for asserting that the runtime semantics are unchanged isn't a good choice and it prevents Ruff from changing its internal AST structure to capture more information, slowing down the development.</p>
<p>It would be nice to have another automatic means to validate that the formatter doesn't change program semantics (could be very useful during fuzzing). We could explore integrating and comparing Python's AST as part of fuzzing, but I prefer not to compare Ruff's ASTs as part of <code>ruff format</code> for the reasons mentioned above and because re-parsing and comparing the AST causes a significant slowdown.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tusharsadhwani">@tusharsadhwani</a> on 2023-10-30 09:21</div>
            <div class="timeline-body"><blockquote>
<p>We could explore integrating and comparing Python's AST as part of fuzzing</p>
</blockquote>
<p>@MichaReiser That is indeed along the lines of what I'm suggesting. Having that option available to end users behind a CLI flag would be a nice to have, but using it for fuzzing during CI seems much more important to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-30 13:27</div>
            <div class="timeline-body"><blockquote>
<p>That's true, but it requires that the used AST only captures runtime semantics, which isn't the case for Ruff.</p>
</blockquote>
<p>In fairness, we do have the <code>Comparable</code> AST variant which exists for this purpose and intentionally ignores (e.g.) implicit concatenations. That property should be maintained over time too -- it's meant to capture whether two AST nodes correspond to the same value.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-10-31 01:00</div>
            <div class="timeline-body"><blockquote>
<p>In fairness, we do have the Comparable AST variant which exists for this purpose and intentionally ignores (e.g.) implicit concatenations. That property should be maintained over time too -- it's meant to capture whether two AST nodes correspond to the same value.</p>
</blockquote>
<p>Oh right. Although it will be interesting to see how we would support this (in a cheap way) if we change our AST structure more fundamentally.</p>
<p>We're also considering integrating <code>isort</code> into the formatter, which would ultimately mean that we have to remove the AST equality check.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tusharsadhwani">@tusharsadhwani</a> on 2023-11-01 11:07</div>
            <div class="timeline-body"><p>Consider having <code>isort</code> stuff as a separate step, and do the AST validation before doing import sorting in your tests?</p>
<p>Since import sorting should be a flag that you can disable (<code>isort</code> is too opinionated for a lot of people), this would make sense overall too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/juftin">@juftin</a> on 2023-11-08 17:29</div>
            <div class="timeline-body"><p>I've been working on introducing the ruff formatter at work but got this question when trying to introduce it as a formatting tool for my organization.</p>
<p>The <code>black</code> formatter's claim that it is safe to use is based on the fact that it <a href="https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#ast-before-and-after-formatting">checks the AST before and after and compares the two</a> is a big reason why a given org may push back on switching from black to ruff - it's a powerful piece of marketing.</p>
<blockquote>
<p>To put things in perspective, the code equivalence check is a feature of Black which other formatters don’t implement at all. It is of crucial importance to us to ensure code behaves the way it did before it got reformatted. We treat this as a feature and there are no plans to relax this in the future.</p>
</blockquote>
<p>Implementing a similar AST validation as an optional flag for the ruff formatter would be a great feature that would make switching over a no-brainer for the team - and speaking personally we would be more than willing to pay for the performance hit that it might cause.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/SonOfLilit">@SonOfLilit</a> on 2023-11-09 17:14</div>
            <div class="timeline-body"><p>If you only want to add it to tests and fuzzing, one easy way to write an AST comparison test would be:</p>
<pre><code class="language-python">def check_same_ast(path):
    with temp_copy(path) as before:
        with temp_copy(path) as after:
            run_ruff(after)
            run_black(before)
            run_black(after)
            assert run_sha256sum(before) == run_sha256sum(after)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tusharsadhwani">@tusharsadhwani</a> on 2023-11-10 09:37</div>
            <div class="timeline-body"><p>@SonOfLilit ruff outputs aren't identical to black though</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/SonOfLilit">@SonOfLilit</a> on 2023-11-11 11:13</div>
            <div class="timeline-body"><p>Indeed, they aren't. But black output is idempotent and does the check we
want, so two files will have the same output if and only if they contain
the same AST, so comparing before/after ruff is a cheap way to compare ASTs.</p>
<p>On Fri, Nov 10, 2023, 11:38 Tushar Sadhwani <em><strong>@</strong></em>.***&gt;
wrote:</p>
<blockquote>
<p>@SonOfLilit <a href="https://github.com/SonOfLilit">https://github.com/SonOfLilit</a> ruff outputs aren't identical
to black though</p>
<p>—
Reply to this email directly, view it on GitHub
<a href="https://github.com/astral-sh/ruff/issues/8184#issuecomment-1805389875">https://github.com/astral-sh/ruff/issues/8184#issuecomment-1805389875</a>,
or unsubscribe
<a href="https://github.com/notifications/unsubscribe-auth/AAADU7OIFELZ34GIE6LCLE3YDXYX7AVCNFSM6AAAAAA6OJRBJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTQMBVGM4DSOBXGU">https://github.com/notifications/unsubscribe-auth/AAADU7OIFELZ34GIE6LCLE3YDXYX7AVCNFSM6AAAAAA6OJRBJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMYTQMBVGM4DSOBXGU</a>
.
You are receiving this because you were mentioned.Message ID:
<em><strong>@</strong></em>.***&gt;</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tusharsadhwani">@tusharsadhwani</a> on 2023-11-11 11:15</div>
            <div class="timeline-body"><p>Ah right, i misread the code. Not a bad idea.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/8624.html">astral-sh/ruff#8624</a> on 2023-11-12 01:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-11-13 17:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-11-13 17:48</div>
            <div class="timeline-body"><p>We now perform this validation during tests.</p>
<p>Interestingly, in implementing this validation, I learned that Black actually <em>does</em> modify the AST during formatting, and so Ruff does too :) Namely, Black modifies indentation within docstrings, which is reflected in the AST; and Black will also parenthesize long <code>del</code> statements (e.g., convert <code>del a, b</code> to <code>del (a, b</code>)), which doesn't change the semantics but does change the AST.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../yt-project/yt/issues/4748.html">yt-project/yt#4748</a> on 2023-11-22 15:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jonasrauber">@jonasrauber</a> on 2024-07-06 02:28</div>
            <div class="timeline-body"><p>If I understand the above correctly, this check is only performed when running ruffs test suite at the moment.
Is there an option to use this at runtime like in black?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-07-06 03:10</div>
            <div class="timeline-body"><p>No, we don’t support running this check at runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../iragm/fishauctions/pulls/199.html">iragm/fishauctions#199</a> on 2024-09-01 00:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:11 UTC
    </footer>
</body>
</html>
