<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>(üéÅ) New rule for suspect dict comprehension with static key - astral-sh/ruff #4857</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>(üéÅ) New rule for suspect dict comprehension with static key</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/4857">#4857</a>
        opened by <a href="https://github.com/KotlinIsland">@KotlinIsland</a>
        on 2023-06-05 05:28
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/KotlinIsland">@KotlinIsland</a></div>
            <div class="timeline-body"><p>I recently ran into some code where the developer was expecting a create a dict with a single key and a value created by a generator comprehension. Instead they ended up with a dict comprehension with a single entry for the value:</p>
<pre><code class="language-py">data = [&quot;some&quot;, &quot;Data&quot;]
out = {&quot;key&quot;: value.upper() for value in data}
print(out)
</code></pre>
<p>Could a new inspection be added that detects the presence of a static key within a dict comprehension?</p>
<h1>Expected:</h1>
<pre><code class="language-py">data = [&quot;some&quot;, &quot;Data&quot;]
out = {&quot;key&quot;: value.upper() for value in data}  # error: Static value for key in dict comprehension.
print(out)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @charliermarsh on 2023-06-05 15:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-05 15:52</div>
            <div class="timeline-body"><p>Looks reasonable to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Skylion007">@Skylion007</a> on 2023-06-05 20:41</div>
            <div class="timeline-body"><p>This feels like it would be a good flake8-bugbear check. Consider suggesting it there https://github.com/PyCQA/flake8-bugbear/issues as well and then we will implement it when it's implemented there anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2023-06-05 22:50</div>
            <div class="timeline-body"><blockquote>
<p>This feels like it would be a good flake8-bugbear check. Consider suggesting it there https://github.com/PyCQA/flake8-bugbear/issues as well and then we will implement it when it's implemented there anyway.</p>
</blockquote>
<p>Seems like a giant waste of effort? Why can't Ruff just do it's own thing and make it's own inspections?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Skylion007">@Skylion007</a> on 2023-06-05 22:59</div>
            <div class="timeline-body"><p>@KotlinIsland Ruf does it have its own inspections (RUFF), but they are way less likely to be used since they have no grouping by category, intent, or are enabled by default.</p>
<p>Putting it under flake8-bugbear would mean they would be transparently added to the default list of rules as well as for any users who use bugbear. Also it would allow people who still only use flake8 for some reason to benefit for the check and improve the quality of code in the entire Python ecosystem. It also provides credibility through their use as popular plugins that already trusted by maintainers (like bugbear, flake8-comprehensions, etc).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-06 00:33</div>
            <div class="timeline-body"><p>So we can definitely add it to <code>RUF</code>. But we won't add it to the flake8-bugbear category unless it's implemented upstream (if we start deviating from the upstream rulesets in those kinds of re-implemented plugins, it makes it impossible to retain parity in the future). Adding it to the flake8-bugbear category has the advantage that more users have it enabled. But it doesn't have to stop us from implementing it, since we can add it to the Ruff-specific category.</p>
<p>To complete the picture... eventually, we will likely recategorize <em>all</em> rules under semantically meaningful categories, rather than tying our categorization to other plugins. (And the thinking is that we'll provide automated tooling to migrate from this flake8-compatibility encoding to a Ruff-first encoding.) But this isn't being worked on right now, we're prioritizing some other stuff above it for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-06-09 02:06</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:47:21 UTC
    </footer>
</body>
</html>
