<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New lint rules for Strength Reduction optimizations - astral-sh/ruff #14636</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>New lint rules for Strength Reduction optimizations</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/14636">#14636</a>
        opened by <a href="https://github.com/tdulcet">@tdulcet</a>
        on 2024-11-27 16:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/tdulcet">@tdulcet</a> on 2024-11-27 16:01</div>
            <div class="timeline-body"><p>Please consider adding new lint rules for <a href="https://en.wikipedia.org/wiki/Strength_reduction">strength reduction</a> optimizations. All of the types of optimizations included in the below examples would improve the performance of Python code, some significantly, especially when the numbers are large. Ruff is fast, so lets help make Python fast as well! A few of the examples would also improve the accuracy/precision of the expression. They should hopefully not decrease the readability of the code and in a few cases might even improve it by simplifying the expressions. Most of them are language agnostic, but they are particularly important in Python, as there is of course typically no compiler to perform the optimizations automatically (at least in CPython). The indented ones are just additional examples of what the proposed new lint rules could fix.</p>
<h3>Power of 2 integer optimizations</h3>
<pre><code class="language-py">x * 2                        # â‡’ x + x or x &lt;&lt; 1
    x * 8                    # â‡’ x &lt;&lt; 3
x // 2                       # â‡’ x &gt;&gt; 1
    x // 8                   # â‡’ x &gt;&gt; 3
x % 2                        # â‡’ x &amp; 1
    x % 8                    # â‡’ x &amp; 7
2 ** x                       # â‡’ 1 &lt;&lt; x
    pow(2, x)
    y * 2 ** x               # â‡’ y &lt;&lt; x
    8 ** 3                   # â‡’ 8 &lt;&lt; 6 or 1 &lt;&lt; 9
</code></pre>
<h3>Exponentiation and Modular optimizations</h3>
<pre><code class="language-py">(x * x) % y                  # â‡’ pow(x, 2, y)
    (x ** 2) % y
    (x * x * x) % y          # â‡’ pow(x, 3, y)
    (x ** 3) % y
    pow(x, 3) % y
x ** 2                       # â‡’ x * x
    pow(x, 2)
pow(x, y)                    # â‡’ x ** y
q, r = x // y, x % y         # â‡’ q, r = divmod(x, y)
    q = x // y; r = x % y
len(bin(x)[2:])              # â‡’ x.bit_length() # Python 3.1+
    len(bin(x).lstrip(&quot;-0b&quot;))
</code></pre>
<p>Also see the <code>FURB161</code> rule.</p>
<h3>Math library related, improves accuracy</h3>
<pre><code class="language-py">math.ceil(x / y)             # â‡’ -(x // -y) # int only
int(math.sqrt(x))            # â‡’ math.isqrt(x) # Python 3.8+
x ** 0.5                     # â‡’ math.sqrt(x)
    x ** (1 / 2)
    pow(x, 0.5)
    math.pow(x, 0.5)
x ** (1 / 3)                 # â‡’ math.cbrt(x) # Python 3.11+
    pow(x, 1 / 3)
    math.pow(x, 1 / 3)
math.e ** x                  # â‡’ math.exp(x)
    pow(math.e, x)
    math.pow(math.e, x)
2.0 ** x                     # â‡’ math.exp2(x) # float only # Python 3.11+
    pow(2.0, x)
    math.pow(2.0, x)
math.exp(x) - 1              # â‡’ math.expm1(x) # Python 3.2+
    (math.e ** x) - 1
    pow(math.e, x) - 1
    math.pow(math.e, x) - 1
x % y                        # â‡’ math.fmod(x, y) # float only
(x * y) + z                  # â‡’ math.fma(x, y, z) # float only # Python 3.13+
math.pi * 2                  # â‡’ math.tau # Python 3.6+
functools.reduce(operator.mul, (x, y, z), 1) # â‡’ math.prod((x, y, z)) # Python 3.8+
</code></pre>
<p>These are similar to the existing rule <code>FURB163</code>.</p>
<h3>Mathematical identities</h3>
<ul>
<li>[ ] #19518</li>
</ul>
<p>May be useful in combination with other autofixes to simplify expressions or when refactoring</p>
<pre><code class="language-py">x * -1               # â‡’ -x
x / -1.0             # â‡’ -x # float only
x // -1              # â‡’ -x # int only
x * 0                # â‡’ 0
x * 1                # â‡’ x
x + 0                # â‡’ x
x - 0                # â‡’ x
x - -y               # â‡’ x + y
x + -y               # â‡’ x - y
+x                   # â‡’ x
x / 1.0              # â‡’ x # float only
x // 1               # â‡’ x # int only
x ** 0               # â‡’ 1
x ** 1               # â‡’ x
x / y / z            # â‡’ x * z / y # float only 
x / 0.0              # â‡’ ERROR!
x // 0               # â‡’ ERROR!
x % 0                # â‡’ ERROR!
</code></pre>
<p>Using <a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws">DeMorganâ€™s theorem</a> to further simplify boolean expressions, similar to the <a href="https://clang.llvm.org/extra/clang-tidy/checks/readability/simplify-boolean-expr.html">simplify-boolean-expr</a> rule in Clang Tidy, would be very helpful here. Also see #15447 and https://github.com/tonybaloney/perflint/issues/50.</p>
<h3>Opinionated, but improves performance</h3>
<pre><code class="language-py"># Replace division with multiplication of the reciprocal
x / 2.0                      # â‡’ x * 0.5 # float only
# Prefer separate lines for assignments, unless tuple unpacking or the expressions depend on each other
x, y = x + z, a * b          # â‡’ x += z; y = a * b
# Unnecessary trivial comprehensions
(y for y in x)               # â‡’ iter(x)
(func(y) for y in x)         # â‡’ map(func, x)
(func(*z) for z in zip(x, y))# â‡’ map(func, x, y)
(y for y in x if y)          # â‡’ filter(None, x)
(y for y in x if not y)      # â‡’ itertools.filterfalse(None, x)
(y for y in x if func(y))    # â‡’ filter(func, x)
(y for y in x if not func(y))# â‡’ itertools.filterfalse(func, x)
# Precompute small constant expressions
60 * 60 * 24                 # â‡’ 86400
(1 &lt;&lt; 32) - 1                # â‡’ 0xFFFFFFFF
&quot;0&quot; * 8                      # â‡’ &quot;00000000&quot;
# Use float literals in exponential notation
10.0 ** 3.0                  # â‡’ 1e3 # float only
2.0 * 10.0 ** 3.0            # â‡’ 2e3
</code></pre>
<p>Also see the <code>FURB140</code> rule and https://github.com/adamchainz/flake8-comprehensions/issues/503.</p>
<hr />
<p>All of these should also work with <code>PLR6104</code> (#8877), so for example <code>x * 2</code> above should also catch <code>x *= 2</code> and offer to replace it with <code>x &lt;&lt;= 1</code>. There are of course more examples, but these are some of the ones I see most frequently in code reviews. As noted above, some of these may require type inference, but I believe an unsafe autofix would still be acceptable in many cases where the chance of a false positive would be low.</p>
<p>I could see some of these proposed rules being added to the existing <code>UP</code>, <code>PL</code>, <code>PERF</code>, <code>FURB</code> and <code>RUF</code> categories, among others. Please let me know if you think I should file this request with one of those upstream linters instead.</p>
<p>For a real world example, see this Python function to calculate the Jacobi symbol <a href="https://rosettacode.org/wiki/Jacobi_symbol#Python">before</a> and <a href="https://github.com/tdulcet/AutoPrimeNet/blob/d92313f882ec6dc11e9d79bd55f99ecee2645258/gimps_status.py#L611-L630">after</a> manually applying several of these strength reduction optimizations, which approximately doubled the resulting performance of the code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-11-28 06:05</div>
            <div class="timeline-body"><p>Interesting! Thanks for writing this up with all the examples provided. This would surely bring Ruff closer to being a <a href="https://docs.astral.sh/ruff/contributing/#compilation-pipeline">&quot;compiler&quot;</a> ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @dhruvmanila on 2024-11-28 06:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @dhruvmanila on 2024-11-28 06:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/14835.html">astral-sh/ruff#14835</a> on 2024-12-08 13:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/15447.html">astral-sh/ruff#15447</a> on 2025-01-13 00:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-03-04 07:44</div>
            <div class="timeline-body"><p>&quot;Power of 2 integer optimizations&quot; I find a <em>lot</em> less readable. Bitshifts and masks are not intuitive unless you actively use them regularly.</p>
<p>I'd expect those to be their own rule for when performance really matters. I'm all for &quot;free speed optimizations&quot; even (especially) for slow languages like Python. But these hurt readability a lot imo.</p>
<p>Some require type information that Ruff may not have atm (int vs float).</p>
<p>Everything else I'd love to see anytime!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tdulcet">@tdulcet</a> on 2025-03-04 12:01</div>
            <div class="timeline-body"><blockquote>
<p>I'd expect those to be their own rule for when performance really matters. I'm all for &quot;free speed optimizations&quot; even (especially) for slow languages like Python.</p>
</blockquote>
<p>Yes, I imagine each of these categories would include at least one rule. Note that the resulting performance improvement from those power of 2 optimizations can be significant (this is with Python 3.12):</p>
<pre><code>$ python3 -m timeit -s 'x = 136279841' '2 ** x'
1 loop, best of 5: 551 msec per loop
$ python3 -m timeit -s 'x = 136279841' '1 &lt;&lt; x'
500 loops, best of 5: 741 usec per loop
</code></pre>
<p>That is <strong>744Ã—</strong> faster (ms to us).</p>
<pre><code>$ python3 -m timeit -s 'x = (1 &lt;&lt; 136279841) - 1' 'x % 2'
5 loops, best of 5: 44.3 msec per loop
$ python3 -m timeit -s 'x = (1 &lt;&lt; 136279841) - 1' 'x &amp; 1'
10000000 loops, best of 5: 33.8 nsec per loop
</code></pre>
<p>That is <strong>762,980Ã—</strong> faster (ms to ns)! ðŸ¤¯</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kaddkaka">@kaddkaka</a> on 2025-06-18 17:55</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>I'd expect those to be their own rule for when performance really matters. I'm all for &quot;free speed optimizations&quot; even (especially) for slow languages like Python.</p>
</blockquote>
<p>Yes, I imagine each of these categories would include at least one rule. Note that the resulting performance improvement from those power of 2 optimizations can be significant (this is with Python 3.12):</p>
<pre><code>$ python3 -m timeit -s 'x = 136279841' '2 ** x'
1 loop, best of 5: 551 msec per loop
$ python3 -m timeit -s 'x = 136279841' '1 &lt;&lt; x'
500 loops, best of 5: 741 usec per loop
</code></pre>
<p>That is <strong>744Ã—</strong> faster (ms to us).</p>
<pre><code>$ python3 -m timeit -s 'x = (1 &lt;&lt; 136279841) - 1' 'x % 2'
5 loops, best of 5: 44.3 msec per loop
$ python3 -m timeit -s 'x = (1 &lt;&lt; 136279841) - 1' 'x &amp; 1'
10000000 loops, best of 5: 33.8 nsec per loop
</code></pre>
<p>That is <strong>762,980Ã—</strong> faster (ms to ns)! ðŸ¤¯</p>
</blockquote>
<p>I'm not sure how fair this comparison is. Such large numbers must be very rare?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tdulcet">@tdulcet</a> on 2025-06-18 19:27</div>
            <div class="timeline-body"><blockquote>
<p>I'm not sure how fair this comparison is. Such large numbers must be very rare?</p>
</blockquote>
<p>I used this large number to make it less noisy and easier to benchmark. Specifically, it is the <a href="https://en.wikipedia.org/wiki/Largest_known_prime_number">largest known prime number</a>. However, it is still much faster even with smaller numbers:</p>
<pre><code>$ python3 -m timeit -s 'x = 127' '2 ** x'
1000000 loops, best of 5: 226 nsec per loop
$ python3 -m timeit -s 'x = 127' '1 &lt;&lt; x'
10000000 loops, best of 5: 34.2 nsec per loop
</code></pre>
<p>That is 6.8Ã— faster.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:54 UTC
    </footer>
</body>
</html>
