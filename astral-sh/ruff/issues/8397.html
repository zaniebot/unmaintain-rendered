<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N805 not compatible with sqlalchemy hybrids - astral-sh/ruff #8397</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>N805 not compatible with sqlalchemy hybrids</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/8397">#8397</a>
        opened by <a href="https://github.com/ThiefMaster">@ThiefMaster</a>
        on 2023-10-31 22:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ThiefMaster">@ThiefMaster</a></div>
            <div class="timeline-body"><p>Apologies for opening a new issue for what's basically part of #4604, but considering that this is one closed even though half of it has not been addressed at all, and I'm not getting any replies to my comment there, I think opening a new one makes sense - this is clearly a missing feature / bug, and it makes this particular check from ruff pretty much unusable for any codebase using SQLAlchemy's hybrid properties.</p>
<p>Basically I need ruff to treat either <code>@*.expression</code> as a classmethod decorator, or alternatively have a way of telling it that <code>sqlalchemy.ext.hybrid.hybrid_property</code> returns a normal property, but the method decorated with that property has a <code>.expression</code> attribute that is a classmethod decorator...</p>
<hr />
<h3>ruff.toml</h3>
<pre><code class="language-toml">select = ['N805']

[pep8-naming]
classmethod-decorators = [
    'classmethod',
    'declared_attr',
    'expression',
    'comparator',
]
</code></pre>
<h3>ruff_sample.py</h3>
<pre><code class="language-python">from sqlalchemy.ext.hybrid import hybrid_property


class SQLAlchemyModel:
    @hybrid_property
    def foo(self):
        return not self._foo

    @foo.expression
    def foo(cls):
        return ~cls._foo
</code></pre>
<h3>Output</h3>
<pre><code>$ ruff check ruff_sample.py
ruff_sample.py:10:13: N805 First argument of a method should be named `self`
Found 1 error.
</code></pre>
<h3>Version</h3>
<pre><code>ruff==0.1.3
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-01 00:30</div>
            <div class="timeline-body"><p>Perhaps we can allow wildcards in <code>classmethod-decorators</code>; would that address your use case?</p>
<p>Sorry your last issue didn't get more replies, we're a small team :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ThiefMaster">@ThiefMaster</a> on 2023-11-01 00:34</div>
            <div class="timeline-body"><p>i think one of these solutions would be the easiest and indeed solve my issue:</p>
<ul>
<li>wildcard support as you proposed, applied to the whole decorator function name</li>
<li>doing a suffix match when the entry in classmethod-decorators starts with a dot</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">configuration</span> added by @zanieb on 2023-11-01 00:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @zanieb on 2023-11-01 00:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-11-10 02:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:48:51 UTC
    </footer>
</body>
</html>
