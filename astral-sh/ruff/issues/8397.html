<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>N805 not compatible with sqlalchemy hybrids - astral-sh/ruff #8397</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>N805 not compatible with sqlalchemy hybrids</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/8397">#8397</a>
        opened by <a href="https://github.com/ThiefMaster">@ThiefMaster</a>
        on 2023-10-31 22:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ThiefMaster">@ThiefMaster</a></div>
            <div class="timeline-body"><p>Apologies for opening a new issue for what&#x27;s basically part of #4604, but considering that this is one closed even though half of it has not been addressed at all, and I&#x27;m not getting any replies to my comment there, I think opening a new one makes sense - this is clearly a missing feature / bug, and it makes this particular check from ruff pretty much unusable for any codebase using SQLAlchemy&#x27;s hybrid properties.</p>
<p>Basically I need ruff to treat either <code>@*.expression</code> as a classmethod decorator, or alternatively have a way of telling it that <code>sqlalchemy.ext.hybrid.hybrid_property</code> returns a normal property, but the method decorated with that property has a <code>.expression</code> attribute that is a classmethod decorator...</p>
<hr>
ruff.toml
<pre><code>select = [&#x27;N805&#x27;]

[pep8-naming]
classmethod-decorators = [
    &#x27;classmethod&#x27;,
    &#x27;declared_attr&#x27;,
    &#x27;expression&#x27;,
    &#x27;comparator&#x27;,
]
</code></pre>
ruff_sample.py
<pre><code>from sqlalchemy.ext.hybrid import hybrid_property


class SQLAlchemyModel:
    @hybrid_property
    def foo(self):
        return not self._foo

    @foo.expression
    def foo(cls):
        return ~cls._foo
</code></pre>
Output
<pre><code>$ ruff check ruff_sample.py
ruff_sample.py:10:13: N805 First argument of a method should be named `self`
Found 1 error.
</code></pre>
Version
<pre><code>ruff==0.1.3
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-01 00:30</div>
            <div class="timeline-body"><p>Perhaps we can allow wildcards in <code>classmethod-decorators</code>; would that address your use case?</p>
<p>Sorry your last issue didn&#x27;t get more replies, we&#x27;re a small team :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ThiefMaster">@ThiefMaster</a> on 2023-11-01 00:34</div>
            <div class="timeline-body"><p>i think one of these solutions would be the easiest and indeed solve my issue:</p>
<ul>
<li>wildcard support as you proposed, applied to the whole decorator function name</li>
<li>doing a suffix match when the entry in classmethod-decorators starts with a dot</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">configuration</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-01 00:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-01 00:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-11-10 02:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:45 UTC
    </footer>
</body>
</html>
