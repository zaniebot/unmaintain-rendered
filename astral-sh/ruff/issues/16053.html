<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLC2801 fix ignores the expression’s syntactic context - astral-sh/ruff #16053</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>PLC2801 fix ignores the expression’s syntactic context</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/16053">#16053</a>
        opened by <a href="https://github.com/dscorbett">@dscorbett</a>
        on 2025-02-09 15:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/dscorbett">@dscorbett</a> on 2025-02-09 15:51</div>
            <div class="timeline-body"><h3>Description</h3>
<p>The fix for <a href="https://docs.astral.sh/ruff/rules/unnecessary-dunder-call/">unnecessary-dunder-call (PLC2801)</a> in Ruff 0.9.5 sometimes misinterprets the context surrounding the rewritten expression, causing changes to program behavior or failing due to syntax errors.</p>
<p>Parentheses are missing when the default precedence of operators does not match the intended evaluation order.</p>
<pre><code class="language-console">$ cat &gt;plc2801_1.py &lt;&lt;'# EOF'
print((not 1).__add__(1))
try:
    print(list(&quot;x&quot;.__add__(y for y in &quot;y&quot;)))
except TypeError as e:
    print(e)
print(type((lambda: 0).__eq__(&quot;x&quot;)))
print((&quot;a&quot; and &quot;x&quot;).__contains__(&quot;x&quot;))
print((&quot;&quot; or &quot;x&quot;).__contains__(&quot;x&quot;))
print((&quot;&quot; if False else &quot;x&quot;).__contains__(&quot;x&quot;))
# EOF

$ python plc2801_1.py
1
can only concatenate str (not &quot;generator&quot;) to str
&lt;class 'NotImplementedType'&gt;
True
True
True

$ ruff --isolated check --preview --select PLC2801 plc2801_1.py --unsafe-fixes --fix
Found 6 errors (6 fixed, 0 remaining).

$ cat plc2801_1.py
print(not 1 + 1)
try:
    print(list(&quot;x&quot; + y for y in &quot;y&quot;))
except TypeError as e:
    print(e)
print(type(lambda: 0 == &quot;x&quot;))
print(&quot;x&quot; in &quot;a&quot; and &quot;x&quot;)
print(&quot;x&quot; in &quot;&quot; or &quot;x&quot;)
print(&quot;x&quot; in &quot;&quot; if False else &quot;x&quot;)

$ python plc2801_1.py
False
['xy']
&lt;class 'function'&gt;
False
x
x
</code></pre>
<p>Parentheses are missing when all the relevant operators have the same precedence but the intended evaluation order is not left to right.</p>
<pre><code class="language-console">$ cat &gt;plc2801_2.py &lt;&lt;'# EOF'
print(3 - (2).__add__(1))
# EOF

$ python plc2801_2.py
0

$ ruff --isolated check --preview --select PLC2801 plc2801_2.py --unsafe-fixes --fix
Found 1 error (1 fixed, 0 remaining).

$ cat plc2801_2.py
print(3 - 2 + 1)

$ python plc2801_2.py
2
</code></pre>
<p>Parentheses are missing around an expression rewritten to be a chainable comparison when it is a chaining context.</p>
<pre><code class="language-console">$ cat &gt;plc2801_3.py &lt;&lt;'# EOF'
print(&quot;x&quot;.__eq__(&quot;y&quot;).__eq__(False))
print(False.__eq__(&quot;y&quot;.__eq__(&quot;z&quot;)))
# EOF

$ python plc2801_3.py
True
True

$ ruff --isolated check --preview --select PLC2801 plc2801_3.py --unsafe-fixes --fix
Found 4 errors (4 fixed, 0 remaining).

$ cat plc2801_3.py
print(&quot;x&quot; == &quot;y&quot; == False)
print(False == &quot;y&quot; == &quot;z&quot;)

$ python plc2801_3.py
False
False
</code></pre>
<p>An assignment expression usually needs to be parenthesized.</p>
<pre><code class="language-console">$ echo 'print((x := &quot;x&quot;).__contains__(&quot;y&quot;))' | ruff --isolated check --preview --select PLC2801 - --unsafe-fixes --diff 2&gt;&amp;1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.
</code></pre>
<p>Expressions starting with <code>not</code> or <code>lambda</code> need to be parenthesized when moved to the right side of a binary operator.</p>
<pre><code class="language-console">$ echo 'print((not 0).__radd__(1))' | ruff --isolated check --preview --select PLC2801 - --unsafe-fixes --diff 2&gt;&amp;1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.

$ echo 'print((not &quot;x&quot;).__contains__(&quot;y&quot;))' | ruff --isolated check --preview --select PLC2801 - --unsafe-fixes --diff 2&gt;&amp;1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.

$ echo 'print((lambda: 0).__contains__(&quot;x&quot;))' | ruff --isolated check --preview --select PLC2801 - --unsafe-fixes --diff 2&gt;&amp;1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.
</code></pre>
<p>The fix introduces a syntax error when the argument is a starred expression. The rule should flag the expression but not offer a fix.</p>
<pre><code class="language-console">$ echo 'print(&quot;x&quot;.__add__(*&quot;y&quot;))' | ruff --isolated check --preview --select PLC2801 - --unsafe-fixes --diff 2&gt;&amp;1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @AlexWaygood on 2025-02-09 16:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fixes</span> added by @AlexWaygood on 2025-02-09 16:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/VascoSch92">@VascoSch92</a> on 2025-02-12 09:31</div>
            <div class="timeline-body"><p>Hey,
this seems a very nice bug to fix :-)</p>
<p>Do you mind if I give a try? Or you would like to solve it internally ? (as there is no label <code>help-needed</code> :-) )</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 09:38</div>
            <div class="timeline-body"><p>Sure. Give it a try. There's an <code>OperatorPrecedence</code> enum that might be useful to fix this error</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/VascoSch92">@VascoSch92</a> on 2025-02-15 10:29</div>
            <div class="timeline-body"><p>Hey,</p>
<p>I was working on this issue, and I have some questions/clarifications to ask:</p>
<p>For instance, it is possible to solve the following bugs:</p>
<ul>
<li><code>print((not 1).__add__(1))</code></li>
<li><code>try: print(list(&quot;x&quot;.__add__(y for y in &quot;y&quot;))) except TypeError as e: print(e)</code></li>
<li><code>print((&quot;a&quot; and &quot;x&quot;).__contains__(&quot;x&quot;))</code></li>
<li><code>print((&quot;&quot; or &quot;x&quot;).__contains__(&quot;x&quot;))</code></li>
<li><code>print((&quot;&quot; if False else &quot;x&quot;).__contains__(&quot;x&quot;))</code></li>
<li><code>print((x := &quot;x&quot;).__contains__(&quot;y&quot;))</code></li>
<li><code>print((not 0).__radd__(1))</code></li>
</ul>
<p>But I have problems for the following:</p>
<ol>
<li><code>print(3 - (2).__add__(1))</code>: the problem here is that Ruff needs to know not just the <code>value</code> and the <code>arg</code> of <code>__add__</code> but also what come before the call. In this case, the error happens because there is a <code>-</code>. Is it something which is possible to control?</li>
<li><code>print((not &quot;x&quot;).__contains__(&quot;y&quot;))</code>: here we are asking if a boolean contains a string. This thrown a Python error as the booleans don't implement the method <code>__contains__</code>.  So Ruff is trying to fix something which is already broken. Should Ruff understand that or we should assume that the python syntax/code is correct before launching Ruff?</li>
<li><code>print(type((lambda: 0).__eq__(&quot;x&quot;)))</code>: the function <code>lambda: 0</code> is an instance of <code>function</code>, which does not define a custom <code>__eq__</code> method. It inherits the default <code>__eq__</code> from object, which returns <code>NotImplemented</code> when the comparison is unsupported. Now, I don't know how to solve it to have the same output.</li>
</ol>
<p>Should I open a PR to start discussing the solutions for the above mentioned solved bugs?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-17 09:39</div>
            <div class="timeline-body"><ol>
<li>I'd have to look at the implementation and I'm not sure what you mean by control but this is something we'd have to support. I assume the problem you're running into is that the rule runs on call expressions. So you don't have access to the parent from the node but you can use <code>checker.semantic().current_expression_parent()</code> to get the parent of the current expression</li>
<li>Ideally yes, but I think it's fine if the provided fix doesn't break the code in new ways. Ideally, it would still emit the same runtime error after applying the fix</li>
<li>This seems to be the same as 2.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/16216.html">astral-sh/ruff#16216</a> on 2025-02-17 16:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/VascoSch92">@VascoSch92</a> on 2025-02-18 10:20</div>
            <div class="timeline-body"><ol>
<li>Thanks. I think I fixed it ;-)</li>
<li>The <code>Exception</code> are not equal/equivalent, e.g., for <code>print((not &quot;x&quot;).__contains__(&quot;y&quot;))</code> we have a <code>AttributeError: 'bool' object has no attribute '__contains__'</code>, while for the relative fix <code>print(&quot;y&quot; in (not &quot;x&quot;))</code> we have a <code>TypeError: argument of type 'bool' is not iterable</code>. Should we just flag these kind of dunder calls without providing a fix or should we also try to fix them even if the relative exceptions are different?</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/18813.html">astral-sh/ruff#18813</a> on 2025-06-20 05:49</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:15 UTC
    </footer>
</body>
</html>
