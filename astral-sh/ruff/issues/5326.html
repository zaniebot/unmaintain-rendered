<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduce `SuiteStatement` - astral-sh/ruff #5326</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Introduce <code>SuiteStatement</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/5326">#5326</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2023-06-23 06:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-06-23 06:40</div>
            <div class="timeline-body"><p>RustPython's AST structure for the following two programs is identical (the ranges differ)</p>
<pre><code class="language-python"># Program 1
if True:
    pass
elif False:
    pass


# Program 2
if True:
    pass
else:
    if False:
        pass
</code></pre>
<pre><code>If(
    StmtIf {
        range: 0..38,
        test: Constant(
            ExprConstant {
                range: 3..7,
                value: Bool(
                    true,
                ),
                kind: None,
            },
        ),
        body: [
            Pass(
                StmtPass {
                    range: 13..17,
                },
            ),
        ],
        orelse: [
            If(
                StmtIf {
                    range: 18..38,
                    test: Constant(
                        ExprConstant {
                            range: 23..28,
                            value: Bool(
                                false,
                            ),
                            kind: None,
                        },
                    ),
                    body: [
                        Pass(
                            StmtPass {
                                range: 34..38,
                            },
                        ),
                    ],
                    orelse: [],
                },
            ),
        ],
    },
),
</code></pre>
<p>This is problematic because the formatter incorrectly assumes that the nested <code>if</code> in the second program is an <code>elif</code> and collapses the nested if. This isn't something a formatter should do. This representation does make sense for an interpreter. It's actually a neat little optimisation that the parser performs.</p>
<p>The solution for this is to change <code>Suite</code> from a <code>Vec&lt;Statement&gt;</code> to its own <code>SuiteStatement</code> AST node and change the <code>orelse</code> type (and any other field that represents a body) from <code>Suite</code> to <code>Option&lt;Stmt&gt;</code>.</p>
<p>This would change the representation of the first program to:</p>
<pre><code>If(
    StmtIf {
        range: 0..38,
        test: Constant(
            ExprConstant {
                range: 3..7,
                value: Bool(
                    true,
                ),
                kind: None,
            },
        ),
        body: [
            Pass(
                StmtPass {
                    range: 13..17,
                },
            ),
        ],
        orelse: Some(If(
              StmtIf {
                  range: 18..38,
                  test: Constant(
                      ExprConstant {
                          range: 23..28,
                          value: Bool(
                              false,
                          ),
                          kind: None,
                      },
                  ),
                  body: [
                      Pass(
                          StmtPass {
                              range: 34..38,
                          },
                      ),
                  ],
                  orelse: None
              },
          ),
    }),
),
</code></pre>
<p>and of the second program:</p>
<pre><code>If(
    StmtIf {
        range: 0..38,
        test: Constant(
            ExprConstant {
                range: 3..7,
                value: Bool(
                    true,
                ),
                kind: None,
            },
        ),
        body: [
            Pass(
                StmtPass {
                    range: 13..17,
                },
            ),
        ],
        orelse: Some(SuiteStatement(SuiteStatement([
            If(
                StmtIf {
                    range: 18..38,
                    test: Constant(
                        ExprConstant {
                            range: 23..28,
                            value: Bool(
                                false,
                            ),
                            kind: None,
                        },
                    ),
                    body: [
                        Pass(
                            StmtPass {
                                range: 34..38,
                            },
                        ),
                    ],
                    orelse: None,
                },
            ),
        ])),
    },
),
</code></pre>
<p>which is unambiguous</p>
<p>This requires changes to:</p>
<ul>
<li>RustPython's parser</li>
<li>Ruff</li>
<li>The visitor implementations</li>
<li>The formatter</li>
</ul>
<h2>Alternatives</h2>
<ul>
<li>Extract the indent from the source to distinguish the two cases. That's what we currently do when extracting comments but it is so easy to get wrong. We would need to do the same in the <code>unparse</code> of the linter</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @konstin by @MichaReiser on 2023-06-23 14:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-06-23 14:40</div>
            <div class="timeline-body"><p>@konstin Sorry for the misunderstanding. I'm excited that you want to take this on!</p>
<p>These are the <code>Python.asdl</code> changes that I already made and encode the AST changes that I had in mind</p>
<pre><code class="language-patch">Index: ast/Python.asdl
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/ast/Python.asdl b/ast/Python.asdl
--- a/ast/Python.asdl	(revision caf6ebcefa80ce835aa689f392000e5cfd18f93d)
+++ b/ast/Python.asdl	(date 1687530270508)
@@ -9,16 +9,16 @@
         | FunctionType(expr* argtypes, expr returns)
 
     stmt = FunctionDef(identifier name, arguments args,
-                       stmt* body, decorator* decorator_list, expr? returns,
+                       stmt body, decorator* decorator_list, expr? returns,
                        string? type_comment)
           | AsyncFunctionDef(identifier name, arguments args,
-                             stmt* body, decorator* decorator_list, expr? returns,
+                             stmt body, decorator* decorator_list, expr? returns,
                              string? type_comment)
 
           | ClassDef(identifier name,
              expr* bases,
              keyword* keywords,
-             stmt* body,
+             stmt body,
              decorator* decorator_list)
           | Return(expr? value)
 
@@ -29,18 +29,18 @@
           | AnnAssign(expr target, expr annotation, expr? value, int simple)
 
           -- use 'orelse' because else is a keyword in target languages
-          | For(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
-          | AsyncFor(expr target, expr iter, stmt* body, stmt* orelse, string? type_comment)
-          | While(expr test, stmt* body, stmt* orelse)
-          | If(expr test, stmt* body, stmt* orelse)
-          | With(withitem* items, stmt* body, string? type_comment)
-          | AsyncWith(withitem* items, stmt* body, string? type_comment)
+          | For(expr target, expr iter, stmt body, stmt? orelse, string? type_comment)
+          | AsyncFor(expr target, expr iter, stmt body, stmt? orelse, string? type_comment)
+          | While(expr test, stmt body, stmt? orelse)
+          | If(expr test, stmt body, stmt? orelse)
+          | With(withitem* items, stmt body, string? type_comment)
+          | AsyncWith(withitem* items, stmt body, string? type_comment)
 
           | Match(expr subject, match_case* cases)
 
           | Raise(expr? exc, expr? cause)
-          | Try(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
-          | TryStar(stmt* body, excepthandler* handlers, stmt* orelse, stmt* finalbody)
+          | Try(stmt body, excepthandler* handlers, stmt? orelse, stmt? finalbody)
+          | TryStar(stmt body, excepthandler* handlers, stmt? orelse, stmt? finalbody)
           | Assert(expr test, expr? msg)
 
           | Import(alias* names)
@@ -50,6 +50,7 @@
           | Nonlocal(identifier* names)
           | Expr(expr value)
           | Pass | Break | Continue
+          | Suite(stmt* statements)
 
           -- col_offset is the byte offset in the utf8 string the parser uses
           attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
@@ -106,7 +107,7 @@
 
     comprehension = (expr target, expr iter, expr* ifs, int is_async)
 
-    excepthandler = ExceptHandler(expr? type, identifier? name, stmt* body)
+    excepthandler = ExceptHandler(expr? type, identifier? name, stmt body)
                     attributes (int lineno, int col_offset, int? end_lineno, int? end_col_offset)
 
     arguments = (arg* posonlyargs, arg* args, arg? vararg, arg* kwonlyargs,
@@ -125,7 +126,7 @@
 
     withitem = (expr context_expr, expr? optional_vars)
 
-    match_case = (pattern pattern, expr? guard, stmt* body)
+    match_case = (pattern pattern, expr? guard, stmt body)
 
     pattern = MatchValue(expr value)
             | MatchSingleton(constant value)
</code></pre>
<ul>
<li>To update the AST, run <code>./scripts/update_asdl.sh</code></li>
<li>To update the generated parser, run <code>~/.cargo/bin/lalrpop parser/src/python.lalrpop</code></li>
</ul>
<p>You may want to base your work on top of https://github.com/astral-sh/RustPython-Parser/pull/15/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-07-31 06:51</div>
            <div class="timeline-body"><p>This would be nice to have but isn't something that we need to ship the formatter. Closing for now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2023-07-31 06:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-07-31 08:55</div>
            <div class="timeline-body"><p>I'd still like to have this, but as a general not-linter-limited improvement that could remove so many <code>.unwrap()</code> in both the linter and the formatter.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-07-31 08:58</div>
            <div class="timeline-body"><blockquote>
<p>I'd still like to have this, but as a general not-linter-limited improvement that could remove so many <code>.unwrap()</code> in both the linter and the formatter.</p>
</blockquote>
<p>I'm now tracking this in https://github.com/astral-sh/ruff/discussions/6183#discussioncomment-6591993</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:30:30 UTC
    </footer>
</body>
</html>
