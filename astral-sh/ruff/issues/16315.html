<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PERF401 gives incorrect suggestions and requires suboptimal workarounds with async iterators - astral-sh/ruff #16315</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>PERF401 gives incorrect suggestions and requires suboptimal workarounds with async iterators</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/16315">#16315</a>
        opened by <a href="https://github.com/MarkusSintonen">@MarkusSintonen</a>
        on 2025-02-22 12:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/MarkusSintonen">@MarkusSintonen</a> on 2025-02-22 12:46</div>
            <div class="timeline-body"><h3>Description</h3>
<p>PERF401 triggers in a following case incorrectly and gives an incorrect suggestion. Making Ruff happy requires creating unnecessary temporary list. Which is not a great workaround.</p>
<pre><code class="language-python">from collections.abc import AsyncIterator


async def my_nested_aiter() -&gt; AsyncIterator[AsyncIterator[int]]:
    async def inner() -&gt; AsyncIterator[int]:
        yield 1

    yield inner()


async def test_ruff_issue():
    my_list: list[int] = []
    async for inner_aiter in my_nested_aiter():
        async for x in inner_aiter:
            # Fails in Ruff with. &quot;PERF401 Use `list.extend` with an async comprehension to create a transformed list&quot;
            my_list.append(x)


async def test_incorrect_ruff_suggestion():
    my_list: list[int] = []
    async for inner_aiter in my_nested_aiter():
        # TypeError: 'async_generator' object is not iterable
        my_list.extend(x async for x in inner_aiter)


async def test_bad_work_around():
    my_list: list[int] = []
    async for inner_aiter in my_nested_aiter():
        # Works but requires unnecessary temporary lists for each iteration, just to get Ruff happy
        my_list.extend([x async for x in inner_aiter])

</code></pre>
<p>version:</p>
<pre><code>% uv run ruff --version
ruff 0.9.3
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MarkusSintonen">@MarkusSintonen</a> on 2025-02-22 12:57</div>
            <div class="timeline-body"><p>Related https://github.com/astral-sh/ruff/issues/11316#issuecomment-2114185025 but the original issue describes yet another issue with the rule as list extend does not work with async iterators</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-02-22 17:43</div>
            <div class="timeline-body"><p>The intended fix is probably this:</p>
<pre><code class="language-python">my_list = [
	x
	async for inner_aiter in my_nested_aiter()
	async for x in inner_aiter
]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-02-22 17:44</div>
            <div class="timeline-body"><p>Thanks for opening the issue! I think there's a lot to consider here.</p>
<p>Just to clarify, when I run</p>
<pre><code class="language-shell">cat &lt;&lt;'EOF' | ruff check --select PERF401 -
from collections.abc import AsyncIterator


async def my_nested_aiter() -&gt; AsyncIterator[AsyncIterator[int]]:
    async def inner() -&gt; AsyncIterator[int]:
        yield 1

    yield inner()


async def test_ruff_issue():
    my_list: list[int] = []
    async for inner_aiter in my_nested_aiter():
        async for x in inner_aiter:
            # Fails in Ruff with. &quot;PERF401 Use `list.extend` with an async comprehension to create a transformed list&quot;
            my_list.append(x)
EOF
</code></pre>
<p>I get the output</p>
<pre><code>-:16:13: PERF401 Use `list.extend` with an async comprehension to create a transformed list
   |
14 |         async for x in inner_aiter:
15 |             # Fails in Ruff with. &quot;PERF401 Use `list.extend` with an async comprehension to create a transformed list&quot;
16 |             my_list.append(x)
   |             ^^^^^^^^^^^^^^^^^ PERF401
   |
   = help: Replace for loop with list.extend

Found 1 error.
</code></pre>
<p>which I would agree could be a bit misleading.</p>
<p>If I add the <code>--preview</code> flag, this enables an unsafe fix for the rule, which I can then enable with<code>--unsafe-fixes</code> (I also throw in <code>--diff</code> to avoid changing any files):</p>
<pre><code class="language-shell">ruff check --select PERF401 --preview --unsafe-fixes --diff
</code></pre>
<p>This produces the diff:</p>
<pre><code class="language-diff">@@ -11,6 +11,5 @@
 async def test_ruff_issue():
     my_list: list[int] = []
     async for inner_aiter in my_nested_aiter():
-        async for x in inner_aiter:
-            # Fails in Ruff with. &quot;PERF401 Use `list.extend` with an async comprehension to create a transformed list&quot;
-            my_list.append(x)
+        # Fails in Ruff with. &quot;PERF401 Use `list.extend` with an async comprehension to create a transformed list&quot;
+        my_list.extend([x async for x in inner_aiter])

Would fix 1 error.
</code></pre>
<p>So I think ruff is actually giving a correct suggestion here, at least in the sense that the code still works. However, I agree that the help message, combined with the non-async <code>list.extend</code> example in the rule documentation, could easily lead you to the <code>list.extend(x async ...)</code> solution.</p>
<p>I also assume, like you and others in the linked issue, that creating a temporary list just to use <code>extend</code> is probably a net negative, so I'm a bit skeptical that this should apply to <code>async</code> iterators at all, at least in the <code>extend</code> case.</p>
<p>Finally, in this <em>specific</em> case, but possibly not in related real-world examples, a better fix would possibly be a nested list comprehension like this:</p>
<pre><code class="language-python">async def test_ruff_issue():
    return [x async for inner_aiter in my_nested_aiter() async for x in inner_aiter]
</code></pre>
<p>I think that would be pretty hard to detect and suggest in the rule, though.</p>
<p>In summary, I think we should do some combination of (1) update the rule documentation with an <code>async</code> example including the caveats with <code>extend</code>, (2) update the help message, possibly with the suggested fix, (3) avoid applying the rule to <code>async</code> iterators when <code>extend</code> is needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">documentation</span> added by @ntBre on 2025-02-22 17:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @ntBre on 2025-02-22 17:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MarkusSintonen">@MarkusSintonen</a> on 2025-02-22 18:18</div>
            <div class="timeline-body"><blockquote>
<p>The intended fix is probably this:</p>
<p>my_list = [
x
async for inner_aiter in my_nested_aiter()
async for x in inner_aiter
]</p>
</blockquote>
<p>I dont see how this would be any better. The nested comprehensions can get really spaghetti. The example I gave is also a very basic example. Also this suggestion has nothing to do with &quot;PERF&quot; rules performance-aspects.</p>
<blockquote>
<p>So I think ruff is actually giving a correct suggestion here</p>
</blockquote>
<p>Yes it is correct but is it really performant as the &quot;PERF&quot; rules try to do, I would bet it is not. So the usage of temporary lists is really not a great workaround and is not inline with &quot;PERF&quot; rules. As it is not performance net positive.</p>
<blockquote>
<p>I also assume, like you and others in the linked issue, that creating a temporary list just to use extend is probably a net negative, so I'm a bit skeptical that this should apply to async iterators at all, at least in the extend case.</p>
</blockquote>
<p>I would say the PERF401 should not be applied to async iterators at all whenever it tries to suggest usage of <code>list.extend</code>. Python just does not support <code>extend</code> with async iterators. Rule is not applicable in the first place here. None of the suggestions are performance related (ugly nested comprehensions), or performance net positive (temp lists).</p>
<p>Otherwise the rule is great so would not want to disable it. But too bad it can break so badly with async iters.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Tishka17">@Tishka17</a> on 2025-11-10 18:35</div>
            <div class="timeline-body"><p>It is not also not optimal for normal generators:</p>
<pre><code class="language-python">def foo():
    a = []
    for x in range(100):
        if x % 2 == 0:
            a.append(x)
def bar():
    a = []
    a.extend(
        x for x in range(100) if x % 2 == 0
    )

n= 1000000
print(timeit.timeit(&quot;foo()&quot;, globals=globals(), number=n))
print(timeit.timeit(&quot;bar()&quot;, globals=globals(), number=n))
</code></pre>
<p>output:
1.9236854760092683
2.2944130940013565</p>
<p>I see the same on python 3.12 and python 3.14
generators are slower than normal for loop</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:36:43 UTC
    </footer>
</body>
</html>
