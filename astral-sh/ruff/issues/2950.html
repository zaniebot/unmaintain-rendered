<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RET504 false-positive when variable built up with assignments and returned - astral-sh/ruff #2950</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>RET504 false-positive when variable built up with assignments and returned</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/2950">#2950</a>
        opened by <a href="https://github.com/gdub">@gdub</a>
        on 2023-02-16 06:07
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/gdub">@gdub</a> on 2023-02-16 06:07</div>
            <div class="timeline-body"><p>Example:</p>
<pre><code class="language-python">def get_options(option1, option2):
    options = []
    if option1:
        options = options + [&quot;option1&quot;]
    if option2:
        options = options + [&quot;option2&quot;]
    return options
</code></pre>
<p>Output:</p>
<pre><code>$ ruff check --isolated --select RET ret_test.py 
ret_test2.py:16:12: RET504 Unnecessary variable assignment before `return` statement
Found 1 error.
</code></pre>
<p>In this case, there is no unnecessary variable assignment that could be removed and cannot do an earlier <code>return</code> as need to get through all the conditionals.</p>
<p>That said, the error does not trigger if one were to instead use an in-place operator such as <code>+=</code>:</p>
<pre><code class="language-python">def get_options(option1, option2):
    options = []
    if option1:
        options += [&quot;option1&quot;]
    if option2:
        options += [&quot;option2&quot;]
    return options
</code></pre>
<p>Version:</p>
<pre><code>$ ruff --version
ruff 0.0.247
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @charliermarsh on 2023-02-16 14:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-16 14:01</div>
            <div class="timeline-body"><p>Possibly not respecting overrides, does look like a bug.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-02-16 17:04</div>
            <div class="timeline-body"><p>Just noticed this too!</p>
<pre><code class="language-python">def f(y):
    x = 1
    if y:
        x = 2

    return x
</code></pre>
<pre><code class="language-console">$ ruff tmp.py --isolated --select RET
tmp.py:6:12: RET504 Unnecessary variable assignment before `return` statement
Found 1 error.
</code></pre>
<p>It seems the RET checks don't handle branches very well (the &quot;else after&quot; ones also are broken when you have a chain).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-16 17:07</div>
            <div class="timeline-body"><p>It may wants you to do this, even though it's awkward:</p>
<pre><code class="language-py">def f(y):
    if y:
        return 2

    return 1
</code></pre>
<blockquote>
<p>the &quot;else after&quot; ones also are broken when you have a chain</p>
</blockquote>
<p>Is this on <code>main</code>? I removed enforcement for <code>elif</code> chains in the most recent release.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-16 17:09</div>
            <div class="timeline-body"><p>(I find these rules really tedious lol. Maybe they should just be removed.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-02-16 17:19</div>
            <div class="timeline-body"><p>They will come back again when adding pylint rules. :) I like these in pylint a lot, which I is why I'm happy to see them showing up in a faster pre-commit friendly form, but the pylint version is solid and doesn't trigger falsely, while RET seems to not properly handle branching (I expect it's a problem with the flake8 plugin).</p>
<blockquote>
<p>It may wants you to do this, even though it's awkward</p>
</blockquote>
<p>It's not practical in the actual code that caused me to look into this. The fix should be to just only enforce <code>x = value; return value</code> and not if the assignment is in an if statement (with statement is 90% of the time fine, just not if statements)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-02-16 17:20</div>
            <div class="timeline-body"><p>I haven't rerun with the most recent release yet for the RET 507 and similar rules, quite possibly fixed!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-16 17:22</div>
            <div class="timeline-body"><p>Ah yeah, I mostly meant that I have issues with the implementation. It's a direct port of the flake8 plugin, and it just has a bunch of limitations (in addition to being hard to reason about).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-02-16 17:36</div>
            <div class="timeline-body"><p>Ahh, I see what you mean.</p>
<pre><code class="language-python">def f(y):
    x = 1
    if y:
        return 2

    return x
</code></pre>
<p>Would pass. I could live with that in some/most cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-16 17:38</div>
            <div class="timeline-body"><p>I think it will still complain about <code>x=1</code> :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-02-16 18:04</div>
            <div class="timeline-body"><p>In a realistic example (where other things are happening to the x before the final if), it seems pretty happy. I didn't end up with any false positives that I couldn't handle knowing that it was fine just changing the assignment in the if to a return. There were several when converting Plumbum and https://github.com/scikit-hep/particle/pull/472/commits/10caa90bb139f6b754bdad1ba577c832e4e3b465 was the one that prompted me to search for this issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/martinlehoux">@martinlehoux</a> on 2023-03-04 13:18</div>
            <div class="timeline-body"><p>Just to add one more (almost) real life example: I have this pattern that seems reasonable in Django to build a queryset based on different inputs</p>
<pre><code class="language-py">def get_queryset(option_1, option_2):
    queryset: Any = None

    queryset = queryset.filter(a=1)

    if option_1:
        queryset = queryset.annotate(b=Value(2))

    if option_2:
        queryset = queryset.filter(c=3)

    return queryset
</code></pre>
<blockquote>
<p><code>main.py:15:12: RET504 Unnecessary variable assignment before return statement</code></p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-03-04 14:24</div>
            <div class="timeline-body"><p>This would be how you’d make it happy:</p>
<pre><code class="language-python">
def get_queryset(option_1, option_2):
    queryset: Any = None

    queryset = queryset.filter(a=1)

    if option_1:
        queryset = queryset.filter(b=2)

    if option_2:
        return queryset.filter(c=3)

    return queryset
</code></pre>
<p>Not quite as symmetric, but not really “worse” from a readers standpoint either. I’d probably disable the check if this was a lot of very symmetric conditions (like you have described), though in practice most of them are not that symmetric and are fine written with the extra return. Overriding a variable is a bit ugly, so avoiding an unnecessary one isn’t that bad.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gdub">@gdub</a> on 2023-03-06 17:13</div>
            <div class="timeline-body"><p>Personally, I dislike the resulting work-around because:</p>
<ul>
<li>The lack of symmetry feels unnatural.</li>
<li>If you need to add an additional condition block, you would have churn turning the return statement back to an assignment.</li>
<li>It does not save any lines, as is the case for simple assignment then return.</li>
</ul>
<p>One idea would be to only flag the single-assignment and return scenarios, e.g.:</p>
<pre><code class="language-python">def get_queryset():
    queryset = Model.filter(a=1)
    return queryset
</code></pre>
<p>...and not flag scenarios where there are <em>multiple</em> assignments to the same variable before returning, e.g.:</p>
<pre><code class="language-python">def get_queryset(option_1, option_2):
    queryset = Model.filter(a=1)
    if option_1:
        queryset = queryset.filter(b=2)
    if option_2:
        queryset = queryset.filter(c=3)
    return queryset
</code></pre>
<p>Though, I guess that would also mean that something like this would pass not get flagged:</p>
<pre><code class="language-python">def get_queryset():
    queryset = Model.filter(a=1)
    queryset = queryset.filter(c=3)
    return queryset
</code></pre>
<p>Which raises the question of what is it that this rule is really meant to be targeting? Cases where would save a line of code due to an unnecessary assignment? Should check be simplified to only look for the simple assign/return case that happens at the same nesting level, and ignore if there is more complex branching/looping involved?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Czaki">@Czaki</a> on 2023-03-06 17:21</div>
            <div class="timeline-body"><blockquote>
<p>Though, I guess that would also mean that something like this would pass not get flagged:</p>
</blockquote>
<p>If the rule should only be ignored if the assignment is under <code>if</code> clause.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bellini666">@bellini666</a> on 2023-03-06 17:24</div>
            <div class="timeline-body"><p>I agree with @gdub . In cases similar to the one mentioned by him, I usually do <code># noqa: RET504</code>, but it would be very good if that kind of usage got exempted from the rule.</p>
<p>Don't know if it is simple for ruff to detect it though =P</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-06 17:50</div>
            <div class="timeline-body"><p>The multiple assignments heuristic seems like it could work... pretty well? In my <em>personal</em> opinion I actually prefer this to inlining <code>return queryset.filter(c=3)</code>:</p>
<pre><code class="language-py">def get_queryset():
    queryset = Model.filter(a=1)
    queryset = queryset.filter(c=3)
    return queryset
</code></pre>
<p>It also has the nice property that if you add another operation to the fluent chain, the diff much clearer. But, it's all a bit subjective of course.</p>
<p>I think the intent of the rule is to capture &quot;trivial&quot; errors like:</p>
<pre><code class="language-py">x = 1
return x
</code></pre>
<p>Or:</p>
<pre><code class="language-py">x = 1
print(&quot;Got 1&quot;)
return x
</code></pre>
<p>Part of me is like... is this even a rule worth having? I wish I had data on how many people are using it and how often it's <code># noqa</code>'d or ignored, etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/NeilGirdhar">@NeilGirdhar</a> on 2023-03-06 18:08</div>
            <div class="timeline-body"><blockquote>
<p>I wish I had data on how many people are using it and how often it's <code># noqa</code>'d or ignored, etc.</p>
</blockquote>
<p>Can you run Ruff on a corpus of projects and gather rule hit counts and a random sampling of examples?  MyPy does something like that with its MyPy Primer, which they use to evaluate pull requests.  It might be nice to see how various changes make rules more or less sensitive, and examples of lines that would be newly flagged, and also examples of lines would no longer be flagged.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-06 18:09</div>
            <div class="timeline-body"><p>I'd like to do something like <a href="https://github.com/rust-lang/rust-clippy/issues/7666">this</a>: index projects using Ruff, and get some data on their configurations (<em>and</em> on how often they <code>noqa</code> various rules).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gdub">@gdub</a> on 2023-03-06 18:38</div>
            <div class="timeline-body"><p>Interesting looking through some results from:
https://github.com/search?q=noqa%3A+RET504&amp;type=code
https://github.com/search?q=RET504&amp;type=Code</p>
<p>Shows up in some ignores with comments, e.g.:</p>
<pre><code># RET504: Unnecessary variable before return (ugly)
</code></pre>
<pre><code>    # suppress what appears to be false-positives with these checks
    'RET504',
    'RET505',
    'RET506',
    'RET507',
    'RET508',
</code></pre>
<p>See many examples with similar chaining-style assignment with conditionals that we've touched on already.</p>
<p>Here's an interesting case where variable is assigned to, referenced, and then returned:
https://github.com/KyleKing/pytest_cache_assert/blob/47d0b538528a9c9cdbc182d2b276462a2aa0fd4d/tests/test_flask.py#L20</p>
<pre><code class="language-python">def _create_app() -&gt; Flask:
    app = Flask(__name__)

    @app.route('/hello')
    def hello() -&gt; str:
        &quot;&quot;&quot;Hello endpoint.&quot;&quot;&quot;
        return 'Hello, World!'

    return app  # noqa: RET504
</code></pre>
<p>Seems like something that shouldn't be flagged.</p>
<p>Perhaps instead of an assignment count, heuristic could be reference count. In other words, excluding return statement, flag if the only reference was assignment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-08 00:26</div>
            <div class="timeline-body"><p>This PR productionizes that suggestion (avoid RET504 for variables with multiple assignments): https://github.com/charliermarsh/ruff/pull/3393.</p>
<p>Feedback welcome, I won't be merging tonight.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-08 00:32</div>
            <div class="timeline-body"><p>(Fixed the decorator thing in #3395, separate bug!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-08 23:18</div>
            <div class="timeline-body"><p>Ok, I looked through the GitHub Code Search, and I do see a lot of examples of this kind of &quot;fluent interface&quot;-like assignment style, e.g.:</p>
<pre><code class="language-py">command = self.extract_command(text)
self.validate_prefix(command=command)
await self.validate_mention(bot=bot, command=command)
command = self.validate_command(command)
command = self.do_magic(command=command)
return command  # noqa: RET504
</code></pre>
<p>This strikes me as very reasonable code, so I'm gonna go ahead and merge that PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-03-09 00:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2023-03-09 19:50</div>
            <div class="timeline-body"><p>Personally, like moving the return up one, reducing the number of variable overwrites there (and that sort of code isn't very good for static typing unless every command returns the same thing!)</p>
<p>I don't see any problem with:</p>
<pre><code class="language-python">command = self.extract_command(text)
self.validate_prefix(command=command)
await self.validate_mention(bot=bot, command=command)
command = self.validate_command(command)
return self.do_magic(command=command)
</code></pre>
<p>In fact, there's only <em>one</em> overwrite now, so I'd actually do:</p>
<pre><code class="language-python">command = self.extract_command(text)
self.validate_prefix(command=command)
await self.validate_mention(bot=bot, command=command)
validated_command = self.validate_command(command)
return self.do_magic(command=validated_command)
</code></pre>
<p>IMO, this now reads much better. The point of style checks is to force better style, not to try not to bother anyone or conform to what everyone is doing if it's wrong. I think the biggest problem with this check was that it wasn't clear how to &quot;fix&quot; it from the message (and also some false positives, like the function false positive above). And it's totally fine to disable a style check you don't agree with! Whenever I talk about style checking, I emphasize this (especially WRT PyLint).</p>
<p>Also, one of the points of this sort of check is to help two people writing the same logic get the same code. Returning without assigning is perfectly valid, so it's reasonable to force this rather than force an assignment always before return.</p>
<p>For example, I think this would have read much better without an extra assignment: https://github.com/scikit-build/scikit-build-core/pull/197/files#diff-5a9598893dbb4007601522cfb26b27c92d790c18bf35d7bfe86205ae1955fa0bR47-R48</p>
<p>I'm not sure why Ruff didn't find that, as I'd guess #3393 wasn't in the version of Ruff that ran on that, but I wish it did.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:29:23 UTC
    </footer>
</body>
</html>
