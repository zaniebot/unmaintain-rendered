<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>rollback tweak to empty spans generated by some lints - astral-sh/ruff #15509</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>rollback tweak to empty spans generated by some lints</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/15509">#15509</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2025-01-15 16:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-15 16:50</div>
            <div class="timeline-body"><p>In #15359, in order to upgrade to the latest version of <code>annotate-snippets</code>, we ended up tweaking the spans generated by some lints. The essential problem is described in an upstream issue: https://github.com/rust-lang/annotate-snippets-rs/issues/176</p>
<p>To work around this, instead of generating an empty span immediately after a line terminator, we instead generate a span that is one character wide immediately after a line terminator. The former would point to the end of the preceding line, but the latter points to the beginning of the following line (which is what we want).</p>
<p>#15359 did this in the following places:</p>
<ul>
<li><code>crates/ruff_linter/src/checkers/logical_lines.rs</code></li>
<li><code>crates/ruff_linter/src/rules/pydocstyle/rules/indent.rs</code></li>
</ul>
<p>Then look for uses of <code>ceil_char_boundary</code>, which was a new method added to <code>Locator</code> to facilitate the creation of these ranges.</p>
<p>I think ideally, we would fix <code>annotate-snippets</code> to render empty spans after a line terminator to point to the beginning of the following line. I did attempt to do this in our vendored copy of <code>annotate-snippets</code>, but any change I tried ended up regressing a bunch of other cases. So I think in order to fix this for real, more investment will be needed to better understand how <code>annotate-snippets</code>'s renderer works.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @BurntSushi on 2025-01-15 16:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @MichaReiser on 2025-01-15 16:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">diagnostics</span> added by @MichaReiser on 2025-01-15 16:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-15 16:55</div>
            <div class="timeline-body"><p>Copying my comment from the PR to add some context why I think this is a bug</p>
<hr />

<p>Okay, somewhat &quot;bad&quot; news. The new diagnostic ranges do regress the LSP experience. It's not in a significant way that I think is worth blocking this PR but it is reason enough that we should change annotation-snippet to support empty ranges pointing at the start of a line. This isn't something we have to follow up on immediately but I consider it &quot;serious&quot; enough that it's something we should act on in the coming months.</p>
<p>I tested it with <code>E115</code> using</p>
<pre><code class="language-py">if False:  
print()
</code></pre>
<p><strong>Before</strong></p>
<p>The quick fix was only shown when the cursor is at the start of the line:</p>
<pre><code class="language-text">if False:  
print()
^-- cursor has to be here
</code></pre>
<p><strong>Now</strong></p>
<p>The quick fix is now shown if the cursor is at the start of the line or between <code>p</code> and <code>r</code>. This is incorrect because the action doesn't make sense at that position:</p>
<pre><code class="language-text">if False:  
print()
^ ---- cursor can be here
 ^ ----- or here
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/15510.html">astral-sh/ruff#15510</a> on 2025-01-15 16:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15359.html">astral-sh/ruff#15359</a> on 2025-01-15 16:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-15 17:01</div>
            <div class="timeline-body"><p>@MichaReiser Hah you beat me to it. I was just going to copy that here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-15 18:08</div>
            <div class="timeline-body"><p>Note that I moved the span fixup to be right before rendering and it applies to all diagnostics:</p>
<pre><code class="language-rust">impl&lt;'a&gt; SourceCode&lt;'a&gt; {
    /// This attempts to &quot;fix up&quot; the span on `SourceCode` in the case where
    /// it's an empty span immediately following a line terminator.
    ///
    /// At present, `annotate-snippets` (both upstream and our vendored copy)
    /// will render annotations of such spans to point to the space immediately
    /// following the previous line. But ideally, this should point to the space
    /// immediately preceding the next line.
    ///
    /// After attempting to fix `annotate-snippets` and giving up after a couple
    /// hours, this routine takes a different tact: it adjusts the span to be
    /// non-empty and it will cover the first codepoint of the following line.
    /// This forces `annotate-snippets` to point to the right place.
    ///
    /// See also: https://github.com/astral-sh/ruff/issues/15509
    fn fix_up_empty_spans_after_line_terminator(self) -&gt; SourceCode&lt;'a&gt; {
        if !self.annotation_range.is_empty()
            || self.annotation_range.start() == TextSize::from(0)
            || self.annotation_range.start() &gt;= self.text.text_len()
        {
            return self;
        }
        if self.text.as_bytes()[self.annotation_range.start().to_usize() - 1] != b'\n' {
            return self;
        }
        let locator = Locator::new(&amp;self.text);
        let start = self.annotation_range.start();
        let end = locator.ceil_char_boundary(start + TextSize::from(1));
        SourceCode {
            annotation_range: TextRange::new(start, end),
            ..self
        }
    }
}
</code></pre>
<p>This doesn't help with the regression in the Python parser diagnostic, but this might help with the LSP regression since we no longer change the spans in the lint, but only right before rendering.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-01-15 19:02</div>
            <div class="timeline-body"><p>Given that the LSP regression is fixed and this is fixed at the level of rendering (which is right before the call out to <code>annotate-snippets</code>), I think it's safe to call this issue fixed. I think it would be nice to not need to fix up the spans by fixing this properly in <code>annotate-snippets</code>, but the current approach shouldn't have any user visible downsides.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2025-01-15 19:02</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:15 UTC
    </footer>
</body>
</html>
