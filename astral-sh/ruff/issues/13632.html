<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] more precise types from chained boolean expressions - astral-sh/ruff #13632</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] more precise types from chained boolean expressions</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/13632">#13632</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-10-04 17:20
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>We currently don't eliminate some impossible types in chained boolean or comparison expressions.</p>
<pre><code class="language-py">from typing import Literal
class A: ...
def f(x: Literal[0, 1]):
    # Currently we reveal `Literal[0, 1] | A` in each of these cases, but we should reveal what's shown below:
    reveal_type(x or A())  # revealed: Literal[1] | A
    reveal_type(x and A())  # revealed: Literal[0] | A
</code></pre>
<p>This one is an existing test in <code>comparison/non_bool_returns.md</code>:</p>
<pre><code class="language-py">from __future__ import annotations

class A:
    def __lt__(self, other) -&gt; A: ...

y = 0 &lt; 1 &lt; A() &lt; 3
# Currently we reveal `bool | A` here, but it's not possible that we'd ever get `True` here, so it should be `Literal[False] | A`
reveal_type(y)  # revealed: Literal[False] | A
</code></pre>
<p>Both of these can be fixed by adding negative intersections with <code>Type::AlwaysTruthy</code> or <code>Type::AlwaysFalsy</code> in the appropriate cases in <code>TypeInferenceBuilder::infer_chained_boolean_types</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-10-04 17:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Slyces">@Slyces</a> on 2024-10-04 19:19</div>
            <div class="timeline-body"><p>If I understand correctly</p>
<ul>
<li>We have 2 new variants <code>Type::Truthy</code> and <code>Type::Falsy</code></li>
<li>They only make sense in intersections (?)<ul>
<li><code>A &amp; Truthy</code> -&gt; subset of instances of A that evaluate to True</li>
<li><code>A &amp; Falsy</code> -&gt; subset of instances of A that evaluate to False (<code>0</code> for int/float, <code>&quot;&quot;</code> for str, ...)</li>
</ul>
</li>
</ul>
<p>I have some questions:</p>
<ul>
<li>Would those new variants make sense outside of intersections?</li>
<li>Would we display those variants? I think I see the use - we understand that it's not &quot;any&quot; <code>A</code> - but would this ever make it to the end user?<ul>
<li>If we answer no (it's purely internal to have more precise information) how do we ensure this doesn't leak?</li>
</ul>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-04 19:47</div>
            <div class="timeline-body"><p>Those are great questions!</p>
<p>Any type &quot;makes sense&quot; independently as long as we can describe it as some set of possible runtime values. So these types can stand alone, in principle: <code>Type::Falsy</code> is the set of all objects whose <code>__bool__</code> method (always) returns <code>False</code>, and vice versa for <code>Type::Truthy</code>.</p>
<p>In practice, I expect that we would only create these types in intersections, wherever we are able to determine that a type must be truthy or falsy.</p>
<p>If we introduce this type, we accept (at least for now) the fact that it may leak to users, since we won't be able to simplify it in all cases. We will often have this tradeoff, where we can more fully represent our type knowledge, at the cost of displaying more complex types to users. In general, I would prefer to represent the most precise type knowledge we can be confident of, and then find ways to simplify the user type display if that proves to be necessary. For instance, we could later implement logic in the display code for intersections to just hide these types in the output, if we end up feeling that it becomes too noisy otherwise. My hope, though, is that users will find these types reasonably intuitive, and will appreciate more precise typing.</p>
<p>One thing to note here is that currently (since we've so far only implemented support for one form of narrowing, <code>is not None</code>), intersections don't occur often; implementing this issue will add another case where intersections appear, and may require adding support for intersections in more places in order to get useful test results.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Slyces">@Slyces</a> on 2024-10-05 20:29</div>
            <div class="timeline-body"><p>So, I started working on this. I have the following question: when expressing <code>X</code> is <code>Truthy</code>, do we go through the <code>positive</code> or the <code>negative</code> part of intersection?</p>
<p>Let's take the following example:</p>
<pre><code class="language-python">def f(x: int):
    if x:
        ...  # here, `x` is `Truthy` or `x` is not `Falsy`
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-05 20:47</div>
            <div class="timeline-body"><p>Related to @Slyces's question here... do we need a <code>Truthy</code> variant <em>and</em> a <code>Falsey</code> variant, given that we support negative intersections? Since the set of all possible truthy objects is disjoint with the set of all possible falsey objects, <code>str &amp; Falsey</code> is surely the same as <code>str &amp; ~Truthy</code> (and both will simplify to <code>Literal[&quot;&quot;]</code>, I suppose!) So can we make do with just a <code>Type::Truthy</code> variant?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-07 14:49</div>
            <div class="timeline-body"><p>I think we could probably get away with only the <code>Truthy</code> variant, but I suspect it may work out better (and more efficiently) in the implementation, and be clearer in displayed types, if we have both <code>Truthy</code> and <code>Falsy</code> variants, and only use the positive side of the intersection. That is, if we try to add <code>~Truthy</code> to an intersection, that turns into adding <code>Falsy</code> instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-25 17:59</div>
            <div class="timeline-body"><p>I wrote up some thoughts relevant to this issue over at https://github.com/astral-sh/ruff/issues/13694#issuecomment-2438438759</p>
<p>It's a bit of an essay, but the summary is that after looking at the PR on this issue, and considering the issue more, I no longer think that it's a good idea to have a type like <code>Truthy</code> as a <code>Type</code> variant, I think we'll want to do something more localized to <code>IntersectionBuilder</code> to represent these cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @carljm on 2024-12-17 16:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-17 16:40</div>
            <div class="timeline-body"><p>With the merge of #14687, this task should now be pretty trivial. We now have <code>AlwaysFalsy</code> and <code>AlwaysTruthy</code> types, we just need to add negative intersections with them in the chained boolean expressions code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-12-22 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-12-22 18:02</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:51:12 UTC
    </footer>
</body>
</html>
