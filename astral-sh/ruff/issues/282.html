<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support pattern matching - astral-sh/ruff #282</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support pattern matching</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/282">#282</a>
        opened by <a href="https://github.com/sobolevn">@sobolevn</a>
        on 2022-09-29 09:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sobolevn">@sobolevn</a></div>
            <div class="timeline-body"><p>As I am learning the source code, it seems to me that python&#x27;s pattern matching is not supported at all.</p>
<p>We have a visitor ready: https://github.com/charliermarsh/ruff/blob/c7349b69c12b7511d48fc45390eac8d7282062a5/src/ast/visitor.rs#L527-L571</p>
<p>But, that&#x27;s about it.</p>
<p>Things to support (feel free to update):</p>
<ul>
<li>[ ] Unused variables check</li>
<li>[ ] Variable names check (<code>MatchAs</code> pattern)</li>
<li>[ ] Custom rules, like do not match <code>float</code>s</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2022-09-29 19:24</div>
            <div class="timeline-body"><p>Yeah it makes some appearances in the RustPython AST but it doesn&#x27;t seem to be supported yet by the actual parser.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woodruffw">@woodruffw</a> on 2023-01-10 04:13</div>
            <div class="timeline-body"><p>The parser in question is <code>rustpython-parser</code>, correct? No promises, but I can take a look at its current state and see whether I can contribute support for the <code>match</code> syntax.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woodruffw">@woodruffw</a> on 2023-01-10 04:19</div>
            <div class="timeline-body"><p>Oh, looks like someone beat me to it :slightly_smiling_face: <a href="https://github.com/RustPython/RustPython/pull/4323">RustPython/RustPython#4323</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-10 04:23</div>
            <div class="timeline-body"><p>Yeah that&#x27;s the one! There&#x27;s been a little bit of progress in that PR. There&#x27;s also someone who&#x27;s been looking to migrate the entire parser to <code>rust-peg</code> (<a href="https://github.com/RustPython/RustPython/pull/4423">RustPython/RustPython#4423</a>) which would be a much bigger change. Then @andersk had augmented the parser to support parenthesized context managers (<a href="https://github.com/RustPython/RustPython/pull/4352">RustPython/RustPython#4352</a>) and had mentioned perhaps looking into match statements next.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-14 15:16</div>
            <div class="timeline-body"><p>I&#x27;d love to sponsor someone (financially, that is) to work on this issue (in RustPython). If you&#x27;re interested, shoot me a DM on <a href="https://twitter.com/charliermarsh">Twitter</a> or email me at charlie.r.marsh@gmail.com :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jad-haddad">@jad-haddad</a> on 2023-01-31 10:35</div>
            <div class="timeline-body"><p>Actually when there is a <code>match</code> expression in a python module, ruff fails silently?
I spent an hour debugging why ruff isn&#x27;t sorting my imports even though the iSort rules are enabled, when I commented out the match expression ruff was able to sort again, is that expected?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-31 12:25</div>
            <div class="timeline-body"><p>@JadHADDAD92 - So sorry that you lost time to this. It <em>is</em> the expected behavior, because syntax errors have their own error code (<code>E999</code>). So if you don&#x27;t have that code enabled (e.g., if you do <code>ruff foo --select I</code>), you won&#x27;t see those errors at all. It&#x27;s consistent with how Ruff works, but I agree it&#x27;s confusing. (Flake8 does have the same behavior.)</p>
<p>A few alternatives:</p>
<ol>
<li>Always log an error (separate from a lint violation) if we fail to parse a file. It&#x27;s hard to imagine this being unhelpful ever.</li>
<li>Always include <code>E999</code> even if it&#x27;s not explicitly enabled. This is tricky and complicates the rule-selection semantics.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jad-haddad">@jad-haddad</a> on 2023-01-31 12:45</div>
            <div class="timeline-body"><p>I find the first alternative to be the better behavior, because I presume all ruff rules depend on a successful parse of RustPython (right?) therefore if we lint a module which contains a syntax error (failed to parse), and ruff returns 0 as if the file is well linted, it brings no clarity of what happened.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-31 12:54</div>
            <div class="timeline-body"><p>Not all rules depend on a successful parse. Some can work off the token stream, or even partial stream. Some rules only look at raw lines (like the line-length violations). And some work off the filesystem (e.g., the rule to detect missing <code>__init__.py</code> files). The majority do, but some rules can complete without one.</p>
<p>We could: always log an <code>error</code> message if a file fails to parse + exit 1.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jad-haddad">@jad-haddad</a> on 2023-02-02 09:36</div>
            <div class="timeline-body"><p>@charliermarsh is there an issue for this (logging an error when failing to parse) that I can subscribe to?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-02 13:01</div>
            <div class="timeline-body"><p>@JadHADDAD92 - No but thank you for the reminder -- I just created #2473, hopefully I can knock it out today.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ofek">@ofek</a> on 2023-02-11 17:28</div>
            <div class="timeline-body"><p>What direction are we going in order to support this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-18 04:23</div>
            <div class="timeline-body"><p>I&#x27;m working on it here: <a href="https://github.com/RustPython/RustPython/pull/4519">RustPython/RustPython#4519</a>. There are a few problems to solve but that implementation already supports many of the variants.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-19 20:22</div>
            <div class="timeline-body"><p>I&#x27;m making good progress on this (I think?). If anyone wants to link to an OSS codebase that makes good use of match statements (for testing), it&#x27;d be appreciated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/phillipuniverse">@phillipuniverse</a> on 2023-02-19 21:34</div>
            <div class="timeline-body"><p>@charliermarsh there are good match examples in the 2nd edition Fluent Python book. <a href="https://github.com/fluentpython/example-code-2e/blob/28d6d033156831a77b700064997c05a40a83805f/18-with-match/lispy/py3.10/lis.py#L145">This snippet</a> looks like it would catch some edge cases. In fact, if you <a href="https://github.com/fluentpython/example-code-2e/search?q=match&amp;type=">search in that repo for the word “match”</a> you’ll get examples of that word being used as a keyword as well as a normal variable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/SRv6d">@SRv6d</a> on 2023-02-19 21:36</div>
            <div class="timeline-body"><p>Pyright has some good examples.
https://github.com/microsoft/pyright/blob/main/packages/pyright-internal/src/tests/samples/match1.py for example or any other <code>match*.py</code> file in that directory.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ofek">@ofek</a> on 2023-02-19 22:05</div>
            <div class="timeline-body"><p>Also test <code>if match := re.search(...):</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henribru">@henribru</a> on 2023-02-19 22:12</div>
            <div class="timeline-body"><p>Python&#x27;s own test suite for pattern matching seems like a good litmus test: https://github.com/python/cpython/blob/main/Lib/test/test_patma.py</p>
<p>https://github.com/brandtbucher/patmaperformance also has some examples.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-19 23:26</div>
            <div class="timeline-body"><p>Parser looking good so far. I got it to parse Black&#x27;s fixtures which cover a lot of tricky cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-19 23:27</div>
            <div class="timeline-body"><p>(It also handles soft keywords as pointed out by @ofek. I&#x27;ve also run it over Hatch, Airflow, and Pandas, and confirmed that the output is unchanged, so it&#x27;s not incorrectly detecting any <code>match</code> statements from e.g. variable assignments.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-19 23:28</div>
            <div class="timeline-body"><p>(Oh, I guess the Black test suite is a subet of <code>test_patma.py</code> :))</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-20 04:07</div>
            <div class="timeline-body"><p>I expect this to go out some time this week, hopefully in the next few days. The PR is up as #3047 (plus depends on <a href="https://github.com/RustPython/RustPython/pull/4519">RustPython/RustPython#4519</a> in RustPython).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-21 18:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danstewart">@danstewart</a> on 2023-02-22 11:11</div>
            <div class="timeline-body"><p>Thank you!</p>
<p>Heads up for anyone else using the VS code extension you will need to set your ruff path:</p>
<pre><code>&quot;ruff.path&quot;: [&quot;./.venv/bin/ruff&quot;]
</code></pre>
<p>Looks like the extension has it&#x27;s own ruff executable, which <a href="https://github.com/charliermarsh/ruff-vscode/pull/137">has already been updated</a> to use the latest ruff but hasn&#x27;t been released yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mikeroll">@mikeroll</a> on 2023-02-22 11:20</div>
            <div class="timeline-body"><p>@danstewart most likely you want this instead:</p>
<pre><code>&quot;ruff.importStrategy&quot;: &quot;fromEnvironment&quot;
</code></pre>
<p>which will find <code>ruff</code> in whatever the venv associated with the vscode workspace is, without having to hardcode the path.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danstewart">@danstewart</a> on 2023-02-22 11:22</div>
            <div class="timeline-body"><p>Thanks, that&#x27;s much better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-02-22 14:28</div>
            <div class="timeline-body"><p>@danstewart - I cut a new pre-release last night that includes v0.0.251, so you can pull it in if you switch to the pre-release channel. I&#x27;ll probably cut a main-channel release today or tomorrow.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:25 UTC
    </footer>
</body>
</html>
