<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] (Gradual) intersection types are not handled in assignability - astral-sh/ruff #14899</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] (Gradual) intersection types are not handled in assignability</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/14899">#14899</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-12-10 20:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-12-10 20:01</div>
            <div class="timeline-body"><p>The <code>is_assignable_to</code>-is-reflexive property test, which makes sure that we can assign any type to itself, is currently failing with counter-examples like <code>Any &amp; T</code>, where <code>T</code> is an arbitrary type (that doesn't let the intersection collapse).</p>
<p>The reason for this is that we can't rely on <em>equivalence</em> for assignability of gradual types anymore ever since https://github.com/astral-sh/ruff/pull/14758. We do have some special casing for gradual types like <code>Any</code> and <code>Unknown</code>, as well as for unions and tuples of these, but we do lack handling of intersections.</p>
<p>This is not completely trivial. We can patch this with some superficial handling like</p>
<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -748,6 +748,14 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 .elements(db)
                 .iter()
                 .any(|&amp;elem_ty| ty.is_assignable_to(db, elem_ty)),
+            (Type::Intersection(intersection), ty) =&gt; intersection
+                .positive(db)
+                .iter()
+                .any(|&amp;elem_ty| elem_ty.is_assignable_to(db, ty)),
+            (ty, Type::Intersection(intersection)) =&gt; intersection
+                .positive(db)
+                .iter()
+                .any(|&amp;elem_ty| ty.is_assignable_to(db, elem_ty)),
             (Type::Tuple(self_tuple), Type::Tuple(target_tuple)) =&gt; {
                 let self_elements = self_tuple.elements(db);
                 let target_elements = target_tuple.elements(db);
</code></pre>
<p>which also works for things like <code>T &amp; ~Any</code>, because we always add <code>Any</code>/<code>Unknown</code> as positive contributions to intersections.</p>
<p>But then quickcheck finds types like <code>~tuple[Any, T]</code>, for which the simple handling above breaks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2024-12-10 20:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/14876.html">astral-sh/ruff#14876</a> on 2024-12-10 20:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @carljm on 2024-12-14 02:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-14 02:19</div>
            <div class="timeline-body"><p>Moving this out of Backlog and into Ready, and also marking help-wanted in case a contributor is interested in it, because I think having the quickcheck tests stable and green on main is quite valuable. Just now I was making another change to type relations, ran the quickcheck tests, and hit this failure, which diverted me for a while until I realized it was failing also on main and found this issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/14967.html">astral-sh/ruff#14967</a> on 2024-12-14 05:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/14970.html">astral-sh/ruff#14970</a> on 2024-12-14 15:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15194.html">astral-sh/ruff#15194</a> on 2025-01-03 16:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15242.html">astral-sh/ruff#15242</a> on 2025-01-03 18:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15297.html">astral-sh/ruff#15297</a> on 2025-01-06 05:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rtpg">@rtpg</a> on 2025-01-06 06:44</div>
            <div class="timeline-body"><blockquote>
<p>which also works for things like T &amp; ~Any, because we always add Any/Unknown as positive contributions to intersections.</p>
</blockquote>
<p>Regarding this, is <code>Ty</code> meant to mirror exactly the sort of structures that we'd end up with using <code>Type&lt;'db&gt;</code>? Like we would never have <code>T &amp; ~Any</code> with <code>Type</code>, and we wouldn't have an intersection of unions (since we normalize to unions of intersections).</p>
<p>I think the arbitrary generator currently in the property tests will gladly generate non-normalized intersections in particular, which might be generating false positives in these tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rtpg">@rtpg</a> on 2025-01-06 11:26</div>
            <div class="timeline-body"><p>After poking at this a bit more, I now feel like the main problem with the existing <code>Ty</code> generation is mainly that a test failure shows the <code>Ty</code> intead of a representation of the actual <code>Type</code> used. So you don't see the shape of the actual type tested, just the pre-transformed <code>Ty</code> smart constructor.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-06 11:28</div>
            <div class="timeline-body"><blockquote>
<p>After poking at this a bit more, I now feel like the main problem with the existing <code>Ty</code> generation is mainly that a test failure shows the <code>Ty</code> intead of a representation of the actual <code>Type</code> used. So you don't see the shape of the actual type tested, just the pre-transformed <code>Ty</code> smart constructor.</p>
</blockquote>
<p>Yeah, agreed that this would be a big usability improvement!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rtpg">@rtpg</a> on 2025-01-06 11:38</div>
            <div class="timeline-body"><p>The idle thought I had here is that it would be cool if quickcheck ran shrunk failures one last time after finding minimal repros, and  had a &quot;verbose log&quot; mechanism that would let me put in &quot;expensive&quot; logs or <code>TestResult</code> error message generation, without actually causing slowdowns most of the time. Or really any sort of way to run something on the minimum repro right before stopping.</p>
<p>For now I might try to just add something into the test harness and see how much slower it is. Computers still are fast after all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-08 19:17</div>
            <div class="timeline-body"><p>This issue is actually a bit more general than the title/description make it sound like.</p>
<p>We currently don't have any logic for handling intersection types in the <code>is_assignable_to</code> relation. We <em>do</em> have special handling in <code>is_equivalent_to</code> and <code>is_subtype_of</code>, so for fully-static types, we're probably good(?). But for gradual types, it looks like we need some special handling. For example, we currently don't allow <code>Unknown &amp; int</code> to be assigned to <code>int</code>, so something like this fails:</p>
<pre><code class="language-py">def f(x) -&gt; None:
    if isinstance(x, int):
        reveal_type(x)  # Unknown &amp; int
        y: int = x  # currently fails with invalid-assignment
</code></pre>
<p>We could probably write a property test like <code>forall T, S. is_assignable_to(T &amp; S, T)</code> that would catch this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] `is_assignable_to` is not reflexive" to "[red-knot] (Gradual) intersection types are not handled in assignability" by @sharkdp on 2025-01-08 19:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-08 19:26</div>
            <div class="timeline-body"><p>This bug now has some failing unit tests here: https://github.com/astral-sh/ruff/blob/beb8e2dfe07b71de5507fbff151e510fb284747a/crates/red_knot_python_semantic/resources/mdtest/type_properties/is_assignable_to.md?plain=1#L267-L276</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15358.html">astral-sh/ruff#15358</a> on 2025-01-08 20:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Red Knot Q1 2025" by @carljm on 2025-01-09 17:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15675.html">astral-sh/ruff#15675</a> on 2025-01-22 15:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/16540.html">astral-sh/ruff#16540</a> on 2025-03-10 09:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/15697.html">astral-sh/ruff#15697</a> on 2025-03-10 11:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/16611.html">astral-sh/ruff#16611</a> on 2025-03-10 22:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-03-11 14:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-03-11 14:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/16641.html">astral-sh/ruff#16641</a> on 2025-03-11 18:16</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:15 UTC
    </footer>
</body>
</html>
