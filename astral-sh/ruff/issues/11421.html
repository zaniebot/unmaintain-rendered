<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C901, PLR0912 and PLR0915 treat match/case as one statement - astral-sh/ruff #11421</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>C901, PLR0912 and PLR0915 treat match/case as one statement</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/11421">#11421</a>
        opened by <a href="https://github.com/jaap3">@jaap3</a>
        on 2024-05-14 09:21
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/jaap3">@jaap3</a> on 2024-05-14 09:21</div>
            <div class="timeline-body"><p>Using ruff 0.4.4 the following code triggers <code>C901</code>, <code>PLR0912</code> and <code>PLR0915</code>:</p>
<pre><code class="language-python">def grades_to_average(grades):
    numbers = []
    for grade in grades:
        if grade in {&quot;F-&quot;, &quot;F&quot;, &quot;F+&quot;, &quot;E-&quot;, &quot;E&quot;}:
            numbers.append(0)
        elif grade == &quot;E+&quot;:
            numbers.append(.3)
        elif grade == &quot;D-&quot;:
            numbers.append(.7)
        elif grade == &quot;D&quot;:
            numbers.append(1.0)
        elif grade == &quot;D+&quot;:
            numbers.append(1.3)
        elif grade == &quot;C-&quot;:
            numbers.append(1.7)
        elif grade == &quot;C&quot;:
            numbers.append(2.0)
        elif grade == &quot;C+&quot;:
            numbers.append(2.3)
        elif grade == &quot;B-&quot;:
            numbers.append(2.7)
        elif grade == &quot;B&quot;:
            numbers.append(3.0)
        elif grade == &quot;B+&quot;:
            numbers.append(3.3)
        elif grade == &quot;A-&quot;:
            numbers.append(3.7)
        elif grade in {&quot;A&quot;, &quot;A+&quot;}:
            numbers.append(4.0)
        else:
            raise ValueError(f&quot;Unknown grade: {grade}&quot;)

    try:
        avg = sum(numbers) / len(numbers)
    except ZeroDivisionError:
        avg = 0

    if avg &lt; 0.3:
        avg_grade = &quot;F&quot;
    elif avg &lt; .7:
        avg_grade = &quot;E+&quot;
    elif avg &lt; 1.0:
        avg_grade = &quot;D-&quot;
    elif avg &lt; 1.3:
        avg_grade = &quot;D&quot;
    elif avg &lt; 1.7:
        avg_grade = &quot;D+&quot;
    elif avg &lt; 2.0:
        avg_grade = &quot;C-&quot;
    elif avg &lt; 2.3:
        avg_grade = &quot;C&quot;
    elif avg &lt; 2.7:
        avg_grade = &quot;C+&quot;
    elif avg &lt; 3.0:
        avg_grade = &quot;B-&quot;
    elif avg &lt; 3.3:
        avg_grade = &quot;B&quot;
    elif avg &lt; 3.7:
        avg_grade = &quot;B+&quot;
    elif avg &lt; 4.0:
        avg_grade = &quot;A-&quot;
    elif avg &gt;= 4.0:
        avg_grade = &quot;A&quot;
    else:
        raise ValueError(f&quot;Unexpected average: {avg}&quot;)
    return avg_grade
</code></pre>
<p>The equivalent code that uses <code>match</code>/<code>case</code> however does not:</p>
<pre><code class="language-python">def grades_to_average(grades):
    numbers = []
    for grade in grades:
        match grade:
            case &quot;F-&quot; | &quot;F&quot; | &quot;F+&quot; | &quot;E-&quot; | &quot;E&quot;:
                numbers.append(0)
            case &quot;E+&quot;:
                numbers.append(.3)
            case &quot;D-&quot;:
                numbers.append(.7)
            case &quot;D&quot;:
                numbers.append(1.0)
            case &quot;D+&quot;:
                numbers.append(1.3)
            case &quot;C-&quot;:
                numbers.append(1.7)
            case &quot;C&quot;:
                numbers.append(2.0)
            case &quot;C+&quot;:
                numbers.append(2.3)
            case &quot;B-&quot;:
                numbers.append(2.7)
            case &quot;B&quot;:
                numbers.append(3.0)
            case &quot;B+&quot;:
                numbers.append(3.3)
            case &quot;A-&quot;:
                numbers.append(3.7)
            case &quot;A&quot; | &quot;A+&quot;:
                numbers.append(4.0)
            case _:
                raise ValueError(f&quot;Unknown grade: {grade}&quot;)

    try:
        avg = sum(numbers) / len(numbers)
    except ZeroDivisionError:
        avg = 0

    match avg:
        case avg if avg &lt; .3:
            avg_grade = &quot;F&quot;
        case avg if avg &lt; .7:
            avg_grade = &quot;E+&quot;
        case avg if avg &lt; 1.0:
            avg_grade = &quot;D-&quot;
        case avg if avg &lt; 1.3:
            avg_grade = &quot;D&quot;
        case avg if avg &lt; 1.7:
            avg_grade = &quot;D+&quot;
        case avg if avg &lt; 2.0:
            avg_grade = &quot;C-&quot;
        case avg if avg &lt; 2.3:
            avg_grade = &quot;C&quot;
        case avg if avg &lt; 2.7:
            avg_grade = &quot;C+&quot;
        case avg if avg &lt; 3.0:
            avg_grade = &quot;B-&quot;
        case avg if avg &lt; 3.3:
            avg_grade = &quot;B&quot;
        case avg if avg &lt; 3.7:
            avg_grade = &quot;B+&quot;
        case avg if avg &lt; 4.0:
            avg_grade = &quot;A-&quot;
        case avg if avg &gt;= 4.0:
            avg_grade = &quot;A&quot;
        case _:
            raise ValueError(f&quot;Unexpected average: {avg}&quot;)
    return avg_grade
</code></pre>
<p>Is this intentional? Should each <code>case</code> count as a conditional?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-05-15 09:18</div>
            <div class="timeline-body"><p>I think it is intentional as Pylint doesn't detect it either.</p>
<blockquote>
<p>Should each <code>case</code> count as a conditional?</p>
</blockquote>
<p>Personally, I wouldn't count it as I find the <code>match</code> statement to be more readable than an <code>if</code> statement. Additionally, the semantics of pattern matching is very different then the test expression of an <code>if</code> statement. I'd love to hear others opinion, cc @AlexWaygood @zanieb</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jaap3">@jaap3</a> on 2024-05-16 08:41</div>
            <div class="timeline-body"><p>I feel like the same complexity and maintainability arguments apply to <code>match</code> and <code>case</code>. They are definitely a way to achieve branching code and each case (especially the conditional ones containing <code>if</code>) could be considered to be a distinct statement right?</p>
<p>This issue should probably be converted to a discussion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @dhruvmanila on 2024-05-20 05:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-05-20 05:52</div>
            <div class="timeline-body"><blockquote>
<p>This issue should probably be converted to a discussion.</p>
</blockquote>
<p>It's fine, we can discuss here.</p>
<p>I don't have any arguments against this, and it does make sense (I think?) to include the <code>match</code> statement similarly to an <code>if</code> statement. I would wait for others to share their opinions before we decide. It would also be useful to hear the thoughts of the Pylint maintainers. Do you want to open an issue on the Pylint repository similar to this? I can also do that :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/11205.html">astral-sh/ruff#11205</a> on 2024-05-22 03:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-05-22 03:17</div>
            <div class="timeline-body"><p>\cc @Pierre-Sassoulas</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Pierre-Sassoulas">@Pierre-Sassoulas</a> on 2024-05-22 05:07</div>
            <div class="timeline-body"><p>Thank you for the ping @charliermarsh :) I see no reason for match  to behave differently than if. I think it's an oversight when we added the match statement for python 3.10 we did not think to test the consequences on the already implemented &quot;too-complex&quot; (assumed the &quot;too-complex&quot; code was generic enough).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Pierre-Sassoulas">@Pierre-Sassoulas</a> on 2024-05-22 06:47</div>
            <div class="timeline-body"><p>So, I did some light research and there might be a point for 'too-complex&quot; behaving the way it does right now. It is based on Mc Cabe and:</p>
<blockquote>
<p>McCabe originally recommended exempting modules consisting of single mul-
tiway decision (“switch” or “case”) statements from the complexity limit. The multiway deci-
sion issue has been interpreted in many ways over the years, sometimes with disastrous
results.</p>
</blockquote>
<p>https://web.archive.org/web/20210908120324/https://www.mccabe.com/pdf/mccabe-nist235r.pdf (page 15, notice also that McCabe himself is one of the authors)</p>
<p>Also on page 26 we can see:</p>
<blockquote>
<p>A less frequently occurring issue that has greater impact on complexity is the distinction between
“case-labeled statements” and “case labels.” When several case labels apply to the same pro-
gram statement, this is modeled as a single decision outcome edge in the control flow graph,
adding one to complexity. It is certainly possible to make a consistent flow graph model in
which each individual case label contributes a different decision outcome edge and hence also
adds one to complexity, but that is not the typical usage</p>
</blockquote>
<p>Imo, the match case in python adds complexity because it's not a simple &quot;case labels&quot;, it's behaving more like an if, or even a regex.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pylint-dev/pylint/pulls/9667.html">pylint-dev/pylint#9667</a> on 2024-05-22 07:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-05-23 13:38</div>
            <div class="timeline-body"><p>I agree with @Pierre-Sassoulas. For the Mccabe plugin, I believe one of the primary motivations for the rule is to ensure that each function is testable in isolation. If a function has too many branches, it becomes hard to write a unit test for it. I think this is just as much a concern for <code>match</code>/<code>case</code> as it is with <code>if</code>/<code>elif</code>, as each new <code>case</code> statement in the <code>match</code>/<code>case</code> treee can be seen as a wholly distinct branch that you would need to account for when writing tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @dhruvmanila on 2024-05-23 13:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @dhruvmanila on 2024-05-23 13:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @dhruvmanila on 2024-05-23 13:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-05-23 13:57</div>
            <div class="timeline-body"><p>Thank you @Pierre-Sassoulas for chiming in! I agree with the conclusion. I think we should update all three rules to consider <code>match</code> statement and we can see how many changes we see in the ecosystem checks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/blueraft">@blueraft</a> on 2024-05-23 16:09</div>
            <div class="timeline-body"><p>I can take a stab at this if that's ok.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-05-23 16:37</div>
            <div class="timeline-body"><p>Go for it -- thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/11521.html">astral-sh/ruff#11521</a> on 2024-05-23 19:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2024-05-24 09:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jaap3">@jaap3</a> on 2024-05-24 14:33</div>
            <div class="timeline-body"><p>Thanks everyone!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qartik">@qartik</a> on 2024-05-29 12:44</div>
            <div class="timeline-body"><p>I wish the consideration for match-case statement for PLR rules was configurable to be turned off with lint.pylint setting. Long match-case statements are very common while walking abstract syntax trees and are arguably way less complex than any other solution. See usage, e.g. at https://github.com/CQCL/pytket-phir/blob/main/pytket/phir/phirgen.py#L102-L148 which now raises  both PLR 912 and 915.</p>
<p>@jaap3, @blueraft, @dhruvmanila what do you think? If there is agreement, I can file a separate issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-05-29 12:52</div>
            <div class="timeline-body"><blockquote>
<p>Long match-case statements are very common while walking abstract syntax trees and are arguably way less complex than any other solution.</p>
</blockquote>
<p>I'd agree that match/case statements are more readable for this purpose, and arguably more idiomatic, but I don't think there's any fewer branches than if you walked the tree using if/elif/else, and the number of branches is what these rules are concerned with. I don't see a strong reason to make match/case statements configurable here specifically. I think I'd find it just as difficult to write comprehensive unit tests for a function with many <code>case</code> branches as I would for a function with many <code>elif</code> branches</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qartik">@qartik</a> on 2024-05-29 15:31</div>
            <div class="timeline-body"><p>The only thing to add is there is no simpler way to process an enumeration than pattern matching (such as those that show up in AST walks as mentioned) and for those cases, I'd argue complexity considerations covered by these rules do not apply.</p>
<p>With current change, any parsers/compilers processing a grammar could be full of ruff ignores for each such match construct (or in each file, but then missing several other cases) or we can let users choose whether they want these code complexity heuristics to apply to match-case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-05-29 15:38</div>
            <div class="timeline-body"><p>To me that just seems to be arbitrarily favouring some language constructs at the expense of others in the name of readability and style, which isn't what this rule is meant to be ultimately concerned about. If the argument is that there are many cases where writing a more complex function is in fact more maintainable and redable than splitting the function into several smaller functions, then I'd agree that that's a valid critique. But to me, that seems like a flaw of the rule in general rather than a flaw of the rule as specifically applied to <code>match</code>/<code>case</code> statements.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/albertomurillo">@albertomurillo</a> on 2024-10-17 07:14</div>
            <div class="timeline-body"><p>The exhaustive match/case pattern for all possible values in an enumeration is actually promoted by the rust compiler, it is a good practice to replicate in other languages such as python but that triggers the complexity warning.</p>
<p>It does make a difference to have if/elif/... statements vs match/case/... because in an if/elif/... scenario you can have any kind of conditional while on the match/case scenario is only values for the same variable.</p>
<p>Anyway, a config setting to revert the rule to the previous behavior would be the best of both worlds.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:12 UTC
    </footer>
</body>
</html>
