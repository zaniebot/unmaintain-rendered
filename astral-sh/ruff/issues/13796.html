<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] support stringified annotations - astral-sh/ruff #13796</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] support stringified annotations</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/13796">#13796</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-10-17 16:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/carljm">@carljm</a> on 2024-10-17 16:41</div>
            <div class="timeline-body"><p>As a work-around for forward references (given that by default type annotations are eagerly evaluated at runtime), the Python type system supports type annotations written as string literals, where the contents of the string should be interpreted by the type checker as an annotation expression. See https://typing.readthedocs.io/en/latest/spec/annotations.html#string-annotations</p>
<p>See https://github.com/astral-sh/ruff/discussions/13499 for prior discussion here.</p>
<p>Some salient things to consider:</p>
<h2>Which strings should be considered stringified annotations?</h2>
<details>

<p>All string literals found within a type annotation (variable annotation or function parameter/return annotation) should be parsed as stringified annotations. (This is recursive, not only when the entire annotation is a string: parts of annotations can be stringified, e.g. <code>list[&quot;MyType&quot;]</code>.)</p>
<p>EXCEPT that a string found inside <code>typing.Literal[&quot;some random string&quot;]</code> or <code>typing.Annotated[SomeType, &quot;some string&quot;]</code> in an annotation should not be parsed as a stringified annotation. The difficulty here is that <code>foo[&quot;some random string&quot;]</code> is also a string literal type, not a stringified annotation, if <code>foo</code> is actually an alias for <code>typing.Literal</code>, even via multiple levels of aliasing and imports. This means we don't know for sure if a string in an annotation is a stringified annotation until we are actually doing type inference on that code, so we can reliably identify <code>typing.Literal</code> and <code>typing.Annotated</code>.</p>
</details>

<h2>How should names within stringified annotations be resolved?</h2>
<details>

<p>The typing spec says only:</p>
<blockquote>
<p>The local and global namespace in which it is evaluated should be the same namespaces in which default arguments to the same function would be evaluated.</p>
</blockquote>
<p>In practice, this isn't how all type checkers behave, though. We can evaluate the actual behavior using this small module:</p>
<pre><code class="language-py">from typing import TypeAlias, TYPE_CHECKING, get_type_hints

A: TypeAlias = int

class C:
    A: TypeAlias = str
    x: &quot;A&quot;
    y: A

    def f(self, x: &quot;A&quot;, y: A):
        pass

if TYPE_CHECKING:
    reveal_type(C.x)
    reveal_type(C.y)
    reveal_type(C.f)
else:
    print(get_type_hints(C))
    print(get_type_hints(C.f))
</code></pre>
<p>We can evaluate this program against mypy, pyright, and the runtime behavior of <code>typing.get_type_hints</code> function. We find that only mypy follows the spec as written above, implementing name lookup for stringified annotations using the same scopes as for non-stringified annotations:</p>
<pre><code>➜ mypy .
res.py:14: note: Revealed type is &quot;builtins.str&quot;
res.py:15: note: Revealed type is &quot;builtins.str&quot;
res.py:16: note: Revealed type is &quot;def (self: res.C, x: builtins.str, y: builtins.str) -&gt; Any&quot;
</code></pre>
<p>However, <code>typing.get_type_hints</code> at runtime implements a backwards-compatibility hack to prioritize the global namespace over the local one, and pyright has <a href="https://github.com/microsoft/pyright/discussions/8958">followed its lead</a>:</p>
<pre><code>➜ python3 res.py
{'A': typing.TypeAlias, 'x': &lt;class 'int'&gt;, 'y': &lt;class 'str'&gt;}
{'x': &lt;class 'int'&gt;, 'y': &lt;class 'str'&gt;}
</code></pre>
<pre><code>➜ pyright
/Users/carlmeyer/projects/pyright-testing/res.py
  /Users/carlmeyer/projects/pyright-testing/res.py:14:17 - information: Type of &quot;C.x&quot; is &quot;int&quot;
  /Users/carlmeyer/projects/pyright-testing/res.py:15:17 - information: Type of &quot;C.y&quot; is &quot;str&quot;
  /Users/carlmeyer/projects/pyright-testing/res.py:16:17 - information: Type of &quot;C.f&quot; is &quot;(self: C, x: int, y: str) -&gt; None&quot;
</code></pre>
<p>They both consider the type of <code>x</code> (either as a class attribute or a method parameter annotation) to be <code>int</code>, prioritizing the global namespace over the local one.</p>
<p>Pyright also does the same for non-stringified annotations which are deferred-evaluated because they are in a type stub, because the typing spec currently says that all annotations in a stub file should be treated as stringified:</p>
<pre><code class="language-py"># file res1.py
from typing import TypeAlias

A: TypeAlias = int

class C:
    A: TypeAlias = str
    x: &quot;A&quot;
    y: A

reveal_type(C.x)
reveal_type(C.y)
</code></pre>
<pre><code>➜ pyright
/Users/carlmeyer/projects/pyright-testing/res1.pyi
  /Users/carlmeyer/projects/pyright-testing/res1.pyi:10:13 - information: Type of &quot;C.x&quot; is &quot;int&quot;
  /Users/carlmeyer/projects/pyright-testing/res1.pyi:11:13 - information: Type of &quot;C.y&quot; is &quot;int&quot;
</code></pre>
<p>And pyright does the same for all annotations in a Python file when <code>from __future__ import annotations</code> is turned on, which makes sense, since at runtime those are actually all stringified annotations.</p>
<p>It's not totally clear to me what we should do here. I think I would <em>prefer</em> to not implement this namespace swapping at all (like mypy), but maybe compatibility with <code>typing.get_type_hints</code> and pyright will be more important in practice? Not sure.</p>
<p>How we answer this question could have significant implications for how we implement this; the more special-cased the name lookup rules for stringified annotations are, the more it suggests we should not transparently try to parse them to AST in the parser.</p>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-10-17 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Viicos">@Viicos</a> on 2024-10-18 11:47</div>
            <div class="timeline-body"><p><code>Annotated</code> metadata also needs to be special cased, similar to <code>Literal</code> :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-18 17:54</div>
            <div class="timeline-body"><blockquote>
<p><code>Annotated</code> metadata also needs to be special cased, similar to <code>Literal</code> :)</p>
</blockquote>
<p>Thanks! Edited the description to reflect this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Red Knot 2024" by @carljm on 2024-11-07 15:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @dhruvmanila by @carljm on 2024-11-07 15:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/14151.html">astral-sh/ruff#14151</a> on 2024-11-13 18:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2024-11-15 04:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2024-11-15 04:10</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:53 UTC
    </footer>
</body>
</html>
