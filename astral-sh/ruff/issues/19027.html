<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Improve detection of redundant parenthesis - astral-sh/ruff #19027</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Improve detection of redundant parenthesis</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/19027">#19027</a>
        opened by <a href="https://github.com/robsdedude">@robsdedude</a>
        on 2025-06-29 15:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/robsdedude">@robsdedude</a> on 2025-06-29 15:43</div>
            <div class="timeline-body"><h3>Summary</h3>
<h2>Problem Statement</h2>
<p>I'm maintaining a flake8 plugin that (besides some other things) lints on redundant parenthesis: https://github.com/robsdedude/flake8-picky-parentheses</p>
<p>It covers many more cases compared to <code>UP034</code>. Examples are</p>
<pre><code class="language-python">a = ((&quot;a&quot;),)  # same as `a = (&quot;a&quot;,)`
a = (1 + 2)  # same as `a = 1 + 2`
a = foo(*(a))  # same as `a = foo(*a)`
foo[(1):]  # same as `foo[1:]`
</code></pre>
<h2>Proposed Solution</h2>
<p>The plugin works by implementing a more complex and therefore computation costly algorithm:</p>
<ul>
<li>For each statement:<ul>
<li><em>optional for optimization</em>: Replace the body of the statement if any with a placeholder, e.g., turn a function's body into  <code>pass</code></li>
<li>Tokenize statement and find each parens pair in the statement</li>
<li>Compute/get AST <code>ast_baseline</code></li>
<li>For each parens pair:<ul>
<li>on a copy of the statement, remove the pair and compute the AST</li>
<li>if the AST is different from <code>ast_baseline</code> :<ul>
<li>parens were necessary; do nothing for this pair</li>
</ul>
</li>
<li>else, if not in one of the exception cases (s. below):<ul>
<li>emit the lint</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>By not operating on the token level, but the AST level, many more cases can be covered at the cost of this being potentially much slower.</p>
<h2>Open Questions</h2>
<p>A while back I asked on Discord if there's interest in integrating such functionality into <code>ruff</code>, but I didn't get a decisive answer.</p>
<ul>
<li>Are you interested in Ruff supporting such a check?</li>
<li>How to go about managing the runtime cost?<ul>
<li>Maybe make it a different, opt-in rule with the docs stating the drawback</li>
<li>Maybe make it config option for <code>UP035</code> something like <code>thorough-extraneous-parentheses</code></li>
</ul>
</li>
</ul>
<h2>Exceptions to the Rule</h2>
<p>(redundant parenthesis that wouldn't trigger the lint)</p>
<details>

<summary>quote from plugin's `README`</summary>

<blockquote>
<p>[...] there are some notable exceptions to this rule:</p>
<ol>
<li>Parentheses for tuple literals.</li>
<li>A single pair or parentheses in expressions to highlight operator
precedence.
Even if these parentheses are redundant, they help to divide parts of
expressions and show sequence of actions.</li>
<li>Parts of slices.</li>
<li>Multi-line<sup>1)</sup> expression, <code>if</code> and <code>for</code> parts in comprehensions.</li>
<li>Multi-line<sup>1)</sup> keyword arguments or argument defaults.</li>
<li>String concatenation over several lines in lists, tuples, and function arguments.</li>
</ol>
<h3>Footnotes</h3>
<ol>
<li>Multi-line means that either<ul>
<li><p>the expression spans multiple lines, e.g.,</p>
<pre><code class="language-python">(a
 + b)
</code></pre>
</li>
<li><p>or the first part of the expression is on a new line (e.g., if a name is very long), e.g.,</p>
<pre><code class="language-python">(
    veeeeeeeeeeery_looooooong_name
)
</code></pre>
<p>but also</p>
<pre><code class="language-python">(
    a
    + b
)
</code></pre>
<p>Multi-line expressions do <strong>not</strong> include</p>
</li>
</ul>
<pre><code class="language-python">(a + b
)
</code></pre>
</details>

</li>
</ol>
</blockquote>
<h2>Related</h2>
<ul>
<li>https://github.com/astral-sh/ruff/issues/2389</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @ntBre on 2025-06-30 13:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @ntBre on 2025-06-30 13:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-30 13:13</div>
            <div class="timeline-body"><p>I think it sounds interesting, I use the &quot;remove redundant parentheses&quot; code action from rust-analyzer fairly often. That does sound like an expensive approach, though. We may want to try exploring other potential designs first.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-07 08:55</div>
            <div class="timeline-body"><p>As a note. The formatter already handles many of those cases. There are also cases where the parentheses are technically not necessary but can improve readability or help to split the code over multiple lines (because Python...).</p>
<p>Overall, I don't think the generic approach described in the summary works for us because it doesn't guarantee formatter compatibility. It would have to be a more opinionated set of rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/robsdedude">@robsdedude</a> on 2025-07-07 10:27</div>
            <div class="timeline-body"><blockquote>
<p>not necessary but can improve readability</p>
</blockquote>
<p>That's exactly what the list of exceptions is for. If there are cases missing, it's easy enough to add them.</p>
<blockquote>
<p>help to split the code over multiple lines</p>
</blockquote>
<p>In those cases, the parentheses are likely actually necessary. Because</p>
<pre><code class="language-python">a = (
    something_very_long + something_that_is_even_longer
)
</code></pre>
<p>yields a valid AST while (same code with parens stripped)</p>
<pre><code class="language-python">a = 
    something_very_long + something_that_is_even_longer

</code></pre>
<p>is a syntax error.</p>
<blockquote>
<p>doesn't guarantee formatter compatibility</p>
</blockquote>
<p>Would the formatter ever produces parentheses where it's not necessary?</p>
<p>I've already started to POC the approach, just because I'm curious. I fully appreciate that the work might go straight into the trash bin as you're both not very convinced ðŸ˜¬ I still want to see where it leads me. @MichaReiser are there any tests that check for linter-formatter compatibility in the code base? If so, could you kindly point me towards them?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-07 14:23</div>
            <div class="timeline-body"><blockquote>
<p>I still want to see where it leads me. @MichaReiser are there any tests that check for linter-formatter compatibility in the code base? If so, could you kindly point me towards them?</p>
</blockquote>
<p>I don't think there are any. Sorry</p>
<blockquote>
<p>yields a valid AST while (same code with parens stripped)</p>
</blockquote>
<p>That's true. Although I'm not convinced that calling the parser for every parenthesized expression will give us good performance. I'd expect a more handcrafted implementation similar to the <a href="https://github.com/biomejs/biome/blob/2649ac625de963bf7411368cdd06142bda362322/crates/biome_js_syntax/src/parentheses/mod.rs#L49"><code>NeedsParentheses</code> trait in biomejs</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/robsdedude">@robsdedude</a> on 2025-07-07 15:28</div>
            <div class="timeline-body"><blockquote>
<p>Although I'm not convinced that calling the parser for every parenthesized expression will give us good performance</p>
</blockquote>
<p>Yes, that's my biggest concern as well as written initially. Assuming that AST parsing is in polynomial complexity <code>O(n^p_ast)</code> (I guess <code>p_ast</code> might even be <code>1</code>), then the proposed algorithm has a complexity of <code>O(n_line_len^(p_ast + 1) * n_line_num)</code> where <code>n_line_len</code> is the length of the longest logical line and <code>n_line_num</code> is the number of logical lines in the file.</p>
<p>My thought is, while you theoretically can write an insanely long logical line, I expect typical Python programs to have a fairly limited max line length, especially if the author cares about readability and maintainability - which I'd argue is indicated by them using ruff in the first place.</p>
<p>Now what all the big O notation fluff does deliberately not account for is the constant factor. That's exactly why I want to POC the idea to see what performance would look like for a long but still reasonable logical line length (say 10 lines filled with 80 characters or so).</p>
<p>Thanks so far for your thoughts and the biomejs link. I'll see if there's some inspiration I can draw from there :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-09-12 14:50</div>
            <div class="timeline-body"><p>I just came across <code>some_func(foo=(&quot;bar&quot;))</code>. I think these parentheses should definitely be removed, they only serve into confusing people to thing that this is a tuple.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:16 UTC
    </footer>
</body>
</html>
