<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`SIM114` fix introduces type checker errors - astral-sh/ruff #17263</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>SIM114</code> fix introduces type checker errors</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/17263">#17263</a>
        opened by <a href="https://github.com/AITechXcel">@AITechXcel</a>
        on 2025-04-07 04:45
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/AITechXcel">@AITechXcel</a> on 2025-04-07 04:45</div>
            <div class="timeline-body"><h3>Summary</h3>
<pre><code class="language-python">def get_value(dotted_str: str, dict_obj: JSON) -&gt; JSON:
    names = parse_path(dotted_str)
    result: JSON = dict_obj
    for name in names:
        if isinstance(name, int) and isinstance(result, list):
            result = result[name]
        elif isinstance(name, str) and isinstance(result, dict):
            result = result[name]
        else:
            msg = f&quot;Expected int or str, got {type(name)}&quot;
            raise ValueError(msg)
    return result
</code></pre>
<p><code>SIM114</code> turns this into ternary operator, which then gives:</p>
<pre><code>No overloads for &quot;__getitem__&quot; match the provided argumentsPylance[reportCallIssue](https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportCallIssue)
builtins.pyi(1026, 9): Overload 2 is the closest match
⌘+click to open in new tab
Argument of type &quot;int | str&quot; cannot be assigned to parameter &quot;s&quot; of type &quot;slice&quot; in function &quot;__getitem__&quot;
  Type &quot;int | str&quot; is incompatible with type &quot;slice&quot;
    &quot;int&quot; is incompatible with &quot;slice&quot;PylancereportArgumentType
⌘+click to open in new tab
Argument of type &quot;int | str&quot; cannot be assigned to parameter &quot;key&quot; of type &quot;str&quot; in function &quot;__getitem__&quot;
  Type &quot;int | str&quot; is incompatible with type &quot;str&quot;
    &quot;int&quot; is incompatible with &quot;str&quot;Pylance[reportArgumentType](https://github.com/microsoft/pyright/blob/main/docs/configuration.md#reportArgumentType)
</code></pre>
<h3>Version</h3>
<pre><code>&quot;ruff==0.9.8&quot;,</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Ruff is turning valid code into invalid code, meaning I cannot run my code" to "`SIM114` turns valid code into invalid code, meaning I cannot run my code" by @MichaReiser on 2025-04-07 06:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`SIM114` turns valid code into invalid code, meaning I cannot run my code" to "`SIM114` fix introduces type checker errors" by @MichaReiser on 2025-04-07 06:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @MichaReiser on 2025-04-07 07:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-07 07:02</div>
            <div class="timeline-body"><p>Your code should run fine but <code>SIM114</code> does introduce type checking errors because Pyright doesn't support narrowing as complicated as this. @sharkdp would red knot understand:</p>
<pre><code class="language-py">if isinstance(name, int) and isinstance(result, list) or isinstance(name, str) and isinstance(result, dict):
    result = result[name]
else:
    msg = f&quot;Expected int or str, got {type(name)}&quot;
    
</code></pre>
<p>Either way. I think this makes an argument that we shouldn't flag <code>isinstance</code> checks (unless @AlexWaygood disagrees)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-07 07:42</div>
            <div class="timeline-body"><blockquote>
<p>because Pyright doesn't support narrowing as complicated as this</p>
</blockquote>
<p>I don't think that's correct. Both <a href="https://pyright-play.net/?code=GYJw9gtgBALgngBwJYDsDmUkQWEMogCmAboQIYA2A%2BvAoQFD0AmhwUwAFCmRIQFxQwAIwBWhAMYwANAUIBnAK4UYA4WMkBKPvSi7MbDjr3Gkc1HJhkU4wlx6EZqGBqPHdVppjMoLVmxyJFZRkKU2dXN1wvc0trW25eGQsQFzc9D2ifWP9ApWkoJiRNCK0I4yJSShpEePsNXQBiTBR8AB8oZLK9CvJqWltc5XqoJtCLKHbCyXogA">pyright</a> and <a href="https://playknot.ruff.rs/96745062-29cc-4ae8-9fa9-cedc06af3d8f">Red Knot</a> can narrow the types just fine after the conditions have been merged:</p>
<pre><code class="language-py">from typing import reveal_type

def f(name: object, result: object):
    if (
        isinstance(name, int)
        and isinstance(result, list)
        or isinstance(name, str)
        and isinstance(result, dict)
    ):
        reveal_type(name)  # int | str
        reveal_type(result)  # list | dict
</code></pre>
<p>But the problem is that <code>result[name]</code> is not true for all four possible combinations of <code>list | dict</code> vs <code>int | str</code>. You can not subscript a list with an argument type of <code>str</code>. So pyright is correct to issue a diagnostic in the transformed code.</p>
<p>In other words: the code transformation suggested by this rule is fine at runtime, but it's not enough to prove to a type checker that the code is correct.</p>
<p>It is, of course, <em>conceivable</em> that a sophisticated type checker could understand this code using a narrowing constraint that captures the <em>relationship</em> between <code>name</code> and <code>result</code>. That is, it would have to generate a narrowing constraint that captures the full Boolean logic here in something like <code>(name is int AND result is list) OR (name is str AND result is dict)</code>. But no existing type checker can do this, and it's even hard to imagine how this could work.</p>
<p>So in summary, I think that SIM114 is indeed suggesting something problematic here. Determining the full set of cases where a transformation could lead to type checking problems seems ... difficult? A lot of conditions can lead to narrowing constraints, not just <code>isinstance</code> checks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-07 10:25</div>
            <div class="timeline-body"><p>FWIW: I also do not find the proposed rewrite by SIM114 here any simpler. It's slightly less repetitive, but it also feels less readable to me!</p>
<p>I don't think there's a great fix here. As @sharkdp says, the type-checking issue here is far from limited to just <code>isinstance()</code> conditions. Our best option may simply be to make sure the fix is always marked as unsafe, clearly document why the fix is always unsafe, and (in my opinion) clearly document that it's a somewhat opinionated rule that might not always &quot;simplify&quot; your code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-07 11:50</div>
            <div class="timeline-body"><p>I'm not sure if I want to extend fix safety to also cover possibility where it introduces type checker errors. I also don't think it helps here. The problem here isn't about the fix, it's about that there's a diagnostic in the first place.</p>
<p>I'm leaning towards documenting the possibility that this can introduce type checker errors, but otherwise, leave it as is. It's an opinionated rule and it's only a problem if you use a type checker (which will catch this for you!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-07 12:07</div>
            <div class="timeline-body"><p>I remember when we last discussed it internally, somebody suggested that we shouldn't be claiming that any autofix is &quot;safe&quot; unless we'd be happy for it to be automatically applied when saving the file. I certainly wouldn't be happy for a fix to be automatically applied when pressing &quot;save&quot; if it means that my code will no longer pass a type checker!</p>
<p>I agree that the bigger problem is that we ideally wouldn't issue a diagnostic at all if there's a possibility that the suggested rewrite would make it no longer type-check. But we agree that this would be very hard. Without that, I think it's probably better to say that users have to explicitly opt into the autofix, since there's a nontrivial chance the fix will turn CI checks red on their pull request.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:37:11 UTC
    </footer>
</body>
</html>
