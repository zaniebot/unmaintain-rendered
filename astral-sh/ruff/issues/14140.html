<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>False-positive TCH002 for runtime-required type annotations - astral-sh/ruff #14140</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>False-positive TCH002 for runtime-required type annotations</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/14140">#14140</a>
        opened by <a href="https://github.com/OlehChyhyryn">@OlehChyhyryn</a>
        on 2024-11-06 19:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/OlehChyhyryn">@OlehChyhyryn</a> on 2024-11-06 19:55</div>
            <div class="timeline-body"><p>In our project, we are using https://injector.readthedocs.io/en/latest/ library to implement dependency injection.</p>
<p>For proper workflow, it requires the following reference of injecting types:</p>
<pre><code>@inject
def fun(t: SomeType) -&gt; None:
    pass
    
# or equivalent

def fun(t: Inject[SomeType]) -&gt; None:
    pass
</code></pre>
<p>(link to the documentation - https://injector.readthedocs.io/en/latest/api.html#injector.Inject)</p>
<p>Both methods (type annotation and regular annotation) require that the context (<code>Inject</code> itself or any type underneath) be available during runtime.</p>
<p>According to the documentation, I added the required annotations to the <code>flake8-type-checking</code> configuration.</p>
<pre><code>[tool.ruff.lint.flake8-type-checking]
runtime-evaluated-base-classes = [
    &quot;pydantic.BaseModel&quot;,
    &quot;injector.Inject&quot;, # DI injection library
    &quot;injector.ClassAssistedBuilder&quot; # DI injection library
]
</code></pre>
<p>But it does not work as expected and returns false positive warnings.</p>
<p>You can reproduce it using the following sanitized sample:</p>
<pre><code>from __future__ import annotations

from typing import Any

from injector import Inject

from services.service_a import ServiceA
from services.service_b import ServiceB



class SomeTask:
    &quot;&quot;&quot;
    Task to pre-heat public URLs cache.
    &quot;&quot;&quot;

    def __init__(
        self,
        *args: Any,
        some_other_variable: str,
        service_a: Inject[ServiceA],
        service_b: Inject[ServiceB],
    ) -&gt; None:
        self._service_a = service_a
        self._service_b = service_b
        self._some_other_variable = some_other_variable

</code></pre>
<p>After running a ruff check for this file, I get the following response:</p>
<pre><code>sample_sanitized.py:24:22:   TCH002 Move third-party import `injector.Inject` into a type-checking block
   |
22 | from typing import Any
23 | 
24 | from injector import Inject
   |                      ^^^^^^ TCH002
25 | 
26 | from services.service_a import ServiceA
   |
   = help: Move into type-checking block

sample_sanitized.py:26:32: TCH002 Move third-party import `services.service_a.ServiceA` into a type-checking block
   |
24 | from injector import Inject
25 | 
26 | from services.service_a import ServiceA
   |                                ^^^^^^^^ TCH002
27 | from services.service_b import ServiceB
   |
   = help: Move into type-checking block

sample_sanitized.py:27:32: TCH002 Move third-party import `services.service_b.ServiceB` into a type-checking block
   |
26 | from services.service_a import ServiceA
27 | from services.service_b import ServiceB
   |                                ^^^^^^^^ TCH002
   |
   = help: Move into type-checking block

Found 3 errors.
No fixes available (3 hidden fixes can be enabled with the `--unsafe-fixes` option).
</code></pre>
<p>This issue is reproducible not only for exactly this library but for any typing annotations evaluated at runtime in similar fashion</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "False TCH002 for runtime-required type annotations" to "False-positive TCH002 for runtime-required type annotations" by @OlehChyhyryn on 2024-11-06 20:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-11-06 21:49</div>
            <div class="timeline-body"><p>Thanks for the nice write up!</p>
<p>This sounds related to https://github.com/astral-sh/ruff/issues/13713</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @MichaReiser on 2024-11-06 21:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-09 02:33</div>
            <div class="timeline-body"><p>Did you try using <a href="https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-decorators"><code>runtime-evaluated-decorators</code></a> with <code>injector.inject</code>? You might have better luck there. <code>runtime-evaluated-base-classes</code> definitely doesn't work for annotations (e.g., <code>Inject[SomeType]</code>); it's applied to the class body when the mentioned class is a base class.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/OlehChyhyryn">@OlehChyhyryn</a> on 2024-11-18 13:05</div>
            <div class="timeline-body"><p>Sorry, I was on vacation, so I could not answer quickly.</p>
<p>Yes, I tested this (and checked again today) and got the same result as I described in the issue description</p>
<p>UPD:</p>
<p>Let me check it with the 0.7.4 release</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/OlehChyhyryn">@OlehChyhyryn</a> on 2024-11-18 13:15</div>
            <div class="timeline-body"><p>Checked again against https://github.com/astral-sh/ruff/releases/tag/0.7.4</p>
<p>The same results were obtained after adding the following to the project.toml:</p>
<pre><code>[tool.ruff.lint.flake8-type-checking]
runtime-evaluated-base-classes = [
    &quot;pydantic.BaseModel&quot;,
    &quot;injector.Inject&quot;, # DI injection library
    &quot;injector.ClassAssistedBuilder&quot; # DI injection library
]
runtime-evaluated-decorators = [
    &quot;injector.Inject&quot;, # DI injection library
    &quot;injector.ClassAssistedBuilder&quot; # DI injection library
]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-18 13:43</div>
            <div class="timeline-body"><p>To clarify, I believe you want:</p>
<pre><code class="language-toml">[tool.ruff.lint.flake8-type-checking]
runtime-evaluated-decorators = [
    &quot;injector.inject&quot;,
]
</code></pre>
<p>Notice the lower-case <code>inject</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/OlehChyhyryn">@OlehChyhyryn</a> on 2024-11-18 15:31</div>
            <div class="timeline-body"><p>I checked again with this one. Still working not as intended:</p>
<p>I have specified pyproject.toml as</p>
<pre><code>[tool.ruff.lint.flake8-type-checking]
runtime-evaluated-base-classes = [
    &quot;injector.Inject&quot;, # DI injection library
    &quot;injector.ClassAssistedBuilder&quot;, # DI injection library
    &quot;injector.inject&quot;, # DI injection library
]
runtime-evaluated-decorators = [
    &quot;injector.inject&quot;, # DI injection library
    &quot;injector.Inject&quot;, # DI injection library
    &quot;injector.ClassAssistedBuilder&quot; # DI injection library
]
</code></pre>
<p>Checked for both versions of the declaration:</p>
<p><code>@annotation</code> scenario is working properly.</p>
<p>In a scenario where only typing annotation is used, e.g., Inject[ServiceA], the error still exists.</p>
<pre><code>from __future__ import annotations

from typing import Any

from injector import Inject
from services.service_a import ServiceA
from services.service_b import ServiceB


class SomeTask:
    &quot;&quot;&quot;
    Task to pre-heat public URLs cache.
    &quot;&quot;&quot;

    @inject
    def __init__(
        self,
        *args: Any,
        some_other_variable: str,
        service_a: Inject[ServiceA],
        service_b: Inject[ServiceB],
    ) -&gt; None:
        self._service_a = service_a
        self._service_b = service_b
        self._some_other_variable = some_other_variable
</code></pre>
<p>This one still generates false positives.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/OlehChyhyryn">@OlehChyhyryn</a> on 2025-03-18 20:21</div>
            <div class="timeline-body"><p>Sorry for bumping it up; the reference task (https://github.com/astral-sh/ruff/issues/13713) has been closed.</p>
<p>But this error (with runtime-required) annotation is still reproducible. I checked it with Ruff 0.11.0</p>
<pre><code>[tool.ruff.lint.flake8-type-checking]
# Add quotes around type annotations, if doing so would allow
# an import to be moved into a type-checking block.
quote-annotations = true
runtime-evaluated-base-classes = [
    &quot;injector.Inject&quot;, # DI injection library
]
exempt-modules = [&quot;injector&quot;]
</code></pre>
<pre><code>from __future__ import annotations

from typing import Any

from injector import Inject
from services.service_a import ServiceA
from services.service_b import ServiceB


class SomeTask:
    &quot;&quot;&quot;
    Task to pre-heat public URLs cache.
    &quot;&quot;&quot;

    def __init__(
        self,
        *args: Any,
        some_other_variable: str,
        service_a: Inject[ServiceA],
        service_b: Inject[ServiceB],
    ) -&gt; None:
        self._service_a = service_a
        self._service_b = service_b
        self._some_other_variable = some_other_variable
</code></pre>
<pre><code>src/example.py:3:20: TC003 Move standard library import `typing.Any` into a type-checking block
  |
1 | from __future__ import annotations
2 |
3 | from typing import Any
  |                    ^^^ TC003
4 |
5 | from injector import Inject
  |
  = help: Move into type-checking block

src/example.py:6:32: TC002 Move third-party import `services.service_a.ServiceA` into a type-checking block
  |
5 | from injector import Inject
6 | from services.service_a import ServiceA
  |                                ^^^^^^^^ TC002
7 | from services.service_b import ServiceB
  |
  = help: Move into type-checking block

src/example.py:7:32: TC002 Move third-party import `services.service_b.ServiceB` into a type-checking block
  |
5 | from injector import Inject
6 | from services.service_a import ServiceA
7 | from services.service_b import ServiceB
  |                                ^^^^^^^^ TC002
  |
  = help: Move into type-checking block

Found 3 errors.
No fixes available (3 hidden fixes can be enabled with the `--unsafe-fixes` option).
</code></pre>
<p>The expected behaviour of Injector type annotation is the fact annotation itself and everything under it I available in the runtime</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-18 21:30</div>
            <div class="timeline-body"><p>Thanks for the reminder. Here's a reproduction in the <a href="https://play.ruff.rs/8a302582-5c3a-4e9f-9f88-88d529ef9eaa">playground</a>, which might be a little easier for others to try out.</p>
<p>@Daverball do you know if this is resolved by any of your open PRs? I know you've been working on these rules and would know better than me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-03-18 21:48</div>
            <div class="timeline-body"><p>No, but it's tangentially related to one of my open issues, so I plan on tackling this issue eventually: #16412</p>
<p>We would definitely need a new setting, so we can treat certain generics as always runtime required.</p>
<p>What makes this particular case a lot trickier however, is that generally it would not be enough just to treat this generic and anything it encloses as runtime required, since most na√Øve uses of runtime type information will use <code>inspect.get_annotations</code> or <code>typing.get_type_hints</code> both of which will fail if not all the symbols in all of the annotations are available at runtime. This will change however in Python 3.14 with PEP 649, which allows partial evaluation of <code>__annotations__</code>, that replaces anything it can't resolve with a <code>ForwardRef</code> object. There are already some runtime type libraries that go out of their way to be more forgiving. So treating everything else as runtime required would not be entirely accurate either. Which is why I believe we would also need to mark those type expressions as runtime ambiguous, i.e. neither treating them as runtime required, nor typing only. This would also involve first having to peek at all of the annotations of a class or function definition so we can check whether or not there's a runtime required generic in play.</p>
<p>A workaround for this that currently works is to define a no-op decorator and add it to <code>runtime-evaluated-decorators</code>, so you can manually mark functions that contain annotations that are runtime required.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/omgMath">@omgMath</a> on 2025-10-20 07:04</div>
            <div class="timeline-body"><p>I think I have a very similar case in relation to <code>fastapi</code>: <a href="https://play.ruff.rs/80ba32e0-9946-4250-8392-24124f491981">Playground reproduction</a></p>
<p>The function is used like so</p>
<pre><code class="language-python">app.include_router(
    router,
    dependencies=[Depends(validate_is_readwrite)],
)
</code></pre>
<p>Somehow the <code>User</code> type is needed during runtime (e.g when accessing the swagger docs).
Would be cool if both the <code>inject</code> as well as this case could be fixed with the same setting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/extrange">@extrange</a> on 2025-11-01 08:44</div>
            <div class="timeline-body"><p>Just to add on, I'm seeing this issue in Pydantic as well, where the class is needed at runtime for validation of the <code>BaseModel</code>.</p>
<pre><code class="language-py">import pytest
from pydantic import BaseModel
from some_module import SomeClass # This cannot be moved to a TYPE_CHECKING block


class A(BaseModel):
    para: SomeClass
</code></pre>
<p><a href="https://play.ruff.rs/8d44bc90-2f58-470f-8801-d2f03a52f04a">Playground</a></p>
<p>Edit: fixed with <code>runtime-evaluated-base-classes</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2025-11-01 09:01</div>
            <div class="timeline-body"><p>@extrange You need to add <code>pydantic.BaseModel</code> to <code>runtime-evaluated-base-classes</code>, then it works as expected. Pydantic is unproblematic if all the required classes are listed in <code>runtime-evaluated-base-classes</code>, it's SQLAlchemy which doesn't quite work correctly whichever way you configure it.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:15 UTC
    </footer>
</body>
</html>
