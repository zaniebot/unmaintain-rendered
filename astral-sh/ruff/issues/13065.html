<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`incorrectly-parenthesized-tuple-in-subscript` (`RUF031`) - false positives with `parenthesize-tuple-in-subscript = true` on types outside of type annotations - astral-sh/ruff #13065</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>`incorrectly-parenthesized-tuple-in-subscript` (`RUF031`) - false positives with `parenthesize-tuple-in-subscript = true` on types outside of type annotations</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/13065">#13065</a>
        opened by <a href="https://github.com/DetachHead">@DetachHead</a>
        on 2024-08-23 01:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/DetachHead">@DetachHead</a> on 2024-08-23 01:30</div>
            <div class="timeline-body"><p>the fix for #12758 only fixed the issue for type annotations, but the generic syntax for types can appear outside of type annotations, eg:</p>
<pre><code class="language-py">foo: dict[str, int] = {&quot;a&quot;: 1} # no error
foo = dict[str, int](a=1) # RUF031: Use parentheses for tuples in subscripts.
</code></pre>
<p><a href="https://play.ruff.rs/0a3d1260-7a71-4c6f-867e-8d9c9c274b00">playground</a></p>
<p>i'm not sure how feasible it is to fix this without type checking (#3893), perhaps it could just assume any index access followed by a call is using a type</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2024-08-23 03:04</div>
            <div class="timeline-body"><p>Neat! This is tricky. Ignoring subscripts followed by calls would lead to false negatives for folks using a dispatch pattern:</p>
<pre><code class="language-python">dispatch = {(0,1): north, (1,0): east, (0,-1): south, (-1,0): west }
def walk(x,y,z):
    return dispatch[x,y](z)
</code></pre>
<p>Maybe there is some sneakier way of teasing out this generic type situation...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-23 04:27</div>
            <div class="timeline-body"><p>Yeah, I also think this is tricky without type inference. @DetachHead I'm curious to know how did you run into this, do you have an example of a real world code base?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by @dhruvmanila on 2024-08-23 04:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @dhruvmanila on 2024-08-23 04:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2024-08-23 04:44</div>
            <div class="timeline-body"><p>yeah there are about a hundred false positives in our codebase after enabling this rule. i haven't looked through all of them but it seems that most of them fall into one of the following scenarios:</p>
<ul>
<li><p>defining the type of an empty dict and populating it later:</p>
<pre><code class="language-py">foo = dict[str, int]()
...
foo[&quot;bar&quot;] = 1
</code></pre>
<p>an obvious workaround is to just do <code>foo: dict[str, int] = {}</code> but nevertheless this is still came from real world code (minified though because it's a private codebase)</p>
</li>
<li><p>defining the type of a <code>defaultdict</code> while instantiating it:</p>
<pre><code class="language-py">foo = defaultdict[str, list[str]](list)
</code></pre>
</li>
<li><p>type aliases that don't use the <code>TypeAlias</code> annotation:</p>
<pre><code class="language-py">Foo = Literal[&quot;a&quot;, &quot;b&quot;]
</code></pre>
</li>
</ul>
<p>all the examples i found use stdlib types so i guess in these cases they can be special-cased to reduce the risk of these false positives</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-23 04:48</div>
            <div class="timeline-body"><p>Interesting, thanks for sharing that. cc @AlexWaygood do you think it's currently feasible to resolve this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`incorrectly-parenthesized-tuple-in-subscript` (`RUF031`) with `parenthesize-tuple-in-subscript = true` false positives on types outside of type annotations" to "`incorrectly-parenthesized-tuple-in-subscript` (`RUF031`) - false positives with `parenthesize-tuple-in-subscript = true` on types outside of type annotations" by @DetachHead on 2024-08-23 04:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-23 12:49</div>
            <div class="timeline-body"><p>Hrm, this is hard!</p>
<p>For your three bullets in https://github.com/astral-sh/ruff/issues/13065#issuecomment-2306282918: bullets (1) and (2) would be easy with type inference; we could just check to see if the subscripted object was a type that had <code>__class_getitem__</code> defined.</p>
<p>Bullet point 3 (detecting whether an assignment not annotated using <code>TypeAlias</code> is intended to be a runtime value or a type alias) would be hard even with type inference. It was for this very reason that <code>typing.TypeAlias</code> (backported as <code>typing_extensions.TypeAlias</code>) was introduced.</p>
<p>I can see several options, none perfect:</p>
<ol>
<li>Ignore the rule for call expressions when <code>lint.ruff.parenthesize-tuple-in-subscript = true</code>. This would reduce false positives but it wouldn't get rid of them, and would also introduce false negatives.</li>
<li>Special-case symbols from <code>builtins</code> and the <code>typing</code> module. And maybe other standard-library modules? It would reduce false positives, but again wouldn't get rid of them; there are lots of third-party generic types, after all.</li>
<li>Add a prominent warning to the docs that setting <code>lint.ruff.parenthesize-tuple-in-subscript = true</code> may lead to a lot of false positives if your code is heavily typed.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BarrensZeppelin">@BarrensZeppelin</a> on 2024-09-04 06:33</div>
            <div class="timeline-body"><p>Hi, I can chime in with another data point.
In my code base I have 21 false positives from this rule.</p>
<ul>
<li>14 instances are from creating empty dictionaries (or <code>defaultdict</code> / <code>WeakKeyDictionary</code>): <code>dict[int, str]()</code></li>
<li>3 instances stem from converting a list to a tuple with known length: <code>tuple[int, int, int](my_list)</code>.</li>
<li>2 instances occur in interfacing with pydantic:
<code>Adapter = TypeAdapter(dict[str, list[str]])</code>
<code>MyID = Annotated[str, AfterValidator(_check_id)]</code></li>
<li>1 instance occurs in the value for <code>default_factory</code> for a <code>dataclasses.field</code>:
<code>_cache: Final = field(default_factory=dict[str, CachedObject], init=False)</code></li>
<li>1 instance occurs when creating a type alias for a collection of literal strings without the <code>TypeAlias</code> annotation:
<code>MyStrings = Literal[&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2024-09-04 13:10</div>
            <div class="timeline-body"><p>Maybe in the short term I can try to disable the rule for calls on builtin types like dict and tuple since I think there is some support for that. I also think it's worth the potential false negative to disable the rule for &quot;Literal&quot; since I doubt many people are shadowing that name and subscripting with it - plus <code>Literal</code> appears to be an instance where parentheses are explicitly disallowed, so it's a bit more dangerous of a false positive.</p>
<p>But I'll wait for the green light from the maintainers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-04 13:14</div>
            <div class="timeline-body"><blockquote>
<p>plus <code>Literal</code> appears to be an instance where parentheses are explicitly disallowed, so it's a bit more dangerous of a false positive.</p>
</blockquote>
<p>hmm, is that true? Type checkers like mypy just read the AST, and <code>Literal[1, 2]</code> has the same AST in CPython as <code>Literal[(1, 2)]</code>, so it would be a hard rule for mypy to enforce. (Ruff's AST preserves whether or not a tuple is parenthesized, but most Python ASTs do not!) Mypy <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=2e781f45e1deb41deeb695e92e94d178">seems to cope fine</a> with <code>Literal[(1, 2)]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2024-09-04 13:18</div>
            <div class="timeline-body"><p>See https://peps.python.org/pep-0586/#illegal-parameters-for-literal-at-type-check-time</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-04 13:20</div>
            <div class="timeline-body"><blockquote>
<p>See <a href="https://peps.python.org/pep-0586/#illegal-parameters-for-literal-at-type-check-time">peps.python.org/pep-0586#illegal-parameters-for-literal-at-type-check-time</a></p>
</blockquote>
<p>TIL! And pyright appears to enforce that rule, too. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/15264.html">astral-sh/ruff#15264</a> on 2025-01-05 03:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @dylwil3 by @dylwil3 on 2025-01-07 18:21</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:53 UTC
    </footer>
</body>
</html>
