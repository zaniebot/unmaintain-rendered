<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add the special logic for int/float/complex in annotations - astral-sh/ruff #14932</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add the special logic for int/float/complex in annotations</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/14932">#14932</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-12-12 11:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-12 11:11</div>
            <div class="timeline-body"><p>Given this Python function:</p>
<pre><code class="language-py">def f(x: float = 42): ...
</code></pre>
<p>red-knot currently issues this complaint:</p>
<pre><code>error[lint:invalid-parameter-default] /Users/alexw/dev/experiment/foo.py:1:7 Default value of type `Literal[42]` is not assignable to annotated parameter type `float`
</code></pre>
<p>This is incorrect. Although <code>Literal[42]</code> is not a subtype of <code>float</code>, the typing spec <a href="https://typing.readthedocs.io/en/latest/spec/special-types.html#special-cases-for-float-and-complex">carves out a special case for numeric types</a> when used specifically in function parameter annotations:</p>
<blockquote>
<p>Pythonâ€™s numeric types <code>complex</code>, <code>float</code> and <code>int</code> are not subtypes of each other, but to support common use cases, the type system contains a straightforward shortcut: when an argument is annotated as having type <code>float</code>, an argument of type <code>int</code> is acceptable; similar, for an argument annotated as having type <code>complex</code>, arguments of type <code>float</code> or <code>int</code> are acceptable.</p>
</blockquote>
<p>We need to implement this special case to avoid false-positive errors like the one above. Note that the special case <em>only</em> applies in function parameter annotations, <em>not</em> in any other context. Note also that <em>all subtypes</em> of <code>int</code> should also be considered assignable to <code>float</code> (and, transitively, <code>complex</code>) in this context: <code>Literal[42]</code>, <code>bool</code> and <code>Literal[True]</code> are also therefore assignable to <code>float</code> and <code>complex</code> in the context of parameter annotations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @AlexWaygood on 2024-12-12 11:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-12-12 11:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-12 12:15</div>
            <div class="timeline-body"><p>Wow interesting. Should we add an optional rule that warns about such &quot;incompatible&quot; default values? I don't think I'd want that behavior ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-12 12:17</div>
            <div class="timeline-body"><blockquote>
<p>Should we add an optional rule that warns about such &quot;incompatible&quot; default values? I don't think I'd want that behavior ðŸ˜†</p>
</blockquote>
<p>It would conflict with https://docs.astral.sh/ruff/rules/redundant-numeric-union/ ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-12 12:18</div>
            <div class="timeline-body"><p>I suppose we could make that rule configurable so that you can &quot;reverse&quot; the behaviour and enforce the opposite...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-12-12 14:35</div>
            <div class="timeline-body"><blockquote>
<p>Note that the special case <em>only</em> applies in function parameter annotations, <em>not</em> in any other context.</p>
</blockquote>
<p>Really? So <code>def f(x: float = 0): ...</code> is okay, but</p>
<pre><code class="language-py">x: float = 0
</code></pre>
<p>is not?</p>
<p>This seems inconsistent to me. Neither mypy nor pyright have this behavior. https://mypy.readthedocs.io/en/stable/duck_type_compatibility.html#duck-type-compatibility. Does the wording in the spec maybe predate variable annotations or is this really what the spec intends? Why?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-12-12 14:41</div>
            <div class="timeline-body"><p>Oh, this seems relevant ðŸ˜„: https://github.com/python/typing/issues/1746</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-12 14:45</div>
            <div class="timeline-body"><p>The spec as a whole is very new and long post-dates variable annotations, but this special case does indeed long predate variable annotations (it <a href="https://peps.python.org/pep-0484/#the-numeric-tower">was introduced by PEP 484</a>).</p>
<p>You're correct that mypy and pyright do sometimes extend this behaviour to other contexts. It can be pretty inconsistent and surprising when they do, however! For example:</p>
<pre><code class="language-py">x: float = 0

reveal_type(x)  # mypy: float

if isinstance(x, int):
    reveal_type(x)  # mypy: int (not Never? Or &lt;subclass of int and float&gt;? Huh?)
else:
    reveal_type(x)  # revealed: float
</code></pre>
<p>I.e., I believe mypy when mypy sees <code>float</code> as an annotation it <em>actually</em> constructs an <code>int | float</code> pseudo-union behind the scenes.</p>
<p>All of this is underspecified and we can defer a lot of it. But the behaviour for parameter annotations specifically <em>is</em> well-specified and important -- and our lack of support for it is causing false positives now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-14 00:51</div>
            <div class="timeline-body"><blockquote>
<p>You're correct that mypy and pyright do sometimes extend this behaviour to other contexts. It can be pretty inconsistent and surprising when they do, however! For example:</p>
</blockquote>
<p>The odd behavior you point out here is inherent to the special case, and the way mypy implements it; it's not related to applying the special case to variable annotations. Exactly the same behavior appears with a function parameter annotation, too: https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=d1d1c0ed731ca0afe425f427fbb7e302</p>
<p>I think the <em>only</em> reason the spec implies this is only for parameter annotations is because the text predates variable annotations; I don't believe there is any good reason to limit it to parameter annotations, nor does any existing type checker do that. So I don't believe we should do so either.</p>
<blockquote>
<p>I believe mypy when mypy sees <code>float</code> as an annotation it <em>actually</em> constructs an <code>int | float</code> pseudo-union behind the scenes.</p>
</blockquote>
<p>Yes, I think this is right; and pyright does this too. I think this is the best way to implement this special case, as compared to the alternative of actually treating <code>int</code> as a subtype of <code>float</code>, which is problematic because <code>int</code> doesn't preserve Liskov relative to <code>float</code>. Applying it as a special case in the interpretation of the annotation <code>float</code> limits the scope of the special case, and means you can still infer a more precise type of &quot;float but not int&quot;, which would not be possible if <code>int</code> were treated generally as a subtype of <code>float</code>. Based on previous discussions, I think if/when we do clarify the spec, we will specify this &quot;treat <code>float</code> annotation as <code>int | float</code>&quot; behavior.</p>
<p>The strangeness you observe in the above example really comes entirely from the fact that mypy tries to &quot;hide&quot; this implicit <code>int | float</code> union type, and display it as <code>float</code>. This means that a display type of <code>float</code> might be &quot;actually just float&quot; or might be &quot;implicit int | float&quot; -- the type display doesn't allow you to tell which it is. And in your example, it's the implicit union in the first <code>reveal_type</code>, and actually-just-float in the third. Once you recognize that, everything in that example makes perfect sense (except, of course, the fact that <code>float</code> means <code>int | float</code> in the first place!).</p>
<p>My feeling is that we should treat a <code>float</code> annotation as <code>int | float</code> (in any annotation, not just function parameter annotations), and that unlike mypy, we should not try to hide this from the user. Yes, it might be confusing for the user to annotate something as <code>float</code> and later see it revealed as <code>int | float</code>, but it's more confusing to have two different types both reveal as <code>float</code>. The special case exists, we can't get rid of it, let's embrace it and not try to hide it.</p>
<p>It's possible this will get us in trouble with overly-aggressive use of <code>reveal_type</code> or <code>assert_type</code> expecting the display name <code>float</code> for the implicit union in the conformance suite, but I'll be happy to advocate for changing the conformance suite so it doesn't require hiding this <code>int | float</code> union.</p>
<p>(Also of course we must treat an annotation of <code>complex</code> as <code>int | float | complex</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Add the special assignability logic for int/float/complex in parameter annotations" to "[red-knot] Add the special assignability logic for int/float/complex in annotations" by @carljm on 2024-12-14 00:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Add the special assignability logic for int/float/complex in annotations" to "[red-knot] Add the special logic for int/float/complex in annotations" by @carljm on 2024-12-14 00:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-14 14:34</div>
            <div class="timeline-body"><p>Thanks @carljm. That all sounds reasonable to me, except for the fact that it does mean there's no way to express in a stub file, for example, that an instance attribute really will be exactly a <code>float</code> (no union type required!). Whether that's actually an issue in practice, though, I'm not sure -- perhaps not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-14 14:39</div>
            <div class="timeline-body"><p>And from the perspective of <em>users</em>, I would encourage them to only <em>make use</em> of the special case in parameter annotations. The intuition that led to this special case was that &quot;nearly all functions that accept floats will also work fine with ints in practice&quot; -- for all the flaws of the special case (and there are many! if only Python had a better runtime numeric tower so we didn't have to hack around it in the type system) it does make parameter annotations a lot less fiddly in many situations. But I don't think there's nearly the same benefits for users outside of the context of parameter annotations.</p>
<p>This isn't an argument against what you're saying -- I agree consistent behaviour is probably more important here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-14 15:53</div>
            <div class="timeline-body"><blockquote>
<p>it does mean there's no way to express in a stub file, for example, that an instance attribute really will be exactly a float</p>
</blockquote>
<p>Yeah, this is the main downside of the special case. If we had intersections you could say <code>float &amp; ~int</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/9810.html">astral-sh/ruff#9810</a> on 2025-01-08 10:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Red Knot Q1 2025" by @carljm on 2025-01-09 18:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jorenham">@jorenham</a> on 2025-01-15 18:53</div>
            <div class="timeline-body"><p>for those that don't like such &quot;type promotion&quot; rules, there's a way to work around it:</p>
<pre><code class="language-py">class Just[T](Protocol):
    @property
    def __class__(self, /) -&gt; type[T]: ...
    @__class__.setter
    def __class__(self, t: type[T], /) -&gt; None: ...


def assert_float(x: Just[float]) -&gt; float:
    assert type(x) is float
    return x


assert_float(object())  # rejected
assert_float(3.14)  # accepted
assert_float(42)  # rejected
</code></pre>
<p>There's a (tested) implementation of this in <code>optype</code>, including several aliases like <code>JustFloat</code> and <code>JustInt</code> (<a href="https://github.com/jorenham/optype#just-types">docs</a>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-15 19:48</div>
            <div class="timeline-body"><p>That's an impressive workaround! I wonder what you mean by &quot;tested&quot;, though, because as far as I can see it doesn't work in either <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=5e5a1f54ed092f9c141d6eae38c8b018">mypy</a> or <a href="https://pyright-play.net/?code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAK4MYAxmADYBQVpFAhgM6NQBSArozANoAqAugAoiYEuQoBKAFxUocqAAEE4BAFM8cWfIAmq4FAD6Buk0ZHBjVRWAAaKAHoJUALQA%2BWIlV9%2BUqADoArTkFIxNmIz9LGBh1IKhdfVCGcIMLK1tYX3g1bztHF3cAOTAUVV8AvxoqBKhTdRgDYAowehhBAA9fDi5uJpaYfic3KD7WmXla5nqPNQ6nJBZRmDiQVRh2EBQodqq6vEbm1sEwACMAK1VSNoknKABiKFWLq9VtKj2GpcEAZj8ARgALLcHvRSKRVAgYm8Pgd%2BoIAQAmYGPVTPKFAA">pyright</a> -- both seem to complain about the Protocol definition in the first place (because it defines <code>__class__</code> in a way that isn't LSP-compatible with the definition of <code>object.__class__</code> in typeshed), and neither reject <code>assert_float(42)</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jorenham">@jorenham</a> on 2025-01-15 20:02</div>
            <div class="timeline-body"><p>@carljm mypy has a <a href="https://github.com/python/mypy/issues/18257">bug</a> that's causing the <code>Just[float]</code> to be ignored, but that has beewn fixed in https://github.com/python/mypy/pull/18360, and will be in the upcoming release I believe.</p>
<p>And yes, my example is missing some <code># type: ignore</code> comments in the protocol definition for it to validate.</p>
<p>The type-tests for it can be found <a href="https://github.com/jorenham/optype/blob/master/tests/test_typing.py#L203-L273">here</a>, and the implementation <a href="https://github.com/jorenham/optype/blob/master/optype/typing.py#L73-L166">here</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/16166.html">astral-sh/ruff#16166</a> on 2025-02-14 19:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-02-14 20:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-02-14 20:24</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:54 UTC
    </footer>
</body>
</html>
