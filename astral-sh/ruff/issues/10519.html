<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Folder with module name detected as source leads to false `I001` error - astral-sh/ruff #10519</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Folder with module name detected as source leads to false <code>I001</code> error</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/10519">#10519</a>
        opened by <a href="https://github.com/carschno">@carschno</a>
        on 2024-03-22 08:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carschno">@carschno</a></div>
            <div class="timeline-body">

<p>This issue affects the expected sorting of imports in Python and hence (incorrectly) triggers a <code>I001</code> error.</p>
<p>When there is a folder that has the same name as a module, it is (possibly incorrectly) identified as <code>SourceMatch</code>. Ruff then categorizes the module as <code>Known(FirstParty)</code> and adapts the expected sorting accordingly.</p>
<p>This happens commonly, but not exclusively, when using the <a href="https://docs.wandb.ai/ref/python/">wandb library</a> because it creates a <code>wandb</code> folder, as discovered in <a href="https://github.com/ChartBoost/ruff-action/issues/20">ChartBoost/ruff-action#20</a>.</p>
<p>To reproduce the issue, create a Python file with these imports (I called it <code>test.py</code>):</p>
<pre><code>import csv
import logging
import random
import sys
from typing import Any, Optional, TextIO

import torch
import torch.nn as nn
from torch import optim
from torcheval.metrics import (
    Metric,
    MulticlassAccuracy,
    MulticlassF1Score,
    MulticlassPrecision,
    MulticlassRecall,
)
from tqdm import tqdm

import wandb
</code></pre>
<p>In the initial scenario, there is a <code>wandb</code> directory:</p>
<pre><code>% ls -d wandb/
wandb/
</code></pre>
<p>Running Ruff to check the import sorting:</p>
<pre><code>% poetry run ruff check -v --select=I001 test.py                                            
[2024-03-22][08:57:28][ruff::resolve][DEBUG] Using configuration file (via parent) at: /Users/carstenschnober/LAHTeR/workspace/document-segmentation/pyproject.toml
[2024-03-22][08:57:28][ruff::commands::check][DEBUG] Identified files to lint in: 2.013375ms
[2024-03-22][08:57:28][ruff::diagnostics][DEBUG] Checking: /Users/carstenschnober/LAHTeR/workspace/document-segmentation/test.py
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torch.nn&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;csv&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;random&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;sys&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;logging&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torch&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;wandb&#x27; as Known(FirstParty) (SourceMatch(&quot;/Users/carstenschnober/LAHTeR/workspace/document-segmentation&quot;))
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torch&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torcheval.metrics&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;typing&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][08:57:28][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;tqdm&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][08:57:28][ruff::commands::check][DEBUG] Checked 1 files in: 765.709¬µs
All checks passed!
</code></pre>
<p>The checks pass, <code>wandb</code> has been categorized as <code>Known(FirstParty)</code></p>
<p>Now remove the <code>wandb</code> directory:</p>
<pre><code>% mv wandb wandb.bak
% ls -d wandb/
ls: wandb/: No such file or directory
</code></pre>
<p>Running the same Ruff check triggers a <code>I001</code> error on the same file, categorizing <code>wandb</code> as <code>Known(ThirdParty)</code>; the module categorization is cached, so I remove the <code>.ruff_cache</code> directory first to reproduce the error:</p>
<pre><code>% rm -r .ruff_cache                             
% poetry run ruff check -v --select=I001 test.py
[2024-03-22][09:06:42][ruff::resolve][DEBUG] Using configuration file (via parent) at: /Users/carstenschnober/LAHTeR/workspace/document-segmentation/pyproject.toml
[2024-03-22][09:06:42][ruff::commands::check][DEBUG] Identified files to lint in: 1.959083ms
[2024-03-22][09:06:42][ruff::diagnostics][DEBUG] Checking: /Users/carstenschnober/LAHTeR/workspace/document-segmentation/test.py
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torch.nn&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;csv&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;random&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;sys&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;logging&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torch&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;wandb&#x27; as Known(FirstParty) (SourceMatch(&quot;/Users/carstenschnober/LAHTeR/workspace/document-segmentation&quot;))
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torch&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;torcheval.metrics&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;typing&#x27; as Known(StandardLibrary) (KnownStandardLibrary)
[2024-03-22][09:06:42][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;tqdm&#x27; as Known(ThirdParty) (NoMatch)
[2024-03-22][09:06:42][ruff::commands::check][DEBUG] Checked 1 files in: 1.004834ms
test.py:1:1: I001 [*] Import block is un-sorted or un-formatted
Found 1 error.
[*] 1 fixable with the `--fix` option.
</code></pre>
<p>This is now the expected sorting that is generated when calling <code>ruff --fix</code> call above:</p>
<pre><code>import csv
import logging
import random
import sys
from typing import Any, Optional, TextIO

import torch
import torch.nn as nn
import wandb
from torch import optim
from torcheval.metrics import (
    Metric,
    MulticlassAccuracy,
    MulticlassF1Score,
    MulticlassPrecision,
    MulticlassRecall,
)
from tqdm import tqdm
</code></pre>
<p>This configuration option fixes the issue properly (see <a href="https://github.com/ChartBoost/ruff-action/issues/20">ChartBoost/ruff-action#20</a>#issuecomment-2012747916):</p>
<pre><code>[tool.ruff.lint.isort]
known-third-party = [&quot;wandb&quot;]
</code></pre>
<p>However, it is difficult for users to identify the issue and fix the configuration accordingly. I think a better solution would be to have a more robust source directory detection.
A heuristics like checking for <code>__init__.py</code> or generally the presence of <code>*.py</code> files as a condition might be a solid starting point for Python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Folder with module name detected as source&quot; to &quot;Folder with module name detected as source leads to false `I001` error&quot; by <a href="https://github.com/carschno">@carschno</a> on 2024-03-24 11:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-03-24 20:00</div>
            <div class="timeline-body"><p>We could consider requiring an <code>__init__.py</code> but it would be a breaking change, I think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">isort</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-03-24 20:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carschno">@carschno</a> on 2024-03-25 08:21</div>
            <div class="timeline-body"><blockquote>
<p>We could consider requiring an <code>__init__.py</code> but it would be a breaking change, I think.</p>
</blockquote>
<p>I see how a folder that is now correctly categorized as a source folder might not have an <code>__init__.py</code> in some cases, so this requirement could perhaps be something for the next major release indeed.</p>
<p>If a source folder is required to contain any <code>*.py</code> file, however, I cannot see how it would break current behaviour -- except for cases in which the sorting has now been incorrectly adapted to identified source folders.
So perhaps requiring any <code>.py</code> file could be an intermediate fix, whereas the next major release requires an <code>__init__.py</code>?</p>
<p>If somebody could point me to the relevant source code, I could try and work on a PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bkad">@bkad</a> on 2024-04-04 00:37</div>
            <div class="timeline-body"><blockquote>
<p>Running the same Ruff check triggers a I001 error on the same file, categorizing wandb as Known(ThirdParty); the module categorization is cached, so I remove the .ruff_cache directory first to reproduce the error</p>
</blockquote>
<p>Shouldn&#x27;t the removal of the wandb directory be enough to invalidate the module categorization cache? The fact that you need to manually remove the cache to get the correct results also seems wrong.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-04 00:44</div>
            <div class="timeline-body"><p>Diagnostics are cached on a per-file basis, where the &quot;file&quot; is the file in which the diagnostic is present. Changing <em>other</em> files on the filesystem doesn&#x27;t invalidate the cache.</p>
<p>Changing the <em>settings</em> will also invalidate the cache. So if you add <code>wandb</code> as a <code>known-third-party</code> module (which is the suggested change), it will also reflect that change on re-run without clearing the cache mnanually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bkad">@bkad</a> on 2024-04-04 01:17</div>
            <div class="timeline-body"><p>Say you were using a third party package in your requirements, but decided later to vendor it to make changes, turning it into a first party package. Then unless caches were manually cleaned you would get incorrect results from the isort check. Even worse, they could be inconsistent with CI checks, which can cause a lot of confusion. We ran into an issue like this today, and had to turn off caching as a result.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carschno">@carschno</a> on 2024-04-04 07:18</div>
            <div class="timeline-body"><blockquote>
<p>Say you were using a third party package in your requirements, but decided later to vendor it to make changes, turning it into a first party package. Then unless caches were manually cleaned you would get incorrect results from the isort check. Even worse, they could be inconsistent with CI checks, which can cause a lot of confusion. We ran into an issue like this today, and had to turn off caching as a result.</p>
</blockquote>
<p>Honestly, I think this should be a separate issue about caching. It is only related in the sense that caching must somehow also handle the detection of third party folders. But if you propose improvements in the caching logic, I think it would make sense to do this separately from this issue (detection of source folders).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-04-04 07:50</div>
            <div class="timeline-body"><p>We&#x27;re looking into changing how we cache data as part of our multifile analysis work. It will allow us to invalidate caches based on dependencies.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/angerhang">@angerhang</a> on 2025-01-28 13:19</div>
            <div class="timeline-body"><p>I would echo the same concern, it is really difficult for the end-users to pick up the error.</p>
<p>I had the same issue when using <code>wandb</code>. I ensured my local and remote CI tests have consistent environments but the differences still persist until I realised that a local folder name <code>wandb</code> is created.</p>
<p>Better error message is needed if we can&#x27;t have a quick fix easily.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-26 09:10</div>
            <div class="timeline-body"><p>We should prioritize resolving this issue. There is a known workaround, but it comes up regularly, and reproducing it is a ton of work for users (and us).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">priority:medium</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-26 12:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-23 19:47</div>
            <div class="timeline-body"><p>@dylwil3 do you have any ideas on how we could improve the <code>wandb</code> case described here? What I understand is that your most recent change won&#x27;t help with this because it will still consider <code>wandb</code> as a possible namespace package (which is correct because Python would do the same)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carschno">@carschno</a> on 2025-04-24 11:17</div>
            <div class="timeline-body"><p>A slightly naive workaround would be to provide a default list of known third parties, including <code>wandb</code> for this specific issue. I see two downsides of such a list:</p>
<ol>
<li>Adding maintenance effort</li>
<li>Not necessarily expected behaviour for new users</li>
</ol>
<p>However, I don&#x27;t see a generalizable solution, so perhaps such a specific list would be a starting point until it grows to an unmaintainable scale.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tboddyspargo">@tboddyspargo</a> on 2025-04-24 15:55</div>
            <div class="timeline-body"><blockquote>
<p>If a source folder is required to contain any <code>*.py</code> file, however, I cannot see how it would break current behaviour -- except for cases in which the sorting has now been incorrectly adapted to identified source folders. So perhaps requiring any <code>.py</code> file could be an intermediate fix, whereas the next major release requires an <code>__init__.py</code>?</p>
<p>If somebody could point me to the relevant source code, I could try and work on a PR.</p>
</blockquote>
<p>Is this (requiring any <code>.py</code> file) a viable option? Perhaps I missed some discussion around this, but it sounded reasonable to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-24 15:59</div>
            <div class="timeline-body"><blockquote>
<p>Is this (requiring any .py file) a viable option? Perhaps I missed some discussion around this, but it sounded reasonable to me.</p>
</blockquote>
<p>The problem with this is that Python doesn&#x27;t require a <code>.py</code> file to consider a folder as a namespace package. But @dylwil3 has more details on the why</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tboddyspargo">@tboddyspargo</a> on 2025-04-24 18:58</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>Is this (requiring any .py file) a viable option? Perhaps I missed some discussion around this, but it sounded reasonable to me.</p>
</blockquote>
<p>The problem with this is that Python doesn&#x27;t require a <code>.py</code> file to consider a folder as a namespace package. But <a href="https://github.com/dylwil3">@dylwil3</a> has more details on the why</p>
</blockquote>
<p>Does it still require <code>.py</code> files somewhere in the hierarchy because if it&#x27;s a candidate for a <code>namespace</code> package, presumably we&#x27;d have to look for files lower down to find out where the namespace package begins. Or are we constrained to looking at only immediate children <code>.py</code> files of the directory in question?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-04-24 19:18</div>
            <div class="timeline-body"><blockquote>
<p>Does it still require .py files somewhere in the hierarchy because if it&#x27;s a candidate for a namespace package, presumably we&#x27;d have to look for files lower down to find out where the namespace package begins. Or are we constrained to looking at only immediate children .py files of the directory in question?</p>
</blockquote>
<p>I think this is worth considering as sort of a compromise between how Python technically resolves the module and how the user&#x27;s would expect (for the purposes of sorting). In theory it may have a performance impact if someone has a heavily nested non-Python folder that shares the name of a package.</p>
<p>Also I&#x27;m working on a longer response here to try to explain what&#x27;s strange about the relationship between Python&#x27;s module resolution and the notion of &quot;first party&quot; in import sorting - hopefully that can help clear some things up... or make everyone more confused, we&#x27;ll see!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mickvangelderen">@mickvangelderen</a> on 2025-04-25 17:57</div>
            <div class="timeline-body"><p>This cost me half an hour today. I find it particularly surprising that ignored folders influence the categorization.</p>
<pre><code>‚ùØ uv run ruff check --verbose . --select I --fix 2&gt;&amp;1 | grep flask_session
[2025-04-25][10:55:45][ignore::walk][DEBUG] ignoring &lt;PROJECT_DIR&gt;/flask_session: Ignore(IgnoreMatch(Gitignore(Glob { from: Some(&quot;&lt;PROJECT_DIR&gt;/.gitignore&quot;), original: &quot;/flask_session/&quot;, actual: &quot;flask_session&quot;, is_whitelist: false, is_only_dir: true })))
[2025-04-25][10:55:45][ruff_linter::rules::isort::categorize][DEBUG] Categorized &#x27;flask_session&#x27; as Known(FirstParty) (SourceMatch(&quot;&lt;PROJECT_DIR&gt;&quot;))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jonathanunderwood">@jonathanunderwood</a> on 2025-08-04 06:41</div>
            <div class="timeline-body"><p>I just hit this today and it had me head scratching for a while. As an extra data point, isort doesn&#x27;t exhibit this behaviour, and correctly detects first/third party related ordering, and so digging into isort&#x27;s heuristics will likely help, though I haven&#x27;t had time to do that yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-08-04 13:34</div>
            <div class="timeline-body"><p>@jonathanunderwood sorry to hear that! Could you help me reproduce this by describing the directory structure/imports where <code>ruff</code> and <code>isort</code> differ? As far as I know <code>isort</code> also suffers from the sort of dilemma in this thread - see, e.g.</p>
<ul>
<li>https://github.com/PyCQA/isort/issues/1619</li>
<li>https://github.com/PyCQA/isort/issues/2143</li>
<li>https://github.com/PyCQA/isort/issues/2101</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-08-07 12:51</div>
            <div class="timeline-body"><p>A short-term workaround could be to add <code>wandb</code> to the <code>known_third_party</code> defaults, as this appears to be the cause of the confusing behavior for most users. Wdyt @dylwil3 ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carschno">@carschno</a> on 2025-08-29 14:02</div>
            <div class="timeline-body"><blockquote>
<p>A short-term workaround could be to add <code>wandb</code> to the <code>known_third_party</code> defaults, as this appears to be the cause of the confusing behavior for most users. Wdyt <a href="https://github.com/dylwil3">@dylwil3</a> ?</p>
</blockquote>
<p>That was my suggestion <a href="https://github.com/astral-sh/ruff/issues/10519#issuecomment-2827245863">above</a>. While the downside (maintenance) remains, a more generic solution does not seem available.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jbcoe">@jbcoe</a> on 2025-08-29 14:25</div>
            <div class="timeline-body"><p>I wonder if skipping folders that are ignored by git (optionally) might be a nice generic fix for avoiding temporary files?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-09-09 13:07</div>
            <div class="timeline-body"><blockquote>
<p>A short-term workaround could be to add <code>wandb</code> to the <code>known_third_party</code> defaults, as this appears to be the cause of the confusing behavior for most users. Wdyt <a href="https://github.com/dylwil3">@dylwil3</a> ?</p>
</blockquote>
<p>Yeah I think we should do this - I&#x27;ll make a PR!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vadimkantorov">@vadimkantorov</a> on 2025-11-28 22:23</div>
            <div class="timeline-body"><p>IMO it can easily happen with some other python packages, and it will be equally confusing to debug. I suggest adding an option to somehow adjust how a package is treated local or not. And maybe somehow make isort variant which will not be dependent on local-ness of the module (and existence of any name-matching dirs) at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-11-28 22:27</div>
            <div class="timeline-body"><p>If you want to &quot;not depend on local-ness&quot;, you can just remove the first-party and local sections -- this already exists:</p>
<pre><code>[lint.isort]
section-order = [
    &quot;future&quot;,
    &quot;standard-library&quot;,
    &quot;third-party&quot;,
]
</code></pre>
<p>Then all first-party and third-party imports will be grouped together.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-28 22:28</div>
            <div class="timeline-body"><p>You can use <a href="https://docs.astral.sh/ruff/settings/#lint_isort_no-sections">no-sections</a> if you don&#x27;t want isort to distinguish between first and third party packages</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vadimkantorov">@vadimkantorov</a> on 2025-11-28 22:42</div>
            <div class="timeline-body"><p>This should help, thanks! Would be nice to maybe make a better default specifically for local dirs: e.g. when package exists both as third-party and as a local dir - do not propose import order fixes, and do not propose moving it out of the third-party section.</p>
<p>It should be relatively less common these days to intentionally actually have a local dir package to shadow a global package (given that these days it&#x27;s so simple to have venvs, so it&#x27;s easy to not put unneded global packages into the env in the first place). So maybe if a package exists as both third-party and local - actually consider it third-party.</p>
<p>And also, somehow python itself doesn&#x27;t get confused and still loads the global wandb, and not breaks saying that the local folder <code>wandb</code> doesn&#x27;t contain anything loadable. But maybe it requires more sophisticated resolution logic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-11-29 01:26</div>
            <div class="timeline-body"><blockquote>
<p>when package exists both as third-party and as a local dir - do not propose import order fixes, and do not propose moving it out of the third-party section.</p>
</blockquote>
<p>Ruff does not really have a way of knowing what third-party means beyond &quot;not first party&quot;, essentially. That is: Ruff does not know what packages you have declared in your <code>pyproject.toml</code>, nor does it look for a virtual environment or anything like that.</p>
<p>One of the big ironies of import sorting is that it <em>feels</em> like it should belong to the formatter, but when you look at the information it would need to understand in order to match user&#x27;s expectations for first/third-party, it really needs to belong to something closer to a type checker or a package manager.</p>
<p>If only some organization built a formatter, package manager, <em>and</em> a type checker üòÑ</p>
<p>See #21520 for a possible way forward on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vadimkantorov">@vadimkantorov</a> on 2025-11-29 03:17</div>
            <div class="timeline-body"><p>Maybe making a heuristic, that a directory without <code>__init__.py</code> or without any python files considered not-first-party? How does Python itself decide that it should skip the local wandb dir?</p>
<p>I think the main problem here is coming up with a default setting which does not depend on existence of local folders and on CI / no-CI env... And it&#x27;s really a painful thing to debug :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-11-29 13:39</div>
            <div class="timeline-body"><blockquote>
<p>Maybe making a heuristic, that a directory without <strong>init</strong>.py or without any python files considered not-first-party? How does Python itself decide that it should skip the local wandb dir?</p>
</blockquote>
<p>A directory without an <code>__init__.py</code> can still be a <a href="https://packaging.python.org/en/latest/guides/packaging-namespace-packages/">namespace package</a>. Checking recursively for Python files would be more likely to be a correct heuristic but could be more expensive to do.</p>
<p>What Python actually does will necessarily involve finding the virtual environment: As described in <a href="https://peps.python.org/pep-0420/#specification">the PEP</a>, Python will look first at your local directory structure and see the directory <code>foo</code> with no Python files in it, say. It will record that it found this as a &quot;potential&quot; namespace package. But then it will search your virtual environment. If it finds an honest Python package <code>foo</code> there, then that is the resolved module. If it doesn&#x27;t, <em>then</em> it will resolve to the local directory <code>foo</code> as an implicit namespace package.</p>
<p>So we couldn&#x27;t mimic that <em>exact</em> behavior unless we found your virtual environment. But having declared dependencies as in the <code>uv metadata</code> idea should give the same behavior (unless someone has an environment that doesn&#x27;t match the declared one).</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:48:51 UTC
    </footer>
</body>
</html>
