<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[feature request] Please add an option to pyproject.toml to optionally use the external 'ruff' executable - astral-sh/ruff #11932</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[feature request] Please add an option to pyproject.toml to optionally use the external 'ruff' executable</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/11932">#11932</a>
        opened by <a href="https://github.com/yurivict">@yurivict</a>
        on 2024-06-19 02:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/yurivict">@yurivict</a> on 2024-06-19 02:02</div>
            <div class="timeline-body"><p>Our use case:
We have both devel/ruff and devel/py-ruff ports on FreeBSD.
The first builds and installs the standalone &quot;ruff&quot; executable.
The second one does the same plus it adds some Python files.</p>
<p>It would be beneficial if devel/py-ruff would be able to just depend on devel/ruff and it would only install Pythioon files using the &quot;ruff&quot; executable installed by devel/ruff.</p>
<p>This would solve 2 problems:</p>
<ol>
<li>It would prevent the need to rebuild ruff multiple times.</li>
<li>It would eliminate the conflict between devel/ruff and devel/py-ruff because they both install the ruff executable.</li>
</ol>
<p>Thank you,
Yuri</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @MichaReiser on 2024-06-19 06:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-19 06:31</div>
            <div class="timeline-body"><p>I'm not sure I follow the use case exactly. Can you tell us more about what python files are part of <code>py-ruff</code> and why you have two separate packages? Why does <code>py-ruff</code> need to ship the binary if it's already part of the <code>ruff</code> package?</p>
<p>Ruff (the binary) doesn't contain any logic to discover the Ruff binary to use. Calling <code>ruff check</code> simply uses the <code>ruff</code> binary on your path. That means, adding an option in the <code>pyproject.toml</code> won't help changing the ruff executable.</p>
<p>I think this is different if you start ruff with the python module, although I'm not sure how common that is. But I don't think we want to read any configuration files as part of that module because that would add a significant start up delay because:</p>
<ul>
<li>It would need to discover the closest configuration, requiring tree traversal</li>
<li>It needs to parse the configuration, something that's slow in Python</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yurivict">@yurivict</a> on 2024-06-19 07:02</div>
            <div class="timeline-body"><p>py311-ruff installs these files:</p>
<pre><code>$ pkg info -l py311-ruff
py311-ruff-0.4.9:
        /usr/local/bin/ruff
        /usr/local/bin/ruff-3.11
        /usr/local/lib/python3.11/site-packages/ruff-0.4.9.dist-info/METADATA
        /usr/local/lib/python3.11/site-packages/ruff-0.4.9.dist-info/RECORD
        /usr/local/lib/python3.11/site-packages/ruff-0.4.9.dist-info/WHEEL
        /usr/local/lib/python3.11/site-packages/ruff-0.4.9.dist-info/license_files/LICENSE
        /usr/local/lib/python3.11/site-packages/ruff/__init__.py
        /usr/local/lib/python3.11/site-packages/ruff/__main__.py
        /usr/local/lib/python3.11/site-packages/ruff/__pycache__/__init__.cpython-311.opt-1.pyc
        /usr/local/lib/python3.11/site-packages/ruff/__pycache__/__init__.cpython-311.pyc
        /usr/local/lib/python3.11/site-packages/ruff/__pycache__/__main__.cpython-311.opt-1.pyc
        /usr/local/lib/python3.11/site-packages/ruff/__pycache__/__main__.cpython-311.pyc
</code></pre>
<p>ruff installs these files:</p>
<pre><code>$ pkg info -l ruff
ruff-0.4.9:
        /usr/local/bin/ruff
        /usr/local/bin/ruff_dev
        /usr/local/bin/ruff_python_formatter
</code></pre>
<p>We need for py311-ruff to use binaries installed by ruff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-19 07:15</div>
            <div class="timeline-body"><p>Yeah, I'm not familiar enough with linux packaging to give good advice here, but I feel like asking users to specify the ruff path in the pyproject toml isn't a good solution to solve a packaging problem. It's just pushing the problem on them.</p>
<p>I think either</p>
<ul>
<li>Simply assume in the <code>py311-ruff</code> that <code>ruff</code> is on the path and use that version?</li>
<li>Inject the path (or you know the path?) to the ruff executable in <code>py311-ruff</code></li>
<li>Install the ruff binary locally in <code>py311-ruff</code> instead of globally. How do you handle other python packages with executables like black, mypy, pyright etc?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yurivict">@yurivict</a> on 2024-06-19 07:33</div>
            <div class="timeline-body"><blockquote>
<p>[...] I feel like asking users to specify the ruff path [...]</p>
</blockquote>
<p>No. This isn't what I am asking.
I am asking to have a build-time option in pyproject.toml to use the externally installed ruff binary.
Users would never use it.
Only the packagers would.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-19 08:00</div>
            <div class="timeline-body"><p>Would you mind explaining in more detail? I don't think I understand what you're asking for. Like what would you Ruff want to do? Where should that path be used?</p>
<p>Regardless. Have you checked how other linux distribution handle this problem or how this is solved for other python packages with executables?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yurivict">@yurivict</a> on 2024-06-19 08:37</div>
            <div class="timeline-body"><blockquote>
<p>Would you mind explaining in more detail?</p>
</blockquote>
<p>I would like to have a build-time option in pyproject.toml that would not build the ruff binary, and instead use the preinstalled binary.</p>
<blockquote>
<p>Regardless. Have you checked how other linux distribution handle this problem or how this is solved for other python packages with executables?</p>
</blockquote>
<p>They have conflicts because they don't care. But I would like to make it right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-19 08:45</div>
            <div class="timeline-body"><blockquote>
<p>I would like to have a build-time option in pyproject.toml that would not build the ruff binary, and instead use the preinstalled binary.</p>
</blockquote>
<p>Is my assumption correct that you're building ruff from source with maturin? How would you imagine the workflow. would you patch the <code>pyproject.toml</code> from the source file before calling maturin?</p>
<p>I think my preferred solution is that you write a tailored build script that simply doesn't call maturin (which calls <code>cargo build</code>) and copy move the python files you need. Overall, this seems a packaging problem to me</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-21 06:09</div>
            <div class="timeline-body"><p>I'll close this as it's unclear to me how this is a Ruff and not a packaging issue and if it's a Ruff issue, how this should work in detail.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-06-21 06:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/saper">@saper</a> on 2025-07-10 13:19</div>
            <div class="timeline-body"><p>I stumbled into this today and I think we could somehow make it work. Fortunately, the tiny Python binding is <a href="https://github.com/astral-sh/ruff/blob/main/python/ruff/__main__.py">small script</a> whose main purpose is to find the <code>ruff</code> binary.</p>
<p>Unlike other Python libraries written in Rust, the binding is very light here - the small script could have been released or packaged as a separate thing, which just requires the <code>ruff</code> binary to work.</p>
<p>The advantage for what the OP wanted is the following:</p>
<blockquote>
<p><code>ruff</code> binary does not need to build every time a Python interpreter version is added/updated</p>
</blockquote>
<p>(I was just setting up dev environment for a downstream project and ruff rust binary had to be needlessly rebuilt for every virtual environment being deployed, with {n} Python versions to be installed).</p>
<p>I think we can experiment outside of this repo first, and, if there is something  that this project here could do (like additional ways to find the binary or providing additional metadata), we shall come back here and reopen this with a proposed solution.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:53 UTC
    </footer>
</body>
</html>
