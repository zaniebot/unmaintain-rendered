```yaml
number: 15395
title: How to check folder and file name conventions (missing init-hook)?
type: issue
state: closed
author: fhg-isi
labels:
  - question
assignees: []
created_at: 2025-01-10T10:06:28Z
updated_at: 2025-01-25T10:52:45Z
url: https://github.com/astral-sh/ruff/issues/15395
synced_at: 2026-01-10T01:56:55Z
```

# How to check folder and file name conventions (missing init-hook)?

---

_Issue opened by @fhg-isi on 2025-01-10 10:06_

Currently I use pylint in combination with an init-hook to check folder and file name conventions.
I would like to switch to ruff but ruff does not seem to support init-hooks to include custom checks.

Is there a ruff rule to do so that I missed?

If not, could you please add rules for it?

If you do not want to include such a feature in ruff, what would be the best practice to check folder and file name conventions?

As a workaround, I could include the checks via pre-commit-hooks and GitHub workflows.

However, I would prefer it to be part of the lint workflow.... so that naming conventions are checked every time the linting is performed. pre-commit hooks would require extra user activity and GitHub workflows give a delayed hint. 

For eslint in the JavaScript world there is https://www.npmjs.com/package/eslint-plugin-check-file.

---

_Renamed from "How to check folder and file name conventions?" to "How to check folder and file name conventions (missing init-hook)?" by @fhg-isi on 2025-01-10 10:14_

---

_Comment by @MichaReiser on 2025-01-10 10:32_

Do you have an example of the naming conventions you want to enforce?

---

_Label `question` added by @MichaReiser on 2025-01-10 10:32_

---

_Comment by @fhg-isi on 2025-01-10 10:40_

Here is example code to check for **snake_case** naming convention for folder and file names. 

Related:
https://peps.python.org/pep-0008/#package-and-module-names



```
import logging
import os
import re

# This module checks if all file and folder names follow
# the snake_case naming convention.
# It is included from the pyproject.toml file via init-hook
# of pylint.


def main(directory_to_check="."):
    _initialize_logging()
    logging.info('Checking if all file and folder names are in snake_case...')
    folders_to_exclude = [
        "LICENSES",
        "web",
        ".git",
        ".idea",
        ".ruff_cache",
        ".pytest_cache",
        ".vscode",
        "__pycache__",
    ]
    file_names_to_exclude = [
        "Dockerfile",
        "README.md",
        "THIRDPARTY.md",
    ]
    check_folders_and_files_to_be_in_snake_case(
        directory_to_check,
        folders_to_exclude,
        file_names_to_exclude,
    )
    logging.info('... naming convention check finished.')


def _initialize_logging():
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)


def check_folders_and_files_to_be_in_snake_case(
    directory_to_check,
    folders_to_exclude,
    file_names_to_exclude,
):
    for path, sub_folders, files in os.walk(directory_to_check):
        for sub_folder in sub_folders:
            if _is_excluded_folder(sub_folder, folders_to_exclude):
                continue

            check_folders_and_files_to_be_in_snake_case(
                directory_to_check + "/" + sub_folder,
                folders_to_exclude,
                file_names_to_exclude,
            )

        if _is_excluded_folder(path, folders_to_exclude):
            continue

        for name in files:
            if name in file_names_to_exclude:
                continue

            _check_snake_case(path, name)
        break


def _is_excluded_folder(path, folders_to_exclude):
    for folder_to_exclude in folders_to_exclude:  # noqa: SIM110
        if folder_to_exclude in path:
            return True
    return False


def _check_snake_case(path, name):
    if not _is_snake_case(name):
        message = "Directory or file name is not in snake_case:\n" + path + "/" + name
        raise NameError(message)



def _is_snake_case(name):
    items = name.split(".")
    name_without_ending = items[0]
    if name_without_ending == "":
        return True

    _rex = re.compile("_?[a-z0-9]+(?:_+[a-z0-9]+)*")
    is_snake = _rex.fullmatch(name_without_ending)
    return is_snake


if __name__ == "__main__":
    main()
```

---

_Comment by @calumy on 2025-01-10 10:46_

This might be handled by: https://docs.astral.sh/ruff/rules/invalid-module-name/. Per file excludes can also be set for the `folders_to_exclude` and `file_names_to_exclude` that are outlined in the script.

---

_Comment by @fhg-isi on 2025-01-10 10:59_

If I create a file src/fooBaa/fooBaa.py, including some FooBaa class and run

`ruff check --select N999`

I do not get a warning. 

---

_Comment by @MichaReiser on 2025-01-10 11:10_

It should warn once you add an `__init__.py` to the `fooBaa` directory

---

_Comment by @fhg-isi on 2025-01-10 11:15_

Thank you for clarification. I do not want to use `__init__.py` files for Python >= 3.3.


---

_Comment by @MichaReiser on 2025-01-10 12:37_

You can also list the namespace packages in [`namespace-packages`](https://docs.astral.sh/ruff/settings/#namespace-packages) that should give you the same behavior I think.

The reason why Ruff only enforces this rule for regular packages is that the name is only relevant for modules that are intended to be imported from other modules and this is generally true for all modules that are part of a package (folder with an `__init__.py`)

---

_Closed by @MichaReiser on 2025-01-25 10:52_

---
