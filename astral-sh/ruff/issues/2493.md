```yaml
number: 2493
title: "Ruff (and flake8) doesn't report a situation where a variable _may_ be  unbound"
type: issue
state: closed
author: DMRobertson
labels: []
assignees: []
created_at: 2023-02-02T19:51:28Z
updated_at: 2024-10-30T05:18:28Z
url: https://github.com/astral-sh/ruff/issues/2493
synced_at: 2026-01-10T01:56:45Z
```

# Ruff (and flake8) doesn't report a situation where a variable _may_ be  unbound

---

_Issue opened by @DMRobertson on 2023-02-02 19:51_

Consider the following snippet:

```python
from random import random


def coin_toss():
    return random.randint(0, 2)


def maybe_runtime_error():
    if coin_toss():
        x = []

    # runtime error if coin_toss returned False, but not detected by the linter
    x = list(x)
    print(x)


def runtime_error():
    # always a runtime error, detected by linter
    y = list(y)
    print(y)
```

There are two problems with this snippet.

1. In `maybe_runtime_error`, the name `x` may not be bound to a variable when we come to evaluate `list(x)`. This means we might get a runtime UnboundLocalError.
2. In `runtime_error`, the name `y` is never bound to a variable when we come to evaluate `list(y)`. We'll always get a runtime UnboundLocalError when calling this function.

Problem (2) is spotted by ruff, but problem (1) is not.

```
$ ruff --isolated temp.py
temp.py:19:14: F821 Undefined name `y`
Found 1 error.
```

I was a little surprised by this! But flake8 has the same output:

```
$ flake8 --version && flake8 temp.py
6.0.0 (mccabe: 0.7.0, pycodestyle: 2.10.0, pyflakes: 3.0.1) CPython 3.10.9 on Linux
temp.py:19:14: F821 undefined name 'y'
```

I'm not sure if it's fair game for ruff to spot the problem with `x`---perhaps that's more the remit of a typechecker like mypy. (Though mypy didn't warn about this either when I tried it!) It'd be great if it was feasible to spot this at lint-time.

<details>
<summary>Configuration</summary>

```toml
[tool.ruff]
line-length = 88

# See https://github.com/charliermarsh/ruff/#pycodestyle
# for error codes. The ones we ignore are:
#  E731: do not assign a lambda expression, use a def
#  E501: Line too long (black enforces this for us)
#
# flake8-bugbear compatible checks. Its error codes are described at
# https://github.com/charliermarsh/ruff/#flake8-bugbear
#  B019: Use of functools.lru_cache or functools.cache on methods can lead to memory leaks
#  B023: Functions defined inside a loop must not use variables redefined in the loop
#  B024: Abstract base class with no abstract method.
ignore = [
    "B019",
    "B023",
    "B024",
    "E501",
    "E731",
]
select = [
    # pycodestyle checks.
    "E",
    "W",
    # pyflakes checks.
    "F",
    # flake8-bugbear checks.
    "B0",
    # flake8-comprehensions checks.
    "C4",
]
```

And as for the version:

```
$ ruff --version
ruff 0.0.240
```

</details>

---

_Referenced in [matrix-org/synapse#14971](../../matrix-org/synapse/pulls/14971.md) on 2023-02-02 19:53_

---

_Comment by @charliermarsh on 2023-02-02 21:53_

Appreciate the clear issue! Right now, (1) is outside of our capabilities -- although I'm surprised that Mypy doesn't flag this... Pyright _does_:

```
â¯ pyright foo.py
/Users/crmarsh/workspace/ruff/foo.py
  /Users/crmarsh/workspace/ruff/foo.py:13:14 - error: "x" is possibly unbound (reportUnboundVariable)
1 error, 0 warnings, 0 informations
Completed in 0.467sec
```

We could _potentially_ include some kind of "possibly unbound" code for those cases. I'd have to think on it ðŸ¤” 


---

_Comment by @DMRobertson on 2023-02-02 22:16_

> I'm surprised that Mypy doesn't flag this

And me! For cross-referencing, it seems like the relevant issues are 

- https://github.com/python/mypy/issues/686
- https://github.com/python/mypy/issues/2400
- https://github.com/python/mypy/issues/4019

---

_Comment by @charliermarsh on 2023-02-03 18:15_

I'm gonna close for now just because it's not super actionable. I'd like Ruff to be able to handle cases like this eventually, but it'd be a fairly big project and probably outside of the scope of a bug fix. Hope that intent is clear. I appreciate the issue!


---

_Closed by @charliermarsh on 2023-02-03 18:15_

---

_Comment by @frankdilo on 2023-09-25 10:53_

just wanted to drop in and say that I would find this **extremely** useful

it's really easy in long Python functions and code blocks when refactoring and moving variables inside nested conditionals or inline functions to nest a variable used somewhere else and only discover at runtime via a Sentry notification days later

---

_Referenced in [opsmill/infrahub#1389](../../opsmill/infrahub/issues/1389.md) on 2023-11-10 12:25_

---

_Comment by @sascharo on 2024-09-16 04:43_

Is this still unsupported?

---

_Comment by @clemente0731 on 2024-10-09 08:14_

STILL ~
Ruff cannot detect the problem of **"referenced before assignment"** and shows all passes. In an if-else scenario, for example, a variable is declared in the else block, but it is not declared in the if block. Then, this corresponding variable is used again in a subsequent inevitable path.

---

_Comment by @Garrett-R on 2024-10-30 05:17_

Note: this is the subject of this issue: https://github.com/astral-sh/ruff/issues/6902

> STILL ~

It sounds like a pretty tough one, but I'm sure Ruff maintainers would welcome a PR for it.

---

_Referenced in [astral-sh/ruff#14821](../../astral-sh/ruff/issues/14821.md) on 2024-12-06 16:26_

---
