<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mypy TYPE_CHECKING imports and sqlalchemy quoted class names which prevent circular imports. - astral-sh/ruff #3548</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Mypy TYPE_CHECKING imports and sqlalchemy quoted class names which prevent circular imports.</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/ruff/issues/3548">#3548</a>
        opened by <a href="https://github.com/ddimmich">@ddimmich</a>
        on 2023-03-15 18:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/ddimmich">@ddimmich</a> on 2023-03-15 18:49</div>
            <div class="timeline-body"><p>The below fails in ruff - often using sqlalchemy you need to provide class names as strings, to prevent circular imports.  Mypy suggests adding these imports inside an if TYPE_CHECKING block, so that it can do type inference.  Unfortunately this causes the pyflakes rules to break.  This is actually consistent with pyflakes behavior, but the discussion here suggests it could either interpret the values in the strings, or ignore f401 for imports in TYPE_CHECKING - neither of which are ideal.  https://github.com/PyCQA/pyflakes/issues/290</p>
<p>Do you have plans for ruff to handle this kind of scenario, or is it best to manually #noqa each line in these imports?</p>
<p>ruff 0.0.256</p>
<p>Run with <code>ruff example.py</code></p>
<p>gives:
example.py:8:19: F401 [*] <code>x.SomeOtherModel</code> imported but unused</p>
<pre><code>import sqlalchemy as sa
from sqlalchemy.schema import MetaData
from sqlalchemy.ext.declarative import declarative_base

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from x import SomeOtherModel

metadata = MetaData()
Base = declarative_base(metadata=metadata)

class MyModel(Base):
    data_source = sa.orm.relationship(&quot;SomeOtherModel&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JonathanPlasse">@JonathanPlasse</a> on 2023-03-15 19:23</div>
            <div class="timeline-body"><p><code>SomeOtherModel</code> is not used in any annotation.
Therefore ruff cannot detect it.
You need to use <code>SomeOtherModel</code>as annotation for <code>data_source</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-15 19:47</div>
            <div class="timeline-body"><p>Yeah we could pick up <code>SomeOtherModel</code> if it were used as an annotation (like <code>data_source: &quot;SomeOtherModel&quot; = ...</code>). But as-is, we have no way of knowing that it's being used as an annotation there.</p>
<p>We <em>could</em> encode that the arguments to SQLAlchemy's <code>relationship</code> function should be treated as types. I'd have to better understand those APIs and how they're intended to be used. Is there an annotation that can go on <code>data_source</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JonathanPlasse">@JonathanPlasse</a> on 2023-03-15 20:07</div>
            <div class="timeline-body"><p>https://docs.sqlalchemy.org/en/20/orm/extensions/mypy.html#mapping-relationships</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-03-15 23:24</div>
            <div class="timeline-body"><p>Ah yeah, ok, I <em>think</em> this is a valid workaround so gonna close as &quot;expected behavior&quot;:</p>
<pre><code class="language-py">import sqlalchemy as sa
from sqlalchemy.schema import MetaData
from sqlalchemy.ext.declarative import declarative_base

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from x import SomeOtherModel

metadata = MetaData()
Base = declarative_base(metadata=metadata)

class MyModel(Base):
    data_source: &quot;SomeOtherModel&quot; = sa.orm.relationship(&quot;SomeOtherModel&quot;)
</code></pre>
<p>Let me know if that's not sufficient though, happy to keep discussing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-03-15 23:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ddimmich">@ddimmich</a> on 2023-03-16 03:56</div>
            <div class="timeline-body"><p>Thank you - very clear, in the case above in sqlalchemy 2 and up it would be:</p>
<pre><code>class MyModel(Base):
    data_source: List[&quot;SomeOtherModel&quot;] = sa.orm.relationship(&quot;SomeOtherModel&quot;)
</code></pre>
<p>Appreciate the time taken to investigate!!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:08 UTC
    </footer>
</body>
</html>
