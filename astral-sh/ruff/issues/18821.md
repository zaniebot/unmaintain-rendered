```yaml
number: 18821
title: "DOC: `PLW1641`'s documentation should emphasize that implementing `__hash__` for mutable objects is unsound"
type: issue
state: open
author: neutrinoceros
labels:
  - documentation
assignees: []
created_at: 2025-06-20T10:02:36Z
updated_at: 2025-11-23T16:21:05Z
url: https://github.com/astral-sh/ruff/issues/18821
synced_at: 2026-01-10T01:56:56Z
```

# DOC: `PLW1641`'s documentation should emphasize that implementing `__hash__` for mutable objects is unsound

---

_Issue opened by @neutrinoceros on 2025-06-20 10:02_

### Summary

The "Why is this bad" reads

>  A class that implements `__eq__` but not `__hash__` will have its hash method implicitly set to None, regardless of if a superclass defines `__hash__`. This will cause the class to be unhashable, which will in turn cause issues when using instances of the class as keys in a dictionary or **members of a set.**

(emphasize mine)
Meanwhile, [`set` is documented as a container for *immutable* objects](https://docs.python.org/3/reference/datamodel.html#set-types).
Indeed, a hash should never change throughout the lifetime of an object, so it is not sound to support hashing for objects that are intended to be mutable.
I would expect the rule's documentation to emphasize this important limitation.

---

_Referenced in [astropy/astropy#18284](../../astropy/astropy/issues/18284.md) on 2025-06-20 10:03_

---

_Label `documentation` added by @ntBre on 2025-06-20 12:28_

---

_Comment by @Pagerous on 2025-08-11 16:35_

I'm genuinely surprised someone added this rule which is completely invalid and makes false assumptions.

---

_Comment by @neutrinoceros on 2025-08-11 16:42_

how is it invalid ? what false assumptions are you refering too ? (I'm not saying you're wrong, I'd just like to avoid making *assumptions* about what you mean :))

---

_Comment by @Pagerous on 2025-08-11 17:08_

> how is it invalid ? what false assumptions are you refering too ? (I'm not saying you're wrong, I'd just like to avoid making _assumptions_ about what you mean :))

I consider the rule invalid because it enforces users to provide the code they don't need. It's totally OK to have either `__hash__` or `__eq__`, or both of them, depending what you need. Maybe it didn't sound like that, but I agreed with what you'd written:

> a hash should never change throughout the lifetime of an object, so it is not sound to support hashing for objects that are intended to be mutable

The false assumptions that this rule made are:
- all objects are immutable
- all objects can be hashable

---

_Comment by @neutrinoceros on 2025-08-11 17:18_

> It's totally OK to have either __hash__ or __eq__, or both of them, depending what you need.

Well if you're writing a library, you cannot make assumptions about what end users actually need. The way I se it, this lint pushes you in a direction that's never incorrect (provided the nuance I want to add). If you don't need it (for writing anything *other* than a library), you can simply not enable this rule. Is that so bad ?



---

_Comment by @Pagerous on 2025-08-11 18:24_

> this lint pushes you in a direction that's never incorrect

In my humble opinion, custom hashability  has been always an optional ability of Python objects and pushing anyone towards that direction isn't nice. A class with `__eq__` and  without `__hash__` isn't incorrect or non-idiomatic, so what's the point of considering it a linting error? Many people learn how to write code by trial-and-error and if "ruff" says it's incorrect, they'll learn that way. But here it's misleading people. So I do think it's incorrect and may cause YAGNI violations. 

>  If you don't need it (for writing anything other than a library), you can simply not enable this rule.

Disabling the rule makes sense to me when I agree that the rule makes sense and I accept my code doesn't fulfil it for some reason. In case of `PLW1641` I don't think this way as it depends on the class semantics whether `__hash__` is needed together with `__eq__` or not, what can't be validated by the static linter.

---

_Comment by @pvandyken on 2025-08-13 19:23_

The difficulty is that I am not aware of an unambiguous way for a linter to determine if a class is meant to be immutable (other than certain library conventions such as `attrs.frozen`.) As the rule stands, even with a documentation change, one would still get false positives even in legitimate "library" settings.

For instance, if one reimplemented `set` in pure python, one would need to leave `__hash__` unset (or set explicitely to `None`, which creates other linting problems if actually attempted.) But because `set` has an `__eq__`, this rule would be innappropriately triggered.

So the OP is correct, but this goes beyond a documentation problem.

---

_Referenced in [astral-sh/ruff#20821](../../astral-sh/ruff/issues/20821.md) on 2025-10-13 13:05_

---

_Comment by @zackw on 2025-11-05 15:00_

Possible heuristics for "this is a mutable class" that could help:

- the class inherits from `list`, `dict`, `set`, `collections.OrderedDict`, any of the `collections.abc.Mutable*` protocol classes, or any other stdlib class that implements a mutable container
- the class implements `__setitem__` or `__delitem__` [refinement: "and the implementation doesn't unconditionally throw an exception"]

But I do think that adding text along the lines of 

> Note that `__hash__` should only be defined for _immutable_ objects.  If this class is mutable, then you should instead annotate it with `__hash__ = None`.

would be a solid improvement over what there is now.

---

_Comment by @Tishka17 on 2025-11-23 16:21_

I believe that this check is just completely wrong. The only case for it to be true is when object is already used in set/dict. 

---
