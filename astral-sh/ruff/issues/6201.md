```yaml
number: 6201
title: missing TCH00(1-3) lint for typing.Callable function signature annotation
type: issue
state: closed
author: bachmannscode
labels: []
assignees: []
created_at: 2023-07-31T16:10:01Z
updated_at: 2023-08-02T22:23:06Z
url: https://github.com/astral-sh/ruff/issues/6201
synced_at: 2026-01-10T01:56:48Z
```

# missing TCH00(1-3) lint for typing.Callable function signature annotation

---

_Issue opened by @bachmannscode on 2023-07-31 16:10_

ruff version: 0.0.280

Due to ```from __future__ import annotations```, the python interpreter can run this snippet without raising a ```NameError```:
```
from __future__ import annotations
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable

def print_hello() -> None:
    print("hello")

def foo() -> Callable[[], None]:
    return print_hello

if __name__ == "__main__":
    foo()()
```
This tells me that ```Callable``` is only used for type checking. Running ```ruff snippet.py --select=TCH --isolated``` does, correctly so, not complain.

If we edit the snippet by removing the type checking guard like so:
```
from __future__ import annotations
from typing import TYPE_CHECKING

from typing import Callable

def print_hello() -> None:
    print("hello")

def foo() -> Callable[[], None]:
    return print_hello

if __name__ == "__main__":
    foo()()
```
Running ```ruff snippet.py --select=TCH --isolated``` still does not complain which imho should with one of "TCH00(1-3)".

Notes:
- When ruff linting the same snippet but instead of importing from ```typing```, one imports from ```collections.abc```, ruff, correctly so, complains with TCH003.
- Ruff also does not complain if the ```__future__``` import is replaced by surrounding the annotation with quotes like so ```"Callable[[], None]"``` which can also be run by the python interpreter without any errors.

---

_Comment by @charliermarsh on 2023-07-31 16:21_

I believe this is working as intended. The typing module itself is exempted from these rules, since you _need_ to import typing at runtime to get access to TYPE_CHECKING, and so there is no runtime benefit to importing it in a deferred manner.

---

_Comment by @charliermarsh on 2023-07-31 16:26_

There are two relevant settings here:

- https://beta.ruff.rs/docs/settings/#flake8-type-checking-strict which applies the above heuristic to _all_ modules (ie, don’t enforce typing rules for imports that have at least one runtime usage, since there’s no runtime benefit to moving parts of the import if you’re already importing the module at runtime).
- https://beta.ruff.rs/docs/settings/#flake8-type-checking-exempt-modules which exempts modules entirely and includes typing by default. I believe you can remove it but there’s at least one bug related to that behavior and I don’t recommend it (we may forbid that entirely for the typing module in the future).

---

_Closed by @charliermarsh on 2023-07-31 19:50_

---

_Comment by @bachmannscode on 2023-08-02 22:23_

I see, that makes sense. Thanks a lot for the answer!

---
