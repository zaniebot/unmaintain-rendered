<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support namespace packages without `namespace-packages` setting - astral-sh/ruff #6114</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support namespace packages without <code>namespace-packages</code> setting</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/6114">#6114</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-07-27 01:59
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-27 01:59</div>
            <div class="timeline-body"><p>Right now, our module discovery doesn't support namespace packages -- or rather, it requires that projects specify namespace packages explicitly via the <a href="https://beta.ruff.rs/docs/settings/#namespace-packages"><code>namespace-packages</code></a> setting.</p>
<p>I'd like to remove this setting, and ensure that namespace packages &quot;just work&quot;.</p>
<p>One option is to take inspiration from <a href="https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-paths-to-modules">Mypy</a>, where they effectively mark a directory without a <code>__init__.py[i]</code> file as a namespace package if it's within a directory that contains an <code>__init__.py[i]</code> file, and provide escape hatches for explicitly specifying package bases.</p>
<p>Another option is to take inspiration <a href="https://github.com/microsoft/pyright/blob/main/docs/configuration.md#execution-environment-options">Pyright</a>, where AFAICT they allow you to specify multiple roots which are effectively your package bases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-27 02:01</div>
            <div class="timeline-body"><p>@hauntsaninja - no pressure to respond, but I'm curious if you'd have any advice here based on your experiences in Mypy. This issue is roughly referring to the behavior Mypy has in the <a href="https://github.com/python/mypy/blob/b901d21194400b856a88df62a3d7db871936a50d/mypy/find_sources.py#L130"><code>SourceFinder</code></a>. Right now, we also try to map every Python file to a (package root directory, dot-separated module path), but our logic relies on namespace packages being explicitly specified in our configuration file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by @charliermarsh on 2023-07-27 02:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-27 02:08</div>
            <div class="timeline-body"><p>It's also plausible that our current approach of requiring namespace packages to be explicitly enumerated is not <em>that</em> bad and fine to preserve for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hauntsaninja">@hauntsaninja</a> on 2023-07-27 02:24</div>
            <div class="timeline-body"><p>mypy's default behaviour isn't very good for actual namespace packages... It's good for &quot;accidental&quot; namespace packages, where you have a large tree and people forget to litter <code>__init__.py</code> everywhere.</p>
<p>I'd probably recommend using something like mypy's behaviour with <code>--explicit-package-bases</code> as described in https://mypy.readthedocs.io/en/stable/running_mypy.html#mapping-file-paths-to-modules . mypy doesn't use <code>--explicit-package-bases</code> by default because it would be too breaking. Having this be cwd dependent is something that's worked reasonably well for mypy, but you may wish to think more carefully about it.</p>
<p>Seems potentially a little annoying to list all namespace packages out, seems preferable to list bases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-27 02:29</div>
            <div class="timeline-body"><p>Thank you, that's helpful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hauntsaninja">@hauntsaninja</a> on 2023-07-27 02:47</div>
            <div class="timeline-body"><p>An argument against using literally mypy's <code>--explicit-package-bases</code> behaviour is that ruff wants to support monorepos with potentially a bunch of nesting, which would cause listing all bases to be tedious. Most users of mypy I've seen are not trying to run mypy in a single invocation on a varied tree. You may wish to explore something that uses the location of pyproject.toml's instead and lets users mix and match settings a little more.</p>
<p>Honestly, maybe mypy should probably just use sys.path of the target interpreter to determine bases. This is very defensible behaviour and unlike ruff mypy does usually have a target interpreter that has the installs needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-27 02:50</div>
            <div class="timeline-body"><p>üëç Yeah monorepo support is important for Ruff. We do currently treat each <code>pyproject.toml</code> as creating a new &quot;source root&quot; -- it's a bit complicated but I wrote it out in detail here (not expecting you to read it, only if curious): https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#import-categorization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hmc-cs-mdrissi">@hmc-cs-mdrissi</a> on 2023-08-05 02:08</div>
            <div class="timeline-body"><p>pyright while not python does still call python for sys.path. Beyond helping with namespace packages it also deals helps a lot of import weirdness like handling .pth files/ways sys.path can be modified.</p>
<p>Pylint's namespace package detection is buggy and I haven't seen an approach that really works besides explicitness/sys.path. Here's a test <a href="https://github.com/hmc-cs-mdrissi/tricky_namespace_package_lint">repo</a> that's small but is already enough to lead to issues for number of tools due to there being files with same name that are distinguished if you detect namespace packages correctly.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:30:50 UTC
    </footer>
</body>
</html>
