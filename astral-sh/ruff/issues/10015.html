<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Request: Implement deptry / pip-check-reqs - astral-sh/ruff #10015</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Request: Implement deptry / pip-check-reqs</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/issues/10015">#10015</a>
        opened by <a href="https://github.com/adamtheturtle">@adamtheturtle</a>
        on 2024-02-17 03:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/adamtheturtle">@adamtheturtle</a> on 2024-02-17 03:04</div>
            <div class="timeline-body"><p><a href="https://fpgmaas.github.io/deptry/">deptry</a> and <a href="https://github.com/r1chardj0n3s/pip-check-reqs">pip-check-reqs</a> are similar tools.</p>
<p>They check whether there are unused or missing dependencies.</p>
<p>Use cases include:</p>
<ul>
<li>My code works but I rely on a transitive dependency, and that could bite me in the future</li>
<li>My tests pass, but one of my dependencies is specified as a test dependency</li>
<li>I am wasting time/space installing a dependency which I do not need</li>
</ul>
<p>My uninformed guess/hope is that with <code>uv</code>, <code>astral-sh</code> now has the tooling to understand the project's requirements, and with existing <code>ruff</code> rules, there is an understanding of the project's imports.</p>
<p>Context: I took over responsibility for <code>pip-check-reqs</code> a few years ago as a user of the project as it was breaking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-02-17 05:18</div>
            <div class="timeline-body"><p>Hi! Thanks for the issue :)</p>
<p>We are indeed very interested in the idea of leveraging <code>uv</code> for linting. I'm not sure if it'll happen soon though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">plugin</span> added by @zanieb on 2024-02-17 05:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">packaging</span> added by @zanieb on 2024-02-17 05:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/baggiponte">@baggiponte</a> on 2024-03-13 13:55</div>
            <div class="timeline-body"><p>+1 on the request. Deptry latest alpha is already using a bit of rust to parse the AST. ruff alone could perform these kind of checks, I guess. The biggest roadblock is that some packages are installed as <code>something</code> and imported as <code>something_else</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-03-13 14:31</div>
            <div class="timeline-body"><p>I think the main challenges here aren't technical, but more-so that it requires deeper coupling to Python, since we need to know the <code>sys.path</code> in order to look for installed packages (at least for some of these rules, and to resolve the issue around <code>something</code> being imported as <code>something_else</code>). That also means we need to be running within a virtual environment, or have a path to a <code>.venv</code> provided by the user (like in Pyright).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/akshaybabloo">@akshaybabloo</a> on 2024-11-27 08:58</div>
            <div class="timeline-body"><p>I think for the third point you could use <code>ast</code> to get all the imports and compare them to dependencies from <code>pyproject.toml</code>. I am not sure if ruff can do something like this natively?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/idan-rahamim-lendbuzz">@idan-rahamim-lendbuzz</a> on 2025-07-09 11:32</div>
            <div class="timeline-body"><blockquote>
<p>I think the main challenges here aren't technical, but more-so that it requires deeper coupling to Python, since we need to know the <code>sys.path</code> in order to look for installed packages (at least for some of these rules, and to resolve the issue around <code>something</code> being imported as <code>something_else</code>). That also means we need to be running within a virtual environment, or have a path to a <code>.venv</code> provided by the user (like in Pyright).</p>
</blockquote>
<p>Maybe it can be added to<code>Ty</code>, as it can run within in a venv?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CarliJoy">@CarliJoy</a> on 2025-08-02 21:19</div>
            <div class="timeline-body"><blockquote>
<p>I think the main challenges here aren't technical, but more-so that it requires deeper coupling to Python, since we need to know the sys.path in order to look for installed packages (at least for some of these rules, and to resolve the issue around something being imported as something_else). That also means we need to be running within a virtual environment, or have a path to a .venv provided by the user (like in Pyright).</p>
</blockquote>
<p>I don't think this is true.</p>
<p>You don't need an venv to get this information.
You need a mapping dependency â†’ import module.</p>
<p>For this you only need the <code>RECORD</code> files in the <code>.dist</code> folder  of the given dependencies.
This is something <code>uv</code> easily could provide, most likely already from the cache.</p>
<p>I even would argue, that taking this from the activated venv could lead to error, because we don't know the state of it.</p>
<p>Using <code>uv</code> we could ensure, that either the newested version of a packages is checked against or the version defined within the projects lock file.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:32:49 UTC
    </footer>
</body>
</html>
