```yaml
number: 8704
title: Add rule to encourage using type aliases (generalize PYI026)
type: issue
state: open
author: NeilGirdhar
labels:
  - rule
  - needs-design
assignees: []
created_at: 2023-11-15T22:02:30Z
updated_at: 2024-09-20T08:22:03Z
url: https://github.com/astral-sh/ruff/issues/8704
synced_at: 2026-01-10T01:56:50Z
```

# Add rule to encourage using type aliases (generalize PYI026)

---

_Issue opened by @NeilGirdhar on 2023-11-15 22:02_

The following code has no errors, but it should use type aliases to indicate that `x` will not be used programmatically:
```python
x = int

def f(y: x) -> x:
    return y
```

This is because of the many benefits of type aliases, which are described in [PEP 613](https://peps.python.org/pep-0613/).

If the [target version](https://peps.python.org/pep-0613/) < 3.10, then suggest
```python
from typing_extensions import TypeAlias
x: TypeAlias = int

def f(y: x) -> x:
    return y
```
for 3.10 <= version < 3.12, suggest:
```python
from typing import TypeAlias
x: TypeAlias = int

def f(y: x) -> x:
    return y
```
and for version >= 3.12 suggest:
```python
type x = int

def f(y: x) -> x:
    return y
```
as per [PEP 695 generic type aliases](https://peps.python.org/pep-0695/#generic-type-alias).

---

There is already a rule [PYI026](https://docs.astral.sh/ruff/rules/type-alias-without-annotation/) that does this for `pyi` files.  This proposal is for all source files.

---

If you are using `x` both programmatically and as an annotation, then in my opinion, you should have a separate generic type alias for the annotation.  While not all uses of programmatic use of type annotations are problematic, there are many pitfalls.  For example,
```python
t = int

x = t(0)
def f(y: t) -> t: return y
```
only seems okay.  But this has problems.  What if `t` is switched with another annotation like `np.ndarray` or `int | float` or `numbers.Real`?  It woudl be better to have
```python
type t_annotation = int
t_constructor: Callable[[int | float], t_annotation] = int

x = t_constructor(0)
def f(y: t_annotation) -> t_annotation: return y
```
Yes, it's more wordy, but it
* has all the benefits of type aliases described in the PEP,
* is less fragile if things change,
* it makes it clear to the reader how `t_constructor` and `t_annotation` will be used, and
* you can annotate the constructor.

---

_Renamed from "Add rule to encourage using type aliases" to "Add rule to encourage using type aliases (generalize PYI026)" by @NeilGirdhar on 2023-11-15 23:08_

---

_Label `rule` added by @charliermarsh on 2023-11-15 23:24_

---

_Comment by @chadrik on 2024-09-18 21:36_

I'm also interested in this.  I found it confusing when I enabled the "PYI" rule set, that some of the rules ran on my .py files and `PYI026` did not.   I noticed that [`UP007`](https://docs.astral.sh/ruff/rules/non-pep604-annotation/), which upgrades `Union[X, Y]` to `X | Y`, will only run on type aliases that are explicitly annotated with `TypeAlias`.  So I want to use `PYI026` to ensure `UP007` runs successfully (also, I think explicitly adding `TypeAlias` is valuable on its own), and I don't want this limited to .py files.



---

_Comment by @chadrik on 2024-09-18 21:37_

I'm happy to try my hand a a pull request if there's no dissent on the usefulness of this. 

---

_Comment by @MichaReiser on 2024-09-19 07:11_

@carljm any thoughts on the addition of said rule?

---

_Comment by @carljm on 2024-09-19 17:33_

In principle it seems like a fine idea, but I think there are a lot of question marks about how it should actually work that haven't been discussed here. It's definitely not a simple matter of extending the existing implementation of PYI026 to non-stub files, too.

The implementation of PYI026 is pretty simple. It doesn't look at context or uses of the variable at all, it just purely looks at the RHS to decide if it "looks like" maybe a type. It can get away with this because it only runs on stub files, where un-annotated assignments are pretty rare, and really the only use for them is for typevars or type aliases. So for instance it will assume that literally any subscript expression on the RHS is a generic type. But this is certainly not a valid assumption outside of a stub file.

It's not at all clear to me in a non-stub file how you reliably decide if a name is intended as a type alias. Is the rule something like "used in an annotation expression, not used in any value expression"?

The second half of that rule can't be definitively established for a top-level name, since it might be exported and used in another module.

Or do we not care if it's used in a value expression? If it's used in an annotation expression, we consider it a type alias, and then the rule is basically saying you should separate the value use from the annotation use, as @NeilGirdhar suggests in the OP? In that case we can't have an autofix for the rule, as it would break the value-expression uses, without further changes to the code.

Overall I'm not opposed to this, but I think we need a precise proposal for how it would decide which assignments to fire on.

---

_Label `needs-design` added by @MichaReiser on 2024-09-20 08:22_

---

_Referenced in [astral-sh/ruff#16701](../../astral-sh/ruff/issues/16701.md) on 2025-03-13 11:12_

---
