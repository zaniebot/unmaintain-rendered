```yaml
number: 14732
title: "Gitlab code quality fingerprint limitation: multiple errors with identical message"
type: issue
state: open
author: fin-gal
labels:
  - great writeup
assignees: []
created_at: 2024-12-02T14:18:50Z
updated_at: 2025-09-09T17:04:39Z
url: https://github.com/astral-sh/ruff/issues/14732
synced_at: 2026-01-12T15:54:54Z
```

# Gitlab code quality fingerprint limitation: multiple errors with identical message

---

_@fin-gal_

Context
---

I'm implementing the use of code quality in Gitlab for the company I work at.
Code quality relies on json reports generated with a specific format, with each error having some metadata and a fingerprint.
My understanding is that in ruff, the fingerprint is a hash generated from:

- The relative file path
- The error message
- A salt value

[Relevant code  is here.](https://github.com/astral-sh/ruff/blob/6dfe125f44352f5fdff19f6d47fc33ac7a6e86ad/crates/ruff_linter/src/message/gitlab.rs#L89)

The finger print is:

- [Generated](https://github.com/astral-sh/ruff/blob/6dfe125f44352f5fdff19f6d47fc33ac7a6e86ad/crates/ruff_linter/src/message/gitlab.rs#L84)
- [Checked for an identical finger print](https://github.com/astral-sh/ruff/blob/6dfe125f44352f5fdff19f6d47fc33ac7a6e86ad/crates/ruff_linter/src/message/gitlab.rs#L88) in the already generated ones
- If the finger print already exists: [regenerated by feeding the path,](https://github.com/astral-sh/ruff/blob/6dfe125f44352f5fdff19f6d47fc33ac7a6e86ad/crates/ruff_linter/src/message/gitlab.rs#L89) message and current fingerprint as a salt.

Past changes
---

In the past, the  line number at which the error is picked up used to be included in the hash, but thankfully was removed. If someone added code before an issue the file had, it would generate a new finger print and the code quality widget in Gitlab would show all the issues as fixed and also new, duplicating everything and making the tool unusable.
Reelvant issues/discussions on this subject:
https://github.com/astral-sh/ruff/discussions/3996 : initial discussion
https://github.com/astral-sh/ruff/pull/7203 : issue solving the above problem
https://github.com/astral-sh/ruff/issues/7159

Current problem
---

This is all positive and a clear welcomed improvement. However I see a shortcoming with this approach, [that is actually mentioned](https://github.com/astral-sh/ruff/pull/7203#discussion_r1318263447) in the issue referenced above.

Let's assume we have a bunch of errors in a file that all have the same error message, I'll blatantly reuse the example by @MichaReiser in the above linked thread:

Let's say we have two unused variable diagnostics in a file:

```
x = 1
y = 2
```
There's a hash collision for x and y, so y performs a second hashing round and we now fix the first violation

```
x = 1
y = 2
print(x)
```
There's no longer a hash collision for y, meaning that the diagnostic for y now gets the hash (fingerprint) of the violation that used to be for x.

If I do this in gitlab's code quality, assuming I had a report generated on my target merge branch generated with these two errors, I might end up with a case where:
- y's unused error is now marked fixed even though it isn't
- x's unused error is still present and not marked as fixed even though it is.

You can also imagine plenty of other scenarios, where I fix a bunch of errors like the one above, but I introduce other identical errors later in the code, following the same logic, the fixed ones will not be marked as fixed and the new ones won't even be picked up and displayed as a new error.

Specific scenario
---

To bring this back to my specific scenario, I noticed problems while doing some various tests of the feature where I would add docstrings to functions missing them but then implement new functions without a docstring and would end up with the same error as above. Why is that? Because the missing docstring rule for a public function (D103) doesn't mention the name of the function for example and therefore all missing docstring errors are the same.

I understand the current implementation is still functional and the above examples are maybe fringe for most people but I still wanted to log it as it represents a limitation in our project.
I also wanted to know if anyone has any idea of how this could be improved without re-adding the line number which creates much more problems than the above.

---

_Label `great writeup` added by @MichaReiser on 2024-12-02 14:26_

---

_Comment by @MichaReiser on 2024-12-02 14:29_

Thanks for the great write up. 

We're interested in anyone's ideas on approaching this that doesn't rely on line numbers and isn't prone to the above problem. I tried to find some guidance or best practices from git lab but couldn't find any. 

Do you use any other linters in your project that doesn't have the limitation you outlined above?

---

_Comment by @mathieugouin on 2025-09-03 20:28_

If it can help:

I manually implemented a similar fix for a custom gitlab code quality generator I wrote.

The trick I used (and I think this would solve the example above), is to **also** include the line content (but **not** the line number) in the input for generating the hash.

This way, it much less need to use the "salt".

This logic was also included in Robocop linter for the Robot Framework testing languate, ref: https://github.com/MarketSquare/robotframework-robocop/issues/1116 and https://github.com/MarketSquare/robotframework-robocop/pull/1318


EDIT: Added "(but **not** the line number)"

---

_Comment by @bhirsz on 2025-09-03 20:54_

Yes, we did it in Robocop here:

https://github.com/MarketSquare/robotframework-robocop/blob/e55f3df6ad3b5b8d11ef34dadf2d0344f3aeea99/src/robocop/linter/reports/gitlab.py#L107

However since line content can be duplicated we also keep generating hash with added iterator index until unique hash is generated. 

Moving the code doesnt affect it so its upside. Downside is that fixing only some of the exact issues (ie you have 10 unused 'x' variables, and you fix 5) may lead to marking incorrect line as fixed. Unrelated changes in the same line may also lead to changing hash and marking line as both fixed and having new issue. But it still worked a lot better than using line numbers approach

---

_Comment by @mathieugouin on 2025-09-05 16:22_

If I can add also: I noticed that if `ruff check` is run on a windows host, the file path will have backslashes in the gitlab json output file.

From my tests, gitlab does not accepts backslashes in file paths.  I had to post process the gitlab file to convert to forward slashes and now it works.

Let me know if you think this should be in a separate issue.

---

_Comment by @ntBre on 2025-09-05 17:59_

That does sound like something we could resolve separately if you want to open a new issue, thanks for letting us know!

---
