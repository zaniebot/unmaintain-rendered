<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FAST002: catch Union with Annotated - astral-sh/ruff #21037</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>FAST002: catch Union with Annotated</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/21037">#21037</a>
        opened by <a href="https://github.com/wilt-vetrec">@wilt-vetrec</a>
        on 2025-10-23 00:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/wilt-vetrec">@wilt-vetrec</a> on 2025-10-23 00:29</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>I ran into an issue in FastAPI recently, where I defined a route with an optional array query parameter, like so:</p>
<pre><code class="language-python">@router.get(&quot;/optional_none_outside&quot;)
def optional_none_outside(params: Annotated[list[Literal[1,2]], Query()] | None = None):
    &quot;&quot;&quot;Incorrect; fails when called like /my_route?params=1 or like /my_route?params=1&amp;params=2&quot;&quot;&quot;
    ...

@router.get(&quot;/optional_none_inside&quot;)
def optional_none_inside(params: Annotated[list[Literal[1,2]] | None, Query()] = None):
    &quot;&quot;&quot;Correct; succeeds with any number of params&quot;&quot;&quot;
    ...
</code></pre>
<p>Full repro: https://replit.com/@wilt00/fastapi-query-annotation-repro#main.py</p>
<p>I'm not sure why this happens, but my understanding is that this is expected and not a bug in FastAPI. Ruff's lint rule FAST002 did not flag this error, and I think it should. I'm happy to work on adding this check.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @amyreese on 2025-10-23 00:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @amyreese on 2025-10-23 00:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-10-23 20:33</div>
            <div class="timeline-body"><p>I think this would have to be a different rule since FAST002 is only inspecting the default values looking for <code>Query</code>, <code>Depends</code>, etc. This would require validating the annotation itself and might be pretty tricky to get right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CoderJoshDK">@CoderJoshDK</a> on 2025-10-24 15:23</div>
            <div class="timeline-body"><p>After thinking about this more, I am not sure that this needs to be solved as a <code>FAST</code> based rule. This should either be a new lint or something a type aware system can handle.</p>
<p><sub>Or nuclear option of &quot;this is a bug with fastAPI, and they should fix it&quot;</sub></p>
<p>The reason I say that is because if we inspect the following:</p>
<pre><code class="language-py">from typing import Annotated, get_type_hints

def f(a: Annotated[str, &quot;test data&quot;]): ...
def z(a: Annotated[str, &quot;test data&quot;] | None): ...
def b(a: Annotated[str | None, &quot;test data&quot;]): ...


get_type_hints(f, include_extras=True)
# {'a': typing.Annotated[str, 'test data']}
get_type_hints(z, include_extras=True)
# {'a': typing.Optional[typing.Annotated[str, 'test data']]}
get_type_hints(b, include_extras=True)
# {'a': typing.Annotated[str | None, 'test data']}
</code></pre>
<p>We can see that <code>a</code> gets converted into an optional annotated object. This obfuscates the <code>Annotated</code> with a compound type. That type should ideally be contained inside the <code>typing.Annotated</code>. IE, this is a bad practice regardless of <code>fastapi</code> or not. Very few libraries handles this case properly. And instead of saying all libraries have some bug, it might be easier to say that it is bad practice to obfuscate the annotated type behind some other type (optional in this instance, but union should also be discouraged).</p>
<p>The major counterpoint to my whole stance is that cpython totally does support complex types like this. And a library should be capable of handling this situation. A thread that might be worth reading up on is https://discuss.python.org/t/what-is-the-right-way-to-extract-pep-593-annotations/42424/27</p>
<p>Anyway, even with that fact; introducing a lint rule that says &quot;Annotated should be the top level type&quot; still sounds like a good idea to me. There are plenty of other rules that are not objective truths to how code can be interpreted, but rather subjective truths to how to write good code. And it might be quite the code smell to have such a complicated <code>Annotated</code> situation. And if you disagree for your uncommon situation, you disable the rule (or never enable it in the first place?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/21079.html">astral-sh/ruff#21079</a> on 2025-10-26 03:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on 2025-12-16 18:27</div>
            <div class="timeline-body"><p>I don't think a general rule &quot;Annotated should be the top level type&quot; makes sense. Annotated has no precise semantics, but there are definitely possible use cases where it should not be the outermost type. For example, you might annotate strings that are meant to serve as regexes as say <code>Annotated[str, &quot;regex&quot;]</code>, and then <code>Annotated[str, &quot;regex&quot;] | None</code> is a completely sensible type.</p>
<p>If this is a common issue with FastAPI specifically, the rule should look for FastAPI-style usages of Annotated only.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-16 19:02</div>
            <div class="timeline-body"><p>Hmm, maybe this pattern is more common than we thought. It definitely comes up in a quick <a href="https://github.com/search?q=language%3Apython+%2FAnnotated%5C%5B%5B%5E%2C%5D%2B%2C+%5B%5E%5D%5D%2B%5D+%5C%7C%2F&amp;type=code&amp;p=2">GitHub search</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CoderJoshDK">@CoderJoshDK</a> on 2025-12-16 19:04</div>
            <div class="timeline-body"><p>In principle, I agree with you, Jelle. In practice, the challenge is that some people use <code>Annotated</code> &quot;wrong&quot; (Â¿in incompatible ways?). Both users and library authors.
<sub>Use and consume wrong</sub></p>
<p>After thinking about it a bunch more, I think you are right. Shocker lol.</p>
<p>That said, I am uneasy about how &quot;Annotated has no precise semantics&quot; and the ecosystem seems to disagree (at times) on its use. The lint rule would unfairly &quot;punish&quot; users when, in reality, library authors hold the same amount of blame. Perhaps this is a limitation of Annotated. It extends an object to carry metadata. And that can be very powerful. But there is also no way to express to a consumer that this metadata might be expected in a specific way. Not without sending them to docs. Ideally, my LSP should provide me with everything I need.</p>
<p>Is this a python limitation? Perhaps it is. And perhaps this convo should be extended beyond ruff. But bringing it back to ruff for a second, I do wonder if there is <em>a</em> potential lint rule to help guide the ecosystem. If there is one, it probably isn't the proposed one (the linked PR). I might go off and do more research and come back with some examples of real world use. Let's see if I find the time for that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on 2025-12-16 19:36</div>
            <div class="timeline-body"><p>I am not too familiar with FastAPI, but it sounds like a lint rule that specifically looks for use of <code>fastapi.Query</code> (and perhaps other FastAPI-specific objects that should always be at the top level) in a non-top-level Annotated should work.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:16 UTC
    </footer>
</body>
</html>
