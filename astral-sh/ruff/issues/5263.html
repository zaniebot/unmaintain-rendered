<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Release build fails in assert_eq_size! with Rust nightly ≥ 2023-06-09 - astral-sh/ruff #5263</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Release build fails in assert_eq_size! with Rust nightly ≥ 2023-06-09</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/issues/5263">#5263</a>
        opened by <a href="https://github.com/andersk">@andersk</a>
        on 2023-06-21 18:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/andersk">@andersk</a></div>
            <div class="timeline-body"><pre><code>error[E0512]: cannot transmute between types of different sizes, or dependently-sized types
   --&gt; crates/ruff_formatter/src/format_element.rs:449:5
    |
449 |     assert_eq_size!(crate::format_element::Tag, [u8; 16]);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: source type: `Tag` (192 bits)
    = note: target type: `[u8; 16]` (128 bits)
    = note: this error originates in the macro `assert_eq_size` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0512]: cannot transmute between types of different sizes, or dependently-sized types
   --&gt; crates/ruff_formatter/src/format_element.rs:452:5
    |
452 |     assert_eq_size!(crate::FormatElement, [u8; 24]);
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    |
    = note: source type: `format_element::FormatElement` (256 bits)
    = note: target type: `[u8; 24]` (192 bits)
    = note: this error originates in the macro `assert_eq_size` (in Nightly builds, run with -Z macro-backtrace for more info)

For more information about this error, try `rustc --explain E0512`.
error: could not compile `ruff_formatter` (lib) due to 2 previous errors
</code></pre>
<p>This is because Rust inflated <code>TypeId</code> from 64 bits to 128 bits (rust-lang/rust#109953).</p>
<p>The affected <code>format_element::tag::LabelId</code> struct is currently never constructed and its <code>id: TypeId</code> field is never used. I don’t know what you plan to use this for, but does it need the extensibility of <code>TypeId</code>, or would a simple <code>enum</code> suffice?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-21 18:49</div>
            <div class="timeline-body"><p>\cc @MichaReiser</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-06-21 20:32</div>
            <div class="timeline-body"><p>Thanks for reporting this new issue. According to https://github.com/rust-lang/compiler-team/issues/608, the main reason of the change is to avoid collisions between two type ids.</p>
<blockquote>
<p>With a 64 bit hash, the probability of collision is 1 in 2^32 (due to the birthday bound) -- 1 in roughly 4 billion.</p>
</blockquote>
<p>I recommend that we simply hash the <code>TypeId</code> and store a <code>u64</code> in <code>Labelid</code> instead. The risk of a collision is extremely low because:</p>
<ul>
<li>All <code>Label</code> types are local to a single crate</li>
<li>Each language only uses a few Labels (Rome uses 2-3?)</li>
<li>Label's are mainly used to <em>mark</em> some content and immediately test in the parent formatter if it has been set. It's rare (or even non-existing?) that a formatter matches on multiple labels (is it label A or B).</li>
</ul>
<p>We can further mitigate this issue by manually implement <code>PartialEq</code> and also assert that the type names are equal to get a compile error if the assumption does not uphold.</p>
<blockquote>
<p>or would a simple enum suffice?</p>
</blockquote>
<p>We aren't using an <code>enum</code> (we could) because <code>ruff_formatter</code> is supposed to be language agnostic (you can use it to implement formatting for many languages. The formatter even uses itself to format the IR). Switching to an enum would introduce language-specific code and limits the extensibility because adding a new label becomes restricted to those that can change <code>ruff_formatter</code>. I don't think this is a huge concern since we're only supporting a single language, but it is regressing the design.</p>
<p>Edit: Another alternative is to use string labels. String labels have the downside that collisions are even more likely (because someone accidentally re-uses an existing name) and comparing strings is more expensive than comparing numbers.</p>
<p>The safest (and least clever?) may be to introduce a new trait that defines two methods:</p>
<ul>
<li><code>value() -&gt; u64</code>: Returns the <code>Label</code> value</li>
<li><code>debug_text() -&gt; &amp;'static str</code></li>
</ul>
<p><code>LabelId</code> then only accepts a type implementing the new trait and calls into <code>value</code> and <code>debug_text</code> internally. This  avoids collisions as long as each formatter only uses a single enum that defines all labels. Mixing labels between formatters is discouraged anyway</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2023-06-21 21:26</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:47:31 UTC
    </footer>
</body>
</html>
