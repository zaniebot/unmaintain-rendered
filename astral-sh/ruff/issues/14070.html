<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[Rule Request] Enforce consistency between `import ...` and `from ... import ...` - astral-sh/ruff #14070</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>[Rule Request] Enforce consistency between `import ...` and `from ... import ...`</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/ruff/issues/14070">#14070</a>
        opened by <a href="https://github.com/jimmyt857">@jimmyt857</a>
        on 2024-11-04 00:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/jimmyt857">@jimmyt857</a> on 2024-11-04 00:41</div>
            <div class="timeline-body"><p>When it comes to readability, consistency is the most important factor. Our team would love to see a rule that does the following:</p>
<p>Before:</p>
<pre><code>from a.b import c
from d.e import g as f
import u.v as v
import x.y as z
</code></pre>
<p>After (<code>Option 1</code>):</p>
<pre><code>from a.b import c
from d.e import g as f
from u import v
from x import y as z
</code></pre>
<p>After (<code>Option 2</code>):</p>
<pre><code>import a.b.c as c
import d.e.g as f
import u.v as v
import x.y as z
</code></pre>
<p>Whether <code>Option 1</code> or <code>Option 2</code> is used would be a configurable parameter. Our team prefers Option 2 because it visually separates the full module name from the alias, and because it makes reverse dependency lookups via search/grepping easier. But I imagine other teams might prefer Option 1, and I noticed there is already a rule (<a href="https://docs.astral.sh/ruff/rules/manual-from-import/">PLR0402</a>) which would be incompatible with option 2.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-11-04 07:06</div>
            <div class="timeline-body"><p>@AlexWaygood what's your take on this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-11-04 18:41</div>
            <div class="timeline-body"><p>So to clarify, PLR0402 currently complains about the first of these, but not the second -- i.e., it only complains if the name the submodule is being aliased to is actually the same as the last part of the submodule's name:</p>
<pre><code class="language-py">import x.y as y
import x.y as z
</code></pre>
<p>One way of interpreting @jimmyt857's issue here is that it would be nice to also have a rule that complained about the second of these. I can see why many people might prefer that as a stylistic preference. I'm torn whether it should be part of PLR0402 or a separate rule, though. On the one hand it feels more pedantic and opinionated than what PLR0402 does currently:</p>
<ul>
<li>The first of these import statements really does feel like a &quot;redundant&quot; alias, a reinvention of <code>from</code> imports. The second feels ~fine to me, but as I say, I can see why some people might not like it from a consistency perspective.</li>
<li>But having a new rule just for complaining about the second pattern feels almost like overkill, given how similar it would be to what PLR0402 already does</li>
<li>Maybe we could make PLR0402 configurable? By default, it would only complain about the first pattern, but if you enabled a setting, it would also complain about the second pattern? But we already have so many configuration settings :(</li>
</ul>
<p>But @jimmyt857 also says that his <em>real</em> preference would be to enforce the <em>opposite</em> of what PRL0402 currently enforces -- he <em>ideally</em> wants a rule that would enforce using <code>import x.y as y</code> instead of <code>from x import y</code>. I don't think we should add a new rule to do this: it's really confusing when we have different rules that recommend contradictory things. Possibly, again, we could make PLR0402 configurable so that you could reverse the kinds of things it complains about -- but I'm not sure it's worth it here... it's just my opinion, but I think Option (1) is the more common preference among Python programmers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[Rule Request] Enforce consistency between `import a.b.c as d` and `from a.b import c as d`" to "[Rule Request] Enforce consistency between `import ...` and `from ... import ...`" by @jimmyt857 on 2024-11-04 21:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jimmyt857">@jimmyt857</a> on 2024-11-04 21:47</div>
            <div class="timeline-body"><p>Yep, you got it @AlexWaygood! Another way of phrasing this request is that it should enforce either that all import lines start with <code>from</code> or that all import lines start with <code>import</code>. There would be a few exceptions in either case, e.g. we wouldn't want to force changes to <code>import enum</code>, <code>import numpy as np</code> or <code>from typing import Callable</code>.</p>
<p>The current state of affairs is the worst of all worlds; the two styles are mixed throughout our codebase and even within individual python files. If only Option 1 (all imports start with <code>from</code>) was supported, it would still be an improvement. I got chatgpt to help generate a more interesting example:</p>
<p>Mixed:</p>
<pre><code class="language-python">import internal_package.module_h as module_h
import internal_package.module_one as module_one
import internal_package.module_two as module_two
import internal_package.submodule_a.submodule_b as submodule_b
import internal_package.submodule_c as submodule_c
import internal_package.submodule_d as d_submodule
from internal_package.submodule_e import logger as log
import internal_package.submodule_f.submodule_g
from internal_package.submodule_i.submodule_j as api_client
import internal_package.submodule_k as submodule_k
import internal_package.submodule_l.submodule_m as submodule_m
from internal_package.submodule_n import formatter as fmt
import internal_package.utils.data_processor as data_processor
</code></pre>
<p><code>Option 1</code></p>
<pre><code class="language-python">from internal_package import module_h
from internal_package import module_one
from internal_package import module_two
from internal_package.submodule_a import submodule_b
from internal_package import submodule_c
from internal_package import submodule_d as d_submodule
from internal_package.submodule_e import logger as log
from internal_package.submodule_f import submodule_g
from internal_package.submodule_i.submodule_j import api_client
from internal_package import submodule_k
from internal_package.submodule_l import submodule_m
from internal_package.submodule_n import formatter as fmt
from internal_package.utils.data_processor import data_processor
</code></pre>
<p><code>Option 2</code></p>
<pre><code class="language-python">import internal_package.module_h as module_h
import internal_package.module_one as module_one
import internal_package.module_two as module_two
import internal_package.submodule_a.submodule_b as submodule_b
import internal_package.submodule_c as submodule_c
import internal_package.submodule_d as d_submodule
import internal_package.submodule_e as log
import internal_package.submodule_f.submodule_g as submodule_g
import internal_package.submodule_i.submodule_j as api_client
import internal_package.submodule_k as submodule_k
import internal_package.submodule_l.submodule_m as submodule_m
import internal_package.submodule_n as formatter
import internal_package.utils.data_processor as data_processor
</code></pre>
<p>I agree that Option 1 is likely the more common preference, and should at least be the default setting. A configurable parameter would be nice though, because Option 2 has a few benefits:</p>
<ul>
<li>The normally-cited benefit of <code>from</code> statements, that they are shorter, is flipped when an alias is used; <code>from mylib1 import mylib2 as mylib3</code> is longer than <code>import mylib1.mylib2 as mylib3</code>.</li>
<li><code>from</code> statements make the reader jump across the <code>import</code> keyword and perform mental concatenation to figure out the module being imported. They are arguably less readable in the most important sense, which is the amount of time required to understand their meaning.</li>
<li>When doing a text-based search or grep of a codebase to find usages of a module, the <code>from</code> syntax makes the search query awkward (<code>grep -r &quot;mylib1 import mylib2&quot;</code> vs <code>grep -r &quot;mylib1.mylib2&quot;</code>). It will also miss string-based imports e.g. in test mocks like <code>with mock.patch(&quot;mylib1.mylib2.my_func&quot;)</code>, forcing the user to perform 2 separate searches (assuming they remember this edge case in the first place).</li>
<li><code>from</code> statements are inappropriate for standard libraries e.g. <code>import enum</code>, <code>import time</code>, etc, so the end result is less aesthetically appealing. <code>import</code> style has fewer exceptions (<code>typing</code> and <code>collections.abc</code> come to mind).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jimmyt857">@jimmyt857</a> on 2024-11-05 01:22</div>
            <div class="timeline-body"><p>Regarding the dilemma you've highlighted about how to structure the rules, IMO it would be reasonable to think of PLR0402 as a check for redundancy, and have a new rule that is focused on stylistic consistency, i.e. it checks all options (not merely <code>import x.y as z</code> but also <code>import x.y as y</code>). This makes the role of each rule very clear, at the cost of creating some overlap between the types of statements they operate on. With the default behavior being <code>Option 1</code>, the new rule would be in alignment with PLR0402 unless the user opts-out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @dhruvmanila on 2024-11-05 04:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @dhruvmanila on 2024-11-05 04:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/15639.html">astral-sh/ruff#15639</a> on 2025-01-21 18:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epenet">@epenet</a> on 2025-01-22 09:30</div>
            <div class="timeline-body"><p>I come here from a similar request in #15639.</p>
<p>I think it's very important to also consider functions, variables, or classes... which I don't think ruff is aware of, without type-inference and multi-file analysis.</p>
<p>With that in mind, I think implementing option 1 would be straightforward.</p>
<p>If the import is a top-level module, then it can't (and shouldn't) be changed:</p>
<pre><code class="language-python">import x
import y as z
</code></pre>
<p>If the import is a sub-level module, then it depends if there is an alias or not:</p>
<pre><code class="language-python">import a.b
import c.d as e

a.b.do_something()
e.do_something_else()
</code></pre>
<p>Only the aliased import can be converted safely:</p>
<pre><code class="language-python">from a import b # unsafe change
from c import d as e # safe change

# this one no longer works, and need to be adjusted
# a.b.do_something()
b.do_something()
# this one is safe
e.do_something_else()
</code></pre>
<p>I think it should be implemented as two separate opt-in rules.</p>
<ul>
<li>Rule 1 to prevent aliased sub-imports <code>import x.y as z</code> with safe fix to <code>from x import y as z</code></li>
<li>Rule 2 to prevent not-aliased sub-import <code>import x.y</code> with unsafe fix to <code>from x import y</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epenet">@epenet</a> on 2025-01-22 09:33</div>
            <div class="timeline-body"><p>Regarding option 2, I am not sure it can de done at all without type-inference and multi-file analysis.</p>
<p>How would ruff be able convert this?</p>
<pre><code class="language-python">from package import module as module_a
from package import function as function_a
</code></pre>
<p>Converting both wouldn't work:</p>
<pre><code class="language-python">import package.module as module_a # OK
import package.function as function_a # ImportError: No module named function
</code></pre>
<p>So I don't think it's a good idea to try to implement option 2</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epenet">@epenet</a> on 2025-01-22 09:44</div>
            <div class="timeline-body"><blockquote>
<p>I think it should be implemented as two separate opt-in rules.</p>
<ul>
<li>Rule 1 to prevent aliased sub-imports <code>import x.y as z</code> with safe fix to <code>from x import y as z</code></li>
<li>Rule 2 to prevent not-aliased sub-import <code>import x.y</code> with unsafe fix to <code>from x import y</code></li>
</ul>
</blockquote>
<p>I would also be happy if it was a configurable option for <code>PLR0402</code>:</p>
<ul>
<li>Checks for submodule imports that are aliased to the submodule name (default/current behavior)</li>
<li>Checks for submodule imports that are aliased (even if the alias is different from the submodule name - see <a href="https://github.com/astral-sh/ruff/issues/15639">#15639</a>)</li>
<li>Checks for submodule imports (even if there is no alias)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/21025.html">astral-sh/ruff#21025</a> on 2025-10-22 13:09</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:14 UTC
    </footer>
</body>
</html>
