<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Unpacking and for loop assignments to attributes - astral-sh/ruff #16004</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Unpacking and for loop assignments to attributes</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16004">#16004</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-02-06 21:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-02-06 21:52</div>
            <div class="timeline-body"><h2>Summary</h2>
<ul>
<li>Support assignments to attributes in more cases:<ul>
<li>assignments in <code>for</code> loops</li>
<li>in unpacking assignments</li>
</ul>
</li>
<li>Add test for multi-target assignments (these were already working, but untested)</li>
<li>Add tests for all other possible assignments to attributes that could possibly occur (in decreasing order of likeliness):<ul>
<li>augmented attribute assignments</li>
<li>attribute assignments in <code>with</code> statements</li>
<li>attribute assignments in comprehensions</li>
<li>Note: assignments to attributes in named expressions are not syntactically allowed</li>
</ul>
</li>
</ul>
<p>closes #15962</p>
<h2>Test Plan</h2>
<p>New Markdown tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-02-06 21:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-02-06 21:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-02-06 21:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-02-06 21:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] For loop and unpacking assignments for attributes" to "[red-knot] Unpacking and for loop assignments to attributes" by @sharkdp on 2025-02-06 21:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-06 21:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:246 on 2025-02-06 21:54</div>
            <div class="timeline-body"><p>This was already working, just added a test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-06 21:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:341 on 2025-02-06 21:56</div>
            <div class="timeline-body"><p>The TODO message was not quite right here, I think <code>Unknown | int</code> / <code>Unknown | str</code> are the correct types here. There is no declaration.</p>
<p>The attributes could technically also be unbound. We don't discover this in other cases either, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:354 on 2025-02-06 21:57</div>
            <div class="timeline-body"><p>I don't know <em>why</em> anyone would do something like this, but while we're at it …</p>
<p>(Mypy and pyright support this)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-06 21:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-06 21:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:376 on 2025-02-06 21:57</div>
            <div class="timeline-body"><p>And this is even weirder....</p>
<p>(Mypy and pyright support this)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-06 22:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/attribute_assignment.rs</code>:30 on 2025-02-06 22:01</div>
            <div class="timeline-body"><p>With the new variants, this now looks similar to <code>CurrentAssignment</code>, but there are differences, and also, attribute assignments are not supported in all scenarios. For example, the target in a <em>name</em>d expression can only be a … <em>name</em>! So something like <code>(self.x := 1)</code> is not legal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:341 on 2025-02-06 22:02</div>
            <div class="timeline-body"><p>Yes, determining that an attribute is definitely-initialized is a complex problem that I think we should defer for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:345 on 2025-02-06 22:03</div>
            <div class="timeline-body"><pre><code class="language-suggestion">#### Attributes defined in comprehensions
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-06 22:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4259 on 2025-02-06 22:06</div>
            <div class="timeline-body"><p>I need to think about this again and maybe write a comment here, but I think it would be a bug if we would fail to look up <code>attribute_expression_id</code>, so I made this a hard error instead of doing <code>if let Some(…inferred_ty) = ….get(…) { … }</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:376 on 2025-02-06 22:06</div>
            <div class="timeline-body"><p>FWIW, this case is closely related to the &quot;nested function&quot; case, which is tested at the very end of this test file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-06 22:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4240 on 2025-02-06 22:15</div>
            <div class="timeline-body"><p>I expect they would still be reported by normal type inference, no? So I'm not sure any special handling is needed here, thus maybe we don't need a TODO either?</p>
<p>Maybe ideally we'd add some tests for cases where diagnostics occur either in iteration, or more generally in type inference of the RHS of a <code>self.x = ...</code> assignment, and verify that we do surface those diagnostics.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4259 on 2025-02-06 22:16</div>
            <div class="timeline-body"><p>Yes, the <code>attribute_expression_id</code> should always be the ID of a target of the unpacking, and unpacking should always populate a type for each target. I guess the latter is not really comprehensively guaranteed at the moment; it depends on the <code>match target</code> in <code>Unpacker::unpack_inner</code> being comprehensive over all possible target forms. But as long as it covers all the forms that we ever create an assignment for in semantic index building, it will be fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:203 on 2025-02-06 22:18</div>
            <div class="timeline-body"><p>Doesn't really matter, but I think this could be just <code>pub(super)</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-02-06 22:19</div>
            <div class="timeline-body"><p>Love it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @MichaReiser on 2025-02-07 07:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-02-07 07:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4259 on 2025-02-07 08:37</div>
            <div class="timeline-body"><p>Yeah, that's correct. The unpacker should populate for each target variable even in the case of length mismatch. I think that wasn't the case in the first iteration but is now guaranteed by this loop:</p>
<p>https://github.com/astral-sh/ruff/blob/a00483a7856cfe5b8c1c59a0e5633a4906d865df/crates/red_knot_python_semantic/src/types/unpacker.rs#L167-L174</p>
<p>Not related to this PR but I think we should also update other places where unpacking is done to consider this a hard error, currently it uses <code>unwrap_or(Type::unknown())</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:77 on 2025-02-07 08:39</div>
            <div class="timeline-body"><p>Can we add test cases when the unpacking target is a starred attribute? Like:</p>
<pre><code class="language-py">In [9]: class Foo:
   ...:     def __init__(self):
   ...:         self.x = (1, 2)
   ...: 
   ...: 
   ...: foo = Foo()
   ...: print(foo.x)
   ...: 
   ...: (a, *foo.x) = (1, 2, 3)
   ...: print(foo.x)
(1, 2)
[2, 3]
</code></pre>
<p>Ignore if it's already present but I didn't find it in the diff of this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-07 08:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-07 08:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:77 on 2025-02-07 08:41</div>
            <div class="timeline-body"><p>(We don't yet support inferring the type here because it requires generic support over list)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-07 08:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4259 on 2025-02-07 08:44</div>
            <div class="timeline-body"><p>We <em>could</em> make this an invariant on Unpacker and update the return type of <code>get</code> to <code>Type</code> to avoid the <code>.expect</code> calls to be spread across similar to how we have methods that directly indexes the inference result.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-07 09:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4259 on 2025-02-07 09:27</div>
            <div class="timeline-body"><blockquote>
<p>currently it uses <code>unwrap_or(Type::unknown())</code>.</p>
</blockquote>
<p>Yes, that's the main reason why I was hesitant. I can look into that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-07 09:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4240 on 2025-02-07 09:55</div>
            <div class="timeline-body"><blockquote>
<p>I expect they would still be reported by normal type inference, no?</p>
</blockquote>
<p>I also hoped that would be the case, but no. We emit the <code>non-iterable</code> diagnostic from <code>infer_for_statement_definition</code>, and attribute assignments are not definitions. I added a test to demonstrate this.</p>
<p>~~We have a similar problem where we do not yet identify cases where (normal) assignments to attributes conflict the declared type of that attribute. We have existing tests for this as well.~~</p>
<p>(Edit: no, I already implemented this :smile:)</p>
<p>I'll also open a new ticket to address both of these issues.</p>
<blockquote>
<p>or more generally in type inference of the RHS of a <code>self.x = ...</code> assignment</p>
</blockquote>
<p>The general case works fine. We only fail to emit diagnostics if they originate from <code>infer_…_definition</code> calls, which do not apply to attribute assignments. I added the following test case:</p>
<pre><code class="language-py">class C:
    def __init__(self) -&gt; None:
        # error: [too-many-positional-arguments]
        self.x: int = len(1, 2, 3)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-02-07 10:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-02-07 10:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-02-07 10:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-07 11:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4259 on 2025-02-07 11:19</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/pull/16018</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:57:52 UTC
    </footer>
</body>
</html>
