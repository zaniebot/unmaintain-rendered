<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rename `SemanticModel::is_builtin` to `SemanticModel::has_builtin_binding` - astral-sh/ruff #10991</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Rename <code>SemanticModel::is_builtin</code> to <code>SemanticModel::has_builtin_binding</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/10991">#10991</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-04-17 09:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body">Summary
<p><code>SemanticModel::is_builtin</code> returns <code>true</code> if a <em>symbol</em> has a builtin binding in the current scope (i.e., the name is bound because it is part of the builtins scope that Python pre-populates without any imports or assignments specified by the user). This is distinct to <code>SemanticModel::resolve_builtin_symbol</code> and <code>SemanticModel::match_builtin_expr</code>, which can be used to determine whether an AST <em>node</em> refers to a symbol from the <code>builtins</code> module.</p>
<p>This PR renames <code>SemanticModel::is_builtin</code> to <code>SemanticModel::has_builtin_binding</code>, to make the distinction between these different methods clearer</p>
Test Plan
<p><code>cargo test</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-04-17 10:10</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-04-17 10:22</div>
            <div class="timeline-body"><blockquote>
<p>This is distinct to SemanticModel::resolve_builtin_symbol and SemanticModel::match_builtin_expr, which can be used to determine whether an AST node refers to a symbol from the builtins module.</p>
</blockquote>
<p>I don&#x27;t think I follow what the distinction is (and thus, why the new name is more explicit). Is the distinction that one resolves an expression and the other a name?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-04-17 10:32</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t think I follow what the distinction is (and thus, why the new name is more explicit). Is the distinction that one resolves an expression and the other a name?</p>
</blockquote>
<p>Partly, yes. I think the name implies currently that you could use it to test whether a node refers to a builtin symbol or not, but it&#x27;s not the correct method to use for that purpose.</p>
<p>I also find calling it <code>is_builtin</code> confusing because it&#x27;s <em>not</em> checking whether a symbol is available in the <code>builtins</code> scope by default -- it&#x27;s checking whether a symbol <em>has a builtin binding</em> at the specific point when we&#x27;re calling into the semantic model. I.e.</p>
<pre><code>...  # &lt;-- If we&#x27;re analysing this node, `semantic.is_builtin(&quot;print&quot;)` returns true

print = &quot;foo&quot;

...  # &lt;-- but at this later point in the same module, it no longer does,
     # because `print` now has a local binding rather than a builtin binding
</code></pre>
<p><code>print</code> is still a builtin at the point of the second call, in that it&#x27;s still available in the builtin scope; you can still access it from Python code by importing <code>builtins</code> and accessing it via <code>builtins.print</code>. But it no longer has a builtin <em>binding</em> in this scope; the builtin binding has been overridden by a local binding, which takes precedence when looking up the <code>print</code> name in that scope.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-04-17 10:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-04-17 10:35</div>
            <div class="timeline-body"><p>Thanks for the explanation. So for me, the importance of the renaming is really about making it clear that it isn&#x27;t a function that tests if <code>name</code> maps to a builtin name, but tests whether name is bound to a builtin (right now)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-04-18 10:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-04-18 10:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-04-18 10:11</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:03:30 UTC
    </footer>
</body>
</html>
