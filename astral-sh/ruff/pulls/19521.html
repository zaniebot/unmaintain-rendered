<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Added support for &quot;document symbols&quot; and &quot;workspace symbols&quot; - astral-sh/ruff #19521</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Added support for &quot;document symbols&quot; and &quot;workspace symbols&quot;</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19521">#19521</a>
        opened by <a href="https://github.com/UnboundVariable">@UnboundVariable</a>
        on 2025-07-24 06:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a></div>
            <div class="timeline-body"><p>This PR adds support for &quot;document symbols&quot; and &quot;workspace symbols&quot; language server features. Most of the logic to implement these features is shared.</p>
<p>The &quot;document symbols&quot; feature returns a list of all symbols within a specified source file. Clients can specify whether they want a flat or hierarchical list. Document symbols are typically presented by a client in an &quot;outline&quot; form. Here&#x27;s what this looks like in VS Code, for example.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/82b11f4f-32ec-4165-ba01-d6496ad13bdf"></p>
<p>The &quot;workspace symbols&quot; feature returns a list of all symbols across the entire workspace that match some user-supplied query string. This allows the user to quickly find and navigate to any symbol within their code.</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/aac131e0-9464-4adf-8a6c-829da028c759"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-24 06:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-24 06:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-24 06:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-24 06:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-24 06:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-24 06:34</div>
            <div class="timeline-body">

<code>mypy_primer</code> results
<p>No ecosystem changes detected ✅
No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/AlexWaygood">@AlexWaygood</a> removed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-24 07:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">server</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-24 09:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-24 09:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-24 10:00</div>
            <div class="timeline-body"><p>Can you tell me more why this use its own visitor over e.g. using the <code>semantic_index</code>, iterating over each scope and retrieving all names from the place table?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-24 10:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-24 20:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-24 20:51</div>
            <div class="timeline-body"><p>I actually implemented it both ways. I started with the approach you&#x27;re suggesting here. There were a couple of issues I ran into.</p>
<ol>
<li>It required me to expose a bunch of APIs publicly from the <code>ty_python_semantic</code> crate. Alternatively (and this is what I did in my initial implementation) push all of the symbol extraction logic down into the <code>ide_support.rs</code> module.</li>
<li>It produced subtly different results than what you get with a visitor implementation. For example, symbols that are synthesized but don&#x27;t appear within the sources are &quot;seen&quot; in the place table. Also, the ordering of symbols ends up being different from source order when you use the place table.</li>
</ol>
<p>I&#x27;m sure we could overcome these problems if we were to use the semantic index, but I think the visitor approach will also be much better for performance. We really don&#x27;t want to do unnecessary semantic indexing just to enumerate the externally-visible symbols in a file when it&#x27;s possible to do this with a simple AST walk — especially one that is able to skip most of the leaf nodes in the tree. Performance is important for multi-file symbol searches in large projects. It will become even more important once we implement &quot;auto import&quot; for the completion provider because that feature will require us to do symbol enumeration for not only project sources but also libraries and stubs. That potentially translates to tens of thousands of source files. Semantically indexing that many files will consume significant time and memory.</p>
<p>I&#x27;ll also note that pyright implements this feature using a visitor approach. To the extent that we want to roughly match the behavior of pyright and pylance, a visitor approach here will help us do that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-25 06:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-25 06:42</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;m sure we could overcome these problems if we were to use the semantic index, but I think the visitor approach will also be much better for performance.</p>
</blockquote>
<p>I think that heavily depends. ty has all semantic index hot in cache when a user uses workspace diagnostics. Therefore, traversing the semantic index should be much cheaper as it is a constant time lookup. Now, we&#x27;ll probably enable LRU for semantic indices in the future, in which ase this would no longer be true.</p>
<blockquote>
<p>We really don&#x27;t want to do unnecessary semantic indexing just to enumerate the externally-visible symbols in a file when it&#x27;s possible to do this with a simple AST walk</p>
</blockquote>
<p>If this is what we do, have you considered using <code>exported_names</code>? It&#x27;s a lightweight salsa query that only returns the exported names of a file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-25 07:30</div>
            <div class="timeline-body"><p>An extra visitor seems fine in an initial version, but I&#x27;m a bit concerned that we now have <code>exported_modules</code> (only traverses top level), <code>semantic_index</code>, and the visitor here that all roughly do the same (but with slightly differences).</p>
<p>Not using <code>semantic_index</code> also has the downside that we don&#x27;t leverage any caching because we clear the <code>parsed_module</code> after an initial check. That means, we end up reparsing every single file in the project and then traverse all of them. A second symbol lookup will then retraverse all files again without any form of caching whatsoever.</p>
<p>Did you test this on a large project (e.g. homeassistant)? How responsive is ty for whole project symbols?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-25 16:50</div>
            <div class="timeline-body"><blockquote>
<p>Did you test this on a large project (e.g. homeassistant)? How responsive is ty for whole project symbols?</p>
</blockquote>
<p>Yes, for large projects, it&#x27;s way more responsive than I expected it would be! <code>homeassistant</code> is a good stress test here because it contains over 20K files. On my machine, it takes about 4 seconds to do a workspace symbols query from a cold start. Subsequent workspace queries take slightly less than 1 second. This assumes the query string has several characters. If the query string is a single character like <code>a</code>, it still takes a little over two seconds because there are so many matches returned.</p>
<p>By comparison, pyright takes a little more than 10 seconds on a cold start for this same test. Subsequent searches take 6 seconds. So ty is already significantly faster than pyright here.</p>
<p>Pylance adds a symbol indexer on top of pyright. Once its indexer runs on <code>homeassistant</code>, it&#x27;s able to perform workspace queries in about 1 second — similar to ty&#x27;s performance without an index.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-07-25 17:13</div>
            <div class="timeline-body"><p>I&#x27;d be interested in @carljm&#x27;s take on the visitor.</p>
<p>Regarding performance. This seems good enough so that it doesn&#x27;t need to block this PR.</p>
<p>I think the way I would implement this with salsa caching is that the visitor collects all symbols for a single file and that result would be cached by salsa. The matching of the symbol name to the name provided in the query then needs to happen outside the visitor (but that should be extremelly fast). Can you open a follow up issue that we should look into caching workspace symbols (or document symbols)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-07-25 17:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-25 17:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-25 17:18</div>
            <div class="timeline-body"><p><code>exported_names</code> relies on the semantic index. Running the semantic index on every file in a large project will take a long time and consume significant memory. Initial workspace queries will be quite slow unless (as you mentioned) the user has opted for workspace diagnostics. (It&#x27;s not clear to me which percentage of users will choose workspace diagnostics versus openFileOnly diagnostics.) Subsequent queries will be faster, assuming that the salsa working set remains in memory.</p>
<p>Running the semantic indexer on every file in the project <em>plus</em> all vendored stubs <em>plus</em> all files in the configured Python environment will almost definitely lead to performance and memory problems, so that approach won&#x27;t work for the auto-import feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-25 17:20</div>
            <div class="timeline-body"><p>The question of reusing semantic index seems more complex, I don&#x27;t have a strong feeling there. I do think that ideally we would unify the existing <code>exported_symbols</code> query and this new visitor -- I don&#x27;t really see any daylight between them in terms of what they are supposed to do (other than of course whether nested scopes are visited, but that seems like a simple flag).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-25 17:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-25 17:21</div>
            <div class="timeline-body"><p>I don&#x27;t think <code>exported_names</code> depends on the semantic index.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-25 17:41</div>
            <div class="timeline-body"><p><code>exported_names</code> doesn&#x27;t depend on semantic indexing.</p>
<p>It does, however, eagerly follow <code>*</code> imports (with fixpoint iteration to resolve cycles) so as to include <code>*</code> imported names in the symbols list.</p>
<p>In fact, I think that&#x27;s a more general difference -- this new visitor finds only locally-defined symbols, it doesn&#x27;t include imported symbols. (It also seems to potentially miss some, though less-common ones -- e.g. names defined by assignment expressions, <code>with</code> statements, <code>for</code> loops, etc -- arguably some of these, while technically available, maybe wouldn&#x27;t be desirable to include in a document-symbols list anyway?) But this is another difference in behavior that would have to be a flag if they were merged.</p>
<p>I do think that in some cases there could potentially be a lot of third-party files that are never imported by the first-party code, so we would never semantic index them otherwise, but I guess they should also be included in workspace symbols?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-25 17:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-25 19:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-25 19:05</div>
            <div class="timeline-body"><blockquote>
<p><code>exported_names</code> doesn&#x27;t depend on semantic indexing.</p>
</blockquote>
<p>Ah, good to know. I misunderstood that in the code. Then I agree that the visitor I implemented in this PR could potentially be unified with <code>exported_names</code> at some point.</p>
<p>Unless you have a strong opinion to the contrary, I think I&#x27;ll merge this PR and log an issue to track the work involved in investigating that union. As you point out, there will need to be some reconciliation of the functionality between the two, and some &quot;mode flags&quot; might be required to get the desired behaviors in all cases.</p>
<blockquote>
<p>I guess they should also be included in workspace symbols?</p>
</blockquote>
<p>The &quot;workspace symbols&quot; feature should never include symbols from third-party files. It&#x27;s limited to just workspace symbols. However, the auto-import feature (part of the &quot;completion suggestions&quot; feature) should include symbols from third-party files. The API that I wrote as part of this PR is intended to be used for both scenarios.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-25 19:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/symbols.rs</code>:89 on 2025-07-25 19:33</div>
            <div class="timeline-body"><p>Sounds good. Thanks for the discussion</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-25 20:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-25 20:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-25 20:07</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:16:57 UTC
    </footer>
</body>
</html>
