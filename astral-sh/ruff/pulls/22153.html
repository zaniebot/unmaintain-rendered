<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Synthesize a `_replace` method for NamedTuples - astral-sh/ruff #22153</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Synthesize a <code>_replace</code> method for NamedTuples</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22153">#22153</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2025-12-23 00:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Closes https://github.com/astral-sh/ty/issues/2170.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 00:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 00:41</div>
            <div class="timeline-body"><p>Mypy has the same behavior here. I'm not familiar enough to know whether this is the correct tradeoff, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-23 00:42</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-23 00:43</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">tornado (https://github.com/tornadoweb/tornado)
- tornado/gen.py:255:62: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `None | Awaitable[Unknown] | list[Awaitable[Unknown]] | dict[Any, Awaitable[Unknown]] | Future[Unknown]`, found `_T@next | _VT@next | _T@next`
+ tornado/gen.py:255:62: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `None | Awaitable[Unknown] | list[Awaitable[Unknown]] | dict[Any, Awaitable[Unknown]] | Future[Unknown]`, found `_T@next | _T@next | _VT@next`

xarray (https://github.com/pydata/xarray)
- xarray/core/dataarray.py:5744:16: error[invalid-return-type] Return type does not match returned value: expected `T_Xarray@map_blocks`, found `DataArray | Dataset`
+ xarray/core/dataarray.py:5744:16: error[invalid-return-type] Return type does not match returned value: expected `T_Xarray@map_blocks`, found `T_Xarray@map_blocks | DataArray | Dataset`
- xarray/core/dataset.py:8873:16: error[invalid-return-type] Return type does not match returned value: expected `T_Xarray@map_blocks`, found `DataArray | Dataset`
+ xarray/core/dataset.py:8873:16: error[invalid-return-type] Return type does not match returned value: expected `T_Xarray@map_blocks`, found `T_Xarray@map_blocks | DataArray | Dataset`

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Top[Index[Any]] | Top[Series[Any, Any]] | TypeBlocks | ... omitted 6 union elements, object_]`
+ static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Top[Bus[Any]] | TypeBlocks | Batch | ... omitted 6 union elements, object_]`

pandas-stubs (https://github.com/pandas-dev/pandas-stubs)
- pandas-stubs/_typing.pyi:1232:16: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 5106 diagnostics
+ Found 5105 diagnostics

core (https://github.com/home-assistant/core)
- homeassistant/util/variance.py:47:12: error[invalid-return-type] Return type does not match returned value: expected `(**_P@ignore_variance) -&gt; _R@ignore_variance`, found `_Wrapped[_P@ignore_variance, _R@ignore_variance | int | float | datetime, _P@ignore_variance, _R@ignore_variance | int | float | datetime]`
- Found 14427 diagnostics
+ Found 14426 diagnostics


</code></pre>
</details>

<p>No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Synthesize a `_replace` method for NamedTuples" to "[ty ]Synthesize a `_replace` method for NamedTuples" by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[ty ]Synthesize a `_replace` method for NamedTuples" to "[ty] Synthesize a `_replace` method for NamedTuples" by @charliermarsh on 2025-12-23 00:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 01:26</div>
            <div class="timeline-body"><p>In my test it looks like mypy gets the best of both worlds? It seems to have the precise <code>_replace</code> signature but also allow the assignability: https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=0eafcba956567980dfaada547a91e2ce</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 01:32</div>
            <div class="timeline-body"><p>It seems like mypy must be special-casing <code>_replace</code> on the protocol version of <code>NamedTuple</code> in order to achieve this, because it doesn't generally allow a similar protocol compatibility: https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=9ae6355cca81234089a0ea2d6a64b0f1</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4706 on 2025-12-23 01:39</div>
            <div class="timeline-body"><p>It's not clear to me why this is correct or what case fails without it. For class-level access, the <code>self</code> argument should be explicitly supplied, I'm not sure why we should be doing anything extra here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-12-23 01:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 02:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4706 on 2025-12-23 02:06</div>
            <div class="timeline-body"><p>Without this change, we get the following:</p>
<pre><code class="language-python">reveal_type(person._replace(name=&quot;Bob&quot;))  # revealed: Self
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 02:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 02:16</div>
            <div class="timeline-body"><p>I feel like I'm going crazy because I definitely saw a diagnostic here from mypy that told me that this wasn't assignable (and it included the specific incompatibility). I must've been mistaken. Will revisit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 02:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 02:31</div>
            <div class="timeline-body"><p>I'm guessing my implementation isn't quite right, but I tried to now special-case <code>_replace</code> in protocol checking...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 02:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 02:34</div>
            <div class="timeline-body"><p>Claude (reading mypy) claims that mypy treats <code>NamedTuple</code> specially as a nominal base type and bypasses method signature checking entirely?</p>
<p>https://github.com/python/mypy/blob/72cff30ce2d8db9fd6d8051b8c966ce9731c4fd4/mypy/subtypes.py#L531-L535</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 02:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4706 on 2025-12-23 02:47</div>
            <div class="timeline-body"><p>Another variant that has the same effect:</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types.rs b/crates/ty_python_semantic/src/types.rs
index a6374a3d18..da46f40709 100644
--- a/crates/ty_python_semantic/src/types.rs
+++ b/crates/ty_python_semantic/src/types.rs
@@ -4695,22 +4695,14 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 // method of these synthesized functions. The method-wrapper would then be returned from
                 // `find_name_in_mro` when called on function-like `Callable`s. This would allow us to
                 // correctly model the behavior of *explicit* `SomeDataclass.__init__.__get__` calls.
-                if instance.is_none(db) &amp;&amp; callable.is_function_like(db) {
-                    // For class-level access (like Person._replace), we still want to replace
-                    // Self with the class's instance type (owner), but we don't bind the self parameter
-                    let owner_instance = owner.to_instance(db).unwrap_or(owner);
-                    let with_self_replaced = Type::Callable(CallableType::new(
-                        db,
-                        callable.signatures(db).apply_self(db, owner_instance),
-                        callable.kind(db),
-                    ));
-                    return Some((with_self_replaced, AttributeKind::NormalOrNonDataDescriptor));
-                }
-                // Pass the instance type so that `typing.Self` is replaced with the actual type
-                return Some((
-                    Type::Callable(callable.bind_self(db, Some(instance))),
-                    AttributeKind::NormalOrNonDataDescriptor,
-                ));
+                return if instance.is_none(db) &amp;&amp; callable.is_function_like(db) {
+                    Some((self, AttributeKind::NormalOrNonDataDescriptor))
+                } else {
+                    Some((
+                        Type::Callable(callable.bind_self(db, None)),
+                        AttributeKind::NormalOrNonDataDescriptor,
+                    ))
+                };
             }
             _ =&gt; {}
         }
diff --git a/crates/ty_python_semantic/src/types/class.rs b/crates/ty_python_semantic/src/types/class.rs
index 71fef6825c..a2cb1047f4 100644
--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -2130,6 +2130,20 @@ impl&lt;'db&gt; ClassLiteral&lt;'db&gt; {
             }
         }
 
+        fn apply_self_to_callable&lt;'d&gt;(db: &amp;'d dyn Db, ty: Type&lt;'d&gt;, self_instance: Type&lt;'d&gt;) -&gt; Type&lt;'d&gt; {
+            match ty {
+                Type::Callable(callable_ty) if callable_ty.is_function_like(db) =&gt; {
+                    Type::Callable(callable_ty.apply_self(db, self_instance))
+                }
+                Type::Union(union) =&gt; {
+                    union.map(db, |element| apply_self_to_callable(db, *element, self_instance))
+                }
+                Type::Intersection(intersection) =&gt; intersection
+                    .map_positive(db, |element| apply_self_to_callable(db, *element, self_instance)),
+                _ =&gt; ty,
+            }
+        }
+
         let mut member = self.class_member_inner(db, None, name, policy);
 
         // We generally treat dunder attributes with `Callable` types as function-like callables.
@@ -2138,6 +2152,13 @@ impl&lt;'db&gt; ClassLiteral&lt;'db&gt; {
             member = member.map_type(|ty| into_function_like_callable(db, ty));
         }
 
+        // For callable members that use `Self` type variables (e.g., synthesized methods like
+        // `_replace` on NamedTuples), replace `Self` with the instance type of this class.
+        // This ensures that when accessing `Person._replace`, we get `(self: Person, ...) -&gt; Person`
+        // instead of `(self: Self, ...) -&gt; Self`.
+        let self_instance = Type::instance(db, ClassType::NonGeneric(self));
+        member = member.map_type(|ty| apply_self_to_callable(db, ty, self_instance));
+
         member
     }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-12-23 03:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:379 on 2025-12-23 03:02</div>
            <div class="timeline-body"><p>Yeah, looks like Claude is right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-12-23 03:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2165 on 2025-12-23 03:07</div>
            <div class="timeline-body"><p>What's not clear to me is why we are accessing <code>person._replace</code> on the class to begin with, when we are calling it on an instance. That's something we do for dunder methods (to mimic the runtime, which also does that), but it's not something we should do for a normal instance method call; <code>_replace</code> is not a dunder method. That seems to be at the root of the need for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/instance.rs</code>:144 on 2025-12-23 03:09</div>
            <div class="timeline-body"><p>I guess for the mypy equivalent we'd just totally short-circuit here and return true, since we've already done the work to check that we're comparing a named-tuple with <code>NamedTupleLike</code>. That seems... probably fine in practice? I'd want to see if @AlexWaygood knows of any reason we shouldn't just do that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2165 on 2025-12-23 03:13</div>
            <div class="timeline-body"><p>Or to put the same question in a more specific way: the previous version of the code had this special case in the branch where <code>instance</code> was <code>None</code> in the descriptor protocol. But that should not be the case for a call like <code>person._replace(...)</code>, where we clearly have an instance. So it seems like that's what we need to root-cause in order to fix this properly?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-12-23 03:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2025-12-23 03:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2165 on 2025-12-23 03:42</div>
            <div class="timeline-body"><p>With https://github.com/astral-sh/ruff/pull/22155, we now get the expected behavior for instances.</p>
<p>We still get <code>Self</code> for classes:</p>
<pre><code class="language-python">reveal_type(Person._replace)  # revealed: (self: Self, *, name: str = ..., age: int | None = ...) -&gt; Self
</code></pre>
<p>But perhaps that's expected?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-12-23 09:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @AlexWaygood on 2025-12-23 09:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-23 10:23</div>
            <div class="timeline-body"><p>I'd be inclined to revert the changes to <code>instance.rs</code> and just make the <code>NamedTupleLike</code> protocol in <code>ty_extensions.pyi</code> a little less precise. All tests pass with this change (except for the one that's modified slightly as part of the patch):</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/resources/mdtest/named_tuple.md b/crates/ty_python_semantic/resources/mdtest/named_tuple.md
index bf5b1e4d9b..812ff930c0 100644
--- a/crates/ty_python_semantic/resources/mdtest/named_tuple.md
+++ b/crates/ty_python_semantic/resources/mdtest/named_tuple.md
@@ -347,7 +347,7 @@ satisfy:
 def expects_named_tuple(x: typing.NamedTuple):
     reveal_type(x)  # revealed: tuple[object, ...] &amp; NamedTupleLike
     reveal_type(x._make)  # revealed: bound method type[NamedTupleLike]._make(iterable: Iterable[Any]) -&gt; NamedTupleLike
-    reveal_type(x._replace)  # revealed: bound method NamedTupleLike._replace(**kwargs) -&gt; NamedTupleLike
+    reveal_type(x._replace)  # revealed: bound method NamedTupleLike._replace(...) -&gt; NamedTupleLike
     # revealed: Overload[(value: tuple[object, ...], /) -&gt; tuple[object, ...], (value: tuple[_T@__add__, ...], /) -&gt; tuple[object, ...]]
     reveal_type(x.__add__)
     reveal_type(x.__iter__)  # revealed: bound method tuple[object, ...].__iter__() -&gt; Iterator[object]
diff --git a/crates/ty_python_semantic/src/types/instance.rs b/crates/ty_python_semantic/src/types/instance.rs
index 11780e6fc6..9e674065b9 100644
--- a/crates/ty_python_semantic/src/types/instance.rs
+++ b/crates/ty_python_semantic/src/types/instance.rs
@@ -3,7 +3,6 @@
 use std::borrow::Cow;
 use std::marker::PhantomData;
 
-use super::class::CodeGeneratorKind;
 use super::protocol_class::ProtocolInterface;
 use super::{BoundTypeVarInstance, ClassType, KnownClass, SubclassOfType, Type, TypeVarVariance};
 use crate::place::PlaceAndQualifiers;
@@ -133,16 +132,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
         relation_visitor: &amp;HasRelationToVisitor&lt;'db&gt;,
         disjointness_visitor: &amp;IsDisjointVisitor&lt;'db&gt;,
     ) -&gt; ConstraintSet&lt;'db&gt; {
-        // Iff we're checking a NamedTuple against NamedTupleLike, skip the `_replace` method
-        // signature. NamedTuples synthesize `_replace` methods with specific keyword-only
-        // parameters (to detect invalid arguments), which are not strictly subtypes of the
-        // protocol's `(**kwargs)` signature, but are intended to be considered as satisfying it.
-        let is_namedtuple_protocol_check = matches!(&amp;protocol.inner, Protocol::FromClass(class) if class.is_known(db, KnownClass::NamedTupleLike))
-            &amp;&amp; self.as_nominal_instance().is_some_and(|instance| {
-                let (class_literal, specialization) = instance.class(db).class_literal(db);
-                CodeGeneratorKind::NamedTuple.matches(db, class_literal, specialization)
-            });
-
         let structurally_satisfied = if let Type::ProtocolInstance(self_protocol) = self {
             self_protocol.interface(db).has_relation_to_impl(
                 db,
@@ -157,16 +146,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 .inner
                 .interface(db)
                 .members(db)
-                .filter(|member| {
-                    // Skip `_replace` check for NamedTuple vs NamedTupleLike. NamedTuples
-                    // synthesize `_replace` with specific keyword-only parameters to detect
-                    // invalid arguments, but this signature is not a strict subtype of the
-                    // protocol's `(**kwargs)` signature.
-                    if is_namedtuple_protocol_check &amp;&amp; member.name() == &quot;_replace&quot; {
-                        return false;
-                    }
-                    true
-                })
                 .when_all(db, |member| {
                     member.is_satisfied_by(
                         db,
diff --git a/crates/ty_vendored/ty_extensions/ty_extensions.pyi b/crates/ty_vendored/ty_extensions/ty_extensions.pyi
index 347b6b4b34..ed0bf16186 100644
--- a/crates/ty_vendored/ty_extensions/ty_extensions.pyi
+++ b/crates/ty_vendored/ty_extensions/ty_extensions.pyi
@@ -190,6 +190,16 @@ class NamedTupleLike(Protocol):
     @classmethod
     def _make(cls: type[Self], iterable: Iterable[Any]) -&gt; Self: ...
     def _asdict(self, /) -&gt; dict[str, Any]: ...
-    def _replace(self, /, **kwargs) -&gt; Self: ...
+
+    # Positional arguments aren't actually accepted by these methods at runtime,
+    # but adding the `*args` parameters means that all `NamedTuple` classes
+    # are understood as assignable to this protocol due to the special case
+    # outlined in https://typing.python.org/en/latest/spec/callables.html#meaning-of-in-callable:
+    #
+    # &gt; If the input signature in a function definition includes both a
+    # &gt; `*args` and `**kwargs` parameter and both are typed as `Any`
+    # &gt; (explicitly or implicitly because it has no annotation), a type
+    # &gt; checker should treat this as the equivalent of `...`.
+    def _replace(self, *args, **kwargs) -&gt; Self: ...
     if sys.version_info &gt;= (3, 13):
-        def __replace__(self, **kwargs) -&gt; Self: ...
+        def __replace__(self, *args, **kwargs) -&gt; Self: ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-23 10:35</div>
            <div class="timeline-body"><p>On Python 3.13+, it looks like we should also be synthesising precise <code>__replace__</code> methods for <code>NamedTuple</code> classes in the same way that we already do for dataclasses.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2025-12-23 14:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/overrides.rs</code>:39 on 2025-12-23 15:21</div>
            <div class="timeline-body"><p>What's the reason for this change? Overriding <code>__replace__</code> doesn't seem to cause a runtime error in the same way that overriding <code>_replace</code> does:</p>
<pre><code class="language-pycon">Python 3.13.1 (main, Jan  3 2025, 12:04:03) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; from typing import NamedTuple
&gt;&gt;&gt; class Foo(NamedTuple):
...     __replace__ = None
...     
&gt;&gt;&gt; class Foo(NamedTuple):
...     _replace = None
...     
Traceback (most recent call last):
  File &quot;&lt;python-input-2&gt;&quot;, line 1, in &lt;module&gt;
    class Foo(NamedTuple):
        _replace = None
  File &quot;/Users/alexw/.pyenv/versions/3.13.1/lib/python3.13/typing.py&quot;, line 3021, in __new__
    raise AttributeError(&quot;Cannot overwrite NamedTuple attribute &quot; + key)
AttributeError: Cannot overwrite NamedTuple attribute _replace
</code></pre>
<p>This change also doesn't seem to be tested at all?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2524 on 2025-12-23 15:24</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">                if matches!(name, &quot;__replace__&quot; | &quot;_replace&quot;) {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2511 on 2025-12-23 15:24</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">                    matches!(name, &quot;__replace__&quot; | &quot;_replace&quot;) || kw_only.unwrap_or(false);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-12-23 15:28</div>
            <div class="timeline-body"><p>LGTM</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-12-23 16:14</div>
            <div class="timeline-body"><p>(Depends on https://github.com/astral-sh/ruff/pull/22155.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2025-12-23 21:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2025-12-23 21:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-12-23 21:33</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:18:22 UTC
    </footer>
</body>
</html>
