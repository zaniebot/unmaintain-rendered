<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Support 'dangling' `type(...)` constructors - astral-sh/ruff #22537</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Support &#x27;dangling&#x27; <code>type(...)</code> constructors</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22537">#22537</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2026-01-12 18:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body">Summary
<p>This PR adds support for &#x27;dangling&#x27; <code>type(...)</code> constructors, e.g.:</p>
<pre><code>class Foo(type(&quot;Bar&quot;, ...)):
   ...
</code></pre>
<p>As opposed to:</p>
<pre><code>Bar = type(&quot;Bar&quot;, ...)
</code></pre>
<p>The former doesn&#x27;t have a <code>Definition</code> since it doesn&#x27;t get bound to a place, so we instead need to store the <code>NodeIndex</code>. Per @MichaReiser&#x27;s suggestion, we can use a Salsa tracked struct for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-12 18:14</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-12 18:15</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>spack (https://github.com/spack/spack)
+ lib/spack/spack/llnl/util/lang.py:693:50: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__init__]`
- Found 4321 diagnostics
+ Found 4322 diagnostics

schemathesis (https://github.com/schemathesis/schemathesis)
- src/schemathesis/core/deserialization.py:137:34: error[invalid-assignment] Object of type `type` is not assignable to `type[SafeLoader]`
+ src/schemathesis/core/deserialization.py:137:54: warning[unsupported-dynamic-base] Unsupported class base: Has type `&lt;class &#x27;CSafeLoader&#x27;&gt; | &lt;class &#x27;SafeLoader&#x27;&gt;`
+ src/schemathesis/core/deserialization.py:174:48: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/schemathesis/specs/openapi/stateful/__init__.py:206:12: error[invalid-return-type] Return type does not match returned value: expected `type[APIStateMachine]`, found `type`

pandera (https://github.com/pandera-dev/pandera)
- pandera/api/dataframe/model.py:257:13: error[invalid-assignment] Object of type `type` is not assignable to attribute `Config` of type `type[BaseConfig]`
+ pandera/api/dataframe/model.py:257:42: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[BaseConfig]`
- pandera/api/dataframe/model.py:455:16: error[invalid-return-type] Return type does not match returned value: expected `tuple[type[BaseConfig], dict[str, Any]]`, found `tuple[type, dict[str, Any]]`
+ pandera/api/dataframe/model.py:455:32: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[BaseConfig]`
- pandera/api/pyspark/model.py:162:13: error[invalid-assignment] Object of type `type` is not assignable to attribute `Config` of type `type[BaseConfig]`
- Found 1582 diagnostics
+ Found 1581 diagnostics

pydantic (https://github.com/pydantic/pydantic)
- pydantic/v1/config.py:183:12: error[invalid-return-type] Return type does not match returned value: expected `type[BaseConfig]`, found `type`
- pydantic/v1/networks.py:572:12: error[invalid-return-type] Return type does not match returned value: expected `type[AnyUrl]`, found `type`
+ pydantic/v1/schema.py:1094:50: warning[unsupported-dynamic-base] Unsupported class base: Has type `(Any &amp; type[SecretStr]) | (Any &amp; type[SecretBytes])`
- pydantic/v1/types.py:239:12: error[invalid-return-type] Return type does not match returned value: expected `type[int]`, found `type`
- pydantic/v1/types.py:318:12: error[invalid-return-type] Return type does not match returned value: expected `type[int] | type[float]`, found `type`
- pydantic/v1/types.py:391:12: error[invalid-return-type] Return type does not match returned value: expected `type[bytes]`, found `type`
- pydantic/v1/types.py:471:12: error[invalid-return-type] Return type does not match returned value: expected `type[str]`, found `type`
- pydantic/v1/types.py:749:12: error[invalid-return-type] Return type does not match returned value: expected `type[Decimal]`, found `type`
- pydantic/v1/types.py:833:16: error[invalid-return-type] Return type does not match returned value: expected `type[JsonWrapper]`, found `type`
- pydantic/v1/types.py:1205:12: error[invalid-return-type] Return type does not match returned value: expected `type[date]`, found `type`
- Found 3159 diagnostics
+ Found 3151 diagnostics

artigraph (https://github.com/artigraph/artigraph)
+ src/arti/internal/mappings.py:111:49: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__class_getitem__]`
- src/arti/producers/__init__.py:441:16: error[invalid-return-type] Return type does not match returned value: expected `type[Producer]`, found `type`
- src/arti/types/__init__.py:339:13: error[invalid-argument-type] Argument to bound method `register_adapter` is incorrect: Expected `type[TypeAdapter]`, found `type`
+ src/arti/types/__init__.py:341:18: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@generate]`
- src/arti/types/bigquery.py:66:9: error[invalid-argument-type] Argument to bound method `register_adapter` is incorrect: Expected `type[TypeAdapter]`, found `type`
- src/arti/types/pyarrow.py:42:9: error[invalid-argument-type] Argument to bound method `register_adapter` is incorrect: Expected `type[TypeAdapter]`, found `type`
- Found 149 diagnostics
+ Found 147 diagnostics

psycopg (https://github.com/psycopg/psycopg)
- psycopg/psycopg/types/array.py:350:12: error[invalid-return-type] Return type does not match returned value: expected `type[BaseListDumper]`, found `type`
- psycopg/psycopg/types/array.py:356:12: error[invalid-return-type] Return type does not match returned value: expected `type[BaseListDumper]`, found `type`
- psycopg/psycopg/types/composite.py:525:12: error[invalid-return-type] Return type does not match returned value: expected `type[_CompositeLoader[T@_make_loader]]`, found `type`
- psycopg/psycopg/types/composite.py:534:12: error[invalid-return-type] Return type does not match returned value: expected `type[_CompositeBinaryLoader[T@_make_binary_loader]]`, found `type`
- psycopg/psycopg/types/composite.py:543:12: error[invalid-return-type] Return type does not match returned value: expected `type[_SequenceDumper[T@_make_dumper]]`, found `type`
- psycopg/psycopg/types/composite.py:552:12: error[invalid-return-type] Return type does not match returned value: expected `type[_SequenceBinaryDumper[T@_make_binary_dumper]]`, found `type`
- psycopg/psycopg/types/enum.py:183:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumLoader[E@_make_loader]]`, found `type`
- psycopg/psycopg/types/enum.py:191:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumLoader[E@_make_binary_loader]]`, found `type`
- psycopg/psycopg/types/enum.py:199:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumDumper[E@_make_dumper]]`, found `type`
- psycopg/psycopg/types/enum.py:207:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumDumper[E@_make_binary_dumper]]`, found `type`
- psycopg/psycopg/types/multirange.py:407:12: error[invalid-return-type] Return type does not match returned value: expected `type[MultirangeLoader[Any]]`, found `type`
- psycopg/psycopg/types/multirange.py:412:12: error[invalid-return-type] Return type does not match returned value: expected `type[MultirangeBinaryLoader[Any]]`, found `type`
- psycopg/psycopg/types/range.py:586:12: error[invalid-return-type] Return type does not match returned value: expected `type[RangeLoader[Any]]`, found `type`
- psycopg/psycopg/types/range.py:591:12: error[invalid-return-type] Return type does not match returned value: expected `type[RangeBinaryLoader[Any]]`, found `type`
- Found 666 diagnostics
+ Found 652 diagnostics

Tanjun (https://github.com/FasterSpeeding/Tanjun)
- tanjun/dependencies/data.py:347:12: error[invalid-return-type] Return type does not match returned value: expected `_T@cached_inject`, found `_T@cached_inject | Coroutine[Any, Any, _T@cached_inject | Coroutine[Any, Any, _T@cached_inject]]`
+ tanjun/dependencies/data.py:347:12: error[invalid-return-type] Return type does not match returned value: expected `_T@cached_inject`, found `Coroutine[Any, Any, _T@cached_inject | Coroutine[Any, Any, _T@cached_inject]] | _T@cached_inject`

trio (https://github.com/python-trio/trio)
- src/trio/_tests/test_util.py:236:5: error[unresolved-attribute] Unresolved attribute `recursion` on type `type`.
+ src/trio/_tests/test_util.py:236:5: error[unresolved-attribute] Unresolved attribute `recursion` on type `&lt;class &#x27;SomeClass&#x27;&gt;`.

mkdocs (https://github.com/mkdocs/mkdocs)
+ mkdocs/config/config_options.py:101:28: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__class_getitem__]`
+ mkdocs/plugins.py:75:28: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__class_getitem__]`
- Found 225 diagnostics
+ Found 227 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
- src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:461:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, None | Unknown]` is not awaitable
+ src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:461:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, Unknown | None]` is not awaitable
- src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:535:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, None | Unknown]` is not awaitable
+ src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:535:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, Unknown | None]` is not awaitable
- src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:610:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, None | Unknown]` is not awaitable
+ src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:610:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, Unknown | None]` is not awaitable
- src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:685:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, None | Unknown]` is not awaitable
+ src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:685:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, Unknown | None]` is not awaitable
- src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:760:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, None | Unknown]` is not awaitable
+ src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:760:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, Unknown | None]` is not awaitable
- src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:835:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, None | Unknown]` is not awaitable
+ src/integrations/prefect-dbt/prefect_dbt/cli/commands.py:835:21: error[invalid-await] `Unknown | None | Coroutine[Any, Any, Unknown | None]` is not awaitable
- src/integrations/prefect-dbt/prefect_dbt/core/settings.py:94:28: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/integrations/prefect-dbt/prefect_dbt/core/settings.py:94:28: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any]` is not assignable to `dict[str, Any]`
- src/integrations/prefect-dbt/prefect_dbt/core/settings.py:99:28: error[invalid-assignment] Object of type `T@resolve_variables | str | int | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/integrations/prefect-dbt/prefect_dbt/core/settings.py:99:28: error[invalid-assignment] Object of type `T@resolve_variables | dict[str, Any]` is not assignable to `dict[str, Any]`
- src/prefect/cli/deploy/_core.py:86:21: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/prefect/cli/deploy/_core.py:86:21: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any]` is not assignable to `dict[str, Any]`
- src/prefect/cli/deploy/_core.py:87:21: error[invalid-assignment] Object of type `T@resolve_variables | str | int | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/prefect/cli/deploy/_core.py:87:21: error[invalid-assignment] Object of type `T@resolve_variables` is not assignable to `dict[str, Any]`
- src/prefect/deployments/runner.py:795:70: warning[possibly-missing-attribute] Attribute `__name__` may be missing on object of type `Unknown | ((...) -&gt; Any)`
+ src/prefect/deployments/runner.py:795:70: warning[possibly-missing-attribute] Attribute `__name__` may be missing on object of type `Unknown | (((...) -&gt; Any) &amp; ((*args: object, **kwargs: object) -&gt; object))`
- src/prefect/deployments/steps/core.py:137:38: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements`
+ src/prefect/deployments/steps/core.py:137:38: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any]`
- src/prefect/flow_engine.py:812:32: error[invalid-await] `Unknown | R@FlowRunEngine | Coroutine[Any, Any, R@FlowRunEngine]` is not awaitable
- src/prefect/flow_engine.py:1401:24: error[invalid-await] `Unknown | R@AsyncFlowRunEngine | Coroutine[Any, Any, R@AsyncFlowRunEngine]` is not awaitable
- src/prefect/flow_engine.py:1482:43: error[invalid-argument-type] Argument to function `next` is incorrect: Expected `SupportsNext[Unknown]`, found `Unknown | R@run_generator_flow_sync`
- src/prefect/flow_engine.py:1490:21: warning[possibly-missing-attribute] Attribute `throw` may be missing on object of type `Unknown | R@run_generator_flow_sync`
- src/prefect/flow_engine.py:1524:44: warning[possibly-missing-attribute] Attribute `__anext__` may be missing on object of type `Unknown | R@run_generator_flow_async`
- src/prefect/flow_engine.py:1531:25: warning[possibly-missing-attribute] Attribute `throw` may be missing on object of type `Unknown | R@run_generator_flow_async`
- src/prefect/flows.py:286:34: error[unresolved-attribute] Object of type `(**P@Flow) -&gt; R@Flow` has no attribute `__name__`
+ src/prefect/flows.py:286:34: error[unresolved-attribute] Object of type `((**P@Flow) -&gt; R@Flow) &amp; ((*args: object, **kwargs: object) -&gt; object)` has no attribute `__name__`
- src/prefect/flows.py:404:68: error[unresolved-attribute] Object of type `(**P@Flow) -&gt; R@Flow` has no attribute `__name__`
+ src/prefect/flows.py:404:68: error[unresolved-attribute] Object of type `((**P@Flow) -&gt; R@Flow) &amp; ((*args: object, **kwargs: object) -&gt; object)` has no attribute `__name__`
+ src/prefect/flows.py:1750:53: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/prefect/input/run_input.py:332:82: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/prefect/utilities/templating.py:320:13: error[invalid-assignment] Invalid subscript assignment with key of type `object` and value of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` on object of type `dict[str, Any]`
+ src/prefect/utilities/templating.py:320:13: error[invalid-assignment] Invalid subscript assignment with key of type `object` and value of type `T@resolve_block_document_references | dict[str, Any]` on object of type `dict[str, Any]`
- src/prefect/utilities/templating.py:323:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_block_document_references | dict[str, Any]`, found `list[T@resolve_block_document_references | dict[str, Any] | str | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:323:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_block_document_references | dict[str, Any]`, found `list[T@resolve_block_document_references | dict[str, Any] | Unknown]`
- src/prefect/utilities/templating.py:437:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `dict[object, T@resolve_variables | str | int | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:437:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `dict[object, T@resolve_variables | Unknown]`
- src/prefect/utilities/templating.py:442:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `list[T@resolve_variables | str | int | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:442:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `list[T@resolve_variables | Unknown]`
- src/prefect/workers/base.py:232:13: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements`
+ src/prefect/workers/base.py:232:13: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any]`
- src/prefect/workers/base.py:234:20: error[invalid-argument-type] Argument expression after ** must be a mapping type: Found `T@resolve_variables | str | int | ... omitted 4 union elements`
+ src/prefect/workers/base.py:234:20: error[invalid-argument-type] Argument expression after ** must be a mapping type: Found `T@resolve_variables`
- Found 5370 diagnostics
+ Found 5364 diagnostics

strawberry (https://github.com/strawberry-graphql/strawberry)
- strawberry/tools/merge_types.py:35:12: error[invalid-return-type] Return type does not match returned value: expected `type`, found `&lt;decorator produced by dataclass-like function&gt;`
- Found 348 diagnostics
+ Found 347 diagnostics

setuptools (https://github.com/pypa/setuptools)
+ setuptools/_distutils/compilers/C/msvc.py:583:13: error[unresolved-attribute] Unresolved attribute `value` on type `Bag`.
- Found 1265 diagnostics
+ Found 1266 diagnostics

jax (https://github.com/google/jax)
- jax/_src/interpreters/partial_eval.py:1710:79: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- jax/_src/interpreters/partial_eval.py:1726:81: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 2832 diagnostics
+ Found 2830 diagnostics

ibis (https://github.com/ibis-project/ibis)
+ ibis/expr/operations/udf.py:155:16: error[invalid-return-type] Return type does not match returned value: expected `type[S@_make_node]`, found `&lt;class &#x27;&lt;unknown&gt;&#x27;&gt;`
- ibis/expr/operations/udf.py:155:50: error[invalid-argument-type] Argument to class `type` is incorrect: Expected `tuple[type, ...]`, found `tuple[property]`
+ ibis/expr/operations/udf.py:155:51: error[invalid-base] Invalid class base with type `property`
- Found 4607 diagnostics
+ Found 4608 diagnostics

hydpy (https://github.com/hydpy-dev/hydpy)
+ hydpy/core/modeltools.py:3252:61: warning[unsupported-dynamic-base] Unsupported class base: Has type `&lt;class &#x27;InletSequences&#x27;&gt; | &lt;class &#x27;ObserverSequences&#x27;&gt; | &lt;class &#x27;ReceiverSequences&#x27;&gt; | ... omitted 8 union elements`
- Found 664 diagnostics
+ Found 665 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Bus[Any] | Bottom[Series[Any, Any]] | ndarray[Never, Never] | ... omitted 6 union elements, object_]`
- static_frame/core/bus.py:675:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Bus[Any], object_]`, found `InterGetItemILocReduces[Bus[Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, object_ | Self@iloc]`
+ static_frame/core/bus.py:675:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Bus[Any], object_]`, found `InterGetItemILocReduces[Self@iloc | Bus[Any], object_ | Self@iloc]`
- static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Any | Bottom[Series[Any, Any]], TVDtype@Index]`
+ static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Any, TVDtype@Index]`
- static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Unknown | Bottom[Series[Any, Any]], Any]`
+ static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Unknown, Any]`
- static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | ndarray[Never, Never] | TypeBlocks | ... omitted 6 union elements, TVDtype@Series]`
+ static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | Bottom[Index[Any]] | ndarray[Never, Never] | ... omitted 6 union elements, TVDtype@Series]`
- static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, object_]`
- Found 1827 diagnostics
+ Found 1825 diagnostics


</code></pre>



Memory usage changes were detected when running on open source projects

<pre><code>trio (https://github.com/python-trio/trio)
-     struct fields = ~11MB
+     struct fields = ~12MB


</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;[ty] Support &#x27;dangling&#x27; type(...) constructors&quot; to &quot;[ty] Support &#x27;dangling&#x27; `type(...)` constructors&quot; by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 19:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 19:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2026-01-12 19:30</div>
            <div class="timeline-body">

Merging this PR will <strong>not alter performance</strong>
<p><code>✅ 23</code> untouched benchmarks<br>
<code>⏩ 30</code> skipped benchmarks[^skipped]</p>
<hr>
<p>Comparing <code>charlie/dyn-expression</code> (a94d0ed) with <code>main</code> (853bb00)</p>
<a href="https://codspeed.io/astral-sh/ruff/branches/charlie%2Fdyn-expression?utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=button">
  
    
    
    <img alt="Open in CodSpeed" src="https://codspeed.io/pr-report/open-in-codspeed-light.svg">
  
</a>

<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/charlie%2Fdyn-expression?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 20:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-12 22:10</div>
            <div class="timeline-body"><blockquote>
<p>The former doesn&#x27;t have a Definition since it doesn&#x27;t get bound to a place, so we instead need to store the NodeIndex. Per @MichaReiser&#x27;s suggestion, we can use a Salsa tracked struct for this.</p>
</blockquote>
<p>I&#x27;m actually coming to the conclusion that we can&#x27;t use tracked structs:</p>
<ul>
<li>I don&#x27;t think Salsa&#x27;s handling of tracked structs in cycles is sound today. Specifically, I suspect that Salsa reuses tracked structs between iterations. This is the behavior you want in this specific instance, but Niko and I believe it is unsound because it mutates tracked structs within a revision (specifically, Salsa <a href="https://github.com/MichaReiser/salsa/blob/103fa518298432a5f5bdb75e3727a179e3b056cf/src/tracked_struct.rs#L664">skips the update entirely</a>, ignoring the values you&#x27;re trying to write in the later iterations), which should not be a thing. Instead, iteration 1 and iteration 2 should create two distinct tracked structs. They are two distinct <code>::new</code> calls (think of each iteration as unrolling the function body once). However, if we make this change, the consequence is that a salsa query returning a tracked struct as part of its result can never converge because the struct&#x27;s ID is different after each iteration. But this is precisely the situation that we have here.</li>
<li>I&#x27;m also having a hard time reasoning about what the equality is supposed to be in the places where we call <code>with_dataclass_params</code>. None of those instances is guaranteed to compare equal, even if they have the same values, because they might be created from different queries. I think this could be fixed by making <code>with_dataclass_params</code> a salsa tracked function, so that calling <code>with_dataclass_params</code> with the same params on the same <code>DynamicClassLiteral</code> always returns the same instance.</li>
</ul>
<p>I&#x27;m not sure yet what the right solution here is but I don&#x27;t feel confident building on something that is very likely unsupported in the near future. I&#x27;ve to think about this a little more.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 22:16</div>
            <div class="timeline-body"><p>The only other idea I had was to create a stable ID for the call:</p>
<pre><code>diff --git a/crates/ty_python_semantic/src/semantic_index/ast_ids.rs b/crates/ty_python_semantic/src/semantic_index/ast_ids.rs
index cc2c65526e..514984674f 100644
--- a/crates/ty_python_semantic/src/semantic_index/ast_ids.rs
+++ b/crates/ty_python_semantic/src/semantic_index/ast_ids.rs
@@ -1,8 +1,8 @@
-use rustc_hash::FxHashMap;
-
-use ruff_index::newtype_index;
+use ruff_index::{IndexVec, newtype_index};
 use ruff_python_ast as ast;
 use ruff_python_ast::ExprRef;
+use ruff_text_size::TextRange;
+use rustc_hash::FxHashMap;
 
 use crate::Db;
 use crate::semantic_index::ast_ids::node_key::ExpressionNodeKey;
@@ -28,12 +28,27 @@ use crate::semantic_index::semantic_index;
 pub(crate) struct AstIds {
     /// Maps expressions which &quot;use&quot; a place (that is, [`ast::ExprName`], [`ast::ExprAttribute`] or [`ast::ExprSubscript`]) to a use id.
     uses_map: FxHashMap&lt;ExpressionNodeKey, ScopedUseId&gt;,
+    /// Maps potential synthesized-type call expressions to a call id for stable identity.
+    tracked_calls_map: FxHashMap&lt;ExpressionNodeKey, ScopedCallId&gt;,
+    /// Stores the ranges of tracked calls, indexed by their [`ScopedCallId`].
+    /// Used for diagnostics (e.g., `header_range`).
+    tracked_call_ranges: IndexVec&lt;ScopedCallId, TextRange&gt;,
 }
 
 impl AstIds {
     fn use_id(&amp;self, key: impl Into&lt;ExpressionNodeKey&gt;) -&gt; ScopedUseId {
         self.uses_map[&amp;key.into()]
     }
+
+    /// Returns the call ID for a potential synthesized-type call, if it was tracked during semantic indexing.
+    pub(crate) fn try_call_id(&amp;self, key: impl Into&lt;ExpressionNodeKey&gt;) -&gt; Option&lt;ScopedCallId&gt; {
+        self.tracked_calls_map.get(&amp;key.into()).copied()
+    }
+
+    /// Returns the range of a tracked call by its ID.
+    pub(crate) fn call_range(&amp;self, id: ScopedCallId) -&gt; TextRange {
+        self.tracked_call_ranges[id]
+    }
 }
 
 fn ast_ids&lt;&#x27;db&gt;(db: &amp;&#x27;db dyn Db, scope: ScopeId) -&gt; &amp;&#x27;db AstIds {
@@ -45,6 +60,15 @@ fn ast_ids&lt;&#x27;db&gt;(db: &amp;&#x27;db dyn Db, scope: ScopeId) -&gt; &amp;&#x27;db AstIds {
 #[derive(get_size2::GetSize)]
 pub struct ScopedUseId;
 
+/// Uniquely identifies a potential synthesized-type call in a [`crate::semantic_index::FileScopeId`].
+///
+/// This is used to provide stable identity for inline calls that create synthesized types,
+/// such as `type()`, `NamedTuple()`, `TypedDict()`, etc. The ID is assigned during semantic
+/// indexing for calls that match known patterns for these synthesizers.
+#[newtype_index]
+#[derive(get_size2::GetSize)]
+pub struct ScopedCallId;
+
 pub trait HasScopedUseId {
     /// Returns the ID that uniquely identifies the use in `scope`.
     fn scoped_use_id(&amp;self, db: &amp;dyn Db, scope: ScopeId) -&gt; ScopedUseId;
@@ -88,6 +112,8 @@ impl HasScopedUseId for ast::ExprRef&lt;&#x27;_&gt; {
 #[derive(Debug, Default)]
 pub(super) struct AstIdsBuilder {
     uses_map: FxHashMap&lt;ExpressionNodeKey, ScopedUseId&gt;,
+    tracked_calls_map: FxHashMap&lt;ExpressionNodeKey, ScopedCallId&gt;,
+    tracked_call_ranges: IndexVec&lt;ScopedCallId, TextRange&gt;,
 }
 
 impl AstIdsBuilder {
@@ -100,11 +126,25 @@ impl AstIdsBuilder {
         use_id
     }
 
+    /// Records a potential synthesized-type call for stable identity tracking.
+    pub(super) fn record_call(
+        &amp;mut self,
+        expr: impl Into&lt;ExpressionNodeKey&gt;,
+        range: TextRange,
+    ) -&gt; ScopedCallId {
+        let call_id = self.tracked_call_ranges.push(range);
+        self.tracked_calls_map.insert(expr.into(), call_id);
+        call_id
+    }
+
     pub(super) fn finish(mut self) -&gt; AstIds {
         self.uses_map.shrink_to_fit();
+        self.tracked_calls_map.shrink_to_fit();
 
         AstIds {
             uses_map: self.uses_map,
+            tracked_calls_map: self.tracked_calls_map,
+            tracked_call_ranges: self.tracked_call_ranges,
         }
     }
 }
diff --git a/crates/ty_python_semantic/src/semantic_index/builder.rs b/crates/ty_python_semantic/src/semantic_index/builder.rs
index 3ef83e97d2..61945b5681 100644
--- a/crates/ty_python_semantic/src/semantic_index/builder.rs
+++ b/crates/ty_python_semantic/src/semantic_index/builder.rs
@@ -14,7 +14,7 @@ use ruff_python_ast::{self as ast, NodeIndex, PySourceType, PythonVersion};
 use ruff_python_parser::semantic_errors::{
     SemanticSyntaxChecker, SemanticSyntaxContext, SemanticSyntaxError, SemanticSyntaxErrorKind,
 };
-use ruff_text_size::TextRange;
+use ruff_text_size::{Ranged, TextRange};
 use ty_module_resolver::{ModuleName, resolve_module};
 
 use crate::ast_node_ref::AstNodeRef;
@@ -2741,6 +2741,17 @@ impl&lt;&#x27;ast&gt; Visitor&lt;&#x27;ast&gt; for SemanticIndexBuilder&lt;&#x27;_, &#x27;ast&gt; {
                 }
                 walk_expr(self, expr);
             }
+            ast::Expr::Call(call_expr) =&gt; {
+                // Track potential synthesized-type calls for stable identity.
+                // Assigned calls use `Definition` for identity; inline calls need a `ScopedCallId`.
+                if self.current_assignment().is_none()
+                    &amp;&amp; is_potential_synthesized_type_call(call_expr)
+                {
+                    self.current_ast_ids()
+                        .record_call(call_expr, call_expr.range());
+                }
+                walk_expr(self, expr);
+            }
             _ =&gt; {
                 walk_expr(self, expr);
             }
@@ -3195,3 +3206,31 @@ fn is_if_not_type_checking(expr: &amp;ast::Expr) -&gt; bool {
         }) if is_if_type_checking(operand)
     )
 }
+
+/// Returns whether a call expression might create a synthesized type.
+///
+/// This is a heuristic used during semantic indexing to assign stable IDs
+/// to calls that may produce `NamedTuple`, `TypedDict`, `type()` classes, etc.
+/// False positives are acceptable (the ID just won&#x27;t be used during inference).
+fn is_potential_synthesized_type_call(call: &amp;ast::ExprCall) -&gt; bool {
+    // Check for `type(...)` or `builtins.type(...)`
+    let is_type_call = match call.func.as_ref() {
+        ast::Expr::Name(name) =&gt; name.id.as_str() == &quot;type&quot;,
+        ast::Expr::Attribute(attr) =&gt; {
+            attr.attr.as_str() == &quot;type&quot;
+                &amp;&amp; matches!(attr.value.as_ref(), ast::Expr::Name(name) if name.id.as_str() == &quot;builtins&quot;)
+        }
+        _ =&gt; false,
+    };
+
+    if is_type_call {
+        // type(&quot;Name&quot;, bases, dict)
+        return call.arguments.keywords.is_empty() &amp;&amp; call.arguments.args.len() == 3;
+    }
+
+    // TODO: Add more patterns as we support them:
+    // - NamedTuple(&quot;Name&quot;, [...]) or NamedTuple(&quot;Name&quot;, field1=type1, ...)
+    // - TypedDict(&quot;Name&quot;, {...}) or TypedDict(&quot;Name&quot;, field1=type1, ...)
+
+    false
+}
diff --git a/crates/ty_python_semantic/src/types.rs b/crates/ty_python_semantic/src/types.rs
index 76cc4684b1..4c9df1bf3c 100644
--- a/crates/ty_python_semantic/src/types.rs
+++ b/crates/ty_python_semantic/src/types.rs
@@ -6529,9 +6529,9 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
                 Some(TypeDefinition::Function(function.definition(db)))
             }
             Self::ModuleLiteral(module) =&gt; Some(TypeDefinition::Module(module.module(db))),
-            Self::ClassLiteral(class_literal) =&gt; Some(class_literal.type_definition(db)),
+            Self::ClassLiteral(class_literal) =&gt; class_literal.type_definition(db),
             Self::GenericAlias(alias) =&gt; Some(TypeDefinition::StaticClass(alias.definition(db))),
-            Self::NominalInstance(instance) =&gt; Some(instance.class(db).type_definition(db)),
+            Self::NominalInstance(instance) =&gt; instance.class(db).type_definition(db),
             Self::KnownInstance(instance) =&gt; match instance {
                 KnownInstanceType::TypeVar(var) =&gt; {
                     Some(TypeDefinition::TypeVar(var.definition(db)?))
@@ -6545,7 +6545,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
 
             Self::SubclassOf(subclass_of_type) =&gt; match subclass_of_type.subclass_of() {
                 SubclassOfInner::Dynamic(_) =&gt; None,
-                SubclassOfInner::Class(class) =&gt; Some(class.type_definition(db)),
+                SubclassOfInner::Class(class) =&gt; class.type_definition(db),
                 SubclassOfInner::TypeVar(bound_typevar) =&gt; {
                     Some(TypeDefinition::TypeVar(bound_typevar.typevar(db).definition(db)?))
                 }
@@ -6575,7 +6575,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
             Self::TypeVar(bound_typevar) =&gt; Some(TypeDefinition::TypeVar(bound_typevar.typevar(db).definition(db)?)),
 
             Self::ProtocolInstance(protocol) =&gt; match protocol.inner {
-                Protocol::FromClass(class) =&gt; Some(class.type_definition(db)),
+                Protocol::FromClass(class) =&gt; class.type_definition(db),
                 Protocol::Synthesized(_) =&gt; None,
             },
 
diff --git a/crates/ty_python_semantic/src/types/class.rs b/crates/ty_python_semantic/src/types/class.rs
index ba4f3b61fc..0d4ed7360a 100644
--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -10,11 +10,13 @@ use super::{
     function::FunctionType,
 };
 use crate::place::{DefinedPlace, TypeOrigin};
-use crate::semantic_index::definition::{Definition, DefinitionState};
-use crate::semantic_index::scope::{NodeWithScopeKind, Scope, ScopeKind};
+use crate::semantic_index::ast_ids::ScopedCallId;
+use crate::semantic_index::definition::{Definition, DefinitionKind, DefinitionState};
+use crate::semantic_index::scope::{FileScopeId, NodeWithScopeKind, Scope, ScopeKind};
 use crate::semantic_index::symbol::Symbol;
 use crate::semantic_index::{
     DeclarationWithConstraint, SemanticIndex, attribute_declarations, attribute_scopes,
+    semantic_index,
 };
 use crate::types::bound_super::BoundSuperError;
 use crate::types::constraints::{ConstraintSet, IteratorConstraintsExtension};
@@ -57,11 +59,7 @@ use crate::{
         known_module_symbol, place_from_bindings, place_from_declarations,
     },
     semantic_index::{
-        attribute_assignments,
-        definition::{DefinitionKind, TargetKind},
-        place_table,
-        scope::{FileScopeId, ScopeId},
-        semantic_index, use_def_map,
+        attribute_assignments, definition::TargetKind, place_table, scope::ScopeId, use_def_map,
     },
     types::{
         CallArguments, CallError, CallErrorKind, MetaclassCandidate, TypeDefinition, UnionType,
@@ -668,10 +666,10 @@ impl&lt;&#x27;db&gt; ClassLiteral&lt;&#x27;db&gt; {
         }
     }
 
-    /// Returns the definition of this class.
-    pub(crate) fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Definition&lt;&#x27;db&gt; {
+    /// Returns the definition of this class, if available.
+    pub(crate) fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;Definition&lt;&#x27;db&gt;&gt; {
         match self {
-            Self::Static(class) =&gt; class.definition(db),
+            Self::Static(class) =&gt; Some(class.definition(db)),
             Self::Dynamic(class) =&gt; class.definition(db),
         }
     }
@@ -679,11 +677,11 @@ impl&lt;&#x27;db&gt; ClassLiteral&lt;&#x27;db&gt; {
     /// Returns the type definition for this class.
     ///
     /// For static classes, returns `TypeDefinition::StaticClass`.
-    /// For dynamic classes, returns `TypeDefinition::DynamicClass`.
-    pub(crate) fn type_definition(self, db: &amp;&#x27;db dyn Db) -&gt; TypeDefinition&lt;&#x27;db&gt; {
+    /// For dynamic classes, returns `TypeDefinition::DynamicClass` if a definition is available.
+    pub(crate) fn type_definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;TypeDefinition&lt;&#x27;db&gt;&gt; {
         match self {
-            Self::Static(class) =&gt; TypeDefinition::StaticClass(class.definition(db)),
-            Self::Dynamic(class) =&gt; TypeDefinition::DynamicClass(class.definition(db)),
+            Self::Static(class) =&gt; Some(TypeDefinition::StaticClass(class.definition(db))),
+            Self::Dynamic(class) =&gt; class.definition(db).map(TypeDefinition::DynamicClass),
         }
     }
 
@@ -941,13 +939,13 @@ impl&lt;&#x27;db&gt; ClassType&lt;&#x27;db&gt; {
         self.class_literal(db).known(db)
     }
 
-    /// Returns the definition for this class.
-    pub(crate) fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Definition&lt;&#x27;db&gt; {
+    /// Returns the definition for this class, if available.
+    pub(crate) fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;Definition&lt;&#x27;db&gt;&gt; {
         self.class_literal(db).definition(db)
     }
 
     /// Returns the type definition for this class.
-    pub(crate) fn type_definition(self, db: &amp;&#x27;db dyn Db) -&gt; TypeDefinition&lt;&#x27;db&gt; {
+    pub(crate) fn type_definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;TypeDefinition&lt;&#x27;db&gt;&gt; {
         self.class_literal(db).type_definition(db)
     }
 
@@ -4680,21 +4678,18 @@ impl&lt;&#x27;db&gt; VarianceInferable&lt;&#x27;db&gt; for ClassLiteral&lt;&#x27;db&gt; {
 ///
 /// # Salsa interning
 ///
-/// Each `type()` call is uniquely identified by its [`Definition`], which provides
-/// stable identity without depending on AST node indices that can change when code
-/// is inserted above the call site.
+/// Each `type()` call is uniquely identified by its [`DynamicClassOrigin`], which provides
+/// stable identity without depending on AST node indices that can change when code is
+/// inserted above the call site.
 ///
-/// Two different `type()` calls always produce distinct `DynamicClassLiteral`
-/// instances, even if they have the same name and bases:
+/// Two different `type()` calls always produce distinct `DynamicClassLiteral` instances,
+/// even if they have the same name and bases:
 ///
 /// ```python
 /// Foo1 = type(&quot;Foo&quot;, (Base,), {})
 /// Foo2 = type(&quot;Foo&quot;, (Base,), {})
 /// # Foo1 and Foo2 are distinct types
 /// ```
-///
-/// Note: Only assigned `type()` calls are currently supported (e.g., `Foo = type(...)`).
-/// Inline calls like `process(type(...))` fall back to normal call handling.
 #[salsa::interned(debug, heap_size = ruff_memory_usage::heap_size)]
 #[derive(PartialOrd, Ord)]
 pub struct DynamicClassLiteral&lt;&#x27;db&gt; {
@@ -4706,14 +4701,38 @@ pub struct DynamicClassLiteral&lt;&#x27;db&gt; {
     #[returns(deref)]
     pub bases: Box&lt;[ClassBase&lt;&#x27;db&gt;]&gt;,
 
-    /// The definition where this class is created.
-    pub definition: Definition&lt;&#x27;db&gt;,
+    /// The origin of this dynamic class, providing stable identity.
+    pub origin: DynamicClassOrigin&lt;&#x27;db&gt;,
 
     /// Dataclass parameters if this class has been wrapped with `@dataclass` decorator
     /// or passed to `dataclass()` as a function.
     pub dataclass_params: Option&lt;DataclassParams&lt;&#x27;db&gt;&gt;,
 }
 
+/// The origin of a dynamically created class, used for stable identity in Salsa.
+///
+/// This enum provides stable identification for `type()` calls without relying on
+/// AST node indices that change when code is inserted above the call site.
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa::Update)]
+pub enum DynamicClassOrigin&lt;&#x27;db&gt; {
+    /// A `type()` call that is assigned to a variable (e.g., `Foo = type(&quot;Foo&quot;, (), {})`).
+    ///
+    /// The Definition provides stable identity via its `ScopedPlaceId`.
+    Assigned(Definition&lt;&#x27;db&gt;),
+
+    /// An inline `type()` call not assigned to a variable (e.g., `process(type(&quot;Foo&quot;, (), {}))`).
+    ///
+    /// Uses file, scope, and a scoped call ID for stable identity.
+    /// The ID is assigned sequentially during semantic indexing.
+    Inline {
+        file: File,
+        file_scope: FileScopeId,
+        call_id: ScopedCallId,
+    },
+}
+
+impl get_size2::GetSize for DynamicClassOrigin&lt;&#x27;_&gt; {}
+
 impl get_size2::GetSize for DynamicClassLiteral&lt;&#x27;_&gt; {}
 
 #[salsa::tracked]
@@ -4727,25 +4746,52 @@ impl&lt;&#x27;db&gt; DynamicClassLiteral&lt;&#x27;db&gt; {
 
     /// Returns the range of the `type()` call expression that created this class.
     pub(super) fn header_range(self, db: &amp;&#x27;db dyn Db) -&gt; TextRange {
-        let definition = self.definition(db);
-        let file = definition.file(db);
-        let module = parsed_module(db, file).load(db);
-
-        // Dynamic classes are only created from regular assignments (e.g., `Foo = type(...)`).
-        let DefinitionKind::Assignment(assignment) = definition.kind(db) else {
-            unreachable!(&quot;DynamicClassLiteral should only be created from Assignment definitions&quot;);
-        };
-        assignment.value(&amp;module).range()
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; {
+                // For assigned calls, get the range from the assignment value.
+                let file = definition.file(db);
+                let module = parsed_module(db, file).load(db);
+                let DefinitionKind::Assignment(assignment) = definition.kind(db) else {
+                    unreachable!(
+                        &quot;DynamicClassOrigin::Assigned should only be created from Assignment definitions&quot;
+                    );
+                };
+                assignment.value(&amp;module).range()
+            }
+            DynamicClassOrigin::Inline {
+                file,
+                file_scope,
+                call_id,
+            } =&gt; {
+                // For inline calls, look up the range from the semantic index.
+                let index = semantic_index(db, file);
+                index.ast_ids(file_scope).call_range(call_id)
+            }
+        }
     }
 
     /// Returns the file containing the `type()` call.
     pub(crate) fn file(self, db: &amp;&#x27;db dyn Db) -&gt; File {
-        self.definition(db).file(db)
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; definition.file(db),
+            DynamicClassOrigin::Inline { file, .. } =&gt; file,
+        }
     }
 
     /// Returns the scope containing the `type()` call.
     pub(crate) fn file_scope(self, db: &amp;&#x27;db dyn Db) -&gt; FileScopeId {
-        self.definition(db).file_scope(db)
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; definition.file_scope(db),
+            DynamicClassOrigin::Inline { file_scope, .. } =&gt; file_scope,
+        }
+    }
+
+    /// Returns the definition where this class is created, if in an assignment context.
+    pub(crate) fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;Definition&lt;&#x27;db&gt;&gt; {
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; Some(definition),
+            DynamicClassOrigin::Inline { .. } =&gt; None,
+        }
     }
 
     /// Get the metaclass of this dynamic class.
@@ -4919,7 +4965,7 @@ impl&lt;&#x27;db&gt; DynamicClassLiteral&lt;&#x27;db&gt; {
             db,
             self.name(db).clone(),
             self.bases(db),
-            self.definition(db),
+            self.origin(db),
             dataclass_params,
         )
     }
diff --git a/crates/ty_python_semantic/src/types/generics.rs b/crates/ty_python_semantic/src/types/generics.rs
index b467f08bbe..290daac22a 100644
--- a/crates/ty_python_semantic/src/types/generics.rs
+++ b/crates/ty_python_semantic/src/types/generics.rs
@@ -96,7 +96,7 @@ pub(crate) fn typing_self&lt;&#x27;db&gt;(
     let identity = TypeVarIdentity::new(
         db,
         ast::name::Name::new_static(&quot;Self&quot;),
-        Some(class.definition(db)),
+        class.definition(db),
         TypeVarKind::TypingSelf,
     );
     let bounds = TypeVarBoundOrConstraints::UpperBound(Type::instance(
diff --git a/crates/ty_python_semantic/src/types/ide_support.rs b/crates/ty_python_semantic/src/types/ide_support.rs
index 70fa611c77..73497948b1 100644
--- a/crates/ty_python_semantic/src/types/ide_support.rs
+++ b/crates/ty_python_semantic/src/types/ide_support.rs
@@ -169,9 +169,9 @@ pub fn definitions_for_name&lt;&#x27;db&gt;(
                 // instead of `int` (hover only shows the docstring of the first definition).
                 .rev()
                 .filter_map(|ty| ty.as_nominal_instance())
-                .map(|instance| {
-                    let definition = instance.class_literal(db).definition(db);
-                    ResolvedDefinition::Definition(definition)
+                .filter_map(|instance| {
+                    let definition = instance.class_literal(db).definition(db)?;
+                    Some(ResolvedDefinition::Definition(definition))
                 })
                 .collect();
         }
diff --git a/crates/ty_python_semantic/src/types/infer/builder.rs b/crates/ty_python_semantic/src/types/infer/builder.rs
index 3953e4cbb8..1046d70bec 100644
--- a/crates/ty_python_semantic/src/types/infer/builder.rs
+++ b/crates/ty_python_semantic/src/types/infer/builder.rs
@@ -48,14 +48,14 @@ use crate::semantic_index::scope::{
 };
 use crate::semantic_index::symbol::{ScopedSymbolId, Symbol};
 use crate::semantic_index::{
-    ApplicableConstraints, EnclosingSnapshotResult, SemanticIndex, place_table,
+    ApplicableConstraints, EnclosingSnapshotResult, SemanticIndex, place_table, semantic_index,
 };
 use crate::subscript::{PyIndex, PySlice};
 use crate::types::call::bind::{CallableDescription, MatchingOverloadIndex};
 use crate::types::call::{Binding, Bindings, CallArguments, CallError, CallErrorKind};
 use crate::types::class::{
-    ClassLiteral, CodeGeneratorKind, DynamicClassLiteral, DynamicMetaclassConflict, FieldKind,
-    MetaclassErrorKind, MethodDecorator,
+    ClassLiteral, CodeGeneratorKind, DynamicClassLiteral, DynamicClassOrigin,
+    DynamicMetaclassConflict, FieldKind, MetaclassErrorKind, MethodDecorator,
 };
 use crate::types::context::{InNoTypeCheck, InferContext};
 use crate::types::cyclic::CycleDetector;
@@ -5412,7 +5412,7 @@ impl&lt;&#x27;db, &#x27;ast&gt; TypeInferenceBuilder&lt;&#x27;db, &#x27;ast&gt; {
                             // Try to extract the dynamic class with definition.
                             // This returns `None` if it&#x27;s not a three-arg call to `type()`,
                             // signalling that we must fall back to normal call inference.
-                            self.infer_dynamic_type_expression(call_expr, definition)
+                            self.infer_dynamic_type_expression(call_expr, Some(definition))
                                 .unwrap_or_else(|| {
                                     self.infer_call_expression_impl(call_expr, callable_type, tcx)
                                 })
@@ -6031,7 +6031,7 @@ impl&lt;&#x27;db, &#x27;ast&gt; TypeInferenceBuilder&lt;&#x27;db, &#x27;ast&gt; {
     fn infer_dynamic_type_expression(
         &amp;mut self,
         call_expr: &amp;ast::ExprCall,
-        definition: Definition&lt;&#x27;db&gt;,
+        definition: Option&lt;Definition&lt;&#x27;db&gt;&gt;,
     ) -&gt; Option&lt;Type&lt;&#x27;db&gt;&gt; {
         let db = self.db();
 
@@ -6090,7 +6090,29 @@ impl&lt;&#x27;db, &#x27;ast&gt; TypeInferenceBuilder&lt;&#x27;db, &#x27;ast&gt; {
 
         let bases = self.extract_dynamic_type_bases(bases_arg, bases_type, &amp;name);
 
-        let dynamic_class = DynamicClassLiteral::new(db, name, bases, definition, None);
+        // Get the origin for this dynamic class.
+        let origin = if let Some(def) = definition {
+            // Assigned call: use the definition for stable identity.
+            DynamicClassOrigin::Assigned(def)
+        } else {
+            // Inline call: look up the ScopedCallId from semantic indexing.
+            let file = self.file();
+            let file_scope = self.scope().file_scope_id(db);
+            let index = semantic_index(db, file);
+            let Some(call_id) = index.ast_ids(file_scope).try_call_id(call_expr) else {
+                // If no call ID was tracked for this call during semantic indexing,
+                // we can&#x27;t create a stable DynamicClassLiteral. Fall back to regular
+                // type inference.
+                return None;
+            };
+            DynamicClassOrigin::Inline {
+                file,
+                file_scope,
+                call_id,
+            }
+        };
+
+        let dynamic_class = DynamicClassLiteral::new(db, name, bases, origin, None);
 
         // Check for MRO errors.
         if let Err(error) = dynamic_class.try_mro(db) {
@@ -9073,6 +9095,14 @@ impl&lt;&#x27;db, &#x27;ast&gt; TypeInferenceBuilder&lt;&#x27;db, &#x27;ast&gt; {
             return Type::TypedDict(typed_dict);
         }
 
+        // Handle 3-argument `type(name, bases, dict)`.
+        if let Type::ClassLiteral(class) = callable_type
+            &amp;&amp; class.is_known(self.db(), KnownClass::Type)
+            &amp;&amp; let Some(dynamic_type) = self.infer_dynamic_type_expression(call_expression, None)
+        {
+            return dynamic_type;
+        }
+
         // We don&#x27;t call `Type::try_call`, because we want to perform type inference on the
         // arguments after matching them to parameters, but before checking that the argument types
         // are assignable to any parameter annotations.
diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index d7a93d8bcf..66543694ad 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -303,14 +303,14 @@ impl&lt;&#x27;db&gt; TypedDictType&lt;&#x27;db&gt; {
 
     pub fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;Definition&lt;&#x27;db&gt;&gt; {
         match self {
-            TypedDictType::Class(defining_class) =&gt; Some(defining_class.definition(db)),
+            TypedDictType::Class(defining_class) =&gt; defining_class.definition(db),
             TypedDictType::Synthesized(_) =&gt; None,
         }
     }
 
     pub fn type_definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;TypeDefinition&lt;&#x27;db&gt;&gt; {
         match self {
-            TypedDictType::Class(defining_class) =&gt; Some(defining_class.type_definition(db)),
+            TypedDictType::Class(defining_class) =&gt; defining_class.type_definition(db),
             TypedDictType::Synthesized(_) =&gt; None,
         }
     }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 08:01</div>
            <div class="timeline-body"><blockquote>
<p>The only other idea I had was to create a stable ID for the call:</p>
</blockquote>
<p>I don&#x27;t think this works for ty as it has false-negatives if you alias an import like <code>from typing import NamedTuple as NT</code></p>
<p>We need to come up with another identifier that changes less often than an absolute node index or a text range, to limit the blast radius. There&#x27;s really just been one pattern that we&#x27;ve been using for this and it is to make IDs relative to some Anchor other than the file root.</p>
<p><code>AstIds</code>: IDs are assigned per scope rather than globally. This isolates IDs across scopes, so that changes in one scope don&#x27;t invalidate the IDS of the entire file, but only IDs from within the changed scope</p>
<p>To unblock this feature, I&#x27;m leaning towards doing the following:</p>
<ul>
<li>If there&#x27;s a <code>Definition</code>, store a <code>NodeIndex</code> that&#x27;s relative to the <code>Definition</code>&#x27;s <code>NodeIndex</code>. This should give us a pretty stable ID that only changes when you modify the assignment itself.</li>
<li>If there&#x27;s no <code>Definition</code>, store a <code>NodeIndex</code> that&#x27;s relative to the <code>FileScope</code>. This is far from ideal if the enclosing scope is the module scope because it&#x27;s then the same as an absolute node index. But I fail to come up with a better anchor in that case, unless we&#x27;d consider anchoring it relative to the <code>InferenceRegion</code> (and storing it on the <code>DynamicClassLiteral</code>).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4923 on 2026-01-13 08:02</div>
            <div class="timeline-body"><p>I&#x27;d be inclined to store <code>ScopeId</code> here which contains both the <code>File</code> and <code>FileScopeId</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:05</div>
            <div class="timeline-body"><p>Can you add a full snapshot diagnostic test showing how the header range gets highlighted? Because I think we should only highlight the <code>name</code> part rather than the entire <code>CallExression</code> (which can be very long)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:671 on 2026-01-13 08:07</div>
            <div class="timeline-body"><p>If you haven&#x27;t done so already. Can you add a go to definition test for a dynamic class literal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-13 08:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:11</div>
            <div class="timeline-body"><p>I think the vast majority of these calls specifically are very likely to fit into one line, just like the vast majority of class headers (and we usually highlight the full class header rather than just the class name in a diagnostic).</p>
<p>We know that these calls take exactly 3 positional arguments (and, in some very rare edge cases, possibly some keyword arguments).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:15</div>
            <div class="timeline-body"><p>I don&#x27;t think this is the case, we use <code>Definition::focus_range</code> in various places (which won&#x27;t apply for dynamic class literal but to the point that we don&#x27;t highlight the entire class literal)</p>
<p>https://github.com/astral-sh/ruff/blob/4abc5fe2f1a4023a9fa6d702f293f7e5e0ad1e07/crates/ty_python_semantic/src/types/diagnostic.rs#L4278-L4283</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-13 08:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:17</div>
            <div class="timeline-body"><p>Hmm, fair enough</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-13 08:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:19</div>
            <div class="timeline-body"><p>(We do <em>also</em> use <code>class.header_range()</code> in <em>many</em> places, though)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:22</div>
            <div class="timeline-body"><p>Yeah, I think which one of the two it should be depends on the diagnostic. Is it something that only references the type (e.g. in a sub diagnostic), that&#x27;s when higlighting the name only feels correct. Or is it something that is about the class&#x27;s definition (including base classes), highlighting the entire header than seems more appropriate.</p>
<p>So what we have here might actually be okay but we might need a new method <code>name_range</code> in the future</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 08:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 08:37</div>
            <div class="timeline-body"><p>Putting this back to draft to make it easier for reviewers to know when this is ready for review (and not one of GitHub&#x27;s force push notifications ;))</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 13:11</div>
            <div class="timeline-body"><blockquote>
<p>If there&#x27;s a Definition, store a NodeIndex that&#x27;s relative to the Definition&#x27;s NodeIndex. This should give us a pretty stable ID that only changes when you modify the assignment itself.</p>
</blockquote>
<p>Do we need to store <code>NodeIndex</code> at all when we have a <code>Definition</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 13:15</div>
            <div class="timeline-body"><blockquote>
<p>Do we need to store NodeIndex at all when we have a Definition?</p>
</blockquote>
<p>It depends on what you want to highlight. If not, that&#x27;s even better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 14:21</div>
            <div class="timeline-body"><p>(Not ready for review, I will mark it as such.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 16:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/Gankra">@Gankra</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 16:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 16:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2026-01-14 09:18</div>
            <div class="timeline-body"><p>Thank you. The <code>DynamicClassLiteral</code> definition looks good to me. I didn&#x27;t review the semantic typing changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4735 on 2026-01-14 12:49</div>
            <div class="timeline-body"><p>Do we need to store <code>scope</code> as a separate field, or could we do something like this (all tests pass):</p>
<pre><code>diff --git a/crates/ty_python_semantic/src/types/class.rs b/crates/ty_python_semantic/src/types/class.rs
index 5479d05080..f561ddd611 100644
--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -4731,9 +4731,6 @@ pub struct DynamicClassLiteral&lt;&#x27;db&gt; {
     #[returns(deref)]
     pub bases: Box&lt;[ClassBase&lt;&#x27;db&gt;]&gt;,
 
-    /// The scope containing the `type()` call.
-    pub scope: ScopeId&lt;&#x27;db&gt;,
-
     /// The anchor for this dynamic class, providing stable identity.
     ///
     /// - `Definition`: The `type()` call is assigned to a variable. The definition
@@ -4776,7 +4773,7 @@ pub enum DynamicClassAnchor&lt;&#x27;db&gt; {
     ///
     /// The offset is relative to the enclosing scope&#x27;s anchor node index.
     /// For module scope, this is equivalent to an absolute index (anchor is 0).
-    ScopeOffset(u32),
+    ScopeOffset { scope: ScopeId&lt;&#x27;db&gt;, offset: u32 },
 }
 
 impl get_size2::GetSize for DynamicClassLiteral&lt;&#x27;_&gt; {}
@@ -4787,7 +4784,14 @@ impl&lt;&#x27;db&gt; DynamicClassLiteral&lt;&#x27;db&gt; {
     pub(crate) fn definition(self, db: &amp;&#x27;db dyn Db) -&gt; Option&lt;Definition&lt;&#x27;db&gt;&gt; {
         match self.anchor(db) {
             DynamicClassAnchor::Definition(definition) =&gt; Some(definition),
-            DynamicClassAnchor::ScopeOffset(_) =&gt; None,
+            DynamicClassAnchor::ScopeOffset { .. } =&gt; None,
+        }
+    }
+
+    pub(crate) fn scope(self, db: &amp;&#x27;db dyn Db) -&gt; ScopeId&lt;&#x27;db&gt; {
+        match self.anchor(db) {
+            DynamicClassAnchor::Definition(definition) =&gt; definition.scope(db),
+            DynamicClassAnchor::ScopeOffset { scope, .. } =&gt; scope,
         }
     }
 
@@ -4814,7 +4818,7 @@ impl&lt;&#x27;db&gt; DynamicClassLiteral&lt;&#x27;db&gt; {
                     .expect(&quot;DynamicClassAnchor::Definition should only be used for assignments&quot;)
                     .range()
             }
-            DynamicClassAnchor::ScopeOffset(offset) =&gt; {
+            DynamicClassAnchor::ScopeOffset { offset, .. } =&gt; {
                 // For dangling `type()` calls, compute the absolute index from the offset.
                 let scope_anchor = scope.node(db).node_index().unwrap_or(NodeIndex::from(0));
                 let anchor_u32 = scope_anchor
@@ -5070,7 +5074,6 @@ impl&lt;&#x27;db&gt; DynamicClassLiteral&lt;&#x27;db&gt; {
             db,
             self.name(db).clone(),
             self.bases(db),
-            self.scope(db),
             self.anchor(db),
             self.members(db),
             self.has_dynamic_namespace(db),
diff --git a/crates/ty_python_semantic/src/types/infer/builder.rs b/crates/ty_python_semantic/src/types/infer/builder.rs
index 43a4c4c073..bcf219a62b 100644
--- a/crates/ty_python_semantic/src/types/infer/builder.rs
+++ b/crates/ty_python_semantic/src/types/infer/builder.rs
@@ -6193,14 +6193,16 @@ impl&lt;&#x27;db, &#x27;ast&gt; TypeInferenceBuilder&lt;&#x27;db, &#x27;ast&gt; {
             let call_u32 = call_node_index
                 .as_u32()
                 .expect(&quot;call node should not be NodeIndex::NONE&quot;);
-            DynamicClassAnchor::ScopeOffset(call_u32 - anchor_u32)
+            DynamicClassAnchor::ScopeOffset {
+                scope,
+                offset: call_u32 - anchor_u32,
+            }
         };
 
         let dynamic_class = DynamicClassLiteral::new(
             db,
             name,
             bases,
-            scope,
             anchor,
             members,
             has_dynamic_namespace,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4710 on 2026-01-14 12:49</div>
            <div class="timeline-body"><pre><code>/// This is a Salsa-interned struct. Two different `type()` calls always produce
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2026-01-14 12:51</div>
            <div class="timeline-body"><p>LGTM too! I <em>did</em> review the semantic typing changes 😄</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-14 13:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-14 13:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2026-01-14 13:48</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:22:57 UTC
    </footer>
</body>
</html>
