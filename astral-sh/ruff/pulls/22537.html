<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Support 'dangling' `type(...)` constructors - astral-sh/ruff #22537</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Support 'dangling' <code>type(...)</code> constructors</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22537">#22537</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2026-01-12 18:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR adds support for 'dangling' <code>type(...)</code> constructors, e.g.:</p>
<pre><code class="language-python">class Foo(type(&quot;Bar&quot;, ...)):
   ...
</code></pre>
<p>As opposed to:</p>
<pre><code class="language-python">Bar = type(&quot;Bar&quot;, ...)
</code></pre>
<p>The former doesn't have a <code>Definition</code> since it doesn't get bound to a place, so we instead need to store the <code>NodeIndex</code>. Per @MichaReiser's suggestion, we can use a Salsa tracked struct for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-12 18:14</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-12 18:15</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">spack (https://github.com/spack/spack)
+ lib/spack/spack/llnl/util/lang.py:693:50: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__init__]`
- Found 4318 diagnostics
+ Found 4319 diagnostics

black (https://github.com/psf/black)
+ src/black/linegen.py:775:32: error[invalid-assignment] Object of type `list[((Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]) | rhs]` is not assignable to `list[(Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]]`
+ src/black/linegen.py:785:32: error[invalid-assignment] Object of type `list[((Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]) | rhs]` is not assignable to `list[(Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]]`
+ src/black/linegen.py:794:32: error[invalid-assignment] Object of type `list[((Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]) | rhs]` is not assignable to `list[(Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]]`
+ src/black/linegen.py:796:32: error[invalid-assignment] Object of type `list[((Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]) | rhs]` is not assignable to `list[(Line, Collection[Feature], Mode, /) -&gt; Iterator[Line]]`
- Found 54 diagnostics
+ Found 58 diagnostics

schemathesis (https://github.com/schemathesis/schemathesis)
- src/schemathesis/core/deserialization.py:137:34: error[invalid-assignment] Object of type `type` is not assignable to `type[SafeLoader]`
+ src/schemathesis/core/deserialization.py:137:54: warning[unsupported-dynamic-base] Unsupported class base: Has type `&lt;class 'CSafeLoader'&gt; | &lt;class 'SafeLoader'&gt;`
+ src/schemathesis/core/deserialization.py:174:48: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/schemathesis/specs/openapi/stateful/__init__.py:206:12: error[invalid-return-type] Return type does not match returned value: expected `type[APIStateMachine]`, found `type`

artigraph (https://github.com/artigraph/artigraph)
+ src/arti/internal/mappings.py:111:49: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__class_getitem__]`
- src/arti/producers/__init__.py:441:16: error[invalid-return-type] Return type does not match returned value: expected `type[Producer]`, found `type`
- src/arti/types/__init__.py:339:13: error[invalid-argument-type] Argument to bound method `register_adapter` is incorrect: Expected `type[TypeAdapter]`, found `type`
+ src/arti/types/__init__.py:341:18: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@generate]`
- src/arti/types/bigquery.py:66:9: error[invalid-argument-type] Argument to bound method `register_adapter` is incorrect: Expected `type[TypeAdapter]`, found `type`
- src/arti/types/pyarrow.py:42:9: error[invalid-argument-type] Argument to bound method `register_adapter` is incorrect: Expected `type[TypeAdapter]`, found `type`
- Found 149 diagnostics
+ Found 147 diagnostics

psycopg (https://github.com/psycopg/psycopg)
- psycopg/psycopg/types/array.py:350:12: error[invalid-return-type] Return type does not match returned value: expected `type[BaseListDumper]`, found `type`
- psycopg/psycopg/types/array.py:356:12: error[invalid-return-type] Return type does not match returned value: expected `type[BaseListDumper]`, found `type`
- psycopg/psycopg/types/composite.py:525:12: error[invalid-return-type] Return type does not match returned value: expected `type[_CompositeLoader[T@_make_loader]]`, found `type`
- psycopg/psycopg/types/composite.py:534:12: error[invalid-return-type] Return type does not match returned value: expected `type[_CompositeBinaryLoader[T@_make_binary_loader]]`, found `type`
- psycopg/psycopg/types/composite.py:543:12: error[invalid-return-type] Return type does not match returned value: expected `type[_SequenceDumper[T@_make_dumper]]`, found `type`
- psycopg/psycopg/types/composite.py:552:12: error[invalid-return-type] Return type does not match returned value: expected `type[_SequenceBinaryDumper[T@_make_binary_dumper]]`, found `type`
- psycopg/psycopg/types/enum.py:183:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumLoader[E@_make_loader]]`, found `type`
- psycopg/psycopg/types/enum.py:191:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumLoader[E@_make_binary_loader]]`, found `type`
- psycopg/psycopg/types/enum.py:199:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumDumper[E@_make_dumper]]`, found `type`
- psycopg/psycopg/types/enum.py:207:12: error[invalid-return-type] Return type does not match returned value: expected `type[_BaseEnumDumper[E@_make_binary_dumper]]`, found `type`
- psycopg/psycopg/types/multirange.py:407:12: error[invalid-return-type] Return type does not match returned value: expected `type[MultirangeLoader[Any]]`, found `type`
- psycopg/psycopg/types/multirange.py:412:12: error[invalid-return-type] Return type does not match returned value: expected `type[MultirangeBinaryLoader[Any]]`, found `type`
- psycopg/psycopg/types/range.py:586:12: error[invalid-return-type] Return type does not match returned value: expected `type[RangeLoader[Any]]`, found `type`
- psycopg/psycopg/types/range.py:591:12: error[invalid-return-type] Return type does not match returned value: expected `type[RangeBinaryLoader[Any]]`, found `type`
- Found 666 diagnostics
+ Found 652 diagnostics

pandera (https://github.com/pandera-dev/pandera)
- pandera/api/dataframe/model.py:257:13: error[invalid-assignment] Object of type `type` is not assignable to attribute `Config` of type `type[BaseConfig]`
+ pandera/api/dataframe/model.py:257:42: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[BaseConfig]`
- pandera/api/dataframe/model.py:455:16: error[invalid-return-type] Return type does not match returned value: expected `tuple[type[BaseConfig], dict[str, Any]]`, found `tuple[type, dict[str, Any]]`
+ pandera/api/dataframe/model.py:455:32: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[BaseConfig]`
- pandera/api/pyspark/model.py:162:13: error[invalid-assignment] Object of type `type` is not assignable to attribute `Config` of type `type[BaseConfig]`
- Found 1580 diagnostics
+ Found 1579 diagnostics

pydantic (https://github.com/pydantic/pydantic)
- pydantic/fields.py:943:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:943:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:983:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:983:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1026:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1026:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1066:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1066:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1109:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1109:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1148:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1148:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1188:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1188:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1567:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`
+ pydantic/fields.py:1567:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, Divergent], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`
- pydantic/v1/config.py:183:12: error[invalid-return-type] Return type does not match returned value: expected `type[BaseConfig]`, found `type`
- pydantic/v1/networks.py:572:12: error[invalid-return-type] Return type does not match returned value: expected `type[AnyUrl]`, found `type`
+ pydantic/v1/schema.py:1094:50: warning[unsupported-dynamic-base] Unsupported class base: Has type `(Any &amp; type[SecretStr]) | (Any &amp; type[SecretBytes])`
- pydantic/v1/types.py:239:12: error[invalid-return-type] Return type does not match returned value: expected `type[int]`, found `type`
- pydantic/v1/types.py:318:12: error[invalid-return-type] Return type does not match returned value: expected `type[int] | type[float]`, found `type`
- pydantic/v1/types.py:391:12: error[invalid-return-type] Return type does not match returned value: expected `type[bytes]`, found `type`
- pydantic/v1/types.py:471:12: error[invalid-return-type] Return type does not match returned value: expected `type[str]`, found `type`
- pydantic/v1/types.py:749:12: error[invalid-return-type] Return type does not match returned value: expected `type[Decimal]`, found `type`
- pydantic/v1/types.py:833:16: error[invalid-return-type] Return type does not match returned value: expected `type[JsonWrapper]`, found `type`
- pydantic/v1/types.py:1205:12: error[invalid-return-type] Return type does not match returned value: expected `type[date]`, found `type`
- Found 3159 diagnostics
+ Found 3151 diagnostics

trio (https://github.com/python-trio/trio)
- src/trio/_tests/test_util.py:236:5: error[unresolved-attribute] Unresolved attribute `recursion` on type `type`.
+ src/trio/_tests/test_util.py:236:5: error[unresolved-attribute] Unresolved attribute `recursion` on type `&lt;class 'SomeClass'&gt;`.

mkdocs (https://github.com/mkdocs/mkdocs)
+ mkdocs/config/config_options.py:101:28: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__class_getitem__]`
+ mkdocs/plugins.py:75:28: warning[unsupported-dynamic-base] Unsupported class base: Has type `type[Self@__class_getitem__]`
- Found 224 diagnostics
+ Found 226 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
- src/prefect/deployments/runner.py:795:70: warning[possibly-missing-attribute] Attribute `__name__` may be missing on object of type `Unknown | (((...) -&gt; Any) &amp; ((*args: object, **kwargs: object) -&gt; object))`
+ src/prefect/deployments/runner.py:795:70: warning[possibly-missing-attribute] Attribute `__name__` may be missing on object of type `Unknown | ((...) -&gt; Any)`
+ src/prefect/flow_engine.py:812:32: error[invalid-await] `Unknown | R@FlowRunEngine | Coroutine[Any, Any, R@FlowRunEngine]` is not awaitable
+ src/prefect/flow_engine.py:1401:24: error[invalid-await] `Unknown | R@AsyncFlowRunEngine | Coroutine[Any, Any, R@AsyncFlowRunEngine]` is not awaitable
+ src/prefect/flow_engine.py:1482:43: error[invalid-argument-type] Argument to function `next` is incorrect: Expected `SupportsNext[Unknown]`, found `Unknown | R@run_generator_flow_sync`
+ src/prefect/flow_engine.py:1490:21: warning[possibly-missing-attribute] Attribute `throw` may be missing on object of type `Unknown | R@run_generator_flow_sync`
+ src/prefect/flow_engine.py:1524:44: warning[possibly-missing-attribute] Attribute `__anext__` may be missing on object of type `Unknown | R@run_generator_flow_async`
+ src/prefect/flow_engine.py:1531:25: warning[possibly-missing-attribute] Attribute `throw` may be missing on object of type `Unknown | R@run_generator_flow_async`
- src/prefect/flows.py:286:34: error[unresolved-attribute] Object of type `((**P@Flow) -&gt; R@Flow) &amp; ((*args: object, **kwargs: object) -&gt; object)` has no attribute `__name__`
+ src/prefect/flows.py:286:34: error[unresolved-attribute] Object of type `(**P@Flow) -&gt; R@Flow` has no attribute `__name__`
- src/prefect/flows.py:404:68: error[unresolved-attribute] Object of type `((**P@Flow) -&gt; R@Flow) &amp; ((*args: object, **kwargs: object) -&gt; object)` has no attribute `__name__`
+ src/prefect/flows.py:404:68: error[unresolved-attribute] Object of type `(**P@Flow) -&gt; R@Flow` has no attribute `__name__`
- src/prefect/flows.py:1750:53: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/prefect/input/run_input.py:332:82: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 5363 diagnostics
+ Found 5367 diagnostics

strawberry (https://github.com/strawberry-graphql/strawberry)
- strawberry/tools/merge_types.py:35:12: error[invalid-return-type] Return type does not match returned value: expected `type`, found `&lt;decorator produced by dataclass-like function&gt;`
- Found 348 diagnostics
+ Found 347 diagnostics

setuptools (https://github.com/pypa/setuptools)
+ setuptools/_distutils/compilers/C/msvc.py:583:13: error[unresolved-attribute] Unresolved attribute `value` on type `Bag`.
- Found 1265 diagnostics
+ Found 1266 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/build/wheel.py:99:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 48 diagnostics
+ Found 47 diagnostics

jax (https://github.com/google/jax)
- jax/_src/interpreters/partial_eval.py:1710:79: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- jax/_src/interpreters/partial_eval.py:1726:81: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 2836 diagnostics
+ Found 2834 diagnostics

ibis (https://github.com/ibis-project/ibis)
+ ibis/expr/operations/udf.py:155:16: error[invalid-return-type] Return type does not match returned value: expected `type[S@_make_node]`, found `&lt;class '&lt;unknown&gt;'&gt;`
- ibis/expr/operations/udf.py:155:50: error[invalid-argument-type] Argument to class `type` is incorrect: Expected `tuple[type, ...]`, found `tuple[property]`
+ ibis/expr/operations/udf.py:155:51: error[invalid-base] Invalid class base with type `property`
- Found 4607 diagnostics
+ Found 4608 diagnostics

hydpy (https://github.com/hydpy-dev/hydpy)
+ hydpy/core/modeltools.py:3252:61: warning[unsupported-dynamic-base] Unsupported class base: Has type `&lt;class 'InletSequences'&gt; | &lt;class 'ObserverSequences'&gt; | &lt;class 'ReceiverSequences'&gt; | ... omitted 8 union elements`
- Found 664 diagnostics
+ Found 665 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Bus[Any] | Bottom[Series[Any, Any]] | ndarray[Never, Never] | ... omitted 6 union elements, object_]`
- static_frame/core/bus.py:675:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Bus[Any], object_]`, found `InterGetItemILocReduces[Bus[Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, object_ | Self@iloc]`
+ static_frame/core/bus.py:675:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Bus[Any], object_]`, found `InterGetItemILocReduces[Self@iloc | Bus[Any], object_ | Self@iloc]`
- static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Any, TVDtype@Index]`
+ static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Any | Bottom[Series[Any, Any]], TVDtype@Index]`
- static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | ndarray[Never, Never] | TypeBlocks | ... omitted 6 union elements, TVDtype@Series]`
+ static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | Bottom[Index[Any]] | ndarray[Never, Never] | ... omitted 6 union elements, TVDtype@Series]`
- static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, object_]`
+ static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Bottom[Series[Any, Any]] | Yarn[Any] | ndarray[Never, Never] | ... omitted 6 union elements, object_]`
- Found 1827 diagnostics
+ Found 1826 diagnostics

pandas-stubs (https://github.com/pandas-dev/pandas-stubs)
+ pandas-stubs/_typing.pyi:1232:16: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
+ tests/frame/test_groupby.py:229:15: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[str | bytes | int | ... omitted 12 union elements]`
+ tests/frame/test_groupby.py:625:15: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[str | bytes | int | ... omitted 12 union elements]`
- Found 5167 diagnostics
+ Found 5170 diagnostics

rotki (https://github.com/rotki/rotki)
+ rotkehlchen/chain/decoding/tools.py:96:44: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- rotkehlchen/chain/decoding/tools.py:97:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `BTCAddress | ChecksumAddress | SubstrateAddress | SolanaAddress`, found `A@BaseDecoderTools`
+ rotkehlchen/chain/decoding/tools.py:99:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `Sequence[A@BaseDecoderTools]`, found `Unknown | tuple[BTCAddress, ...] | tuple[ChecksumAddress, ...] | tuple[SubstrateAddress, ...] | tuple[SolanaAddress, ...]`
- rotkehlchen/chain/decoding/tools.py:98:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `BTCAddress | ChecksumAddress | SubstrateAddress | SolanaAddress | None`, found `A@BaseDecoderTools | None`
+ rotkehlchen/chain/decoding/tools.py:100:62: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 2056 diagnostics
+ Found 2057 diagnostics

core (https://github.com/home-assistant/core)
+ homeassistant/util/variance.py:47:12: error[invalid-return-type] Return type does not match returned value: expected `(**_P@ignore_variance) -&gt; _R@ignore_variance`, found `_Wrapped[_P@ignore_variance, _R@ignore_variance | int | float | datetime, _P@ignore_variance, _R@ignore_variance | int | float | datetime]`
- Found 14496 diagnostics
+ Found 14497 diagnostics


</code></pre>
</details>

<p>No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[ty] Support 'dangling' type(...) constructors" to "[ty] Support 'dangling' `type(...)` constructors" by @charliermarsh on 2026-01-12 19:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @charliermarsh on 2026-01-12 19:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2026-01-12 19:30</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2>Merging this PR will <strong>not alter performance</strong></h2>
<p><code>✅ 23</code> untouched benchmarks<br />
<code>⏩ 30</code> skipped benchmarks[^skipped]</p>
<hr />
<p><sub>Comparing <code>charlie/dyn-expression</code> (3bf7fa3) with <code>main</code> (6e89e0a)</sub></p>
<a href="https://codspeed.io/astral-sh/ruff/branches/charlie%2Fdyn-expression?utm_source=github&utm_medium=comment-v2&utm_content=button">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://codspeed.io/pr-report/open-in-codspeed-dark.svg">
    <source media="(prefers-color-scheme: light)" srcset="https://codspeed.io/pr-report/open-in-codspeed-light.svg">
    <img alt="Open in CodSpeed" src="https://codspeed.io/pr-report/open-in-codspeed-light.svg" width="169" height="32">
  </picture>
</a>

<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/charlie%2Fdyn-expression?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @charliermarsh on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @charliermarsh on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @charliermarsh on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @charliermarsh on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @charliermarsh on 2026-01-12 20:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2026-01-12 20:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-12 22:10</div>
            <div class="timeline-body"><blockquote>
<p>The former doesn't have a Definition since it doesn't get bound to a place, so we instead need to store the NodeIndex. Per @MichaReiser's suggestion, we can use a Salsa tracked struct for this.</p>
</blockquote>
<p>I'm actually coming to the conclusion that we can't use tracked structs:</p>
<ul>
<li>I don't think Salsa's handling of tracked structs in cycles is sound today. Specifically, I suspect that Salsa reuses tracked structs between iterations. This is the behavior you want in this specific instance, but Niko and I believe it is unsound because it mutates tracked structs within a revision (specifically, Salsa <a href="https://github.com/MichaReiser/salsa/blob/103fa518298432a5f5bdb75e3727a179e3b056cf/src/tracked_struct.rs#L664">skips the update entirely</a>, ignoring the values you're trying to write in the later iterations), which should not be a thing. Instead, iteration 1 and iteration 2 should create two distinct tracked structs. They are two distinct <code>::new</code> calls (think of each iteration as unrolling the function body once). However, if we make this change, the consequence is that a salsa query returning a tracked struct as part of its result can never converge because the struct's ID is different after each iteration. But this is precisely the situation that we have here.</li>
<li>I'm also having a hard time reasoning about what the equality is supposed to be in the places where we call <code>with_dataclass_params</code>. None of those instances is guaranteed to compare equal, even if they have the same values, because they might be created from different queries. I think this could be fixed by making <code>with_dataclass_params</code> a salsa tracked function, so that calling <code>with_dataclass_params</code> with the same params on the same <code>DynamicClassLiteral</code> always returns the same instance.</li>
</ul>
<p>I'm not sure yet what the right solution here is but I don't feel confident building on something that is very likely unsupported in the near future. I've to think about this a little more.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-12 22:16</div>
            <div class="timeline-body"><p>The only other idea I had was to create a stable ID for the call:</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/semantic_index/ast_ids.rs b/crates/ty_python_semantic/src/semantic_index/ast_ids.rs
index cc2c65526e..514984674f 100644
--- a/crates/ty_python_semantic/src/semantic_index/ast_ids.rs
+++ b/crates/ty_python_semantic/src/semantic_index/ast_ids.rs
@@ -1,8 +1,8 @@
-use rustc_hash::FxHashMap;
-
-use ruff_index::newtype_index;
+use ruff_index::{IndexVec, newtype_index};
 use ruff_python_ast as ast;
 use ruff_python_ast::ExprRef;
+use ruff_text_size::TextRange;
+use rustc_hash::FxHashMap;
 
 use crate::Db;
 use crate::semantic_index::ast_ids::node_key::ExpressionNodeKey;
@@ -28,12 +28,27 @@ use crate::semantic_index::semantic_index;
 pub(crate) struct AstIds {
     /// Maps expressions which &quot;use&quot; a place (that is, [`ast::ExprName`], [`ast::ExprAttribute`] or [`ast::ExprSubscript`]) to a use id.
     uses_map: FxHashMap&lt;ExpressionNodeKey, ScopedUseId&gt;,
+    /// Maps potential synthesized-type call expressions to a call id for stable identity.
+    tracked_calls_map: FxHashMap&lt;ExpressionNodeKey, ScopedCallId&gt;,
+    /// Stores the ranges of tracked calls, indexed by their [`ScopedCallId`].
+    /// Used for diagnostics (e.g., `header_range`).
+    tracked_call_ranges: IndexVec&lt;ScopedCallId, TextRange&gt;,
 }
 
 impl AstIds {
     fn use_id(&amp;self, key: impl Into&lt;ExpressionNodeKey&gt;) -&gt; ScopedUseId {
         self.uses_map[&amp;key.into()]
     }
+
+    /// Returns the call ID for a potential synthesized-type call, if it was tracked during semantic indexing.
+    pub(crate) fn try_call_id(&amp;self, key: impl Into&lt;ExpressionNodeKey&gt;) -&gt; Option&lt;ScopedCallId&gt; {
+        self.tracked_calls_map.get(&amp;key.into()).copied()
+    }
+
+    /// Returns the range of a tracked call by its ID.
+    pub(crate) fn call_range(&amp;self, id: ScopedCallId) -&gt; TextRange {
+        self.tracked_call_ranges[id]
+    }
 }
 
 fn ast_ids&lt;'db&gt;(db: &amp;'db dyn Db, scope: ScopeId) -&gt; &amp;'db AstIds {
@@ -45,6 +60,15 @@ fn ast_ids&lt;'db&gt;(db: &amp;'db dyn Db, scope: ScopeId) -&gt; &amp;'db AstIds {
 #[derive(get_size2::GetSize)]
 pub struct ScopedUseId;
 
+/// Uniquely identifies a potential synthesized-type call in a [`crate::semantic_index::FileScopeId`].
+///
+/// This is used to provide stable identity for inline calls that create synthesized types,
+/// such as `type()`, `NamedTuple()`, `TypedDict()`, etc. The ID is assigned during semantic
+/// indexing for calls that match known patterns for these synthesizers.
+#[newtype_index]
+#[derive(get_size2::GetSize)]
+pub struct ScopedCallId;
+
 pub trait HasScopedUseId {
     /// Returns the ID that uniquely identifies the use in `scope`.
     fn scoped_use_id(&amp;self, db: &amp;dyn Db, scope: ScopeId) -&gt; ScopedUseId;
@@ -88,6 +112,8 @@ impl HasScopedUseId for ast::ExprRef&lt;'_&gt; {
 #[derive(Debug, Default)]
 pub(super) struct AstIdsBuilder {
     uses_map: FxHashMap&lt;ExpressionNodeKey, ScopedUseId&gt;,
+    tracked_calls_map: FxHashMap&lt;ExpressionNodeKey, ScopedCallId&gt;,
+    tracked_call_ranges: IndexVec&lt;ScopedCallId, TextRange&gt;,
 }
 
 impl AstIdsBuilder {
@@ -100,11 +126,25 @@ impl AstIdsBuilder {
         use_id
     }
 
+    /// Records a potential synthesized-type call for stable identity tracking.
+    pub(super) fn record_call(
+        &amp;mut self,
+        expr: impl Into&lt;ExpressionNodeKey&gt;,
+        range: TextRange,
+    ) -&gt; ScopedCallId {
+        let call_id = self.tracked_call_ranges.push(range);
+        self.tracked_calls_map.insert(expr.into(), call_id);
+        call_id
+    }
+
     pub(super) fn finish(mut self) -&gt; AstIds {
         self.uses_map.shrink_to_fit();
+        self.tracked_calls_map.shrink_to_fit();
 
         AstIds {
             uses_map: self.uses_map,
+            tracked_calls_map: self.tracked_calls_map,
+            tracked_call_ranges: self.tracked_call_ranges,
         }
     }
 }
diff --git a/crates/ty_python_semantic/src/semantic_index/builder.rs b/crates/ty_python_semantic/src/semantic_index/builder.rs
index 3ef83e97d2..61945b5681 100644
--- a/crates/ty_python_semantic/src/semantic_index/builder.rs
+++ b/crates/ty_python_semantic/src/semantic_index/builder.rs
@@ -14,7 +14,7 @@ use ruff_python_ast::{self as ast, NodeIndex, PySourceType, PythonVersion};
 use ruff_python_parser::semantic_errors::{
     SemanticSyntaxChecker, SemanticSyntaxContext, SemanticSyntaxError, SemanticSyntaxErrorKind,
 };
-use ruff_text_size::TextRange;
+use ruff_text_size::{Ranged, TextRange};
 use ty_module_resolver::{ModuleName, resolve_module};
 
 use crate::ast_node_ref::AstNodeRef;
@@ -2741,6 +2741,17 @@ impl&lt;'ast&gt; Visitor&lt;'ast&gt; for SemanticIndexBuilder&lt;'_, 'ast&gt; {
                 }
                 walk_expr(self, expr);
             }
+            ast::Expr::Call(call_expr) =&gt; {
+                // Track potential synthesized-type calls for stable identity.
+                // Assigned calls use `Definition` for identity; inline calls need a `ScopedCallId`.
+                if self.current_assignment().is_none()
+                    &amp;&amp; is_potential_synthesized_type_call(call_expr)
+                {
+                    self.current_ast_ids()
+                        .record_call(call_expr, call_expr.range());
+                }
+                walk_expr(self, expr);
+            }
             _ =&gt; {
                 walk_expr(self, expr);
             }
@@ -3195,3 +3206,31 @@ fn is_if_not_type_checking(expr: &amp;ast::Expr) -&gt; bool {
         }) if is_if_type_checking(operand)
     )
 }
+
+/// Returns whether a call expression might create a synthesized type.
+///
+/// This is a heuristic used during semantic indexing to assign stable IDs
+/// to calls that may produce `NamedTuple`, `TypedDict`, `type()` classes, etc.
+/// False positives are acceptable (the ID just won't be used during inference).
+fn is_potential_synthesized_type_call(call: &amp;ast::ExprCall) -&gt; bool {
+    // Check for `type(...)` or `builtins.type(...)`
+    let is_type_call = match call.func.as_ref() {
+        ast::Expr::Name(name) =&gt; name.id.as_str() == &quot;type&quot;,
+        ast::Expr::Attribute(attr) =&gt; {
+            attr.attr.as_str() == &quot;type&quot;
+                &amp;&amp; matches!(attr.value.as_ref(), ast::Expr::Name(name) if name.id.as_str() == &quot;builtins&quot;)
+        }
+        _ =&gt; false,
+    };
+
+    if is_type_call {
+        // type(&quot;Name&quot;, bases, dict)
+        return call.arguments.keywords.is_empty() &amp;&amp; call.arguments.args.len() == 3;
+    }
+
+    // TODO: Add more patterns as we support them:
+    // - NamedTuple(&quot;Name&quot;, [...]) or NamedTuple(&quot;Name&quot;, field1=type1, ...)
+    // - TypedDict(&quot;Name&quot;, {...}) or TypedDict(&quot;Name&quot;, field1=type1, ...)
+
+    false
+}
diff --git a/crates/ty_python_semantic/src/types.rs b/crates/ty_python_semantic/src/types.rs
index 76cc4684b1..4c9df1bf3c 100644
--- a/crates/ty_python_semantic/src/types.rs
+++ b/crates/ty_python_semantic/src/types.rs
@@ -6529,9 +6529,9 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 Some(TypeDefinition::Function(function.definition(db)))
             }
             Self::ModuleLiteral(module) =&gt; Some(TypeDefinition::Module(module.module(db))),
-            Self::ClassLiteral(class_literal) =&gt; Some(class_literal.type_definition(db)),
+            Self::ClassLiteral(class_literal) =&gt; class_literal.type_definition(db),
             Self::GenericAlias(alias) =&gt; Some(TypeDefinition::StaticClass(alias.definition(db))),
-            Self::NominalInstance(instance) =&gt; Some(instance.class(db).type_definition(db)),
+            Self::NominalInstance(instance) =&gt; instance.class(db).type_definition(db),
             Self::KnownInstance(instance) =&gt; match instance {
                 KnownInstanceType::TypeVar(var) =&gt; {
                     Some(TypeDefinition::TypeVar(var.definition(db)?))
@@ -6545,7 +6545,7 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
 
             Self::SubclassOf(subclass_of_type) =&gt; match subclass_of_type.subclass_of() {
                 SubclassOfInner::Dynamic(_) =&gt; None,
-                SubclassOfInner::Class(class) =&gt; Some(class.type_definition(db)),
+                SubclassOfInner::Class(class) =&gt; class.type_definition(db),
                 SubclassOfInner::TypeVar(bound_typevar) =&gt; {
                     Some(TypeDefinition::TypeVar(bound_typevar.typevar(db).definition(db)?))
                 }
@@ -6575,7 +6575,7 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
             Self::TypeVar(bound_typevar) =&gt; Some(TypeDefinition::TypeVar(bound_typevar.typevar(db).definition(db)?)),
 
             Self::ProtocolInstance(protocol) =&gt; match protocol.inner {
-                Protocol::FromClass(class) =&gt; Some(class.type_definition(db)),
+                Protocol::FromClass(class) =&gt; class.type_definition(db),
                 Protocol::Synthesized(_) =&gt; None,
             },
 
diff --git a/crates/ty_python_semantic/src/types/class.rs b/crates/ty_python_semantic/src/types/class.rs
index ba4f3b61fc..0d4ed7360a 100644
--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -10,11 +10,13 @@ use super::{
     function::FunctionType,
 };
 use crate::place::{DefinedPlace, TypeOrigin};
-use crate::semantic_index::definition::{Definition, DefinitionState};
-use crate::semantic_index::scope::{NodeWithScopeKind, Scope, ScopeKind};
+use crate::semantic_index::ast_ids::ScopedCallId;
+use crate::semantic_index::definition::{Definition, DefinitionKind, DefinitionState};
+use crate::semantic_index::scope::{FileScopeId, NodeWithScopeKind, Scope, ScopeKind};
 use crate::semantic_index::symbol::Symbol;
 use crate::semantic_index::{
     DeclarationWithConstraint, SemanticIndex, attribute_declarations, attribute_scopes,
+    semantic_index,
 };
 use crate::types::bound_super::BoundSuperError;
 use crate::types::constraints::{ConstraintSet, IteratorConstraintsExtension};
@@ -57,11 +59,7 @@ use crate::{
         known_module_symbol, place_from_bindings, place_from_declarations,
     },
     semantic_index::{
-        attribute_assignments,
-        definition::{DefinitionKind, TargetKind},
-        place_table,
-        scope::{FileScopeId, ScopeId},
-        semantic_index, use_def_map,
+        attribute_assignments, definition::TargetKind, place_table, scope::ScopeId, use_def_map,
     },
     types::{
         CallArguments, CallError, CallErrorKind, MetaclassCandidate, TypeDefinition, UnionType,
@@ -668,10 +666,10 @@ impl&lt;'db&gt; ClassLiteral&lt;'db&gt; {
         }
     }
 
-    /// Returns the definition of this class.
-    pub(crate) fn definition(self, db: &amp;'db dyn Db) -&gt; Definition&lt;'db&gt; {
+    /// Returns the definition of this class, if available.
+    pub(crate) fn definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;Definition&lt;'db&gt;&gt; {
         match self {
-            Self::Static(class) =&gt; class.definition(db),
+            Self::Static(class) =&gt; Some(class.definition(db)),
             Self::Dynamic(class) =&gt; class.definition(db),
         }
     }
@@ -679,11 +677,11 @@ impl&lt;'db&gt; ClassLiteral&lt;'db&gt; {
     /// Returns the type definition for this class.
     ///
     /// For static classes, returns `TypeDefinition::StaticClass`.
-    /// For dynamic classes, returns `TypeDefinition::DynamicClass`.
-    pub(crate) fn type_definition(self, db: &amp;'db dyn Db) -&gt; TypeDefinition&lt;'db&gt; {
+    /// For dynamic classes, returns `TypeDefinition::DynamicClass` if a definition is available.
+    pub(crate) fn type_definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;TypeDefinition&lt;'db&gt;&gt; {
         match self {
-            Self::Static(class) =&gt; TypeDefinition::StaticClass(class.definition(db)),
-            Self::Dynamic(class) =&gt; TypeDefinition::DynamicClass(class.definition(db)),
+            Self::Static(class) =&gt; Some(TypeDefinition::StaticClass(class.definition(db))),
+            Self::Dynamic(class) =&gt; class.definition(db).map(TypeDefinition::DynamicClass),
         }
     }
 
@@ -941,13 +939,13 @@ impl&lt;'db&gt; ClassType&lt;'db&gt; {
         self.class_literal(db).known(db)
     }
 
-    /// Returns the definition for this class.
-    pub(crate) fn definition(self, db: &amp;'db dyn Db) -&gt; Definition&lt;'db&gt; {
+    /// Returns the definition for this class, if available.
+    pub(crate) fn definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;Definition&lt;'db&gt;&gt; {
         self.class_literal(db).definition(db)
     }
 
     /// Returns the type definition for this class.
-    pub(crate) fn type_definition(self, db: &amp;'db dyn Db) -&gt; TypeDefinition&lt;'db&gt; {
+    pub(crate) fn type_definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;TypeDefinition&lt;'db&gt;&gt; {
         self.class_literal(db).type_definition(db)
     }
 
@@ -4680,21 +4678,18 @@ impl&lt;'db&gt; VarianceInferable&lt;'db&gt; for ClassLiteral&lt;'db&gt; {
 ///
 /// # Salsa interning
 ///
-/// Each `type()` call is uniquely identified by its [`Definition`], which provides
-/// stable identity without depending on AST node indices that can change when code
-/// is inserted above the call site.
+/// Each `type()` call is uniquely identified by its [`DynamicClassOrigin`], which provides
+/// stable identity without depending on AST node indices that can change when code is
+/// inserted above the call site.
 ///
-/// Two different `type()` calls always produce distinct `DynamicClassLiteral`
-/// instances, even if they have the same name and bases:
+/// Two different `type()` calls always produce distinct `DynamicClassLiteral` instances,
+/// even if they have the same name and bases:
 ///
 /// ```python
 /// Foo1 = type(&quot;Foo&quot;, (Base,), {})
 /// Foo2 = type(&quot;Foo&quot;, (Base,), {})
 /// # Foo1 and Foo2 are distinct types
 /// ```
-///
-/// Note: Only assigned `type()` calls are currently supported (e.g., `Foo = type(...)`).
-/// Inline calls like `process(type(...))` fall back to normal call handling.
 #[salsa::interned(debug, heap_size = ruff_memory_usage::heap_size)]
 #[derive(PartialOrd, Ord)]
 pub struct DynamicClassLiteral&lt;'db&gt; {
@@ -4706,14 +4701,38 @@ pub struct DynamicClassLiteral&lt;'db&gt; {
     #[returns(deref)]
     pub bases: Box&lt;[ClassBase&lt;'db&gt;]&gt;,
 
-    /// The definition where this class is created.
-    pub definition: Definition&lt;'db&gt;,
+    /// The origin of this dynamic class, providing stable identity.
+    pub origin: DynamicClassOrigin&lt;'db&gt;,
 
     /// Dataclass parameters if this class has been wrapped with `@dataclass` decorator
     /// or passed to `dataclass()` as a function.
     pub dataclass_params: Option&lt;DataclassParams&lt;'db&gt;&gt;,
 }
 
+/// The origin of a dynamically created class, used for stable identity in Salsa.
+///
+/// This enum provides stable identification for `type()` calls without relying on
+/// AST node indices that change when code is inserted above the call site.
+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa::Update)]
+pub enum DynamicClassOrigin&lt;'db&gt; {
+    /// A `type()` call that is assigned to a variable (e.g., `Foo = type(&quot;Foo&quot;, (), {})`).
+    ///
+    /// The Definition provides stable identity via its `ScopedPlaceId`.
+    Assigned(Definition&lt;'db&gt;),
+
+    /// An inline `type()` call not assigned to a variable (e.g., `process(type(&quot;Foo&quot;, (), {}))`).
+    ///
+    /// Uses file, scope, and a scoped call ID for stable identity.
+    /// The ID is assigned sequentially during semantic indexing.
+    Inline {
+        file: File,
+        file_scope: FileScopeId,
+        call_id: ScopedCallId,
+    },
+}
+
+impl get_size2::GetSize for DynamicClassOrigin&lt;'_&gt; {}
+
 impl get_size2::GetSize for DynamicClassLiteral&lt;'_&gt; {}
 
 #[salsa::tracked]
@@ -4727,25 +4746,52 @@ impl&lt;'db&gt; DynamicClassLiteral&lt;'db&gt; {
 
     /// Returns the range of the `type()` call expression that created this class.
     pub(super) fn header_range(self, db: &amp;'db dyn Db) -&gt; TextRange {
-        let definition = self.definition(db);
-        let file = definition.file(db);
-        let module = parsed_module(db, file).load(db);
-
-        // Dynamic classes are only created from regular assignments (e.g., `Foo = type(...)`).
-        let DefinitionKind::Assignment(assignment) = definition.kind(db) else {
-            unreachable!(&quot;DynamicClassLiteral should only be created from Assignment definitions&quot;);
-        };
-        assignment.value(&amp;module).range()
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; {
+                // For assigned calls, get the range from the assignment value.
+                let file = definition.file(db);
+                let module = parsed_module(db, file).load(db);
+                let DefinitionKind::Assignment(assignment) = definition.kind(db) else {
+                    unreachable!(
+                        &quot;DynamicClassOrigin::Assigned should only be created from Assignment definitions&quot;
+                    );
+                };
+                assignment.value(&amp;module).range()
+            }
+            DynamicClassOrigin::Inline {
+                file,
+                file_scope,
+                call_id,
+            } =&gt; {
+                // For inline calls, look up the range from the semantic index.
+                let index = semantic_index(db, file);
+                index.ast_ids(file_scope).call_range(call_id)
+            }
+        }
     }
 
     /// Returns the file containing the `type()` call.
     pub(crate) fn file(self, db: &amp;'db dyn Db) -&gt; File {
-        self.definition(db).file(db)
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; definition.file(db),
+            DynamicClassOrigin::Inline { file, .. } =&gt; file,
+        }
     }
 
     /// Returns the scope containing the `type()` call.
     pub(crate) fn file_scope(self, db: &amp;'db dyn Db) -&gt; FileScopeId {
-        self.definition(db).file_scope(db)
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; definition.file_scope(db),
+            DynamicClassOrigin::Inline { file_scope, .. } =&gt; file_scope,
+        }
+    }
+
+    /// Returns the definition where this class is created, if in an assignment context.
+    pub(crate) fn definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;Definition&lt;'db&gt;&gt; {
+        match self.origin(db) {
+            DynamicClassOrigin::Assigned(definition) =&gt; Some(definition),
+            DynamicClassOrigin::Inline { .. } =&gt; None,
+        }
     }
 
     /// Get the metaclass of this dynamic class.
@@ -4919,7 +4965,7 @@ impl&lt;'db&gt; DynamicClassLiteral&lt;'db&gt; {
             db,
             self.name(db).clone(),
             self.bases(db),
-            self.definition(db),
+            self.origin(db),
             dataclass_params,
         )
     }
diff --git a/crates/ty_python_semantic/src/types/generics.rs b/crates/ty_python_semantic/src/types/generics.rs
index b467f08bbe..290daac22a 100644
--- a/crates/ty_python_semantic/src/types/generics.rs
+++ b/crates/ty_python_semantic/src/types/generics.rs
@@ -96,7 +96,7 @@ pub(crate) fn typing_self&lt;'db&gt;(
     let identity = TypeVarIdentity::new(
         db,
         ast::name::Name::new_static(&quot;Self&quot;),
-        Some(class.definition(db)),
+        class.definition(db),
         TypeVarKind::TypingSelf,
     );
     let bounds = TypeVarBoundOrConstraints::UpperBound(Type::instance(
diff --git a/crates/ty_python_semantic/src/types/ide_support.rs b/crates/ty_python_semantic/src/types/ide_support.rs
index 70fa611c77..73497948b1 100644
--- a/crates/ty_python_semantic/src/types/ide_support.rs
+++ b/crates/ty_python_semantic/src/types/ide_support.rs
@@ -169,9 +169,9 @@ pub fn definitions_for_name&lt;'db&gt;(
                 // instead of `int` (hover only shows the docstring of the first definition).
                 .rev()
                 .filter_map(|ty| ty.as_nominal_instance())
-                .map(|instance| {
-                    let definition = instance.class_literal(db).definition(db);
-                    ResolvedDefinition::Definition(definition)
+                .filter_map(|instance| {
+                    let definition = instance.class_literal(db).definition(db)?;
+                    Some(ResolvedDefinition::Definition(definition))
                 })
                 .collect();
         }
diff --git a/crates/ty_python_semantic/src/types/infer/builder.rs b/crates/ty_python_semantic/src/types/infer/builder.rs
index 3953e4cbb8..1046d70bec 100644
--- a/crates/ty_python_semantic/src/types/infer/builder.rs
+++ b/crates/ty_python_semantic/src/types/infer/builder.rs
@@ -48,14 +48,14 @@ use crate::semantic_index::scope::{
 };
 use crate::semantic_index::symbol::{ScopedSymbolId, Symbol};
 use crate::semantic_index::{
-    ApplicableConstraints, EnclosingSnapshotResult, SemanticIndex, place_table,
+    ApplicableConstraints, EnclosingSnapshotResult, SemanticIndex, place_table, semantic_index,
 };
 use crate::subscript::{PyIndex, PySlice};
 use crate::types::call::bind::{CallableDescription, MatchingOverloadIndex};
 use crate::types::call::{Binding, Bindings, CallArguments, CallError, CallErrorKind};
 use crate::types::class::{
-    ClassLiteral, CodeGeneratorKind, DynamicClassLiteral, DynamicMetaclassConflict, FieldKind,
-    MetaclassErrorKind, MethodDecorator,
+    ClassLiteral, CodeGeneratorKind, DynamicClassLiteral, DynamicClassOrigin,
+    DynamicMetaclassConflict, FieldKind, MetaclassErrorKind, MethodDecorator,
 };
 use crate::types::context::{InNoTypeCheck, InferContext};
 use crate::types::cyclic::CycleDetector;
@@ -5412,7 +5412,7 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
                             // Try to extract the dynamic class with definition.
                             // This returns `None` if it's not a three-arg call to `type()`,
                             // signalling that we must fall back to normal call inference.
-                            self.infer_dynamic_type_expression(call_expr, definition)
+                            self.infer_dynamic_type_expression(call_expr, Some(definition))
                                 .unwrap_or_else(|| {
                                     self.infer_call_expression_impl(call_expr, callable_type, tcx)
                                 })
@@ -6031,7 +6031,7 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
     fn infer_dynamic_type_expression(
         &amp;mut self,
         call_expr: &amp;ast::ExprCall,
-        definition: Definition&lt;'db&gt;,
+        definition: Option&lt;Definition&lt;'db&gt;&gt;,
     ) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
         let db = self.db();
 
@@ -6090,7 +6090,29 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
 
         let bases = self.extract_dynamic_type_bases(bases_arg, bases_type, &amp;name);
 
-        let dynamic_class = DynamicClassLiteral::new(db, name, bases, definition, None);
+        // Get the origin for this dynamic class.
+        let origin = if let Some(def) = definition {
+            // Assigned call: use the definition for stable identity.
+            DynamicClassOrigin::Assigned(def)
+        } else {
+            // Inline call: look up the ScopedCallId from semantic indexing.
+            let file = self.file();
+            let file_scope = self.scope().file_scope_id(db);
+            let index = semantic_index(db, file);
+            let Some(call_id) = index.ast_ids(file_scope).try_call_id(call_expr) else {
+                // If no call ID was tracked for this call during semantic indexing,
+                // we can't create a stable DynamicClassLiteral. Fall back to regular
+                // type inference.
+                return None;
+            };
+            DynamicClassOrigin::Inline {
+                file,
+                file_scope,
+                call_id,
+            }
+        };
+
+        let dynamic_class = DynamicClassLiteral::new(db, name, bases, origin, None);
 
         // Check for MRO errors.
         if let Err(error) = dynamic_class.try_mro(db) {
@@ -9073,6 +9095,14 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
             return Type::TypedDict(typed_dict);
         }
 
+        // Handle 3-argument `type(name, bases, dict)`.
+        if let Type::ClassLiteral(class) = callable_type
+            &amp;&amp; class.is_known(self.db(), KnownClass::Type)
+            &amp;&amp; let Some(dynamic_type) = self.infer_dynamic_type_expression(call_expression, None)
+        {
+            return dynamic_type;
+        }
+
         // We don't call `Type::try_call`, because we want to perform type inference on the
         // arguments after matching them to parameters, but before checking that the argument types
         // are assignable to any parameter annotations.
diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index d7a93d8bcf..66543694ad 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -303,14 +303,14 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
 
     pub fn definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;Definition&lt;'db&gt;&gt; {
         match self {
-            TypedDictType::Class(defining_class) =&gt; Some(defining_class.definition(db)),
+            TypedDictType::Class(defining_class) =&gt; defining_class.definition(db),
             TypedDictType::Synthesized(_) =&gt; None,
         }
     }
 
     pub fn type_definition(self, db: &amp;'db dyn Db) -&gt; Option&lt;TypeDefinition&lt;'db&gt;&gt; {
         match self {
-            TypedDictType::Class(defining_class) =&gt; Some(defining_class.type_definition(db)),
+            TypedDictType::Class(defining_class) =&gt; defining_class.type_definition(db),
             TypedDictType::Synthesized(_) =&gt; None,
         }
     }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 08:01</div>
            <div class="timeline-body"><blockquote>
<p>The only other idea I had was to create a stable ID for the call:</p>
</blockquote>
<p>I don't think this works for ty as it has false-negatives if you alias an import like <code>from typing import NamedTuple as NT</code></p>
<p>We need to come up with another identifier that changes less often than an absolute node index or a text range, to limit the blast radius. There's really just been one pattern that we've been using for this and it is to make IDs relative to some Anchor other than the file root.</p>
<p><code>AstIds</code>: IDs are assigned per scope rather than globally. This isolates IDs across scopes, so that changes in one scope don't invalidate the IDS of the entire file, but only IDs from within the changed scope</p>
<p>To unblock this feature, I'm leaning towards doing the following:</p>
<ul>
<li>If there's a <code>Definition</code>, store a <code>NodeIndex</code> that's relative to the <code>Definition</code>'s <code>NodeIndex</code>. This should give us a pretty stable ID that only changes when you modify the assignment itself.</li>
<li>If there's no <code>Definition</code>, store a <code>NodeIndex</code> that's relative to the <code>FileScope</code>. This is far from ideal if the enclosing scope is the module scope because it's then the same as an absolute node index. But I fail to come up with a better anchor in that case, unless we'd consider anchoring it relative to the <code>InferenceRegion</code> (and storing it on the <code>DynamicClassLiteral</code>).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4923 on 2026-01-13 08:02</div>
            <div class="timeline-body"><p>I'd be inclined to store <code>ScopeId</code> here which contains both the <code>File</code> and <code>FileScopeId</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:05</div>
            <div class="timeline-body"><p>Can you add a full snapshot diagnostic test showing how the header range gets highlighted? Because I think we should only highlight the <code>name</code> part rather than the entire <code>CallExression</code> (which can be very long)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:675 on 2026-01-13 08:07</div>
            <div class="timeline-body"><p>If you haven't done so already. Can you add a go to definition test for a dynamic class literal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-13 08:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:11</div>
            <div class="timeline-body"><p>I think the vast majority of these calls specifically are very likely to fit into one line, just like the vast majority of class headers (and we usually highlight the full class header rather than just the class name in a diagnostic).</p>
<p>We know that these calls take exactly 3 positional arguments (and, in some very rare edge cases, possibly some keyword arguments).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:15</div>
            <div class="timeline-body"><p>I don't think this is the case, we use <code>Definition::focus_range</code> in various places (which won't apply for dynamic class literal but to the point that we don't highlight the entire class literal)</p>
<p>https://github.com/astral-sh/ruff/blob/4abc5fe2f1a4023a9fa6d702f293f7e5e0ad1e07/crates/ty_python_semantic/src/types/diagnostic.rs#L4278-L4283</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-13 08:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:17</div>
            <div class="timeline-body"><p>Hmm, fair enough</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-13 08:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:19</div>
            <div class="timeline-body"><p>(We do <em>also</em> use <code>class.header_range()</code> in <em>many</em> places, though)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-13 08:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:4748 on 2026-01-13 08:22</div>
            <div class="timeline-body"><p>Yeah, I think which one of the two it should be depends on the diagnostic. Is it something that only references the type (e.g. in a sub diagnostic), that's when higlighting the name only feels correct. Or is it something that is about the class's definition (including base classes), highlighting the entire header than seems more appropriate.</p>
<p>So what we have here might actually be okay but we might need a new method <code>name_range</code> in the future</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @MichaReiser on 2026-01-13 08:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 08:37</div>
            <div class="timeline-body"><p>Putting this back to draft to make it easier for reviewers to know when this is ready for review (and not one of GitHub's force push notifications ;))</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 13:11</div>
            <div class="timeline-body"><blockquote>
<p>If there's a Definition, store a NodeIndex that's relative to the Definition's NodeIndex. This should give us a pretty stable ID that only changes when you modify the assignment itself.</p>
</blockquote>
<p>Do we need to store <code>NodeIndex</code> at all when we have a <code>Definition</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-13 13:15</div>
            <div class="timeline-body"><blockquote>
<p>Do we need to store NodeIndex at all when we have a Definition?</p>
</blockquote>
<p>It depends on what you want to highlight. If not, that's even better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-13 14:21</div>
            <div class="timeline-body"><p>(Not ready for review, I will mark it as such.)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-13 15:31:41 UTC
    </footer>
</body>
</html>
