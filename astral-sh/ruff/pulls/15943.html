<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Make `Symbol::or_fall_back_to()` lazy - astral-sh/ruff #15943</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Make <code>Symbol::or_fall_back_to()</code> lazy</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15943">#15943</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-02-04 17:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR allows us to conditionally chain different fallback symbols together. (The chain breaks as soon as we reach a symbol that is definitely bound.) The new API means we're lazy by default (I realized we were eagerly executing several <code>ModuleType::to_class_literal(db).member(db, name)</code> calls which would be immediately thrown away in several situations). Lastly, it means that in some situations we construct union types where the elements are arranged in a more intuitive order than we currently have on main.</p>
<h2>Test Plan</h2>
<p><code>cargo test -p red_knot_python_semantic</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-02-04 17:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-02-04 17:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2025-02-04 17:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-02-04 17:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 17:43</div>
            <div class="timeline-body"><p>Nit: I'm leaning towards calling this <code>or_else</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:87 on 2025-02-04 17:47</div>
            <div class="timeline-body"><p>The <code>and</code> is slightly misleading<code>because it doesn't &quot;and&quot; any existing condition. E.g. the API suggests that</code>symbol.or_possibly_unbound(db).and(|| false).and(|| true)` would be possible where it isn't.</p>
<p>I don't know a better naming or have a suggestion just now. I'd have to think it through in detail. How important is that we change this now or could we improve this later or just leave as is?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-04 17:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 17:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 17:52</div>
            <div class="timeline-body"><p>The idea is that you can read the method chaining &quot;like a sentence&quot;. E.g. the usage in <code>infer.rs</code> in this PR:</p>
<pre><code class="language-rs">            Symbol::Unbound
                // No nonlocal binding? Check the module's globals.
                // Avoid infinite recursion if `self.scope` already is the module's global scope.
                .or_if_possibly_unbound(db)
                .and(|| !file_scope_id.is_global())
                .then_fall_back_to(|| global_symbol(db, self.file(), name))
                // Not found in globals? Fallback to builtins
                // (without infinite recursion if we're already in builtins.)
                .or_if_possibly_unbound(db)
                .and(|| Some(self.scope()) != builtins_module_scope(self.db()))
                .then_fall_back_to(|| builtins_symbol(self.db(), name))
                // Still not found? It might be `reveal_type`...
                .or_if_possibly_unbound(db)
                .and(|| name == &quot;reveal_type&quot;)
                .then_fall_back_to(|| {
                    self.context.report_lint(
                        &amp;UNDEFINED_REVEAL,
                        name_node.into(),
                        format_args!(
                            &quot;`reveal_type` used without importing it; \
                        this is allowed for debugging convenience but will fail at runtime&quot;
                        ),
                    );
                    typing_extensions_symbol(self.db(), name)
                })
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-04 17:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 17:53</div>
            <div class="timeline-body"><p>Hmm. I find this very hard to parse. There's so much going on with nested lambdas and such.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 17:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 17:56</div>
            <div class="timeline-body"><p>that's a shame :( I find it much nicer than the <code>if</code>/<code>else</code> nesting we have on <code>main</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:87 on 2025-02-04 18:13</div>
            <div class="timeline-body"><blockquote>
<p>How important is that we change this now</p>
</blockquote>
<p>it's not crucial, but:</p>
<ol>
<li>I do think we're doing some things eagerly at the moment where we don't have to</li>
<li>I'm <em>slightly</em> worried this unnecessary eagerness will matter more if I start doing TODOs like this, since I think instance attributes are more expensive to lookup than class attributes https://github.com/astral-sh/ruff/blob/64e64d26812601b840953a186d8e4d66da17594b/crates/red_knot_python_semantic/src/types.rs#L272-L274</li>
<li>I do find the nested <code>if</code>-conditions and early returns on <code>main</code> quite hard to follow in places like <code>types::infer::TypeInferenceBuidler::lookup_name()</code>, which this PR rewrites</li>
<li>I'm pretty interested in seeing if we could use builders like this in other places too: for example, falling back to different code paths depending on whether a dunder method is defined, possibly defined, or undefined. (I consider this PR linked to my <code>Outcome</code> refactor work; it's touching on similar themes.)</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 18:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-04 18:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 18:20</div>
            <div class="timeline-body"><p>I do like that it reads like a sentence but it also reads like a very long German sentence with three subsentences without any punctuation. The comments act as some sort of punctuation, but it is still very unclear where one filtering begins or ends and on what type these operations operate.</p>
<p>I also think that your current approach of returning some other struct that then exposes more methods is probably the right direction, similar to the <code>HashMap::entry</code> API. Maybe the returned value should be an enum? But I don't know how such an API would look specifically. It also reminds me of my <a href="https://github.com/biomejs/biome/blob/b35c9ed4910a1fca9eac2ac1dbed5b5067725efc/crates/biome_parser/src/parsed_syntax.rs#L169"><code>ParsedSyntax</code></a> API in Rome's parser.</p>
<p>Thanks for explaining your motivation below. Exploring it if it's related to your <code>Outcome</code> work is reasonable. I only want to avoid that we're persuing this just to make things &quot;nicer&quot; because it's currently rarely used and the eagerness isn't a problem today (as the neutral benchmarks show)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 18:23</div>
            <div class="timeline-body"><blockquote>
<p>I do like that it reads like a sentence but it also reads like a very long German sentence with three subsentences without any punctuation. The comments act as some sort of punctuation, but it is still very unclear where one filtering begins or ends and on what type these operations operate.</p>
</blockquote>
<p>Hmm, that sounds like an argument for my earlier approach in https://github.com/astral-sh/ruff/pull/15931 -- which feels less readable to me, and has deeper indentation but has the advantage that it's clearer where one filtering begins and ends</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-04 18:58</div>
            <div class="timeline-body"><p>What would you think about something like this?</p>
<pre><code class="language-rs">            Symbol::Unbound
                // No nonlocal binding? Check the module's globals.
                // Avoid infinite recursion if `self.scope` already is the module's global scope.
                .with_possible_fallback(
                    db,
                    SymbolFallback {
                        fallback_if: || !file_scope_id.is_global(),
                        fallback_to: || global_symbol(db, self.file(), name),
                    },
                )
                // Not found in globals? Fallback to builtins
                // (without infinite recursion if we're already in builtins.)
                .with_possible_fallback(SymbolFallback {
                    fallback_if: || Some(self.scope()) != builtins_module_scope(db),
                    fallback_to: || builtins_symbol(db, name),
                })
                // Still not found? It might be `reveal_type`...
                .with_possible_fallback(SymbolFallback {
                    fallback_if: || name == &quot;reveal_type&quot;,
                    fallback_to: || {
                        self.context.report_lint(
                            &amp;UNDEFINED_REVEAL,
                            name_node.into(),
                            format_args!(
                                &quot;`reveal_type` used without importing it; \
                            this is allowed for debugging convenience but will fail at runtime&quot;
                            ),
                        );
                        typing_extensions_symbol(db, name)
                    },
                })
                .build()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 18:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-05 07:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-05 07:18</div>
            <div class="timeline-body"><p>I think we don't need the <code>fallback_if</code>, or at least, we can use the normal <code>if</code> expression to accomplish it, the same as for <code>or_else</code> by returning the lower bound value (<code>Err</code>/<code>None</code>/<code>Unbound</code>):</p>
<pre><code class="language-rust">Symbol::Unbound
	.or_else(|| {
		if file_scope_id.is_global() {
			Symbol::Unbound
		} else {
			global_symbol(db, self.file(), name)
		}
	})
	.or_else(|| {
		if builtins_module_scope(db) == Some(self.scope()) {
			Symbol::Unbound
		} else {
			builtins_symbol(db, name)
		}
	})
	.or_else(|| {
		if name == &quot;reveal_type&quot; {
			...
		} else  {
			Symbol::Unbound
		}
	})
</code></pre>
<p>I do prefer this because it removes the amount of lambdas and it also simplifies the case where there's no condition to just <code>Symbol::or_else(|| global_symbol(db, self.file(), name)</code>.</p>
<p>However, I'm not sure if I'm happy with the name <code>or_else</code> because the operation doesn't to <code>a</code> or <code>b</code>, it does <code>a</code> or <code>b</code> and sometimes merge <code>a</code> and <code>b</code>...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-05 13:13</div>
            <div class="timeline-body"><blockquote>
<p>I do prefer this because it removes the amount of lambdas</p>
</blockquote>
<p>I considered this (in fact, it was the version I initially prototyped before filing any PRs), but decided against it. It feels very annoyingly repetitive that every time we use this method we have to have an <code>if</code>/<code>else</code> branch inside it. And the whole purpose of this PR is to move away from an imperative API and towards a declarative API where I can easily see from the code that Python's semantics are being implemented correctly without having to wade throught the visual noise of <code>if</code>/<code>else</code> everywhere.</p>
<p>I also don't much like that we have to explicitly encode that the fallback should be <code>Symbol::Unbound</code> every time we use the method. As well as being repetitive, this will make it harder to change the internal representation of <code>Symbol</code> in the future (e.g., if we had something more similar to a <code>Result</code>, where a fully bound type is <code>Ok()</code> but partially-bound and unbound are both <code>Err()</code> subvariants -- this is something I'm prototyping for my <code>Outcome</code> refactor). If we changed the <code>Symbol</code> representation like that, we'd have to change every use of these methods.</p>
<blockquote>
<p>it also simplifies the case where there's no condition</p>
</blockquote>
<p>we currently have no places outside of unit tests where we would use this API without a condition.</p>
<hr />
<p>Having said all of the above, however, I am okay with this as a compromise if you strongly dislike all my other suggestions. I do think it's better than the status quo on <code>main</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-05 13:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-05 13:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-05 13:20</div>
            <div class="timeline-body"><p>I would find it interesting to hear some other opinions but I do prefer this solution even if it's somewhat more verbose because it uses a pattern that's familiar even if you have never worked with <code>Symbol</code> and I find the explicit <code>if</code> and <code>Symbol::Unbound</code> easier to read than having to jump to the method declaration to understand what important details it is hidding from me.</p>
<p>The solution to hide the nested <code>if</code>s would be to add a <code>bool.then_symbol</code> method but I consider it overkill, considering how rare this code pattern even appears.</p>
<p>Overall, my preference is to move on. I feel like we're spending too much time on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-05 13:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:104 on 2025-02-05 13:23</div>
            <div class="timeline-body"><p>Alright, I'll go with your suggestion as a compromise solution then</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Add a `SymbolFallbackBuilder` to allow symbol fallbacks to be elegantly chained together" to "[red-knot] Make `Symbol::or_fall_back_to()` lazy" by @AlexWaygood on 2025-02-05 14:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-02-05 14:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-02-05 14:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-02-05 14:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-05 16:51</div>
            <div class="timeline-body"><p>Nice!!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:09:44 UTC
    </footer>
</body>
</html>
