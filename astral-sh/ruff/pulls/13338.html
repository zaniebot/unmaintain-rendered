<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add control flow for `try`/`except` blocks - astral-sh/ruff #13338</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add control flow for <code>try</code>/<code>except</code> blocks</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13338">#13338</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-09-12 09:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body">Summary
<p>This PR adds control flow for <code>try</code>/<code>except</code>/<code>else</code>/<code>finally</code> blocks to red-knot.</p>
<p>The semantics of <code>try</code>/<code>except</code> blocks are as follows:</p>
<ol>
<li>If an <code>except</code> branch is taken, this indicates that an exception in the <code>try</code> block caused that block to terminate early. This means that potentially 0 of the definitions in the <code>try</code> block were executed; or potentially all of them were; or potentially some number in between.</li>
<li>All <code>except</code> and <code>else</code> branches are mutually exclusive: if a single <code>except</code> or <code>else</code> branch is taken, it means none of the others were taken.</li>
<li>If an <code>else</code> branch was taken, it means that the <code>try</code> block was fully executed without any exceptions having occurred; we can in this branch count on all definitions in the <code>try</code> block having been executed.</li>
<li>If there is a <code>finally</code> branch, this branch is <em>always</em> executed last, before completion of the block, regardless of whether the block has any <code>except</code> or <code>else</code> branches and (if so) which one was taken.</li>
</ol>
<p>In order to model (1), two new fields are added to the <code>SemanticIndexBuilder</code>:</p>
<ul>
<li>A new boolean <code>visiting_try_block</code> flag is added, to keep track of whether we are visiting the <code>try</code> branch of a <code>try</code>/<code>except</code>/<code>else</code>/<code>finally</code> block.</li>
<li>A new <code>try_block_definition_states</code> field is added, which is a <code>Vec&lt;FlowSnapshot&gt;</code>. If the <code>visiting_try_block</code> flag is set to <code>true</code>, the <code>add_definition()</code> method pushes a snapshot to this vec after each new definition is added.</li>
</ul>
Test Plan
<p><code>cargo test</code>.</p>
<p>I believe I still may be missing some test coverage for nested <code>try</code> blocks. An early version of this PR looked like it had some subtle bugs there (where the visitor would no longer remember it was in a <code>try</code> block if it had finished visiting a <code>try</code> block inside a <code>try</code> block). But I couldn&#x27;t find a test that would fail as a result of the apparent bug (which I&#x27;ve now fixed in this PR branch, anyway).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-12 09:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-12 09:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-12 09:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-12 09:51</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>‚ÑπÔ∏è ecosystem check <strong>encountered linter errors</strong>. (no lint changes; 1 project error)</p>
<a href="https://github.com/langchain-ai/langchain">langchain-ai/langchain</a> (error)
<p>

<pre><code>Failed to clone langchain-ai/langchain: error: RPC failed; curl 56 GnuTLS recv error (-54): Error in the pull function.
error: 1179 bytes of body are still expected
fetch-pack: unexpected disconnect while reading sideband packet
fatal: early EOF
fatal: fetch-pack: invalid index-pack output
</code></pre>
</p>


Linter (preview)
<p>‚úÖ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-12 09:52</div>
            <div class="timeline-body"><p>The <code>tomllib</code> benchmark failures indicate that this would lead to too many false positives unless we also understand all of these patterns:</p>
<pre><code>def foo():
    try:
        x = 42
    except TypeError:
        return
    # x is guaranteed to be defined here

def bar():
    try:
        x = 42
    except TypeError:
        raise RuntimeError
    # x is guaranteed to be defined here

def baz():
    for i in range(5):
        try:
            x = 42
        except TypeError:
            continue
        # x is guaranteed to be defined here

def eggs():
    for i in range(5):
        try:
            x = 42
        except TypeError:
            break
        # x is guaranteed to be defined here
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4726 on 2024-09-12 18:04</div>
            <div class="timeline-body"><p>Should there be a colon after <code>NameError</code>? Is this a typo or expected? Same for other test cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-09-12 18:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-12 18:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4726 on 2024-09-12 18:10</div>
            <div class="timeline-body"><p>thanks!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4754 on 2024-09-12 18:10</div>
            <div class="timeline-body"><pre><code>            except NameError:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4778 on 2024-09-12 18:10</div>
            <div class="timeline-body"><pre><code>            except NameError:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4808 on 2024-09-12 18:11</div>
            <div class="timeline-body"><pre><code>            except NameError:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-12 18:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-12 18:13</div>
            <div class="timeline-body"><blockquote>
<p>The <code>tomllib</code> benchmark failures indicate that this would lead to too many false positives unless we also understand all of these patterns:</p>
</blockquote>
<p>I discussed this in person with @carljm -- for now, we&#x27;ll defer fixing this, since it&#x27;s a general issue that also applies to other kinds of control flow such as <code>if</code>/<code>else</code>. It&#x27;s important to fix and it comes up much more often with <code>try</code>/<code>except</code> than with <code>if</code>/<code>else</code>, but it&#x27;s orthogonal to what this PR is trying to fix, so it&#x27;s best kept out of this PR. I&#x27;ll open a followup issue for this specifically.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-12 18:16</div>
            <div class="timeline-body"><blockquote>
<p>I believe I still may be missing some test coverage for nested <code>try</code> blocks. An early version of this PR looked like it had some subtle bugs there (where the visitor would no longer remember it was in a <code>try</code> block if it had finished visiting a <code>try</code> block inside a <code>try</code> block). But I couldn&#x27;t find a test that would fail as a result of the apparent bug (which I&#x27;ve now fixed in this PR branch, anyway).</p>
</blockquote>
<p>To be more specific here: the buggy thing I was doing in an early version of the PR was this:</p>
<pre><code>--- a/crates/red_knot_python_semantic/src/semantic_index/builder.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
@@ -725,7 +725,6 @@ where
                 // states during the `try` block before visiting the `except` blocks.
                 let pre_try_block_state = self.flow_snapshot();
                 let saved_definition_states = std::mem::take(&amp;mut self.try_block_definition_states);
-                let visiting_nested_try_block = self.visiting_try_block;
 
                 // Visit the `try` block!
                 //
@@ -733,7 +732,7 @@ where
                 // in `self.try_block_definition_states` after each new definition is recorded.
                 self.visiting_try_block = true;
                 self.visit_body(body);
-                self.visiting_try_block = visiting_nested_try_block;
+                self.visiting_try_block = false;
</code></pre>
<p>I&#x27;m pretty sure that this was incorrect (I don&#x27;t think it handles nested <code>try</code> blocks properly at all?), but couldn&#x27;t find a test that actually demonstrated the bugginess.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4491 on 2024-09-12 18:25</div>
            <div class="timeline-body"><p>In principle I think these tests would be better if they asserted the inferred type of the name inside the except block, rather than at end of scope.</p>
<p>But that&#x27;s quite a major pain to do in our current test framework, so I would just leave the tests as-is for now and wait for the new test framework with <code>reveal_type</code> :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:750 on 2024-09-12 18:28</div>
            <div class="timeline-body"><p>Do we need to do any merging of the <code>try_block_definition_states</code> if there are nested try statements?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:751 on 2024-09-12 18:30</div>
            <div class="timeline-body"><p>Can we remove the clone from here? It seems to be the only reference to <code>pre_try_block_state</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:792 on 2024-09-12 18:31</div>
            <div class="timeline-body"><p>Nit. We could avoid this call for the last except handler because we restore the <code>post_try_block_state</code> on line 797 but I&#x27;m not sure if it&#x27;s worth the complexity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-09-12 18:32</div>
            <div class="timeline-body"><p>Uff, excepts are hard haha. Great work!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4798 on 2024-09-12 18:34</div>
            <div class="timeline-body"><p>I think a test that is missing here is something verifying that <em>within</em> the <code>else</code> block, names bound in the <code>try</code> block are definitely bound. (This is along the same lines as the above comment; we&#x27;re generally weak on tests demonstrating inferred types inside a particular block, rather than at end of scope.)</p>
<p>But as mentioned above, this is difficult to do with current test infra. (You can assign the name to another name, but then that other name is still potentially unbound, so the test isn&#x27;t super clear.) But it would be nice to have a TODO to add this test, once we have the new test framework.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:751 on 2024-09-12 18:36</div>
            <div class="timeline-body"><p>Great catch. I think in an early version of the PR I thought I&#x27;d be referencing this again later, but obviously I don&#x27;t now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-12 18:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-09-12 18:38</div>
            <div class="timeline-body"><p>This is fantastic!! Probably the most complex control flow we&#x27;ll need to handle, due to the &quot;control flow can depart anywhere in the middle of a block&quot; wrinkle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:762 on 2024-09-13 04:10</div>
            <div class="timeline-body"><p>I think the exception to this is if we can guarantee that the inner try block catches all exceptions. I think the only way we can be sure of this is if it has a bare except (or maybe an <code>except BaseException</code>?). In this case the outer try shouldn&#x27;t see all the possible partial states from the inner try, it should only see the states after the except or else.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:762 on 2024-09-13 04:12</div>
            <div class="timeline-body"><p>Oh, and if the inner try has a finally block, the outer one should not see any state that doesn&#x27;t include the finally block having run. So that&#x27;s another thing we aren&#x27;t quite doing right here yet.</p>
<p>Good grief this is complex!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:167 on 2024-09-13 04:14</div>
            <div class="timeline-body"><p>I think it would be slightly better if this were kept as temporary state in the scope stack in the index builder, rather than in the scope itself. I think it is only needed transiently in the builder, so we don&#x27;t need to pay the memory cost of storing it permanently in the symbol table for every scope.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-13 04:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-13 13:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:167 on 2024-09-13 13:59</div>
            <div class="timeline-body"><p>I suspected I might get this feedback üòÑ I decided to do this anyway as it seems much cleaner than the alternative. But I guess perf wins out!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-13 14:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:167 on 2024-09-13 14:35</div>
            <div class="timeline-body"><p>I pushed <a href="https://github.com/astral-sh/ruff/pull/13338">astral-sh/ruff#13338</a>/commits/c25592d095833eb1c9f1d901e08439ee9b5d6e2e</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-13 17:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:762 on 2024-09-13 17:38</div>
            <div class="timeline-body"><blockquote>
<p>or maybe an <code>except BaseException</code>?</p>
</blockquote>
<p>oh no... I don&#x27;t know how we do that without type inference capabilities in the <code>SemanticIndexBuilder</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-13 17:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:762 on 2024-09-13 17:42</div>
            <div class="timeline-body"><p>For now I&#x27;ll just handle the bare <code>except:</code> case, I think :/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-13 17:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:762 on 2024-09-13 17:45</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t know how we do that without type inference capabilities in the <code>SemanticIndexBuilder</code>?</p>
</blockquote>
<p>Let&#x27;s not worry about this wrinkle for this PR. I think handling bare except correctly is good; <code>except BaseException</code> is less common.</p>
<p>Eventually we will need to find a solution for adding conditional control flow paths that can be eliminated from consideration in type inference. It may be possible to do this as an extension of &quot;constraints&quot; using the Never type. We&#x27;ll need this also for context manager <code>__exit__</code> return type handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-13 17:48</div>
            <div class="timeline-body"><p>Noting it here for myself because I&#x27;m context-switching to something else: even not considering nested <code>try</code> blocks, the logic in this PR is currently incorrect. The logic currently assumes that at least one of the <code>except</code> and/or <code>else</code> branches must have been executed prior to the <code>finally</code> block being executed. That&#x27;s only actually true if one of the <code>except</code> branches is a catch-all branch (either a bare <code>except</code> or an <code>except BaseException</code> branch). Otherwise, we could skip straight from the <code>try</code> block to the <code>finally</code> block in something like this if e.g. <code>RuntimeError</code> is raised during the <code>try</code> block:</p>
<pre><code>try:
    x = 1
except TypeError:
    x = 2
else:
    x = 3
finally:
    pass
</code></pre>
<p>This means that the inferred type of <code>x</code> needs to be <code>Unbound | Literal[1, 2, 3]</code> after this <code>try</code>/<code>except</code> block, rather than <code>Literal[2, 3]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-13 22:03</div>
            <div class="timeline-body"><p>Re-requesting review as I had to change the approach quite radically to fix issues with nested <code>try</code>/<code>except</code> blocks and <code>finally</code> clauses!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-13 22:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-13 22:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:101 on 2024-09-13 22:27</div>
            <div class="timeline-body"><p>I don&#x27;t think callers of <code>push_scope</code> and <code>pop_scope</code> should be required to keep track of try block contexts data returned from <code>push_scope</code> and pass it back into <code>pop_scope</code>. Instead we can keep a per-scope stack of TryBlockContexts on the builder itself; <code>push_scope</code> can push onto it and <code>pop_scope</code> can pop off of it, and it can all be handled transparently to the caller.</p>
<p>(I&#x27;m pretty sure looking at this now that <code>loop_break_states</code> also has bugs with loops containing nested scopes containing loops, and needs this same scope-stack treatment! I&#x27;ll fix this in a separate PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:774 on 2024-09-13 22:34</div>
            <div class="timeline-body"><p>This comment looks a bit outdated relative to the implementation?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:873 on 2024-09-13 22:42</div>
            <div class="timeline-body"><p>It could be relevant to perf. Snapshotting and restoring flow states is sufficiently expensive (if there are lots of symbols) that it might be worth explicitly checking for empty else and finally, if that would allow us to skip any snapshots or restores/merges. And it looks like we could skip a fair amount of those, if there is no finally body and no parent try block?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:868 on 2024-09-13 22:44</div>
            <div class="timeline-body"><p>Do we also need to merge the pre-try-block state here? (We could jump straight from before completing any statement in the try block, to executing the finally block and/or into an outer try block.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:880 on 2024-09-13 22:45</div>
            <div class="timeline-body"><p>I find it slightly confusing that within the same try block visit, above we refer to an outer try block as <code>parent_try_block</code> and here we refer to the same thing as <code>current_try_block</code>. Let&#x27;s be consistent about what is &quot;current&quot; and what is &quot;parent&quot;?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1027 on 2024-09-13 22:47</div>
            <div class="timeline-body"><p>I like this change, letting us keep scope pushes and pops paired; I&#x27;d keep this, even if we no longer <em>need</em> it in order to handle the try block contexts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:242 on 2024-09-13 22:51</div>
            <div class="timeline-body"><p>We could check <code>visiting_nested_try_stmt</code> inside <code>TryBlockContext::push_snapshot</code> instead, to keep things a bit more encapsulated.</p>
<p>This would mean passing in <code>self</code> instead of <code>self.flow_snapshot()</code>, to avoid taking snapshots we won&#x27;t use, but that seems fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:782 on 2024-09-13 22:53</div>
            <div class="timeline-body"><p>This is a lot of boilerplate we repeat several times. I think maybe we can reduce it somewhat by not using a RefCell, but we can also have a <code>self.current_try_block_mut()</code> wrapper method to reduce the repetition.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1175 on 2024-09-13 22:55</div>
            <div class="timeline-body"><p>It&#x27;s not clear to me why we need to introduce a <code>RefCell</code> here. Maybe it&#x27;s related to having all the scope pushing and popping methods holding onto references unnecessarily? I think if we don&#x27;t do that, the ownership here should be pretty straightforward (owned by the builder, mutable reference to current block occasionally borrowed for very short time) and there shouldn&#x27;t be any need for <code>RefCell</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4707 on 2024-09-13 22:57</div>
            <div class="timeline-body"><p>There is no <code>except TypeError</code> branch; out of date comment? Or maybe the test should be changed back from <code>except:</code> to <code>except TypeError:</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4701 on 2024-09-13 22:58</div>
            <div class="timeline-body"><p>It seems like removing these two lines wouldn&#x27;t change the semantics of the test at all, so why include them?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4824 on 2024-09-13 23:03</div>
            <div class="timeline-body"><p>It&#x27;s possible, just a bit of a pain. But on second thought, it&#x27;s less of a pain than I&#x27;d originally thought. If you have a separate variable (let&#x27;s say <code>reveal_x</code>) just for the purpose of inspecting a value in a nested location, and initialize it up top to a value nothing else is initialized to (<code>reveal_x = 0</code>), and then at the nested location where you want to inspect <code>x</code> you do <code>reveal_x = x</code>), then if you inspect <code>reveal_x</code> at the end you&#x27;ll get a union of <code>Literal[0]</code> and the value of <code>x</code> where you wanted to inspect it. It&#x27;s not quite as clear as a <code>reveal_type</code> in the new testing framework will be, but it&#x27;s not bad. Up to you if you find that nicer than a TODO comment, if you&#x27;re editing this PR anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4888 on 2024-09-13 23:08</div>
            <div class="timeline-body"><p>I think <code>x</code> can be <code>Unbound</code> here; it&#x27;s never set in an exhaustive <code>except</code>, or in a <code>finally</code>.</p>
<p>I think this might be the issue I pointed out above, where we don&#x27;t include the pre-try-block state as a pre-finally possibility.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4916 on 2024-09-13 23:14</div>
            <div class="timeline-body"><p>I don&#x27;t see how <code>x</code> could actually be unbound in this scenario, but I&#x27;m also not sure if it&#x27;s worth fixing. We assume that we could exit the outer try with an exception before executing the inner try at all, but that&#x27;s not actually true in this example; nothing happens in the outer try before we enter the inner try, so in actual fact we are guaranteed to either complete the assignment <code>x = 1</code> in the inner try, or have an exception caught by the exhaustive inner handler, which also binds <code>x</code>.</p>
<p>I think we would handle this correctly if, instead of saving a pre-try state, and then pushing a state post each definition, we instead pushed a state pre each definition, and then saved a post-try state.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4969 on 2024-09-13 23:18</div>
            <div class="timeline-body"><p>&quot;otherwise-exhausive except/else branches in the inner block&quot; doesn&#x27;t seem right -- those aren&#x27;t exhaustive</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4970 on 2024-09-13 23:20</div>
            <div class="timeline-body"><p>How is this assertion different from if the outer <code>try/except</code> weren&#x27;t there?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:5001 on 2024-09-13 23:22</div>
            <div class="timeline-body"><p>How is this assertion different from if the outer <code>try/except</code> weren&#x27;t there?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-13 23:23</div>
            <div class="timeline-body"><p>Awesome work tracking down all these different test cases and sorting out how to make them all pass!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-13 23:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:101 on 2024-09-13 23:43</div>
            <div class="timeline-body"><p>I looked into <code>loop_break_states</code>, and I think it&#x27;s actually fine; since every nested loop resets it, and (unlike try/except) there&#x27;s no interaction with the parent loop state, there&#x27;s no potential for scope-confusion bugs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 16:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1027 on 2024-09-14 16:52</div>
            <div class="timeline-body"><p>I think maybe I&#x27;ll separate this out into a separate PR, as I agree that it&#x27;s a desirable change anyway, and it&#x27;ll help reduce the diff of this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 16:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:782 on 2024-09-14 16:55</div>
            <div class="timeline-body"><p>I agree that this is somewhat boilerplate-y. The version without the <code>RefCell</code> was unfortunately even more boilerplate-y, as it&#x27;s hard to call a method on <code>TryBlockContexts</code> that takes <code>&amp;mut self</code> in the same scope as a <code>self.flow_snapshot()</code> call, or the borrow checker complains that you have a mutable borrow and an immutable borrow in the same scope which is unsafe. Your suggestion in <a href="https://github.com/astral-sh/ruff/pull/13338">astral-sh/ruff#13338</a>#discussion_r1759593449 might fix this, however; I&#x27;ll take a look.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 16:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4707 on 2024-09-14 16:55</div>
            <div class="timeline-body"><p>out-of-date comment, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 16:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:101 on 2024-09-14 16:58</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t think callers of <code>push_scope</code> and <code>pop_scope</code> should be required to keep track of try block contexts data returned from <code>push_scope</code> and pass it back into <code>pop_scope</code>. Instead we can keep a per-scope stack of TryBlockContexts on the builder itself; <code>push_scope</code> can push onto it and <code>pop_scope</code> can pop off of it, and it can all be handled transparently to the caller.</p>
</blockquote>
<p>I&#x27;m okay with doing that, but how would that be different (in terms of memory usage) to keeping the <code>TryBlockContexts</code> state as a field on the <code>Scope</code> instances? I switched to this approach because of the concerns you stated in <a href="https://github.com/astral-sh/ruff/pull/13338">astral-sh/ruff#13338</a>#discussion_r1758151643</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-14 17:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:101 on 2024-09-14 17:04</div>
            <div class="timeline-body"><p>It&#x27;s different because Scope is permanent; it&#x27;s stored in the SemanticIndex and used in type inference. We should only put data in it that is needed by type inference.</p>
<p>Storing state on the SemanticIndexBuilder is ephemeral, only kept while we are building the semantic index for a given module, and then dropped when that&#x27;s done.</p>
<p>Keeping the state on the builder as I&#x27;ve suggested here is in fact equivalent in memory usage to what we&#x27;re doing right now in this PR; either way the same number of TryBlockContexts are alive at any given time. The only difference is whether their ownership is held on the stack (the current approach in this PR) or as part of the builder.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 17:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:101 on 2024-09-14 17:04</div>
            <div class="timeline-body"><p>Ahh, thanks, that makes a lot of sense!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 17:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1027 on 2024-09-14 17:22</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/pull/13353</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-14 18:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1175 on 2024-09-14 18:05</div>
            <div class="timeline-body"><p>So if I try applying this diff:</p>


<pre><code>--- a/crates/red_knot_python_semantic/src/semantic_index/builder.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
@@ -96,7 +96,7 @@ impl&lt;&#x27;db&gt; SemanticIndexBuilder&lt;&#x27;db&gt; {
             .expect(&quot;Always to have a root scope&quot;)
     }
 
-    fn try_block_contexts(&amp;self) -&gt; &amp;TryBlockContexts {
+    fn try_block_contexts(&amp;mut self) -&gt; &amp;mut TryBlockContexts {
         self.try_block_contexts_stack.current_try_block_context()
     }
 
@@ -232,8 +232,7 @@ impl&lt;&#x27;db&gt; SemanticIndexBuilder&lt;&#x27;db&gt; {
             DefinitionCategory::Binding =&gt; use_def.record_binding(symbol, definition),
         }
 
-        if let Some(current_try_block) = self.try_block_contexts().borrow_mut().current_try_block()
-        {
+        if let Some(current_try_block) = self.try_block_contexts().current_try_block() {
             current_try_block.record_definition(self);
         }
 
@@ -780,9 +779,7 @@ where
                     .try_block_contexts()
                     .pop_try_block()
                     .expect(&quot;A `try` block should have been pushed to the stack prior to visiting the `body` field&quot;);
-                if let Some(parent_try_block) =
-                    self.try_block_contexts().borrow_mut().current_try_block()
-                {
+                if let Some(parent_try_block) = self.try_block_contexts().current_try_block() {
                     parent_try_block.record_visiting_nested_try_stmt();
                 }
                 self.flow_restore(pre_try_block_state);
@@ -877,9 +874,7 @@ where
                 // Account for the fact that we could be visiting a nested `try` block,
                 // in which case the outer `try` block must be kept informed about all the possible
                 // between-definition states we could have encountered in the inner `try` block(!)
-                if let Some(current_try_block) =
-                    self.try_block_contexts().borrow_mut().current_try_block()
-                {
+                if let Some(current_try_block) = self.try_block_contexts().current_try_block() {
                     current_try_block.record_exiting_nested_try_stmt();
                     current_try_block.record_definition(self);
                 }
diff --git a/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs b/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs
index de1918f71..b89bd4c52 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs
@@ -1,5 +1,3 @@
-use std::cell::{RefCell, RefMut};
-
 use super::SemanticIndexBuilder;
 use super::use_def::FlowSnapshot;
 
@@ -11,9 +9,9 @@ impl TryBlockContextsStack {
         self.0.push(TryBlockContexts::default());
     }
 
-    pub(super) fn current_try_block_context(&amp;self) -&gt; &amp;TryBlockContexts {
+    pub(super) fn current_try_block_context(&amp;mut self) -&gt; &amp;mut TryBlockContexts {
         self.0
-            .last()
+            .last_mut()
             .expect(&quot;There should always be at least one `TryBlockContexts` on the stack&quot;)
     }
 
@@ -52,28 +50,19 @@ impl TryBlockContext {
     }
 }
 
-#[derive(Debug)]
-pub(super) struct TryBlockContextsRefMut&lt;&#x27;a&gt;(RefMut&lt;&#x27;a, Vec&lt;TryBlockContext&gt;&gt;);
-
-impl&lt;&#x27;a&gt; TryBlockContextsRefMut&lt;&#x27;a&gt; {
-    pub(super) fn current_try_block(&amp;mut self) -&gt; Option&lt;&amp;mut TryBlockContext&gt; {
-        self.0.last_mut()
-    }
-}
-
 #[derive(Debug, Default)]
-pub(super) struct TryBlockContexts(RefCell&lt;Vec&lt;TryBlockContext&gt;&gt;);
+pub(super) struct TryBlockContexts(Vec&lt;TryBlockContext&gt;);
 
 impl TryBlockContexts {
-    pub(super) fn push_try_block(&amp;self) {
-        self.0.borrow_mut().push(TryBlockContext::default());
+    pub(super) fn push_try_block(&amp;mut self) {
+        self.0.push(TryBlockContext::default());
     }
 
-    pub(super) fn pop_try_block(&amp;self) -&gt; Option&lt;TryBlockContext&gt; {
-        self.0.borrow_mut().pop()
+    pub(super) fn pop_try_block(&amp;mut self) -&gt; Option&lt;TryBlockContext&gt; {
+        self.0.pop()
     }
 
-    pub(super) fn borrow_mut(&amp;self) -&gt; TryBlockContextsRefMut {
-        TryBlockContextsRefMut(self.0.borrow_mut())
+    pub(super) fn current_try_block(&amp;mut self) -&gt; Option&lt;&amp;mut TryBlockContext&gt; {
+        self.0.last_mut()
     }
 }
</code></pre>


<p>Then the borrow check complains thusly:</p>
<pre><code>error[E0502]: cannot borrow `*self` as immutable because it is also borrowed as mutable
   --&gt; crates/red_knot_python_semantic/src/semantic_index/builder.rs:236:49
    |
235 |         if let Some(current_try_block) = self.try_block_contexts().current_try_block() {
    |                                          ---- mutable borrow occurs here
236 |             current_try_block.record_definition(self);
    |                               ----------------- ^^^^ immutable borrow occurs here
    |                               |
    |                               mutable borrow later used by call

error[E0502]: cannot borrow `*self` as immutable because it is also borrowed as mutable
   --&gt; crates/red_knot_python_semantic/src/semantic_index/builder.rs:879:57
    |
877 |                 if let Some(current_try_block) = self.try_block_contexts().current_try_block() {
    |                                                  ---- mutable borrow occurs here
878 |                     current_try_block.record_exiting_nested_try_stmt();
879 |                     current_try_block.record_definition(self);
    |                                       ----------------- ^^^^ immutable borrow occurs here
    |                                       |
    |                                       mutable borrow later used by call
</code></pre>
<p>LMK if you can see a way of getting round this without the <code>RefCell</code>... I agree it&#x27;s less than ideal, for sure!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_benchmark/benches/red_knot.rs</code>:57 on 2024-09-16 13:08</div>
            <div class="timeline-body"><p>I recommend moving this comment next to the relevant errors. It increases the likelihood that the comment gets deleted when the errors are resolved (I would miss the comment up there)</p>
<pre><code>static EXPECTED_DIAGNOSTICS: &amp;[&amp;str] = &amp;[
    &quot;/src/tomllib/_parser.py:5:24: Module &#x27;__future__&#x27; has no member &#x27;annotations&#x27;&quot;,
		
		// The failed import from &#x27;collections.abc&#x27; is due to lack of support for &#x27;import *&#x27;.
    &quot;/src/tomllib/_parser.py:7:29: Module &#x27;collections.abc&#x27; has no member &#x27;Iterable&#x27;&quot;,
    
    &quot;Line 69 is too long (89 characters)&quot;,
    &quot;Use double quotes for strings&quot;,
    &quot;Use double quotes for strings&quot;,
    &quot;Use double quotes for strings&quot;,
    &quot;Use double quotes for strings&quot;,
    &quot;Use double quotes for strings&quot;,
    &quot;Use double quotes for strings&quot;,
    &quot;Use double quotes for strings&quot;,

				// The &quot;possibly not defined&quot; errors in `tomllib/_parser.py` are because
		// we don&#x27;t yet understand terminal statements (`return`/`raise`/etc.) in our control-flow analysis
    &quot;/src/tomllib/_parser.py:66:18: Name &#x27;s&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:98:12: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:101:12: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:104:14: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:104:14: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:115:14: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:115:14: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:126:12: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:348:20: Name &#x27;nest&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:353:5: Name &#x27;nest&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:453:24: Name &#x27;nest&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:455:9: Name &#x27;nest&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:482:16: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:566:12: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:573:12: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:579:12: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:580:63: Name &#x27;char&#x27; used when possibly not defined.&quot;,
    &quot;/src/tomllib/_parser.py:629:38: Name &#x27;datetime_obj&#x27; used when possibly not defined.&quot;,
];
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs</code>:1 on 2024-09-16 13:10</div>
            <div class="timeline-body"><p>I would make this a sub module of <code>builder</code> if it is only used in <code>builder.rs</code>. It allows to keep the structs scoped to <code>builder</code> (and not the entire <code>semantic_index</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs</code>:22 on 2024-09-16 13:11</div>
            <div class="timeline-body"><p>Nit. We should assert that the popped value is never <code>None</code> because that would indicate an unbalanced <code>push</code>/<code>pop</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs</code>:45 on 2024-09-16 13:12</div>
            <div class="timeline-body"><p>Nit: These methods arent&#x27; realy recording anything. Rename to <code>enter_nested_try_block</code> and <code>exit_nested_try_block</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:769 on 2024-09-16 13:18</div>
            <div class="timeline-body"><p>What&#x27;s the reason that we need to &quot;emulate&quot; a stack here instead of making use of the function&#x27;s stack to allocate the try blocks?</p>
<p>I looked at <code>TryBlockContextsStack</code> and I didn&#x27;t spot anything that obviously requires a <code>Vec</code> (e.g. because we would need to inspect the entire stack.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 13:22</div>
            <div class="timeline-body"><p>The method name here seems misleading to me because it is called <strong>after</strong> we visit the <code>try</code> body. It seems it&#x27;s about visiting the except handlers, finaly , and or else blocks of a <code>try</code>.</p>
<p>Related: What&#x27;s the reason that we don&#x27;t record definitions in a nested try? E.g. what if</p>
<pre><code>try:
    try:
        x =  10:
        maybe_panic()
    finally:
        y = panic()
finally:
    y
</code></pre>
<p>shouldn&#x27;t the use of <code>y</code> be an error?</p>
<p>but</p>
<pre><code>try:
    try:
        x =  10:
        maybe_panic()
    finally:
        y = 10
finally:
    y
</code></pre>
<p>should be okay?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:881 on 2024-09-16 13:26</div>
            <div class="timeline-body"><p>Can&#x27;t we call <code>self.try_block_contexts_mut()</code> here to avoid the <code>RefCell</code> in the contexts (and all the <code>borrow_mut</code> stuff)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-16 13:27</div>
            <div class="timeline-body"><p>To me it&#x27;s unclear why we need the extra except handler stack vs just using the function stack (all you need is the current context and the parent&#x27;s). Keeping an extra <code>Vec</code> around isn&#x27;t expensive but I think it&#x27;s slightly more complicated than just making use of the stack.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-09-16 13:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs</code>:33 on 2024-09-16 14:36</div>
            <div class="timeline-body"><p>If I remove this check in the current version of this PR, all tests pass. So either we don&#x27;t need this, or we need more tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 14:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 14:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 14:42</div>
            <div class="timeline-body"><p>I commented elsewhere that it seems we currently don&#x27;t have any tests that fail if we stop paying attention to <code>visiting_nested_try_stmt</code> entirely.</p>
<p>And it seems to me that Micha is right here -- outside the inner <code>try</code> block body itself, it does seem like intermediate states in the except/else/finally <em>should</em> all get registered with the outer try block, because we could have an exception happen in any of those places. (And such an exception would not cause us to still enter an inner <code>finally</code> block, which only applies to the inner <code>try</code> body; it would jump straight to being handled by the outer <code>try</code> block.) So it does seem to me like <code>visiting_nested_try_stmt</code> might be inherently semantically not right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 14:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:769 on 2024-09-16 14:44</div>
            <div class="timeline-body"><p>I didn&#x27;t understand this suggestion (or the similar one in the top-level comment) so I checked in with Micha off-line; it sounds like this suggestion was based on a misunderstanding of what this PR does (and needs to do), in terms of tracking stack of try-blocks per scope (i.e. it currently uses a nested vec of vecs). This comment is effectively suggesting to go back to the previous <code>std::mem::replace</code> approach, which isn&#x27;t sufficient because it doesn&#x27;t clear the try blocks on scope-push and restore them on scope-pop.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 14:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1175 on 2024-09-16 14:48</div>
            <div class="timeline-body"><p>I&#x27;m fairly confident that there is a way to avoid the need for RefCell, and I also am interested in considering simpler representations than the current vec-of-vecs approach (e.g. can we use just a flat stack of try blocks, but via an enum that also has a no-try-block variant, so when we push scope we just push a no-try-block entry on the flat stack, and when we pop scope we pop it off?).</p>
<p>But I think this PR is complex enough that we should first make sure we have all the semantics and tests right, and <em>then</em> worry about fine-tuning implementation strategy. So I suggest ignoring all implementation comments for now and focusing only on semantic comments until we are confident in the semantics and tests.</p>
<p>(For example, the approach for removing the need for RefCell will look different depending on whether we do or don&#x27;t need <code>visiting_nested_try_stmt</code>, which seems in question to me at the moment.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-16 14:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs</code>:33 on 2024-09-16 14:54</div>
            <div class="timeline-body"><p>A test fails if you make this change:</p>
<pre><code>diff --git a/crates/red_knot_python_semantic/src/semantic_index/builder.rs b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
index c7e8a6428..74cbd6b2d 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/builder.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
@@ -873,16 +873,6 @@ where
                 }
 
                 self.visit_body(finalbody);
-
-                // Account for the fact that we could be visiting a nested `try` block,
-                // in which case the outer `try` block must be kept informed about all the possible
-                // between-definition states we could have encountered in the inner `try` block(!)
-                if let Some(current_try_block) =
-                    self.try_block_contexts().borrow_mut().current_try_block()
-                {
-                    current_try_block.record_exiting_nested_try_stmt();
-                    current_try_block.record_definition(self);
-                }
             }
             _ =&gt; {
                 walk_stmt(self, stmt);
diff --git a/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs b/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs
index 2eded0089..ce4e76ca0 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/except_handlers.rs
@@ -30,9 +30,7 @@ pub(super) struct TryBlockContext {
 
 impl TryBlockContext {
     pub(super) fn record_definition(&amp;mut self, builder: &amp;SemanticIndexBuilder) {
-        if !self.visiting_nested_try_stmt {
-            self.snapshots.push(builder.flow_snapshot());
-        }
+        self.snapshots.push(builder.flow_snapshot());
     }
</code></pre>
<p>The <code>if !self.visiting_nested_try_stmt</code> check isn&#x27;t necessary for correctness. But it&#x27;s unnecessary to push all those snapshots to be recorded by the outer <code>TryBlockContexts</code>, since it&#x27;s more efficient -- and more correct -- to simply record the state once at the completion of the inner <code>try/except/else/finally</code> block. I.e., the <code>if !self.visiting_nested_try_stmt</code> check is simply an optimisation to avoid unnecessary snapshotting.</p>
<p>I see that at the moment this is quite unclear; I&#x27;ll add some more comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 15:15</div>
            <div class="timeline-body"><p>(Cases to consider for tests here are e.g. <code>x = 1; x = 2</code> inside an <code>except</code>, <code>else</code>, or <code>finally</code> block in a nested try statement -- the <code>x = 1</code> possibility should be visible to the outer try block.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-16 15:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 15:18</div>
            <div class="timeline-body"><blockquote>
<p>(And such an exception would not cause us to still enter an inner <code>finally</code> block, which only applies to the inner <code>try</code> body; it would jump straight to being handled by the outer <code>try</code> block.)</p>
</blockquote>
<p>What do you mean? The inner <code>finally</code> block is indeed always executed, even if the exception is caught by the outer <code>try</code> block:</p>
<pre><code>&gt;&gt;&gt; try:
...     try:
...         raise TypeError()
...     except NameError:
...         print(1)
...     finally:
...         print(2)
... except TypeError:
...     print(3)
... finally:
...     print(4)
... 
2
3
4
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 15:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 15:22</div>
            <div class="timeline-body"><p>What I mean is that if an exception is raised inside an except/else/finally block in the nested try (not inside the try body), in <em>that</em> case the inner finally is not executed, the exception unwinds directly to the outer try statement handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 15:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 15:24</div>
            <div class="timeline-body"><p>... except this is just wrong üòÜ apparently <code>finally</code> does still apply, even if the except is raised in an except handler or else block! So never mind.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-16 15:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 15:25</div>
            <div class="timeline-body"><p>I guess the one thing to consider still is the case where an exception is raised within the <code>finally</code> block itself? I.e. is it important that we register those intermediate states within the nested <code>finally</code> block with the outer try statement?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:786 on 2024-09-16 15:25</div>
            <div class="timeline-body"><p>I still can&#x27;t find any cases where the inner <code>finally</code> is not executed, though it is of course true that if an exception is raised in an <code>except</code> handler then we might switch to the inner <code>finally</code> block before the except handler has finished, and indeed if an exception is raised in the inner <code>finally</code> block then that <code>finally</code> block might not run to completion. I might not handle <em>that</em> properly right now...</p>
<pre><code>&gt;&gt;&gt; try:
...     try:
...         raise TypeError
...     except TypeError:
...         raise RuntimeError
...         print(1)
...     finally:
...         print(2)
... except RuntimeError:
...     print(3)
... finally:
...     print(4)
... 
2
3
4
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-16 15:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4824 on 2024-10-02 20:37</div>
            <div class="timeline-body"><p>We now have <code>reveal_type</code>, so this is more easily doable, even though we don&#x27;t have the full new testing framework yet</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-02 20:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-02 20:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4916 on 2024-10-02 20:38</div>
            <div class="timeline-body"><p>I think this comment is wrong; given that we don&#x27;t currently try to distinguish non-raising statements, we have to assume that <code>x = 2</code> in the inner exhaustive <code>except</code> could also raise, so it is correct for <code>x</code> to be possibly unbound.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-04 18:19</div>
            <div class="timeline-body"><p>Closing in favour of #13633</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-04 18:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-04 18:19</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:06:45 UTC
    </footer>
</body>
</html>
