<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Narrowing for class patterns in match statements - astral-sh/ruff #15223</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Narrowing for class patterns in match statements</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15223">#15223</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-01-02 16:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-02 16:15</div>
            <div class="timeline-body"><p>We now support class patterns in a match statement, adding a narrowing constraint that within the body of that match arm, we can assume that the subject is an instance of that class.</p>
<p>#14740</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-01-03 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 15:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/match.md</code>:24 on 2025-01-03 15:53</div>
            <div class="timeline-body"><p>Oh cool. I totally missed that we can do this now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1128 on 2025-01-03 21:52</div>
            <div class="timeline-body"><p>h/t to @sharkdp for noticing that we were performing these steps out of order.  The correct order is:</p>
<ol>
<li>visit the pattern first</li>
<li>add the pattern constraint</li>
<li>visit the guard expression and body</li>
</ol>
<p>That is, each pattern's constraint applies to the guard and body of that match case, but not to the pattern itself.</p>
<p>Also note that this is different than what David first suggested, which was that the pattern constraint should not apply to the guard either.  I think that it <em>should</em> apply to the guard, giving my reading of this part of <a href="https://docs.python.org/3/reference/compound_stmts.html#overview">the spec</a>:</p>
<blockquote>
<p>If the pattern succeeds, the corresponding guard (if present) is evaluated. In this case all name bindings are guaranteed to have happened.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1551 on 2025-01-03 21:54</div>
            <div class="timeline-body"><p>This isn't used anywhere else, so I updated the call site to only call it once and then inlined it.  That way I didn't need to add a field to pass the constraint ID back up to where we're iterating through all of the cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dcreager on 2025-01-03 21:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-01-03 21:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dcreager on 2025-01-03 21:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-01-03 21:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-03 21:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-04 08:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1128 on 2025-01-04 08:42</div>
            <div class="timeline-body"><blockquote>
<p>Also note that this is different than what David first suggested, which was that the pattern constraint should not apply to the guard either. I think that it should apply to the guard</p>
</blockquote>
<p>Ah, yes. Of course.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-06 18:38</div>
            <div class="timeline-body"><p>Given the failing tests and the &quot;WIP, not working yet&quot; PR description, moving this to draft state for now? Let me know if you would like a review in the current state.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @carljm on 2025-01-06 18:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-06 19:35</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1788 on 2025-01-06 19:40</div>
            <div class="timeline-body"><p>This separation between <code>infer_match_pattern</code> and <code>infer_match_pattern_impl</code> has to do with how we handle nested subpatterns in the semantic index builder.  (I've changed the name of the latter to <code>infer_nested_match_pattern</code> to better describe this.)</p>
<p>We currently only call <code>add_pattern_constraint</code> for top-level patterns, and do not recurse into subpatterns.  That means, in particular, that we don't create a standalone expression for the value part of a value pattern nor for the class identifier in a class pattern.  That means we need to know here whether we are looking at a top-level pattern (in which case we would call <code>infer_standalone_expression</code>) or a nested subpattern (in which case we would call <code>infer_expression</code>).</p>
<p>I've kept that separation, since it results in a smaller diff for this PR.  But it seems brittle to have standalone expressions only for some value/class patterns, but not others.  So I've added this TODO comment to consider updating the semantic index builder to <em>always</em> create standalone expressions.  (And 252290e2ae60716772bc3cda49b137dbc8a34361 actually implements that, should we want to do that now.)</p>
<p>@sharkdp, do have strong opinions about the two choices?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-06 19:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dcreager on 2025-01-06 19:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/match.md</code>:37 on 2025-01-06 20:46</div>
            <div class="timeline-body"><p>I don't think we need to do it in this PR (I didn't mention it in the issue; in fact I ignored it in my specification of the test case), but since cases are checked in order and only one can match, we can also constrain each case using the negation of all prior constraints. (Note that this doesn't apply if there's also an <code>if</code> guard, since the <code>if</code> guard can mean that the case doesn't match even if the pattern would have.)</p>
<pre><code class="language-suggestion">        # TODO could be `B &amp; ~A`
        reveal_type(x)  # revealed: B
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1788 on 2025-01-06 21:09</div>
            <div class="timeline-body"><p>I think the standalone-expressions system is brittle in general, not only in this this case. It requires hard-coded agreement between the semantic index builder and type inference about which expressions (in which syntactic positions) are standalone and which are not. This is just a particular case of that general problem. (In fact the brittleness problem is even more general than that; we also require hardcoded agreement between semantic-index builder and inference about e.g. what AST nodes we will/won't create a Definition for.)</p>
<p>The reason it works this way is because we want to minimize our overall number of Salsa ingredients, because they are associated with memory and performance overhead. But if we need to query the type of an expression as its own Salsa query (because it is either part of a definition or part of a constraint on a definition, which are things we need to query independently from the rest of the surrounding scope), then we need a Salsa ingredient for it. So we record it as a standalone expression.</p>
<p>In https://github.com/astral-sh/ruff/commit/252290e2ae60716772bc3cda49b137dbc8a34361 we would actually create both an <code>Expression</code> ingredient and a <code>Constraint</code> ingredient for every sub-pattern. I agree that this is less brittle and simpler to handle in inference. But it's also wasteful; we don't need those Salsa ingredients, because we will never need to query them separately from the top-level pattern. The logical conclusion of this approach would be to create an <code>Expression</code> for every expression, period. Which would indeed be simpler and less brittle (and is basically what I wanted to do in our bespoke inference-caching before we decided to adopt Salsa), but also prohibitively expensive.</p>
<p>(Creating a <code>Constraint</code> for each nested pattern is semantically odd as well, because nested patterns cannot function as an independent constraint on the type of any symbol, they are just potentially additional information -- e.g. information about the possible types of attributes -- within the context of the constraint applied by the top-level pattern.)</p>
<p>It's certainly possible that we could accept some inefficiency here for the sake of simpler code; we make that trade-off all the time. But I'm not convinced that it's warranted here; the current code is not that complex, and I think we arguably create more confusion by creating unused nested <code>Constraint</code> ingredients that aren't semantically sensible as standalone constraints.</p>
<p>So I would suggest to replace this <code>TODO</code> comment with something that explains why the distinction exists.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:429 on 2025-01-06 21:18</div>
            <div class="timeline-body"><p>Hmm, interesting. So normally the idea would be that when inferring types for a standalone-expression inference scope, we would only infer types for sub-expressions of the standalone expression. This is to ensure that we have a clear &quot;owning inference scope&quot; for every expression, and don't end up inferring some expressions multiple times, as part of different inference scopes.</p>
<p>But of course the inference code doesn't really care about what is actually nested inside what in the AST, as long as we do know which expressions belong to which inference scope, and only infer them there. So I don't think there is a problem with making <code>pattern.cls</code> be the standalone expression, as long as we know that <code>pattern.arguments</code> is &quot;part of&quot; the same inference scope.</p>
<p>The natural thing to do would be to have <code>pattern</code> itself be the standalone expression, since it is the parent of both <code>cls</code> and <code>arguments</code>. But since <code>pattern</code> is not an <code>ast::Expr</code>, we can't do that; at least not without reworking the <code>Expression</code> ingredient to be able to wrap nodes that are not actually expressions, which would be both invasive and semantically odd.</p>
<p>So I think what you've done here is the best option. But it may be worth an explicit comment over on the type inference side, that we consider <code>pattern.arguments</code> to be part of the inference scope of the standalone expression <code>pattern.cls</code>, even though they aren't actually nested in the AST. (Or an alternate phrasing would be that we use <code>pattern.cls</code> as a stand-in for the overall <code>pattern</code>, since its an expression.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/visibility_constraints.rs</code>:333 on 2025-01-06 21:29</div>
            <div class="timeline-body"><p>We could sometimes infer a static truthiness here (and also for <code>Singleton</code> for that matter), but for now we can consider that a possible future feature, to be driven by actual demand. We don't need to add it as a TODO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-06 21:29</div>
            <div class="timeline-body"><p>This is great, thank you! Sorry for the novel-length comments; I hope they are useful in clarifying some things.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1788 on 2025-01-06 22:08</div>
            <div class="timeline-body"><p>Thank you for the explanation!  That's very helpful — I was able to figure out the &quot;what&quot;, but the &quot;why&quot; is useful context.</p>
<blockquote>
<p>Creating a <code>Constraint</code> for each nested pattern is semantically odd as well</p>
</blockquote>
<p>Yes, definitely — I had also considered adding a different method that would have recursed into the subpatterns, creating the standalone expression but not the <code>Constraint</code>.  But that would have just moved the complexity from the inference side to the builder.</p>
<blockquote>
<p>So I would suggest to replace this <code>TODO</code> comment with something that explains why the distinction exists.</p>
</blockquote>
<p>Done — please lmk if I got any of the details wrong</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:429 on 2025-01-06 22:08</div>
            <div class="timeline-body"><p>I've taken this into account in the new comment over in <code>infer_match_pattern</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:418 on 2025-01-06 22:09</div>
            <div class="timeline-body"><p>Does your comment below about inference scopes suggest that the guard of a pattern doesn't need to be wrapped in its own standalone expression?  And instead that we can consider it part of the inference scope of the standalone expression that we create for the pattern?  (That might require being exhaustive in creating a standalone expression for all pattern variants, even the ones we don't yet support for inference/narrowing?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/match.md</code>:37 on 2025-01-06 22:11</div>
            <div class="timeline-body"><p>Ah yes!  @sharkdp already did that with the visibility constraints, but that's a good call-out that we can do that for the inferred types as well</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-06 22:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 01:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:429 on 2025-01-07 01:44</div>
            <div class="timeline-body"><p>The comment you wrote is excellent, and accurately reflects what I said! Unfortunately, after stepping away from the computer and going for a run, I realized that my description of the situation was wrong :/</p>
<p>The reason the nesting structure of the AST <em>is</em> important is that, given an AST node, we can only access its children; we have no way to walk up the AST, or find sibling nodes. And the whole point of a standalone expression is that we can enter type inference given only that node (when you call <code>infer_expression_types</code> in <code>evaluate_match_pattern_class</code>, in this case.)</p>
<p>In the current PR, when we are inferring types for the entire scope, we will hit the match-pattern node, infer its <code>cls</code> attribute as a standalone expression, and infer its <code>arguments</code> attribute as normal expressions. The arguments will not be inferred as part of the standalone expression inference region, they will be inferred as part of the outer scope inference region.</p>
<p>When we are inferring just the standalone expression region, we start with the expression that is the <code>cls</code> attribute of the pattern, and can only reach it and its sub-expressions.</p>
<p>For the purposes of the current PR, this works fine, because the only thing we care about for the type narrowing is the <code>cls</code>; we don't care about the arguments. But if you tried to pull out types for the argument expressions in <code>evaluate_match_pattern_class</code>, you would find they are not in the returned <code>TypeInference</code>.</p>
<p>I think, given that it's unclear exactly how much we will narrow based on arguments to a class patter, and how we will implement that, that we shouldn't go out out of our way for it now. So I still think the implementation you have here is good for now. We can cross the arguments bridge when we come to it. But we should update the comment(s) to accurately reflect that class pattern arguments are not currently inferred as part of the standalone expression inference region, but that's fine for now because at the moment we don't need them in our handling of the constraint.</p>
<p>Sorry for the confusion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1107 on 2025-01-07 07:30</div>
            <div class="timeline-body"><p>Nit: Using <code>assert_eq</code> gives more useful assertion messages if <code>current_match_case</code> is <code>Some</code> for whatever reason</p>
<pre><code class="language-suggestion">                debug_assert_eq!(self.current_match_case, None);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-07 07:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 07:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:418 on 2025-01-07 07:58</div>
            <div class="timeline-body"><p>Currently the guard doesn't need to be its own standalone expression, because we don't actually do any narrowing based on it. But if/when we do, it will need to be its own standalone expression, because of what I described in my more recent comment; we can't actually include non-child nodes as part of the inference region of a standalone expression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-07 15:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:418 on 2025-01-07 15:37</div>
            <div class="timeline-body"><p>Does this suggest that it's worth a follow-on PR to allow standalone expressions to wrap <code>ast::Pattern</code> in addition to <code>ast::Expr</code>?  (Or I guess <code>ast::MatchCase</code>, so that it can encompass both the pattern and the guard)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:429 on 2025-01-07 15:48</div>
            <div class="timeline-body"><blockquote>
<p>But we should update the comment(s) to accurately reflect that class pattern arguments are not currently inferred as part of the standalone expression inference region,</p>
</blockquote>
<p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1107 on 2025-01-07 15:50</div>
            <div class="timeline-body"><p>I had to also add <code>Debug</code> and <code>PartialEq</code> derivations to make this work</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-07 15:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 20:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:418 on 2025-01-07 20:48</div>
            <div class="timeline-body"><p>The other approach (which is already used for guards, although we don't use it on the inference side yet) is that the <code>PatternConstraintKind</code> can just store references to multiple expressions. (The code isn't super clear because it uses tuple variants instead of struct variants, but the optional second expression in both <code>PatternConstraintKind::Singleton</code> and <code>PatternConstraintKind::Value</code> is the guard expression, which is already recorded as a standalone expression in the semantic index builder.) So I don't think there's anything more to be done with guards, until we are ready to actually use them in narrowing.</p>
<p>The situation with class pattern arguments is more complex, since they aren't expressions either, but rather nested patterns. So we'll need to do something different there; one option is to allow an <code>ast::Pattern</code> itself to be an inference region (similar to a standalone expression). Another option might be to have <code>PatternConstraintKind::Class</code> recursively contain a vec of constraints for the arguments; this would be more similar to the recursive-standalone-expression approach you experimented with. It would result in more <code>Constraint</code> ingredients for large nested patterns, but in practice that might be fine, if such patterns aren't very common.</p>
<p>My suggestion was that we just punt on this until we actually want to narrow based on class-pattern arguments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-07 20:51</div>
            <div class="timeline-body"><p>Looks good, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-01-07 20:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-01-07 20:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-07 20:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 20:34:29 UTC
    </footer>
</body>
</html>
