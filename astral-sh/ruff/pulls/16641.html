<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stabilize `all_type_pairs_can_be_assigned_from_their_intersection` - astral-sh/ruff #16641</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Stabilize <code>all_type_pairs_can_be_assigned_from_their_intersection</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16641">#16641</a>
        opened by <a href="https://github.com/mtshiba">@mtshiba</a>
        on 2025-03-11 18:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR further fixes the problem in astral-sh/ruff#14899.</p>
<p>It seems that the implementation of <code>is_assignable_to</code> for intersection was already done in the PR astral-sh/ruff#16611. But some parts I fixed are still usable.</p>
<p>The changes are as follows:</p>
<ul>
<li>fix <code>is_gradual_equivalent_to</code> for union/intersection types containing multiple dynamic types</li>
<li>fix <code>union_elements_ordering</code> (implement lexicographic order comparison and use instead of automatic implementation)</li>
<li>implement special handlings of <code>is_subtype_of</code>, <code>is_assignable_to</code> for simplified types such as <code>LiteralString &amp; AlwaysFalsy -&gt; LiteralString &amp; Literal[‚Äú‚Äù]</code></li>
<li>fix a boolean simplification bug in <code>IntersectionBuilder::add_positive</code></li>
<li>improve handling of <code>is_disjoint_from</code> for negative intersection types</li>
</ul>
<h2>Test Plan</h2>
<p>With these changes, the property tests <code>all_fully_static_type_pairs_are_supertypes_of_their_intersection</code> and <code>all_type_pairs_can_be_assigned_from_their_intersection</code> now succeed in almost all cases (10M attempts were run for each and passed). If you agree that this problem is completely fixed, I will move these two tests from <code>flaky</code> to <code>stable</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-03-11 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @mtshiba on 2025-03-11 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @mtshiba on 2025-03-11 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @mtshiba on 2025-03-11 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-11 18:22</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ‚úÖ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-11 18:27</div>
            <div class="timeline-body"><p>Thank you! Haven't fully reviewed yet, just a quick note from running property tests on this PR. This also appears to fix a couple stable property tests I'd been looking at earlier this morning that were newly failing since astral-sh/ruff#16611 landed (<code>all_type_pairs_are_assignable_to_their_union</code> and <code>subtype_of_implies_assignable_to</code>).</p>
<p>I am seeing a new failure of the stable property test <code>disjoint_from_is_symmetric</code> with this PR, though. Example type pair:</p>
<pre><code>thread 'types::property_tests::stable::all_type_pairs_are_assignable_to_their_union' panicked at /Users/carlmeyer/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quickcheck-1.0.3/src/tester.rs:165:28:
[quickcheck] TEST FAILED. Arguments: (Intersection { pos: [], neg: [KnownClassInstance(Tuple)] }, Intersection { pos: [], neg: [Tuple([BuiltinsFunction(&quot;chr&quot;), BuiltinsFunction(&quot;ascii&quot;)])] })
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-11 18:32</div>
            <div class="timeline-body"><p>I am seeing that <code>all_fully_static_type_pairs_are_supertypes_of_their_intersection</code> and <code>all_type_pairs_can_be_assigned_from_their_intersection</code> are both consistently passing with this PR, so I think you are good to move those over to stable!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:700 on 2025-03-11 18:37</div>
            <div class="timeline-body"><p>Are we also able to detect disjointness of these type pairs? If so it might be useful to also add these cases to <code>type_properties/is_disjoint_from.md</code> in the form <code>static_assert(is_disjoint_from(..., ...))</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_properties/is_subtype_of.md</code>:312 on 2025-03-11 19:19</div>
            <div class="timeline-body"><p>These three tests all look like they are describing a type equivalence, not just a subtype relationship. It seems they all pass if modified to use <code>is_equivalent_to</code> instead. Maybe we should also add these tests to <code>type_properties/is_equivalent_to.md</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_properties/is_subtype_of.md</code>:319 on 2025-03-11 19:19</div>
            <div class="timeline-body"><p>These also look like type equivalences.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_properties/is_subtype_of.md</code>:329 on 2025-03-11 19:20</div>
            <div class="timeline-body"><p>These also look like equivalencies?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:277 on 2025-03-11 19:24</div>
            <div class="timeline-body"><p>Would it be more efficient to do this check first, to avoid lots of element comparisons if we compare two lengthy unions of different lengths?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:299 on 2025-03-11 19:24</div>
            <div class="timeline-body"><p>Same as above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3832 on 2025-03-11 19:36</div>
            <div class="timeline-body"><p>I think perhaps we should just always do this eagerly in the union and intersection builders? Though there may be cases, particularly with Todo types, where this reduces debuggability. We can look into this separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-11 19:39</div>
            <div class="timeline-body"><p>This looks like a positive step to me! I think we should figure out and solve the disjointness asymmetry that it seems to introduce, but otherwise I'm happy to go with it for now.</p>
<p>I think this effectively solves https://github.com/astral-sh/ruff/issues/15513, in a more special-cased way than we were initially aiming for there. But I think that's fine; literal types are special cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2025-03-11 20:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-11 20:54</div>
            <div class="timeline-body"><p>This PR has some overlap with https://github.com/astral-sh/ruff/pull/16636. As I mentioned there, they both look generally good to me, I will merge whichever one first reaches merge-ready state, and the other can rebase and see what is left to add.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jgeralnik">@jgeralnik</a> on 2025-03-11 22:57</div>
            <div class="timeline-body"><p>For what it's worth I made the same change to intersections in is_disjoint over in astral-sh/ruff#16636 and it has the same asymmetry problem as this commit. I haven't yet managed to make a version that passes all four of these tests:</p>
<pre><code>class X: ...
class Y: ...

static_assert(not is_disjoint_from(Intersection[Any, X], Intersection[Any, Not[Y]]))
static_assert(not is_disjoint_from(Intersection[Any, Not[Y]], Intersection[Any, X]))

static_assert(is_disjoint_from(Intersection[int, Any], Not[int]))
static_assert(is_disjoint_from(Not[int], Intersection[int, Any]))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-03-14 18:14</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_INSTRUMENTATION_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3A14899-gradual-type-assignability">CodSpeed Performance Report</a></h2>
<h3>Merging astral-sh/ruff#16641 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>mtshiba:14899-gradual-type-assignability</code> (9718536) with <code>main</code> (1fab292)</sub></p>
<h3>Summary</h3>
<p><code>‚úÖ 32</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-14 18:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:1 on 2025-03-14 18:31</div>
            <div class="timeline-body"><p>The title of this PR is &quot;Stabilize <code>all_type_pairs_can_be_assigned_from_their_intersection</code>&quot;, but it seems like on this PR branch, it's still in the <code>flaky</code> submodule in this file. In order for it to be marked as stable, you need to move it to the <code>stable</code> submodule in this file. If you do so, it will be run once a day automatically as part of a cron job, and a bot will open an issue like <a href="https://github.com/astral-sh/ruff/issues/16670">this one</a> when the tests fail. (These tests aren't run normally as part of our CI since they're quite slow!)</p>
<p>In actual fact, it looks like the changes made in this PR mean that <em>four</em> property tests currently in the <code>flaky</code> submodule can be moved to the <code>stable</code> submodule:</p>
<ul>
<li><code>all_type_pairs_can_be_assigned_from_their_intersection</code></li>
<li><code>intersection_equivalence_not_order_dependent</code></li>
<li><code>negation_is_disjoint</code></li>
<li><code>all_fully_static_type_pairs_are_supertypes_of_their_intersection</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-03-14 18:40</div>
            <div class="timeline-body"><p>Yes, it seems to pass several tests other than the mentioned one in the PR title.</p>
<p>However, many branches are added to handle <code>is_subtype_of/is_assignable_to</code> correctly. There seems to be some performance issues as well. I am looking for ideas for improvement, but I don't think this way is the final, best solution. Please let me know what you all think.</p>
<p>If this is not desirable, or if a good fix is in progress, I will revert to a commit with the test cases marked as TODO, leaving only the correct bug fix part of the PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-14 18:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:1 on 2025-03-14 18:44</div>
            <div class="timeline-body"><p>Oops, I spoke too soon. <code>intersection_equivalence_not_order_dependent</code> is still flaky with this PR. I thought it was now stable as I ran it with <code>QUICKCHECK_TESTS=1000000 cargo test --release -p red_knot_python_semantic -- --ignored types::property_tests::flaky::intersection_equivalence_not_order_dependent</code> and it didn't fail once... but then I ran it again and it immediately produced this failure üôÉ</p>
<pre><code>failures:

---- types::property_tests::stable::intersection_equivalence_not_order_dependent stdout ----

thread 'types::property_tests::stable::intersection_equivalence_not_order_dependent' panicked at /Users/alexw/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quickcheck-1.0.3/src/tester.rs:165:28:
[quickcheck] TEST FAILED. Arguments: (Union([KnownClassInstance(Bool), AlwaysTruthy]), Intersection { pos: [], neg: [] }, Union([AlwaysTruthy, AlwaysFalsy]))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-14 19:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:284 on 2025-03-14 19:05</div>
            <div class="timeline-body"><p>these Salsa lookups (the methods that take <code>db</code>) can be surprisingly expensive. It would be better to do something like this (and similar for the <code>Type::Intersection</code> branch below this):</p>
<pre><code class="language-suggestion">        (Type::Union(left), Type::Union(right)) =&gt; {
            let left = left.elements(db);
            let right = right.elements(db);
            left.len().cmp(&amp;right.len()).then_with(|| {
                left.iter()
                    .zip(right)
                    .map(|(left, right)| union_elements_ordering(left, right, db))
                    .find(|ordering| *ordering != Ordering::Equal)
                    .unwrap_or(Ordering::Equal)
            })
        }
</code></pre>
<p>but I also don't really understand why this change is necessary. I see that one mdtest fails if I revert the changes to this file:</p>
<pre><code>failures:

---- mdtest__type_properties_is_gradual_equivalent_to stdout ----

is_gradual_equivalent_to.md - Gradual equivalence relation - Unions and intersections

  crates/red_knot_python_semantic/resources/mdtest/type_properties/is_gradual_equivalent_to.md:45 unexpected error: [static-assert-error] &quot;Static assertion error: argument evaluates to `False`&quot;
</code></pre>
<p>But I don't really understand why. Can you explain it to me?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-03-14 19:14</div>
            <div class="timeline-body"><blockquote>
<p>Yes, it seems to pass several tests other than the mentioned one in the PR title.</p>
<p>However, many branches are added to handle <code>is_subtype_of/is_assignable_to</code> correctly. There seems to be some performance issues as well. I am looking for ideas for improvement, but I don't think this way is the final, best solution. Please let me know what you all think.</p>
<p>If this is not desirable, or if a good fix is in progress, I will revert to a commit with the test cases marked as TODO, leaving only the correct bug fix part of the PR.</p>
</blockquote>
<p>https://github.com/astral-sh/ruff/pull/16641#discussion_r1996132460 might help with performance.</p>
<p>https://github.com/astral-sh/ruff/pull/15784, https://github.com/astral-sh/ruff/pull/15773 and https://github.com/astral-sh/ruff/pull/15738 are all attempts at fixing <em>some</em> of the problems fixed in this PR in a slightly more general way. It's possible that merging one of those might make this PR's changes redundant. But I need to get back to those; I set them aside for a while as other things seemed more important.</p>
<p>I'll look at this PR more in-depth over the weekend or on Monday if nobody beats me to it; I need to stop working for the day now :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-03-14 19:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:284 on 2025-03-14 19:23</div>
            <div class="timeline-body"><p>The following test did not pass because the union elements were not aligned correctly.</p>
<pre><code class="language-python">static_assert(is_gradual_equivalent_to(
    Intersection[str | int, Not[type[Any]]],
    Intersection[int | str, Not[type[Unknown]]]
))
</code></pre>
<p>The arguments of <code>is_gradual_equivalent_to</code> were evaluated as follows:</p>
<pre><code class="language-python">LHS: (str &amp; ~type[Any]) | (int &amp; ~type[Any])
RHS: (int &amp; ~type[Unknown]) | (str &amp; ~type[Unknown])
</code></pre>
<p>If the union elements were sorted correctly, <code>is_gradual_equivalent_to</code> would work. like this:</p>
<pre><code class="language-python">LHS: (int &amp; ~type[Any]) | (str &amp; ~type[Any])
RHS: (int &amp; ~type[Unknown]) | (str &amp; ~type[Unknown])
</code></pre>
<p>But they weren't. This means that there was a problem with ordering for intersections.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-14 19:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:284 on 2025-03-14 19:26</div>
            <div class="timeline-body"><p>Thank you, that's really helpful! Makes total sense :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:286 on 2025-03-14 19:37</div>
            <div class="timeline-body"><p>Our representation of types is always in disjunctive normal form (union of intersections) and does not permit nested unions. Since this method is only used to sort elements of unions and intersections, it is impossible for us to ever encounter a union here. I think we should use <code>unreachable!</code> to assert this invariant, rather than adding dead code here.</p>
<pre><code class="language-suggestion">        (Type::Union(_), _) | (_, Type::Union(_)) =&gt; {
            unreachable!(&quot;our type representation does not permit nested unions&quot;)
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:24 on 2025-03-14 19:39</div>
            <div class="timeline-body"><p>Orthogonal to this PR, but this method is used to sort elements of both unions and intersections. The doc comment above describes this correctly, but this name is misleading. I would suggest we rename to <code>union_or_intersection_elements_ordering</code>. (It only has two call sites, so verbosity is not really an issue.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:284 on 2025-03-14 19:41</div>
            <div class="timeline-body"><p>I don't think <em>this</em> change is necessary (because unions can never actually appear here, see my other comment), but the below change for intersections is necessary. The point is that intersections are a type that can appear within a union, and using just <code>cmp</code> on the vector of elements in the intersection (as we did before this PR) means that two intersections that should be considered the same can be considered different, and thus mess up the comparison of the outer union. As in @mtshiba 's example.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:307 on 2025-03-14 19:42</div>
            <div class="timeline-body"><p>I'm not convinced this is the source of the incremental-check regression (since I don't remember seeing the regression on earlier versions of the diff that included this code), but I do think it's probably worth extracting <code>{left,right}.negative(db)</code> and <code>{left,right}.positive(db)</code> into local variables so we call those queries just once each.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-14 19:43</div>
            <div class="timeline-body"><p>Still reviewing, but submitting a few comments related to an active discussion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-14 19:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:1 on 2025-03-14 19:53</div>
            <div class="timeline-body"><p>Hmm, interesting. Empty intersection types cannot be created by our type builders; it will simplify to just <code>object</code>. So we should probably prevent an empty intersection from being constructed in the property tests, too. Maybe that will be enough to fix this property test?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-14 19:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:1 on 2025-03-14 19:55</div>
            <div class="timeline-body"><p>Oh, never mind - we already use <code>IntersectionBuilder</code> in the property tests, it's just the examples are shown in the original <code>Ty</code> representation. So this is a real bug.</p>
<p>I ran it again and got another counter-example for it:</p>
<pre><code>[quickcheck] TEST FAILED. Arguments: (KnownClassInstance(Int), Union([KnownClassInstance(Bool), AlwaysFalsy]), Intersection { pos: [], neg: [Intersection { pos: [], neg: [AlwaysFalsy, BooleanLiteral(true)] }] })
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-14 20:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:1 on 2025-03-14 20:07</div>
            <div class="timeline-body"><p>The root cause of these failures is that we simplify <code>(bool | AlwaysTruthy) &amp; (AlwaysTruthy | AlwaysFalsy)</code> to <code>AlwaysTruthy | Literal[False]</code>, but if we swap that intersection around to <code>(AlwaysTruthy | AlwaysFalsy) &amp; (bool | AlwaysTruthy)</code>, we only reduce it to <code>bool | AlwaysTruthy</code>. So this I guess demonstrates that the approach in this PR is not (so far) adequate to really resolve #15513, because the simplification we do in union/intersection builder is still order sensitive.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:576 on 2025-03-14 20:12</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                // `bool` is a subtype of any type that `Literal[True]` and `Literal[False]` are both subtypes of.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:590 on 2025-03-14 20:13</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                // `LiteralString` is a subtype of any type that both `Literal[&quot;&quot;]` and `AlwaysTruthy` are subtypes of
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:606 on 2025-03-14 20:18</div>
            <div class="timeline-body"><p>We understand that <code>is_subtype_of(AlwaysFalsy, Not[AlwaysTruthy])</code>, so this double condition is redundant, all tests pass if it is simplified to this:</p>
<pre><code class="language-suggestion">                else if self.is_subtype_of(db, Type::AlwaysTruthy.negate(db))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:604 on 2025-03-14 20:22</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                // `Not[AlwaysTruthy]` is a subtype of any type that both `Literal[&quot;&quot;]` and `Not[LiteralString]` are subtypes of
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:619 on 2025-03-14 21:11</div>
            <div class="timeline-body"><p>I think this is the special case that is most concerning from a performance perspective, since many types will be subtypes of <code>Not[AlwaysTruthy]</code>, even if they are totally unrelated to literal strings, and we will have to do these extra checks on all of those types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:742 on 2025-03-14 21:23</div>
            <div class="timeline-body"><p>This seems to effectively just undo https://github.com/astral-sh/ruff/pull/16636, which is unfortunate as that was a nice simplification. Is this really necessary?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-14 21:27</div>
            <div class="timeline-body"><p>Haven't finished reviewing all the special cases but need to move on to other things. I think it would be good to split this PR apart. For instance I think the fix to ordering of intersections is good; can we land that separately? I'm not convinced by all the new special cases; it feels like some of them really should be handled in a more general way (like by improving our eager simplifications of types in intersection and union builder.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:307 on 2025-03-15 10:23</div>
            <div class="timeline-body"><blockquote>
<p>I'm not convinced this is the source of the incremental-check regression</p>
</blockquote>
<p>FWIW, while there's still a regression on codspeed, it does look like https://github.com/astral-sh/ruff/pull/16641/commits/9718536fb866598b95b868c69db4265149770888 <em>significantly</em> improved performance: https://codspeed.io/astral-sh/ruff/branches/mtshiba%3A14899-gradual-type-assignability</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-15 10:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-03-15 15:08</div>
            <div class="timeline-body"><p>Now I am convinced that this problem should be solved using a more general method. But it may be a good fact that at least half of the flaky tests will pass if we can implement the special equivalence relation for <code>LiteralString</code> and <code>bool</code> types.</p>
<p>For now, I would like to create a new PR that cut out the correct bug fix (<code>union_or_intersection_elements_ordering</code>) in this PR. The new test cases presented in this PR would be an option to add as TODOs, or reference for future work. Which would you prefer?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-17 20:56</div>
            <div class="timeline-body"><blockquote>
<p>The new test cases presented in this PR would be an option to add as TODOs, or reference for future work. Which would you prefer?</p>
</blockquote>
<p>I think it is useful to add reviewed test cases that should pass but don't, with TODO comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-03-19 18:05</div>
            <div class="timeline-body"><p>OK, so I'll create a new PR with the test cases marked as TODOs and add them, then close this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @mtshiba on 2025-03-19 18:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-24 14:32</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:10:39 UTC
    </footer>
</body>
</html>
