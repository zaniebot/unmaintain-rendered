<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keep lambda parameters on one line and parenthesize the body if it expands - astral-sh/ruff #21385</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Keep lambda parameters on one line and parenthesize the body if it expands</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21385">#21385</a>
        opened by <a href="https://github.com/ntBre">@ntBre</a>
        on 2025-11-11 15:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/ntBre">@ntBre</a> on 2025-11-11 15:57</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR makes two changes to our formatting of <code>lambda</code> expressions:</p>
<ol>
<li>We now parenthesize the body expression if it expands</li>
<li>We now try to keep the parameters on a single line</li>
</ol>
<p>The latter of these fixes #8179:</p>
<p>Black formatting and this PR's formatting:</p>
<pre><code class="language-py">def a():
    return b(
        c,
        d,
        e,
        f=lambda self, *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
            *args, **kwargs
        ),
    )
</code></pre>
<p>Stable Ruff formatting</p>
<pre><code class="language-py">def a():
    return b(
        c,
        d,
        e,
        f=lambda self,
        *args,
        **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs),
    )
</code></pre>
<p>We don't parenthesize the body expression here because the call to <code>aaaa...</code> has its own parentheses, but adding a binary operator shows the new parenthesization:</p>
<pre><code class="language-diff">@@ -3,7 +3,7 @@
         c,
         d,
         e,
-        f=lambda self, *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
-            *args, **kwargs
-        ) + 1,
+        f=lambda self, *args, **kwargs: (
+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
+        ),
     )
</code></pre>
<p>This is actually a new divergence from Black, which formats this input like this:</p>
<pre><code class="language-py">def a():
    return b(
        c,
        d,
        e,
        f=lambda self, *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(
            *args, **kwargs
        )
        + 1,
    )
</code></pre>
<p>But I think this is an improvement, unlike the case from #8179.</p>
<p>One other, smaller benefit is that because we now add parentheses to lambda bodies, we also remove redundant parentheses:</p>
<pre><code class="language-diff"> @pytest.mark.parametrize(
     &quot;f&quot;,
     [
-        lambda x: (x.expanding(min_periods=5).cov(x, pairwise=True)),
-        lambda x: (x.expanding(min_periods=5).corr(x, pairwise=True)),
+        lambda x: x.expanding(min_periods=5).cov(x, pairwise=True),
+        lambda x: x.expanding(min_periods=5).corr(x, pairwise=True),
     ],
 )
 def test_moment_functions_zero_length_pairwise(f):
</code></pre>
<h2>Test Plan</h2>
<p>New tests taken from #8465 and probably a few more I should grab from the ecosystem results.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by @ntBre on 2025-11-11 15:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by @ntBre on 2025-11-11 15:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-11 16:11</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>ℹ️ ecosystem check <strong>detected format changes</strong>. (+900 -814 lines in 68 files in 19 projects; 36 projects unchanged)</p>
<details><summary><a href="https://github.com/RasaHQ/rasa">RasaHQ/rasa</a> (+6 -6 lines across 2 files)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/RasaHQ/rasa/blob/b8de3b231126747ff74b2782cb25cb22d2d898d7/rasa/nlu/extractors/crf_entity_extractor.py#L101'>rasa/nlu/extractors/crf_entity_extractor.py~L101</a></p>
<pre><code class="language-diff">         CRFEntityExtractorOptions.SUFFIX1: lambda crf_token: crf_token.text[-1:],
         CRFEntityExtractorOptions.BIAS: lambda _: &quot;bias&quot;,
         CRFEntityExtractorOptions.POS: lambda crf_token: crf_token.pos_tag,
-        CRFEntityExtractorOptions.POS2: lambda crf_token: crf_token.pos_tag[:2]
-        if crf_token.pos_tag is not None
-        else None,
+        CRFEntityExtractorOptions.POS2: lambda crf_token: (
+            crf_token.pos_tag[:2] if crf_token.pos_tag is not None else None
+        ),
         CRFEntityExtractorOptions.UPPER: lambda crf_token: crf_token.text.isupper(),
         CRFEntityExtractorOptions.DIGIT: lambda crf_token: crf_token.text.isdigit(),
         CRFEntityExtractorOptions.PATTERN: lambda crf_token: crf_token.pattern,
</code></pre>
<p><a href='https://github.com/RasaHQ/rasa/blob/b8de3b231126747ff74b2782cb25cb22d2d898d7/rasa/nlu/featurizers/sparse_featurizer/lexical_syntactic_featurizer.py#L86'>rasa/nlu/featurizers/sparse_featurizer/lexical_syntactic_featurizer.py~L86</a></p>
<pre><code class="language-diff">         &quot;suffix2&quot;: lambda token: token.text[-2:],
         &quot;suffix1&quot;: lambda token: token.text[-1:],
         &quot;pos&quot;: lambda token: token.data.get(POS_TAG_KEY, None),
-        &quot;pos2&quot;: lambda token: token.data.get(POS_TAG_KEY, [])[:2]
-        if POS_TAG_KEY in token.data
-        else None,
+        &quot;pos2&quot;: lambda token: (
+            token.data.get(POS_TAG_KEY, [])[:2] if POS_TAG_KEY in token.data else None
+        ),
         &quot;upper&quot;: lambda token: token.text.isupper(),
         &quot;digit&quot;: lambda token: token.text.isdigit(),
     }
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/PlasmaPy/PlasmaPy">PlasmaPy/PlasmaPy</a> (+2 -2 lines across 1 file)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/PlasmaPy/PlasmaPy/blob/f95c6a4b6629f094b39837614f50741dc13e2282/src/plasmapy/particles/atomic.py#L1245'>src/plasmapy/particles/atomic.py~L1245</a></p>
<pre><code class="language-diff">         # If it has been indicated that the user wants the interpolator, construct
         # an anonymous function to handle units and sanitize IO
         if return_interpolator:
-            return (
-                lambda x: np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
+            return lambda x: (
+                np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
             )
 
         return (
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/apache/airflow">apache/airflow</a> (+10 -13 lines across 4 files)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/apache/airflow/blob/8256ee16d1de5b47ad996af82608d2bb836dfe1d/airflow-core/tests/unit/cli/commands/test_config_command.py#L355'>airflow-core/tests/unit/cli/commands/test_config_command.py~L355</a></p>
<pre><code class="language-diff">     def test_lint_detects_multiple_issues(self, stdout_capture):
         with mock.patch(
             &quot;airflow.configuration.conf.has_option&quot;,
-            side_effect=lambda section, option, lookup_from_deprecated: option
-            in [&quot;check_slas&quot;, &quot;strict_dataset_uri_validation&quot;],
+            side_effect=lambda section, option, lookup_from_deprecated: (
+                option in [&quot;check_slas&quot;, &quot;strict_dataset_uri_validation&quot;]
+            ),
         ):
             with stdout_capture as temp_stdout:
                 config_command.lint_config(cli_parser.get_parser().parse_args([&quot;config&quot;, &quot;lint&quot;]))
</code></pre>
<p><a href='https://github.com/apache/airflow/blob/8256ee16d1de5b47ad996af82608d2bb836dfe1d/providers/cncf/kubernetes/tests/unit/cncf/kubernetes/executors/test_kubernetes_executor.py#L992'>providers/cncf/kubernetes/tests/unit/cncf/kubernetes/executors/test_kubernetes_executor.py~L992</a></p>
<pre><code class="language-diff">         mock_ti.queued_by_job_id = &quot;10&quot;  # scheduler_job would have updated this after the first adoption
         executor.scheduler_job_id = &quot;20&quot;
         # assume success adopting, `adopt_launched_task` pops `ti_key` from `tis_to_flush_by_key`
-        mock_adopt_launched_task.side_effect = (
-            lambda client, pod, tis_to_flush_by_key: tis_to_flush_by_key.pop(ti_key)
+        mock_adopt_launched_task.side_effect = lambda client, pod, tis_to_flush_by_key: (
+            tis_to_flush_by_key.pop(ti_key)
         )
 
         reset_tis = executor.try_adopt_task_instances([mock_ti])
</code></pre>
<p><a href='https://github.com/apache/airflow/blob/8256ee16d1de5b47ad996af82608d2bb836dfe1d/providers/docker/tests/unit/docker/operators/test_docker.py#L153'>providers/docker/tests/unit/docker/operators/test_docker.py~L153</a></p>
<pre><code class="language-diff">         self.client_mock.attach.return_value = self.log_messages
 
         # If logs() is called with tail then only return the last value, otherwise return the whole log.
-        self.client_mock.logs.side_effect = (
-            lambda **kwargs: iter(self.log_messages[-kwargs[&quot;tail&quot;] :])
-            if &quot;tail&quot; in kwargs
-            else iter(self.log_messages)
+        self.client_mock.logs.side_effect = lambda **kwargs: (
+            iter(self.log_messages[-kwargs[&quot;tail&quot;] :]) if &quot;tail&quot; in kwargs else iter(self.log_messages)
         )
 
         docker_api_client_patcher.return_value = self.client_mock
</code></pre>
<p><a href='https://github.com/apache/airflow/blob/8256ee16d1de5b47ad996af82608d2bb836dfe1d/providers/docker/tests/unit/docker/operators/test_docker.py#L622'>providers/docker/tests/unit/docker/operators/test_docker.py~L622</a></p>
<pre><code class="language-diff">         self.client_mock.pull.return_value = [b'{&quot;status&quot;:&quot;pull log&quot;}']
         self.client_mock.attach.return_value = iter([b&quot;container log 1 \n&quot;, b&quot;container log 2\n&quot;])
         # Make sure the logs side effect is updated after the change
-        self.client_mock.attach.side_effect = (
-            lambda **kwargs: iter(self.log_messages[-kwargs[&quot;tail&quot;] :])
-            if &quot;tail&quot; in kwargs
-            else iter(self.log_messages)
+        self.client_mock.attach.side_effect = lambda **kwargs: (
+            iter(self.log_messages[-kwargs[&quot;tail&quot;] :]) if &quot;tail&quot; in kwargs else iter(self.log_messages)
         )
 
         kwargs = {
</code></pre>
<p><a href='https://github.com/apache/airflow/blob/8256ee16d1de5b47ad996af82608d2bb836dfe1d/providers/http/tests/unit/http/sensors/test_http.py#L302'>providers/http/tests/unit/http/sensors/test_http.py~L302</a></p>
<pre><code class="language-diff">             method=&quot;GET&quot;,
             endpoint=&quot;/search&quot;,
             data={&quot;client&quot;: &quot;ubuntu&quot;, &quot;q&quot;: &quot;airflow&quot;},
-            response_check=lambda response: (&quot;apache/airflow&quot; in response.text),
+            response_check=lambda response: &quot;apache/airflow&quot; in response.text,
             headers={},
         )
         op.execute({})
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/apache/superset">apache/superset</a> (+34 -25 lines across 7 files)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/superset/tags/api.py#L598'>superset/tags/api.py~L598</a></p>
<pre><code class="language-diff">     @statsd_metrics
     @rison({&quot;type&quot;: &quot;array&quot;, &quot;items&quot;: {&quot;type&quot;: &quot;integer&quot;}})
     @event_logger.log_this_with_context(
-        action=lambda self, *args, **kwargs: f&quot;{self.__class__.__name__}&quot;
-        f&quot;.favorite_status&quot;,
+        action=lambda self, *args, **kwargs: (
+            f&quot;{self.__class__.__name__}.favorite_status&quot;
+        ),
         log_to_statsd=False,
     )
     def favorite_status(self, **kwargs: Any) -&gt; Response:
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/superset/tags/api.py#L696'>superset/tags/api.py~L696</a></p>
<pre><code class="language-diff">     @safe
     @statsd_metrics
     @event_logger.log_this_with_context(
-        action=lambda self, *args, **kwargs: f&quot;{self.__class__.__name__}&quot;
-        f&quot;.remove_favorite&quot;,
+        action=lambda self, *args, **kwargs: (
+            f&quot;{self.__class__.__name__}.remove_favorite&quot;
+        ),
         log_to_statsd=False,
     )
     def remove_favorite(self, pk: int) -&gt; Response:
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/datasource_tests.py#L213'>tests/integration_tests/datasource_tests.py~L213</a></p>
<pre><code class="language-diff">     def test_external_metadata_by_name_for_virtual_table_uses_mutator(self):
         self.login(ADMIN_USERNAME)
         with create_and_cleanup_table() as tbl:
-            current_app.config[&quot;SQL_QUERY_MUTATOR&quot;] = (
-                lambda sql, **kwargs: &quot;SELECT 456 as intcol, 'def' as mutated_strcol&quot;
+            current_app.config[&quot;SQL_QUERY_MUTATOR&quot;] = lambda sql, **kwargs: (
+                &quot;SELECT 456 as intcol, 'def' as mutated_strcol&quot;
             )
 
             params = prison.dumps({
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/datasource_tests.py#L339'>tests/integration_tests/datasource_tests.py~L339</a></p>
<pre><code class="language-diff"> 
         pytest.raises(
             SupersetGenericDBErrorException,
-            lambda: db.session.query(SqlaTable)
-            .filter_by(id=tbl.id)
-            .one_or_none()
-            .external_metadata(),
+            lambda: (
+                db.session.query(SqlaTable)
+                .filter_by(id=tbl.id)
+                .one_or_none()
+                .external_metadata()
+            ),
         )
 
         resp = self.client.get(url)
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/db_engine_specs/presto_tests.py#L81'>tests/integration_tests/db_engine_specs/presto_tests.py~L81</a></p>
<pre><code class="language-diff">     def verify_presto_column(self, column, expected_results):
         inspector = mock.Mock()
         preparer = inspector.engine.dialect.identifier_preparer
-        preparer.quote_identifier = preparer.quote = preparer.quote_schema = (
-            lambda x: f'&quot;{x}&quot;'
+        preparer.quote_identifier = preparer.quote = preparer.quote_schema = lambda x: (
+            f'&quot;{x}&quot;'
         )
         row = mock.Mock()
         row.Column, row.Type, row.Null = column
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/db_engine_specs/presto_tests.py#L827'>tests/integration_tests/db_engine_specs/presto_tests.py~L827</a></p>
<pre><code class="language-diff">     def test_show_columns(self):
         inspector = mock.MagicMock()
         preparer = inspector.engine.dialect.identifier_preparer
-        preparer.quote_identifier = preparer.quote = preparer.quote_schema = (
-            lambda x: f'&quot;{x}&quot;'
+        preparer.quote_identifier = preparer.quote = preparer.quote_schema = lambda x: (
+            f'&quot;{x}&quot;'
         )
         inspector.bind.execute.return_value.fetchall = mock.MagicMock(
             return_value=[&quot;a&quot;, &quot;b&quot;]
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/db_engine_specs/presto_tests.py#L843'>tests/integration_tests/db_engine_specs/presto_tests.py~L843</a></p>
<pre><code class="language-diff">     def test_show_columns_with_schema(self):
         inspector = mock.MagicMock()
         preparer = inspector.engine.dialect.identifier_preparer
-        preparer.quote_identifier = preparer.quote = preparer.quote_schema = (
-            lambda x: f'&quot;{x}&quot;'
+        preparer.quote_identifier = preparer.quote = preparer.quote_schema = lambda x: (
+            f'&quot;{x}&quot;'
         )
         inspector.bind.execute.return_value.fetchall = mock.MagicMock(
             return_value=[&quot;a&quot;, &quot;b&quot;]
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/security/api_tests.py#L187'>tests/integration_tests/security/api_tests.py~L187</a></p>
<pre><code class="language-diff">         self.assert500(self._get_guest_token_with_rls(rls_rule))
 
     @with_config({
-        &quot;GUEST_TOKEN_VALIDATOR_HOOK&quot;: lambda x: len(x[&quot;rls&quot;]) == 1
-        and &quot;tenant_id=&quot; in x[&quot;rls&quot;][0][&quot;clause&quot;]
+        &quot;GUEST_TOKEN_VALIDATOR_HOOK&quot;: lambda x: (
+            len(x[&quot;rls&quot;]) == 1 and &quot;tenant_id=&quot; in x[&quot;rls&quot;][0][&quot;clause&quot;]
+        )
     })
     def test_guest_validator_hook_real_world_example_positive(self):
         &quot;&quot;&quot;
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/integration_tests/security/api_tests.py#L201'>tests/integration_tests/security/api_tests.py~L201</a></p>
<pre><code class="language-diff">         self.assert200(self._get_guest_token_with_rls(rls_rule))
 
     @with_config({
-        &quot;GUEST_TOKEN_VALIDATOR_HOOK&quot;: lambda x: len(x[&quot;rls&quot;]) == 1
-        and &quot;tenant_id=&quot; in x[&quot;rls&quot;][0][&quot;clause&quot;]
+        &quot;GUEST_TOKEN_VALIDATOR_HOOK&quot;: lambda x: (
+            len(x[&quot;rls&quot;]) == 1 and &quot;tenant_id=&quot; in x[&quot;rls&quot;][0][&quot;clause&quot;]
+        )
     })
     def test_guest_validator_hook_real_world_example_negative(self):
         &quot;&quot;&quot;
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/unit_tests/datasets/test_datetime_format_detector.py#L44'>tests/unit_tests/datasets/test_datetime_format_detector.py~L44</a></p>
<pre><code class="language-diff">     dataset.database.get_sqla_engine.return_value.__exit__.return_value = None
 
     # Mock apply_limit_to_sql to return SQL with LIMIT
-    dataset.database.apply_limit_to_sql = (
-        lambda sql, limit, force: f&quot;{sql} LIMIT {limit}&quot;
+    dataset.database.apply_limit_to_sql = lambda sql, limit, force: (
+        f&quot;{sql} LIMIT {limit}&quot;
     )
 
     return dataset
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/unit_tests/importexport/api_test.py#L48'>tests/unit_tests/importexport/api_test.py~L48</a></p>
<pre><code class="language-diff">     mocked_export_result = [
         (
             &quot;metadata.yaml&quot;,
-            lambda: &quot;version: 1.0.0\ntype: assets\ntimestamp: '2022-01-01T00:00:00+00:00'\n&quot;,  # noqa: E501
+            lambda: (
+                &quot;version: 1.0.0\ntype: assets\ntimestamp: '2022-01-01T00:00:00+00:00'\n&quot;
+            ),  # noqa: E501
         ),
         (&quot;databases/example.yaml&quot;, lambda: &quot;&lt;DATABASE CONTENTS&gt;&quot;),
     ]
</code></pre>
<p><a href='https://github.com/apache/superset/blob/e5b7e38a305437b81526f542f750d152dd6870ae/tests/unit_tests/utils/test_core.py#L635'>tests/unit_tests/utils/test_core.py~L635</a></p>
<pre><code class="language-diff"> 
 
 @with_config({
-    &quot;USER_AGENT_FUNC&quot;: lambda database,
-    source: f&quot;{database.database_name} {source.name}&quot;
+    &quot;USER_AGENT_FUNC&quot;: lambda database, source: (
+        f&quot;{database.database_name} {source.name}&quot;
+    )
 })
 def test_get_user_agent_custom(mocker: MockerFixture, app_context: None) -&gt; None:
     database_mock = mocker.MagicMock()
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/aws/aws-sam-cli">aws/aws-sam-cli</a> (+15 -12 lines across 1 file)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/aws/aws-sam-cli/blob/a367657230ac67dc46de62f7d71e4e5a75e124ff/samcli/lib/cli_validation/image_repository_validation.py#L70'>samcli/lib/cli_validation/image_repository_validation.py~L70</a></p>
<pre><code class="language-diff"> 
             validators = [
                 Validator(
-                    validation_function=lambda: bool(image_repository)
-                    + bool(image_repositories)
-                    + bool(resolve_image_repos)
-                    &gt; 1,
+                    validation_function=lambda: (
+                        bool(image_repository) + bool(image_repositories) + bool(resolve_image_repos) &gt; 1
+                    ),
                     exception=click.BadOptionUsage(
                         option_name=&quot;--image-repositories&quot;,
                         ctx=ctx,
</code></pre>
<p><a href='https://github.com/aws/aws-sam-cli/blob/a367657230ac67dc46de62f7d71e4e5a75e124ff/samcli/lib/cli_validation/image_repository_validation.py#L82'>samcli/lib/cli_validation/image_repository_validation.py~L82</a></p>
<pre><code class="language-diff">                     ),
                 ),
                 Validator(
-                    validation_function=lambda: not guided
-                    and not (image_repository or image_repositories or resolve_image_repos)
-                    and required,
+                    validation_function=lambda: (
+                        not guided and not (image_repository or image_repositories or resolve_image_repos) and required
+                    ),
                     exception=click.BadOptionUsage(
                         option_name=&quot;--image-repositories&quot;,
                         ctx=ctx,
</code></pre>
<p><a href='https://github.com/aws/aws-sam-cli/blob/a367657230ac67dc46de62f7d71e4e5a75e124ff/samcli/lib/cli_validation/image_repository_validation.py#L92'>samcli/lib/cli_validation/image_repository_validation.py~L92</a></p>
<pre><code class="language-diff">                     ),
                 ),
                 Validator(
-                    validation_function=lambda: not guided
-                    and (
-                        image_repositories
-                        and not resolve_image_repos
-                        and not _is_all_image_funcs_provided(template_file, image_repositories, parameters_overrides)
+                    validation_function=lambda: (
+                        not guided
+                        and (
+                            image_repositories
+                            and not resolve_image_repos
+                            and not _is_all_image_funcs_provided(
+                                template_file, image_repositories, parameters_overrides
+                            )
+                        )
                     ),
                     exception=click.BadOptionUsage(
                         option_name=&quot;--image-repositories&quot;, ctx=ctx, message=image_repos_error_msg
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/binary-husky/gpt_academic">binary-husky/gpt_academic</a> (+30 -26 lines across 3 files)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/agent_fns/general.py#L83'>crazy_functions/agent_fns/general.py~L83</a></p>
<pre><code class="language-diff">             }
             kwargs.update(agent_kwargs)
             agent_handle = agent_cls(**kwargs)
-            agent_handle._print_received_message = (
-                lambda a, b: self.gpt_academic_print_override(agent_kwargs, a, b)
+            agent_handle._print_received_message = lambda a, b: (
+                self.gpt_academic_print_override(agent_kwargs, a, b)
             )
             for d in agent_handle._reply_func_list:
                 if (
</code></pre>
<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/agent_fns/general.py#L93'>crazy_functions/agent_fns/general.py~L93</a></p>
<pre><code class="language-diff">                 ):
                     d[&quot;reply_func&quot;] = gpt_academic_generate_oai_reply
             if agent_kwargs[&quot;name&quot;] == &quot;user_proxy&quot;:
-                agent_handle.get_human_input = (
-                    lambda a: self.gpt_academic_get_human_input(user_proxy, a)
+                agent_handle.get_human_input = lambda a: (
+                    self.gpt_academic_get_human_input(user_proxy, a)
                 )
                 user_proxy = agent_handle
             if agent_kwargs[&quot;name&quot;] == &quot;assistant&quot;:
</code></pre>
<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/agent_fns/general.py#L134'>crazy_functions/agent_fns/general.py~L134</a></p>
<pre><code class="language-diff">                 kwargs = {&quot;code_execution_config&quot;: code_execution_config}
                 kwargs.update(agent_kwargs)
                 agent_handle = agent_cls(**kwargs)
-                agent_handle._print_received_message = (
-                    lambda a, b: self.gpt_academic_print_override(agent_kwargs, a, b)
+                agent_handle._print_received_message = lambda a, b: (
+                    self.gpt_academic_print_override(agent_kwargs, a, b)
                 )
                 agents_instances.append(agent_handle)
                 if agent_kwargs[&quot;name&quot;] == &quot;user_proxy&quot;:
                     user_proxy = agent_handle
-                    user_proxy.get_human_input = (
-                        lambda a: self.gpt_academic_get_human_input(user_proxy, a)
+                    user_proxy.get_human_input = lambda a: (
+                        self.gpt_academic_get_human_input(user_proxy, a)
                     )
             try:
                 groupchat = autogen.GroupChat(
</code></pre>
<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/agent_fns/general.py#L150'>crazy_functions/agent_fns/general.py~L150</a></p>
<pre><code class="language-diff">                 manager = autogen.GroupChatManager(
                     groupchat=groupchat, **self.define_group_chat_manager_config()
                 )
-                manager._print_received_message = (
-                    lambda a, b: self.gpt_academic_print_override(agent_kwargs, a, b)
+                manager._print_received_message = lambda a, b: (
+                    self.gpt_academic_print_override(agent_kwargs, a, b)
                 )
                 manager.get_human_input = lambda a: self.gpt_academic_get_human_input(
                     manager, a
</code></pre>
<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/crazy_utils.py#L299'>crazy_functions/crazy_utils.py~L299</a></p>
<pre><code class="language-diff">         retry_op = retry_times_at_unknown_error
         exceeded_cnt = 0
         mutable[index][2] = &quot;执行中&quot;
-        detect_timeout = (
-            lambda: len(mutable[index]) &gt;= 2
+        detect_timeout = lambda: (
+            len(mutable[index]) &gt;= 2
             and (time.time() - mutable[index][1]) &gt; watch_dog_patience
         )
         while True:
</code></pre>
<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/review_fns/paper_processor/paper_llm_ranker.py#L143'>crazy_functions/review_fns/paper_processor/paper_llm_ranker.py~L143</a></p>
<pre><code class="language-diff">                     )
                 elif search_criteria.query_type == &quot;review&quot;:
                     papers.sort(
-                        key=lambda x: 1
-                        if any(
-                            keyword in (getattr(x, &quot;title&quot;, &quot;&quot;) or &quot;&quot;).lower()
-                            or keyword in (getattr(x, &quot;abstract&quot;, &quot;&quot;) or &quot;&quot;).lower()
-                            for keyword in [&quot;review&quot;, &quot;survey&quot;, &quot;overview&quot;]
-                        )
-                        else 0,
+                        key=lambda x: (
+                            1
+                            if any(
+                                keyword in (getattr(x, &quot;title&quot;, &quot;&quot;) or &quot;&quot;).lower()
+                                or keyword in (getattr(x, &quot;abstract&quot;, &quot;&quot;) or &quot;&quot;).lower()
+                                for keyword in [&quot;review&quot;, &quot;survey&quot;, &quot;overview&quot;]
+                            )
+                            else 0
+                        ),
                         reverse=True,
                     )
             return papers[:top_k]
</code></pre>
<p><a href='https://github.com/binary-husky/gpt_academic/blob/0aa0472da44edc0a888c7f83b564c6d0d1089366/crazy_functions/review_fns/paper_processor/paper_llm_ranker.py#L164'>crazy_functions/review_fns/paper_processor/paper_llm_ranker.py~L164</a></p>
<pre><code class="language-diff">         if search_criteria and search_criteria.query_type == &quot;review&quot;:
             papers = sorted(
                 papers,
-                key=lambda x: 1
-                if any(
-                    keyword in (getattr(x, &quot;title&quot;, &quot;&quot;) or &quot;&quot;).lower()
-                    or keyword in (getattr(x, &quot;abstract&quot;, &quot;&quot;) or &quot;&quot;).lower()
-                    for keyword in [&quot;review&quot;, &quot;survey&quot;, &quot;overview&quot;]
-                )
-                else 0,
+                key=lambda x: (
+                    1
+                    if any(
+                        keyword in (getattr(x, &quot;title&quot;, &quot;&quot;) or &quot;&quot;).lower()
+                        or keyword in (getattr(x, &quot;abstract&quot;, &quot;&quot;) or &quot;&quot;).lower()
+                        for keyword in [&quot;review&quot;, &quot;survey&quot;, &quot;overview&quot;]
+                    )
+                    else 0
+                ),
                 reverse=True,
             )
 
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/ibis-project/ibis">ibis-project/ibis</a> (+135 -119 lines across 7 files)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/datafusion/__init__.py#L246'>ibis/backends/datafusion/<strong>init</strong>.py~L246</a></p>
<pre><code class="language-diff"> 
         for name, func in inspect.getmembers(
             udfs,
-            predicate=lambda m: callable(m)
-            and not m.__name__.startswith(&quot;_&quot;)
-            and m.__module__ == udfs.__name__,
+            predicate=lambda m: (
+                callable(m)
+                and not m.__name__.startswith(&quot;_&quot;)
+                and m.__module__ == udfs.__name__
+            ),
         ):
             annotations = typing.get_type_hints(func)
             argnames = list(inspect.signature(func).parameters.keys())
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/sql/dialects.py#L241'>ibis/backends/sql/dialects.py~L241</a></p>
<pre><code class="language-diff">             sge.ArrayAgg: rename_func(&quot;array_agg&quot;),
             sge.ArraySort: rename_func(&quot;array_sort&quot;),
             sge.Length: rename_func(&quot;char_length&quot;),
-            sge.TryCast: lambda self,
-            e: f&quot;TRY_CAST({e.this.sql(self.dialect)} AS {e.to.sql(self.dialect)})&quot;,
+            sge.TryCast: lambda self, e: (
+                f&quot;TRY_CAST({e.this.sql(self.dialect)} AS {e.to.sql(self.dialect)})&quot;
+            ),
             sge.DayOfYear: rename_func(&quot;dayofyear&quot;),
             sge.DayOfWeek: rename_func(&quot;dayofweek&quot;),
             sge.DayOfMonth: rename_func(&quot;dayofmonth&quot;),
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_aggregation.py#L1278'>ibis/backends/tests/test_aggregation.py~L1278</a></p>
<pre><code class="language-diff">         )
         .groupby(&quot;bigint_col&quot;)
         .string_col.agg(
-            lambda s: (np.nan if pd.isna(s).all() else pandas_sep.join(s.values))
+            lambda s: np.nan if pd.isna(s).all() else pandas_sep.join(s.values)
         )
         .rename(&quot;tmp&quot;)
         .sort_index()
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_window.py#L214'>ibis/backends/tests/test_window.py~L214</a></p>
<pre><code class="language-diff">         ),
         param(
             lambda t, win: t.double_col.cummean().over(win),
-            lambda t: (t.double_col.expanding().mean().reset_index(drop=True, level=0)),
+            lambda t: t.double_col.expanding().mean().reset_index(drop=True, level=0),
             id=&quot;cummean&quot;,
             marks=pytest.mark.notimpl([&quot;druid&quot;], raises=PyDruidProgrammingError),
         ),
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_window.py#L279'>ibis/backends/tests/test_window.py~L279</a></p>
<pre><code class="language-diff">         ),
         param(
             lambda t, win: t.double_col.mean().over(win),
-            lambda gb: (
-                gb.double_col.expanding().mean().reset_index(drop=True, level=0)
-            ),
+            lambda gb: gb.double_col.expanding().mean().reset_index(drop=True, level=0),
             id=&quot;mean&quot;,
             marks=pytest.mark.notimpl([&quot;druid&quot;], raises=PyDruidProgrammingError),
         ),
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_window.py#L335'>ibis/backends/tests/test_window.py~L335</a></p>
<pre><code class="language-diff">     [
         param(
             lambda t, win: t.double_col.mean().over(win),
-            lambda df: (df.double_col.expanding().mean()),
+            lambda df: df.double_col.expanding().mean(),
             id=&quot;mean&quot;,
             marks=[
                 pytest.mark.notimpl(
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_window.py#L350'>ibis/backends/tests/test_window.py~L350</a></p>
<pre><code class="language-diff">             # Disabled on PySpark and Spark backends because in pyspark&lt;3.0.0,
             # Pandas UDFs are only supported on unbounded windows
             lambda t, win: mean_udf(t.double_col).over(win),
-            lambda df: (df.double_col.expanding().mean()),
+            lambda df: df.double_col.expanding().mean(),
             id=&quot;mean_udf&quot;,
             marks=[
                 pytest.mark.notimpl(
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_window.py#L538'>ibis/backends/tests/test_window.py~L538</a></p>
<pre><code class="language-diff">     [
         param(
             lambda t, win: t.double_col.mean().over(win),
-            lambda gb: (gb.double_col.transform(&quot;mean&quot;)),
+            lambda gb: gb.double_col.transform(&quot;mean&quot;),
             id=&quot;mean&quot;,
             marks=pytest.mark.notimpl([&quot;druid&quot;], raises=PyDruidProgrammingError),
         ),
         param(
             lambda t, win: mean_udf(t.double_col).over(win),
-            lambda gb: (gb.double_col.transform(&quot;mean&quot;)),
+            lambda gb: gb.double_col.transform(&quot;mean&quot;),
             id=&quot;mean_udf&quot;,
             marks=[
                 pytest.mark.notimpl(
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/test_window.py#L1192'>ibis/backends/tests/test_window.py~L1192</a></p>
<pre><code class="language-diff">     expected = (
         df.sort_values(&quot;int_col&quot;)
         .groupby(df[&quot;int_col&quot;].notnull())
-        .apply(lambda df: (df.int_col.rank(method=&quot;min&quot;).sub(1).div(len(df) - 1)))
+        .apply(lambda df: df.int_col.rank(method=&quot;min&quot;).sub(1).div(len(df) - 1))
         .T.reset_index(drop=True)
         .iloc[:, 0]
         .rename(expr.get_name())
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/tpc/ds/test_queries.py#L35'>ibis/backends/tests/tpc/ds/test_queries.py~L35</a></p>
<pre><code class="language-diff">         )
         .join(customer, _.ctr_customer_sk == customer.c_customer_sk)
         .filter(
-            lambda t: t.ctr_total_return
-            &gt; ctr2.filter(t.ctr_store_sk == ctr2.ctr_store_sk)
-            .ctr_total_return.mean()
-            .as_scalar()
-            * 1.2
+            lambda t: (
+                t.ctr_total_return
+                &gt; ctr2.filter(t.ctr_store_sk == ctr2.ctr_store_sk)
+                .ctr_total_return.mean()
+                .as_scalar()
+                * 1.2
+            )
         )
         .select(_.c_customer_id)
         .order_by(_.c_customer_id)
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/tpc/ds/test_queries.py#L783'>ibis/backends/tests/tpc/ds/test_queries.py~L783</a></p>
<pre><code class="language-diff">                 &gt; 0
             ),
             lambda t: (
-                web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
-                .filter(
-                    t.c_customer_sk == web_sales.ws_bill_customer_sk,
-                    _.d_year == 2002,
-                    _.d_moy.between(1, 1 + 3),
+                (
+                    web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
+                    .filter(
+                        t.c_customer_sk == web_sales.ws_bill_customer_sk,
+                        _.d_year == 2002,
+                        _.d_moy.between(1, 1 + 3),
+                    )
+                    .count()
+                    &gt; 0
                 )
-                .count()
-                &gt; 0
-            )
-            | (
-                catalog_sales.join(date_dim, [(&quot;cs_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
-                .filter(
-                    t.c_customer_sk == catalog_sales.cs_ship_customer_sk,
-                    _.d_year == 2002,
-                    _.d_moy.between(1, 1 + 3),
+                | (
+                    catalog_sales.join(date_dim, [(&quot;cs_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
+                    .filter(
+                        t.c_customer_sk == catalog_sales.cs_ship_customer_sk,
+                        _.d_year == 2002,
+                        _.d_moy.between(1, 1 + 3),
+                    )
+                    .count()
+                    &gt; 0
                 )
-                .count()
-                &gt; 0
             ),
         )
         .group_by(
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/tpc/ds/test_queries.py#L1037'>ibis/backends/tests/tpc/ds/test_queries.py~L1037</a></p>
<pre><code class="language-diff">             _.d_date.between(date(&quot;2002-02-01&quot;), date(&quot;2002-04-02&quot;)),
             _.ca_state == &quot;GA&quot;,
             _.cc_county == &quot;Williamson County&quot;,
-            lambda t: catalog_sales.filter(
-                t.cs_order_number == _.cs_order_number,
-                t.cs_warehouse_sk != _.cs_warehouse_sk,
-            ).count()
-            &gt; 0,
-            lambda t: catalog_returns.filter(
-                t.cs_order_number == _.cr_order_number
-            ).count()
-            == 0,
+            lambda t: (
+                catalog_sales.filter(
+                    t.cs_order_number == _.cs_order_number,
+                    t.cs_warehouse_sk != _.cs_warehouse_sk,
+                ).count()
+                &gt; 0
+            ),
+            lambda t: (
+                catalog_returns.filter(t.cs_order_number == _.cr_order_number).count()
+                == 0
+            ),
         )
         .agg(**{
             &quot;order count&quot;: _.cs_order_number.nunique(),
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/tpc/ds/test_queries.py#L2057'>ibis/backends/tests/tpc/ds/test_queries.py~L2057</a></p>
<pre><code class="language-diff">         item.view()
         .filter(
             _.i_manufact_id.between(738, 738 + 40),
-            lambda i1: item.filter(
-                lambda s: (
-                    (i1.i_manufact == s.i_manufact)
-                    &amp; (
-                        (
-                            (s.i_category == &quot;Women&quot;)
-                            &amp; s.i_color.isin((&quot;powder&quot;, &quot;khaki&quot;))
-                            &amp; s.i_units.isin((&quot;Ounce&quot;, &quot;Oz&quot;))
-                            &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
-                        )
-                        | (
-                            (s.i_category == &quot;Women&quot;)
-                            &amp; s.i_color.isin((&quot;brown&quot;, &quot;honeydew&quot;))
-                            &amp; s.i_units.isin((&quot;Bunch&quot;, &quot;Ton&quot;))
-                            &amp; s.i_size.isin((&quot;N/A&quot;, &quot;small&quot;))
-                        )
-                        | (
-                            (s.i_category == &quot;Men&quot;)
-                            &amp; s.i_color.isin((&quot;floral&quot;, &quot;deep&quot;))
-                            &amp; s.i_units.isin((&quot;N/A&quot;, &quot;Dozen&quot;))
-                            &amp; s.i_size.isin((&quot;petite&quot;, &quot;petite&quot;))
-                        )
-                        | (
-                            (s.i_category == &quot;Men&quot;)
-                            &amp; s.i_color.isin((&quot;light&quot;, &quot;cornflower&quot;))
-                            &amp; s.i_units.isin((&quot;Box&quot;, &quot;Pound&quot;))
-                            &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
-                        )
-                    )
-                )
-                | (
-                    (i1.i_manufact == s.i_manufact)
-                    &amp; (
+            lambda i1: (
+                item.filter(
+                    lambda s: (
                         (
-                            (s.i_category == &quot;Women&quot;)
-                            &amp; s.i_color.isin((&quot;midnight&quot;, &quot;snow&quot;))
-                            &amp; s.i_units.isin((&quot;Pallet&quot;, &quot;Gross&quot;))
-                            &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
-                        )
-                        | (
-                            (s.i_category == &quot;Women&quot;)
-                            &amp; s.i_color.isin((&quot;cyan&quot;, &quot;papaya&quot;))
-                            &amp; s.i_units.isin((&quot;Cup&quot;, &quot;Dram&quot;))
-                            &amp; s.i_size.isin((&quot;N/A&quot;, &quot;small&quot;))
-                        )
-                        | (
-                            (s.i_category == &quot;Men&quot;)
-                            &amp; s.i_color.isin((&quot;orange&quot;, &quot;frosted&quot;))
-                            &amp; s.i_units.isin((&quot;Each&quot;, &quot;Tbl&quot;))
-                            &amp; s.i_size.isin((&quot;petite&quot;, &quot;petite&quot;))
+                            (i1.i_manufact == s.i_manufact)
+                            &amp; (
+                                (
+                                    (s.i_category == &quot;Women&quot;)
+                                    &amp; s.i_color.isin((&quot;powder&quot;, &quot;khaki&quot;))
+                                    &amp; s.i_units.isin((&quot;Ounce&quot;, &quot;Oz&quot;))
+                                    &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
+                                )
+                                | (
+                                    (s.i_category == &quot;Women&quot;)
+                                    &amp; s.i_color.isin((&quot;brown&quot;, &quot;honeydew&quot;))
+                                    &amp; s.i_units.isin((&quot;Bunch&quot;, &quot;Ton&quot;))
+                                    &amp; s.i_size.isin((&quot;N/A&quot;, &quot;small&quot;))
+                                )
+                                | (
+                                    (s.i_category == &quot;Men&quot;)
+                                    &amp; s.i_color.isin((&quot;floral&quot;, &quot;deep&quot;))
+                                    &amp; s.i_units.isin((&quot;N/A&quot;, &quot;Dozen&quot;))
+                                    &amp; s.i_size.isin((&quot;petite&quot;, &quot;petite&quot;))
+                                )
+                                | (
+                                    (s.i_category == &quot;Men&quot;)
+                                    &amp; s.i_color.isin((&quot;light&quot;, &quot;cornflower&quot;))
+                                    &amp; s.i_units.isin((&quot;Box&quot;, &quot;Pound&quot;))
+                                    &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
+                                )
+                            )
                         )
                         | (
-                            (s.i_category == &quot;Men&quot;)
-                            &amp; s.i_color.isin((&quot;forest&quot;, &quot;ghost&quot;))
-                            &amp; s.i_units.isin((&quot;Lb&quot;, &quot;Bundle&quot;))
-                            &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
+                            (i1.i_manufact == s.i_manufact)
+                            &amp; (
+                                (
+                                    (s.i_category == &quot;Women&quot;)
+                                    &amp; s.i_color.isin((&quot;midnight&quot;, &quot;snow&quot;))
+                                    &amp; s.i_units.isin((&quot;Pallet&quot;, &quot;Gross&quot;))
+                                    &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
+                                )
+                                | (
+                                    (s.i_category == &quot;Women&quot;)
+                                    &amp; s.i_color.isin((&quot;cyan&quot;, &quot;papaya&quot;))
+                                    &amp; s.i_units.isin((&quot;Cup&quot;, &quot;Dram&quot;))
+                                    &amp; s.i_size.isin((&quot;N/A&quot;, &quot;small&quot;))
+                                )
+                                | (
+                                    (s.i_category == &quot;Men&quot;)
+                                    &amp; s.i_color.isin((&quot;orange&quot;, &quot;frosted&quot;))
+                                    &amp; s.i_units.isin((&quot;Each&quot;, &quot;Tbl&quot;))
+                                    &amp; s.i_size.isin((&quot;petite&quot;, &quot;petite&quot;))
+                                )
+                                | (
+                                    (s.i_category == &quot;Men&quot;)
+                                    &amp; s.i_color.isin((&quot;forest&quot;, &quot;ghost&quot;))
+                                    &amp; s.i_units.isin((&quot;Lb&quot;, &quot;Bundle&quot;))
+                                    &amp; s.i_size.isin((&quot;medium&quot;, &quot;extra large&quot;))
+                                )
+                            )
                         )
                     )
-                )
-            ).count()
-            &gt; 0,
+                ).count()
+                &gt; 0
+            ),
         )
         .select(_.i_product_name)
         .distinct()
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/tpc/ds/test_queries.py#L4491'>ibis/backends/tests/tpc/ds/test_queries.py~L4491</a></p>
<pre><code class="language-diff">         customer_total_return.join(customer, [(&quot;ctr_customer_sk&quot;, &quot;c_customer_sk&quot;)])
         .join(customer_address, [(&quot;c_current_addr_sk&quot;, &quot;ca_address_sk&quot;)])
         .filter(
-            lambda ctr1: ctr1.ctr_total_return
-            &gt; (
-                ctr2.filter(ctr1.ctr_state == _.ctr_state).ctr_total_return.mean() * 1.2
-            ).as_scalar(),
+            lambda ctr1: (
+                ctr1.ctr_total_return
+                &gt; (
+                    ctr2.filter(ctr1.ctr_state == _.ctr_state).ctr_total_return.mean()
+                    * 1.2
+                ).as_scalar()
+            ),
             _.ca_state == &quot;GA&quot;,
         )
         .select(
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/backends/tests/tpc/ds/test_queries.py#L4913'>ibis/backends/tests/tpc/ds/test_queries.py~L4913</a></p>
<pre><code class="language-diff">         .filter(
             _.i_manufact_id == 350,
             _.d_date.between(date(&quot;2000-01-07&quot;), date(&quot;2000-04-26&quot;)),
-            lambda t: t.ws_ext_discount_amt
-            &gt; (
-                web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
-                .filter(
-                    t.i_item_sk == _.ws_item_sk,
-                    _.d_date.between(date(&quot;2000-01-07&quot;), date(&quot;2000-04-26&quot;)),
+            lambda t: (
+                t.ws_ext_discount_amt
+                &gt; (
+                    web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
+                    .filter(
+                        t.i_item_sk == _.ws_item_sk,
+                        _.d_date.between(date(&quot;2000-01-07&quot;), date(&quot;2000-04-26&quot;)),
+                    )
+                    .ws_ext_discount_amt.mean()
+                    .as_scalar()
+                    * 1.3
                 )
-                .ws_ext_discount_amt.mean()
-                .as_scalar()
-                * 1.3
             ),
         )
         .select(_.ws_ext_discount_amt.sum().name(&quot;Excess Discount Amount&quot;))
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/tests/benchmarks/test_benchmarks.py#L692'>ibis/tests/benchmarks/test_benchmarks.py~L692</a></p>
<pre><code class="language-diff">     N = 20_000_000
 
     path = str(tmp_path_factory.mktemp(&quot;duckdb&quot;) / &quot;data.ddb&quot;)
-    sql = (
-        lambda var, table, n=N: f&quot;&quot;&quot;
+    sql = lambda var, table, n=N: (
+        f&quot;&quot;&quot;
         CREATE TABLE {table} AS
         SELECT ROW_NUMBER() OVER () AS id, {var}
         FROM (
</code></pre>
<p><a href='https://github.com/ibis-project/ibis/blob/9126733b38e1c92f6e787f92dc9954e88ab6400d/ibis/tests/expr/test_value_exprs.py#L926'>ibis/tests/expr/test_value_exprs.py~L926</a></p>
<pre><code class="language-diff">         operator.gt,
         operator.ge,
         lambda left, right: ibis.timestamp(&quot;2017-04-01 00:02:34&quot;).between(left, right),
-        lambda left, right: ibis.timestamp(&quot;2017-04-01&quot;)
-        .cast(dt.date)
-        .between(left, right),
+        lambda left, right: (
+            ibis.timestamp(&quot;2017-04-01&quot;).cast(dt.date).between(left, right)
+        ),
     ],
 )
 def test_string_temporal_compare(op, left, right):
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/langchain-ai/langchain">langchain-ai/langchain</a> (+46 -20 lines across 1 file)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L53'>libs/core/tests/unit_tests/runnables/test_history.py~L53</a></p>
<pre><code class="language-diff"> 
 def test_input_messages() -&gt; None:
     runnable = RunnableLambda(
-        lambda messages: &quot;you said: &quot;
-        + &quot;\n&quot;.join(str(m.content) for m in messages if isinstance(m, HumanMessage))
+        lambda messages: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(str(m.content) for m in messages if isinstance(m, HumanMessage))
+        )
     )
     store: dict = {}
     get_session_history = _get_get_session_history(store=store)
</code></pre>
<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L82'>libs/core/tests/unit_tests/runnables/test_history.py~L82</a></p>
<pre><code class="language-diff"> 
 async def test_input_messages_async() -&gt; None:
     runnable = RunnableLambda(
-        lambda messages: &quot;you said: &quot;
-        + &quot;\n&quot;.join(str(m.content) for m in messages if isinstance(m, HumanMessage))
+        lambda messages: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(str(m.content) for m in messages if isinstance(m, HumanMessage))
+        )
     )
     store: dict = {}
     get_session_history = _get_get_session_history(store=store)
</code></pre>
<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L113'>libs/core/tests/unit_tests/runnables/test_history.py~L113</a></p>
<pre><code class="language-diff"> 
 def test_input_dict() -&gt; None:
     runnable = RunnableLambda(
-        lambda params: &quot;you said: &quot;
-        + &quot;\n&quot;.join(
-            str(m.content) for m in params[&quot;messages&quot;] if isinstance(m, HumanMessage)
+        lambda params: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(
+                str(m.content)
+                for m in params[&quot;messages&quot;]
+                if isinstance(m, HumanMessage)
+            )
         )
     )
     get_session_history = _get_get_session_history()
</code></pre>
<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L133'>libs/core/tests/unit_tests/runnables/test_history.py~L133</a></p>
<pre><code class="language-diff"> 
 async def test_input_dict_async() -&gt; None:
     runnable = RunnableLambda(
-        lambda params: &quot;you said: &quot;
-        + &quot;\n&quot;.join(
-            str(m.content) for m in params[&quot;messages&quot;] if isinstance(m, HumanMessage)
+        lambda params: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(
+                str(m.content)
+                for m in params[&quot;messages&quot;]
+                if isinstance(m, HumanMessage)
+            )
         )
     )
     get_session_history = _get_get_session_history()
</code></pre>
<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L155'>libs/core/tests/unit_tests/runnables/test_history.py~L155</a></p>
<pre><code class="language-diff"> 
 def test_input_dict_with_history_key() -&gt; None:
     runnable = RunnableLambda(
-        lambda params: &quot;you said: &quot;
-        + &quot;\n&quot;.join(
-            [str(m.content) for m in params[&quot;history&quot;] if isinstance(m, HumanMessage)]
-            + [params[&quot;input&quot;]]
+        lambda params: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(
+                [
+                    str(m.content)
+                    for m in params[&quot;history&quot;]
+                    if isinstance(m, HumanMessage)
+                ]
+                + [params[&quot;input&quot;]]
+            )
         )
     )
     get_session_history = _get_get_session_history()
</code></pre>
<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L177'>libs/core/tests/unit_tests/runnables/test_history.py~L177</a></p>
<pre><code class="language-diff"> 
 async def test_input_dict_with_history_key_async() -&gt; None:
     runnable = RunnableLambda(
-        lambda params: &quot;you said: &quot;
-        + &quot;\n&quot;.join(
-            [str(m.content) for m in params[&quot;history&quot;] if isinstance(m, HumanMessage)]
-            + [params[&quot;input&quot;]]
+        lambda params: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(
+                [
+                    str(m.content)
+                    for m in params[&quot;history&quot;]
+                    if isinstance(m, HumanMessage)
+                ]
+                + [params[&quot;input&quot;]]
+            )
         )
     )
     get_session_history = _get_get_session_history()
</code></pre>
<p><a href='https://github.com/langchain-ai/langchain/blob/57ff48e62e5753de9200fe83adbdb5ac59587e29/libs/core/tests/unit_tests/runnables/test_history.py#L827'>libs/core/tests/unit_tests/runnables/test_history.py~L827</a></p>
<pre><code class="language-diff"> 
 def test_get_output_messages_no_value_error() -&gt; None:
     runnable = _RunnableLambdaWithRaiseError(
-        lambda messages: &quot;you said: &quot;
-        + &quot;\n&quot;.join(str(m.content) for m in messages if isinstance(m, HumanMessage))
+        lambda messages: (
+            &quot;you said: &quot;
+            + &quot;\n&quot;.join(str(m.content) for m in messages if isinstance(m, HumanMessage))
+        )
     )
     store: dict = {}
     get_session_history = _get_get_session_history(store=store)
</code></pre>
</p>
</details>
<details><summary><a href="https://github.com/mlflow/mlflow">mlflow/mlflow</a> (+6 -4 lines across 2 files)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href='https://github.com/mlflow/mlflow/blob/c0a2f87e7a6264f6fb356c1e40ff4e4e8b41d6a5/mlflow/store/model_registry/file_store.py#L895'>mlflow/store/model_registry/file_store.py~L895</a></p>
<pre><code class="language-diff">     def _list_file_model_versions_under_path(self, path) -&gt; list[FileModelVersion]:
       

... (truncated 1844 lines) ...

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-11 16:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/tests/snapshots/black_compatibility@cases__preview_long_strings.py.snap</code>:923 on 2025-11-11 16:39</div>
            <div class="timeline-body"><p>This seems bad.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/tests/snapshots/black_compatibility@cases__preview_long_strings.py.snap</code>:923 on 2025-11-11 18:51</div>
            <div class="timeline-body"><p>I think this was resolved by using the correct <code>Parenthesize</code> variant. In the rebase I replaced <code>IfBreaksOrIfRequired</code> with <code>IfBreaksParenthesized</code> but <code>IfBreaksParenthesizedNested</code> seems to be the better choice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-11 18:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-12 14:04</div>
            <div class="timeline-body"><pre><code class="language-diff">                  &gt; 0
             ),
             lambda t: (
-                web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
-                .filter(
-                    t.c_customer_sk == web_sales.ws_bill_customer_sk,
-                    _.d_year == 2002,
-                    _.d_moy.between(1, 1 + 3),
+                (
+                    web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
+                    .filter(
+                        t.c_customer_sk == web_sales.ws_bill_customer_sk,
+                        _.d_year == 2002,
+                        _.d_moy.between(1, 1 + 3),
+                    )
+                    .count()
+                    &gt; 0
                 )
-                .count()
-                &gt; 0
-            )
-            | (
-                catalog_sales.join(date_dim, [(&quot;cs_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
-                .filter(
-                    t.c_customer_sk == catalog_sales.cs_ship_customer_sk,
-                    _.d_year == 2002,
-                    _.d_moy.between(1, 1 + 3),
+                | (
+                    catalog_sales.join(date_dim, [(&quot;cs_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
+                    .filter(
+                        t.c_customer_sk == catalog_sales.cs_ship_customer_sk,
+                        _.d_year == 2002,
+                        _.d_moy.between(1, 1 + 3),
+                    )
+                    .count()
+                    &gt; 0
                 )
-                .count()
-                &gt; 0
             ),
         )
         .group_by(
</code></pre>
<p>this looks unfortunate</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-11-12 14:19</div>
            <div class="timeline-body"><p>This actually seems okay to me? There are two large elements being unioned together, and I think nesting them in another set of parens makes it more clear that they're both in the same lambda. At first I thought I had just added an extra set of parens.</p>
<p>The formatted:</p>
<pre><code class="language-py">lambda t: (
    (
        web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
        .filter(
            t.c_customer_sk == web_sales.ws_bill_customer_sk,
            _.d_year == 2002,
            _.d_moy.between(1, 1 + 3),
        )
        .count()
        &gt; 0
    )
    | (
        catalog_sales.join(date_dim, [(&quot;cs_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
        .filter(
            t.c_customer_sk == catalog_sales.cs_ship_customer_sk,
            _.d_year == 2002,
            _.d_moy.between(1, 1 + 3),
        )
        .count()
        &gt; 0
    )
),
</code></pre>
<p>and unformatted code for comparison:</p>
<pre><code class="language-py">lambda t: (
    web_sales.join(date_dim, [(&quot;ws_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
    .filter(
        t.c_customer_sk == web_sales.ws_bill_customer_sk,
        _.d_year == 2002,
        _.d_moy.between(1, 1 + 3),
    )
    .count()
    &gt; 0
)
| (
    catalog_sales.join(date_dim, [(&quot;cs_sold_date_sk&quot;, &quot;d_date_sk&quot;)])
    .filter(
        t.c_customer_sk == catalog_sales.cs_ship_customer_sk,
        _.d_year == 2002,
        _.d_moy.between(1, 1 + 3),
    )
    .count()
    &gt; 0
),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-12 14:43</div>
            <div class="timeline-body"><p>Oh, I guess I don't like the parentheses around the union elements but they were already present before</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-11-12 15:33</div>
            <div class="timeline-body"><p>I reverted the indentation changes and tried throwing in <code>RemoveSoftLinesBuffer</code>. It was rearranging trailing comments on the parameters, so I just skipped the new format if there are <em>any</em> comments present for now, but I assume there's a better approach here, possibly the arbitrary line length you mentioned on Discord.</p>
<p>But the current state of this branch at least resolves the initial deviation from Black reported in https://github.com/astral-sh/ruff/issues/8179.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-12 15:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@expression__lambda.py.snap</code>:2016 on 2025-11-12 15:35</div>
            <div class="timeline-body"><p>Wrapping the body here is a bit silly since the <code>(</code> and the <code>d</code> have the same length. But this seems like it should be quite rare in real code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-11-12 17:18</div>
            <div class="timeline-body"><h3>Ecosystem results</h3>
<p>Most of them look good with a few exceptions:</p>
<ul>
<li><p><a href="https://github.com/apache/airflow/blob/0534b90db660d6815be28d7d4b086b4c87df8995/providers/google/tests/unit/google/cloud/hooks/test_gcs.py#L420">providers/google/tests/unit/google/cloud/hooks/test_gcs.py~L420</a></p>
<pre><code class="language-diff">         mock_copy.return_value = storage.Blob(
             name=destination_object_name, bucket=storage.Bucket(mock_service, destination_bucket_name)
         )
-        mock_service.return_value.bucket.side_effect = lambda name: (
-            source_bucket
-            if name == source_bucket_name
-            else storage.Bucket(mock_service, destination_bucket_name)
+        mock_service.return_value.bucket.side_effect = (
+            lambda name: (
+                source_bucket
+                if name == source_bucket_name
+                else storage.Bucket(mock_service, destination_bucket_name)
+            )
         )

         self.gcs_hook.copy(
</code></pre>
<p>It seems like this should have been fine before? The very last astropy example is like this too.</p>
</li>
<li><p><a href="https://github.com/apache/airflow/blob/0534b90db660d6815be28d7d4b086b4c87df8995/providers/http/tests/unit/http/sensors/test_http.py#L302">providers/http/tests/unit/http/sensors/test_http.py~L302</a></p>
<pre><code class="language-diff">             method=&quot;GET&quot;,
             endpoint=&quot;/search&quot;,
             data={&quot;client&quot;: &quot;ubuntu&quot;, &quot;q&quot;: &quot;airflow&quot;},
-            response_check=lambda response: (&quot;apache/airflow&quot; in response.text),
+            response_check=lambda response: &quot;apache/airflow&quot; in response.text,
             headers={},
         )
         op.execute({})
</code></pre>
<p>I think this is okay, just worth pointing out that we also remove parentheses if the body doesn't wrap.</p>
</li>
<li><p><a href="https://github.com/apache/superset/blob/0b535b792e9bf95dd72f4d9a98a49fbfc04b23f8/tests/unit_tests/importexport/api_test.py#L48">tests/unit_tests/importexport/api_test.py~L48</a></p>
<pre><code class="language-diff">     mocked_export_result = [
         (
             &quot;metadata.yaml&quot;,
-            lambda: &quot;version: 1.0.0\ntype: assets\ntimestamp: '2022-01-01T00:00:00+00:00'\n&quot;,  # noqa: E501
+            lambda: (
+                &quot;version: 1.0.0\ntype: assets\ntimestamp: '2022-01-01T00:00:00+00:00'\n&quot;
+            ),  # noqa: E501
         ),
         (&quot;databases/example.yaml&quot;, lambda: &quot;&lt;DATABASE CONTENTS&gt;&quot;),
     ]
</code></pre>
<p>This seems bad, it breaks the noqa comment (although it also fixes E501 in this case). Maybe this is expected, there's another case where we move the noqa comment in the stable formatting</p>
  <details><summary>Here</summary>

<ul>
<li><a href="https://github.com/rotki/rotki/blob/d3afc02b022c19c4a85984d758e28a9f0dfa1fea/rotkehlchen/rotkehlchen.py#L617">rotkehlchen/rotkehlchen.py~L617</a></li>
</ul>
<pre><code class="language-diff">                         ]
                     },  # noqa: E501
                 ),
-                extra_check_callback=lambda: cursor.execute(
-                    &quot;SELECT COUNT(*) FROM user_added_solana_tokens&quot;
-                ).fetchone()[0]
-                &gt; 0,  # noqa: E501
+                extra_check_callback=lambda: (
+                    cursor.execute(&quot;SELECT COUNT(*) FROM user_added_solana_tokens&quot;).fetchone()[0]
+                    &gt; 0
+                ),  # noqa: E501
             )

     def _logout(self) -&gt; None:
</code></pre>
  </details>

</li>
<li><p><a href="https://github.com/ibis-project/ibis/blob/bb42a6bd090c5c500ca86303f37bfd66d05767c7/ibis/tests/benchmarks/test_benchmarks.py#L693">ibis/tests/benchmarks/test_benchmarks.py~L693</a></p>
<pre><code class="language-diff">     path = str(tmp_path_factory.mktemp(&quot;duckdb&quot;) / &quot;data.ddb&quot;)
     sql = (
-        lambda var, table, n=N: f&quot;&quot;&quot;
+        lambda var, table, n=N: (
+            f&quot;&quot;&quot;
         CREATE TABLE {table} AS
         SELECT ROW_NUMBER() OVER () AS id, {var}
         FROM (
</code></pre>
<p>This seems a bit questionable. The <code>f&quot;&quot;&quot;</code> feels like it could take the place of parentheses.</p>
</li>
<li><p><a href="https://github.com/rotki/rotki/blob/d3afc02b022c19c4a85984d758e28a9f0dfa1fea/rotkehlchen/chain/solana/node_inquirer.py#L354">rotkehlchen/chain/solana/node_inquirer.py~L354</a></p>
<pre><code class="language-diff">         signatures = []
         while True:
             response: GetSignaturesForAddressResp = self.query(
-                method=lambda client,
-                _before=before,
-                _until=until: client.get_signatures_for_address(  # type: ignore[misc]  # noqa: E501
+                method=lambda client, _before=before, _until=until: client.get_signatures_for_address(  # type: ignore[misc]  # noqa: E501
                     account=Pubkey.from_string(address),
                     limit=SIGNATURES_PAGE_SIZE,
                     before=_before,
</code></pre>
<p>This case actually seems to be what the project wants because of the <code>noqa</code> comment, but I'm pretty sure this line is just over their configured line length of 99. Maybe the <code>has_own_parentheses</code> check is too lax here?</p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[WIP] Indent lambda parameters if parameters wrap" to "[WIP] Keep lambda parameters on one line and parenthesize the body if it expands" by @ntBre on 2025-11-12 17:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[WIP] Keep lambda parameters on one line and parenthesize the body if it expands" to "Keep lambda parameters on one line and parenthesize the body if it expands" by @ntBre on 2025-11-14 13:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-11-14 13:54</div>
            <div class="timeline-body"><p>Not sure this is exactly ready for review, but the code itself seems fine and I'm curious to get some thoughts on the ecosystem results in https://github.com/astral-sh/ruff/pull/21385#issuecomment-3523043238. I think the results look good overall.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-11-14 13:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @ntBre on 2025-11-14 13:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @amyreese by @MichaReiser on 2025-11-14 13:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-14 15:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@expression__lambda.py.snap</code>:1690 on 2025-11-14 15:06</div>
            <div class="timeline-body"><p>The wrapping here is unfortunate. But it's probably not worth special casing, given that it's a very contrived exmaple</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-14 15:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@expression__lambda.py.snap</code>:1707 on 2025-11-14 15:06</div>
            <div class="timeline-body"><p>This feels worse</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-14 15:09</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/apache/airflow/blob/0534b90db660d6815be28d7d4b086b4c87df8995/providers/google/tests/unit/google/cloud/hooks/test_gcs.py#L420">providers/google/tests/unit/google/cloud/hooks/test_gcs.py~L420</a></p>
</blockquote>
<p>Yeah, this one looks just wrong</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-14 15:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@expression__lambda.py.snap</code>:1707 on 2025-11-14 15:17</div>
            <div class="timeline-body"><p>Ah yeah, this is like the case I flagged in https://github.com/astral-sh/ruff/pull/21385#discussion_r2518795764. But this also seems pretty contrived to me. It seems very unlikely to have a long lambda with a single-character body where the <code>(</code> and body are the same length. Unless you think it would be worse for a longer name too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-14 15:28</div>
            <div class="timeline-body"><p>I think you want to experiment with hitting this branch</p>
<p>https://github.com/astral-sh/ruff/blob/32d7d52d2af7591cf0d03c01aee319693b54cfb3/crates/ruff_python_formatter/src/expression/parentheses.rs#L196-L205</p>
<p>To improve formatting of</p>
<pre><code>def test():
    def more():
        mock_service.return_value.bucket.side_effect = lambda name: (
            source_bucket
            if name == source_bucket_name
            else storage.Bucket(mock_service, destination_bucket_name)
         )
</code></pre>
<p>I don't remember the exact semantics but the idea would be to fit the entire lambda in a <code>fits_expanded</code>. I haven't thought it through carefully of what the implication of this is for lambda usages in other places than assignments</p>
<p>Edit: Not the entire lambda, only the body part</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @ntBre on 2025-11-18 19:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-11-19 17:54</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/brent%2Findent-lambda-params?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a></h2>
<h3>Merging #21385 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>brent/indent-lambda-params</code> (95301b3) with <code>main</code> (3ac58b4)</sub></p>
<h3>Summary</h3>
<p><code>✅ 30</code> untouched<br />
<code>⏩ 22</code> skipped[^skipped]</p>
<p>[^skipped]: 22 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/brent%2Findent-lambda-params?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Keep lambda parameters on one line and parenthesize the body if it expands" to "Parenthesize long lambda bodies" by @ntBre on 2025-11-20 17:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Parenthesize long lambda bodies" to "Keep lambda parameters on one line and parenthesize the body if it expands" by @ntBre on 2025-11-20 17:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-11-20 23:06</div>
            <div class="timeline-body"><p>I still see at least one problem in the ecosystem report, but the results are looking better, and I rebased to clean up the history a bit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-21 07:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:99 on 2025-11-21 07:34</div>
            <div class="timeline-body"><p>Can you try <code>parenthesized</code> instead of <code>optional_parentheses</code>.</p>
<pre><code class="language-suggestion">                    fits_expanded(&amp;parenthesized(&quot;(&quot;, &amp;body.format(), &quot;)&quot;)).fmt(f)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-21 20:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:99 on 2025-11-21 20:03</div>
            <div class="timeline-body"><p>It looks like this always parenthesizes the body, one example:</p>
<pre><code class="language-diff">#### Preview changes            
```diff                         
--- Stable                      
+++ Preview                     
@@ -23,8 +23,8 @@               
     pass                       
                                
                                
-x1 = lambda y: 1               
-x2 = lambda y,: 1              
+x1 = lambda y: (1)             
+x2 = lambda y,: (1)            
                                
 # Ignore trailing comma.       
 with a:  # magic trailing comma
</code></pre>
<p>I also tried inverting the order (<code>optional_parentheses(fits_expanded(...))</code>) like we talked about, but it then doesn't wrap the f-string case:</p>
<pre><code class="language-diff">-msg = lambda x: (                                                                                       
-    f&quot;this is a very very very very long lambda value {x} that doesn't fit on a single line&quot;            
-)                                                                                                       
+msg = lambda x: f&quot;this is a very very very very long lambda value {x} that doesn't fit on a single line&quot;
</code></pre>
<p>That seems to be the only test failure, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-21 20:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:1 on 2025-11-21 20:09</div>
            <div class="timeline-body"><p>Oh no, I thought I had reverted this, but I must have missed it in the rebase. I guess I'm not as close as I thought.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-22 13:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:99 on 2025-11-22 13:58</div>
            <div class="timeline-body"><p>ah sorry, I meant <code>parenthesize_if_expands</code></p>
<p>We can't use <code>fits_expanded</code> because it's causing this weird wrapping here where the binary expression continues on the same line</p>
<pre><code class="language-patch">         # If it has been indicated that the user wants the interpolator, construct
         # an anonymous function to handle units and sanitize IO
         if return_interpolator:
-            return (
-                lambda x: np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
-            )
+            return lambda x: np.exp(
+                cs(np.log(x.to(u.MeV).value))
+            ) * u.MeV * u.cm**2 / u.g
 
         return (
             energies,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-11-22 14:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:99 on 2025-11-22 14:38</div>
            <div class="timeline-body"><p>Ahh, thank you! That's the case I added in the last commit and looked at yesterday. I'll try <code>parenthesize_if_expands</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-01 17:21</div>
            <div class="timeline-body"><p>Thanks again for the <code>parenthesize_if_expands</code> suggestion, that cleaned up the ecosystem issue you pointed out.</p>
<p>The other ecosystem changes now look good to me, with the exception of the last two cases I mentioned before in https://github.com/astral-sh/ruff/pull/21385#issuecomment-3523043238, which I've now added as tests. These get formatted like this:</p>
<pre><code class="language-py">class C:
    def foo():
        if True:
            transaction_count = self._query_txs_for_range(
                get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: db_evmtx.count_transactions_in_range(
                    chain_id=_chain_id,
                    from_ts=from_ts,
                    to_ts=to_ts,
                ),
            )

def ddb():
    sql = lambda var, table, n=N: (
        f&quot;&quot;&quot;
        CREATE TABLE {table} AS
        SELECT ROW_NUMBER() OVER () AS id, {var}
        FROM (
            SELECT {var}
            FROM RANGE({n}) _ ({var})
            ORDER BY RANDOM()
        )
        &quot;&quot;&quot;
    )
</code></pre>
<p>where the lambda body in the first case exceeds the configured line length, and in the second case, I would expect not to have an extra set of parentheses around the f-string. In other words I would expect this output:</p>
<pre><code class="language-py">class C:
    def foo():
        if True:
            transaction_count = self._query_txs_for_range(
                get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: (
                    db_evmtx.count_transactions_in_range(
                        chain_id=_chain_id,
                        from_ts=from_ts,
                        to_ts=to_ts,
                    )
                ),
            )

def ddb():
    sql = lambda var, table, n=N: f&quot;&quot;&quot;
        CREATE TABLE {table} AS
        SELECT ROW_NUMBER() OVER () AS id, {var}
        FROM (
            SELECT {var}
            FROM RANGE({n}) _ ({var})
            ORDER BY RANDOM()
        )
    &quot;&quot;&quot;
</code></pre>
<p>with this diff between the two:</p>
<pre><code class="language-diff">5,8c5,10
&lt;                 get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: db_evmtx.count_transactions_in_range(
&lt;                     chain_id=_chain_id,
&lt;                     from_ts=from_ts,
&lt;                     to_ts=to_ts,
---
&gt;                 get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: (
&gt;                     db_evmtx.count_transactions_in_range(
&gt;                         chain_id=_chain_id,
&gt;                         from_ts=from_ts,
&gt;                         to_ts=to_ts,
&gt;                     )
14,15c16
&lt;     sql = lambda var, table, n=N: (
&lt;         f&quot;&quot;&quot;
---
&gt;     sql = lambda var, table, n=N: f&quot;&quot;&quot;
23,24c24
&lt;         &quot;&quot;&quot;
&lt;     )
---
&gt;     &quot;&quot;&quot;
</code></pre>
<p>I'm kind of okay with both of these, and vaguely remember that we might have already discussed them too. In the first case, the project already has <code>noqa: E501</code> comments, so I think this is actually the formatting they want, and in the latter case we at least don't add any extra parentheses compared to the <a href="https://play.ruff.rs/9eaba5d4-44aa-43c6-a946-d5dd494624c7?secondary=Format">stable formatting</a>, which parenthesizes the whole lambda.</p>
<p>But the f-string case also (naively) seems easier to fix than the call, which <code>has_own_parentheses</code> returns <code>Some</code> for.</p>
<p>So this may be ready for review again, depending on how we want to handle those cases and if my changes to <code>ParenthesizeIfExpands</code> are acceptable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amyreese">@amyreese</a> on 2025-12-01 17:57</div>
            <div class="timeline-body"><p>Personally I actually prefer parentheses around the f-string in your example, because that allows the opening quotes to match indentation of the closing quotes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 09:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:1 on 2025-12-02 09:51</div>
            <div class="timeline-body"><p>Can you revert those changes before opening this for review?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:106 on 2025-12-02 09:52</div>
            <div class="timeline-body"><p>I think this should be the other way round</p>
<pre><code class="language-suggestion">                    parenthesize_if_expands(&amp;fits_expanded(&amp;body.format())).fmt(f)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 09:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 09:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:424 on 2025-12-02 09:53</div>
            <div class="timeline-body"><p>Hmm, <code>maybe_parenthesize_expression</code> shouldn't contain any expression specific formattingl Can you say more why this change is necessary?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 09:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:312 on 2025-12-02 09:54</div>
            <div class="timeline-body"><p>We shouldn't use <code>maybe_parenthesize_expression</code> if we see a lambda, instead, call the lambda formatting directly.</p>
<p>Just make sure you add some tests for when the lambda is parenthesized and has comments</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:1 on 2025-12-02 14:08</div>
            <div class="timeline-body"><p>I've tried reverting this a couple of times, but it introduces instability in at least these cases:</p>
<pre><code class="language-diff">       if True:
           if True:
               return lambda x: (
  -                    np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
  -                )
  +                np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
  +            )
   
   
   class C:
  @@ -361,7 +361,7 @@
   
   def ddb():
       sql = lambda var, table, n=N: (
  -            f&quot;&quot;&quot;
  +        f&quot;&quot;&quot;
           CREATE TABLE {table} AS
           SELECT ROW_NUMBER() OVER () AS id, {var}
           FROM (
  @@ -370,4 +370,4 @@
               ORDER BY RANDOM()
           )
           &quot;&quot;&quot;
  -        )
  +    )
</code></pre>
<p>So I will have to find a different way to avoid that if we want to revert this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-02 14:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-02 14:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:106 on 2025-12-02 14:10</div>
            <div class="timeline-body"><p>Swapping them without other changes introduces a syntax error:</p>
<pre><code>       --&gt; /home/brent/astral/ruff/crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py:342:13
        |
    340 |             * u.MeV
    341 |             * u.cm**2
    342 |             / u.g
        |             ^
        |
</code></pre>
<p>on this snippet:</p>
<pre><code class="language-py">def foo():
    if True:
        if True:
            return (
                lambda x: np.exp(cs(np.log(x.to(u.MeV).value))) * u.MeV * u.cm**2 / u.g
            )
</code></pre>
<p>This is the output:</p>
<pre><code class="language-py">    def foo():
        if True:
            if True:
                return lambda x: np.exp(cs(np.log(x.to(u.MeV).value)))
                * u.MeV
                * u.cm**2
                / u.g
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-02 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:424 on 2025-12-02 14:12</div>
            <div class="timeline-body"><p>I was trying to propagate the <code>Layout</code> setting from the assignment formatting, which doesn't format the lambda directly. It calls <code>maybe_parenthesize_expression</code> first.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-02 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:312 on 2025-12-02 14:12</div>
            <div class="timeline-body"><p>Ah okay, this probably resolves your other question about why I was doing this in the first place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-02 17:24</div>
            <div class="timeline-body"><p>I &quot;fixed&quot; (see below) the call formatting by excluding both call and subscript expressions from the <code>has_own_parentheses</code> check; and inlined the lambda formatting from <code>maybe_parenthesize_expression</code> into the assignment formatting and reverted the <code>maybe_parenthesize_expression</code> changes. I also added a few new tests (I tried to get Claude to suggest even more, but they didn't look very interesting beyond what we had already).</p>
<p>For some reason the ecosystem comment isn't updating, but I downloaded the report, and there are actually many more changes now as a result of the <code>has_own_parentheses</code> check. I think we're now wrapping call arguments too eagerly. Here's one example:</p>
<pre><code class="language-diff">             if self.location in EVM_EVMLIKE_LOCATIONS and database is not None:
                 # call _maybe_add_label_with_address on each address in the note
                 exported_dict[&quot;notes&quot;] = EVM_ADDRESS_REGEX.sub(
-                    repl=lambda matched_address: self._maybe_add_label_with_address(
-                        database=database,
-                        matched_address=matched_address,
+                    repl=lambda matched_address: (
+                        self._maybe_add_label_with_address(
+                            database=database,
+                            matched_address=matched_address,
+                        )
                     ),
                     string=exported_dict[&quot;notes&quot;],  # type: ignore [call-overload]  # exported_dict['notes'] is always a string
                 )
</code></pre>
<p>The initial code is only 83 columns wide. Is that desirable, or do I need to try to find a more careful check? I think I would lean toward reverting this change and accepting the occasional overly-long lambda header, if these are our only two choices. That was much, much less common in the ecosystem, and the cases with many parameters plus a long callable seemed to be intentionally formatted that way in the original code.</p>
<hr>

<p>As noted above, I believe the changes to <code>parenthesize_if_expands</code> are necessary to avoid instability. This is probably the clearest example, which came up earlier:</p>
<pre><code class="language-diff"> msg = lambda x: (                                                                               
-        f&quot;this is a very very very very long lambda value {x} that doesn't fit on a single line&quot;
-    )                                                                                           
+    f&quot;this is a very very very very long lambda value {x} that doesn't fit on a single line&quot;    
+)                                                                                               
</code></pre>
<p>Note the indented parenthesis in the first format (the <code>-</code> lines). This is from the unconditional <code>soft_block_indent</code> in the old version of <code>parenthesize_if_expands</code>. I think using <code>indent_if_group_breaks</code> like we do in <code>optional_parentheses</code> is correct, and I haven't seen any non-lambda changes in the ecosystem report.</p>
<p>Of course, I could be missing a better way to avoid this, so I'm happy to revisit it, but I currently believe it to be necessary, in contrast to what I said initially (https://github.com/astral-sh/ruff/pull/21385#discussion_r2550845179).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-02 19:08</div>
            <div class="timeline-body"><p>I'll take a look tomorrow. I want to understand why the lambda doesn't get wrapped in that instance. Might it just be that we hit a case where <code>needs_parentheses</code> returns <code>Never</code> here</p>
<p>https://github.com/astral-sh/ruff/blob/95c61deb8a9a42e8c9a8626f98d440ffb7652ea5/crates/ruff_python_formatter/src/expression/expr_attribute.rs#L196</p>
<p>And all that we need to change (using <code>maybe_parenthesize_expression</code> again) is to change <code>needs_parentheses</code> of call expression formatting to return <code>BestFit</code> or <code>Multiline</code> if it is the body of a lambda expression? Same for subscript?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:59 on 2025-12-02 19:15</div>
            <div class="timeline-body"><p>Use write</p>
<pre><code class="language-suggestion">                        write!(f, [
                        	if_group_breaks(&amp;token(&quot;(&quot;)).
                        	Arguments::from(&amp;self.inner);
                        	if_group_breaks(&amp;token(&quot;)&quot;))
                      	])?;
                    }
</code></pre>
<p>We only use <code>.fmt</code> when formatting a single item</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 19:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 19:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:34 on 2025-12-02 19:16</div>
            <div class="timeline-body"><p>We should avoid creating the id if <code>self.indent</code> is false. We should also use a better unique name</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:40 on 2025-12-02 19:17</div>
            <div class="timeline-body"><p>We're now adding two groups. One outer group here and an inner group within <code>self.indent</code>. This seems wrong to me and extra groups can be very costly</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 19:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-02 20:47</div>
            <div class="timeline-body"><blockquote>
<p>I'll take a look tomorrow. I want to understand why the lambda doesn't get wrapped in that instance. Might it just be that we hit a case where <code>needs_parentheses</code> returns <code>Never</code> here</p>
<p>https://github.com/astral-sh/ruff/blob/95c61deb8a9a42e8c9a8626f98d440ffb7652ea5/crates/ruff_python_formatter/src/expression/expr_attribute.rs#L196</p>
<p>And all that we need to change (using <code>maybe_parenthesize_expression</code> again) is to change <code>needs_parentheses</code> of call expression formatting to return <code>BestFit</code> or <code>Multiline</code> if it is the body of a lambda expression? Same for subscript?</p>
</blockquote>
<p>I looked into this briefly by debugging the return value of <code>ExprCall::needs_parentheses</code> for the case above, and it was already returning <code>BestFit</code> via the recursive <code>self.func.needs_parentheses</code> branch.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-02 21:08</div>
            <div class="timeline-body"><p>Oh, I just realized you meant in the original code when it wasn't wrapping the long one. I'll check that too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-03 09:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:96 on 2025-12-03 09:18</div>
            <div class="timeline-body"><p>What's the reason we skip over expressions that are parenthesized? This has the issue that the new formatting style isn't reversible in the sense that Ruff might introduce new parentheses but will fail to remove the parentheses once they're no longer needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-03 10:03</div>
            <div class="timeline-body"><p>Looking at</p>
<pre><code>class C:
    def foo():
        if True:
            transaction_count = self._query_txs_for_range(
                get_count_fn=lambda from_ts, to_ts, _chain_id=chain_id: db_evmtx.count_transactions_in_range(
                    chain_id=_chain_id,
                    from_ts=from_ts,
                    to_ts=to_ts,
                ),
            )
</code></pre>
<p>Which gives you the following IR:</p>
<pre><code>		...
		&quot;self._query_txs_for_range(&quot;,
          fits_expanded(propagate_expand: true, condition: if_group_fits_on_line(&quot;#optional_parentheses-2&quot;), [
            group(expand: propagated, [
              indent([
                soft_line_break,
                group(expand: propagated, [
                  &quot;get_count_fn=lambda &quot;,
                  group([&quot;from_ts, to_ts, _chain_id=chain_id&quot;]),
                  &quot;: db_evmtx.count_transactions_in_range(&quot;,
                  group(expand: propagated, [
                    indent([
                      soft_line_break,
                      group(expand: propagated, [
                        &quot;chain_id=_chain_id,&quot;,
                        soft_line_break_or_space,
                        &quot;from_ts=from_ts,&quot;,
                        soft_line_break_or_space,
                        &quot;to_ts=to_ts&quot;,
                        if_group_breaks([&quot;,&quot;]),
                        expand_parent
                      ])
                    ]),
                    soft_line_break
                  ]),
                  &quot;)&quot;,
                  if_group_breaks([&quot;,&quot;]),
                  expand_parent
                ])
              ]),
              soft_line_break
            ])
          ]),
		  ...
</code></pre>
<p>The important IR element is <code>&quot;: db_evmtx.count_transactions_in_range(&quot;,</code>, note how the formatter doesn't emit the IR for optionally parenthesizing the lambda body. It always assumes that it never needs parentheses. This suggests that <code>ExprCall::needs_parentheses</code> returns <code>Never</code>. I worry that we'll have the same problem with many other expressions that return <code>Never</code> because they don't want to be parenthesized in a clause header, but we now use <code>maybe_parenthesize_expression</code> in a context where we still want to parenthesize those expressions. While we can try to fix them up, to me it feels as if we're mixing concerns here and using <code>maybe_parenthesize_expression</code> here might not be a good idea after all. It's also the first use of <code>maybe_parenthesize_expression</code> within a nested expression (ignoring <code>await</code> and <code>yield</code> which are often used like statements.</p>
<p>Overall, this doesn't give me confidence that using <code>maybe_parenthesize_expression</code> is the right tool here. It's tempting to use it here because it almost gives us what we want, but without us understanding why it works (or even knowing what exactly we want?).</p>
<p>Thinking through the body formatting logic:</p>
<ul>
<li>If the item has its own parentheses (ignoring subscript and call), we should never add parentheses unless the value requires it because it has leading or trailing comments, but I think that <code>Expr::format</code> already handles this for us. Therefore, we can simply call <code>body.format</code> without adding any parentheses in that case</li>
<li>For all other expressions other than subscript and call, we simply use <code>parenthesize_if_expands(body.format)</code> (ignoring the assignment formatting for now)</li>
<li>Now, Subscript and <code>Call</code> are tricky, because we only want to add parentheses if the part coming before the <code>(</code> doesn't fit. I would expect that we can use <code>fits_expanded</code>, the same as we do for the assignment case but this doesn't seem to work for reasons I don't fully understand. A simplified version of the case is:<pre><code class="language-py">lambda from_ts, to_ts, _chain_id=chain_id: db_evmtx.count_(
    chain_id=_chain_id,
    from_ts=from_ts,
    to_ts=to_ts
)
</code></pre>
</li>
</ul>
<p>After debugging printer, the issue is that <code>fits_expanded</code> only prevents splitting <code>parameters</code> if splitting the <code>db_evmtx.count_</code> prevents makes the expression fit on a single line. But what we need is that the call expression formatting adds a <code>fits_expanded</code> around its call arguments so that we don't parenthesize <code>db_evmtx.count_(</code> if expanding the arguments make the expression fit. Luckily, <code>FormatCallExpr</code> supports just that if the lambda body uses <code>optional_parentheses</code> instead of <code>parenthesize_if_expands</code>.</p>
<p>Changing the formatting logic to the following almost gives us what we want:</p>
<pre><code class="language-rust">        if is_parenthesize_lambda_bodies_enabled(f.context()) {
            let fmt_body = format_with(|f| {
                if matches!(&amp;**body, Expr::Call(_) | Expr::Subscript(_)) {
                    optional_parentheses(
                        &amp;body
                            .format()
                            .with_options(crate::expression::parentheses::Parentheses::Never),
                    )
                    .fmt(f)
                } else if has_own_parentheses(body, f.context()).is_some() {
                    // We probably need to be more careful here and preserve parentheses
                    body.format().fmt(f)
                } else {
                    // Can we always use `optional_parentheses`?
                    parenthesize_if_expands(
                        &amp;body
                            .format()
                            .with_options(crate::expression::parentheses::Parentheses::Never),
                    )
                    .fmt(f)
                }
            });

            match self.layout {
                ExprLambdaLayout::Assignment =&gt; fits_expanded(&amp;fmt_body).fmt(f),
                ExprLambdaLayout::Default =&gt; fmt_body.fmt(f),
            }
        } else {
            body.format().fmt(f)
        }
</code></pre>
<p>However, this doesn't play nicely with lambdas nested within other expressions:</p>
<pre><code>    ────────────────────────────────────────────────────────────────────────────────
    -old snapshot
    +new results
    ────────────┬───────────────────────────────────────────────────────────────────
      206   206 │ +).casefold() == ([]).unicodedata.normalize(&quot;NFKCNFKCNFKCNFKCNFKC&quot;, s2).casefold()
      207   207 │
      208   208 │  return await self.http_client.fetch(
      209   209 │      f&quot;http://127.0.0.1:{self.port}{path}&quot;,
            210 │+@@ -88,6 +88,6 @@
            211 │+     )
            212 │+ )
            213 │+
            214 │+-response = await sync_to_async(
            215 │+-    lambda: self.django_handler.get_response(request), thread_sensitive=True
            216 │+-)()
            217 │++response = await sync_to_async(lambda: self.django_handler.get_response(
            218 │++        request
            219 │++    ), thread_sensitive=True)()
      210   220 │ ```
    ────────────┴───────────────────────────────────────────────────────────────────
</code></pre>
<p>The printer now sees that everything up to the <code>(</code> of the <code>get_response</code> call expression fits, so that we don't indent the body of <code>sync_to_async</code>. But that's obviously not what we want. We want the formatter to indent the call argument, but not the lambda body.</p>
<p>Even when using <code>maybe_parenthesize_expression</code>, there are cases where the formatter breaks before the opening <code>(</code>, because it doesn't use <code>OptionalParentheses::Never</code> (the subscript could break:</p>
<pre><code class="language-py">class C:
    def foo():
        if True:
            transaction_count = self._query_txs_for_range(
                lambda from_ts, to_ts, _chain_id=chain_id: (
                    db_evmtex[more].call(
                        chain_id=_chain_id,
                        from_ts=from_ts,
                        to_ts=to_ts,
                    )
                ),
            )
</code></pre>
<p>I'm not sure what the solution here is and I now need to switch to other work but I don't think we've figured that one out yet</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-03 10:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:309 on 2025-12-03 10:52</div>
            <div class="timeline-body"><p>I'm pretty sure <code>can_omit_optional_parentheses</code> always returns <code>False</code> for a lambda expression</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-03 11:10</div>
            <div class="timeline-body"><p>I think this mostly works? We should avoid using <code>best_fitting</code> where we can but here might be an okay enough use case.</p>
<p>Search for some other usages of <code>best_fitting</code> to see what checks we normally perform to bail early if it isn't strictly necessary.</p>
<p>An alternative would be to implement the <code>Marker</code> feature that we talked about a few weeks ago but I think we can re-visit this separately and I don't think performance will suffer to much, given that lambdas tend to be rare.</p>
<pre><code class="language-rust">        if is_parenthesize_lambda_bodies_enabled(f.context()) {
            let fmt_body = format_with(|f| {
                if matches!(&amp;**body, Expr::Call(_) | Expr::Subscript(_)) {
                    let body = body
                        .format()
                        .with_options(crate::expression::parentheses::Parentheses::Never)
                        .memoized();

                    best_fitting![
                        // body all flat
                        body,
                        // body expanded
                        body,
                        // parenthesized
                        format_args![token(&quot;(&quot;), block_indent(&amp;body), token(&quot;)&quot;)]
                    ]
                    .fmt(f)
                } else if has_own_parentheses(body, f.context()).is_some() {
                    // We probably need to be more careful here and preserve parentheses if there are comments?
                    body.format().fmt(f)
                } else {
                    parenthesize_if_expands(
                        &amp;body
                            .format()
                            .with_options(crate::expression::parentheses::Parentheses::Never),
                    )
                    .fmt(f)
                }
            });

            match self.layout {
                // Can we move the `fits_expanded` into the assignment formatting?
                ExprLambdaLayout::Assignment =&gt; fits_expanded(&amp;fmt_body).fmt(f),
                ExprLambdaLayout::Default =&gt; fmt_body.fmt(f),
            }
        } else {
            body.format().fmt(f)
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 14:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:96 on 2025-12-03 14:04</div>
            <div class="timeline-body"><p>That was for another instability/duplicate parentheses. Here's one example instability after removing it:</p>
<pre><code class="language-diff"> msg = lambda x: (                                                                               
-    f&quot;this is a very very very very long lambda value {x} that doesn't fit on a single line&quot;    
+    (                                                                                           
+        f&quot;this is a very very very very long lambda value {x} that doesn't fit on a single line&quot;
+    )                                                                                           
 )                                                                                               
</code></pre>
<p>Maybe that's another sign this isn't the right approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-03 14:51</div>
            <div class="timeline-body"><p>Wow, thank you! That patch does seem to resolve everything. I'm still looking at the other uses of <code>best_fitting</code> to see how we could bail out early. Are there supposed to be two different entries for the flat and expanded cases here:</p>
<pre><code class="language-rust">                    best_fitting![
                        // body all flat
                        body,
                        // body expanded
                        body,
                        // parenthesized
                        format_args![token(&quot;(&quot;), block_indent(&amp;body), token(&quot;)&quot;)]
                    ]
</code></pre>
<p>or should I just delete one of them? Everything seems to work either way, at least on our current test cases.</p>
<p>You also fixed a Black deviation in the multi-line string preview style!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 19:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:309 on 2025-12-03 19:26</div>
            <div class="timeline-body"><p>I threw a <code>panic!</code> in this branch, and it's definitely being entered. Not sure under what conditions, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-03 20:28</div>
            <div class="timeline-body"><p>Hopefully I'm not missing anything too obvious, but the ecosystem check now looks great to me. A couple of long lines stuck out, but I checked with the projects' configuration, and they were within the configured <code>line-length</code>. So it all looks good.</p>
<p>I looked at the other uses of <code>best_fitting!</code> and didn't see any great ways for us to bail out earlier, maybe just if <code>unparenthesized</code> won't break? I think we could just use the unparenthesized formatting in that case.</p>
<p>I'll mark this ready for review in any case, hopefully that's just a minor point. Thanks Micha yet again for all of the help!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-12-03 20:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-03 21:53</div>
            <div class="timeline-body"><p>We should add a lot more tests (unless they already exist in some form) for different comment placement, including combinations where the body or lambda are parenthesized (and for every special case branch that we have)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:1 on 2025-12-03 21:54</div>
            <div class="timeline-body"><p>Do we still need this 😅?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:110 on 2025-12-03 21:58</div>
            <div class="timeline-body"><p>Let's add some documentation to those branches. What's the intended formatting for each of them, eg. For this brmach, the idea is to never add parantheses for expressions that start with a parentheses</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:111 on 2025-12-03 22:00</div>
            <div class="timeline-body"><p>Why do we need the contains_comments branch here? If so, I would expect that we need to parenthesize the expression if there are comments.</p>
<p>Contains_commments is also too aggressive. A call-argument comment shouldn't change the layout.</p>
<p>I suggest removing this branch, add tests, then add the minimal necessary comment handling (and documment it)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:120 on 2025-12-03 22:01</div>
            <div class="timeline-body"><p>Can we move this into the assignment formatting instead?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/preview.rs</code>:66 on 2025-12-03 22:01</div>
            <div class="timeline-body"><p>Do we need both?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:309 on 2025-12-03 22:06</div>
            <div class="timeline-body"><p>I would like to understand when it takes this branch and if it's indeed necessary.</p>
<p>Or is it the opposite and the lambda formatting always takes this branch?</p>
<p>I know it's annoying to narrow this all down but it will be much harder to understand for someone who has to change this code in the future. That's why it's important that the formatting code is as minimal as possible</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2025-12-03 22:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-03 22:09</div>
            <div class="timeline-body"><p>We have a lot of tests in this file, including with comments in various places. And I didn't bump into anything very interesting when sprinkling more comments into the assignment cases, but I can try injecting more again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/builders.rs</code>:1 on 2025-12-03 22:10</div>
            <div class="timeline-body"><p>Yes, just tried reverting it again, and the formatting is still unstable without it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:120 on 2025-12-03 22:12</div>
            <div class="timeline-body"><p>I wrote this in my commit message for https://github.com/astral-sh/ruff/pull/21385/commits/7dddcc85bc1e3c291e6ea1df1a2e65b91ea34f6b when I deleted your comment, but I don't think we can:</p>
<blockquote>
<p>I don't think we can move the <code>fits_expanded</code> call into the assignment
formatting because that would wrap the whole lambda in a <code>fits_expanded</code>, when we
just want to wrap the lambda body in it instead. if I understand correctly, we'd
need to duplicate basically this whole function to inject <code>fits_expanded</code> in the
right place for the lambda formatting in assignments</p>
</blockquote>
<p>I could be missing something obviously.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:309 on 2025-12-03 22:15</div>
            <div class="timeline-body"><p>It panics in the other branch too. I just copied these branches from inside of <code>maybe_parenthesize_expression</code> when I moved the layout out of it. I'll try to narrow it down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:111 on 2025-12-03 22:17</div>
            <div class="timeline-body"><p>I added this to fix a couple of existing tests altered by the <code>best_fitting</code> changes in https://github.com/astral-sh/ruff/pull/21385/commits/6f6c09c72a1ce0b7adf5d46744d1e50d02463d46. It makes sense that it's too aggressive, I'll try to narrow it down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-03 22:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-03 22:17</div>
            <div class="timeline-body"><p>It's not just about assignment. We also need tests for all sort of combinations between comments and parenthesized bodies (but maybe they all exist already? I'm on my phone and can't check it)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-03 22:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:120 on 2025-12-03 22:18</div>
            <div class="timeline-body"><p>I don't think that makes a difference because the header never breaks? Have you tried it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-03 22:19</div>
            <div class="timeline-body"><p>I probably phrased that poorly. I just meant nothing went wrong in the assignment cases, so I kind of assumed all comment placement was handled well. I will try injecting more comments into various (non-assignment) cases again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-03 22:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:120 on 2025-12-03 22:24</div>
            <div class="timeline-body"><p>I tried it just now with this patch:</p>
<pre><code class="language-diff">-                        let lambda = lambda.format().with_options(ExprLambdaLayout::Assignment);
+                        let lambda_format = lambda.format();
+                        let lambda = fits_expanded(&amp;lambda_format);
</code></pre>
<p>and it caused this syntax error:</p>
<pre><code>    error[internal-error]: Expected an expression
      --&gt; /home/brent/astral/ruff/crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py:57:24
       |
    55 | # Trailing
    56 |
    57 | a = lambda:  # Dangling
       |                        ^
    58 | 1
       |
</code></pre>
<p>Maybe that's the wrong approach, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @ntBre on 2025-12-04 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-04 08:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:309 on 2025-12-04 08:28</div>
            <div class="timeline-body"><p>The comment here might be relevant. Does the formatting change if you remove the optional_parantheses case and how?</p>
<p>https://github.com/astral-sh/ruff/blob/main/crates/ruff_python_formatter/src/expression/mod.rs (on my phone, go to can_omit_optional_parentheses and there's a long lambda related comment. Could we remove the lambda special casing in preview?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-04 08:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:120 on 2025-12-04 08:30</div>
            <div class="timeline-body"><p>I see. Lambda headers can split if they contain comments. Thanks for trying</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-04 14:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/preview.rs</code>:66 on 2025-12-04 14:49</div>
            <div class="timeline-body"><p>No, I think not. I forgot we discussed not landing the two separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:309 on 2025-12-04 15:38</div>
            <div class="timeline-body"><p>Ah thank you, yes that comment seems very relevant. I tried removing the <code>optional_parentheses</code> branches, and a couple example snapshot failures include:</p>
<pre><code class="language-diff">-        mock_service.return_value.bucket.side_effect = lambda name: (     
-            source_bucket                                                 
-            if name == source_bucket_name                                 
-            else storage.Bucket(mock_service, destination_bucket_name)    
+        mock_service.return_value.bucket.side_effect = (                  
+            lambda name: (                                                
+                source_bucket                                             
+                if name == source_bucket_name                             
+                else storage.Bucket(mock_service, destination_bucket_name)
+            )                                                             
</code></pre>
<p>and</p>
<pre><code class="language-diff"> class C:                                                                         
-    _is_recognized_dtype: Callable[[DtypeObj], bool] = lambda x: lib.is_np_dtype(
-        x, &quot;M&quot;                                                                   
-    ) or isinstance(x, DatetimeTZDtype)                                          
+    _is_recognized_dtype: Callable[[DtypeObj], bool] = (                         
+        lambda x: lib.is_np_dtype(x, &quot;M&quot;) or isinstance(x, DatetimeTZDtype)      
+    )                                                                            
</code></pre>
<p>just like the comment said. But yes, it seems safe to skip this in preview with no snapshot changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-04 15:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-04 16:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:111 on 2025-12-04 16:49</div>
            <div class="timeline-body"><p>The two cases that changed before I added this were these:</p>
<pre><code class="language-diff">-lambda: (  # comment 1 
+lambda: (
+    # comment 1
     x                 
 )                     
                       
@@ -184,7 +167,8 @@    
                       
 (                     
     lambda:  # comment
-    (  # comment 2 
+    (
+        # comment 2
         x             
     )                 
 )                     
</code></pre>
<p>with these inputs:</p>
<pre><code class="language-py">lambda: ( # comment 1
    x)

(
    lambda:  # comment
    (  # comment 2
        x
    )
)
</code></pre>
<p>So I think the narrower condition is something like &quot;has a leading, end-of-line comment within the already-parenthesized body.&quot;</p>
<p>Instead of checking comments, we could also use <code>is_expression_parenthesized</code> here. That avoids these comment changes too, but it will preserve unnecessary parentheses in cases like this:</p>
<pre><code class="language-py">lambda xxxxxxxxxxxxxxxxxxxx: (xxxxxxxxxxxxxxxxxxxx + 1)
</code></pre>
<p>Are we supposed to be removing those? It came up pretty often in the ecosystem check too. I thought it looked nicer to remove them, but maybe we're not supposed to remove parentheses the user included in the input.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-04 17:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:111 on 2025-12-04 17:59</div>
            <div class="timeline-body"><blockquote>
<p>Are we supposed to be removing those? It came up pretty often in the ecosystem check too. I thought it looked nicer to remove them, but maybe we're not supposed to remove parentheses the user included in the input.</p>
</blockquote>
<p>Yes, we're supposed to remove unnecessary parentheses in instances where they might have been introduced by the formatter before. This is important for the formatting to be reversible, something we try all our formatting styles to adhere to (with the exception of `skip-magic-trailing-comma)</p>
<p>I think what you want here is to test if there's any leading or trailing comment on <code>x</code>, and if so, call <code>body.format().with_options(Parentheses::Always)</code>. Similar to what we have here https://github.com/astral-sh/ruff/blob/bc6331200163546b5db19d04444e51c38db05a3e/crates/ruff_python_formatter/src/expression/mod.rs#L380-L382</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-04 23:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-04 23:02</div>
            <div class="timeline-body"><p>I added a bunch of additional tests, with some help from Claude admittedly. I tried to edit down the redundant ones, but I'm not sure I've captured everything you had in mind. The main interesting cases in the new tests involve dangling comments on the lambda header, which end up outside the body parentheses:</p>
<pre><code class="language-diff"> (
     lambda name:
     # dangling header comment
-    source_bucket
-    if name == source_bucket_name
-    else storage.Bucket(mock_service, destination_bucket_name)
+    (
+        source_bucket
+        if name == source_bucket_name
+        else storage.Bucket(mock_service, destination_bucket_name)
+    )
 )
</code></pre>
<p>instead of something more like this:</p>
<pre><code class="language-py">(
    lambda name: (
        # leading comment
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)
</code></pre>
<p>but I think this is pretty reasonable and consistent with our unary comment formatting? (This is reminding me a bit of #21501.)</p>
<p>Calls are maybe slightly more awkward since they don't end up parenthesized in this case at all:</p>
<pre><code class="language-py">(
    lambda from_ts, to_ts, _chain_id=chain_id:
    # dangling header comment before call
    db_evmtx.count_transactions_in_range(
        chain_id=_chain_id,
        from_ts=from_ts,
        to_ts=to_ts,
    )
)
</code></pre>
<p>This isn't a diff because it doesn't get reformatted. This is the same as our stable formatting.</p>
<p>Another case is a comment within the parameter list. This somewhat obviously prevents collapsing the parameter list to a single line:</p>
<pre><code class="language-diff"> foo(
     lambda from_ts,  # comment prevents collapsing the parameters to one line
-    to_ts, _chain_id=chain_id: db_evmtx.count_transactions_in_range(
+    to_ts,
+    _chain_id=chain_id: db_evmtx.count_transactions_in_range(
         chain_id=_chain_id,
         from_ts=from_ts,
         to_ts=to_ts,
</code></pre>
<p>I don't really have a better idea here, but it seemed worth pointing out. Black relocates the comment to the end of the line so that it can join the parameters, but I don't think we want to do that.</p>
<p>I did confirm that we will still wrap and parenthesize the body if it gets too long, at least:</p>
<pre><code class="language-diff"> foo(
     lambda from_ts,  # but still wrap the body if it gets too long
     to_ts,
-    _chain_id=chain_id: db_evmtx.count_transactions_in_rangeeeeeeeeeeeeeeeeeeeeeeeeeeeee(
-        chain_id=_chain_id,
-        from_ts=from_ts,
-        to_ts=to_ts,
+    _chain_id=chain_id: (
+        db_evmtx.count_transactions_in_rangeeeeeeeeeeeeeeeeeeeeeeeeeeeee(
+            chain_id=_chain_id,
+            from_ts=from_ts,
+            to_ts=to_ts,
+        )
     )
 )
</code></pre>
<p>I also haven't found any test cases where the <code>body_comments.has_trailing_own_line()</code> has any effect. However, deleting that part in the <code>maybe_parenthesize_expression</code> code where I copied mine from also doesn't change any snapshots, for whatever that's worth.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-05 07:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:144 on 2025-12-05 07:19</div>
            <div class="timeline-body"><p>We probably want to make this the first condition as it doesn't make sense to use <code>best_fitting</code> if we know the body has comments</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-05 07:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-05 07:26</div>
            <div class="timeline-body"><p>That's a great find. Let's improve our dangling comment formatting and I'm leaning towards always using the <code>parenthesize_if_expands</code> layout in that case (for all nodes). I hope that this shouldn't be too hard, given that we already have dangling comment formatting in <code>ExprLambda</code>.</p>
<pre><code class="language-py">(
     lambda name: # dangling header comment    
    (
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)

# Format to, includding call and subscript expressions
(
     lambda name: ( # dangling header comment    
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)


(
    lambda from_ts, to_ts, _chain_id=chain_id: # dangling header comment
    db_evmtx.count_transactions_in_range(
        chain_id=_chain_id,
        from_ts=from_ts,
        to_ts=to_ts,
    )
)

(
    lambda from_ts, to_ts, _chain_id=chain_id: (  # dangling header comment
        db_evmtx.count_transactions_in_range(
            chain_id=_chain_id,
            from_ts=from_ts,
            to_ts=to_ts,
        )
    )
)

# Do the same for dangling lambda header parameters
(
    lambda # dangling header comment
    from_ts, to_ts, _chain_id=chain_id:
    db_evmtx.count_transactions_in_range(
        chain_id=_chain_id,
        from_ts=from_ts,
        to_ts=to_ts,
    )
)

# Formats to
(
    lambda from_ts, to_ts, _chain_id=chain_id: ( # dangling header comment
        db_evmtx.count_transactions_in_range(
            chain_id=_chain_id,
            from_ts=from_ts,
            to_ts=to_ts,
        )
    )
)
    
# For in-between body:
(
    lambda name: 
    # leading comment
    (
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)

# What we have seems fine, but I could also see us always parenthesizing the value and moving
# formatting it before the body expression
(
    lambda name: 
    (
        # leading comment
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)
</code></pre>
<p>Placing end-of-line comments at the end of the line makes more sense now, where we flatten the lambda header.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-05 14:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-05 14:50</div>
            <div class="timeline-body"><p>I think I got the dangling comments working, besides the ones interspersed with parameters. Those seem a bit trickier because they change whether the lambda needs to be parenthesized. I'm running into an instability with my first naive pass, but I'll keep looking. It was pretty nice to bail out of the parameter flattening if there were any comments :laughing: but I agree that this would look better if we can get it to work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-05 15:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:456 on 2025-12-05 15:08</div>
            <div class="timeline-body"><blockquote>
<p>It was pretty nice to bail out of the parameter flattening if there were any comments</p>
</blockquote>
<p>We can still bail if there are any comments within <code>Parameters</code>. I just think we shouldn't if there are comments after the <code>lambda</code>, before the body</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-05 15:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-05 15:27</div>
            <div class="timeline-body"><p>You only want to add <code>(</code> if the expression breaks (which I think isn't necessarily the case if you only have dangling end of line comments). If the expression is guaranteed to always break, use <code>block_indent</code> over <code>soft_block_indent</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-05 15:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-05 15:30</div>
            <div class="timeline-body"><p>Don't we need a line break after the dangling comment, which will always make the expression break? I might be thinking about this the wrong way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-05 16:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-05 16:39</div>
            <div class="timeline-body"><p>Not necessarily: It could get flattened to:</p>
<pre><code class="language-py"># input 
a = (
	lambda # comment
	x: body
)

a = lambda x: body # comment
</code></pre>
<p>The formatter doesn't immediately flush end-of-line comments. Instead, they're queued up and only rendered when the formatter hits a line break. You can force the formatter to emit comments sooner by writing a <code>line_suffix_boundary</code> (which can be useful if you don't want comments from wandering off)</p>
<p>Now, whether this is the desired formatting is a separate discussion (I think it makes sense to flatten if we can)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-05 16:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-05 16:41</div>
            <div class="timeline-body"><p>Oh boy, okay. I guess I have to figure out this instability since that changes whether the whole thing is parenthesized too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-05 16:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-05 16:49</div>
            <div class="timeline-body"><p>Oh your example is still between the lambda and its parameters, so that's the same instability I mentioned above. I've only handled cases like this so far:</p>
<pre><code class="language-py">(
     lambda name: # dangling header comment    
    (
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)

# Format to, includding call and subscript expressions
(
     lambda name: ( # dangling header comment    
        source_bucket
        if name == source_bucket_name
        else storage.Bucket(mock_service, destination_bucket_name)
    )
)
</code></pre>
<p>Where the dangling comments are <em>after</em> the parameters, and we want to move them into the parenthesized body.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-05 21:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-05 21:44</div>
            <div class="timeline-body"><p>I think if we want to move any comments before parameters, we would also have to move parameter comments. There's a tricky preexisting test case:</p>
<pre><code class="language-py">(
    lambda # comment 1
    * # comment 2
    x: # comment 3
    x
)
</code></pre>
<p><code>comment 2</code> is initially a parameter comment, but our <a href="https://play.ruff.rs/71a14e0e-4202-4caf-910c-c4c42c58078b">stable</a> formatting moves it to be a dangling lambda comment:</p>
<pre><code class="language-py">(
    lambda  # comment 1
    # comment 2
    *x:  # comment 3
    x
)
</code></pre>
<p>This is causing trouble in our partitioning logic because I was trying to restrict our dangling comment formatting to cases without comments in the parameters, but the initial check for comments in parameters is true, so we leave <code>comment 2</code> alone, but on a second formatting, &quot;comments in parameters&quot; is false, and we try to format it with the dangling logic.</p>
<p>We have a similar problem if we don't check for comments in parameters and move the dangling comments unconditionally. On the first format, we change the order, and then the second format still tries to move comment 2 again:</p>
<pre><code class="language-diff"> (                            
-    lambda # comment 2       
-    *x: (                    
+    lambda *x: (  # comment 2
         # comment 1          
         # comment 3          
         x                    
</code></pre>
<p>I got the other comment instabilities worked out, though, so I can take another look at this too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-08 18:22</div>
            <div class="timeline-body"><p>Alright, I may have gone overboard on moving comments around, but I got something working. We now format the case above like this:</p>
<pre><code class="language-py">(
    lambda *x: (  # comment 1  # comment 2  # comment 3
        x
    )
)
</code></pre>
<p>instead of our stable style:</p>
<pre><code class="language-py">(
    lambda  # comment 1
    *x:  # comment 2
    # comment 3
    x
)
</code></pre>
<p>and closer to Black's style:</p>
<pre><code class="language-py">(lambda *x: x)  # comment 1  # comment 2  # comment 3
</code></pre>
<p>I think I've resolved all of the other comments, this was just working on our dangling comment formatting, which we also discussed in <a href="https://github.com/astral-sh/ruff/pull/21385#discussion_r2586735153">this thread</a>. I tried to mark most of the older comments as resolved to clean up the discussion somewhat.</p>
<p>I think there's a small change to our stable formatting of lambda header comments in e8540d9b08, but I didn't see any other <code>preview</code> checks in the comment placement code. I'm happy to look further into that, but it also seems like a pretty niche case and won't affect any code that we've formatted previously because our stable formatting already converts the affected comment kind into a dangling comment, as I noted above. There are also no ecosystem changes as a result of the dangling comment commits.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-08 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-09 00:16</div>
            <div class="timeline-body"><p>I guess I'll mark this ready for review again. As noted above (https://github.com/astral-sh/ruff/pull/21385#discussion_r2599665225) I'm not super confident in the new comment changes, but I think the previous round of feedback has been resolved and that this could use another look.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-12-09 00:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-09 10:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:153 on 2025-12-09 10:50</div>
            <div class="timeline-body"><p>It seems unfortunate that this two branches are now the same except for what the dangling comments are. I think we should create a <code>FormatBody</code> struct that implements <code>Format</code> that we can use in both branches</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-09 11:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-09 11:11</div>
            <div class="timeline-body"><p>Hmm, yeah this goes too far. As explained on previous PRs, we try to always preserve the comment position: Comments that are end-of-line comments should remain end-of-line comments and own-line comments should remain own-line comments. Your formatting violates this principle.</p>
<p>This diff preserves our existing formatting closer but it also requires your changes in <code>placement.rs</code></p>
<pre><code class="language-diff">use ruff_formatter::{FormatRuleWithOptions, RemoveSoftLinesBuffer, format_args, write};
use ruff_python_ast::{AnyNodeRef, Expr, ExprLambda};
use ruff_text_size::Ranged;
use ruff_python_trivia::SimpleTokenizer;
use ruff_text_size::{Ranged, TextRange};

use crate::builders::parenthesize_if_expands;
use crate::comments::{dangling_comments, leading_comments, trailing_comments};
use crate::expression::parentheses::{NeedsParentheses, OptionalParentheses, Parentheses};
use crate::expression::parentheses::{
    NeedsParentheses, OptionalParentheses, Parentheses, is_expression_parenthesized,
};
use crate::expression::{CallChainLayout, has_own_parentheses};
use crate::other::parameters::ParametersParentheses;
use crate::prelude::*;
        } = item;

        let body = &amp;**body;
        let parameters = parameters.as_deref();

        let comments = f.context().comments().clone();
        let dangling = comments.dangling(item);
        let preview = is_parenthesize_lambda_bodies_enabled(f.context());

        if let Some(parameters) = parameters {
            let parameters_have_comments = comments.contains_comments(parameters.as_ref().into());
            let parameters_have_comments = comments.contains_comments(parameters.into());

            // In this context, a dangling comment can either be a comment between the `lambda` and the
            // parameters, or a comment between the parameters and the body.
            let (dangling_before_parameters, dangling_after_parameters) =
                // To prevent an instability in cases like:
                //
                // ```py
                // (
                //     lambda # comment 1
                //     * # comment 2
                //     x: # comment 3
                //     x
                // )
                // ```
                //
                // `# comment 1` and `# comment 2` also become dangling comments on the lambda, so
                // in preview, we include these in `dangling_after_parameters`, as long as the
                // parameter list doesn't include any additional comments.
                //
                // This ends up formatted as:
                //
                // ```py
                // (
                //     lambda *x: (  # comment 1  # comment 2  # comment 3
                //         x
                //     )
                // )
                // ```
                //
                // instead of the stable formatting:
                //
                // ```py
                // (
                //     lambda  # comment 1
                //     *x:  # comment 2
                //     # comment 3
                //     x
                // )
                // ```
                if preview &amp;&amp; !parameters_have_comments {
                    ([].as_slice(), dangling)
                } else {
                    dangling.split_at(
                        dangling.partition_point(|comment| comment.end() &lt; parameters.start()),
                    )
                };
            let (dangling_before_parameters, dangling_after_parameters) = dangling
                .split_at(dangling.partition_point(|comment| comment.end() &lt; parameters.start()));

            let (end_of_line_lambda_keyword_comments, leading_parameter_comments) = if preview {
                dangling_before_parameters.split_at(
                    dangling_before_parameters
                        .iter()
                        .position(|comment| comment.line_position().is_own_line())
                        .unwrap_or(dangling_before_parameters.len()),
                )
            } else {
                ([].as_slice(), dangling_before_parameters)
            };

            // To prevent an instability in cases like:
            //
            // ```py
            // (
            //     lambda # comment 1
            //     * # comment 2
            //     x: # comment 3
            //     x
            // )
            // ```
            //
            // `# comment 1` and `# comment 2` also become dangling comments on the lambda, so
            // in preview, we include these in `dangling_after_parameters`, as long as the
            // parameter list doesn't include any additional comments.
            //
            // This ends up formatted as:
            //
            // ```py
            // (
            //     lambda *x: (  # comment 1  # comment 2  # comment 3
            //         x
            //     )
            // )
            // ```
            //
            // instead of the stable formatting:
            //
            // ```py
            // (
            //     lambda  # comment 1
            //     *x:  # comment 2
            //     # comment 3
            //     x
            // )
            // ```

            trailing_comments(end_of_line_lambda_keyword_comments).fmt(f)?;

            if dangling_before_parameters.is_empty() {
            if leading_parameter_comments.is_empty() &amp;&amp; !comments.has_leading(parameters) {
                write!(f, [space()])?;
            } else {
                write!(f, [dangling_comments(dangling_before_parameters)])?;
                write!(
                    f,
                    [
                        hard_line_break(),
                        leading_comments(leading_parameter_comments)
                    ]
                )?;
            }

            // Try to keep the parameters on a single line, unless there are intervening comments.
                //
                // and alternate between own line and end of line.
                let (dangling_end_of_line, dangling_own_line) = dangling_after_parameters.split_at(
                    dangling_after_parameters
                        .iter()
                        .position(|comment| comment.line_position().is_own_line())
                        .unwrap_or(dangling_after_parameters.len()),
                );
                let (after_parameters_end_of_line, leading_body_comments) =
                    dangling_after_parameters.split_at(
                        dangling_after_parameters
                            .iter()
                            .position(|comment| comment.line_position().is_own_line())
                            .unwrap_or(dangling_after_parameters.len()),
                    );

                let fmt_body = format_with(|f: &amp;mut PyFormatter| {
                    write!(
                            space(),
                            token(&quot;(&quot;),
                            trailing_comments(dangling_end_of_line),
                            trailing_comments(after_parameters_end_of_line),
                            block_indent(&amp;format_args!(
                                leading_comments(dangling_own_line),
                                leading_comments(leading_body_comments),
                                body.format().with_options(Parentheses::Never)
                            )),
                            token(&quot;)&quot;)

        if preview {
            let body_comments = comments.leading_dangling_trailing(&amp;**body);
            let body_comments = comments.leading_dangling_trailing(body);
            let fmt_body = format_with(|f: &amp;mut PyFormatter| {
                // If the body has comments, we always want to preserve the parentheses. This also
                // ensures that we correctly handle parenthesized comments, and don't need to worry
                // )
                // ```
                else if matches!(&amp;**body, Expr::Call(_) | Expr::Subscript(_)) {
                else if matches!(body, Expr::Call(_) | Expr::Subscript(_)) {
                    let unparenthesized = body.format().with_options(Parentheses::Never);
                    if CallChainLayout::from_expression(
                        body.into(),

(
    lambda  # comment 1
    lambda
    # comment 1
    *x:  # comment 2
    # comment 3
    x

(
    lambda  # 1
    lambda
    # 1
    # 2
    x:  # 3
    # 4

(
    lambda  # 1
    lambda
    # 1
    # 2
    x,  # 3
    # 4

(
    lambda  # comment
    lambda
    # comment
    *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs)
    + 1
)

(
    lambda  # comment 1
    lambda
    # comment 1
    # comment 2
    *args, **kwargs:  # comment 3
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1

(
    lambda  # comment 1
    lambda
    # comment 1
    *args, **kwargs:  # comment 3
    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
)

(
    lambda  # 1
    lambda
    # 1
    # 2
    left,  # 3
    # 4
     pass
 
@@ -102,58 +83,63 @@
@@ -102,22 +83,25 @@
 
 # Dangling comments without parameters.
 (
 
 (
-    lambda
-    # comment
-    *x: x
+    lambda *x: (
+        # comment
+        x
+    )
 )
 
 (
-    lambda
-    # comment
-    *x, **y: x
+    lambda *x, **y: (
+        # comment
+        x
+    )
 )
 
@@ -135,18 +119,17 @@
 (
-    lambda
-    # comment 1
     lambda
     # comment 1
-    *x:
-    # comment 2
-    # comment 3
-    x
+    lambda *x: (
+        # comment 1
+    *x: (
+        # comment 2
+        # comment 3
+        x
 
 (
-    lambda  # comment 1
-    lambda
-    # comment 1
-    *x:  # comment 2
-    # comment 3
-    x
 
 lambda *x: x
 
 (
-    lambda
-    # comment
-    *x: x
+    lambda *x: (
+        # comment
+        x
+    )
 )
 
 lambda: (  # comment
@@ -161,42 +147,47 @@
@@ -162,54 +145,58 @@
 )
 
 (
 
 (
-    lambda  # 1
-    # 2
-    lambda
-    # 1
+    lambda  # 1
     # 2
-    x:  # 3
-    # 4
-    # 5
-    # 6
-    x
+    lambda x: (  # 1
+        # 2
+        # 3
+    x: (  # 3
+        # 4
+        # 5
+        # 6
 
 (
@@ -204,9 +195,10 @@
-    lambda
-    # 1
+    lambda  # 1
     # 2
     x,  # 3
     # 4
 
 (
@@ -218,71 +210,79 @@
@@ -221,71 +208,79 @@
 
 # Leading
 lambda x: (
 
 # Regression tests for https://github.com/astral-sh/ruff/issues/8179
@@ -291,9 +291,9 @@
@@ -294,9 +289,9 @@
         c,
         d,
         e,
 
 
@@ -302,15 +302,9 @@
@@ -305,15 +300,9 @@
         c,
         d,
         e,
     )
 
@@ -320,9 +314,9 @@
@@ -323,9 +312,9 @@
         c,
         d,
         e,
 
 
@@ -338,9 +332,9 @@
@@ -341,9 +330,9 @@
 
 class C:
     function_dict: Dict[Text, Callable[[CRFToken], Any]] = {
 
 
@@ -352,42 +346,40 @@
@@ -355,42 +344,40 @@
 def foo():
     if True:
         if True:
         SELECT ROW_NUMBER() OVER () AS id, {var}
         FROM (
@@ -402,18 +394,19 @@
@@ -405,18 +392,19 @@
 long_assignment_target.with_attribute.and_a_slice[with_an_index] = (
     # 1
     # 2
 
 very_long_variable_name_x, very_long_variable_name_y = (
@@ -421,8 +414,8 @@
@@ -424,8 +412,8 @@
     lambda b: b * another_very_long_expression_here,
 )
 
     )
 )
@@ -458,12 +451,12 @@
@@ -461,12 +449,12 @@
     [
         # Not fluent
         param(
         param(
             lambda left, right: (
@@ -472,9 +465,9 @@
@@ -475,9 +463,9 @@
         ),
         param(lambda left, right: ibis.timestamp(&quot;2017-04-01&quot;).cast(dt.date)),
         param(
         # This is too long on one line in the lambda body and gets wrapped
         # inside the body.
@@ -508,16 +501,18 @@
@@ -511,16 +499,18 @@
 ]
 
 # adds parentheses around the body
 lambda x, y, z: (
     x + y + z
@@ -528,7 +523,7 @@
@@ -531,7 +521,7 @@
     x + y + z  # trailing eol body
 )
 
 lambda x, y, z: (
     # leading body
@@ -540,21 +535,23 @@
@@ -543,21 +533,23 @@
 )
 
 (
     source_bucket
     if name == source_bucket_name
@@ -562,8 +559,7 @@
@@ -565,8 +557,7 @@
 )
 
 (
         if name == source_bucket_name
         else storage.Bucket(mock_service, destination_bucket_name)
@@ -571,61 +567,70 @@
@@ -574,61 +565,70 @@
 )
 
 (
 
 (
@@ -636,29 +641,30 @@
 )
 
@@ -641,51 +641,50 @@
 (
-    lambda
-    # comment
     lambda
     # comment
-    *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs)
-    + 1
+    lambda *args, **kwargs: (
+        # comment
+    *args, **kwargs: (
+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
+    )
 )
 
 (
-    lambda  # comment
-    lambda
-    # comment
-    *args, **kwargs: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs)
-    + 1
+    lambda *args, **kwargs: (  # comment
 
 (
-    lambda  # comment 1
-    # comment 2
-    lambda
-    # comment 1
+    lambda  # comment 1
     # comment 2
-    *args, **kwargs:  # comment 3
-    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
+    lambda *args, **kwargs: (  # comment 1
+        # comment 2
+        # comment 3
+    *args, **kwargs: (  # comment 3
+        aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
+    )
 )
 
 (
-    lambda  # comment 1
-    lambda
-    # comment 1
-    *args, **kwargs:  # comment 3
-    aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa(*args, **kwargs) + 1
+    lambda *args, **kwargs: (  # comment 1  # comment 3
 
 (
@@ -666,19 +672,20 @@
-    lambda
-    # 1
+    lambda  # 1
     # 2
     left,  # 3
     # 4
     )
 )
@@ -696,46 +703,50 @@
@@ -703,46 +702,50 @@
 foo(
     lambda from_ts,  # but still wrap the body if it gets too long
     to_ts,
diff --git a/crates/ruff_python_formatter/src/expression/expr_lambda.rs b/crates/ruff_python_formatter/src/expression/expr_lambda.rs
index 18ab36997b..082e694d8f 100644
--- a/crates/ruff_python_formatter/src/expression/expr_lambda.rs
+++ b/crates/ruff_python_formatter/src/expression/expr_lambda.rs
@@ -1,10 +1,13 @@
 use ruff_formatter::{FormatRuleWithOptions, RemoveSoftLinesBuffer, format_args, write};
 use ruff_python_ast::{AnyNodeRef, Expr, ExprLambda};
-use ruff_text_size::Ranged;
+use ruff_python_trivia::SimpleTokenizer;
+use ruff_text_size::{Ranged, TextRange};
 
 use crate::builders::parenthesize_if_expands;
 use crate::comments::{dangling_comments, leading_comments, trailing_comments};
-use crate::expression::parentheses::{NeedsParentheses, OptionalParentheses, Parentheses};
+use crate::expression::parentheses::{
+    NeedsParentheses, OptionalParentheses, Parentheses, is_expression_parenthesized,
+};
 use crate::expression::{CallChainLayout, has_own_parentheses};
 use crate::other::parameters::ParametersParentheses;
 use crate::prelude::*;
@@ -24,6 +27,9 @@ impl FormatNodeRule&lt;ExprLambda&gt; for FormatExprLambda {
             body,
         } = item;
 
+        let body = &amp;**body;
+        let parameters = parameters.as_deref();
+
         let comments = f.context().comments().clone();
         let dangling = comments.dangling(item);
         let preview = is_parenthesize_lambda_bodies_enabled(f.context());
@@ -31,58 +37,72 @@ impl FormatNodeRule&lt;ExprLambda&gt; for FormatExprLambda {
         write!(f, [token(&quot;lambda&quot;)])?;
 
         if let Some(parameters) = parameters {
-            let parameters_have_comments = comments.contains_comments(parameters.as_ref().into());
+            let parameters_have_comments = comments.contains_comments(parameters.into());
 
             // In this context, a dangling comment can either be a comment between the `lambda` and the
             // parameters, or a comment between the parameters and the body.
-            let (dangling_before_parameters, dangling_after_parameters) =
-                // To prevent an instability in cases like:
-                //
-                // ```py
-                // (
-                //     lambda # comment 1
-                //     * # comment 2
-                //     x: # comment 3
-                //     x
-                // )
-                // ```
-                //
-                // `# comment 1` and `# comment 2` also become dangling comments on the lambda, so
-                // in preview, we include these in `dangling_after_parameters`, as long as the
-                // parameter list doesn't include any additional comments.
-                //
-                // This ends up formatted as:
-                //
-                // ```py
-                // (
-                //     lambda *x: (  # comment 1  # comment 2  # comment 3
-                //         x
-                //     )
-                // )
-                // ```
-                //
-                // instead of the stable formatting:
-                //
-                // ```py
-                // (
-                //     lambda  # comment 1
-                //     *x:  # comment 2
-                //     # comment 3
-                //     x
-                // )
-                // ```
-                if preview &amp;&amp; !parameters_have_comments {
-                    ([].as_slice(), dangling)
-                } else {
-                    dangling.split_at(
-                        dangling.partition_point(|comment| comment.end() &lt; parameters.start()),
-                    )
-                };
+            let (dangling_before_parameters, dangling_after_parameters) = dangling
+                .split_at(dangling.partition_point(|comment| comment.end() &lt; parameters.start()));
+
+            let (end_of_line_lambda_keyword_comments, leading_parameter_comments) = if preview {
+                dangling_before_parameters.split_at(
+                    dangling_before_parameters
+                        .iter()
+                        .position(|comment| comment.line_position().is_own_line())
+                        .unwrap_or(dangling_before_parameters.len()),
+                )
+            } else {
+                ([].as_slice(), dangling_before_parameters)
+            };
+
+            // To prevent an instability in cases like:
+            //
+            // ```py
+            // (
+            //     lambda # comment 1
+            //     * # comment 2
+            //     x: # comment 3
+            //     x
+            // )
+            // ```
+            //
+            // `# comment 1` and `# comment 2` also become dangling comments on the lambda, so
+            // in preview, we include these in `dangling_after_parameters`, as long as the
+            // parameter list doesn't include any additional comments.
+            //
+            // This ends up formatted as:
+            //
+            // ```py
+            // (
+            //     lambda *x: (  # comment 1  # comment 2  # comment 3
+            //         x
+            //     )
+            // )
+            // ```
+            //
+            // instead of the stable formatting:
+            //
+            // ```py
+            // (
+            //     lambda  # comment 1
+            //     *x:  # comment 2
+            //     # comment 3
+            //     x
+            // )
+            // ```
+
+            trailing_comments(end_of_line_lambda_keyword_comments).fmt(f)?;
 
-            if dangling_before_parameters.is_empty() {
+            if leading_parameter_comments.is_empty() &amp;&amp; !comments.has_leading(parameters) {
                 write!(f, [space()])?;
             } else {
-                write!(f, [dangling_comments(dangling_before_parameters)])?;
+                write!(
+                    f,
+                    [
+                        hard_line_break(),
+                        leading_comments(leading_parameter_comments)
+                    ]
+                )?;
             }
 
             // Try to keep the parameters on a single line, unless there are intervening comments.
@@ -124,12 +144,13 @@ impl FormatNodeRule&lt;ExprLambda&gt; for FormatExprLambda {
                 // ```
                 //
                 // and alternate between own line and end of line.
-                let (dangling_end_of_line, dangling_own_line) = dangling_after_parameters.split_at(
-                    dangling_after_parameters
-                        .iter()
-                        .position(|comment| comment.line_position().is_own_line())
-                        .unwrap_or(dangling_after_parameters.len()),
-                );
+                let (after_parameters_end_of_line, leading_body_comments) =
+                    dangling_after_parameters.split_at(
+                        dangling_after_parameters
+                            .iter()
+                            .position(|comment| comment.line_position().is_own_line())
+                            .unwrap_or(dangling_after_parameters.len()),
+                    );
 
                 let fmt_body = format_with(|f: &amp;mut PyFormatter| {
                     write!(
@@ -137,9 +158,9 @@ impl FormatNodeRule&lt;ExprLambda&gt; for FormatExprLambda {
                         [
                             space(),
                             token(&quot;(&quot;),
-                            trailing_comments(dangling_end_of_line),
+                            trailing_comments(after_parameters_end_of_line),
                             block_indent(&amp;format_args!(
-                                leading_comments(dangling_own_line),
+                                leading_comments(leading_body_comments),
                                 body.format().with_options(Parentheses::Never)
                             )),
                             token(&quot;)&quot;)
@@ -196,7 +217,7 @@ impl FormatNodeRule&lt;ExprLambda&gt; for FormatExprLambda {
         }
 
         if preview {
-            let body_comments = comments.leading_dangling_trailing(&amp;**body);
+            let body_comments = comments.leading_dangling_trailing(body);
             let fmt_body = format_with(|f: &amp;mut PyFormatter| {
                 // If the body has comments, we always want to preserve the parentheses. This also
                 // ensures that we correctly handle parenthesized comments, and don't need to worry
@@ -232,7 +253,7 @@ impl FormatNodeRule&lt;ExprLambda&gt; for FormatExprLambda {
                 //     ),
                 // )
                 // ```
-                else if matches!(&amp;**body, Expr::Call(_) | Expr::Subscript(_)) {
+                else if matches!(body, Expr::Call(_) | Expr::Subscript(_)) {
                     let unparenthesized = body.format().with_options(Parentheses::Never);
                     if CallChainLayout::from_expression(
                         body.into(),
</code></pre>
<p>However, I think we can simplify the implementation if we move more of the logic into <code>placement.rs</code>:</p>
<ul>
<li>Pass <code>preview_mode</code> to <code>place_comment</code>.</li>
<li>Can we change <code>place_comment</code> to always make the <code>leading_body_comments</code>/<code>dangling_own_line</code> leading comments of the body? I think we should then get the entire <code>fmt_body</code> for free</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-09 13:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-09 13:45</div>
            <div class="timeline-body"><blockquote>
<p>As explained on previous PRs, we try to always preserve the comment position: Comments that are end-of-line comments should remain end-of-line comments and own-line comments should remain own-line comments. Your formatting violates this principle.</p>
</blockquote>
<p>Oh, I thought I had preserved that, at least in this case. All three comments here start out as end-of-line comments and remain that way in my preview format, but maybe you're talking about a different example. Actually our stable formatting changes the placement in this case because comment 2 becomes an own-line comment.</p>
<pre><code class="language-py"># input
(
    lambda # comment 1
    * # comment 2
    x: # comment 3
    x
)

# stable: https://play.ruff.rs/a0980704-a9a0-4c7f-83e5-0f18bed89f72?secondary=Format
(
    lambda  # comment 1
    # comment 2
    *x:  # comment 3
    x
)

# preview
(
    lambda *x: (  # comment 1  # comment 2  # comment 3
        x
    )
)
</code></pre>
<p>Anyway, thanks for the patch. I'll apply that and then look into moving more of the logic into <code>placement.rs</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-09 23:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@expression__lambda.py.snap</code>:2004 on 2025-12-09 23:30</div>
            <div class="timeline-body"><p>This is not right. The first comment should stay on the first line, like in the <a href="https://play.ruff.rs/326510c9-8457-408c-90f6-b6bb3d1fd060?secondary=Format">playground</a> and on main.</p>
<p>I tracked it down to the assignment statement changes on this branch, but I still need to resolve it. I think the rest of the output is looking as I want, though.</p>
<p>I don't want GitHub to discard any of the old review comments, but I can also squash this down heavily if it would help with review. I think it would be nice to see all of the test snapshots before any of the code changes to make sure the stable formatting doesn't change accidentally. I could even spin the tests off into a separate PR, if that would help.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @ntBre on 2025-12-10 00:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-10 07:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:312 on 2025-12-10 07:15</div>
            <div class="timeline-body"><p>Can we gate the <code>if let Expr::Lambda</code> with the preview check to avoid this branch on stable (and remove the need for this comment)?</p>
<p>For preserving the <code>( # comment</code>, you want a branch similar to this in <code>maybe_parenthesize_expression</code>:</p>
<pre><code class="language-rust">        // If the expression has comments, we always want to preserve the parentheses. This also
        // ensures that we correctly handle parenthesized comments, and don't need to worry about
        // them in the implementation below.
        if node_comments.has_leading() || node_comments.has_trailing_own_line() {
            return expression.format().with_options(Parentheses::Always).fmt(f);
        }
</code></pre>
<p>In your case, it's probably sufficient to just check if the lambda has any leading comments and, if so, don't take this branch</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 14:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:312 on 2025-12-10 14:04</div>
            <div class="timeline-body"><p>Ah yeah, that's much better. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 15:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-10 15:01</div>
            <div class="timeline-body"><p>I think I got this working in <code>placement.rs</code> while mostly deleting both of the duplicated <code>fmt_body</code> blocks. I still had to preserve some of the logic in the <code>body_comments.has_leading()</code> block, so I may have missed something, though.</p>
<p>Only one snapshot changed, but I think maybe it's more correct now since we preserve the line placement, as long as it's okay to stack comments?</p>
<pre><code class="language-py">(
    lambda:  # comment 1
    (  # comment 2
        x
    )
)
</code></pre>
<p>now formats as</p>
<pre><code class="language-py">(
    lambda: (  # comment 1  # comment 2
        x
    )
)
</code></pre>
<p>instead of</p>
<pre><code class="language-py">(
    lambda: (  # comment 1
        # comment 2
        x
    )
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1888 on 2025-12-10 16:55</div>
            <div class="timeline-body"><p>Ah, hmm. This will be a footgun to stabilize because it doesn't use our normal function to check whether the feature is on. maybe add an extra function that takes the <code>PreviewMode</code> instead of the <code>FormatContext</code> so that we can use it here too</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1 on 2025-12-10 16:57</div>
            <div class="timeline-body"><p>Let's update the comments on the function you've changed and document the preview behavior. It's very unlikely that the person promoting the style would update the documentation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:101 on 2025-12-10 16:59</div>
            <div class="timeline-body"><p>Cool, how small the comment placement change is now :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:169 on 2025-12-10 17:00</div>
            <div class="timeline-body"><p>Poking into the formatting of inner expressions is something we should avoid whenever we can because it erodes isolation.</p>
<p>Can't we call <code>body.format</code> directly (may require <code>Parentheses::Always</code>) here? I think it should format the comments exactly the way you want (and add parentheses too)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1888 on 2025-12-10 17:02</div>
            <div class="timeline-body"><p>Do we even need the <code>SimpleTokenizer</code> call if preview is enabled?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1922 on 2025-12-10 17:06</div>
            <div class="timeline-body"><p>I'm not convinced we should do this for the example in the comment (right after the <code>else</code>) because it doesn't match my mental model of what's considered leading comments: An end-of-line comment is a trailing comment.</p>
<p>It is nice that it simplifies the formatting logic but I would rather do a little more in the lambda formatting than be surprised in the formatting of any given expression that it now suddenly has an end-of-line comment as its leading comment</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-10 17:06</div>
            <div class="timeline-body"><p>Are these now always own line comments? If so, can we use <code>leading_comments</code> with a <code>hard_line_break</code> instead?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/stmt_assign.rs</code>:1368 on 2025-12-10 17:09</div>
            <div class="timeline-body"><p>I think the name here is misleading. It suggests that it only applies to lambda expressions. <code>maybe_parenthesize_value</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/expression/lambda.py</code>:630 on 2025-12-10 17:11</div>
            <div class="timeline-body"><p>Can you add some tests where the call expression is or isn't parenthesized and has comments?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-10 17:13</div>
            <div class="timeline-body"><p>We're very close. My only real concern here is that I don't think we should make end-of-line comments leading comments (assuming I understand the change correctly).</p>
<p>I've to head out soon, so I won't be able to review the ecosystem changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 17:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1888 on 2025-12-10 17:22</div>
            <div class="timeline-body"><p>Oh yeah, looks like I can move the token check into the non-preview branch. And I added another preview function, good call!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1 on 2025-12-10 18:25</div>
            <div class="timeline-body"><p>Oh good catch. I'm attempting to put a <code>preview</code> docs link into the comment so that the doc tests will fail when the preview function is removed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 18:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 18:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:169 on 2025-12-10 18:27</div>
            <div class="timeline-body"><p><code>body.format().with_options(Parentheses::Always)</code> is all we had here before, but it was placing the leading comments before the parentheses of the body, as in:</p>
<pre><code class="language-py">(
    lambda:  # leading comment 1
    (  # comment 2
        x
    )
)
</code></pre>
<p>instead of:</p>
<pre><code class="language-py">(
    lambda: (  # leading comment 1  # comment 2
        x
    )
)
</code></pre>
<p>or similar. This is where I suspected I was missing something in my <a href="https://github.com/astral-sh/ruff/pull/21385#discussion_r2607024760">comment</a> above. Maybe we actually prefer the first result? That's what we do on stable.</p>
<p>If not, I'll take another look at this after the other comments!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 18:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-10 18:42</div>
            <div class="timeline-body"><p>I believe these are actually always end-of-line comments. This is part of the updated docs I added to <code>handle_lambda_comment</code>:</p>
<pre><code class="language-rust">/// In [preview](is_parenthesize_lambda_bodies_enabled_preview), the comment placement is instead:
///
/// ```python
/// (
///     lambda  # dangling lambda
///     # leading parameters
///     x
///     :  # leading body
///     # leading body
///     y
/// )
/// ```
</code></pre>
<p>and a temporary assertion here confirms that:</p>
<pre><code class="language-rust">                assert!(
                    dangling_before_parameters
                        .iter()
                        .all(|comment| comment.line_position().is_end_of_line())
                );
</code></pre>
<p>at least on our tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1922 on 2025-12-10 19:09</div>
            <div class="timeline-body"><p>Ah yeah, that makes sense to me. So should I just revert this and go back to handling it in the lambda formatting? I can just factor out the shared code like you mentioned before.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 19:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 21:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1922 on 2025-12-10 21:05</div>
            <div class="timeline-body"><p>I reverted the preview placement changes and factored out <code>FormatBody</code>, assuming that's what you meant. I think that resolves this comment and the one above (https://github.com/astral-sh/ruff/pull/21385#discussion_r2607482398).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/comments/placement.rs</code>:1 on 2025-12-10 21:05</div>
            <div class="timeline-body"><p>(opened https://github.com/astral-sh/ruff/pull/21903 to help enforce the links)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-10 21:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:169 on 2025-12-11 07:57</div>
            <div class="timeline-body"><p>I would have to play with the most recent version to say why this is happening but I would expect this to get formatted like your second code snippet when using <code>trailing_comments</code> for <code>leading comment 1</code>.</p>
<p>But that also assumes we place the comments correctly:</p>
<pre><code class="language-py">(
	lambda: # dangling-end-of-line
	# leading-body-own-line
	(  # leading-body-end-of-line (okay, we sometimes have end of line comments :))
		x
	)
)
</code></pre>
<p>I'd expect the following IR to work</p>
<pre><code>if has_comments... {
	write!(f, [
		trailing_comments(dangling-end-of-line),
		body.format().with_options(Parentheses::Always),
	])?;
} else {
	...
}
</code></pre>
<p>It may be necessary to insert a <code>hard_line_break</code> if <code>body</code> has a leading own-line comment but not 100% sure about that:</p>
<p>It should format my example to</p>
<pre><code class="language-py">(
	lambda: # dangling-end-of-line
	# leading-body-own-line
	(  # leading-body-end-of-line (okay, we sometimes have end of line comments :))
		x
	)
)
</code></pre>
<p>But the <code># dangling-end-of-line</code> should float to the back after the <code>(</code> if there's no <code>leading-body-own-line</code> comment like so</p>
<pre><code class="language-py">(
	lambda: (  # dangling-end-of-line # leading-body-end-of-line (okay, we sometimes have end of line comments :))
		x
	)
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-11 07:59</div>
            <div class="timeline-body"><p>I would then recommend using <code>trailing_comments</code> and ideally change the variable naming too</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-11 08:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 15:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:169 on 2025-12-11 15:09</div>
            <div class="timeline-body"><p>Your <code>leading-body-own-line</code> comment is currently placed as a dangling comment on the lambda, I guess that's why your snippet is formatted like this in preview:</p>
<pre><code class="language-py">(
    lambda: (  # dangling-end-of-line
        # leading-body-own-line
        # leading-body-end-of-line (okay, we sometimes have end of line comments :))
        x
    )
)
</code></pre>
<p>Your output is the stable formatting, though.</p>
<p>I'll start playing with making <code>leading-body-own-line</code> a leading comment on the body in a separate branch, it's a bit hard to isolate all the variables here with the preview changes mixed in.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 16:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:169 on 2025-12-11 16:45</div>
            <div class="timeline-body"><p>Okay I got something working by just manipulating the dangling comments a bit more. I don't think we want to make <code>leading-body-own-line</code> a leading comment because it complicates a lot of other situations like these:</p>
<pre><code class="language-py">(
    lambda
    # 3
    : None
)

(
    lambda  # 1
    # 2
    : # 3
    # 4
    None # 5
)

a = (
    lambda  # Dangling
           : 1
)

a = (
    lambda:  # Dangling
    1
)
</code></pre>
<p>I saved some of my experiments trying to get these to work in 2cb98d4cdb9 before reverting it and trying a different approach in <code>FormatBody</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-11 16:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:169 on 2025-12-11 16:52</div>
            <div class="timeline-body"><blockquote>
<p>Okay I got something working by just manipulating the dangling comments a bit more. I don't think we want to make leading-body-own-line a leading comment because it complicates a lot of other situations like these:</p>
</blockquote>
<p>We don't have to if we can find another solution and I'm fine with that. But I don't follow how or why it complicates the examples you shared. Again, no reason to explain if you have a working solution.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 17:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-11 17:02</div>
            <div class="timeline-body"><p>I think using <code>trailing_comments</code> here conflicts with the <code>trailing_comments</code> changes I just pushed for the body. Comments from before the parameters are migrating all the way into the body, and in the wrong order, at least when simply swapping <code>dangling_comments</code> for <code>trailing_comments</code> (it's also unstable).</p>
<pre><code class="language-py"># input
(
    lambda # comment 1
    * # comment 2
    x: # comment 3
    x
)

# first output
(
    lambda # comment 2  # comment 1
    *x:  # comment 3
    x
)

# second output
(
    lambda *x:  # comment 3  # comment 2  # comment 1
    x
)
</code></pre>
<p>(This suggestion may be outdated after some of the other changes, but I did give it a try)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-12-11 17:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-11 17:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-11 17:24</div>
            <div class="timeline-body"><p>The order shouldn't be changed unless this is a bug in the printer for as long as they appear in the right order in the IR. But again, hard to say without debugging this msyelf</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:411 on 2025-12-11 17:25</div>
            <div class="timeline-body"><p>You use <code>f.context().comments()</code> a lot. I think it makes sense to assign it to a variable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:432 on 2025-12-11 17:27</div>
            <div class="timeline-body"><p>I like to move the common code out of the conditions</p>
<pre><code class="language-rust">trailing_comments(dangling.fmt())?;

if leading_body_comments.is_empty() {
	space.fmt(f)?;
} else {
	hard_line_break().fmt(f)?;
}

body.format().with_options(Parentheses::Always).fmt(f)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:414 on 2025-12-11 17:28</div>
            <div class="timeline-body"><p>Why don't we need to format the <code>leading_body_comments</code> if they aren't empty as we do in the <code>else</code> branch</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-11 17:28</div>
            <div class="timeline-body"><p>I don't want to belabor the point if we're happy with the current version, but this is the IR, if you're curious:</p>
<pre><code>cargo run --bin ruff_python_formatter -- --emit stdout --target-version 3.10 --print-ir
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.15s
     Running `target/debug/ruff_python_formatter --emit stdout --target-version 3.10 --print-ir`
[
  &quot;(&quot;,
  group(expand: propagated, [
    indent([
      soft_line_break,
      &quot;lambda &quot;,
      line_suffix(13, [&quot;  # comment 1&quot;]),
      expand_parent,
      &quot;# comment 2&quot;,
      hard_line_break,
      group([&quot;*x&quot;]),
      &quot;:  # comment 3&quot;,
      hard_line_break,
      &quot;x&quot;
    ]),
    soft_line_break
  ]),
  &quot;)&quot;,
  hard_line_break
]
(
    lambda # comment 2  # comment 1
    *x:  # comment 3
    x
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 17:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:344 on 2025-12-11 17:29</div>
            <div class="timeline-body"><p>Nit: For inline helpers, I tend to just call the struct initializer</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:133 on 2025-12-11 17:31</div>
            <div class="timeline-body"><p>It would be more helpful if the comment said why that's the case. I otherwise suggest removing it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:135 on 2025-12-11 17:32</div>
            <div class="timeline-body"><p>I think <code>format_body</code> should be renamed to <code>parenthesized_body</code> or <code>body_with_comments</code> or what not if this really is about formatting a parenthesized body and not the function to format any lambda body</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-11 17:35</div>
            <div class="timeline-body"><p>I see. The issue is that <code>comment 3</code> doesn't use <code>trailing_comments</code>. So <code>comment 3</code> doesn't become a line suffix and, instead, gets rendered in place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:148 on 2025-12-11 17:43</div>
            <div class="timeline-body"><p>Uff, I found this flow with early returns extremelly confusing. I was like, wait a minue. Aren't we formatting the body twice.</p>
<p>I think I'd prefer to unify it with the <code>preview</code> branch below. I feel like this would simplify things because</p>
<ol>
<li>You don't need to repeat the logic twice. In preview, just don't format the dangling comments up here</li>
<li>The reading flow becomes a more natural top-down flow.</li>
<li>It removes to match on the layout twice</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-11 17:54</div>
            <div class="timeline-body"><p>Thank you. I think this looks good logic wise. It's great to see that this now requires way fewer changes than first expect.</p>
<p>It would have been nice if there were fewer places we used <code>dangling_comments</code> but I'm fine leaving this where we are now.</p>
<p>I think we should try to unify the body formatting logic in preview mode to make the code easier to read.</p>
<p>We should also do one more pass over the ecosystem changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-11 17:58</div>
            <div class="timeline-body"><p>Thank you! I'll go through these new comments this afternoon.</p>
<p>I'll also go through the ecosystem results once more. I've been keeping up with them, including a full look at a local run yesterday since the comment is truncated. I'll do that again after these code changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:135 on 2025-12-11 18:01</div>
            <div class="timeline-body"><p>I mark this as resolved because this will just become <code>format_body</code> if you address my other comment about unifying the body formatting</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-11 18:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 20:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:432 on 2025-12-11 20:13</div>
            <div class="timeline-body"><p>Oh nice, thanks! I thought the space had to go before <code>trailing_comments</code> in the first arm, but this works perfectly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:414 on 2025-12-11 20:15</div>
            <div class="timeline-body"><p>We're formatting <code>dangling</code> as a whole here, so we don't need to format <code>after_parameters_end_of_line</code> and <code>leading_body_comments</code> separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 20:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 20:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:133 on 2025-12-11 20:18</div>
            <div class="timeline-body"><p>Oh yeah, I think this is partially outdated and handled better by the comments in <code>FormatBody</code>, so I'll just delete it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 20:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:107 on 2025-12-11 20:23</div>
            <div class="timeline-body"><p>Comments 1 and 2 still swap their order in this case, even though they seem to be in the right order in the IR, unless I'm missing something. And it happens without comment 3 too:</p>
<pre><code>❯ cat &lt;&lt;EOF | just fmt --print-ir
(
    lambda # comment 1
    * # comment 2
    x:
    x
)
EOF
[
  &quot;(&quot;,
  group(expand: propagated, [
    indent([
      soft_line_break,
      &quot;lambda &quot;,
      line_suffix(13, [&quot;  # comment 1&quot;]),
      expand_parent,
      &quot;# comment 2&quot;,
      hard_line_break,
      group([&quot;*x&quot;]),
      &quot;: x&quot;
    ]),
    soft_line_break
  ]),
  &quot;)&quot;,
  hard_line_break
]
(
    lambda # comment 2  # comment 1
    *x: x
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-11 20:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:148 on 2025-12-11 20:34</div>
            <div class="timeline-body"><p>Ah that's much nicer. I felt that it was complicated but hadn't found a good way to fix it. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-11 21:05</div>
            <div class="timeline-body"><p>I think that should take care of the code changes, just waiting for the ecosystem comment. I'll download the results, go through them, and then upload a copy here. I was getting a slightly different number of changes when running ruff-ecosystem locally, so I'll stick to the canonical one from CI.</p>
<p>Differently, are my comments in the code too long? It felt like a bad sign that I installed a plugin to hide comments this afternoon to get a better look at the overall code structure. Otherwise it seemed nice to make them very explicit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-11 21:28</div>
            <div class="timeline-body"><p>Ecosystem results look good to me! As expected and noted in the summary, we now:</p>
<ul>
<li>Keep lambda parameters on one line</li>
<li>Parenthesize the lambda body if it expands</li>
<li>Remove parentheses around the lambda body if they're no longer needed</li>
</ul>
<p><a href="https://github.com/user-attachments/files/24112238/ecosystem-result.md">ecosystem-result.md</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-12 09:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:414 on 2025-12-12 09:28</div>
            <div class="timeline-body"><p>This might be worth a comment</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:39 on 2025-12-12 09:39</div>
            <div class="timeline-body"><p>Let's move this closer to where it's used (line 110)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:135 on 2025-12-12 09:43</div>
            <div class="timeline-body"><p>Could we also move this into <code>FormatBody</code>, given that it's the same for both branches and that we moved the responsibility of formatting those comments into <code>FormatBody</code> anyway</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:38 on 2025-12-12 09:44</div>
            <div class="timeline-body"><p>Can we give this variable a more descriptive name (also in <code>FormatBody</code>). Like dangling where? And how are they different from dangling on line 33</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:215 on 2025-12-12 09:44</div>
            <div class="timeline-body"><p>Let's give this field a better name and add a document what sort of comments they are (where should they be placed. Can they be end of line comments and own line comments?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:429 on 2025-12-12 09:53</div>
            <div class="timeline-body"><p>I'm inclined to move this out of <code>FormatBody</code> to remove the need for the <code>fmt_body</code> lambda</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:251 on 2025-12-12 09:55</div>
            <div class="timeline-body"><p>So <code>after_parameters_end_of_line</code> only contain <code># 1</code>? The <code>after_parameters</code> part is a bit confusing because there are no parameters in the example but I think it's fine</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:347 on 2025-12-12 09:59</div>
            <div class="timeline-body"><p>Can you remind me again why we can't use this layout for call chains?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-12-12 10:01</div>
            <div class="timeline-body"><p>This is looks great to me. My only question is if we can improve call chain formatting. The extra set of parentheses around call chains often feels unnecessary. It would be nice if we could avoid that, but I don't remember what the issue was that we faced. I don't think it's very important and also something we can iterate on later but might be worth giving a short try</p>
<p>This isn't a call chain, but I do find the parentheses very unnecessary.</p>
<p><a href='https://github.com/qdrant/qdrant-client/blob/750d735b2917a30b0cbf468ddccbc47d12704e32/tests/congruence_tests/test_delete_points.py#L70'>tests/congruence_tests/test_delete_points.py~L70</a></p>
<pre><code class="language-diff">     compare_client_results(
         local_client,
         remote_client,
-        lambda c: c.query_points(
-            COLLECTION_NAME,
-            query=vector,
-            using=&quot;sparse-image&quot;,
-        ).points,
+        lambda c: (
+            c.query_points(
+                COLLECTION_NAME,
+                query=vector,
+                using=&quot;sparse-image&quot;,
+            ).points
+        ),
     )
 
     found_ids = [
</code></pre>
<p><a href='https://github.com/zulip/zulip/blob/86cec937dd0ab004c9f2f50d1a853dd432e2c996/zerver/lib/user_groups.py#L788'>zerver/lib/user_groups.py~L788</a></p>
<pre><code class="language-diff"> 
 def get_recursive_subgroups_union_for_groups(user_group_ids: list[int]) -&gt; QuerySet[UserGroup]:
     cte = CTE.recursive(
-        lambda cte: UserGroup.objects.filter(id__in=user_group_ids)
-        .values(group_id=F(&quot;id&quot;))
-        .union(
-            cte.join(NamedUserGroup, direct_supergroups=cte.col.group_id).values(group_id=F(&quot;id&quot;))
+        lambda cte: (
+            UserGroup.objects.filter(id__in=user_group_ids)
+            .values(group_id=F(&quot;id&quot;))
+            .union(
+                cte.join(NamedUserGroup, direct_supergroups=cte.col.group_id).values(
+                    group_id=F(&quot;id&quot;)
+                )
+            )
         )
     )
     return with_cte(cte, select=cte.join(UserGroup, id=cte.col.group_id))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-12 14:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:347 on 2025-12-12 14:42</div>
            <div class="timeline-body"><p>I think we discussed it looking better this way. Here's a quick example without the call chain formatting:</p>
<pre><code class="language-diff">         param(
-            lambda left, right: (
-                ibis.timestamp(&quot;2017-04-01&quot;)
-                .cast(dt.date)
-                .between(left, right)
-                .between(left, right)
-            ),
+            lambda left, right: ibis.timestamp(&quot;2017-04-01&quot;)
+            .cast(dt.date)
+            .between(left, right)
+            .between(left, right),
         ),
     ],
</code></pre>
<p>which is like our <a href="https://play.ruff.rs/95e18d91-1d35-43a5-915b-40cf83c55991?secondary=Format">stable</a> formatting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-12 14:49</div>
            <div class="timeline-body"><p>To your first example, the <code>.points</code> is what causes us to wrap. Without that, we'll reuse the call parentheses:</p>
<pre><code class="language-py">def foo():
    compare_client_results(
        local_client,
        remote_client,
        lambda c: (
            c.query_points(
                COLLECTION_NAME,
                query=vector,
                using=&quot;sparse-image&quot;,
            ).points
        ),
    )

    compare_client_results(
        local_client,
        remote_client,
        lambda c: c.query_points(
            COLLECTION_NAME,
            query=vector,
            using=&quot;sparse-image&quot;,
        ),
    )
</code></pre>
<p>So I think it's okay. I think that's preferable to our stable formatting:</p>
<pre><code class="language-py">def foo():
    compare_client_results(
        local_client,
        remote_client,
        lambda c: c.query_points(
            COLLECTION_NAME,
            query=vector,
            using=&quot;sparse-image&quot;,
        ).points,
    )
</code></pre>
<p>Like the call chains, I think this becomes less clear especially when followed by arguments after the lambda, similar to the examples from #8179.</p>
<pre><code class="language-py">def foo():
    compare_client_results(
        local_client,
        remote_client,
        lambda c: c.query_points(
            COLLECTION_NAME,
            query=vector,
            using=&quot;sparse-image&quot;,
        ).points,
        somewhat_ambiguous_argument=might_be_part_of_the_lambda
    )
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-12 15:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:135 on 2025-12-12 15:03</div>
            <div class="timeline-body"><p>What do you think about something like this?</p>
<pre><code class="language-rust">        write!(f, [token(&quot;:&quot;)])?;

        // In this context, a dangling comment is a comment between the `lambda` and the body.
        if dangling.is_empty() {
            write!(f, [space()])?;
        } else if !preview {
            write!(f, [dangling_comments(dangling)])?;
        }

        if !preview {
            return body.format().fmt(f);
        }

        let fmt_body = FormatBody { body, dangling };

        match self.layout {
            ExprLambdaLayout::Assignment =&gt; fits_expanded(&amp;fmt_body).fmt(f),
            ExprLambdaLayout::Default =&gt; fmt_body.fmt(f),
        }
</code></pre>
<p>I see what you mean about putting the dangling comments into <code>FormatBody</code>, but this also seems nice because it moves both the preview and layout checks out of <code>FormatBody</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-12 15:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:135 on 2025-12-12 15:11</div>
            <div class="timeline-body"><p>That looks good too. For as long as we move it into a shared code path</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-12 16:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:38 on 2025-12-12 16:33</div>
            <div class="timeline-body"><p>I tried a couple of different names like <code>dangling_after_parameters</code> and <code>dangling_body_comments</code> before settling on <code>dangling_header_comments</code> and adding a couple of comments to explain what it means. Hopefully that's a bit better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-12-12 16:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_formatter/src/expression/expr_lambda.rs</code>:251 on 2025-12-12 16:39</div>
            <div class="timeline-body"><p>Yes, that's right. I made this name <code>trailing_header_comments</code> since we format them with <code>trailing_comments</code>, and improved the docs here after verifying that the example is correct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-12 16:45</div>
            <div class="timeline-body"><p>Thank you again for all of your help here! I've addressed the new comments and will plan to merge once CI passes, and I verify that the ecosystem checks haven't changed!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @ntBre on 2025-12-12 17:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ntBre on 2025-12-12 17:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-12-12 17:02</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 16:42:35 UTC
    </footer>
</body>
</html>
