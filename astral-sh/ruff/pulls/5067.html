<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add &quot;verbatim&quot; node support to source code generator - astral-sh/ruff #5067</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add &quot;verbatim&quot; node support to source code generator</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/5067">#5067</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-06-13 22:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body">Summary
<p>One of our primary autofix mechanisms is the <code>Generator</code>, which takes an AST, and &quot;unparses&quot; it to generate source code.</p>
<p>This is a convenient mechanism, because it allows for a structured editing approach: rather than manipulating text directly, you can just modify the AST in a type-safe way, and rely on the <code>Generator</code> to generate the approach code to mimic your edit.</p>
<p>For example, if you want to change <code>x is True</code> to <code>x == True</code>, you can just create a new <code>Expr::Compare</code> node and change the operator type, rather than lexing to find <code>is</code>, etc.</p>
<p>The main downside of this approach -- and it&#x27;s a big one -- is that it doesn&#x27;t preserve formatting or trivia. That is, it doesn&#x27;t preserve anything that isn&#x27;t captured by the AST.</p>
<p>One common example here is raw strings:</p>
<pre><code>not (re.search(r&quot;^.:\\Users\\[^\\]*\\Downloads\\.*&quot;) is None)
</code></pre>
<p>Raw strings are not part of the AST. Instead, the AST stores the parsed string as a constant. So when we &quot;unparse&quot; this, we remove the <code>r</code> prefix, and add a ton of backslashes to the string -- all just to change <code>is</code> to <code>==</code>.</p>
<p>This PR proposes an improvement to the source code generator to support &quot;verbatim&quot; nodes, which should be formatted by reading their existing representations from source. In the above example, we can model the fix is: <code>${verbatim left expression} == ${verbatim right expression}</code>. Rather than generating source code &quot;all the way down&quot;, we just generate the parts we need, and then insert source code verbatim for existing expressions that we&#x27;re manipulating. Thus, we&#x27;d preserve the raw string when formatting the left node.</p>
<p>Though we&#x27;ll still lose comments in some cases (if they exist between expressions), this does seem like a strict improvement over our current system. The main reasons <em>not</em> to pursue it are:</p>
<ul>
<li>In order to add a new <code>ExprVerbatim</code> node to the AST (specifically for the <code>Generator</code>), we have to create an entire parallel struct hierarchy (see <code>verbatim.rs</code>, similar to our existing <code>comparable.rs</code>). It&#x27;s just a lot of code, though it&#x27;s all boilerplate and perhaps could even be generated some day.</li>
<li>We have a lot of usages of <code>Generator</code> today, and we need to go through and migrate them all to this new API. Probably not too bad, but it will take time.</li>
<li>It still doesn&#x27;t guarantee that we&#x27;ll preserve all trivia.</li>
</ul>
Test Plan
<p><code>cargo test</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-13 22:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/konstin">@konstin</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-13 22:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-06-13 22:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_ast/src/source_code/verbatim_generator.rs</code>:1 on 2023-06-13 22:51</div>
            <div class="timeline-body"><p>This is an exact copy of <code>generator.rs</code>, but with the <code>ExprVerbatim</code> case added, and it uses the AST from <code>verbatim</code> instead of the RustPython AST.</p>
<p>If we like this approach, then the plan would be to remove <code>Generator</code> and migrate all usages to this instead. This would then be the new <code>Generator</code> (we wouldn&#x27;t need the &quot;verbatim&quot; prefix).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-06-13 22:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_ast/src/verbatim.rs</code>:3 on 2023-06-13 22:52</div>
            <div class="timeline-body"><p>This is basically copied from <code>comparable.rs</code> where we have a similar hierarchy but for creating hashable AST nodes. The difference is that this adds <code>ExprVerbatim</code> and <code>StmtVerbatim</code> to the hierarchy, and removes some things that don&#x27;t matter for formatting (like <code>ExprContext</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-13 22:52</div>
            <div class="timeline-body"><p>I&#x27;m looking for feedback on this concept before investing any more work in the migration.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-06-13 23:22</div>
            <div class="timeline-body">PR Check Results
Ecosystem
<p>✅ ecosystem check detected no changes.</p>
Benchmark
Linux
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.01      6.4±0.02ms     6.4 MB/sec    1.00      6.3±0.07ms     6.4 MB/sec
formatter/numpy/ctypeslib.py               1.01   1327.9±4.68µs    12.5 MB/sec    1.00   1319.3±3.33µs    12.6 MB/sec
formatter/numpy/globals.py                 1.00    127.0±0.15µs    23.2 MB/sec    1.00    127.4±0.17µs    23.2 MB/sec
formatter/pydantic/types.py                1.01      2.6±0.02ms     9.7 MB/sec    1.00      2.6±0.01ms     9.8 MB/sec
linter/all-rules/large/dataset.py          1.01     14.3±0.08ms     2.8 MB/sec    1.00     14.2±0.06ms     2.9 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.01      3.4±0.01ms     4.9 MB/sec    1.00      3.4±0.01ms     4.9 MB/sec
linter/all-rules/numpy/globals.py          1.00    426.3±0.96µs     6.9 MB/sec    1.00    427.6±0.80µs     6.9 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.0±0.02ms     4.2 MB/sec    1.00      6.0±0.03ms     4.3 MB/sec
linter/default-rules/large/dataset.py      1.01      6.9±0.03ms     5.9 MB/sec    1.00      6.8±0.03ms     6.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1485.7±3.15µs    11.2 MB/sec    1.00   1480.7±2.90µs    11.2 MB/sec
linter/default-rules/numpy/globals.py      1.00    164.2±0.38µs    18.0 MB/sec    1.00    163.8±0.55µs    18.0 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.1±0.01ms     8.2 MB/sec    1.00      3.1±0.01ms     8.2 MB/sec
</code></pre>
Windows
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      8.7±0.32ms     4.7 MB/sec    1.03      8.9±0.30ms     4.6 MB/sec
formatter/numpy/ctypeslib.py               1.00  1791.1±78.81µs     9.3 MB/sec    1.03  1841.4±57.15µs     9.0 MB/sec
formatter/numpy/globals.py                 1.00    182.5±8.39µs    16.2 MB/sec    1.00   182.1±10.27µs    16.2 MB/sec
formatter/pydantic/types.py                1.00      3.7±0.16ms     6.9 MB/sec    1.00      3.7±0.14ms     6.9 MB/sec
linter/all-rules/large/dataset.py          1.01     19.0±0.64ms     2.1 MB/sec    1.00     18.9±0.55ms     2.2 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.7±0.21ms     3.5 MB/sec    1.03      4.9±0.16ms     3.4 MB/sec
linter/all-rules/numpy/globals.py          1.00   574.4±24.03µs     5.1 MB/sec    1.03   594.1±21.71µs     5.0 MB/sec
linter/all-rules/pydantic/types.py         1.00      7.9±0.28ms     3.2 MB/sec    1.07      8.5±0.28ms     3.0 MB/sec
linter/default-rules/large/dataset.py      1.02      9.8±0.30ms     4.1 MB/sec    1.00      9.6±0.27ms     4.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.01      2.1±0.09ms     8.1 MB/sec    1.00      2.0±0.10ms     8.2 MB/sec
linter/default-rules/numpy/globals.py      1.03   234.1±12.67µs    12.6 MB/sec    1.00    226.8±7.54µs    13.0 MB/sec
linter/default-rules/pydantic/types.py     1.01      4.5±0.18ms     5.7 MB/sec    1.00      4.5±0.19ms     5.7 MB/sec
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> approved on 2023-06-14 06:16</div>
            <div class="timeline-body"><p>Without having touched a lot of the existing generator code, this looks good to me.</p>
<p>Implementation-wise, would wrapping <code>Expr</code> either in an enum (<code>Verbatim</code> and <code>Default</code> variants) or through a <code>MaybeVerbatim</code> trait (accepts both <code>Expr</code> and <code>Verbatim&lt;T: Node&gt;</code>, <code>&amp;Expr</code> -&gt; <code>&amp;impl MaybeVerbatim&lt;Expr&gt;</code>) work? This would avoid duplicating the files</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-06-19 09:03</div>
            <div class="timeline-body"><p>I do like the idea. It seems a reasonable compromise between having an AST vs a CST.  A few questions/notes</p>
<ul>
<li>I think it should be possible to preserve the in-between comments if we come up with an explicit convention on when to associate comments to which nodes. This will not be perfect for e.g. trailing body comments. Rome used swifts convention (<a href="https://github.com/rome/tools/issues/1718">rome/tools#1718</a>)</li>
</ul>
<ol>
<li>A token owns all of its trailing trivia up to, but not including, the next newline character.</li>
<li>Looking backward in the text, a token owns all of the leading trivia up to and including the first newline character.</li>
</ol>
<p>Is there a possibility that verbatim nodes and operator precedence doesn&#x27;t play well together? E.g. you change the operator of a nested binary expression. Will the generator insert the parentheses in the right place?</p>
<p>From my experience with verbatim nodes on the formatter. Is there a chance that a verbatim node may not have the right indent, e.g. when changing indentation and formatting a compound statement as verbatim.</p>
<p><strong>Implementation</strong></p>
<ul>
<li>A little less ergonomic, but would it instead be possible to keep a list of node-ranges that should be formatted as verbatim? This should be cheap to check if the ranges are stored in sorted order because the generator iterates the nodes in pre-order. It would remove the need for duplicating all nodes</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-14 03:07</div>
            <div class="timeline-body"><p>We&#x27;ll return to this at some point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-14 03:07</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:54:28 UTC
    </footer>
</body>
</html>
