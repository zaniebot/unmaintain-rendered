<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] support for typing.reveal_type - astral-sh/ruff #13384</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] support for typing.reveal_type</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13384">#13384</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-09-17 18:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>Add support for the <code>typing.reveal_type</code> function, emitting a diagnostic revealing the type of its single argument. This is a necessary piece for the planned testing framework.</p>
<p>This puts the cart slightly in front of the horse, in that we don&#x27;t yet have proper support for validating call signatures / argument types. But it&#x27;s easy to do just enough to make <code>reveal_type</code> work.</p>
<p>This PR includes support for calling union types (this is necessary because we don&#x27;t yet support <code>sys.version_info</code> checks, so <code>typing.reveal_type</code> itself is a union type), plus some nice consolidated error messages for calls to unions where some elements are not callable. This is mostly to demonstrate the flexibility in diagnostics that we get from the <code>CallOutcome</code> enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/carljm">@carljm</a> on 2024-09-17 18:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;[red-knot] [WIP] typing.reveal_type&quot; to &quot;[red-knot] support for typing.reveal_type&quot; by <a href="https://github.com/carljm">@carljm</a> on 2024-09-17 21:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-17 21:59</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/carljm">@carljm</a> on 2024-09-17 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/carljm">@carljm</a> on 2024-09-17 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/carljm">@carljm</a> on 2024-09-17 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-18 06:28</div>
            <div class="timeline-body"><p>Do we need to store the entire <code>FunctionType</code> for <code>RevealType</code>? Don&#x27;t we know its exact signature?</p>
<p>Also, kind of funny to have this as a dedicated type</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:334 on 2024-09-18 06:29</div>
            <div class="timeline-body"><p>I guess the answer is probably <em>no</em> because the function is called <code>into_function_type</code> and not <code>into_function</code> but is there any existing code that makes the assumption that the function only returns <code>Some</code> if the variant is <code>Function</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:504 on 2024-09-18 06:31</div>
            <div class="timeline-body"><p>Should this be <code>None</code> instead for better error messages? It&#x27;s a difference whether a type is inferred as <code>Unknown</code> or the argument was missing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:525 on 2024-09-18 06:33</div>
            <div class="timeline-body"><p>Nit: I would expect a <code>CallOutcome::union</code> constructor function for symmetry with <code>::callable</code>. Or to move <code>Type::call to </code>CallOutcome::new(Type)`.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:524 on 2024-09-18 06:35</div>
            <div class="timeline-body"><p>Do we need to unify the elements because multiple elements could have the same return type (or even all of them)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:503 on 2024-09-18 06:36</div>
            <div class="timeline-body"><p>Is this a fixed return type or is the <code>reveal_type</code> function similar to <code>dbg</code> where it is an <code>identity</code> function with the side effect that it prints the type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:755 on 2024-09-18 06:39</div>
            <div class="timeline-body"><p>Nit: I would move out the <code>if</code> because it also has a side effect (and the formatting is rather weird).</p>
<pre><code>												let call_ty = if let Self::NotCallable { not_callable_ty } = outcome {
													not_callable.push(*not_callable_ty);
													Type::Unknown
												} else {
													outcome.unwrap_with_diagnostic(db, node, builder)
												}
                        union_builder.add(call_ty);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2418 on 2024-09-18 06:42</div>
            <div class="timeline-body"><p>What&#x27;s the motivation for this change? I can&#x27;t find any use of <code>add_diagnostic_string</code> outside of `add_diagnostic?</p>
<p>I would prefer not to expose a <code>_string</code> function to avoid usage of <code>format!</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:656 on 2024-09-18 06:43</div>
            <div class="timeline-body"><p>I find the name <code>Outcome</code> a bit strange but I think that&#x27;s something you plan to address as part of your context proposal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-09-18 06:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-18 12:30</div>
            <div class="timeline-body"><p>Yeah, agree with Micha that there&#x27;s not much use storing inner data for this variant, since we already have the complexity of having an extra variant (wrapping inner data doesn&#x27;t really save us any complexity, I don&#x27;t think), everything about <code>reveal_type</code>&#x27;s special behaviour will have to be hardcoded in by us anyway, and the signature is known and guaranteed to never change.</p>
<blockquote>
<p>Also, kind of funny to have this as a dedicated type</p>
</blockquote>
<p>It surprised me initially that this was the approach used, since conceptually it&#x27;s really the <em>symbol</em> of <code>reveal_type</code> that&#x27;s special rather than the <em>type</em> of <code>reveal_type</code>. But I suppose that unless it&#x27;s represented as a separate variant here, it&#x27;s hard for <code>Type::Call</code> to operate differently when applied to <code>revealed_type</code> as opposed to other functions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:334 on 2024-09-18 12:30</div>
            <div class="timeline-body"><p>I think this makes <code>Type::expect_function</code> not operate as expected, since the purpose of that method is partly to assert that the variant you have is a <code>Type::Function</code> variant:</p>
<p>https://github.com/astral-sh/ruff/blob/4eb849aed3a6df9ce0f45dd7a2fdb525e31e61e3/crates/red_knot_python_semantic/src/types.rs#L332-L335</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:378 on 2024-09-18 12:31</div>
            <div class="timeline-body"><p>Is this correct? It surprises me that <code>Type::RevealedType(...).is_stdlib_symbol(&amp;db, &quot;collections&quot;, &quot;deque&quot;)</code> would return <code>true</code>. It&#x27;s not the stdlib symbol <code>collections.deque</code>!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:503 on 2024-09-18 12:32</div>
            <div class="timeline-body"><p>It&#x27;s a generic identity function, the same as <code>dbg!</code>: https://github.com/python/cpython/blob/32119fc377a4d9df524a7bac02b6922a990361dd/Lib/typing.py#L3635-L3651</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-18 12:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 15:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-18 15:45</div>
            <div class="timeline-body">Why have this as a distinct Type variant?
<p>Conceptually, singleton types (which include Class and Function) are already the same thing as &quot;a symbol&quot; -- they represent a single Python class or function object, defined at a single location, and these types allow us to track this identity across imports (including with aliasing), assignments, etc. So identifying <code>reveal_type</code> via the type system is a natural fit; I don&#x27;t really see what the alternative would even be.</p>
<p>In principle, we wouldn&#x27;t <em>need</em> the extra variant for this; <code>Type::Function</code> has all the information we need already. But practically speaking, it would be a bad idea for performance if we had to add an extra check &quot;wait, is this function <code>reveal_type</code>??&quot; at every single call site of any function; <code>is_stdlib_symbol</code> is not free, differentiating an enum tag is much much cheaper. Using a distinct variant allows us to make the <code>is_stdlib_symbol</code> check only at function-definition time, which is <em>much</em> less frequent than function-call time.</p>
Should we store the inner <code>FunctionType</code> inside <code>Type::RevealTypeFunction</code>?
<p>I don&#x27;t have super-strong feelings here, but I think the overall cost-benefit for doing this is positive.</p>
<p>The cost is very low; a <code>FunctionType</code> is just a u32 id, and <code>RevealTypeFunction</code> is not going to be a super common type. I would venture to say the cost of doing this is effectively zero.</p>
<p>And the benefit is not zero. We don&#x27;t <em>have</em> to hardcode <em>everything</em> about <code>RevealTypeFunction</code>. If we store the inner <code>FunctionType</code>, we can in almost every case just fall back to the normal <code>Function</code> handling, and only add special <code>reveal_type</code> behavior where it is actually special. For instance, I would rather not hardcode call-signature validation, I&#x27;d rather share as much as possible with <code>Type::Function</code>.</p>
<p>So yes, we could skip storing the inner <code>FunctionType</code>, and instead hardcode literally everything about <code>RevealTypeFunction</code>. But I don&#x27;t see why we&#x27;d want to do this, when we don&#x27;t have to.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 15:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:334 on 2024-09-18 15:51</div>
            <div class="timeline-body"><blockquote>
<p>is there any existing code that makes the assumption that the function only returns <code>Some</code> if the variant is <code>Function</code>?</p>
</blockquote>
<p>No, there&#x27;s no such code. And I think we generally want any external code to ideally transparently treat <code>Type::RevealTypeFunction</code> as if it were <code>Type::Function</code>. Because <code>reveal_type</code> is a function, and should behave as one.</p>
<p>This is another really good reason to store the inner <code>FunctionType</code> inside <code>RevealTypeFunction</code>.</p>
<blockquote>
<p>I think this makes <code>Type::expect_function</code> not operate as expected</p>
</blockquote>
<p>I think this makes <code>Type::expect_function</code> behave precisely how we want it to, which is that the caller can transparently get out the correct <code>FunctionType</code> without having to special-case <code>RevealTypeFunction</code>. Once the caller has the <code>FunctionType</code>, there&#x27;s no reason they should have to know or care about whether it was a <code>Type::Function</code> or <code>Type::RevealTypeFunction</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-18 15:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:334 on 2024-09-18 15:55</div>
            <div class="timeline-body"><blockquote>
<p>I think this makes <code>Type::expect_function</code> behave precisely how we want it to</p>
</blockquote>
<p>Well, you&#x27;ll at least need to change the message in the <code>.expect()</code> call here, to something like &quot;expected a variant that wraps a <code>FunctionType</code>&quot;</p>
<p>https://github.com/astral-sh/ruff/blob/4eb849aed3a6df9ce0f45dd7a2fdb525e31e61e3/crates/red_knot_python_semantic/src/types.rs#L332-L335</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 15:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:504 on 2024-09-18 15:57</div>
            <div class="timeline-body"><p>Yes, but this shouldn&#x27;t be handled as a special case for <code>CallOutcome::RevealType</code>, it should be handled by general call-argument-matching-and-validation, which applies to all function calls (and which we don&#x27;t have yet.) So this code is presuming that in the future (once we add call signature checking) you would get a diagnostic from that; we don&#x27;t need extra handling it for it here, we should just reveal unknown.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:524 on 2024-09-18 15:58</div>
            <div class="timeline-body"><p>That&#x27;s handled by <code>CallOutcome::return_ty</code> and <code>CallOutcome::unwrap_with_diagnostic</code>, in the <code>CallOutcome::Union</code> arms, where we do build a union of all the return types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 15:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 15:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:503 on 2024-09-18 15:59</div>
            <div class="timeline-body"><p>It would be possible here to instead set <code>return_ty</code> to the same as the revealed type. But this is another case where I would prefer to have less special-casing, and allow the return type to be inferred via the typeshed stubs, the same as for any other function. The result should be the same, although avoiding special-casing means we won&#x27;t have that correct result until we add support for generic functions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2418 on 2024-09-18 16:01</div>
            <div class="timeline-body"><p>Oops, that was an accidental holdover from a different aborted approach. Removed!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 16:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 16:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:378 on 2024-09-18 16:04</div>
            <div class="timeline-body"><p>Oops, no, this is wrong, good catch! I originally had it correct, and then in a review pass I was like &quot;wait, we always know it&#x27;s a stdlib symbol&quot;, forgetting that the semantics of the function are not &quot;is it a stdlib symbol&quot; but rather &quot;is it <em>this</em> stdlib symbol&quot;. Fixed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-18 16:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:504 on 2024-09-18 16:15</div>
            <div class="timeline-body"><p>Possibly. But then you end up with two diagnostics where one is the error and the other is the reveal type diagnostic which doesn&#x27;t seem ideal to me. But I can see that special casing reveal type&#x27;s diagnostic is probably more work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 16:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:334 on 2024-09-18 16:22</div>
            <div class="timeline-body"><p>Good call! Fixed the message.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 16:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:525 on 2024-09-18 16:24</div>
            <div class="timeline-body"><p>Maybe I should just remove these constructors, I&#x27;m not sure they are worth it. But for now I added new ones for <code>revealed</code> and <code>union</code>, for symmetry.</p>
<p>Eliminating <code>Type::call</code> is an interesting idea, but to me it seems clearer to keep it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 16:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:656 on 2024-09-18 16:27</div>
            <div class="timeline-body"><p>I don&#x27;t have any plans to address this. My document was just listing out pros and cons as I saw them of different options I&#x27;d considered in working on this, so as to be able to refer back to them later. My conclusion for now was to <em>not</em> do a context object, and stick with this style.</p>
<p>It&#x27;s very possible that we later decide it makes sense to do a type inference context object, but that&#x27;s not clear to me yet and not something I plan to do in the short term.</p>
<p>So if you don&#x27;t like the name &quot;Outcome&quot; then we should brainstorm alternative name options, and we can change both <code>CallOutcome</code> and <code>IterationOutcome</code>. But maybe in a separate PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 16:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:504 on 2024-09-18 16:40</div>
            <div class="timeline-body"><p>Good point that it may not make sense to even have a revealed-type diagnostic if the call to <code>reveal_type</code> is incorrect. But when we add call-signature checking (which can be shared in a common function used across both the <code>Function</code> and <code>RevealTypeFunction</code> arms, because it just needs the call arguments and the <code>FunctionType</code>), the <code>RevealTypeFunction</code> arm isn&#x27;t required to return a <code>CallOutcome::RevealType</code> at all. If it fails call signature checking, it can return a different outcome type, that won&#x27;t issue a revealed-type diagnostic at all.</p>
<p>So in that case you can consider this fallback just a temporary band-aid until we have call signature checking (which I already added a TODO for above.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 16:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 16:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-18 16:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 01:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 01:31</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t really see what the alternative would even be.</p>
</blockquote>
<p>The alternative would be this diff, right? All the red-knot tests pass if I apply this diff to <code>main</code>, and to me it seems much simpler conceptually. Perhaps it adds a performance cost, though, because you have to check whether the function is the <code>reveal_type</code> function every time you run <code>Type::Call</code>.</p>

Diff demonstrating an implementation without a new `Type` variant

<pre><code>diff --git a/crates/red_knot_python_semantic/src/types.rs b/crates/red_knot_python_semantic/src/types.rs
index 607fa80ac..38451fd9c 100644
--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -238,8 +238,6 @@ pub enum Type&lt;&#x27;db&gt; {
     None,
     /// a specific function object
     Function(FunctionType&lt;&#x27;db&gt;),
-    /// The `typing.reveal_type` function, which has special `__call__` behavior.
-    RevealTypeFunction(FunctionType&lt;&#x27;db&gt;),
     /// a specific module object
     Module(File),
     /// a specific class object
@@ -326,9 +324,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
 
     pub const fn into_function_type(self) -&gt; Option&lt;FunctionType&lt;&#x27;db&gt;&gt; {
         match self {
-            Type::Function(function_type) | Type::RevealTypeFunction(function_type) =&gt; {
-                Some(function_type)
-            }
+            Type::Function(function_type) =&gt; Some(function_type),
             _ =&gt; None,
         }
     }
@@ -374,9 +370,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
     pub fn is_stdlib_symbol(&amp;self, db: &amp;&#x27;db dyn Db, module_name: &amp;str, name: &amp;str) -&gt; bool {
         match self {
             Type::Class(class) =&gt; class.is_stdlib_symbol(db, module_name, name),
-            Type::Function(function) | Type::RevealTypeFunction(function) =&gt; {
-                function.is_stdlib_symbol(db, module_name, name)
-            }
+            Type::Function(function) =&gt; function.is_stdlib_symbol(db, module_name, name),
             _ =&gt; false,
         }
     }
@@ -450,7 +444,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
                 // TODO: attribute lookup on None type
                 Type::Unknown
             }
-            Type::Function(_) | Type::RevealTypeFunction(_) =&gt; {
+            Type::Function(_) =&gt; {
                 // TODO: attribute lookup on function type
                 Type::Unknown
             }
@@ -499,11 +493,16 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
     fn call(self, db: &amp;&#x27;db dyn Db, arg_types: &amp;[Type&lt;&#x27;db&gt;]) -&gt; CallOutcome&lt;&#x27;db&gt; {
         match self {
             // TODO validate typed call arguments vs callable signature
-            Type::Function(function_type) =&gt; CallOutcome::callable(function_type.return_type(db)),
-            Type::RevealTypeFunction(function_type) =&gt; CallOutcome::revealed(
-                function_type.return_type(db),
-                *arg_types.first().unwrap_or(&amp;Type::Unknown),
-            ),
+            Type::Function(function_type) =&gt; {
+                if function_type.is_stdlib_symbol(db, &quot;typing&quot;, &quot;reveal_type&quot;) {
+                    CallOutcome::revealed(
+                        function_type.return_type(db),
+                        *arg_types.first().unwrap_or(&amp;Type::Unknown),
+                    )
+                } else {
+                    CallOutcome::callable(function_type.return_type(db))
+                }
+            }
 
             // TODO annotated return type on `__new__` or metaclass `__call__`
             Type::Class(class) =&gt; CallOutcome::callable(Type::Instance(class)),
@@ -605,7 +604,6 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
             Type::BooleanLiteral(_)
             | Type::BytesLiteral(_)
             | Type::Function(_)
-            | Type::RevealTypeFunction(_)
             | Type::Instance(_)
             | Type::Module(_)
             | Type::IntLiteral(_)
@@ -628,7 +626,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
             Type::BooleanLiteral(_) =&gt; builtins_symbol_ty(db, &quot;bool&quot;),
             Type::BytesLiteral(_) =&gt; builtins_symbol_ty(db, &quot;bytes&quot;),
             Type::IntLiteral(_) =&gt; builtins_symbol_ty(db, &quot;int&quot;),
-            Type::Function(_) | Type::RevealTypeFunction(_) =&gt; types_symbol_ty(db, &quot;FunctionType&quot;),
+            Type::Function(_) =&gt; types_symbol_ty(db, &quot;FunctionType&quot;),
             Type::Module(_) =&gt; types_symbol_ty(db, &quot;ModuleType&quot;),
             Type::None =&gt; typeshed_symbol_ty(db, &quot;NoneType&quot;),
             // TODO not accurate if there&#x27;s a custom metaclass...
diff --git a/crates/red_knot_python_semantic/src/types/display.rs b/crates/red_knot_python_semantic/src/types/display.rs
index 3d037fe65..954a19d31 100644
--- a/crates/red_knot_python_semantic/src/types/display.rs
+++ b/crates/red_knot_python_semantic/src/types/display.rs
@@ -36,7 +36,6 @@ impl Display for DisplayType&lt;&#x27;_&gt; {
                 | Type::BytesLiteral(_)
                 | Type::Class(_)
                 | Type::Function(_)
-                | Type::RevealTypeFunction(_)
         ) {
             write!(f, &quot;Literal[{representation}]&quot;,)
         } else {
@@ -73,9 +72,7 @@ impl Display for DisplayRepresentation&lt;&#x27;_&gt; {
             // TODO functions and classes should display using a fully qualified name
             Type::Class(class) =&gt; f.write_str(class.name(self.db)),
             Type::Instance(class) =&gt; f.write_str(class.name(self.db)),
-            Type::Function(function) | Type::RevealTypeFunction(function) =&gt; {
-                f.write_str(function.name(self.db))
-            }
+            Type::Function(function) =&gt; f.write_str(function.name(self.db)),
             Type::Union(union) =&gt; union.display(self.db).fmt(f),
             Type::Intersection(intersection) =&gt; intersection.display(self.db).fmt(f),
             Type::IntLiteral(n) =&gt; n.fmt(f),
@@ -194,7 +191,7 @@ impl TryFrom&lt;Type&lt;&#x27;_&gt;&gt; for LiteralTypeKind {
     fn try_from(value: Type&lt;&#x27;_&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
         match value {
             Type::Class(_) =&gt; Ok(Self::Class),
-            Type::Function(_) | Type::RevealTypeFunction(_) =&gt; Ok(Self::Function),
+            Type::Function(_) =&gt; Ok(Self::Function),
             Type::IntLiteral(_) =&gt; Ok(Self::IntLiteral),
             Type::StringLiteral(_) =&gt; Ok(Self::StringLiteral),
             Type::BytesLiteral(_) =&gt; Ok(Self::BytesLiteral),
diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index 52d95f1be..c53ce7b27 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -704,12 +704,12 @@ impl&lt;&#x27;db&gt; TypeInferenceBuilder&lt;&#x27;db&gt; {
             }
         }
 
-        let function_type = FunctionType::new(self.db, name.id.clone(), definition, decorator_tys);
-        let function_ty = if function_type.is_stdlib_symbol(self.db, &quot;typing&quot;, &quot;reveal_type&quot;) {
-            Type::RevealTypeFunction(function_type)
-        } else {
-            Type::Function(function_type)
-        };
+        let function_ty = Type::Function(FunctionType::new(
+            self.db,
+            name.id.clone(),
+            definition,
+            decorator_tys,
+        ));
 
         self.add_declaration_with_binding(function.into(), definition, function_ty, function_ty);
     }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 01:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 01:35</div>
            <div class="timeline-body"><p>Sure, yeah -- that&#x27;s what I addressed in my second paragraph. I guess my first paragraph didn&#x27;t make much sense / wasn&#x27;t relevant, because you&#x27;re not suggesting not using types at all.</p>
<p>This approach is definitely simpler, but I considered it a performance nonstarter to add the overhead of <code>is_stdlib_symbol</code> to every Type::call. Perhaps that&#x27;s premature optimization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 01:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 01:39</div>
            <div class="timeline-body"><p>I expect <code>Type::Call</code> to be pretty darn hot (even attribute accesses may need to invoke it once we implement the descriptor protocol), so I think it&#x27;s reasonable to worry about the performance of the method. Just as long as we&#x27;re on the same page about <em>why</em> we&#x27;re using a separate variant ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 14:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 14:45</div>
            <div class="timeline-body"><p>Yet another option might be to add a boolean field (which in the long term would probably be better as a bitflag or enum field) to <code>FunctionType</code>. We could determine once when we create <code>FunctionType</code> objects whether it&#x27;s a regular function or a &quot;special&quot; function (<code>reveal_type</code>/<code>assert_type</code>/<code>cast</code>/<code>final</code>/<code>overload</code>/<code>override</code>/<code>no_type_check</code>/<code>type_check_only</code>/<code>runtime_checkable</code>/<code>dataclasses.dataclass</code>/<code>dataclasses.field</code>/<code>enum.unique</code>/<code>enum.member</code>/<code>enum.nonmember</code>/<code>dataclass_transform</code>/<code>warnings.deprecated</code>/etc.), and store that information on <code>FunctionType</code> in such a way that it could be cheaply queried from <code>Type::Call</code>:</p>


<pre><code>diff --git a/crates/red_knot_python_semantic/src/semantic_index/definition.rs b/crates/red_knot_python_semantic/src/semantic_index/definition.rs
index 35b1fefc9..0104515af 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/definition.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/definition.rs
@@ -3,6 +3,7 @@ use ruff_db::parsed::ParsedModule;
 use ruff_python_ast as ast;
 
 use crate::ast_node_ref::AstNodeRef;
+use crate::module_resolver::file_to_module;
 use crate::node_key::NodeKey;
 use crate::semantic_index::symbol::{FileScopeId, ScopeId, ScopedSymbolId};
 use crate::Db;
@@ -45,6 +46,14 @@ impl&lt;&#x27;db&gt; Definition&lt;&#x27;db&gt; {
     pub(crate) fn is_binding(self, db: &amp;&#x27;db dyn Db) -&gt; bool {
         self.kind(db).category().is_binding()
     }
+
+    /// Return true if this is a symbol was defined in the `typing` or `typing_extensions` modules
+    pub(crate) fn is_typing_definition(self, db: &amp;&#x27;db dyn Db) -&gt; bool {
+        file_to_module(db, self.file(db)).is_some_and(|module| {
+            module.search_path().is_standard_library()
+                &amp;&amp; matches!(&amp;**module.name(), &quot;typing&quot; | &quot;typing_extensions&quot;)
+        })
+    }
 }
 
 #[derive(Copy, Clone, Debug)]
diff --git a/crates/red_knot_python_semantic/src/types.rs b/crates/red_knot_python_semantic/src/types.rs
index 31355eb48..f31b13f81 100644
--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -245,8 +245,6 @@ pub enum Type&lt;&#x27;db&gt; {
     None,
     /// a specific function object
     Function(FunctionType&lt;&#x27;db&gt;),
-    /// The `typing.reveal_type` function, which has special `__call__` behavior.
-    RevealTypeFunction(FunctionType&lt;&#x27;db&gt;),
     /// a specific module object
     Module(File),
     /// a specific class object
@@ -333,9 +331,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
 
     pub const fn into_function_type(self) -&gt; Option&lt;FunctionType&lt;&#x27;db&gt;&gt; {
         match self {
-            Type::Function(function_type) | Type::RevealTypeFunction(function_type) =&gt; {
-                Some(function_type)
-            }
+            Type::Function(function_type) =&gt; Some(function_type),
             _ =&gt; None,
         }
     }
@@ -381,9 +377,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
     pub fn is_stdlib_symbol(&amp;self, db: &amp;&#x27;db dyn Db, module_name: &amp;str, name: &amp;str) -&gt; bool {
         match self {
             Type::Class(class) =&gt; class.is_stdlib_symbol(db, module_name, name),
-            Type::Function(function) | Type::RevealTypeFunction(function) =&gt; {
-                function.is_stdlib_symbol(db, module_name, name)
-            }
+            Type::Function(function) =&gt; function.is_stdlib_symbol(db, module_name, name),
             _ =&gt; false,
         }
     }
@@ -475,7 +469,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
                 // TODO: attribute lookup on None type
                 Type::Unknown
             }
-            Type::Function(_) | Type::RevealTypeFunction(_) =&gt; {
+            Type::Function(_) =&gt; {
                 // TODO: attribute lookup on function type
                 Type::Unknown
             }
@@ -524,11 +518,16 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
     fn call(self, db: &amp;&#x27;db dyn Db, arg_types: &amp;[Type&lt;&#x27;db&gt;]) -&gt; CallOutcome&lt;&#x27;db&gt; {
         match self {
             // TODO validate typed call arguments vs callable signature
-            Type::Function(function_type) =&gt; CallOutcome::callable(function_type.return_type(db)),
-            Type::RevealTypeFunction(function_type) =&gt; CallOutcome::revealed(
-                function_type.return_type(db),
-                *arg_types.first().unwrap_or(&amp;Type::Unknown),
-            ),
+            Type::Function(function_type) =&gt; {
+                if function_type.is_reveal_type(db) {
+                    CallOutcome::revealed(
+                        function_type.return_type(db),
+                        *arg_types.first().unwrap_or(&amp;Type::Unknown),
+                    )
+                } else {
+                    CallOutcome::callable(function_type.return_type(db))
+                }
+            }
 
             // TODO annotated return type on `__new__` or metaclass `__call__`
             Type::Class(class) =&gt; CallOutcome::callable(Type::Instance(class)),
@@ -630,7 +629,6 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
             Type::BooleanLiteral(_)
             | Type::BytesLiteral(_)
             | Type::Function(_)
-            | Type::RevealTypeFunction(_)
             | Type::Instance(_)
             | Type::Module(_)
             | Type::IntLiteral(_)
@@ -653,7 +651,7 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
             Type::BooleanLiteral(_) =&gt; builtins_symbol_ty(db, &quot;bool&quot;),
             Type::BytesLiteral(_) =&gt; builtins_symbol_ty(db, &quot;bytes&quot;),
             Type::IntLiteral(_) =&gt; builtins_symbol_ty(db, &quot;int&quot;),
-            Type::Function(_) | Type::RevealTypeFunction(_) =&gt; types_symbol_ty(db, &quot;FunctionType&quot;),
+            Type::Function(_) =&gt; types_symbol_ty(db, &quot;FunctionType&quot;),
             Type::Module(_) =&gt; types_symbol_ty(db, &quot;ModuleType&quot;),
             Type::None =&gt; typeshed_symbol_ty(db, &quot;NoneType&quot;),
             // TODO not accurate if there&#x27;s a custom metaclass...
@@ -864,6 +862,9 @@ pub struct FunctionType&lt;&#x27;db&gt; {
     #[return_ref]
     pub name: ast::name::Name,
 
+    /// Flag to indicate that this function is `typing(_extensions).reveal_type`
+    is_reveal_type: bool,
+
     definition: Definition&lt;&#x27;db&gt;,
 
     /// types of all decorators on this function
@@ -879,15 +880,6 @@ impl&lt;&#x27;db&gt; FunctionType&lt;&#x27;db&gt; {
             })
     }
 
-    /// Return true if this is a symbol with given name from `typing` or `typing_extensions`.
-    pub(crate) fn is_typing_symbol(self, db: &amp;&#x27;db dyn Db, name: &amp;str) -&gt; bool {
-        name == self.name(db)
-            &amp;&amp; file_to_module(db, self.definition(db).file(db)).is_some_and(|module| {
-                module.search_path().is_standard_library()
-                    &amp;&amp; matches!(&amp;**module.name(), &quot;typing&quot; | &quot;typing_extensions&quot;)
-            })
-    }
-
     pub fn has_decorator(self, db: &amp;dyn Db, decorator: Type&lt;&#x27;_&gt;) -&gt; bool {
         self.decorators(db).contains(&amp;decorator)
     }
diff --git a/crates/red_knot_python_semantic/src/types/display.rs b/crates/red_knot_python_semantic/src/types/display.rs
index 3d037fe65..954a19d31 100644
--- a/crates/red_knot_python_semantic/src/types/display.rs
+++ b/crates/red_knot_python_semantic/src/types/display.rs
@@ -36,7 +36,6 @@ impl Display for DisplayType&lt;&#x27;_&gt; {
                 | Type::BytesLiteral(_)
                 | Type::Class(_)
                 | Type::Function(_)
-                | Type::RevealTypeFunction(_)
         ) {
             write!(f, &quot;Literal[{representation}]&quot;,)
         } else {
@@ -73,9 +72,7 @@ impl Display for DisplayRepresentation&lt;&#x27;_&gt; {
             // TODO functions and classes should display using a fully qualified name
             Type::Class(class) =&gt; f.write_str(class.name(self.db)),
             Type::Instance(class) =&gt; f.write_str(class.name(self.db)),
-            Type::Function(function) | Type::RevealTypeFunction(function) =&gt; {
-                f.write_str(function.name(self.db))
-            }
+            Type::Function(function) =&gt; f.write_str(function.name(self.db)),
             Type::Union(union) =&gt; union.display(self.db).fmt(f),
             Type::Intersection(intersection) =&gt; intersection.display(self.db).fmt(f),
             Type::IntLiteral(n) =&gt; n.fmt(f),
@@ -194,7 +191,7 @@ impl TryFrom&lt;Type&lt;&#x27;_&gt;&gt; for LiteralTypeKind {
     fn try_from(value: Type&lt;&#x27;_&gt;) -&gt; Result&lt;Self, Self::Error&gt; {
         match value {
             Type::Class(_) =&gt; Ok(Self::Class),
-            Type::Function(_) | Type::RevealTypeFunction(_) =&gt; Ok(Self::Function),
+            Type::Function(_) =&gt; Ok(Self::Function),
             Type::IntLiteral(_) =&gt; Ok(Self::IntLiteral),
             Type::StringLiteral(_) =&gt; Ok(Self::StringLiteral),
             Type::BytesLiteral(_) =&gt; Ok(Self::BytesLiteral),
diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index fa5197f5f..865aeeef9 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -711,12 +711,13 @@ impl&lt;&#x27;db&gt; TypeInferenceBuilder&lt;&#x27;db&gt; {
             }
         }
 
-        let function_type = FunctionType::new(self.db, name.id.clone(), definition, decorator_tys);
-        let function_ty = if function_type.is_typing_symbol(self.db, &quot;reveal_type&quot;) {
-            Type::RevealTypeFunction(function_type)
-        } else {
-            Type::Function(function_type)
-        };
+        let function_ty = Type::Function(FunctionType::new(
+            self.db,
+            name.id.clone(),
+            name == &quot;reveal_type&quot; &amp;&amp; definition.is_typing_definition(self.db),
+            definition,
+            decorator_tys,
+        ));
 
         self.add_declaration_with_binding(function.into(), definition, function_ty, function_ty);
     }
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 16:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 16:08</div>
            <div class="timeline-body"><p>Yes, this is an option worth considering. I didn&#x27;t go with it here because it has a higher memory cost (every function type, even the vast majority of non-special ones, now takes up an extra 8 bytes); I was pretty focused on doing this in a way that adds near-zero cost for the common case. But it may be over time that <code>FunctionType</code> is large enough that this isn&#x27;t a significant additional cost, and/or we end up needing a set of bitflags anyway so it&#x27;s no extra cost. Or we have so many special function types that representing them all as <code>Type</code> variants bumps up the size of the <code>Type</code> enum, and that ends up being higher cost. So I can envision lots of potential reasons why it might make sense to switch to the flag approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 16:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 16:42</div>
            <div class="timeline-body"><blockquote>
<p>Or we have so many special function types that representing them all as <code>Type</code> variants bumps up the size of the <code>Type</code> enum, and that ends up being higher cost.</p>
</blockquote>
<p>@MichaReiser can correct me if I&#x27;m wrong, but I don&#x27;t believe the number of variants in an enum has an impact on the size of an enum -- I think an enum always just has the size of its largest variant. (Possibly it leads to a larger amount of generated code if you have more variants, though, since the compiler has to generate different code paths for each possible branch?) I&#x27;m more concerned about the maintenance cost of having so many possible function-like <code>Type</code> variants representing &quot;special functions&quot;. ISTM that there&#x27;s an implicit invariant that they should all work exactly the same way as <code>Type::Function</code> in nearly every respect (most of them will only need special handling in <code>Type::Call</code>, I think?).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 17:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 17:08</div>
            <div class="timeline-body"><p>Yes, I agree the code maintenance is a bigger concern as we accumulate lots of these.</p>
<p>If the contained data inside enum variants is large, that will dominate the overall size of the enum. But in this case the contained data is small (usually just a u32 id; I think <code>IntLiteral</code> is currently our largest variant, as it contains an <code>i64</code>), so the need to find niches to discriminate the enum variants themselves can be relevant. Though in practice in this case there just aren&#x27;t any niches available in an <code>i64</code>, so the enum requires another entire 8 bytes for the discriminant (doubling the overall size of <code>Type</code> to 16 bytes), and we are certainly not going to reach 2^64 variants 😆</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 18:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 18:19</div>
            <div class="timeline-body"><blockquote>
<p>doubling the overall size of <code>Type</code> to 16 bytes</p>
</blockquote>
<p>I believe a <code>FunctionType</code> instance is actually just a <code>u32</code>, though, since it&#x27;s a salsa-tracked struct — right? So adding a boolean field to <code>FunctionType</code> would increase the size of the underlying data stored in the salsa cache for each <code>FunctionType</code> instance, but wouldn&#x27;t actually increase the size of the <code>Type</code> enum...?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 18:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 18:21</div>
            <div class="timeline-body"><p>Yes, that&#x27;s right. I never mentioned the size of the Type enum in relation to adding a boolean to FunctionType. I only brought up the size of the Type enum in relation to having a ton of extra Type variants in the future, and it&#x27;s probably not even really relevant there.</p>
<p>Making every FunctionType bigger is less bad than making the Type enum bigger would be, but we will have quite a large number of FunctionType in the db.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 18:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 18:43</div>
            <div class="timeline-body"><p>Sorry, that was a sloppy misreading of what you said there!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 18:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:242 on 2024-09-19 18:45</div>
            <div class="timeline-body"><p>No worries!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:06:48 UTC
    </footer>
</body>
</html>
