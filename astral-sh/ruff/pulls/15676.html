<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Consider all definitions after terminal statements unreachable - astral-sh/ruff #15676</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Consider all definitions after terminal statements unreachable</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15676">#15676</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-01-22 21:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p><code>FlowSnapshot</code> now tracks a <code>reachable</code> bool, which indicates whether we have encountered a terminal statement on that control flow path.  When merging flow states together, we skip any that have been marked unreachable.  This ensures that bindings that can only be reached through unreachable paths are not considered visible.</p>
Test Plan
<p>The new mdtests failed (with incorrect <code>reveal_type</code> results, and spurious <code>possibly-unresolved-reference</code> errors) before adding the new visibility constraints.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 21:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 21:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 21:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 21:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 21:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-22 21:57</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>‚ÑπÔ∏è ecosystem check <strong>detected linter changes</strong>. (+5 -5 violations, +0 -0 fixes in 2 projects; 53 projects unchanged)</p>
<a href="https://github.com/bokeh/bokeh">bokeh/bokeh</a> (+4 -4 violations, +0 -0 fixes)
<p>
<pre>ruff check --no-cache --exit-zero --ignore RUF9 --no-fix --output-format concise --no-preview --select ALL</pre>
</p>
<p>

<pre>
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_embed.py#L26">examples/server/api/flask_embed.py:26:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_embed.py#L26">examples/server/api/flask_embed.py:26:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_gunicorn_embed.py#L41">examples/server/api/flask_gunicorn_embed.py:41:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_gunicorn_embed.py#L41">examples/server/api/flask_gunicorn_embed.py:41:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/standalone_embed.py#L18">examples/server/api/standalone_embed.py:18:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/standalone_embed.py#L18">examples/server/api/standalone_embed.py:18:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/tornado_embed.py#L29">examples/server/api/tornado_embed.py:29:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/tornado_embed.py#L29">examples/server/api/tornado_embed.py:29:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
</pre>

</p>

<a href="https://github.com/zulip/zulip">zulip/zulip</a> (+1 -1 violations, +0 -0 fixes)
<p>
<pre>ruff check --no-cache --exit-zero --ignore RUF9 --no-fix --output-format concise --no-preview --select ALL</pre>
</p>
<p>

<pre>
+ <a href="https://github.com/zulip/zulip/blob/861917d2c50418aa2d641c57e1cfe147113ca45c/scripts/lib/sharding.py#L65">scripts/lib/sharding.py:65:21:</a> SIM108 Use ternary operator `host = shard if &quot;.&quot; in shard else f&quot;{shard}.{external_host}&quot;` instead of `if`-`else`-block
- <a href="https://github.com/zulip/zulip/blob/861917d2c50418aa2d641c57e1cfe147113ca45c/scripts/lib/sharding.py#L65">scripts/lib/sharding.py:65:21:</a> SIM108 Use ternary operator `host = shard if &quot;.&quot; in shard else f&#x27;{shard}.{external_host}&#x27;` instead of `if`-`else`-block
</pre>

</p>

Changes by rule (1 rules affected)
<p>

<p>| code | total | + violation | - violation | + fix | - fix |
| ---- | ------- | --------- | -------- | ----- | ---- |
| SIM108 | 10 | 5 | 5 | 0 | 0 |</p>
</p>


Linter (preview)
<p>‚ÑπÔ∏è ecosystem check <strong>detected linter changes</strong>. (+5 -5 violations, +0 -0 fixes in 2 projects; 53 projects unchanged)</p>
<a href="https://github.com/bokeh/bokeh">bokeh/bokeh</a> (+4 -4 violations, +0 -0 fixes)
<p>
<pre>ruff check --no-cache --exit-zero --ignore RUF9 --no-fix --output-format concise --preview --select ALL</pre>
</p>
<p>

<pre>
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_embed.py#L26">examples/server/api/flask_embed.py:26:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_embed.py#L26">examples/server/api/flask_embed.py:26:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_gunicorn_embed.py#L41">examples/server/api/flask_gunicorn_embed.py:41:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/flask_gunicorn_embed.py#L41">examples/server/api/flask_gunicorn_embed.py:41:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/standalone_embed.py#L18">examples/server/api/standalone_embed.py:18:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/standalone_embed.py#L18">examples/server/api/standalone_embed.py:18:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
+ <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/tornado_embed.py#L29">examples/server/api/tornado_embed.py:29:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&quot;{new}D&quot;).mean()` instead of `if`-`else`-block
- <a href="https://github.com/bokeh/bokeh/blob/829b2a75c402d0d0abd7e37ff201fbdfd949d857/examples/server/api/tornado_embed.py#L29">examples/server/api/tornado_embed.py:29:9:</a> SIM108 Use ternary operator `data = df if new == 0 else df.rolling(f&#x27;{new}D&#x27;).mean()` instead of `if`-`else`-block
</pre>

</p>

<a href="https://github.com/zulip/zulip">zulip/zulip</a> (+1 -1 violations, +0 -0 fixes)
<p>
<pre>ruff check --no-cache --exit-zero --ignore RUF9 --no-fix --output-format concise --preview --select ALL</pre>
</p>
<p>

<pre>
+ <a href="https://github.com/zulip/zulip/blob/861917d2c50418aa2d641c57e1cfe147113ca45c/scripts/lib/sharding.py#L65">scripts/lib/sharding.py:65:21:</a> SIM108 Use ternary operator `host = shard if &quot;.&quot; in shard else f&quot;{shard}.{external_host}&quot;` instead of `if`-`else`-block
- <a href="https://github.com/zulip/zulip/blob/861917d2c50418aa2d641c57e1cfe147113ca45c/scripts/lib/sharding.py#L65">scripts/lib/sharding.py:65:21:</a> SIM108 Use ternary operator `host = shard if &quot;.&quot; in shard else f&#x27;{shard}.{external_host}&#x27;` instead of `if`-`else`-block
</pre>

</p>

Changes by rule (1 rules affected)
<p>

<p>| code | total | + violation | - violation | + fix | - fix |
| ---- | ------- | --------- | -------- | ----- | ---- |
| SIM108 | 10 | 5 | 5 | 0 | 0 |</p>
</p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 22:07</div>
            <div class="timeline-body"><p>There are a couple of new diagnostics in the benchmark that don&#x27;t look correct to me.  I need to see if I can minimize that into an mdtest to diagnose.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-22 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:43 on 2025-01-22 22:08</div>
            <div class="timeline-body"><p>Just to clarify, since it took me a moment on first read, even though you just explained it above:</p>
<pre><code>    return x  # no possibly-unresolved-reference diagnostic!
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:91 on 2025-01-22 22:10</div>
            <div class="timeline-body"><p>We could <code>return x</code> here as well and expect the <code>possibly-unresolved-reference</code> error?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:107 on 2025-01-22 22:12</div>
            <div class="timeline-body"><p>I don&#x27;t think &quot;nested scopes&quot; is the right term here; Python <code>if</code> statements don&#x27;t establish nested scopes. This heading would suggest a test with e.g. a nested function.</p>
<pre><code>## `return` is terminal in nested conditionals
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-22 22:14</div>
            <div class="timeline-body"><p>Fantastic!! Love to see a feature that is easier than anticipated :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/T-256">@T-256</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:257 on 2025-01-22 23:53</div>
            <div class="timeline-body"><p>I&#x27;m curious in which combination of <code>cond</code> and <code>i</code> it&#x27;d be <code>Literal[&quot;loop&quot;]</code> at here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/T-256">@T-256</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:69 on 2025-01-22 23:58</div>
            <div class="timeline-body"><p>You may want to switch to <code>for</code> loop instead or increase <code>i</code>&#x27;s value inside the loop, otherwise it&#x27;s infinite loop when <code>i&lt;5</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/T-256">@T-256</a> reviewed on 2025-01-23 00:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-01-23 22:16</div>
            <div class="timeline-body"><p>I don&#x27;t think you need to change anything for this PR, but just so it&#x27;s on your radar: <code>try</code>/<code>finally</code> knows how to ruin any clean story. For example, the following test fails on this branch:</p>
<pre><code>def f():
    x = 1
    while True:
        try:
            break
        finally:
            x = 2
    reveal_type(x)  # revealed: Literal[2] 
</code></pre>
<p>(it gives a revealed type of <code>Literal[1]</code> instead)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-23 23:08</div>
            <div class="timeline-body"><p>Yeah, we can handle <code>finally</code> in this PR or as a separate follow up PR, but it probably will need some special handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:69 on 2025-01-24 19:35</div>
            <div class="timeline-body"><p>Fair point!  I originally had this as <code>while True</code> (i.e. a purposefully infinite loop), but our flow analysis was smart enough to see that we&#x27;d never leave the loop.  <code>while i &lt; 5</code> is not something we can currently detect as infinite, even though it&#x27;s clear that <code>i</code> is never modified.  That might change with @carljm&#x27;s fixed point work, so I&#x27;ve changed it to a <code>for</code> loop so that we don&#x27;t get a regression if/when that changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:257 on 2025-01-24 19:38</div>
            <div class="timeline-body"><p>At runtime it couldn&#x27;t, but per above, our flow analysis couldn&#x27;t detect that.  It couldn&#x27;t see that <code>i</code> is not modified, so it had to assume there was some control flow path that executed the <code>while</code> body at least once but not an infinite number of times.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:91 on 2025-01-24 19:39</div>
            <div class="timeline-body"><p>Done.  And it turns out to be <code>unresolved</code>, not <code>possibly-unresolved</code>, since we can now see that the only binding is blocked by the <code>return</code> statement!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-24 19:44</div>
            <div class="timeline-body"><blockquote>
<p>For example, the following test fails on this branch:</p>
</blockquote>
<p>Thanks @dylwil3!  I added that as a failing test case.  I&#x27;m going to poke at it briefly to see if it&#x27;s easy to add for this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-24 19:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:257 on 2025-01-24 19:59</div>
            <div class="timeline-body"><p>Ooh, this is now incorrect.  It should be <code>Literal[&quot;before&quot;, &quot;loop&quot;, &quot;continue&quot;]</code>:</p>
<p>If <code>i &lt;= 0</code>, the loop body won&#x27;t execute, and <code>x == &quot;before&quot;</code>.
If <code>i &gt; 0 and cond</code>, the loop body will execute <code>i</code> times, each time assigning <code>&quot;loop&quot;</code>.
If <code>i &gt; 0 and not cond</code>, the loop body will execute <code>i</code> times, each time assigning <code>&quot;continue&quot;</code>.</p>
<p>The <code>continue</code> statement should mark its flow as unreachable <em>for when we join the <code>if</code> branches</em>.  But it should <em>not</em> be considered unreachable when we join with the <code>for</code> loop&#x27;s continuation and exit paths.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:257 on 2025-01-27 21:22</div>
            <div class="timeline-body"><p>After discussing in Discord, we&#x27;ve decided that this incorrect result is not because of the new terminal statement handling, but because we&#x27;re not currently handling <em>any</em> loop back-links (including <code>continue</code> statements) pending fixpoint support in salsa.  cf <a href="https://github.com/astral-sh/ruff/issues/14160">astral-sh/ruff#14160</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-27 21:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-27 21:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-27 22:03</div>
            <div class="timeline-body"><blockquote>
<p>We can use the new statically known branches feature to address</p>
</blockquote>
<p>Nit: update the PR description to match how the PR currently works.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:23 on 2025-01-27 22:12</div>
            <div class="timeline-body"><p>Nit: &quot;unreachable&quot; is a possibly-confusing term here, since (in terms of control flow) the assignment <code>x = &quot;unreachable&quot;</code> certainly is reachable. But that binding is not visible from later in the function. Sometimes we&#x27;ve carelessly used the term &quot;reachable&quot; to refer to a binding that is visible from later in control flow, but I&#x27;ve tried to avoid that usage in favor of &quot;visible&quot; or &quot;reaching&quot; (that is, the definition <em>reaches</em> a later point in control flow, not &quot;is reachable from&quot; a later point in control flow -- control flow flows forward, not backward.)</p>
<p>All that said, it clearly doesn&#x27;t matter too much what word we use in this string in this test :) But I would probably favor <code>&quot;terminal&quot;</code> instead?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:56 on 2025-01-27 22:17</div>
            <div class="timeline-body"><p>More terminology nits! &quot;Loop scope&quot; not really a thing in Python, probably best to avoid possible confusion.</p>
<p>A more accurate phrasing might be &quot;<code>continue</code> is terminal in local control flow, but represents a jump back to top-of-loop&quot; -- but this is too much to squeeze into a heading. The heading could perhaps just be one word: <code>continue</code>, and we can elaborate in prose?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:86 on 2025-01-27 22:17</div>
            <div class="timeline-body"><p>same comment as above</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:51 on 2025-01-27 22:17</div>
            <div class="timeline-body"><p>same comment as above</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:112 on 2025-01-27 22:20</div>
            <div class="timeline-body"><p>Maybe you have it below and I haven&#x27;t gotten there yet, but somewhere I&#x27;d like to see a test showing we understand that if we have terminals in both <code>if</code> and <code>else</code> branches, that translates to the merged flow after the if/else also being terminal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:141 on 2025-01-27 22:26</div>
            <div class="timeline-body"><p>This test looks fine. I think we should have at least a couple additional tests showing correct handling of terminals in <code>try/except</code> blocks in various cases. Some examples that come to mind:</p>
<ul>
<li><code>raise</code> or <code>return</code> inside a <code>try</code> block (bindings from before the <code>raise</code> are visible in <code>except</code> and <code>finally</code> and beyond the whole <code>try</code> statement, bindings from after the <code>raise</code> are not)</li>
<li><code>return</code> inside an <code>except</code> block means bindings in that block are not visible later</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:589 on 2025-01-27 22:27</div>
            <div class="timeline-body"><p>We should be able to at least eliminate this <code>Unknown</code>, because there is no other scope which can assign to <code>x</code>:</p>
<pre><code>        # TODO eliminate Unknown
        reveal_type(x)  # revealed: Unknown | Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:187 on 2025-01-27 22:28</div>
            <div class="timeline-body"><pre><code>        # TODO: Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:200 on 2025-01-27 22:28</div>
            <div class="timeline-body"><pre><code>        # TODO: Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:216 on 2025-01-27 22:32</div>
            <div class="timeline-body"><p>A return at the end of the function isn&#x27;t really an &quot;early return&quot;, contrary to the test title.</p>
<p>Is this test testing some code that was added in this PR? It doesn&#x27;t clearly seem to test anything about terminality of <code>return</code>.</p>
<p>This test intersects with two known-incorrect areas (closed-over vars in scopes with <code>return</code> statements, modeling of eagerly-executing nested scopes), has no <code>reveal_type</code> (so asserts nothing more than &quot;no diagnostics here&quot;) and doesn&#x27;t demonstrate any TODOs. This makes me question its value as a test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:707 on 2025-01-27 23:44</div>
            <div class="timeline-body"><p>There is also the possibility that neither <code>self</code> nor <code>snapshot</code> is reachable. This code will correctly result in <code>self</code> still being marked unreachable in that case, but it seems a little odd that we keep the visible definitions state from <code>self</code> in that case. The logical extension of the idea that an unreachable state takes no part in a merge should be that in case neither are reachable, we reset <code>self</code> to a state with <code>reachable: false</code> and no visible definitions, right?</p>
<p>Not sure if it practically makes a difference, though; since the new state is still unreachable its visible definitions shouldn&#x27;t &quot;go&quot; anywhere anyway, even if <code>self</code> is later merged into another state. I guess it will make a difference to the types we reveal in the following unreachable code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:731 on 2025-01-27 23:45</div>
            <div class="timeline-body"><p>If we&#x27;ve gotten past the top-of-function checks, we know that <em>both</em> of the two states were reachable, right? So this comment understates what we know here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_benchmark/benches/red_knot.rs</code>:44 on 2025-01-27 23:45</div>
            <div class="timeline-body"><p>üéâ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-27 23:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-28 12:01</div>
            <div class="timeline-body"><p>I haven&#x27;t followed the full conversation on this topic, so maybe I have missed this being discussed somewhere. I&#x27;m also not sure if this is out-of-scope for this PR or out-of-scope in general, but I was curious how the interplay between statically-known branches and terminal statements worked, and it looks like this is something that this approach does not handle (yet)?</p>
<pre><code>def _(cond: bool):
    x = &quot;a&quot;
    if cond:
        x = &quot;b&quot;
        if True:
            return

    reveal_type(x)  # revealed: &quot;a&quot;, &quot;b&quot;; should be &quot;a&quot;
</code></pre>
<p>I understand that this is probably difficult to handle with our &quot;delayed&quot; handling of statically-known branches, but it seems worth to mention as a limitation, because pyright can handle situations like this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:23 on 2025-01-28 14:34</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:51 on 2025-01-28 14:34</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:56 on 2025-01-28 14:43</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:86 on 2025-01-28 14:48</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:216 on 2025-01-28 14:53</div>
            <div class="timeline-body"><p>This is a minimal reproduction of an error I was getting in the <code>tomllib</code> benchmark test.  I thought to put it here to catch it earlier in the CI process, but since it&#x27;s redundant with the <code>tomllib</code> test I&#x27;ll remove it.  (Maybe a better way to handle this is to move the assertions out of the benchmark and into a new test case that also analyzes <code>tomllib</code>?  That way the benchmark is only concerned with performance, and the test with correctness.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:112 on 2025-01-28 15:06</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:707 on 2025-01-28 15:21</div>
            <div class="timeline-body"><blockquote>
<p>but it seems a little odd that we keep the visible definitions state from <code>self</code> in that case</p>
</blockquote>
<p>If we want this, I think it would be best to add an invariant that marking a flow as unreachable clears out all of its definitions, and update <code>mark_unreachable</code> and <code>restore</code> to maintain that invariant.  Then this code in <code>merge</code> would do the right thing as you describe.</p>
<blockquote>
<p>I guess it will make a difference to the types we reveal in the following unreachable code?</p>
</blockquote>
<p>Yes, that&#x27;s exactly right.  (In the sense that that&#x27;s what the code does, not necessarily that that&#x27;s what we <em>want</em> it to do :sweat_smile:)  For now, I was punting on this, because this PR isn&#x27;t currently addressing what we want to do for unreachable code.  (Note that in the mdtests I&#x27;ve tried to not put in any <code>reveal_type</code>s in unreachable positions.)</p>
<p>I think there are a couple of issues at play here.  One is that, not even considering the merge, what do we want to report in the unreachable code within the same block after a terminal statement?</p>
<pre><code>x = 2
return
reveal_type(x)  # ???
</code></pre>
<p>Should it be an <code>unresolved-reference</code> error?  Or should it act as if the terminal statement weren&#x27;t there, and show what <code>x</code> would be if control flow could somehow make it to that point?  Or should we silence all diagnostics completely in unreachable code?</p>
<p>Whatever we choose, we should have the same result for</p>
<pre><code>if cond:
    x = 2
    return
else:
    x = 3
    return
reveal_type(x)  # ???
</code></pre>
<p>If we decide that we want the first case to reveal <code>Literal[2]</code>, then we&#x27;d want this case to reveal <code>Literal[2, 3]</code> ‚Äî which means that we actually <em>do</em> want to merge all of the flows, even if they&#x27;re unreachable, and it&#x27;s just the visibility of the relevant symbols that needs to be tracked/adjusted somehow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:731 on 2025-01-28 15:23</div>
            <div class="timeline-body"><p>Yes good catch!  Stale comment from a previous iteration of this function.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-28 15:29</div>
            <div class="timeline-body"><blockquote>
<p>but I was curious how the interplay between statically-known branches and terminal statements worked</p>
</blockquote>
<p>That&#x27;s a good example @sharkdp!  Before I was also adding a <code>~AlwaysTrue</code> visibility constraint when we encountered a terminal statement, which (edit: I think) would handle your example.  I removed it because it seemed to be interacting incorrectly with <code>continue</code> and <code>break</code>.  (The new visibility constraint should apply to the rest of the current flow, but should <em>not</em> apply when we jump back to the beginning of the loop.)  But @carljm and I convinced each other in Discord that the issue with <code>continue</code> is that we haven&#x27;t implemented the jump back to top-of-loop yet (pending fixpoint support in salsa) ‚Äî and I think that would solve the visibility constraint issue too...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-28 16:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:707 on 2025-01-28 16:47</div>
            <div class="timeline-body"><p>Yes, that all makes sense, thanks for clarifying!</p>
<p>I think we should tackle this separately as a later problem; maybe file an issue for it? I don&#x27;t think it&#x27;s urgent, and I&#x27;m happy with doing the &quot;least work&quot; for now, even if it&#x27;s less consistent (that is, neither eagerly clearing definitions when a branch becomes unreachable, nor merging definitions from two unreachable branches just so we can have fully consistent types in unreachable code).</p>
<p>Whatever we do for unreachable code should look consistent whether the origin of that unreachability is in terminals or in statically-known branches (that is, code under an <code>if False</code> should behave similarly to code after a <code>return</code>), which may place some additional constraints on how we handle it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-28 16:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:216 on 2025-01-28 16:52</div>
            <div class="timeline-body"><p>I think it&#x27;s fine (even good) to take cases that we find from tomllib (or any other testing on real code), distill them down to their simplest form that illustrates a potential regression, and include them as mdtests. So that&#x27;s not an issue. I think my question here really is trying to understand what the regression was (what did we do wrong in this example in some earlier version of this PR?) and clarify what behavior the test is trying to demonstrate (maybe just with some prose, maybe by adding a <code>reveal_type</code>, maybe both).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-28 16:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:707 on 2025-01-28 16:58</div>
            <div class="timeline-body"><p>Top-of-head thoughts on what behaviors we do/don&#x27;t want (not for action now, just for consideration in writing up the issue):</p>
<ul>
<li>I definitely don&#x27;t think it would be useful to issue undefined-reference diagnostics for names used in unreachable code that would have been defined were the branch reachable.</li>
<li>In some sense I think <code>Never</code> is the &quot;right&quot; type for all expressions in unreachable code?</li>
<li>But I suspect that the most useful behavior is to check the unreachable code (and still raise diagnostics in it as normal), as if it were reachable.</li>
<li>We should look into mypy and pyright behavior here.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-28 17:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:216 on 2025-01-28 17:39</div>
            <div class="timeline-body"><p>When I was using visibility constraints, this was a regression because:</p>
<ul>
<li>the <code>return</code> statement would mark the <code>x</code> parameter as non-visible for the remainder of the flow;</li>
<li>list comprehensions would resolve free variables as of the end of the containing scope,</li>
<li>which is technically after the <code>return</code> statement, and so the body of the list comprehension wouldn&#x27;t see the <code>x</code> formal parameter as a visible definition.</li>
</ul>
<p>It&#x27;s the a lack of an <code>unresolved-reference</code> error that shows that the regression isn&#x27;t there anymore.</p>
<p>Talking through it in detail like this, I think this is superfluous with the &quot;Early returns and nested functions&quot; tests, because it was the &quot;closed-over vars in scopes with <code>return</code> statements&quot; part that was relevant, and the &quot;modeling of eagerly-executing nested scopes&quot; was a red herring.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-28 17:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:707 on 2025-01-28 17:44</div>
            <div class="timeline-body"><p>Mypy has terrible UX if it sees a <code>reveal_type</code> in a block of code it considers unreachable: it just doesn&#x27;t emit any diagnostic for the <code>reveal_type</code> call at all. This has been the source of many bug reports at mypy over the years, because the rule that tells you off for having unreachable code in the first place is disabled by default, even if you opt into mypy&#x27;s <code>--strict</code> flag. We shouldn&#x27;t do what mypy does!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:141 on 2025-01-28 18:23</div>
            <div class="timeline-body"><p>Added several <code>try</code>- and <code>raise</code>-related tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:90 on 2025-01-28 18:24</div>
            <div class="timeline-body"><p>Here we&#x27;re considering the <code>&quot;test&quot;</code> assignment visible even though we return immediately after.  Is that because we assume an exception might occur after the assignment but before the <code>return</code>?  (It looks like we take a flow snapshot after every definition in the <code>try</code> body.  Should we instead take snapshots after each statement that could in theory raise an exception?  i.e. actual <code>raise</code>s plus anything that desugars into a call?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-28 18:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:90 on 2025-01-28 18:41</div>
            <div class="timeline-body"><p>In practice almost everything in Python desugars into a call, so currently our over-approximation is to take a snapshot after every definition. But yes, I think in future we should aim to refine that to better handle cases where an exception really isn&#x27;t possible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-28 18:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-28 18:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:90 on 2025-01-28 18:46</div>
            <div class="timeline-body"><p>theoretically even a statement like <code>x = 3</code> <em>could</em> raise an exception, since there&#x27;s always the possibility of a <code>KeyboardInterrupt</code> terminating the current scope. But we probably want to pretend that <code>KeyboardInterrupt</code> doesn&#x27;t exist, since most real-world code pretends that <code>KeyboardInterrupt</code> doesn&#x27;t exist. It will be annoying for users if we explain to them that the reason red-knot is complaining that some variable in their code might be undefined is because they haven&#x27;t accounted for the possibility of a <code>KeyboardInterrupt</code> leading to the <code>try</code> block being terminated before it ran to completion.</p>
<p>TL;DR: I agree with Carl. We should add a more sophisticated analysis of exactly which statements are actually capable of raising exceptions at some point. We just haven&#x27;t gotten to it yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-28 20:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:90 on 2025-01-28 20:39</div>
            <div class="timeline-body"><p>:+1: Thanks for the details!  I was mostly wanting to confirm my understanding of the result and that there wasn&#x27;t a bug I needed to fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:624 on 2025-01-28 21:33</div>
            <div class="timeline-body"><p>I&#x27;ve added @sharkdp&#x27;s example as an mdtest.  I think we can support it by tracking reachability with a visibility constraint, instead of a Rust boolean, but I want to tackle that in a follow-on PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-28 21:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:127 on 2025-01-28 21:38</div>
            <div class="timeline-body"><p>I think one more assignment here would add a useful dimension to this test; it should also not be a possible value for <code>x</code> at the end of the scope:</p>
<pre><code>    else:
        x = &quot;terminal0&quot;
        if cond2:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:142 on 2025-01-28 21:38</div>
            <div class="timeline-body"><pre><code>are likely visible after the loop body, since loops do not introduce new scopes. (Statically
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:263 on 2025-01-28 21:41</div>
            <div class="timeline-body"><pre><code>likely visible after the loop body, since loops do not introduce new scopes. (Statically known
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:379 on 2025-01-28 21:47</div>
            <div class="timeline-body"><p>This is currently describing <code>finally</code> as if it were <code>else</code>. We don&#x27;t really need to discuss <code>finally</code> here, as it&#x27;s not directly connected to <code>raise</code> -- <code>finally</code> occurs after any <code>except</code> or <code>else</code>, regardless of the presence of a <code>raise</code>.</p>
<p>Also, the last phrase about <code>try</code> not introducing a new scope doesn&#x27;t seem to me clearly related to why definitions from before <code>raise</code> are visible after the <code>try</code>; I suggested an adjusted wording.</p>
<pre><code>jump to one of the `except` clauses (if it matches the value being raised), or to the `else`
clause (if none match). Currently, we assume definitions from before the `raise` are visible in all
`except` and `else` clauses. (In the future, we might analyze the `except` clauses to see which
ones match the value being raised, and limit visibility to those clauses.) Definitions from before
the `raise` are not visible in any `else` clause, but are visible in `except` clauses or after the
containing `try` statement (since control flow may have passed through an `except`).
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:397 on 2025-01-28 21:51</div>
            <div class="timeline-body"><p>I don&#x27;t think this TODO is accurate, since <code>reveal_type</code> is a call, and I don&#x27;t think we&#x27;d special-case it to assume it can&#x27;t raise? So at the very least <code>&quot;else&quot;</code> is a possible value here.</p>
<p>I think it&#x27;s accurate to say that <code>&quot;before&quot;</code> is not possible here, but only if we understand that boolean-testing a value of type <code>bool</code> is a special case that doesn&#x27;t execute a <code>__bool__</code> method.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:400 on 2025-01-28 21:52</div>
            <div class="timeline-body"><p><code>&quot;else&quot;</code> is also a possible value here, even after we model possible-exception-raising-locations more accurately, due to the <code>reveal_type</code> call.</p>
<p>And for the same reason, I don&#x27;t think there&#x27;s any scenario where we&#x27;d ever eliminate <code>&quot;raise&quot;</code> as a possibility here, because a non-ValueError could have been raised by the <code>reveal_type</code> call before the <code>raise</code> statement.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:406 on 2025-01-28 21:56</div>
            <div class="timeline-body"><p>It seems a little inconsistent to make TODO comments above but a non-TODO explanatory comment for precisely the same thing here. Let&#x27;s either change this to <code># TODO: Literal[&quot;raise&quot;, &quot;else&quot;]</code>, or else remove all the <code>TODO</code> in this function and replace them with explanatory comments about our over-approximation of possible jumps from within the <code>try</code> block. (I don&#x27;t feel strongly about which way we go; to me our current behavior is not exactly <em>wrong</em>, given that some exceptions can occur pretty much anywhere, but it&#x27;s not ideal and pretty likely we&#x27;ll want to change it, so it&#x27;s reasonable either to mark it as an outright <code>TODO</code>, or just comment on it for the benefit of someone possibly changing it in future.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:410 on 2025-01-28 21:57</div>
            <div class="timeline-body"><p>If in future we decided that no exception can be raised until the <code>raise</code> statement or <code>reveal_type</code> calls above, then <code>&quot;before&quot;</code> would also be absent from this list, right? So this line deserves the same <code>TODO</code> or explanatory comment that we use above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:433 on 2025-01-28 21:58</div>
            <div class="timeline-body"><p>I think all of the comments above apply here as well</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:450 on 2025-01-28 22:00</div>
            <div class="timeline-body"><pre><code>        # TODO: Literal[&quot;raise1&quot;, &quot;raise2&quot;]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:454 on 2025-01-28 22:01</div>
            <div class="timeline-body"><p>I realize we are intentionally not asserting about types <em>within</em> unreachable code, but can we still verify that we consider this code unreachable by adding an assignment to <code>x</code> here and verifying it is not a possible value for <code>x</code> in the end?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:459 on 2025-01-28 22:02</div>
            <div class="timeline-body"><p>Same comments as above about TODO vs explanatory comment, and about <code>&quot;before&quot;</code> as removable from both of these in future</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:489 on 2025-01-28 22:03</div>
            <div class="timeline-body"><p>All the same comments as above (though in this case both <code>&quot;else1&quot;</code> and <code>&quot;else2&quot;</code> should be possible in the <code>except</code> clauses)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:519 on 2025-01-28 22:04</div>
            <div class="timeline-body"><p>Same comments as in previous test</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:549 on 2025-01-28 22:05</div>
            <div class="timeline-body"><p>Same comments as in above cases (in this case <code>&quot;else&quot;</code> should be possible in both <code>except</code> clauses)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:382 on 2025-01-28 22:09</div>
            <div class="timeline-body"><p>AFAICT from the TODOs below, it looks like the only problem you&#x27;re referring to here is our over-approximation of the possible location where an exception could be raised. Let&#x27;s describe this a bit more clearly, to save future us from wondering what we meant here. (Also re-wording to avoid making it specific to <code>raise</code> statements, since it&#x27;s really about too many jumps from places that <em>aren&#x27;t</em> <code>raise</code> statements at all, and to avoid describing it as incorrect, since technically (given <code>KeyboardInterrupt</code>) the current behavior is correct, just likely not preferable.</p>
<pre><code>Currently we assume that an exception could be raised anywhere within a `try` block; the TODOs below reflect
cases where we could implement a more precise understanding of where exceptions (barring `KeyboardInterrupt`
and `MemoryError`) can and cannot actually be raised.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:552 on 2025-01-28 22:10</div>
            <div class="timeline-body"><p>Nit: the test below does not have a terminal statement in a <code>finally</code> block, it has a terminal statement in a <code>try</code> block with an associated <code>finally</code> clause.</p>
<pre><code>## Terminal in `try` with `finally` clause
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:554 on 2025-01-28 22:13</div>
            <div class="timeline-body"><p>This also seems overly broad; we could be more specific to save future-us from possible confusion about what we meant</p>
<pre><code>TODO: we don&#x27;t yet model that a `break` or `continue` in a `try` block will jump to a `finally` clause before it
jumps to end/start of the loop.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-28 22:15</div>
            <div class="timeline-body"><p>Some comments on the new tests, but the behavior looks good for this PR!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-28 22:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:707 on 2025-01-28 22:16</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/issues/15797</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Cryptomonkey1979">@Cryptomonkey1979</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:519 on 2025-01-28 23:45</div>
            <div class="timeline-body"><p>FxHashMap::default</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Cryptomonkey1979">@Cryptomonkey1979</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:482 on 2025-01-29 02:41</div>
            <div class="timeline-body"><p>Debug</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:382 on 2025-01-29 13:30</div>
            <div class="timeline-body"><p>A couple of points, though the tl;dr is that I like your edit:</p>
<ul>
<li><p>The part about the jump behavior was less about &quot;exceptions can come from anywhere&quot; and more about &quot;a <code>raise</code> definitely doesn&#x27;t execute the <code>else</code> clause&quot;.  The latter should be something we can model regardless of how approximate our exception tracking is.  But we&#x27;re actually giving the correct result below in the <code>else</code> <code>reveal_type</code>, so you&#x27;re right that this isn&#x27;t accurately a <code>TODO</code>!  That said, I think it&#x27;s coincidence that we&#x27;re giving the correct result in the <code>else</code> clause ‚Äî <code>&quot;raise&quot;</code> isn&#x27;t included because we&#x27;re treating <code>raise</code> the same as <code>return</code>, not because we know that <code>raise</code> skips the <code>else</code> clause.  (And <code>&quot;raise&quot;</code> <em>is</em> included in the <code>except</code> clauses not because we know the <code>raise</code> statement jumps there ‚Äî with this PR we think the <code>raise</code> skips everything since it&#x27;s terminal! ‚Äî but because our approximation thinks an unrelated exception might occur just after the assignment.)</p>
</li>
<li><p>I had written this (and the TODOs below) describing the goal of a less approximate exception tracking strategy.  But that deserves discussion about what we&#x27;d want that to look like, so I like your suggestion to describe this in terms of what we&#x27;re currently doing instead.</p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:397 on 2025-01-29 14:19</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t think this TODO is accurate, since <code>reveal_type</code> is a call, and I don&#x27;t think we&#x27;d special-case it to assume it can&#x27;t raise? So at the very least <code>&quot;else&quot;</code> is a possible value here.</p>
</blockquote>
<p>Ah, I was actually thinking we <em>would</em> try to do that somehow!  But per above, that deserves discussion, so I&#x27;ll back out the <em>assumption</em> that we&#x27;d try to do that.</p>
<blockquote>
<p>I think it&#x27;s accurate to say that <code>&quot;before&quot;</code> is not possible here, but only if we understand that boolean-testing a value of type <code>bool</code> is a special case that doesn&#x27;t execute a <code>__bool__</code> method.</p>
</blockquote>
<p>I removed the TODO entirely, leaving <code>&quot;before&quot;</code> as a potential possibility here too, so that we&#x27;re not making <em>any</em> assumptions about how we might make exception tracking less approximate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:400 on 2025-01-29 14:23</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:406 on 2025-01-29 14:25</div>
            <div class="timeline-body"><p>Done.  See above, wrote the commentary based on what exception tracking currently does, not what we might change it to do in the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:410 on 2025-01-29 14:29</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:433 on 2025-01-29 14:29</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:454 on 2025-01-29 14:30</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:459 on 2025-01-29 14:30</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:489 on 2025-01-29 14:31</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:519 on 2025-01-29 14:31</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:549 on 2025-01-29 14:31</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-29 14:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-29 17:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:382 on 2025-01-29 17:47</div>
            <div class="timeline-body"><p>Ah, the first bullet point here is something I hadn&#x27;t fully understood! It sort of seems like the current &quot;right behavior by accident&quot; might suffice until/unless we implement tighter understandings of where exceptions can be raised, at which point we might also need better understanding of what <code>raise</code> actually does. Certainly wouldn&#x27;t object to adding some text to record this context for future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:384 on 2025-01-29 17:52</div>
            <div class="timeline-body"><p>Rewording this slightly since there are no longer TODOs below about this!</p>
<pre><code>Currently we assume that an exception could be raised anywhere within a `try` block. We may want to
implement a more precise understanding of where exceptions (barring `KeyboardInterrupt` and
`MemoryError`) can and cannot actually be raised.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:382 on 2025-01-29 17:58</div>
            <div class="timeline-body"><p>So I tried to write up an edit describing this, and I kind of ended up concluding that we may never need to implement any special understanding of where <code>raise</code> can jump to? Even if we tighten up our understanding of where exceptions can be raised, it seems like the only thing we&#x27;ll need to do is maintain two things: 1) understanding <code>raise</code> as terminal, as we do already in this PR, and 2) still understanding <code>raise</code> as &quot;a point where an exception can be raised&quot;, as we do in this PR.</p>
<p>(2) seems unlikely to be something we&#x27;d miss in that future where we&#x27;re adding more understanding of exception points, so I&#x27;m thinking maybe we don&#x27;t need to document this any more than it is already.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-29 17:59</div>
            <div class="timeline-body"><p>One minor edit, but looks land-ready to me!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-29 18:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:382 on 2025-01-29 18:31</div>
            <div class="timeline-body"><blockquote>
<p>Even if we tighten up our understanding of where exceptions can be raised, it seems like the only thing we&#x27;ll need to do is maintain two things: 1) understanding <code>raise</code> as terminal, as we do already in this PR, and 2) still understanding <code>raise</code> as &quot;a point where an exception can be raised&quot;, as we do in this PR.</p>
</blockquote>
<p>Ah yes, that sounds right!</p>
<blockquote>
<p>so I&#x27;m thinking maybe we don&#x27;t need to document this any more than it is already.</p>
</blockquote>
<p>:+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-29 18:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/terminal_statements.md</code>:382 on 2025-01-29 18:35</div>
            <div class="timeline-body"><blockquote>
<p>still understanding <code>raise</code> as &quot;a point where an exception can be raised&quot;, as we do in this PR.</p>
</blockquote>
<p>The only place where this might fall over is that a <code>raise</code> can <em>only</em> raise an exception, whereas a call <em>can</em> but <em>doesn&#x27;t have to</em> raise one.  So calls could jump to <code>except</code> or <code>else</code>, while <code>raise</code> could only jump to <code>except</code>.</p>
<p>No, wait!  Calls can jump to <code>except</code> or flow through to the next statement, and <em>the end of the <code>try</code> block</em> flows to <code>else</code>.  So yes, you&#x27;re right, <code>raise</code> being terminal within the <code>try</code> block would correctly encode that it can&#x27;t &quot;jump&quot; to <code>else</code>.  (Nothing actually &quot;jumps&quot; there, in fact.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-29 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-29 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-29 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Cryptomonkey1979">@Cryptomonkey1979</a> reviewed on 2025-02-26 07:26</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:10:44 UTC
    </footer>
</body>
</html>
