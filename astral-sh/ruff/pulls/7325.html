<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Update `Indexer` to use new f-string tokens - astral-sh/ruff #7325</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Update <code>Indexer</code> to use new f-string tokens</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/7325">#7325</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2023-09-13 04:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>This PR updates the <code>Indexer</code> to use the new f-string tokens to compute the <code>f_string_ranges</code> for f-strings. It adds a new abstraction which exposes two methods to support extracting the range for the surrounding innermost and outermost f-string. It uses the builder pattern to build the f-string ranges which is similar to how the comment ranges are built.</p>
Test Plan
<p>Add new test cases for f-strings for:</p>
<ul>
<li>Tab indentation rule</li>
<li>Line continuation detection in the indexer</li>
<li>To get the innermost / outermost f-string range</li>
<li>All detected f-string ranges</li>
</ul>
<p>fixes: #7290</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-13 04:41</div>
            <div class="timeline-body"><p>Current dependencies on/for this PR:</p>
<ul>
<li>main<ul>
<li><strong>PR #7376</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7376"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a><ul>
<li><strong>PR #7690</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7690"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7667</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7667"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7597</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7597"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7588</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7588"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a><ul>
<li><strong>PR #7589</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7589"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
</ul>
</li>
<li><strong>PR #7586</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7586"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7515</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7515"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7477</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7477"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7387</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7387"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7378</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7378"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7329</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7329"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7328</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7328"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7327</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7327"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7326</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7326"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a></li>
<li><strong>PR #7325</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7325"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a>  ðŸ‘ˆ</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This comment was auto-generated by <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7325?utm_source=stack-comment">Graphite</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">python312</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-13 05:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-13 05:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-14 02:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:92 on 2023-09-14 02:54</div>
            <div class="timeline-body"><p>In previous implementation, triple-quoted f-strings were only stored in <code>triple_quoted_string_ranges</code> and not in <code>f_string_ranges</code>. Was that an expected behavior?</p>
<p>Currently, I&#x27;m storing in both ranges but I can revert back to the original bahavior.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-14 02:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/charliermarsh">@charliermarsh</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-14 02:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-14 02:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:84 on 2023-09-14 06:43</div>
            <div class="timeline-body"><p>We need to use <code>saturating_sub</code> because we use <code>.flatten</code> which filters out <code>Err</code> token. Meaning, it could happen that we skip an arbitrary number of valid tokens.</p>
<p>Or you rewrite it to guarantee that <code>if f_string_start_count == 0</code> can only be true exactly once.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:75 on 2023-09-14 06:48</div>
            <div class="timeline-body"><p>I don&#x27;t think that only storing the full f-string ranges is sufficient anymore. E.g. the <code>tab_indentation</code> needs to know whether it is inside of a multiline string. But that should only return true if it is inside a FString-Middle part of a multiline string, e.g. the following should trigger but would not</p>
<pre><code>f&quot;&quot;&quot;test{
    tab_indented_should_be_flagged
}   &lt;- this tab is fine&quot;&quot;&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:73 on 2023-09-14 06:49</div>
            <div class="timeline-body"><p>Can we add a test for line continuations inside of strings and that is properly handled by the indexer?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:94 on 2023-09-14 06:53</div>
            <div class="timeline-body"><p><code>f_string_quote_style</code> is the only usage of <code>f_string_ranges</code>. It tries to find the f string quote style of the enclosing f-string. Does the current implementation support nested fstrings? Does the binary search still work with nested fstrings or how do we ensure we find the &quot;smallest&quot; range that fully encloses the expression.</p>
<p>https://github.com/astral-sh/ruff/blob/04f2842e4f187a26ff74d7b845f3cdc6abacf765/crates/ruff/src/checkers/ast/mod.rs#L179-L195</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2023-09-14 06:53</div>
            <div class="timeline-body"><p>Can you add tests for the upstream functions that use the metadata extracted by the <code>Indexer</code> to ensure they are working as intended.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-14 07:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:75 on 2023-09-14 07:47</div>
            <div class="timeline-body"><p>I agree with this but this isn&#x27;t triggered on the stable version as well. I think I would prefer to have a 1-1 change between the stable version and with the new f-string tokens version. We can fix this bug later on (#7379).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-14 10:45</div>
            <div class="timeline-body">Nested f-strings:
<p>Pre 3.12, nested f-strings were possible but up to an extent. For example,</p>
<pre><code>f&quot;outside {f&#x27;inside&#x27;} outside&quot;
# or
f&#x27;outside {f&quot;inside&quot;} outside&#x27;
</code></pre>
<p>The rules which performs checks on strings donâ€™t support nested f-strings. For example,</p>
<pre><code>f&quot;{f&quot;\y&quot;}&quot;
</code></pre>
<p>For the above code snippet, the <code>W605</code> (<code>invalid-escape-sequence</code>) incorrectly auto-fixes by adding the <code>r</code> prefix to the outermost f-string while it should be added to the f-string which contains the escape character.</p>
F-string ranges:
<p>The <code>Indexer</code> includes the range of the outermost f-string while it should probably include the actual range of all the f-strings. This creates a challenge in the way f-string ranges are inserted as the vector needs to be sorted for the binary search to work but thatâ€™s an implementation detail.</p>
<p>Currently, the f-string range is only being utilized to get the f-string quote style but this would be incorrect in the case of nested f-strings. For example, in <code>f&quot;foo {f&#x27;{bar}&#x27;}&quot;</code>, for the variable <code>bar</code>, the quote style would give <code>Quote::Double</code>.</p>
<p>The question is: do we want to proceed with how the current implementation is (use the outermost f-string range) or have separate ranges for each f-strings even if itâ€™s nested?</p>
Triple-quoted string ranges:
<p>Currently, if a triple-quoted f-string is encountered, then the range is only recorded as a triple-quoted string but not as a f-string i.e., itâ€™s only being inserted to <code>indexer.triple_quoted_string_ranges</code> and not <code>indexer.f_string_ranges</code>. Iâ€™m not sure if thatâ€™s intentional or not but with the current changes, Iâ€™m inserting it into both.</p>
<p>This is only being utilized in <code>W191</code> (<code>tab-indentation</code>) which works on physical lines. This creates a problem as we canâ€™t really know if this line is part of a f-string expression or non-expression part (thus, <a href="https://github.com/astral-sh/ruff/issues/7379">astral-sh/ruff#7379</a>).</p>
<p>Another challenge here is that with f-strings even the triple-quoted strings can be nested:</p>
<pre><code>f&quot;&quot;&quot;first level
of triple-quoted {f&quot;&quot;&quot;second level
of triple-quoted&quot;&quot;&quot;}
f-strings&quot;&quot;&quot;
</code></pre>
<p>This again brings up the question of how granular we want the triple-quoted string ranges to be?</p>
<hr>
<p>I&#x27;m leaning towards keeping the behavior same and we can iterate to fix the issues around nested f-strings. But, if we&#x27;re sure on how to handle nested f-strings I can make the changes here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-09-15 06:08</div>
            <div class="timeline-body"><blockquote>
<p>F-string ranges:</p>
</blockquote>
<p>Technically, I think we can solve this by using a <code>BTreeMap&lt;TextSize, TextRange&gt;</code> where the key is the start position of the f-string and the value is the string range. Finding the enclosing f-strings for an offset is then <code>map.range(...Include(offset)).rev().filter(|range| range.contains(offset))</code>. This doesn&#x27;t just give you the enclosing f-string but an iterator over all enclosing fstrings.</p>
<blockquote>
<p>Currently, the f-string range is only being utilized to get the f-string quote style but this would be incorrect in the case of nested f-strings.</p>
</blockquote>
<p>More specifically, it seems this is only used to guess the appropriate quote style for an fstring. This logic won&#x27;t be needed for Python 3.12+ because we can pick any quote style (ideally, the default quote style).</p>
<p>It might be okay to leave the implementation as is but we should document the limitation and its intended use case. Not that more call sites are introduced that incorrectly assume it supports nested FStrings correctly.</p>
<blockquote>
<p>Currently, if a triple-quoted f-string is encountered, then the range is only recorded as a triple-quoted string but not as a f-string i.e., itâ€™s only being inserted to indexer.triple_quoted_string_ranges and not indexer.f_string_ranges. Iâ€™m not sure if thatâ€™s intentional or not but with the current changes, Iâ€™m inserting it into both.</p>
</blockquote>
<p>I don&#x27;t think this was intentional.</p>
<blockquote>
<p>This is only being utilized in W191 (tab-indentation) which works on physical lines. This creates a problem as we canâ€™t really know if this line is part of a f-string expression or non-expression part (thus, <a href="https://github.com/astral-sh/ruff/issues/7379">astral-sh/ruff#7379</a>).</p>
</blockquote>
<p>I wonder if it would be easier to rewrite that rule to a token-based rule rather than trying to extract all the data at a granularity level close to the individual tokens.</p>
<p>Except if we plan to to re-use the multiline-string ranges for <code>add-noqa</code> as well:</p>
<p>https://github.com/astral-sh/ruff/blob/fc89976c24d1c8b9d13d88ef70b619e8a2ac393a/crates/ruff/src/directives.rs#L90-L114</p>
<p>I would be interested to get @charliermarsh&#x27;s opinion on this, who is more familiar with the use cases (I only know the <code>Indexer</code> from when I refactored from column to byte offsets).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2023-09-18 16:56</div>
            <div class="timeline-body"><a href="https://codspeed.io/astral-sh/ruff/branches/dhruv/issue-7290">CodSpeed Performance Report</a>
Merging #7325 will <strong>not alter performance</strong>
<p>Comparing <code>dhruv/issue-7290</code> (0b2e6bb) with <code>dhruv/pep-701</code> (c496d9c)</p>
Summary
<p><code>âœ… 25</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-09-18 19:15</div>
            <div class="timeline-body"><p>Could you rebase your PRs so that we get clear benchmark numbers? This all looks worrying but they&#x27;re probably false positives</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/fstring_ranges.rs</code>:20 on 2023-09-18 19:19</div>
            <div class="timeline-body"><p>The worst-case complexity of this is that this function traverses all values in the map. Would it be sufficient to only look at the last element in the range?</p>
<pre><code>				self.raw.range(..=offset).last().filter(|range| range.contains(offset)).copied()
</code></pre>
<p>It may be worth a comment why the filter is necessary</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/fstring_ranges.rs</code>:50 on 2023-09-18 19:21</div>
            <div class="timeline-body"><p>This has a worst time complexity of <code>O(n)</code> if the searched offset is the last in the map.</p>
<p>I think it would be better to iterate from the back and take the last entry where <code>range.contains</code> is still true. This should be <code>O(log(n))</code> for almost all entries</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_index/src/fstring_ranges.rs</code>:82 on 2023-09-18 19:22</div>
            <div class="timeline-body"><p>Nit; Maybe add a debug assertion that <code>start_locations</code> is empty</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-09-18 19:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-19 03:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/fstring_ranges.rs</code>:20 on 2023-09-19 03:33</div>
            <div class="timeline-body"><blockquote>
<p>Would it be sufficient to only look at the last element in the range?</p>
</blockquote>
<p>Unfortunately no. Let me explain using an example:</p>
<pre><code>f&quot;first {f&quot;second&quot;} first&quot;
</code></pre>
<p>Here, there are 2 f-strings with the following range:</p>
<ol>
<li><code>0..26</code> (outer)</li>
<li><code>9..17</code> (inner)</li>
</ol>
<p>Now, when we want to find the f-string for the offset 20 which is <em>after</em> the inner f-string that&#x27;s where the <code>find</code> comes in handy.</p>
<p>The <code>range</code> method will give both ranges because <code>range(..=20)</code> satisfies both. But, when iterating backwards, it isn&#x27;t in (2) but in (1).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-19 04:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/fstring_ranges.rs</code>:20 on 2023-09-19 04:27</div>
            <div class="timeline-body"><p>Per your suggestion, we need to filter first and then get the last element:</p>
<pre><code>        self.raw
            .range(..=offset)
            .filter(|(_, range)| range.contains(offset))
            .last()
            .map(|(_, range)| *range)
</code></pre>
<p>But, I think the original version is optimal as it&#x27;ll short circuit on the first find while the filter would go through all the ranges and then get the last <code>Some</code> element.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-19 04:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/fstring_ranges.rs</code>:50 on 2023-09-19 04:50</div>
            <div class="timeline-body"><p>Yes, this is correct. Thanks for the suggestion. One thing to note is that we&#x27;ll have to skip the initial ranges where the offset doesn&#x27;t belong because those will be part of the inner ranges while the offset might be part of an outer range. The iterator of nested ranges goes from the innermost to the outermost.</p>
<p>For example:</p>
<pre><code>#                                                     v
  f&quot;normal&quot; f&quot;another&quot; f&quot;first {f&quot;second {f&quot;third&quot;} second&quot;} first&quot;
#                                         ^^^1^^^^
#                               ^^^^^^^^^^^^^2^^^^^^^^^^^^^
#                      ^^^^^^^^^^^^^^^^^^^^^^3^^^^^^^^^^^^^^^^^^^^^
#           ^^^^4^^^^^
# ^^^^5^^^^
</code></pre>
<p>If the offset is where <code>v</code> is at, then the iterator would yield the range in the order mentioned above. Now, the offset doesn&#x27;t belong in (1) so we will skip until we get a range where the offset belongs to. Then, we&#x27;ll continue until we get a range which <em>doesn&#x27;t</em> contain the offset and the last range will be the outermost range.</p>
<p>So, skip (1), next (2), next (3), stop. Outermost range is (3).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-19 06:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:75 on 2023-09-19 06:06</div>
            <div class="timeline-body"><p>Added a test case for single and triple-quoted f-strings</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-09-19 06:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_index/src/indexer.rs</code>:73 on 2023-09-19 06:16</div>
            <div class="timeline-body"><p>Added test cases for line continuation within f-strings (and nested).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-19 06:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-09-19 06:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-09-19 06:25</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:57:08 UTC
    </footer>
</body>
</html>
