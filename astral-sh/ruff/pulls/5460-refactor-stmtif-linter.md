```yaml
number: 5460
title: "Refactor `StmtIf`: Linter"
type: pull_request
state: merged
author: konstin
labels: []
assignees: []
merged: true
base: refator-if-statement-formatter
head: refactor-if-statement-linter
created_at: 2023-07-01T20:23:50Z
updated_at: 2023-07-11T15:32:17Z
url: https://github.com/astral-sh/ruff/pull/5460
synced_at: 2026-01-12T03:36:55Z
```

# Refactor `StmtIf`: Linter

---

_Pull request opened by @konstin on 2023-07-01 20:23_

See https://github.com/astral-sh/ruff/pull/5458 for detailed information

I've tried to split this into commits for individual rules as much as feasible and left a bunch of TODO where i'm not sure about the rules
 

---

_Comment by @konstin on 2023-07-01 20:24_

Current dependencies on/for this PR:
* main
  * **PR #5459** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/5459" target="_blank"><img src="https://static.graphite.dev/graphite-32x32.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #5460** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/5460" target="_blank"><img src="https://static.graphite.dev/graphite-32x32.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ

This comment was auto-generated by [Graphite](https://app.graphite.dev/github/pr/astral-sh/ruff/5460?utm_source=stack-comment).

---

_Review requested from @charliermarsh by @konstin on 2023-07-01 20:24_

---

_Comment by @github-actions[bot] on 2023-07-01 20:53_

## PR Check Results
### Benchmark
#### Linux
```
group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.01     10.5Â±0.24ms     3.9 MB/sec    1.00     10.4Â±0.25ms     3.9 MB/sec
formatter/numpy/ctypeslib.py               1.06      2.4Â±0.09ms     7.0 MB/sec    1.00      2.3Â±0.06ms     7.4 MB/sec
formatter/numpy/globals.py                 1.06   272.8Â±12.71Âµs    10.8 MB/sec    1.00   258.5Â±10.26Âµs    11.4 MB/sec
formatter/pydantic/types.py                1.02      5.2Â±0.19ms     4.9 MB/sec    1.00      5.1Â±0.17ms     5.0 MB/sec
linter/all-rules/large/dataset.py          1.02     18.8Â±0.46ms     2.2 MB/sec    1.00     18.5Â±0.62ms     2.2 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.4Â±0.22ms     3.8 MB/sec    1.02      4.5Â±0.12ms     3.7 MB/sec
linter/all-rules/numpy/globals.py          1.00   559.3Â±20.78Âµs     5.3 MB/sec    1.04   579.0Â±28.10Âµs     5.1 MB/sec
linter/all-rules/pydantic/types.py         1.01      8.2Â±0.24ms     3.1 MB/sec    1.00      8.1Â±0.22ms     3.1 MB/sec
linter/default-rules/large/dataset.py      1.00      8.8Â±0.26ms     4.6 MB/sec    1.01      8.9Â±0.18ms     4.6 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1905.6Â±43.60Âµs     8.7 MB/sec    1.01  1916.1Â±61.57Âµs     8.7 MB/sec
linter/default-rules/numpy/globals.py      1.03   230.5Â±20.45Âµs    12.8 MB/sec    1.00   224.8Â±10.64Âµs    13.1 MB/sec
linter/default-rules/pydantic/types.py     1.02      4.1Â±0.23ms     6.2 MB/sec    1.00      4.0Â±0.12ms     6.3 MB/sec
```

#### Windows
```
group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.02      9.5Â±0.10ms     4.3 MB/sec    1.00      9.3Â±0.08ms     4.4 MB/sec
formatter/numpy/ctypeslib.py               1.06      2.1Â±0.04ms     7.9 MB/sec    1.00  1995.6Â±37.84Âµs     8.3 MB/sec
formatter/numpy/globals.py                 1.04    229.7Â±4.11Âµs    12.8 MB/sec    1.00   221.4Â±14.35Âµs    13.3 MB/sec
formatter/pydantic/types.py                1.05      4.7Â±0.08ms     5.4 MB/sec    1.00      4.5Â±0.14ms     5.6 MB/sec
linter/all-rules/large/dataset.py          1.00     15.7Â±0.12ms     2.6 MB/sec    1.01     15.9Â±0.17ms     2.6 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.01      4.2Â±0.03ms     4.0 MB/sec    1.00      4.1Â±0.05ms     4.0 MB/sec
linter/all-rules/numpy/globals.py          1.00    434.3Â±9.61Âµs     6.8 MB/sec    1.00    433.7Â±9.81Âµs     6.8 MB/sec
linter/all-rules/pydantic/types.py         1.03      7.2Â±0.07ms     3.6 MB/sec    1.00      7.0Â±0.06ms     3.7 MB/sec
linter/default-rules/large/dataset.py      1.00      8.1Â±0.04ms     5.0 MB/sec    1.01      8.2Â±0.09ms     4.9 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1673.6Â±18.27Âµs     9.9 MB/sec    1.00  1672.1Â±21.69Âµs    10.0 MB/sec
linter/default-rules/numpy/globals.py      1.00    181.9Â±3.30Âµs    16.2 MB/sec    1.00    181.5Â±2.85Âµs    16.3 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.6Â±0.04ms     7.0 MB/sec    1.01      3.7Â±0.03ms     6.9 MB/sec
```
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

---

_Review comment by @MichaReiser on `crates/ruff/src/checkers/ast/mod.rs`:1313 on 2023-07-03 06:41_

Nit: We now also have the option to pass the whole if statement by binding it on line 1298 (`if_stmt @ ast::StmtIf {...}`). But I can see how this was the more lightweight refactor.

---

_Review comment by @MichaReiser on `crates/ruff/src/checkers/ast/mod.rs`:2032 on 2023-07-03 06:46_

Our current visitor has a `visit_*` method for every node type (or the union the node type belongs). That's why I think we should instead, for consistency, add a `visit_elif_else_clause` to visitor and (pre-order visitor) and call that function here.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_bugbear/rules/reuse_of_groupby_generator.rs`:153 on 2023-07-03 06:50_

Nit: We can avoid the `unwrap` call here. I find this easier to read because I don't have to reason about why `unwrap` is safe
```suggestion
				let mut if_stack = Vec::with_capacity(1 + elif_else_clauses.len());
                // Initialize the vector with the count for the if branch.
				if_stack.push(0);
                self.counter_stack.push(if_stack);
```

Would it even be safe to use the `if_stack` on lines 157..171 instead of calling `self.counter_stack.last_mut`?

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_bugbear/rules/reuse_of_groupby_generator.rs`:162 on 2023-07-03 06:51_

```suggestion
					self.visit_elif_else_clause(&clause)
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_return/visitor.rs`:135 on 2023-07-03 06:58_

Isn't this always `false` for `if` statements since we no longer represent `elif`s as `body: [if_stmt]` but instead as an `ElifElseClause` (meaning, an `IfStmt` can never be an elif`)?

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:309 on 2023-07-03 06:59_

Nit: I prefer `nested_if_statements` over `is_*` because the function returns the nested if statement and not a boolean.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:312 on 2023-07-03 07:00_

Nit: Pass the whole `if_stmt`

```suggestion
    if_stmt: &StmtIf,
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/fix_if.rs`:36 on 2023-07-03 07:04_

Nit: Can we use a more specific name than `range`. What range do I need to pass here? Is any range fine or does it have to be a statement range? I personally prefer passing a `Stmt` if we have it at hand because it is more explicit about what we're expecting here, even if we don't use all its fields.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/fix_if.rs`:48 on 2023-07-03 07:05_

Why is it no longer necessary to remove the `whitespace`? `lines` returns the text from the beginning to the end of the line(s), including indentation.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/isort/block.rs`:241 on 2023-07-03 07:10_

Nit: `walk_elif_else_clause(self, clause)` and override `visit_elif_else_clause`

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pylint/rules/collapsible_else_if.rs`:56 on 2023-07-03 07:15_

```suggestion
    let [ElifElseClause { body, test: None, ..}] = elif_else_clauses else {
        return None;
    };
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pylint/rules/collapsible_else_if.rs`:57 on 2023-07-03 07:16_

Unrelated to this PR: It would probably be good to highlight the test-condition range instead of the whole if statement

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pylint/rules/too_many_branches.rs`:208 on 2023-07-03 07:19_

4 seems to be correct at first look but I think the reasoning is:

* `if` 
* `if -> else -> if`
* `if -> else -> else`

Which is also the reason why you can collapse this into an `if .. elif... else`

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pylint/rules/too_many_statements.rs`:210 on 2023-07-03 07:23_

CC: @charliermarsh 

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:133 on 2023-07-03 07:24_

Is the `BranchKind` necessary here, considering that only an `if` statement can have `elif_else_clauses`?

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:146 on 2023-07-03 07:27_

```suggestion
            Some(ElifElseClause { test: Some(_), range, .. }) => {
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:146 on 2023-07-03 07:28_

Nit: It could make sense to add `is_elif` and `is_else` on `ElifElseClause` 

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:155 on 2023-07-03 07:29_

Nit: If you want to be explicit about it and not rely the preceding match patterns

```suggestion
            Some(ElifElseClause { body, test: None.. }) => {
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:134 on 2023-07-03 07:30_

Nit: Can we use a more explicit name than `range`. What kind of range is it. Is it the range of the `stmt` (if so, use stmt.range). If it is either the `If` or `ElifElseClause` range, maybe add it to `BranchKind` or change `BranchKind` to `Branch` which stores a reference to either the `IfStmt` or `ElifElseClause`. This would also remove the need for the 4 value tuple in `outdated_version_block`

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:132 on 2023-07-03 07:35_

Nit: Pass the whole `if_stmt` instead of the individual fields. I think it would have helped me understand the logic easier because I assumed that there's a relation between the `elif_else_clause` and the `branch_kind` which isn't the case. It may even make sense to change the ordering of the arguments: The most important argument is the `BranchKind` with the `range`, because that's what the method operates on. All other arguments are only necessary to get the job done.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:285 on 2023-07-03 07:35_

Nit: Pass the whole if statement instead?

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:304 on 2023-07-03 07:37_

```suggestion
            continue;
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/tryceratops/rules/type_check_without_type_error.rs`:172 on 2023-07-03 07:38_

Nit: Pass the whole if_statement instead of the individual fields (fewer arguments, less data to be copied)

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:297 on 2023-07-03 07:49_

GitHub doesn't allow me to comment on the correct line. The documentation confuses me. It mention that it returns the **first** statement but it returns `inner_body.last()`.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:360 on 2023-07-03 07:53_

Nit: Pass the whole `if_stmt` instead of the individual fields (results in passing a single 8 byte reference instead of four 8 byte references)

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:310 on 2023-07-03 07:57_

Nit: Make the function private

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:319 on 2023-07-03 07:59_

It seems that being able to either refer to th `If` statement or the `Elif` clause is a recurring pattern. Consider introducing a union in `ruff_python_ast` that represents either (implements `Ranged`, `From<&StmtIf>`, `From<&ElifElseClause>`, provides methods to get the `condition` and the `body`, etc.)

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:391 on 2023-07-03 08:01_


```suggestion
        colon.map_or(
            || range,
            |colon| TextRange::new(range.start(), colon.end()),
        ),
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:567 on 2023-07-03 08:05_

Nit: I think @charliermarsh started to move `semantic` to the back because it is only an *auxilary* argument, necessary to perform the job. The important arguments that this function is operating on are the `expr` and the `targets`.

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:691 on 2023-07-03 08:07_

Nit
```suggestion
                .filter_map(|clause| clause.test.is_some().then_some(clause.start(), clause.body.as_slice()))
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:693 on 2023-07-03 08:10_

Using `peekable` here is probably more expensive (next takes the value from peek in every iteration, just so that we can write it in the immediately followed peek) than keeping track of the last branch in a stack variable

```
let mut Some(last) = branches_iter.next() else {
    return;
}

for (current_start, current_body) in branches_iter {
    ...
    
    last = (current_start, current_body);
}
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:721 on 2023-07-03 08:12_

You can add a helper method to `CommentRanges` that performs a binary search using the start position, then checks if the range is included)

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:732 on 2023-07-03 08:13_


```suggestion
    if_stmt: &StmtIf,
```

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:778 on 2023-07-03 08:15_

Nit: I don't know how expensive the `contains_effect` and `is_builtin` calls are but it could make sense to make this the very last check (testing if it is an elif or comparing the `id` and ops are relatively cheap)

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:819 on 2023-07-03 08:15_


```suggestion
    if_stmt: &StmtIf,
```

---

_@MichaReiser approved on 2023-07-03 08:16_

This is awesome. So many TODOs and manual string inspections that are just gone :)

---

_@konstin reviewed on 2023-07-03 10:47_

---

_Review comment by @konstin on `crates/ruff/src/checkers/ast/mod.rs`:1313 on 2023-07-03 10:47_

much cleaner, thanks

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_bugbear/rules/reuse_of_groupby_generator.rs`:153 on 2023-07-03 11:03_

i don't think so, but i wouldn't want to refactor that in this Pr anyway

---

_@konstin reviewed on 2023-07-03 11:03_

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_return/visitor.rs`:135 on 2023-07-03 11:58_

it's not the same but it removes a false negative, so i take it

---

_@konstin reviewed on 2023-07-03 11:58_

---

_@konstin reviewed on 2023-07-03 11:59_

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:309 on 2023-07-03 11:59_

`nested_if_body`, since `nested_if_statements` is the name of rule already

---

_@konstin reviewed on 2023-07-03 12:02_

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/fix_if.rs`:48 on 2023-07-03 12:02_

we have the correct range starting with the `elif` token now


---

_Review comment by @konstin on `crates/ruff/src/rules/pylint/rules/collapsible_else_if.rs`:57 on 2023-07-03 12:05_

i forward this question to charlie ;)

---

_@konstin reviewed on 2023-07-03 12:05_

---

_@konstin reviewed on 2023-07-03 12:07_

---

_Review comment by @konstin on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:133 on 2023-07-03 12:07_

the `elif_else_clauses` clauses are those of the entire `if` statement, we use them to find the start of the following branch in `BranchKind::Elif`

---

_Review comment by @konstin on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:133 on 2023-07-03 12:08_

i thought about making this a bool but kept it like the original implementation

---

_@konstin reviewed on 2023-07-03 12:08_

---

_@konstin reviewed on 2023-07-03 12:09_

---

_Review comment by @konstin on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:146 on 2023-07-03 12:09_

i though about adding more abstractions but the cases are to different and we're normally matching anyway to extract the fields

---

_@konstin reviewed on 2023-07-03 12:12_

---

_Review comment by @konstin on `crates/ruff/src/rules/pyupgrade/rules/outdated_version_block.rs`:304 on 2023-07-03 12:12_

i've applied nightly rustfmt

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:297 on 2023-07-03 12:15_

good point, seems to have been wrong since the original PR

---

_@konstin reviewed on 2023-07-03 12:15_

---

_@konstin reviewed on 2023-07-03 12:21_

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:319 on 2023-07-03 12:21_

i though about it but the actual cases we have (yet) are too different to effectively unify them.

---

_@konstin reviewed on 2023-07-03 12:26_

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:691 on 2023-07-03 12:26_

i find it easier to read the current way

---

_@konstin reviewed on 2023-07-03 12:27_

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:693 on 2023-07-03 12:27_

don't we lose the first value in this model?

---

_@MichaReiser reviewed on 2023-07-03 14:11_

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:693 on 2023-07-03 14:11_

We can track the next one too ;)

```rust
let mut Some((first_start, first_body)) = branches_iter.next() else {
	return;
}

let mut next = branches_iter.next();

while let Some((second_start, second_body)) = next.take() {
	...
	
	(first_start, first_body) = (second_start, second_body);
	next = branches_iter.next()
}
```

---

_Review comment by @konstin on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:693 on 2023-07-03 14:32_

but that would compile down to the same thing as the peekable, wouldn't it?

---

_@konstin reviewed on 2023-07-03 14:32_

---

_@MichaReiser reviewed on 2023-07-03 14:38_

---

_Review comment by @MichaReiser on `crates/ruff/src/rules/flake8_simplify/rules/ast_if.rs`:693 on 2023-07-03 14:38_

That depends on whether the compiler can infer that the `peeked` field on the peekable iterator is always initialized when calling `Iterator` and, thus, can simplify 

```
   #[inline]
    fn next(&mut self) -> Option<I::Item> {
        match self.peeked.take() {
            Some(v) => v,
            None => self.iter.next(),
        }
    }
    ```

to a simple `self.peeked.take()`. It might, it might not. Anwyay, I should have marked this as a Nit. Keep it as you prefer, I don't expect it to change performance significantly (it's not a hot loop, the eliminated code is minimal)  

---

_Comment by @konstin on 2023-07-05 08:57_

I think i've handled all review comments now

---

_Comment by @konstin on 2023-07-05 11:40_

@MichaReiser could you have a look at the unreachable code analysis? I failed to port the StmtIf logic and i think you're quicker than me with the block logic

---

_Comment by @MichaReiser on 2023-07-05 13:34_

> @MichaReiser could you have a look at the unreachable code analysis? I failed to port the StmtIf logic and i think you're quicker than me with the block logic

Done. The ordering of some blocks changed and the source span for `elif` branches now use the span of the enclosing `if`. I didn't spend much time trying to create the blocks in the exact same order as before. 

---

_Review comment by @charliermarsh on `crates/ruff/resources/test/fixtures/pyupgrade/UP036_4.py`:10 on 2023-07-11 14:47_

Why this?

---

_Review comment by @charliermarsh on `crates/ruff/src/autofix/edits.rs`:198 on 2023-07-11 14:47_

Nit: extra newline here

---

_Review comment by @charliermarsh on `crates/ruff/src/rules/pylint/rules/collapsible_else_if.rs`:57 on 2023-07-11 14:49_

I'm cool w/ that change.

---

_Review comment by @charliermarsh on `crates/ruff/src/rules/pylint/rules/too_many_statements.rs`:210 on 2023-07-11 14:52_

I'm guessing it thought this was equivalent to:

```python
def f():
    if a:
        print()
    elif a:
        print()
```

Which it wanted to treat as equivalent to:

```python
def f():
    if a:
        print()
    else:
        print()
```

I think 6 is better, feel free to remove this TODO.

---

_@charliermarsh approved on 2023-07-11 14:54_

---

_Review comment by @konstin on `crates/ruff/resources/test/fixtures/pyupgrade/UP036_4.py`:10 on 2023-07-11 14:56_

i had trouble telling apart the `pass` that were in the input and the `pass` that we insert for removing the last statement in body

---

_@konstin reviewed on 2023-07-11 14:56_

---

_Merged by @konstin on 2023-07-11 14:59_

---

_Closed by @konstin on 2023-07-11 14:59_

---

_Branch deleted on 2023-07-11 14:59_

---
