<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] support walrus expressions in type inference - astral-sh/ruff #11762</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] support walrus expressions in type inference</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/11762">#11762</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-06-05 20:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Add support for walrus expressions, both in expression type inference and in symbol definition type inference.</p>
<h2>Test Plan</h2>
<p>Added test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-06-05 20:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-06-05 20:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-06-05 20:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] suppport walrus expressions in type inference" to "[red-knot] support walrus expressions in type inference" by @carljm on 2024-06-05 20:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot/src/semantic.rs</code>:260 on 2024-06-05 20:48</div>
            <div class="timeline-body"><p>Should we also immediately mark any symbol defined using a walrus as both defined and used?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-06-05 20:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-06-05 20:52</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-05 20:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot/src/semantic.rs</code>:260 on 2024-06-05 20:55</div>
            <div class="timeline-body"><p>The walrus expression should record the symbol as defined, not as used; a use is a load of a name, not a store to it.</p>
<p>But we already do record it as defined! Because we visit <code>node.target</code> on the walrus, which will be a <code>Name</code> node with ctx <code>Store</code>, so we will recursively hit this <code>Name</code> case, with <code>current_definition</code> set to the walrus expression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-05 20:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot/src/semantic/types/infer.rs</code>:182 on 2024-06-05 20:56</div>
            <div class="timeline-body"><p>Just realized this comment is wrong/unnecessary, because unpacking assignment can't actually be used in a walrus expression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-06-05 20:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot/src/semantic.rs</code>:260 on 2024-06-05 20:57</div>
            <div class="timeline-body"><blockquote>
<p>The walrus expression should record the symbol as defined, not as used; a use is a load of a name, not a store to it.</p>
</blockquote>
<p>Right, but in e.g. <code>x = (y := 1) + 2</code>, you could argue that <code>y</code> is being defined (assigned to <code>1</code>) and then <em>immediately</em> used (added to <code>2</code>) in the same breath?</p>
<blockquote>
<p>But we already do record it as defined! Because we visit <code>node.target</code> on the walrus, which will be a <code>Name</code> node with ctx <code>Store</code>, so we will recursively hit this <code>Name</code> case, with <code>current_definition</code> set to the walrus expression.</p>
</blockquote>
<p>Ah gotcha, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-06-05 21:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot/src/semantic.rs</code>:260 on 2024-06-05 21:06</div>
            <div class="timeline-body"><p>Thinking of the walrus-created variable as unused is consistent with our current behaviour, though: it appears we flag <code>x</code> in the following snippet as unused in e.g. our <code>F841</code> lint rule:</p>
<pre><code class="language-py">def foo():
    return (x := 1) + 2
</code></pre>
<p>And that sorta makes sense, since you can just write that more simply without the walrus as</p>
<pre><code class="language-py">def foo():
    return 1 + 2
</code></pre>
<p>So I think I retract my argument. It only makes sense to think of walrus-defined variables as being &quot;used&quot; if they are <em>additionally</em> used <em>outside</em> of the immediate expression in which they are defined.</p>
<p>TL;DR: LGTM!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-05 21:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot/src/semantic.rs</code>:260 on 2024-06-05 21:10</div>
            <div class="timeline-body"><blockquote>
<p>Right, but in e.g. x = (y := 1) + 2, you could argue that y is being defined (assigned to 1) and then immediately used (added to 2) in the same breath?</p>
</blockquote>
<p>Aha! Yes, that's an interesting point. You could look at it that way, but this is not really the way Python looks at it, in terms of the AST (there is no <code>Name</code> node for <code>y</code> with context <code>Load</code> here) or in terms of the compiled bytecode (there is no <code>LOAD_FAST/LOAD_NAME</code> of <code>y</code> here).</p>
<p>For basically exactly the same reasons, it is not the simplest way for us to look at it, either. There is no &quot;use&quot; of <code>y</code> here because there is no need for us to look up <code>y</code> and resolve reachable definition(s) for it: we know that definition would always resolve to this very walrus expression, and when doing type inference we always already have the type of that expression in hand! So it's much simpler to look at it as simply &quot;the type of the walrus expression is the type of its right-hand side, and as a side effect it also defines a name.&quot; This is how CPython handles it (except in terms of value, not type, of course), and how we handle it in this PR, and it doesn't require treating the walrus expression as a &quot;use&quot; of its target name. You could think of it instead as we are only &quot;using&quot; the right-hand-side expression, and also storing it off to a name as a side effect, but not &quot;using&quot; the name here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-06-05 21:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-06-05 21:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-06-05 21:13</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:04:41 UTC
    </footer>
</body>
</html>
