<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Fix non-determinism in `ConstraintSet.specialize_constrained` - astral-sh/ruff #21744</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Fix non-determinism in <code>ConstraintSet.specialize_constrained</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21744">#21744</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-12-01 23:39
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>This fixes a non-determinism that we were seeing in the constraint set tests in <a href="https://github.com/astral-sh/ruff/pull/21715">astral-sh/ruff#21715</a>.</p>
<p>In this test, we create the following constraint set, and then try to create a specialization from it:</p>
<pre><code>(T@constrained_by_gradual_list = list[Base])
  ∨
(Bottom[list[Any]] ≤ T@constrained_by_gradual_list ≤ Top[list[Any]])
</code></pre>
<p>That is, <code>T</code> is either specifically <code>list[Base]</code>, or it&#x27;s any <code>list</code>. Our current heuristics say that, absent other restrictions, we should specialize <code>T</code> to the more specific type (<code>list[Base]</code>).</p>
<p>In the correct test output, we end up creating a BDD that looks like this:</p>
<pre><code>(T@constrained_by_gradual_list = list[Base])
┡━₁ always
└─₀ (Bottom[list[Any]] ≤ T@constrained_by_gradual_list ≤ Top[list[Any]])
    ┡━₁ always
    └─₀ never
</code></pre>
<p>In the incorrect output, the BDD looks like this:</p>
<pre><code>(Bottom[list[Any]] ≤ T@constrained_by_gradual_list ≤ Top[list[Any]])
┡━₁ always
└─₀ never
</code></pre>
<p>The difference is the ordering of the two individual constraints. Both constraints appear in the first BDD, but the second BDD only contains <code>T is any list</code>. If we were to force the second BDD to contain both constraints, it would look like this:</p>
<pre><code>(Bottom[list[Any]] ≤ T@constrained_by_gradual_list ≤ Top[list[Any]])
┡━₁ always
└─₀ (T@constrained_by_gradual_list = list[Base])
    ┡━₁ always
    └─₀ never
</code></pre>
<p>This is the standard shape for an OR of two constraints. However! Those two constraints are not independent of each other! If <code>T</code> is specifically <code>list[Base]</code>, then it&#x27;s definitely also &quot;any <code>list</code>&quot;. From that, we can infer the contrapositive: that if <code>T</code> is not any list, then it cannot be <code>list[Base]</code> specifically. When we encounter impossible situations like that, we prune that path in the BDD, and treat it as <code>false</code>. That rewrites the second BDD to the following:</p>
<pre><code>(Bottom[list[Any]] ≤ T@constrained_by_gradual_list ≤ Top[list[Any]])
┡━₁ always
└─₀ (T@constrained_by_gradual_list = list[Base])
    ┡━₁ never   &lt;-- IMPOSSIBLE, rewritten to never
    └─₀ never
</code></pre>
<p>We then would see that that BDD node is redundant, since both of its outgoing edges point at the <code>never</code> node. Our BDDs are <em>reduced</em>, which means we have to remove that redundant node, resulting in the BDD we saw above:</p>
<pre><code>(Bottom[list[Any]] ≤ T@constrained_by_gradual_list ≤ Top[list[Any]])
┡━₁ always
└─₀ never       &lt;-- redundant node removed
</code></pre>
<p>The end result is that we were &quot;forgetting&quot; about the <code>T = list[Base]</code> constraint, but only for some BDD variable orderings.</p>
<p>To fix this, I&#x27;m leaning in to the fact that our BDDs really do need to &quot;remember&quot; all of the constraints that they were created with. Some combinations might not be possible, but we now have the sequent map, which is quite good at detecting and pruning those.</p>
<p>So now our BDDs are <em>quasi-reduced</em>, which just means that redundant nodes are allowed. (At first I was worried that allowing redundant nodes would be an unsound &quot;fix the glitch&quot;. But it turns out they&#x27;re real! <a href="https://ieeexplore.ieee.org/abstract/document/130209">This</a> is the paper that introduces them, though it&#x27;s very difficult to read. Knuth mentions them in §7.1.4 of <a href="https://course.khoury.northeastern.edu/csu690/ssl/bdd-knuth.pdf">TAOCP</a>, and <a href="https://par.nsf.gov/servlets/purl/10128966">this paper</a> has a nice short summary of them in §2.)</p>
<p>While we&#x27;re here, I&#x27;ve added a bunch of <code>debug</code> and <code>trace</code> level log messages to the constraint set implementation. I was getting tired of having to add these by hands over and over. To enable them, just set <code>TY_LOG</code> in your environment, e.g.</p>
<pre><code>env TY_LOG=ty_python_semantic::types::constraints::SequentMap=trace ty check ...
</code></pre>
<p>[Note, this has an <code>internal</code> label because are still not using <code>specialize_constrained</code> in anything user-facing yet.]</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-01 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-01 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-01 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-01 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-01 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-01 23:41</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-01 23:43</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>beartype (https://github.com/beartype/beartype)
- beartype/claw/_package/clawpkgtrie.py:66:29: warning[unsupported-base] Unsupported class base with type `&lt;class &#x27;dict[str, PackagesTrieBlacklist]&#x27;&gt; | &lt;class &#x27;dict[str, Divergent]&#x27;&gt;`
- Found 494 diagnostics
+ Found 493 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/_logging.py:153:13: warning[unsupported-base] Unsupported class base with type `&lt;class &#x27;Mapping[str, Style]&#x27;&gt; | &lt;class &#x27;Mapping[str, Divergent]&#x27;&gt;`
- src/scikit_build_core/build/_pathutil.py:25:38: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `str | PathLike[str]`, found `DirEntry[Path]`
- src/scikit_build_core/build/_pathutil.py:27:24: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `str | PathLike[str]`, found `DirEntry[Path]`
- src/scikit_build_core/build/wheel.py:98:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 45 diagnostics
+ Found 41 diagnostics

rotki (https://github.com/rotki/rotki)
- rotkehlchen/accounting/structures/processed_event.py:85:75: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- rotkehlchen/api/rest.py:1041:73: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 2052 diagnostics
+ Found 2050 diagnostics


</code></pre>


<p>No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:45 on 2025-12-02 13:46</div>
            <div class="timeline-body"><p>I think this test (and the other changed one below) were other possible points of nondeterminism, since the result could depend on whether <code>T ≤ bool</code> was kept in the BDD or simplified away as described in the PR body.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:257 on 2025-12-02 13:47</div>
            <div class="timeline-body"><p>This test failed before these fixes, reproducing the test failure in the macOS CI job</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:785 on 2025-12-02 13:53</div>
            <div class="timeline-body"><p>This is the clause that used to remove redundant BDD nodes. Removing it changes our BDDs from reduced to quasi-reduced.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:956 on 2025-12-02 13:55</div>
            <div class="timeline-body"><p>This method skips calling <code>Node::new</code> for some inputs, so we have to change the base cases to not throw away redundant nodes. (ditto below)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3172 on 2025-12-02 13:57</div>
            <div class="timeline-body"><p>This was a bug in our display rendering that we couldn&#x27;t trigger before, since <code>never</code> BDDs were always collapsed into the <code>AlwaysNever</code> terminal. Now we might have BDDs where all paths lead to the <code>never</code> terminal, which would hit this clause. (The intuition here is that we&#x27;re displaying a DNF formula — a union of intersections — and so if the union contains no elements, the overall formula is <code>false</code>/<code>never</code>. And the new snippet just above handles where there&#x27;s a single-element union of an empty intersection, which represents <code>true</code>/<code>always</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3426 on 2025-12-02 14:00</div>
            <div class="timeline-body"><p>This looks like a big blow-up in the size of the BDD, but we still have structural sharing from the salsa interning. So for example, all of the copies of</p>
<pre><code>(U = bool)
┡━₁ always
└─₀ never
</code></pre>
<p>are stored once as a single <code>InternalNode</code>. So the rendered size here is not a good proxy for how much memory is used internally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-12-02 14:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-12-02 14:11</div>
            <div class="timeline-body">

<a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fnondeterminism?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a>
Merging #21744 will <strong>not alter performance</strong>
<p>Comparing <code>dcreager/nondeterminism</code> (948a9fb) with <code>main</code> (cd079bd)</p>
Summary
<p><code>✅ 22</code> untouched<br>
<code>⏩ 30</code> skipped[^skipped]</p>
<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fnondeterminism?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:45 on 2025-12-03 03:07</div>
            <div class="timeline-body"><p>I&#x27;m not sure I understand why we solve this to <code>bool</code>. The constraints are <code>T &lt;= int | T &lt;= bool</code>, which seems equivalent to <code>T &lt;= int</code>. Why do we prefer solving to <code>bool</code> when there&#x27;s the additional (seemingly redundant) constraint present?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3426 on 2025-12-03 03:11</div>
            <div class="timeline-body"><p>Primer doesn&#x27;t report any noticeable memory increases, that&#x27;s good enough for me!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-12-03 03:14</div>
            <div class="timeline-body"><p>It seems a bit sad that we have to do this. I guess ultimately the reason for it boils down to the fact that constraints can involve gradual types, and we don&#x27;t staticify those via materialization, and this can lead to these path-dependent redundancy determinations. And we can&#x27;t reduce constraints to fully static types without breaking the gradual guarantee / causing false positives.</p>
<p>But I guess the positive is that this fix isn&#x27;t complex at all, fixes the issue, and doesn&#x27;t seem to cause memory issues!</p>
<p>Thank you.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-12-03 14:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:45 on 2025-12-03 14:37</div>
            <div class="timeline-body"><p>This is because of our current heuristic for handling multiple paths in a BDD. <code>T ≤ int ∨ T ≤ bool</code> ends up looking like this now:</p>
<pre><code>(T ≤ int)
┡━₁ (T ≤ bool)
│   ┡━₁ true
│   └─₀ true
└─₀ (T ≤ bool)
    ┡━₁ impossible
    └─₀ false
</code></pre>
<p>There are two paths to the <code>true</code> terminal, one representing <code>T ≤ bool</code> and one representing <code>bool &lt; T ≤ int</code>. <code>T = bool</code> and <code>T = int</code> are the largest types that satisfy each respective path. Our current heuristic says that if there&#x27;s a type that satisfies all paths, we choose that. (That is, if the intersection of the specializations is non-empty, use it.)</p>
<p>I&#x27;m very much open to changing that heuristic, but think that should be follow-on work. I&#x27;ll mark this as a TODO that we&#x27;d rather produce <code>T = int</code> here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-03 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dcreager">@dcreager</a> on 2025-12-03 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-12-03 15:19</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:21:17 UTC
    </footer>
</body>
</html>
