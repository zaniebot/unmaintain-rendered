<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] remove any_over_type - astral-sh/ruff #19099</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] remove any_over_type</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19099">#19099</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-07-02 18:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2025-07-02 18:43</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Remove the recursive type walk <code>any_over_type</code> and its sole current use in deciding whether to emit a redundant-cast diagnostic; instead, just skip the redundant-cast diagnostic if we are casting <code>Unknown</code> or <code>Todo</code> as a top-level type. This removes another recursive type walk (and its associated recursive-type complications).</p>
<p>The ecosystem report suggests the number of false positives this currently adds is quite manageable, and the few that it does add can mostly be removed by targeting a few cases where we currently create <code>Todo</code> types. While suppressing false positives from <code>Todo</code> types is useful in the short term and worth doing when it's easy, I don't think it should drive significant architecture decisions or extra runtime work.</p>
<p>If we do decide (even though it currently seems to have little impact on the ecosystem report) that it's important for gradual-guarantee reasons to do deep suppression of <code>redundant-cast</code> when nested <code>Unknown</code> types are involved (I am not sure how strong the case for this is, since the use of <code>cast</code> in the first place suggests a typed codebase), I think the better approach to this would be a strategy parameter to <code>is_equivalent_to</code> that could cause <code>Unknown</code> to not be considered equivalent to <code>Unknown</code> or <code>Any</code>, rather than a separate recursive type walk.</p>
<h2>Test Plan</h2>
<p>CI</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @carljm on 2025-07-02 18:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-02 18:47</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">Expression (https://github.com/cognitedata/Expression)
-     memo fields = ~49MB
+     memo fields = ~54MB

aioredis (https://github.com/aio-libs/aioredis)
-     memo fields = ~54MB
+     memo fields = ~60MB

werkzeug (https://github.com/pallets/werkzeug)
-     memo fields = ~129MB
+     memo fields = ~142MB

hydra-zen (https://github.com/mit-ll-responsible-ai/hydra-zen)
+ warning[redundant-cast] src/hydra_zen/_utils/coerce.py:107:16: Value is already of type `_T`
+ warning[redundant-cast] src/hydra_zen/_utils/coerce.py:178:16: Value is already of type `_T`
- Found 599 diagnostics
+ Found 601 diagnostics
- TOTAL MEMORY USAGE: ~80MB
+ TOTAL MEMORY USAGE: ~88MB

discord.py (https://github.com/Rapptz/discord.py)
- TOTAL MEMORY USAGE: ~228MB
+ TOTAL MEMORY USAGE: ~251MB

kopf (https://github.com/nolar/kopf)
+ warning[redundant-cast] kopf/_cogs/configs/diffbase.py:52:19: Value is already of type `dict[Any, Any]`
- Found 130 diagnostics
+ Found 131 diagnostics

mkosi (https://github.com/systemd/mkosi)
-     memo fields = ~106MB
+     memo fields = ~97MB

bandersnatch (https://github.com/pypa/bandersnatch)
-     memo fields = ~66MB
+     memo fields = ~72MB

tornado (https://github.com/tornadoweb/tornado)
- TOTAL MEMORY USAGE: ~171MB
+ TOTAL MEMORY USAGE: ~156MB

mkdocs (https://github.com/mkdocs/mkdocs)
- TOTAL MEMORY USAGE: ~117MB
+ TOTAL MEMORY USAGE: ~129MB

streamlit (https://github.com/streamlit/streamlit)
+ warning[redundant-cast] lib/streamlit/runtime/state/common.py:71:5: Value is already of type `tuple[@Todo(Inference of subscript on special form), ...]`
- Found 3304 diagnostics
+ Found 3305 diagnostics

meson (https://github.com/mesonbuild/meson)
+ warning[redundant-cast] mesonbuild/options.py:705:35: Value is already of type `list[@Todo(Inference of subscript on special form)]`
+ warning[redundant-cast] mesonbuild/options.py:772:35: Value is already of type `list[@Todo(Inference of subscript on special form)]`
- Found 930 diagnostics
+ Found 932 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
+ warning[redundant-cast] src/prefect/server/orchestration/core_policy.py:68:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
+ warning[redundant-cast] src/prefect/server/orchestration/core_policy.py:106:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
+ warning[redundant-cast] src/prefect/server/orchestration/core_policy.py:146:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
+ warning[redundant-cast] src/prefect/server/orchestration/core_policy.py:184:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
+ warning[redundant-cast] src/prefect/server/orchestration/core_policy.py:218:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
+ warning[redundant-cast] src/prefect/server/orchestration/global_policy.py:69:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
+ warning[redundant-cast] src/prefect/server/orchestration/global_policy.py:102:16: Value is already of type `list[@Todo(unsupported nested subscript in type[X])]`
- Found 3851 diagnostics
+ Found 3858 diagnostics

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-07-02 18:53</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_WALLTIME_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Fnoanyover?runnerMode=WallTime">CodSpeed WallTime Performance Report</a></h2>
<h3>Merging #19099 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>cjm/noanyover</code> (ca0e578) with <code>main</code> (0660188)</sub></p>
<h3>Summary</h3>
<p><code>âœ… 8</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[experiment] remove any_over_type" to "[ty] remove any_over_type" by @carljm on 2025-07-02 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @carljm on 2025-07-02 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2025-07-02 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @carljm on 2025-07-02 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @carljm on 2025-07-02 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-07-03 11:49</div>
            <div class="timeline-body"><p>I love the reduction in code complexity (especially relative to https://github.com/astral-sh/ruff/pull/19094!) but I do think this pretty clearly breaks the gradual guarantee for something like this?</p>
<pre><code class="language-py">from unresolvable_module import Foo, Bar

def f(x: list[Foo]):
    y = cast(list[Bar], x)
</code></pre>
<p>it seems just like somewhat random luck that we don't have anything in the mypy_primer corpus that triggers a false-positive <code>redundant-cast</code> diagnostic on that as a result of this change :-) I'd be curious to see what this idea looks like; it seems viable:</p>
<blockquote>
<p>I think the better approach to this would be a strategy parameter to is_equivalent_to that could cause <code>Unknown</code> to not be considered equivalent to <code>Unknown</code> or <code>Any</code>, rather than a separate recursive type walk.</p>
</blockquote>
<p>I also don't think this gets us away in the long term from having to find a way to recursively walk types. For example, we've discussed for a while that a feature many people want is a way to know what percentage of types across a single run of ty are inferred as <code>Any</code>/<code>Unknown</code>. Mypy's version of this feature also tells users what percentage of types are &quot;partially <code>Any</code>/<code>Unknown</code>&quot;; it would be a shame not to be able to match that capability.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-03 12:40</div>
            <div class="timeline-body"><blockquote>
<p>I'd be curious to see what this idea looks like; it seems viable:</p>
<blockquote>
<p>I think the better approach to this would be a strategy parameter to is_equivalent_to that could cause <code>Unknown</code> to not be considered equivalent to <code>Unknown</code> or <code>Any</code>, rather than a separate recursive type walk.</p>
</blockquote>
</blockquote>
<p>But on second thought, I don't think this approach works for protocols that have unknown fields? Equivalence for protocols just normalizes both the l.h.s. and the r.h.s., then compares for identity; this has the advantage that once recursive protocols are &quot;solved&quot; in <code>Type::normalized()</code>, it means we don't have to worry about them in equivalence checks between protocols:</p>
<p>https://github.com/astral-sh/ruff/blob/fc43d3c83ec170e58c9c42ab1d98866572fe1750/crates/ty_python_semantic/src/types/instance.rs#L259-L261</p>
<p>But this means that these two protocols will normalize to the same type, because <code>Unknown</code>/<code>Todo</code> both normalize to <code>Any</code>, so you'd get a false-positive <code>redundant-cast</code> diagnostic if you tried to cast from one to the other. <code>Unknown.is_equivalent_to(Any)</code> would never be called:</p>
<pre><code class="language-py">from unresolved_module import Foo
from typing import Any, Protocol

class Bar(Protocol):
    x: Foo

class Baz(Protocol):
    x: Any
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-03 16:43</div>
            <div class="timeline-body"><p>Ok, I'm convinced, both that we may have other needs for this in future, and that doing this <code>cast</code> check in <code>is_equivalent_to</code> won't work in all cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-07-03 16:43</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:33:38 UTC
    </footer>
</body>
</html>
