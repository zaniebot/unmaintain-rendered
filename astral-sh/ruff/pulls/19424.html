<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`pyupgrade`]  Apply `UP008` only when the `__class__` cell exists - astral-sh/ruff #19424</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>pyupgrade</code>]  Apply <code>UP008</code> only when the <code>__class__</code> cell exists</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19424">#19424</a>
        opened by <a href="https://github.com/IDrokin117">@IDrokin117</a>
        on 2025-07-18 15:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/IDrokin117">@IDrokin117</a> on 2025-07-18 15:33</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Resolves #19357</p>
<p>Skip UP008 diagnostic for <code>builtins.super(P, self)</code> calls when <code>__class__</code> is not referenced locally, preventing incorrect fixes.</p>
<p><strong>Note:</strong> I haven't found concrete information about which cases <code>__class__</code> will be loaded into the scope. Let me know if anyone has references, it would be useful to enhance the implementation. I did a lot of tests to determine when <code>__class__</code> is loaded. Considered sources:</p>
<ol>
<li><a href="https://docs.python.org/3/library/functions.html#super">Python doc super</a></li>
<li><a href="https://docs.python.org/3/tutorial/classes.html">Python doc classes</a></li>
<li><a href="https://peps.python.org/pep-3135/#specification">pep-3135</a></li>
</ol>
<p>As I understand it, Python will inject at runtime into local scope a <code>__class__</code> variable if it detects references to <code>super</code> or <code>__class__</code>. This allows calling <code>super()</code> and passing appropriate parameters. However, the compiler doesn't do the same for <code>builtins.super</code>, so we need to somehow introduce <code>__class__</code> into the local scope.</p>
<p>I figured out <code>__class__</code> will be in scope with valid value when two conditions are met:</p>
<ol>
<li><code>super</code> or <code>__class__</code> names have been loaded within function scope</li>
<li><code>__class__</code> is not overridden.</li>
</ol>
<p>I think my solution isn't elegant, so I would be appreciate a detailed review.</p>
<h2>Test Plan</h2>
<p>Added 19 test cases, updated snapshots.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-18 15:43</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @IDrokin117 on 2025-07-20 13:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @IDrokin117 on 2025-07-21 15:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/IDrokin117">@IDrokin117</a> on 2025-07-24 12:56</div>
            <div class="timeline-body"><p>@ntBre Could you please review a PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ntBre by @ntBre on 2025-07-24 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @ntBre on 2025-07-24 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fixes</span> added by @ntBre on 2025-07-24 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-07-24 13:04</div>
            <div class="timeline-body"><p>Will do! Sorry, I'm a bit behind on my review queue, but this has been on the list.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ntBre by @IDrokin117 on 2025-08-09 20:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-13 18:22</div>
            <div class="timeline-body"><p>I just came back to this notification right after reviewing https://github.com/astral-sh/ruff/pull/19783. I somehow hadn't connected these two before, but now I'm wondering if they have the same root cause. I think if we're able to work out a neat, general solution for binding the <code>__class__</code> cell it might help here too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-26 13:54</div>
            <div class="timeline-body"><p>We added a new <code>ScopeKind::DunderClassCell</code> (and <code>BindingKind::DunderClassCell</code>) in https://github.com/astral-sh/ruff/pull/20048. I don't believe that will resolve the issue addressed by this PR, but would you mind seeing if it makes anything easier? I was hoping it might help to avoid the new <code>Visitor</code>, but I think we'll still need some rule-specific changes in any case.</p>
<p>Thanks again for your work here :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/IDrokin117">@IDrokin117</a> on 2025-08-26 18:05</div>
            <div class="timeline-body"><p>@ntBre Good news! Here are my thoughts after reviewing the new feature.<br />
It seems the <code>__class__</code> binding is being created in any case now, regardless of whether <code>__class__</code> and <code>super</code> names are present. Am I right? This is going to be simple and good for some rules, but not for this case. Since the <code>__class__</code> binding pretends to always exist within a method, it doesn't provide any new information. I mean, if a <code>__class__</code> cell is available, then <code>builtins.super()</code> has to work. But that's not true since <code>__class__</code> is not always available. I see two options to resolve the issue:</p>
<ol>
<li>Left the extra visitor to ensure determination of whether <code>__class__</code> is really injected at runtime based on specific rules.</li>
<li>Simplify the rule and apply it only if <code>super()</code> is encountered, ignoring <code>builtins.super()</code>.</li>
</ol>
<p>Since I've already implemented tailored <code>__class__</code> determination, I prefer the first option. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-29 13:34</div>
            <div class="timeline-body"><p>Thanks for looking into it and rebasing the PR!</p>
<blockquote>
<p>It seems the <code>__class__</code> binding is being created in any case now, regardless of whether <code>__class__</code> and <code>super</code> names are present. Am I right?</p>
</blockquote>
<p>Yes that's right, we didn't try to detect if <code>__class__</code> or <code>super</code> was used, so it makes sense that it may not help here.</p>
<blockquote>
<ol>
<li>Left the extra visitor to ensure determination of whether <code>__class__</code> is really injected at runtime based on specific rules.</li>
<li>Simplify the rule and apply it only if <code>super()</code> is encountered, ignoring <code>builtins.super()</code>.</li>
</ol>
<p>Since I've already implemented tailored <code>__class__</code> determination, I prefer the first option. What do you think?</p>
</blockquote>
<p>Makes sense to me, I'll give this another review soon!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ntBre by @IDrokin117 on 2025-09-09 18:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[`pyupgrade`]  Apply UP008 only when the __class__ cell exists (`UP008`)" to "[`pyupgrade`]  Apply `UP008` only when the `__class__` cell exists (`UP008`)" by @ntBre on 2025-09-09 18:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[`pyupgrade`]  Apply `UP008` only when the `__class__` cell exists (`UP008`)" to "[`pyupgrade`]  Apply `UP008` only when the `__class__` cell exists" by @ntBre on 2025-09-09 18:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @ntBre on 2025-09-09 18:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ntBre on 2025-09-09 18:59</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:40:52 UTC
    </footer>
</body>
</html>
