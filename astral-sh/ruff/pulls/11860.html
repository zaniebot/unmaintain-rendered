<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>red-knot: Symbol table - astral-sh/ruff #11860</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>red-knot: Symbol table</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/11860">#11860</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2024-06-13 15:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-13 15:15</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR ports the <code>red_knot</code> <code>SymbolTable</code> to Salsa.</p>
<p>The main design difference compared to the non-Salsa <code>SymbolTable</code> is that this PR uses a representation that allows Salsa to cache the symbol table per scope. The <code>SemanticIndex</code> is still built in a single pass, it's just the internal representation that's different. The main benefit of a symbol tables per scope is that we get more fine-grained invalidation during type checking.</p>
<ul>
<li>Before: A query depending on the public symbol <code>foo</code> from module <code>bar</code> would be invalidated whenever any symbol in that file changes.</li>
<li>With this PR: A query depending on the public symbol <code>foo</code> from <code>bar</code> only gets invalidated when the module level symbol table changes, but not if a function or class level symbol table changes.</li>
</ul>
<p>However, splitting the symbol table by scope does bring new complexity. Mainly, that we now have to deal with more IDs.
I tried to establish a naming schema, although I'm not yet fully satisfied with the names:</p>
<ul>
<li><code>Local*Id</code> (e.g <code>LocalSymbolId</code>). An ID that uniquely identifies an entity in a scope.</li>
<li><code>*Id</code> (e.g. <code>SymbolId</code>). An ID that uniquely identifies an entity in a file. It's a combination of <code>ScopeId</code> + <code>Local*Id</code></li>
<li><code>Global*</code> (e.g. <code>GlobalSymbol). A globally unique identifier across modules. Consists of a </code>VfsFile<code>, </code>ScopeId<code>, and </code>LocalId`.</li>
</ul>
<p>I don't particularly like the <code>Global</code> prefix because it's a bit misleading when using it with <code>Scope</code> -&gt; <code>GlobalScope</code>. Any name suggestions would be highly appreciated.</p>
<p><code>GlobalScope</code> is special, because it is a Salsa interned. This allows us to parameterized queries by scope, e.g. the <code>symbol_table</code> query now accepts a <code>GlobalScope</code> as parameter.</p>
<h2>What's not part of this PR</h2>
<ul>
<li>Control flow graph</li>
<li>Anything types</li>
<li>Node with scope -&gt; Scope (I want to wait until I have a concrete use case before adding it)</li>
</ul>
<h2>Test Plan</h2>
<ul>
<li>I ported all <code>SemanticIndex</code> tests</li>
<li>I added a few new tests.</li>
</ul>
<h2>Test Plan</h2>
<p>What's a test plan?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2024-06-13 15:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-13 15:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/symbol_table/symbol.rs</code>:13 on 2024-06-13 15:23</div>
            <div class="timeline-body"><p>@carljm Is there a particular reason why the existing semantic model stores the definitions in a <code>FxHashMap&lt;SymbolId, Vec&lt;Definition&gt;&gt;</code> rather than on the symbol itself?</p>
<p>Having it on the <code>Symbol</code> should make <code>is_defined()</code> trivial</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-06-13 15:37</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/symbol.rs</code>:37 on 2024-06-14 12:49</div>
            <div class="timeline-body"><p>@carljm I copied this over from the existing semanitc model. Always pushing <code>Unbound</code> feels off. Could we insert unbound in the read path instead of when creating the symbols?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-14 12:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @MichaReiser on 2024-06-14 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @MichaReiser on 2024-06-14 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-06-17 23:44</div>
            <div class="timeline-body"><p>After reading this PR, I agree that the name <code>GlobalScope</code> especially is way too confusing.</p>
<blockquote>
<p>Any name suggestions would be highly appreciated.</p>
</blockquote>
<p>One possible suggestion:</p>
<ul>
<li><code>ScopeSymbolId</code> (unique id of a symbol within a scope)</li>
<li><code>FileSymbolId</code> (unique id of a symbol within a file)</li>
<li><code>SymbolId</code> (globally unique symbol id)</li>
<li><code>FileScopeId</code> (unique id of a scope within a file)</li>
<li><code>ScopeId</code> (globally unique scope ID)</li>
</ul>
<p>The general principle here is that the most generic / shortest name is reserved for the globally-unique thing (since this is the most general-purpose / generally-usable), and scoped variants are named with a prefix representing their scope of validity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-17 23:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/symbol.rs</code>:37 on 2024-06-17 23:48</div>
            <div class="timeline-body"><p>By &quot;existing semantic model&quot; here I assume you mean the existing (non-red-knot) ruff semantic model? Because the existing non-salsa red-knot semantic model doesn't do this, it only inserts Unbound in the read path (in ReachableDefinitionsIterator.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-17 23:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/symbol_table/symbol.rs</code>:13 on 2024-06-17 23:52</div>
            <div class="timeline-body"><p>I did it that way in order to keep the symbol table potentially separable from definitions and thus from the AST.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/Cargo.toml</code>:39 on 2024-06-18 00:08</div>
            <div class="timeline-body"><p>If we have to always turn on the optional dependency in order to avoid breaking the build, are we gaining anything by maintaining the optional feature deps?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/lib.rs</code>:15 on 2024-06-18 00:10</div>
            <div class="timeline-body"><p>If we are going to have a <code>red_knot</code> submodule, why doesn't all the red-knot code go there? What's special about the <code>module</code> and <code>db</code> and <code>name</code> submodules? I don't feel like I understand the intention or plan behind the code structure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/lib.rs</code>:12 on 2024-06-18 00:13</div>
            <div class="timeline-body"><p>Why isn't this under the red-knot feature, if it's only used by red-knot code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/Cargo.toml</code>:39 on 2024-06-18 00:25</div>
            <div class="timeline-body"><p>I know I said this morning I was OK either way, but after reading this PR and thinking about it more, I really do favor putting all this in a separate crate. I don't see any shared code between the old <code>ruff_python_semantic</code> code and the new, and looking through the old semantic model code, I'm not really seeing where there would be shared code between them in the future (or even any direct dependency between them). I think the code we are likely to share is in other crates; <code>ruff_python_semantic</code> we are basically replacing. I think it will be a lot clearer, both for maintainers of the old semantic model and for development of the new, if we use a new crate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/ast_node_ref.rs</code>:127 on 2024-06-18 00:33</div>
            <div class="timeline-body"><p>I would usually prefer to make this three separate tests, since it's testing entirely different scenarios that could separately succeed or fail, even if it means we can't reuse <code>node1</code> in all three tests. Gives better signal on test failures.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/ast_node_ref.rs</code>:107 on 2024-06-18 00:35</div>
            <div class="timeline-body"><p>We do this three-line dance three times in these tests; that's about the point where I'd usually consider a helper function. (This also goes with the below comment, since helper functions make it less onerous to separate tests.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-18 00:46</div>
            <div class="timeline-body"><p>It's not clear to me why we need a mapping or a query here when it seems like the mapping function is trivial: take the file id and the file-local scope id and put them together.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:75 on 2024-06-18 00:47</div>
            <div class="timeline-body"><pre><code class="language-suggestion">/// The symbol tables for an entire file.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:89 on 2024-06-18 00:51</div>
            <div class="timeline-body"><p>I think it would be more useful/usable to put comments like this on queries or on methods. E.g. I don't think a file should ever query the entire semantic index for another file at all, it should only query the public type of a global symbol.</p>
<p>It's hard to know how to make use of this comment since the field itself isn't public anyway, so you can't use it directly, and you'd have to read a lot of code to know which methods on the semantic index might risk making use of this map.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:251 on 2024-06-18 00:58</div>
            <div class="timeline-body"><pre><code class="language-suggestion">
#[cfg(test)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:412 on 2024-06-18 01:04</div>
            <div class="timeline-body"><p>I would prefer to use <code>textwrap::dedent</code> in <code>test_case</code> function and avoid this ugly (lack of) indentation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/definition.rs</code>:44 on 2024-06-18 01:15</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Index into [`ruff_python_ast::StmtImportFrom::names`].
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/definition.rs</code>:42 on 2024-06-18 01:16</div>
            <div class="timeline-body"><p>why no from impls for assignment, annassign, namedexpr?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/definition.rs</code>:71 on 2024-06-18 01:30</div>
            <div class="timeline-body"><p>We will need <code>level</code> field here also, whenever we actually add support for resolving relative imports.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-18 01:30</div>
            <div class="timeline-body"><p>This looks really good! Definitely an upgrade over the existing version in a lot of ways.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 06:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/Cargo.toml</code>:39 on 2024-06-18 06:41</div>
            <div class="timeline-body"><p>You still get faster compile time when working on ruff (not red knot) because cargo can avoid compiling these dependencies and the red knot code</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 06:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/lib.rs</code>:15 on 2024-06-18 06:43</div>
            <div class="timeline-body"><p>The main idea is that <code>Name</code> isn't something that's by design coupled to red-knots new architecture. It's a general useful abstraction that could also be used in the existing Ruff code. In other words, the idea is to have code in the red-knot module that's specific to red-knots new architecture.</p>
<p>I think we could move <code>db</code> to the <code>red_knot</code> sub-module. But <code>Db</code> and <code>Jar</code> must be defined (or at least re-exported) at the crate level for better salsa integration (or we have to explicitly specify the <code>Db</code> and <code>Jar</code> type whenever we use the macros)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 06:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/lib.rs</code>:12 on 2024-06-18 06:44</div>
            <div class="timeline-body"><p>Resolving in favor of https://github.com/astral-sh/ruff/pull/11860#discussion_r1643569747</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 06:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/ast_node_ref.rs</code>:107 on 2024-06-18 06:45</div>
            <div class="timeline-body"><p>I can look into it but I'm not sure if we gain much and it could be a bit complicated because of lifetimes. That means, I try but I don't think it's worth spending more than 5min if I run into complications.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 06:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-18 06:48</div>
            <div class="timeline-body"><p>The operation is simple but it runs on every <code>public_symbol_ty</code>. The other reason is that <code>GlobalScope</code> is a salsa tracked struct and their identity is purely defined by their instance. That means, re-creating them would create different salsa <code>GlobalScope</code>s even if their value is identical.</p>
<p>I think we could work around this by changing <code>GlobalScope</code> to</p>
<pre><code class="language-rust">struct GlobalScope {
	#[id]
	id: (VfsFile, ScopeId) 
}
</code></pre>
<p>But this shouldn't be necessary if we have this intermediate query, because Salsa than tracks the identity by their ordering.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 06:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:412 on 2024-06-18 06:50</div>
            <div class="timeline-body"><p>I avoid using <code>dedent</code> because it makes it very difficult to reason about text offsets. The offsets in the AST no longer match the offsets in the string that you see in the test. Cases where you then slice into the string using the AST offsets may even panic.</p>
<p>The formatting with <code>dedent</code> is</p>
<pre><code class="language-rust">        let TestCase { db, file } = test_case(
                    &quot;
                    def func():
                        x = 1
                    y = 2
                    &quot;,
        );
</code></pre>
<p>Which may be slightly better but is still hard to read.  (I don't know what GitHub does but I did align the quotes!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 07:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/Cargo.toml</code>:39 on 2024-06-18 07:00</div>
            <div class="timeline-body"><p>See https://github.com/astral-sh/ruff/issues/11920</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @MichaReiser on 2024-06-18 12:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 12:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/symbol_table/symbol.rs</code>:13 on 2024-06-18 12:13</div>
            <div class="timeline-body"><p>That makes sense. <code>Definition</code> no longer depends on the AST, so I guess that's fine?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 12:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/ast_node_ref.rs</code>:107 on 2024-06-18 12:19</div>
            <div class="timeline-body"><p>I prefer it the way it is. I like setup function but I don't think they give us much or are flawed because they're not fully generic over their argument or need to be unsafe:</p>
<ul>
<li>Any utility function would need to make assumption about the source and, therefore, wouldn't be parametrized of the source.</li>
<li>A function just for getting <code>parsed.syntax().body[0]</code> seems overkill (even if it wraps the <code>unsafe</code> call, in which case that function would need to be unsafe).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 12:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:89 on 2024-06-18 12:22</div>
            <div class="timeline-body"><p>I added some documentation to the methods using the map. Overall, the note is no longer relevant because the argument is an <code>&amp;ast::Expr</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 12:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/definition.rs</code>:42 on 2024-06-18 12:29</div>
            <div class="timeline-body"><p>Too much work :P</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 12:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index/definition.rs</code>:71 on 2024-06-18 12:30</div>
            <div class="timeline-body"><p>Makes sense. I'll wait with adding it for when we add support for relative imports</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-18 13:06</div>
            <div class="timeline-body"><p>I went with the following naming</p>
<ul>
<li><code>GlobalSymbol</code> -&gt; <code>PublicSymbolId</code> because it is even more restrictive</li>
<li><code>SymbolId</code> -&gt; <code>FileSymbolId</code></li>
<li><code>LocalSymbolId</code> -&gt; <code>ScopeSymbolId</code></li>
<li><code>GlobalScope</code> -&gt; <code>ScopeId</code></li>
<li><code>ScopeId</code> -&gt; <code>FileScopeId</code></li>
</ul>
<p>I do find <code>ScopeSymbolId</code> a bit weird, but I wasn't able to come up with a better naming schema.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @dhruvmanila removed by @MichaReiser on 2024-06-18 13:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "red-knot [salsa part 7]: Symbol table" to "red-knot: Symbol table" by @MichaReiser on 2024-06-18 13:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-06-18 13:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-06-18 13:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-06-18 13:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-18 18:20</div>
            <div class="timeline-body"><p>To me, having the global <code>Scope</code> have identity defined by value, and created on-demand, (i.e. basically what you propose using <code>#[id]</code>) seems simpler and cheaper than maintaining an extra query and redundant map structure. But it's quite likely that I'm missing some subtleties here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-18 18:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-18 18:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:412 on 2024-06-18 18:24</div>
            <div class="timeline-body"><p>Ah, hm. I do think the indented version is significantly more readable (it doesn't disrupt the visual indentation of the overall block structure), but I do see the point about offsets. I'm not totally convinced by it, though.</p>
<p>I'm not sure how often I would ever manually count character offsets in the text on screen, but even if I did, it would feel pretty natural to skip all those leading spaces rather than try to count them.</p>
<p>And if the issue is programmatically indexing into the text within the test, that's also not a problem if the version of the text that accessible to the test is the already-dedented one. For instance, in these tests, if the dedent happens in <code>test_case</code>, and the returned <code>TestCase</code> exposes the dedented text, it's not an issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-18 19:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-18 19:13</div>
            <div class="timeline-body"><p>Let me try this tomorrow. I need to take a closer look at how salsa interns the tracked struct. Creating them lazily could especially be interesting for symbols because we would only create symbols for file symbols that are imported somewhere.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-19 06:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-19 06:49</div>
            <div class="timeline-body"><p>Okay I tried it out and it doesn't work. I added a log statement where we create the <code>ScopeId</code> from a <code>FileScopeId</code> and what I see is that salsa creates different IDs even when the two <code>ScopeIds</code> are equal</p>
<pre><code>[crates/red_knot_python_semantic/src/semantic_index/symbol.rs:180:9] self = FileScopeId(
    0,
)
[crates/red_knot_python_semantic/src/semantic_index/symbol.rs:180:9] file = VfsFile(
    Id {
        value: 1,
    },
)
[crates/red_knot_python_semantic/src/semantic_index/symbol.rs:182:9] scope_id.debug(db) = ScopeId {
    [salsa id]: 0,
    file: VfsFile(
        Id {
            value: 1,
        },
    ),
    file_id: FileScopeId(
        0,
    ),
}
[crates/red_knot_python_semantic/src/semantic_index/symbol.rs:180:9] self = FileScopeId(
    0,
)
[crates/red_knot_python_semantic/src/semantic_index/symbol.rs:180:9] file = VfsFile(
    Id {
        value: 1,
    },
)
[crates/red_knot_python_semantic/src/semantic_index/symbol.rs:182:9] scope_id.debug(db) = ScopeId {
    [salsa id]: 1,
    file: VfsFile(
        Id {
            value: 1,
        },
    ),
    file_id: FileScopeId(
        0,
    ),
}
</code></pre>
<p>That means, it's our responsibility to track the <code>FileScopeId</code> -&gt; <code>ScopeId</code> mapping</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-19 19:18</div>
            <div class="timeline-body"><p>Interesting. Does that mean that <code>#[id]</code> annotation doesn't do what we think it does? What's the explanation for this behavior? Is it not possible to have ingredients interned in salsa by value?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-06-19 19:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-19 20:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/red_knot/semantic_index.rs</code>:48 on 2024-06-19 20:13</div>
            <div class="timeline-body"><p>You can intern values by id. We do that for module names. But interning has the downside that salsa never collects old values, at least in salsa 2022.</p>
<p>What I understand is that salsa uses the id to match identical items across revisions (similar to key in React). But the uniqueness is not just defined by the id, but also the query that generates it. That means we could have a salsa query that maps the file id to the globally unique id, but that might result in more overhead (maybe not for public symbols if only a small subset is queried).</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:56:33 UTC
    </footer>
</body>
</html>
