<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for resolving metaclasses - astral-sh/ruff #14120</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for resolving metaclasses</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14120">#14120</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2024-11-06 02:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>I mirrored some of the idioms that @AlexWaygood used in the MRO work.</p>
<p>Closes https://github.com/astral-sh/ruff/issues/14096.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @charliermarsh on 2024-11-06 02:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2024-11-06 02:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @charliermarsh on 2024-11-06 02:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @charliermarsh on 2024-11-06 02:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 02:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:27 on 2024-11-06 02:39</div>
            <div class="timeline-body"><p>Should this be <code>A</code> rather than <code>Literal[A]</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @charliermarsh on 2024-11-06 02:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 02:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2105 on 2024-11-06 02:44</div>
            <div class="timeline-body"><p>Not totally certain what to do here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 03:31</div>
            <div class="timeline-body"><p>(Oops, it looks like I did this prior to pulling and need to resolve some conflicts.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @charliermarsh on 2024-11-06 03:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @charliermarsh on 2024-11-06 03:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2063 on 2024-11-06 03:45</div>
            <div class="timeline-body"><p>Not totally sure what to do with these non-<code>Class</code> bases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 03:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 03:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:27 on 2024-11-06 03:46</div>
            <div class="timeline-body"><p>(I don't feel confident about my understanding and usage of <code>ClassLiteralType</code> vs. <code>Class</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1989 on 2024-11-06 06:13</div>
            <div class="timeline-body"><p>We should add a note similar to the <code>Type::node</code> function that this function should only ever be called from queries that belong to the same file as the class.
We otherwise end up introducing cross-file query-dependencies where some queries need to re-run when the AST of another file changes -&gt; bad for incremental performance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-11-06 06:29</div>
            <div class="timeline-body"><p>Looks like there are test failures here, and the error output assertions in the benchmark need to be updated. (I haven't looked closely at the discrepancy; it may just be that we need to update the assertion, or it may highlight an issue with the PR that should be fixed.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2012 on 2024-11-06 06:57</div>
            <div class="timeline-body"><p>Nit: I suggest moving the shared logic for finding the keyword out of the if branch</p>
<pre><code>let metaclass_value = class_stmt
      .keywords()
      .iter()
      .find(|keyword| keyword.arg.as_ref().is_some_and(|arg| arg == &quot;metaclass&quot;))
      .map(|keyword| &amp;keyword.value);

metaclass_value.map(|base_node| {
	if class_stmt.type_params.is_some() {
		...
	} else {
		...
	}
})
</code></pre>
<p>It makes it more apparent what the difference between the two branches is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1988 on 2024-11-06 06:59</div>
            <div class="timeline-body"><p>Nit: Move next to the <code>metaclass</code> method or next to <code>explicit_base_query</code>. The way it's ordered now requires a lot of jumping around to read the code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2059 on 2024-11-06 07:03</div>
            <div class="timeline-body"><p>We should make this a salsa query because what I understand is that this function can also be called cross module (e.g. resolve a base class from another file and we then lookup it's base).</p>
<p>See https://github.com/astral-sh/ruff/pull/14087 for a more in depth explanation.</p>
<pre><code class="language-suggestion">    #[salsa::tracked]
    pub(crate) fn metaclass(self, db: &amp;'db dyn Db) -&gt; Result&lt;Type&lt;'db&gt;, MetaclassError&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2024-11-06 07:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 12:11</div>
            <div class="timeline-body"><pre><code class="language-python">class NotSubscriptable: ...

a = NotSubscriptable[0]  # error: &quot;Cannot subscript object of type `Literal[NotSubscriptable]` with no `__class_getitem__` method&quot;
</code></pre>
<p>We no longer throw this error -- I think because we resolve the metaclass to <code>type</code>, which allows subscripting (?). That seems wrong to me but I must be misunderstanding something about the semantics.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2024-11-06 12:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 12:14</div>
            <div class="timeline-body"><p>I think the remaining failures represent a misunderstanding or lack of nuance in how we handle metaclass lookups / <code>__class_getitem__</code> so would appreciate reviews on that component.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-11-06 12:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2055 on 2024-11-06 12:16</div>
            <div class="timeline-body"><p>Calling this function from other files is fine, because you now added the <code>#[salsa::tracked</code>] which &quot;isolates&quot; the dependencies (dependent queries only re-run when the returned <code>Result</code> is different from previous run)</p>
<pre><code class="language-suggestion"></code></pre>
<p>But this comment should be added to <code>explicit_metaclass</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @MichaReiser on 2024-11-06 12:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 13:30</div>
            <div class="timeline-body"><p>Gonna do a bit more research into how subscripts interact with this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @charliermarsh on 2024-11-06 13:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 13:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:27 on 2024-11-06 13:37</div>
            <div class="timeline-body"><p>This should be <code>Literal[A]</code>!</p>
<p>You're confusing three things here, I think. Remember that every type is a set of possible runtime values.</p>
<ul>
<li>All <code>ClassLiteralType</code>s are sets of size 1. The sole member of the set described by <code>Literal[A]</code> (which is a class-literal type) is the class object <code>A</code> itself.</li>
<li><code>InstanceType</code>s are sets of (usually) unknown size. The set described by the type <code>A</code> (which is an instance type) is the set of &quot;all possible instances of <code>A</code> that could ever exist&quot;. Note that this is a disjoint set from the set described by <code>Literal[A]</code>: the class object <code>A</code> is not an instance of <code>A</code>.</li>
<li>We have a struct named <code>Class</code> that is used as the inner data for both <code>InstanceType</code> and <code>ClassLiteralType</code>. But this struct doesn't represent a type at all; it's just a &quot;bag of data&quot; that you can query about a specific class definition at runtime.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 13:49</div>
            <div class="timeline-body"><p>Okay, the subscript failures were all related to a misunderstanding of literal vs. instance for class types. Fixed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 13:50</div>
            <div class="timeline-body"><p>But I still have one failure in the MRO tests due to a cycle somewhere.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-06 13:55</div>
            <div class="timeline-body"><p>Ok I'm not handling cycles in metaclasses. Will debug.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-11-06 14:05</div>
            <div class="timeline-body"><blockquote>
<p>Ok I'm not handling cycles in metaclasses. Will debug.</p>
</blockquote>
<p>You'll probably have to use something like the <code>is_class_cyclically_defined</code> function we currently have in <code>mro.rs</code>. Feel free to move it to another file if you need to!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-11-06 14:26</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @charliermarsh on 2024-11-06 14:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/mro.md</code>:14 on 2024-11-06 14:47</div>
            <div class="timeline-body"><p>Why are you deleting all these MRO tests?!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1286 on 2024-11-06 14:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                // TODO: `type[Unknown]` would be a more precise fallback
                // (needs support for &lt;https://docs.python.org/3/library/typing.html#the-type-of-class-objects&gt;)
                class.metaclass(db).unwrap_or(Type::Unknown)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-11-06 14:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/mro.md</code>:1 on 2024-11-06 14:53</div>
            <div class="timeline-body"><p>Is it intentional, that you remove all these tests?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2043 on 2024-11-06 14:54</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            .arguments
            .find_keyword(&quot;metaclass&quot;)
</code></pre>
<p>Or maybe we should add a <code>find_keyword</code> method (or just a <code>metaclass</code> method) directly to <code>ruff_python_ast::StmtClassDef</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2185 on 2024-11-06 14:54</div>
            <div class="timeline-body"><p>Watcher seems misleading, IMO. I think of something like a file watcher. <code>SeenSet</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2188 on 2024-11-06 14:55</div>
            <div class="timeline-body"><p>What's the reason for storing <code>initial</code> explicitly over just putting it into the set?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2054 on 2024-11-06 14:56</div>
            <div class="timeline-body"><p>Huh, this looks correct! I guess it makes sense, but I guess I never thought about whether the metaclass argument would be executed in the type-parameters scope. TIL:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; class Foo[T](metaclass=T): pass
... 
Traceback (most recent call last):
  File &quot;&lt;python-input-5&gt;&quot;, line 1, in &lt;module&gt;
    class Foo[T](metaclass=T): pass
  File &quot;&lt;python-input-5&gt;&quot;, line 1, in &lt;generic parameters of Foo&gt;
    class Foo[T](metaclass=T): pass
TypeError: 'typing.TypeVar' object is not callable
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-11-06 14:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2190 on 2024-11-06 14:57</div>
            <div class="timeline-body"><p>Nice!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2098 on 2024-11-06 14:58</div>
            <div class="timeline-body"><p>Is there a reference in the language spec we could also link to somewhere? Maybe in the data model?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2149 on 2024-11-06 14:59</div>
            <div class="timeline-body"><p>The fact that we have to do this in multiple places makes me think that maybe we should have a <code>try_metaclass</code> method (that returns a <code>Result</code>) and a <code>metaclass</code> method (that has a fallback metaclass type), similar to the way we have a <code>try_mro</code> method and an <code>mro</code> method. That way if we change the fallback in the future (which I think is quite likely -- see my comment above), we'll only have to change it in one place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 15:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 15:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2188 on 2024-11-06 15:13</div>
            <div class="timeline-body"><p>We don't have to allocate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 15:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/mro.md</code>:14 on 2024-11-06 15:14</div>
            <div class="timeline-body"><p>Sorry, this is my backlash against not having a way to run a single test lol. Fixed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2149 on 2024-11-06 15:15</div>
            <div class="timeline-body"><p>I'm not really convinced of the ergonomics of that -- I don't think we should hide the need to handle errors from callers -- but I'm fine to do it for consistency.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2054 on 2024-11-06 15:15</div>
            <div class="timeline-body"><p>I took this from <code>explicit_bases</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2052 on 2024-11-06 15:26</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let metaclass_node = &amp;class_stmt
            .arguments
            .as_ref()?
            .find_keyword(&quot;metaclass&quot;)?
            .value;
        if class_stmt.type_params.is_some() {
            // when we have a specialized scope, we'll look up the inference
            // within that scope
            let model = SemanticModel::new(db, self.file(db));
            metaclass_node.ty(&amp;model)
        } else {
            // Otherwise, we can do the lookup based on the definition scope
            let class_definition = semantic_index(db, self.file(db)).definition(class_stmt);
            definition_expression_ty(db, class_definition, metaclass_node)
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 15:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:12 on 2024-11-06 17:37</div>
            <div class="timeline-body"><p>nit: in general, for tests intending to test the &quot;happy path&quot; of a metaclass, I'd prefer we use something that actually can work as a metaclass. Otherwise, in the future if/when we introduce a diagnostic for bad metaclasses, all these tests will need updating.</p>
<pre><code class="language-suggestion">class A(type): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:41 on 2024-11-06 17:43</div>
            <div class="timeline-body"><p>It looks like this test differs from the below test only in that <code>A</code> here is not a valid metaclass. I think it's good to have a test for an invalid metaclass, but</p>
<ol>
<li>Only the below test should be named &quot;Linear inheritance&quot;, this test should have a name that clarifies its purpose is to test an invalid metaclass, like &quot;Invalid metaclass&quot;</li>
<li>The &quot;invalid metaclass&quot; test probably doesn't need the double layer of B and C, it could just have B; unless we are aware of some particular issue with inherited bad metaclasses that we need to test for.</li>
<li>The &quot;invalid metaclass&quot; test should have a TODO comment that we should emit a diagnostic for the invalid metaclass, even though we don't yet today.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:52 on 2024-11-06 17:44</div>
            <div class="timeline-body"><pre><code class="language-suggestion">class A(type): ...
class B(metaclass=A): ...
class C(type): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:55 on 2024-11-06 17:48</div>
            <div class="timeline-body"><p>Nit: &quot;compatible&quot; is kind of a hand-wavy word, it's not clear what precisely it means. I would rather say &quot;<code>Literal[C]</code> and <code>Literal[A]</code> have no subclass relationship&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:80 on 2024-11-06 17:53</div>
            <div class="timeline-body"><pre><code class="language-suggestion">class A(type): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:91 on 2024-11-06 17:53</div>
            <div class="timeline-body"><pre><code class="language-suggestion">class A(type): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:117 on 2024-11-06 17:59</div>
            <div class="timeline-body"><p>This test is kinda odd, I'm not sure it should make any difference to <code>D</code> or <code>E</code> here that their metaclass <code>C</code> itself has a custom metaclass. But it doesn't hurt to include, and maybe it does verify something important about the implementation (I haven't dug into the implementation yet.) But like the above cases, let's make the test actually valid:</p>
<pre><code class="language-suggestion">class A(type): ...
class B(type, metaclass=A): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 18:01</div>
            <div class="timeline-body"><pre><code class="language-suggestion">## Inheritance (4)

```py
class A(type): ...
class B(type, metaclass=A): ...
class C(metaclass=B): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:153 on 2024-11-06 18:02</div>
            <div class="timeline-body"><p>So we have two tests here for this kind of odd metaclass-with-a-metaclass scenario, whose value isn't entirely clear to me (the fact that a metaclass itself has a metaclass doesn't change anything about its compatibility with other metaclasses, and both of these tests are just simple linear inheritance, so no multiple base metaclasses to reconcile).</p>
<p>But it seems to me that we are missing tests for the scenarios that we are more likely to get wrong in the implementation where we have multiple different inherited metaclasses that <em>do</em> have a subclass relationship and are thus compatible, and we should pick the child one. For instance a test for a case like this:</p>
<pre><code class="language-py">class M(type): ...
class N(M): ...
class A(metaclass=M): ...
class B(metaclass=N): ...
class C(A, B): ...

reveal_type(C.__class__)  # revealed: Literal[N]
</code></pre>
<p>Or even a really complex case like this with diamond-inherited metaclasses, which actually should error:</p>
<pre><code class="language-py">class M(type): ...
class M1(M): ...
class M2(M): ...
class M12(M1, M2): ...

class A(metaclass=M1): ...
class B(metaclass=M2): ...
class C(metaclass=M12): ...
class D(A, B, C): ...

# error: [conflicting-metaclass] &quot;A and B have no subclass relationship&quot;
reveal_type(D.__class__)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2047 on 2024-11-06 18:12</div>
            <div class="timeline-body"><p>Add a test for a PEP 695 generic class with a metaclass? (No need to use the type param or test anything specific to generics, just to verify that we still resolve the right type for its metaclass.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2070 on 2024-11-06 18:15</div>
            <div class="timeline-body"><p>Do we have tests exercising getting the metaclass of a cyclically-defined class?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2091 on 2024-11-06 18:25</div>
            <div class="timeline-body"><p>I think we should add a test where one of the bases is <code>Unknown</code>, but I think the current behavior here is already mostly correct; we should (mostly) effectively ignore that base when it comes to metaclass calculation. If there are other bases, we should assume the metaclass of the unknown base is compatible with anything, and if the only base is <code>Unknown</code>, we should assume its metaclass is <code>type</code>.</p>
<p>The reason I say &quot;mostly&quot;  above is that technically if we have at least one Unknown (or Any or Todo) base, then the returned metaclass should be a <code>type[]</code> type (instead of a class literal type), and should be intersected with <code>Any</code> or <code>Unknown</code> or <code>Todo</code>. So:</p>
<pre><code>from nonexistent_module import UnknownClass  # error: [unresolved-import]

class C(UnknownClass): ...
reveal_type(C.__class__)  # revealed: type[type] &amp; Unknown

class M(type): ...
class A(metaclass=M): ...
class B(A, UnknownClass): ...

reveal_type(B.__class__)  # revealed: type[M] | Unknown
</code></pre>
<p>This is a bit subtle, but the reason for the intersection with Unknown in these cases is that the unknown base <em>might</em> have a metaclass that is a subclass of <code>type</code> (in the first case) or <code>M</code> (in the second case). We reflect this possibility by intersecting with Unknown. <code>T &amp; Unknown</code> effectively means &quot;this type may be something narrower than T, but it can't be anything not in T&quot;.</p>
<p>It may seem like <code>type[M] &amp; Unknown</code> is no different from <code>type[M]</code>, because <code>type[M]</code> is already a type that includes all subclasses of M! But the difference is that <code>Unknown/Any</code> are forgiving; they always assume the most compatible type. If you ask whether <code>type[M]</code> is a subclass of <code>type[N]</code>, the answer may be &quot;no&quot; -- if you ask whether <code>type[M] &amp; Unknown</code> is a subclass of <code>type[N]</code>, the answer is always yes.</p>
<p>But all that said, this requires a <code>type[]</code> type, which we don't have yet, and it's not high priority, so I think we should just TODO it for this PR. I'd still want to add the above tests, but the test would reveal e.g. <code>Literal[M]</code>, with a TODO comment right above the <code>revealed: </code> line that it should be <code>type[M] &amp; Unknown</code> instead.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2105 on 2024-11-06 18:27</div>
            <div class="timeline-body"><p>I think this is the right thing to do; it matches what happens at runtime. It would be good to have a test for this behavior, too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2117 on 2024-11-06 18:28</div>
            <div class="timeline-body"><p>This is a fair amount of code to duplicate; wrap it up in a closure?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:69 on 2024-11-06 18:31</div>
            <div class="timeline-body"><pre><code class="language-suggestion">class A(type): ...
class B(metaclass=A): ...
class C(type): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:25 on 2024-11-06 18:47</div>
            <div class="timeline-body"><p>This will fail at runtime, and at some point in the future we'll want to start emitting diagnostics about that. To future-proof the test, I'd either change the example to one that will not fail at runtime (that seems to make more sense here?):</p>
<pre><code class="language-suggestion">class A(type): ...
class B(metaclass=A): ...
</code></pre>
<p>or add a TODO comment to say that we should emit a diagnostic about it at some point:</p>
<pre><code class="language-suggestion">class A: ...
# TODO: will fail at runtime, should emit a diagnostic here
class B(metaclass=A): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:55 on 2024-11-06 18:51</div>
            <div class="timeline-body"><p>nit: it's not immediately clear to me here what &quot;compatible&quot; means. Maybe something like this?</p>
<pre><code class="language-suggestion"># error: [conflicting-metaclass] &quot;The metaclass of a derived class (`E`) must be a subclass of the metaclasses of all its bases, but `C` is not a subclass of `A` and `A` is not a subclass of `C`
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:548 on 2024-11-06 18:52</div>
            <div class="timeline-body"><p>I don't think we need this TODO? I don't think we ever have plans to de-duplicate diagnostics in a way that would de-deduplicate two diagnostics that we explicitly raise separately. And I think a cyclic class definition is a cyclic class definition; I don't think there are cases where the MRO cycle detection would fail to detect a cycle but we'd detect it here.</p>
<pre><code class="language-suggestion">                    // Cyclic class definition diagnostic will already have been emitted above in MRO calculation.
</code></pre>
<p>An interesting question here: if this is true, do we really need cycle detection implemented separately in both MRO and metaclass calculation? It seems inefficient, both in code to maintain and at runtime. Could we instead hoist the &quot;is cyclically defined&quot; check (which is already done as a totally separate function in MRO calculation) out into this function, and if a class is cyclically defined, we emit a diagnostic and just <code>specify</code> (this is a Salsa feature) the result of its MRO and metaclass queries as Unknown, and never try to calculate them. Then the MRO and metaclass calculation code could both take non-cyclic as an assumed invariant.</p>
<p>This might be a big enough change to do as a separate PR, but it seems worth doing to me, unless I'm missing something. Curious what @AlexWaygood and @MichaReiser think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:58 on 2024-11-06 18:52</div>
            <div class="timeline-body"><p>I know the runtime error message uses the term &quot;non-strict&quot;, but do we know what it means by that? Can we link to a definition somewhere?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1232 on 2024-11-06 18:53</div>
            <div class="timeline-body"><p>Weird, why isn't rustfmt formatting deterministic here and below?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-11-06 18:54</div>
            <div class="timeline-body"><p>Looks great, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2083 on 2024-11-06 18:55</div>
            <div class="timeline-body"><p>Could rename this variable to <code>num_seen</code> now that the <code>watcher</code> variable was renamed to <code>seen</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 18:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2149 on 2024-11-06 18:57</div>
            <div class="timeline-body"><p>The thing is that in this case, there's really nothing a caller can or should do about the error -- we've already emitted a diagnostic for it in <code>check_class_definitions</code>, and once we've done that, the error <em>shouldn't</em> be explicitly handled by any other caller, it would just result in duplicate or cascading diagnostics in some form. So it's more <em>correct</em>, not just more ergonomic, to provide most callers with an API that just tells them the type of the metaclass is <code>Unknown</code>.</p>
<p>This is a pattern that occurs a lot in red-knot. There's an error condition -- it's somebody's responsibility to handle that error condition and emit a diagnostic. But once that's been done, the correct thing to do is flatten the error condition into a simple <code>Unknown</code> type so the rest of the world doesn't have to care about it or try to re-handle it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:1 on 2024-11-06 18:58</div>
            <div class="timeline-body"><p>I think your logic should handle them correctly, but I'd love it if you added explicit tests for two edge cases at the root of Python's class hierarchy: <code>builtins.object</code> and <code>builtins.type</code>. <code>reveal_type(object.__class__)</code> and <code>reveal_type(type.__class__)</code> should both be <code>Literal[type]</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 19:03</div>
            <div class="timeline-body"><p>This is really great, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 19:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:58 on 2024-11-06 19:07</div>
            <div class="timeline-body"><p>&quot;Strict subclass&quot; is a synonym for &quot;proper subclass&quot; -- that is, not including yourself. So &quot;non-strict&quot; is just clarifying that &quot;subclass&quot; here is also ok with &quot;same type&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 19:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:58 on 2024-11-06 19:12</div>
            <div class="timeline-body"><p>I think adding a sentence to the prose description of the test (or even just a footnote) explaining that might be helpful</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:530 on 2024-11-06 19:24</div>
            <div class="timeline-body"><p>This means we're now iterating over all class definitions twice, when I think we can make do with a single loop. Something like this?</p>
<details>

<pre><code class="language-rs">    fn check_class_definitions(&amp;mut self) {
        let class_definitions = self
            .types
            .declarations
            .values()
            .filter_map(|ty| ty.into_class_literal())
            .map(|class_ty| class_ty.class);

        for class in class_definitions {
            if let Err(mro_error) = class.try_mro(self.db).as_ref() {
                match mro_error.reason() {
                    MroErrorKind::DuplicateBases(duplicates) =&gt; {
                        let base_nodes = class.node(self.db).bases();
                        for (index, duplicate) in duplicates {
                            self.diagnostics.add(
                                (&amp;base_nodes[*index]).into(),
                                &quot;duplicate-base&quot;,
                                format_args!(&quot;Duplicate base class `{}`&quot;, duplicate.name(self.db)),
                            );
                        }
                    }
                    MroErrorKind::CyclicClassDefinition =&gt; self.diagnostics.add(
                        class.node(self.db).into(),
                        &quot;cyclic-class-def&quot;,
                        format_args!(
                            &quot;Cyclic definition of `{}` or bases of `{}` (class cannot inherit from itself)&quot;,
                            class.name(self.db),
                            class.name(self.db)
                        ),
                    ),
                    MroErrorKind::InvalidBases(bases) =&gt; {
                        let base_nodes = class.node(self.db).bases();
                        for (index, base_ty) in bases {
                            self.diagnostics.add(
                                (&amp;base_nodes[*index]).into(),
                                &quot;invalid-base&quot;,
                                format_args!(
                                    &quot;Invalid class base with type `{}` (all bases must be a class, `Any`, `Unknown` or `Todo`)&quot;,
                                    base_ty.display(self.db)
                                ),
                            );
                        }
                    }
                    MroErrorKind::UnresolvableMro { bases_list } =&gt; self.diagnostics.add(
                        class.node(self.db).into(),
                        &quot;inconsistent-mro&quot;,
                        format_args!(
                            &quot;Cannot create a consistent method resolution order (MRO) for class `{}` with bases list `[{}]`&quot;,
                            class.name(self.db),
                            bases_list.iter().map(|base| base.display(self.db)).join(&quot;, &quot;)
                        ),
                    )
                }
            }

            if let Err(metaclass_error) = class.try_metaclass(self.db) {
                match metaclass_error.reason() {
                    MetaclassErrorKind::Conflict {
                        metaclass1,
                        metaclass2
                    } =&gt; self.diagnostics.add(
                        class.node(self.db).into(),
                        &quot;conflicting-metaclass&quot;,
                        format_args!(
                            &quot;The metaclass of a derived class (`{}`) must be a subclass of the metaclasses of all its bases, but `{}` and `{}` are not compatible&quot;,
                            class.name(self.db),
                            Type::ClassLiteral(*metaclass1).display(self.db),
                            Type::ClassLiteral(*metaclass2).display(self.db),
                        ),
                    ),
                    MetaclassErrorKind::CyclicDefinition =&gt; {
                        // TODO(charlie): When diagnostics are deduplicated, add a `cyclic-class-def`
                        // diagnostic, equivalent to the above.
                    }
                }
            }
        }
    }
</code></pre>
</details>

<p>The doc-comment for the function should also be updated: we do more than just check MROs in this method now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 19:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 19:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:548 on 2024-11-06 19:31</div>
            <div class="timeline-body"><p>It's definitely an interesting question where cycle detection should go. In an earlier version of my MRO PR, I had cycle-detection as a separate Salsa query, which was called by the MRO-resolution logic but was not itself part of the MRO resolution logic (my PR did this until https://github.com/astral-sh/ruff/pull/14027/commits/e1f1874e9f195c2953f155762668f362f14145aa, which changed it to the current implementation of cycle detection in MROs).</p>
<p>I'd vote for leaving it as @charliermarsh has it for now, though, and investigating whether we can consolidate/optimise the cycle-detection logic as a followup.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 19:41</div>
            <div class="timeline-body"><p>Why no <code>type</code> on <code>C</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 19:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 19:42</div>
            <div class="timeline-body"><p>Or, separately, why a <code>type</code> on <code>B</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 19:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1232 on 2024-11-06 19:43</div>
            <div class="timeline-body"><p>(It's because it's within a macro, I think.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 19:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 19:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1232 on 2024-11-06 19:44</div>
            <div class="timeline-body"><p>(Oh sorry -- not sure about below, but here yeah.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:41 on 2024-11-06 19:50</div>
            <div class="timeline-body"><p>Thanks, just a mental error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 19:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 19:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:153 on 2024-11-06 19:55</div>
            <div class="timeline-body"><p>Thanks, these are great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 20:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:68 on 2024-11-06 20:06</div>
            <div class="timeline-body"><p>I think I would prefer for this error message to be</p>
<pre><code class="language-suggestion"># error: [conflicting-metaclass] &quot;The metaclass of a derived class (`E`) must be a subclass of the metaclasses of all its bases, but `C` and `A` have no subclass relationship&quot;
</code></pre>
<p>since the error is about a lack of a subclass relationship between classes rather than a subtype relationship between types. (<code>Literal[A]</code> is how we would describe the class-literal type with only the class object <code>A</code> in it, but <code>A</code> is how we would describe the class object <code>A</code>.) You could get there with this diff:</p>
<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -2123,8 +2123,8 @@ impl&lt;'db&gt; Class&lt;'db&gt; {
                 }
                 return Err(MetaclassError {
                     kind: MetaclassErrorKind::Conflict {
-                        metaclass1: candidate,
-                        metaclass2: metaclass,
+                        metaclass1: candidate.class,
+                        metaclass2: metaclass.class,
                     },
                 });
             }
@@ -2294,8 +2294,8 @@ pub(super) enum MetaclassErrorKind&lt;'db&gt; {
     /// The metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all
     /// its bases.
     Conflict {
-        metaclass1: ClassLiteralType&lt;'db&gt;,
-        metaclass2: ClassLiteralType&lt;'db&gt;,
+        metaclass1: Class&lt;'db&gt;,
+        metaclass2: Class&lt;'db&gt;,
     },
     /// The class inherits from itself!
     ///
diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index 0c0991ec4..5287df8d8 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -540,8 +540,8 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
                     format_args!(
                         &quot;The metaclass of a derived class (`{}`) must be a subclass of the metaclasses of all its bases, but `{}` and `{}` have no subclass relationship&quot;,
                         class.name(self.db),
-                        Type::ClassLiteral(*metaclass1).display(self.db),
-                        Type::ClassLiteral(*metaclass2).display(self.db),
+                        metaclass1.name(self.db),
+                        metaclass2.name(self.db),
                     ),
                 ),
                 MetaclassErrorKind::CyclicDefinition =&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-06 20:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2105 on 2024-11-06 20:15</div>
            <div class="timeline-body"><p>I'm not sure I agree with this. If a non-<code>type</code>-subclass is used as the metaclass, I think it's more likely than not that <code>__class__</code> will be something completely different to the object passed as the <code>metaclass=</code> keyword:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; class Foo(metaclass=lambda *args: 42): ...
... 
&gt;&gt;&gt; Foo
42
&gt;&gt;&gt; Foo.__class__
&lt;class 'int'&gt;
</code></pre>
<p>I think with the current logic we'd infer <code>Foo.__class__</code> here as being <code>&lt;lambda function&gt;</code> or something? But that's just incorrect.</p>
<p>Even if the metaclass is something that returns a class (I think the more common case, really!), it's almost certainly going to be a callable object, and the <code>__class__</code> of the created class is not going to be the same as the callable object itself.</p>
<p>I think honestly we don't have a clue what's going on if a non-<code>type</code>-subclass is passed as the <code>metaclass=</code> keyword, so emitting a diagnostic and inferring <code>Unknown</code> as the value of <code>__class__</code> might be better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 20:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 20:16</div>
            <div class="timeline-body"><p><code>B</code> needs to inherit <code>type</code> (or define a custom <code>__new__</code> taking a bunch of arguments) because it is the metaclass for <code>C</code>. Otherwise it isn't a valid metaclass and will fail immediately at runtime when the class creation machinery tries to call it with a bunch of arguments at the <code>class C</code> statement and fails.</p>
<p><code>C</code> doesn't need to inherit <code>type</code> because it is never used as a metaclass in this test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-11-06 20:17</div>
            <div class="timeline-body"><p>I have a couple of nits outstanding (I left comments), but nothing serious or blocking. This is great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 20:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 20:18</div>
            <div class="timeline-body"><p>I think perhaps some of these tests would be clearer in what they are testing if the naming scheme for classes distinguished between &quot;metaclasses, which inherit <code>type</code>&quot; vs &quot;regular classes, which don't&quot;. Like in some of my examples I used <code>M, N, ...</code> for metaclasses and <code>A, B, ...</code> for regular classes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:142 on 2024-11-06 20:26</div>
            <div class="timeline-body"><p>@carljm -- In your example, this was <code># revealed: type[type] &amp; Unknown</code> -- am I missing an <code>Unknown</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 20:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 20:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 20:28</div>
            <div class="timeline-body"><p>I see, thanks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2024-11-06 20:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:128 on 2024-11-06 20:33</div>
            <div class="timeline-body"><p>(Re-did all tests to match.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 20:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/metaclass.md</code>:142 on 2024-11-06 20:40</div>
            <div class="timeline-body"><p>Yes, but I think you should just add a TODO for it, since you also need the <code>type[]</code> type, which hasn't landed yet (and the distinction here may not matter much practically, so we can defer the TODO until/unless we find a case where it does matter)</p>
<pre><code class="language-suggestion"># TODO should technically be `type[type] &amp; Unknown`
reveal_type(C.__class__)  # revealed: Literal[type]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2024-11-06 20:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2024-11-06 20:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-11-06 20:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 20:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2105 on 2024-11-06 20:43</div>
            <div class="timeline-body"><p>Oh! Great point.</p>
<p>I think this is something we should address in the future once we have call signature checking, and what we should do here is a) verify that the metaclass is something callable which accepts the type-new arguments (otherwise emit a diagnostic), and then b) return the return type of that callable.</p>
<p>For now returning <code>Type::Todo</code> with a todo comment to that effect is probably best.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:548 on 2024-11-06 21:33</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/issues/14141</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-06 21:33</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:07:30 UTC
    </footer>
</body>
</html>
