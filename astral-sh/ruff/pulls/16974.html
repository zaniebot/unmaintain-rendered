<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] support narrowing on constants in matches - astral-sh/ruff #16974</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] support narrowing on constants in matches</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16974">#16974</a>
        opened by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a>
        on 2025-03-26 04:35
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on 2025-03-26 04:35</div>
            <div class="timeline-body"><!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<p>Part of #13694</p>
<p>The implementation here was suspiciously straightforward so please lmk if I missed something</p>
<p>Also some drive-by changes to DRY things up a bit</p>
<!-- What's the purpose of the change? What does it do, and why? -->

<h2>Test Plan</h2>
<!-- How was it tested? -->

<p>Add new tests to narrow/match.md</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @ericmarkmartin on 2025-03-26 04:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @ericmarkmartin on 2025-03-26 04:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @ericmarkmartin on 2025-03-26 04:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @ericmarkmartin on 2025-03-26 04:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-26 04:41</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-03-26 11:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:485 on 2025-03-26 17:21</div>
            <div class="timeline-body"><p>this is nice, though it's a shame that we can't use it in the <code>evaluate_expr_name</code> method and in a few other methods. Maybe we should do something like this instead?</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types/narrow.rs b/crates/red_knot_python_semantic/src/types/narrow.rs
index 00c270eba..fe7eddd0b 100644
--- a/crates/red_knot_python_semantic/src/types/narrow.rs
+++ b/crates/red_knot_python_semantic/src/types/narrow.rs
@@ -263,11 +263,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
         is_positive: bool,
     ) -&gt; NarrowingConstraints&lt;'db&gt; {
         let ast::ExprName { id, .. } = expr_name;
-
-        let symbol = self
-            .symbols()
-            .symbol_id_by_name(id)
-            .expect(&quot;Should always have a symbol for every Name node&quot;);
+        let symbol = self.expect_expr_name_symbol(id);
         let mut constraints = NarrowingConstraints::default();
 
         constraints.insert(
@@ -338,10 +334,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
                     id,
                     ctx: _,
                 }) =&gt; {
-                    let symbol = self
-                        .symbols()
-                        .symbol_id_by_name(id)
-                        .expect(&quot;Should always have a symbol for every Name node&quot;);
+                    let symbol = self.expect_expr_name_symbol(id);
 
                     match if is_positive { *op } else { op.negate() } {
                         ast::CmpOp::IsNot =&gt; {
@@ -408,10 +401,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
                         .into_class_literal()
                         .is_some_and(|c| c.class().is_known(self.db, KnownClass::Type))
                     {
-                        let symbol = self
-                            .symbols()
-                            .symbol_id_by_name(id)
-                            .expect(&quot;Should always have a symbol for every Name node&quot;);
+                        let symbol = self.expect_expr_name_symbol(id);
                         constraints.insert(symbol, Type::instance(rhs_class));
                     }
                 }
@@ -474,14 +464,11 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
         }
     }
 
-    fn get_subject_symbol(&amp;self, subject: Expression&lt;'db&gt;) -&gt; Option&lt;ScopedSymbolId&gt; {
-        let ast::ExprName { id, .. } = subject.node_ref(self.db).as_name_expr()?;
-        let symbol = self
-            .symbols()
-            .symbol_id_by_name(id)
-            .expect(&quot;We should always have a symbol for every `Name` node&quot;);
-
-        Some(symbol)
+    #[track_caller]
+    fn expect_expr_name_symbol(&amp;self, symbol: &amp;str) -&gt; ScopedSymbolId {
+        self.symbols()
+            .symbol_id_by_name(symbol)
+            .expect(&quot;We should always have a symbol for every `Name` node&quot;)
     }
 
     fn evaluate_match_pattern_singleton(
@@ -489,7 +476,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
         subject: Expression&lt;'db&gt;,
         singleton: ast::Singleton,
     ) -&gt; Option&lt;NarrowingConstraints&lt;'db&gt;&gt; {
-        let symbol = self.get_subject_symbol(subject)?;
+        let symbol = self.expect_expr_name_symbol(&amp;subject.node_ref(self.db).as_name_expr()?.id);
 
         let ty = match singleton {
             ast::Singleton::None =&gt; Type::none(self.db),
@@ -506,7 +493,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
         subject: Expression&lt;'db&gt;,
         cls: Expression&lt;'db&gt;,
     ) -&gt; Option&lt;NarrowingConstraints&lt;'db&gt;&gt; {
-        let symbol = self.get_subject_symbol(subject)?;
+        let symbol = self.expect_expr_name_symbol(&amp;subject.node_ref(self.db).as_name_expr()?.id);
         let ty = infer_same_file_expression_type(self.db, cls).to_instance(self.db)?;
 
         let mut constraints = NarrowingConstraints::default();
@@ -519,7 +506,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
         subject: Expression&lt;'db&gt;,
         value: Expression&lt;'db&gt;,
     ) -&gt; Option&lt;NarrowingConstraints&lt;'db&gt;&gt; {
-        let symbol = self.get_subject_symbol(subject)?;
+        let symbol = self.expect_expr_name_symbol(&amp;subject.node_ref(self.db).as_name_expr()?.id);
         let ty = infer_same_file_expression_type(self.db, value);
         let mut constraints = NarrowingConstraints::default();
         constraints.insert(symbol, ty);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:527 on 2025-03-26 17:26</div>
            <div class="timeline-body"><p>it looks to me like we could probably simplify this pattern throughout this file:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types/narrow.rs b/crates/red_knot_python_semantic/src/types/narrow.rs
index 00c270eba..f20974cb9 100644
--- a/crates/red_knot_python_semantic/src/types/narrow.rs
+++ b/crates/red_knot_python_semantic/src/types/narrow.rs
@@ -268,18 +268,15 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
             .symbols()
             .symbol_id_by_name(id)
             .expect(&quot;Should always have a symbol for every Name node&quot;);
-        let mut constraints = NarrowingConstraints::default();
 
-        constraints.insert(
+        NarrowingConstraints::from_iter([(
             symbol,
             if is_positive {
                 Type::AlwaysFalsy.negate(self.db)
             } else {
                 Type::AlwaysTruthy.negate(self.db)
             },
-        );
-
-        constraints
+        )])
     }
 
     fn evaluate_expr_compare(
@@ -453,9 +450,10 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
                 function
                     .generate_constraint(self.db, class_info_ty)
                     .map(|constraint| {
-                        let mut constraints = NarrowingConstraints::default();
-                        constraints.insert(symbol, constraint.negate_if(self.db, !is_positive));
-                        constraints
+                        NarrowingConstraints::from_iter([(
+                            symbol,
+                            constraint.negate_if(self.db, !is_positive),
+                        )])
                     })
             }
             // for the expression `bool(E)`, we further narrow the type based on `E`
@@ -496,9 +494,8 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
             ast::Singleton::True =&gt; Type::BooleanLiteral(true),
             ast::Singleton::False =&gt; Type::BooleanLiteral(false),
         };
-        let mut constraints = NarrowingConstraints::default();
-        constraints.insert(symbol, ty);
-        Some(constraints)
+
+        Some(NarrowingConstraints::from_iter([(symbol, ty)]))
     }
 
     fn evaluate_match_pattern_class(
@@ -509,9 +506,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
         let symbol = self.get_subject_symbol(subject)?;
         let ty = infer_same_file_expression_type(self.db, cls).to_instance(self.db)?;
 
-        let mut constraints = NarrowingConstraints::default();
-        constraints.insert(symbol, ty);
-        Some(constraints)
+        Some(NarrowingConstraints::from_iter([(symbol, ty)]))
     }
 
     fn evaluate_match_pattern_value(
@@ -521,10 +516,7 @@ impl&lt;'db&gt; NarrowingConstraintsBuilder&lt;'db&gt; {
     ) -&gt; Option&lt;NarrowingConstraints&lt;'db&gt;&gt; {
         let symbol = self.get_subject_symbol(subject)?;
         let ty = infer_same_file_expression_type(self.db, value);
-        let mut constraints = NarrowingConstraints::default();
-        constraints.insert(symbol, ty);
-
-        Some(constraints)
+        Some(NarrowingConstraints::from_iter([(symbol, ty)]))
     }
</code></pre>
<p>could possibly be done in this PR, or as a followup if you're interested!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-03-26 17:33</div>
            <div class="timeline-body"><p>Nice, this looks great. A couple of minor comments:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/match.md</code>:86 on 2025-03-28 02:30</div>
            <div class="timeline-body"><p>nit: I'd suggest for clarity we use a pure complex (i.e. imaginary) literal here. I spent a while wondering why we get <code>int  | float | complex</code> here, and it took me a while to realize that it's because <code>1+1j</code> is not really a literal, its a binop Add with int and complex operands.</p>
<pre><code class="language-suggestion">    case 1j:
        reveal_type(x)  # revealed: complex
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/match.md</code>:110 on 2025-03-28 02:30</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    case 1j if reveal_type(x):  # revealed: complex
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-03-28 02:32</div>
            <div class="timeline-body"><p>Very nice, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-03-28 02:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-03-28 02:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-28 04:53</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:41:05 UTC
    </footer>
</body>
</html>
