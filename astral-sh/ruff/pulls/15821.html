<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`flake8-pyi`] Fix more complex cases (`PYI019`) - astral-sh/ruff #15821</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>flake8-pyi</code>] Fix more complex cases (<code>PYI019</code>)</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15821">#15821</a>
        opened by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a>
        on 2025-01-30 00:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-01-30 00:09</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Resolves #15798.</p>
<p><code>PYI019</code> is now a binding-based rule. All references to the type variable will now be replaced correctly. As a result, the fix is now safe in most cases; when that is not possible, its applicability remains display-only. Additionally, for a safe fix, comments within the fix ranges will cause it to be marked as unsafe.</p>
<h2>Test Plan</h2>
<p><code>cargo nextest run</code> and <code>cargo insta test</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @InSyncWithFoo on 2025-01-30 00:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-30 00:16</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fixes</span> added by @dylwil3 on 2025-01-30 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @AlexWaygood by @AlexWaygood on 2025-01-31 11:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-31 12:40</div>
            <div class="timeline-body"><p>I'd like for us to fix existing bugs such as https://github.com/astral-sh/ruff/issues/15849 first before extending this rule further (edit: see https://github.com/astral-sh/ruff/pull/15851, and https://github.com/astral-sh/ruff/pull/15853)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-31 15:07</div>
            <div class="timeline-body"><blockquote>
<p>Previously, there was also a small bug that would cause a PEP 695 type variable not to be removed correctly were it to be placed at the very end of the type parameter list. This has been fixed as well.</p>
</blockquote>
<p>Could you possibly separate this out into an isolated PR? That would make it easier to see which tests are specifically for this bugfix</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-01-31 16:19</div>
            <div class="timeline-body"><p>@AlexWaygood I submitted #15854. As it happens, this PR overlaps with #15853 as well. I'll rebase this once you give the heads-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-31 16:55</div>
            <div class="timeline-body"><blockquote>
<p>I'll rebase this once you give the heads-up.</p>
</blockquote>
<p>Okay, I'm done -- rebase at your leisure! Thanks :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-02-01 04:00</div>
            <div class="timeline-body"><p>@AlexWaygood This PR now introduces a regression:</p>
<pre><code class="language-python">def shadowed_type():
    type = 1
    class A:
        @classmethod
        def m[S](cls: type[S]) -&gt; S: ...  # error
</code></pre>
<p>This is due to <code>semantic.match_builtin_expr()</code> searching for <code>type</code> in the &quot;current&quot; scope (via <code>self.scope_id</code> in <code>.lookup_symbol()</code>) rather than the scope of the method.</p>
<p>I'm not sure how to fix this. <code>.simulate_runtime_load_at_location_in_scope()</code> returns a binding, but a <code>::Builtin</code> binding does not have any information as to what symbol it represents. Not to mention, that method expects a string, so <code>builtins.type</code> can't be detected correctly. On the other hand, <code>.resolve_qualified_name()</code> does not accept a scope.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:108 on 2025-02-01 11:23</div>
            <div class="timeline-body"><p>I would do</p>
<pre><code class="language-rs">    let self_or_cls_annotation = parameters
        .posonlyargs
        .iter()
        .chain(&amp;parameters.args)
        .next()?
        .parameter
        .annotation
        .as_ref()?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:333 on 2025-02-01 11:23</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    if let Some(edits) = replace_typevar_usages_with_self(
        typevar,
        &amp;self_symbol_binding,
        replace_references_range,
        checker.semantic(),
    ) {
        other_edits.extend(edits);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-01 11:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:89 on 2025-02-01 15:41</div>
            <div class="timeline-body"><p>nit: not really sure we need all these blank lines; the code here isn't that complex</p>
<pre><code class="language-suggestion">    let semantic = checker.semantic();
    let current_scope = &amp;semantic.scopes[binding.scope];
    let function_def = binding.statement(semantic)?.as_function_def_stmt()?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:308 on 2025-02-01 15:43</div>
            <div class="timeline-body"><p>nit: I prefer the existing variable name <code>import_edit</code> here. It's what we generally call this variable in other rules, and it's more descriptive about what the edit does</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:323 on 2025-02-01 15:43</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let first_parameter_end = edit.end();
        other_edits.push(edit);
        TextRange::new(first_parameter_end, returns.start())
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-01 15:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-01 16:04</div>
            <div class="timeline-body"><blockquote>
<p>@AlexWaygood This PR now introduces a regression:</p>
</blockquote>
<p>I think you can do something like this:</p>
<pre><code class="language-diff">diff --git a/crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs b/crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs
index 4d30fd3eb..7128fddb1 100644
--- a/crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs
+++ b/crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs
@@ -8,7 +8,7 @@ use ruff_python_ast::{
 };
 use ruff_python_semantic::analyze::function_type::{self, FunctionType};
 use ruff_python_semantic::analyze::visibility::{is_abstract, is_overload};
-use ruff_python_semantic::{Binding, BindingKind, SemanticModel};
+use ruff_python_semantic::{Binding, BindingKind, ScopeId, SemanticModel};
 use ruff_text_size::{Ranged, TextRange, TextSize};
 
 use crate::checkers::ast::Checker;
@@ -138,7 +138,7 @@ pub(crate) fn custom_type_var_return_type(
         }),
     };
 
-    if !method.uses_custom_var(semantic) {
+    if !method.uses_custom_var(semantic, binding.scope) {
         return None;
     }
 
@@ -162,9 +162,9 @@ enum Method&lt;'a&gt; {
 }
 
 impl Method&lt;'_&gt; {
-    fn uses_custom_var(&amp;self, semantic: &amp;SemanticModel) -&gt; bool {
+    fn uses_custom_var(&amp;self, semantic: &amp;SemanticModel, scope: ScopeId) -&gt; bool {
         match self {
-            Self::Class(class_method) =&gt; class_method.uses_custom_var(semantic),
+            Self::Class(class_method) =&gt; class_method.uses_custom_var(semantic, scope),
             Self::Instance(instance_method) =&gt; instance_method.uses_custom_var(),
         }
     }
@@ -180,7 +180,7 @@ struct ClassMethod&lt;'a&gt; {
 impl ClassMethod&lt;'_&gt; {
     /// Returns `true` if the class method is annotated with
     /// a custom `TypeVar` that is likely private.
-    fn uses_custom_var(&amp;self, semantic: &amp;SemanticModel) -&gt; bool {
+    fn uses_custom_var(&amp;self, semantic: &amp;SemanticModel, scope: ScopeId) -&gt; bool {
         let Expr::Subscript(ast::ExprSubscript {
             value: cls_annotation_value,
             slice: cls_annotation_typevar,
@@ -196,7 +196,15 @@ impl ClassMethod&lt;'_&gt; {
 
         let cls_annotation_typevar = &amp;cls_annotation_typevar.id;
 
-        if !semantic.match_builtin_expr(cls_annotation_value, &quot;type&quot;) {
+        let Expr::Name(ExprName { id, ..}) = &amp;**cls_annotation_value else {
+            return false;
+        };
+
+        if id != &quot;type&quot; {
+            return false;
+        }
+
+        if !semantic.has_builtin_binding_in_scope(&quot;type&quot;, scope) {
             return false;
         }
 
@@ -206,7 +214,10 @@ impl ClassMethod&lt;'_&gt; {
                 let Expr::Name(return_annotation_typevar) = &amp;**slice else {
                     return false;
                 };
-                if !semantic.match_builtin_expr(value, &quot;type&quot;) {
+                let Expr::Name(ExprName { id, ..}) = &amp;**value else {
+                    return false;
+                };
+                if id != &quot;type&quot; {
                     return false;
                 }
                 &amp;return_annotation_typevar.id
diff --git a/crates/ruff_python_semantic/src/model.rs b/crates/ruff_python_semantic/src/model.rs
index 4ef240e23..825ee3256 100644
--- a/crates/ruff_python_semantic/src/model.rs
+++ b/crates/ruff_python_semantic/src/model.rs
@@ -265,13 +265,22 @@ impl&lt;'a&gt; SemanticModel&lt;'a&gt; {
         self.shadowed_bindings.get(&amp;binding_id).copied()
     }
 
-    /// Return `true` if `member` is bound as a builtin.
+    /// Return `true` if `member` is bound as a builtin *in the scope we are currently visiting*.
     ///
     /// Note that a &quot;builtin binding&quot; does *not* include explicit lookups via the `builtins`
     /// module, e.g. `import builtins; builtins.open`. It *only* includes the bindings
     /// that are pre-populated in Python's global scope before any imports have taken place.
     pub fn has_builtin_binding(&amp;self, member: &amp;str) -&gt; bool {
-        self.lookup_symbol(member)
+        self.has_builtin_binding_in_scope(member, self.scope_id)
+    }
+
+    /// Return `true` if `member` is bound as a builtin *in a given scope*.
+    ///
+    /// Note that a &quot;builtin binding&quot; does *not* include explicit lookups via the `builtins`
+    /// module, e.g. `import builtins; builtins.open`. It *only* includes the bindings
+    /// that are pre-populated in Python's global scope before any imports have taken place.
+    pub fn has_builtin_binding_in_scope(&amp;self, member: &amp;str, scope_id: ScopeId) -&gt; bool {
+        self.lookup_symbol_in_scope(member, scope_id, false)
             .map(|binding_id| &amp;self.bindings[binding_id])
             .is_some_and(|binding| binding.kind.is_builtin())
     }
</code></pre>
<p>It will still mean that the PR introduces a small regression. We will no longer emit the diagnostic on code like this, where the fully qualified <code>builtins.type</code> is used in the annotation of the first parameter of a classmethod:</p>
<pre><code class="language-py">import builtins

class Foo:
    @classmethod
    def m[S](cls: builtins.type[S]) -&gt; builtins.type[S]: ...
</code></pre>
<p>But false negatives are much better than false positives. And I think the small regression of some edge-case false negatives is hugely outweighed by the improvements you're introducing in this PR!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-01 17:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:89 on 2025-02-01 17:44</div>
            <div class="timeline-body"><p>I think this is redundant considering you have <code>let function_def = binding.statement(semantic)?.as_function_def_stmt()?;</code> a few lines below. That already ensures that we won't emit this diagnostic on a <code>Binding</code> unless that binding is associated with a function-definition statement</p>
<pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:103 on 2025-02-02 12:23</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        .next()?
        .annotation()?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:386 on 2025-02-02 12:26</div>
            <div class="timeline-body"><p>Can you add some docs to this function? It was quite unclear to me at first why it returns an <code>Option&lt;Vec&lt;Edit&gt;&gt;</code> rather than just returning an empty <code>Vec</code> in the cases where it currently returns <code>None</code>. I think it's because if we can't resolve the binding to something in this module, we can't be sure that the binding refers to a private TypeVar. Is that correct?</p>
<p>It would also be good to explain what <code>editable_range</code> represents, and why we only replace references to the TypeVar if the references lie within that range</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:277 on 2025-02-02 12:33</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Return `true` if `member` is bound as a builtin *in a given scope*.
</code></pre>
<p>And you need ot change the sentence on line 268 to add <code>*in the scope we are currently visiting*</code> to the end of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-02 12:34</div>
            <div class="timeline-body"><p>Do the changes in this PR mean that we could also offer the fix for <code>.py</code> files as well as stub files? We could potentially iterate over the references to the TypeVar in the body of the function and replace them with <code>Self</code>, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-02-02 18:00</div>
            <div class="timeline-body"><blockquote>
<p>Do the changes in this PR mean that we could also offer the fix for <code>.py</code> files as well as stub files?</p>
</blockquote>
<p>Very unfortunately, no. This would have problems similar to that of #15862.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-02 18:30</div>
            <div class="timeline-body"><blockquote>
<p>Very unfortunately, no. This would have problems similar to that of #15862.</p>
</blockquote>
<p>You're worried about references inside stringized type expressions? That doesn't seem like a <em>great</em> reason to restrict the rule to stub files, since stringized type expressions are legal in stub files as well as <code>.py</code> files (they're just not encouraged). It would be better to detect if any of the references are inside stringized type expressions, and make the fix display-only if so, but to run the fix on both stub files and <code>.py</code> files.</p>
<p>But anyway, let's land this as-is for now. It's a big improvement as it is, and the PR is big enough as it is. I have some followup work locally that I can file as PRs to build on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/custom_type_var_return_type.rs</code>:381 on 2025-02-02 18:31</div>
            <div class="timeline-body"><pre><code class="language-suggestion">/// Returns a series of [`Edit`]s that modify all references to the given `typevar`,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-02-02 18:33</div>
            <div class="timeline-body"><p>Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by @AlexWaygood on 2025-02-02 18:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-02-02 18:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-02-02 18:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-02-02 19:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-02-02 19:09</div>
            <div class="timeline-body"><blockquote>
<p>[...] stringized type expressions are legal in stub files as well as <code>.py</code> files [...]</p>
</blockquote>
<p>True, but we also have <a href="https://docs.astral.sh/ruff/rules/non-empty-stub-body/"><code>PYI010</code></a> for non-empty bodies and <a href="https://docs.astral.sh/ruff/rules/quoted-annotation-in-stub/"><code>PYI020</code></a> for stringified types, both of which are only reported for stubs and always safely fixable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-02 19:15</div>
            <div class="timeline-body"><p>Sure, but users are fickle, and may only have some of the flake8-pyi rules enabled ;)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:57:51 UTC
    </footer>
</body>
</html>
