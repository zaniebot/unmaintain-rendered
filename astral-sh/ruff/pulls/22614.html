<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Use distributed versions of AND and OR on constraint sets - astral-sh/ruff #22614</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Use distributed versions of AND and OR on constraint sets</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22614">#22614</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2026-01-16 10:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>There are some pathological examples where we create a constraint set which is the AND or OR of several smaller constraint sets. For example, when calling a function with many overloads, where the argument is a typevar, we create an OR of the typevar specializing to a type compatible with the respective parameter of each overload.</p>
<p>Most functions have a small number of overloads. But there are some examples of methods with 15-20 overloads (pydantic, numpy, our own auto-generated <code>__getitem__</code> for large tuple literals). For those cases, it is helpful to be more clever about how we construct the final result.</p>
<p>Before, we would just step through the <code>Iterator</code> of elements and accumulate them into a result constraint set. That results in an <code>O(n)</code> number of calls to the underlying <code>and</code> or <code>or</code> operator — each of which might have to construct a large temporary BDD tree.</p>
<p>AND and OR are both associative, so we can do better! We now invoke the operator in a &quot;tree&quot; shape (described in more detail in the doc comment). We still have to perform the same number of calls, but more of the calls operate on smaller BDDs, resulting in a much smaller amount of overall work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-16 10:03</div>
            <div class="timeline-body">

<a href="https://github.com/python/typing/blob/dece44f2922ca390fe314145d09939514a21e76e/conformance/">Typing conformance results</a>
<p>No changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-16 10:05</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>tornado (https://github.com/tornadoweb/tornado)
- tornado/gen.py:255:62: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `None | Awaitable[Unknown] | list[Awaitable[Unknown]] | dict[Any, Awaitable[Unknown]] | Future[Unknown]`, found `_T@next | _T@next | _VT@next`
+ tornado/gen.py:255:62: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `None | Awaitable[Unknown] | list[Awaitable[Unknown]] | dict[Any, Awaitable[Unknown]] | Future[Unknown]`, found `_T@next | _VT@next | _T@next`

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
+ src/scikit_build_core/build/wheel.py:99:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 46 diagnostics
+ Found 47 diagnostics

core (https://github.com/home-assistant/core)
- homeassistant/util/variance.py:47:12: error[invalid-return-type] Return type does not match returned value: expected `(**_P@ignore_variance) -&gt; _R@ignore_variance`, found `_Wrapped[_P@ignore_variance, _R@ignore_variance | int | float | datetime, _P@ignore_variance, _R@ignore_variance | int | float | datetime]`
- Found 14465 diagnostics
+ Found 14464 diagnostics


</code></pre>


<p>No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 10:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:723 on 2026-01-16 10:08</div>
            <div class="timeline-body"><p>While we&#x27;re here, I&#x27;m updating the BDD variable ordering to be less clever. For the pathological example from #21902 this has a huge benefit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 10:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:4028 on 2026-01-16 10:08</div>
            <div class="timeline-body"><p>and also update the tree display to make it more obvious where we&#x27;re sharing tree structure</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2026-01-16 10:30</div>
            <div class="timeline-body">

<a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a>
Merging this PR will <strong>degrade performance by 45.74%</strong>
<p>Comparing <code>dcreager/distributed-ops</code> (18f5b2a) with <code>main</code> (d4123fc)</p>
Summary
<p><code>❌ 4</code> regressed benchmarks<br>
<code>✅ 19</code> untouched benchmarks<br>
<code>⏩ 30</code> skipped benchmarks[^skipped]</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?utm_source=github&amp;utm_medium=comment&amp;utm_content=acknowledge">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
Performance Changes
<p>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Efficiency |
| --- | ---- | --------- | ------ | ------ | ---------- |
| ❌ | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Acolour_science&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>colour_science</code></a> | 87.2 s | 160.6 s | -45.74% |
| ❌ | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Apandas&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>pandas</code></a> | 61.8 s | 68.7 s | -10.06% |
| ❌ | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Astatic_frame&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>static_frame</code></a> | 20.8 s | 22.8 s | -8.81% |
| ❌ | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Afreqtrade&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>freqtrade</code></a> | 7.7 s | 8.1 s | -4.59% |</p>
<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-16 10:43</div>
            <div class="timeline-body"><p>From the summary, I expect this to improve performance and reduce memory usage. Both don&#x27;t seem to be the case. Do you have an understanding where the performance regression comes from? Could we keep using the &quot;old approach&quot; when not dealing with many overloads?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-16 10:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1828 on 2026-01-16 10:45</div>
            <div class="timeline-body"><p>Could this be a <code>FxIndexSet</code> or why is it important that <code>seen</code> has <code>Eq</code> and <code>PartialEq</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-16 10:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:149 on 2026-01-16 10:47</div>
            <div class="timeline-body"><p>Could it be that the collect calls are expensive? Given that <code>distributed_or</code> and <code>distributed_and</code> are very small methods, would it make sense to pass the <code>f</code> through and apply the mapping in <code>distributed_or</code>/and?</p>
<p>Another alternative is to use a <code>SmallVec</code> instead. But I wonder if part of the perf regression simply comes from writing all the constraints to a vec</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 12:37</div>
            <div class="timeline-body"><blockquote>
<p>From the summary, I expect this to improve performance and reduce memory usage. Both don&#x27;t seem to be the case. Do you have an understanding where the performance regression comes from? Could we keep using the &quot;old approach&quot; when not dealing with many overloads?</p>
</blockquote>
<p>Me too! Maybe the collecting is the culprit, as you suggest? Or maybe because we&#x27;re not short circuiting anymore? I have an idea that might help with both.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:149 on 2026-01-16 13:25</div>
            <div class="timeline-body"><p>I&#x27;ve pushed up a new version that doesn&#x27;t collect into a vec first. I want to see how that affects the perf numbers; if it works well I plan to add some better documentation comments describing how it works</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1828 on 2026-01-16 13:25</div>
            <div class="timeline-body"><p>It can! Done (My muscle memory is to immediately reach for <code>FxOrderSet</code> first)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 13:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-16 13:40</div>
            <div class="timeline-body"><p>Wow, nice job getting this from a 5x perf regression to a 4% perf improvement!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 14:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:149 on 2026-01-16 14:51</div>
            <div class="timeline-body"><p>This seems to work well! Pushed up some documentation of the approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:150 on 2026-01-19 09:16</div>
            <div class="timeline-body"><p>This PR does improve the performance by a fair bit but it also regresses performance by about 1-2 on most other projects.</p>
<p>It would be lovely if we could use specialization to specialize <code>when_any</code> and <code>when_all</code> for <code>ExactSizeIterator</code> so that we could use the old implementation if there are only very few items. But, that&#x27;s unlikely an option any time soon unless we migrate to nightly Rust.</p>
<p>I went through some <code>when_any</code> usages and:</p>
<ul>
<li>We could implement <code>when_any</code> for <code>&amp;[T]</code> and <code>&amp;FxOrderSet</code></li>
<li>We could add a <code>when_any_exact</code> method (or rename <code>when_any</code> to <code>when_any_iter</code> to advertise the <code>ExactSizeIterator</code> version)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:723 on 2026-01-19 09:17</div>
            <div class="timeline-body"><p>Should we do this in a separate PR so that we better understand where the performance improvements are coming from?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2026-01-19 09:22</div>
            <div class="timeline-body"><p>Nice.</p>
<p>It might make sense to specialize <code>distribute_or</code> and <code>distribute_and</code> (or <code>when_any</code>) for <code>&amp;[T]</code> and <code>ExactSizeIterator</code> as we see a perf regression on many projects (while small). Unless the perf regression is related to the <code>ordering</code> change. I suggest splitting that change into its own PR so that we have a better understanding where the regression is coming from.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:723 on 2026-01-20 21:28</div>
            <div class="timeline-body"><p>Done: <a href="https://github.com/astral-sh/ruff/pull/22777">astral-sh/ruff#22777</a></p>
<p>(I have not addressed the other comments below yet; did this first to see what the performance looks like before considering a fallback for smaller vecs/etc)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-20 21:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-20 23:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:150 on 2026-01-20 23:03</div>
            <div class="timeline-body"><p>An <code>ExactSizeIterator</code> is required to return the exact size from <code>size_hint</code>, too, so I added a fallback that checks if the max size hint is &lt;= 4, and uses the old implementation if so.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:150 on 2026-01-20 23:14</div>
            <div class="timeline-body"><p>(That way I didn&#x27;t have to worry about specialization or adding a new method for exact-sized things)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-20 23:14</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 23:54:08 UTC
    </footer>
</body>
</html>
