<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Use distributed versions of AND and OR on constraint sets - astral-sh/ruff #22614</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Use distributed versions of AND and OR on constraint sets</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22614">#22614</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2026-01-16 10:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>There are some pathological examples where we create a constraint set which is the AND or OR of several smaller constraint sets. For example, when calling a function with many overloads, where the argument is a typevar, we create an OR of the typevar specializing to a type compatible with the respective parameter of each overload.</p>
<p>Most functions have a small number of overloads. But there are some examples of methods with 15-20 overloads (pydantic, numpy, our own auto-generated <code>__getitem__</code> for large tuple literals). For those cases, it is helpful to be more clever about how we construct the final result.</p>
<p>Before, we would just step through the <code>Iterator</code> of elements and accumulate them into a result constraint set. That results in an <code>O(n)</code> number of calls to the underlying <code>and</code> or <code>or</code> operator — each of which might have to construct a large temporary BDD tree.</p>
<p>AND and OR are both associative, so we can do better! We now invoke the operator in a &quot;tree&quot; shape (described in more detail in the doc comment). We still have to perform the same number of calls, but more of the calls operate on smaller BDDs, resulting in a much smaller amount of overall work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-16 10:03</div>
            <div class="timeline-body">

<a href="https://github.com/python/typing/blob/dece44f2922ca390fe314145d09939514a21e76e/conformance/">Typing conformance results</a>
<p>No changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-16 10:05</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>tornado (https://github.com/tornadoweb/tornado)
- tornado/gen.py:255:62: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `None | Awaitable[Unknown] | list[Awaitable[Unknown]] | dict[Any, Awaitable[Unknown]] | Future[Unknown]`, found `_T@next | _VT@next | _T@next`
+ tornado/gen.py:255:62: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `None | Awaitable[Unknown] | list[Awaitable[Unknown]] | dict[Any, Awaitable[Unknown]] | Future[Unknown]`, found `_T@next | _T@next | _VT@next`

pydantic (https://github.com/pydantic/pydantic)
- pydantic/fields.py:949:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:949:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:989:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:989:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1032:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1032:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1072:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1072:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1115:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1115:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1154:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1154:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1194:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1194:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1573:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`
+ pydantic/fields.py:1573:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, Divergent], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`

discord.py (https://github.com/Rapptz/discord.py)
- discord/app_commands/checks.py:390:42: error[invalid-assignment] Object of type `Coroutine[Any, Any, Cooldown | None] | Cooldown | None` is not assignable to `Cooldown | None`
- Found 540 diagnostics
+ Found 539 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
- src/prefect/_internal/concurrency/api.py:83:29: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@call_soon_in_new_thread]`, found `() -&gt; T@call_soon_in_new_thread | Awaitable[T@call_soon_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:87:16: error[invalid-return-type] Return type does not match returned value: expected `Call[T@call_soon_in_new_thread]`, found `Call[Awaitable[T@call_soon_in_new_thread]]`
- src/prefect/_internal/concurrency/api.py:99:29: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@call_soon_in_loop_thread]`, found `() -&gt; T@call_soon_in_loop_thread | Awaitable[T@call_soon_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:103:16: error[invalid-return-type] Return type does not match returned value: expected `Call[T@call_soon_in_loop_thread]`, found `Call[Awaitable[T@call_soon_in_loop_thread]]`
- src/prefect/_internal/concurrency/api.py:137:29: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@wait_for_call_in_loop_thread]`, found `(() -&gt; Awaitable[T@wait_for_call_in_loop_thread]) | Call[T@wait_for_call_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:146:20: error[invalid-return-type] Return type does not match returned value: expected `T@wait_for_call_in_loop_thread`, found `Awaitable[T@wait_for_call_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:154:29: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@wait_for_call_in_new_thread]`, found `(() -&gt; T@wait_for_call_in_new_thread) | Call[T@wait_for_call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:160:16: error[invalid-return-type] Return type does not match returned value: expected `T@wait_for_call_in_new_thread`, found `Awaitable[T@wait_for_call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:166:46: error[invalid-argument-type] Argument to function `call_soon_in_new_thread` is incorrect: Expected `() -&gt; Awaitable[T@call_in_new_thread]`, found `(() -&gt; T@call_in_new_thread) | Call[T@call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:174:47: error[invalid-argument-type] Argument to function `call_soon_in_loop_thread` is incorrect: Expected `() -&gt; Awaitable[T@call_in_loop_thread]`, found `(() -&gt; Awaitable[T@call_in_loop_thread]) | Call[T@call_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:189:29: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@wait_for_call_in_loop_thread]`, found `(() -&gt; Awaitable[T@wait_for_call_in_loop_thread]) | Call[T@wait_for_call_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:198:20: error[invalid-return-type] Return type does not match returned value: expected `T@wait_for_call_in_loop_thread`, found `Awaitable[T@wait_for_call_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:206:29: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@wait_for_call_in_new_thread]`, found `(() -&gt; T@wait_for_call_in_new_thread) | Call[T@wait_for_call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:212:16: error[invalid-return-type] Return type does not match returned value: expected `T@wait_for_call_in_new_thread`, found `Awaitable[T@wait_for_call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:219:46: error[invalid-argument-type] Argument to function `call_soon_in_new_thread` is incorrect: Expected `() -&gt; Awaitable[T@call_in_new_thread]`, found `() -&gt; T@call_in_new_thread | Awaitable[T@call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:220:16: error[invalid-return-type] Return type does not match returned value: expected `T@call_in_new_thread`, found `Awaitable[T@call_in_new_thread]`
- src/prefect/_internal/concurrency/api.py:230:33: error[invalid-argument-type] Argument to function `cast_to_call` is incorrect: Expected `() -&gt; Awaitable[T@call_in_loop_thread]`, found `() -&gt; T@call_in_loop_thread | Awaitable[T@call_in_loop_thread]`
- src/prefect/_internal/concurrency/api.py:233:47: error[invalid-argument-type] Argument to function `call_soon_in_loop_thread` is incorrect: Expected `() -&gt; Awaitable[T@call_in_loop_thread]`, found `() -&gt; T@call_in_loop_thread | Awaitable[T@call_in_loop_thread]`
- src/prefect/concurrency/_leases.py:89:53: error[invalid-argument-type] Argument to bound method `add_done_callback` is incorrect: Expected `(Future[CoroutineType[Any, Any, None]], /) -&gt; object`, found `def handle_lease_renewal_failure(future: Future[None]) -&gt; Unknown`
- src/prefect/utilities/asyncutils.py:198:16: error[invalid-return-type] Return type does not match returned value: expected `R@run_coro_as_sync | None`, found `CoroutineType[Any, Any, R@run_coro_as_sync | None]`
- src/prefect/utilities/asyncutils.py:207:20: error[invalid-return-type] Return type does not match returned value: expected `R@run_coro_as_sync | None`, found `CoroutineType[Any, Any, R@run_coro_as_sync | None]`
- Found 5412 diagnostics
+ Found 5391 diagnostics

ibis (https://github.com/ibis-project/ibis)
+ ibis/formats/pandas.py:115:27: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `Overload[(objs: Iterable[None] | Mapping[HashableT1@concat, None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2@concat] | None = None, levels: Sequence[list[HashableT3@concat] | tuple[HashableT3@concat, ...]] | None = None, names: list[HashableT4@concat] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Series[S2@concat] | Series[Any], (objs: Iterable[Series[S2@concat] | None] | Mapping[HashableT1@concat, Series[S2@concat] | None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2@concat] | None = None, levels: Sequence[list[HashableT3@concat] | tuple[HashableT3@concat, ...]] | None = None, names: list[HashableT4@concat] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Series[S2@concat] | Series[Any], (objs: Iterable[Series[Any] | None] | Mapping[HashableT1@concat, Series[Any] | None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2@concat] | None = None, levels: Sequence[list[HashableT3@concat] | tuple[HashableT3@concat, ...]] | None = None, names: list[HashableT4@concat] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Series[S2@concat] | Series[Any], (objs: Iterable[NDFrame | None] | Mapping[HashableT1@concat, NDFrame | None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2@concat] | None = None, levels: Sequence[list[HashableT3@concat] | tuple[HashableT3@concat, ...]] | None = None, names: list[HashableT4@concat] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Series[S2@concat] | Series[Any]]`, found `Overload[[HashableT1, HashableT2, HashableT3, HashableT4](objs: Iterable[None] | Mapping[HashableT1, None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2] | None = None, levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] | None = None, names: list[HashableT4] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Never, [S2, HashableT1, HashableT2, HashableT3, HashableT4](objs: Iterable[Series[S2] | None] | Mapping[HashableT1, Series[S2] | None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2] | None = None, levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] | None = None, names: list[HashableT4] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Series[S2], [HashableT1, HashableT2, HashableT3, HashableT4](objs: Iterable[Series[Any] | None] | Mapping[HashableT1, Series[Any] | None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2] | None = None, levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] | None = None, names: list[HashableT4] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; Series[Any], [HashableT1, HashableT2, HashableT3, HashableT4](objs: Iterable[NDFrame | None] | Mapping[HashableT1, NDFrame | None], *, axis: Unknown = 0, join: Literal[&quot;inner&quot;, &quot;outer&quot;] = &quot;outer&quot;, ignore_index: bool = False, keys: Iterable[HashableT2] | None = None, levels: Sequence[list[HashableT3] | tuple[HashableT3, ...]] | None = None, names: list[HashableT4] | None = None, verify_integrity: bool = False, sort: bool = False, copy: bool = True) -&gt; DataFrame]`
- Found 4609 diagnostics
+ Found 4610 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Any | Bottom[Series[Any, Any]], TVDtype@Index]`
+ static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Any, TVDtype@Index]`
- static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Unknown | Bottom[Series[Any, Any]], Any]`
+ static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Unknown, Any]`

rotki (https://github.com/rotki/rotki)
+ rotkehlchen/chain/decoding/tools.py:96:44: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- rotkehlchen/chain/decoding/tools.py:97:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `BTCAddress | ChecksumAddress | SubstrateAddress | SolanaAddress`, found `A@BaseDecoderTools`
+ rotkehlchen/chain/decoding/tools.py:99:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `Sequence[A@BaseDecoderTools]`, found `Unknown | tuple[BTCAddress, ...] | tuple[ChecksumAddress, ...] | tuple[SubstrateAddress, ...] | tuple[SolanaAddress, ...]`
- rotkehlchen/chain/decoding/tools.py:98:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `BTCAddress | ChecksumAddress | SubstrateAddress | SolanaAddress | None`, found `A@BaseDecoderTools | None`
+ rotkehlchen/chain/decoding/tools.py:100:62: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 2058 diagnostics
+ Found 2059 diagnostics

core (https://github.com/home-assistant/core)
- homeassistant/util/variance.py:47:12: error[invalid-return-type] Return type does not match returned value: expected `(**_P@ignore_variance) -&gt; _R@ignore_variance`, found `_Wrapped[_P@ignore_variance, _R@ignore_variance | int | float | datetime, _P@ignore_variance, _R@ignore_variance | int | float | datetime]`
- Found 14465 diagnostics
+ Found 14464 diagnostics


</code></pre>


<p>No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 10:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:723 on 2026-01-16 10:08</div>
            <div class="timeline-body"><p>While we&#x27;re here, I&#x27;m updating the BDD variable ordering to be less clever. For the pathological example from #21902 this has a huge benefit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 10:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:4028 on 2026-01-16 10:08</div>
            <div class="timeline-body"><p>and also update the tree display to make it more obvious where we&#x27;re sharing tree structure</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 10:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2026-01-16 10:30</div>
            <div class="timeline-body">

<a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a>
Merging this PR will <strong>not alter performance</strong>
<p>Comparing <code>dcreager/distributed-ops</code> (ffd9920) with <code>main</code> (3b5d0d5)</p>
Summary
<p><code>✅ 23</code> untouched benchmarks<br>
<code>⏩ 30</code> skipped benchmarks[^skipped]</p>
<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fdistributed-ops?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-16 10:43</div>
            <div class="timeline-body"><p>From the summary, I expect this to improve performance and reduce memory usage. Both don&#x27;t seem to be the case. Do you have an understanding where the performance regression comes from? Could we keep using the &quot;old approach&quot; when not dealing with many overloads?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-16 10:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1828 on 2026-01-16 10:45</div>
            <div class="timeline-body"><p>Could this be a <code>FxIndexSet</code> or why is it important that <code>seen</code> has <code>Eq</code> and <code>PartialEq</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-16 10:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:149 on 2026-01-16 10:47</div>
            <div class="timeline-body"><p>Could it be that the collect calls are expensive? Given that <code>distributed_or</code> and <code>distributed_and</code> are very small methods, would it make sense to pass the <code>f</code> through and apply the mapping in <code>distributed_or</code>/and?</p>
<p>Another alternative is to use a <code>SmallVec</code> instead. But I wonder if part of the perf regression simply comes from writing all the constraints to a vec</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-16 12:37</div>
            <div class="timeline-body"><blockquote>
<p>From the summary, I expect this to improve performance and reduce memory usage. Both don&#x27;t seem to be the case. Do you have an understanding where the performance regression comes from? Could we keep using the &quot;old approach&quot; when not dealing with many overloads?</p>
</blockquote>
<p>Me too! Maybe the collecting is the culprit, as you suggest? Or maybe because we&#x27;re not short circuiting anymore? I have an idea that might help with both.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:149 on 2026-01-16 13:25</div>
            <div class="timeline-body"><p>I&#x27;ve pushed up a new version that doesn&#x27;t collect into a vec first. I want to see how that affects the perf numbers; if it works well I plan to add some better documentation comments describing how it works</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1828 on 2026-01-16 13:25</div>
            <div class="timeline-body"><p>It can! Done (My muscle memory is to immediately reach for <code>FxOrderSet</code> first)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 13:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-16 13:40</div>
            <div class="timeline-body"><p>Wow, nice job getting this from a 5x perf regression to a 4% perf improvement!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-16 14:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:149 on 2026-01-16 14:51</div>
            <div class="timeline-body"><p>This seems to work well! Pushed up some documentation of the approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:150 on 2026-01-19 09:16</div>
            <div class="timeline-body"><p>This PR does improve the performance by a fair bit but it also regresses performance by about 1-2 on most other projects.</p>
<p>It would be lovely if we could use specialization to specialize <code>when_any</code> and <code>when_all</code> for <code>ExactSizeIterator</code> so that we could use the old implementation if there are only very few items. But, that&#x27;s unlikely an option any time soon unless we migrate to nightly Rust.</p>
<p>I went through some <code>when_any</code> usages and:</p>
<ul>
<li>We could implement <code>when_any</code> for <code>&amp;[T]</code> and <code>&amp;FxOrderSet</code></li>
<li>We could add a <code>when_any_exact</code> method (or rename <code>when_any</code> to <code>when_any_iter</code> to advertise the <code>ExactSizeIterator</code> version)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:723 on 2026-01-19 09:17</div>
            <div class="timeline-body"><p>Should we do this in a separate PR so that we better understand where the performance improvements are coming from?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2026-01-19 09:22</div>
            <div class="timeline-body"><p>Nice.</p>
<p>It might make sense to specialize <code>distribute_or</code> and <code>distribute_and</code> (or <code>when_any</code>) for <code>&amp;[T]</code> and <code>ExactSizeIterator</code> as we see a perf regression on many projects (while small). Unless the perf regression is related to the <code>ordering</code> change. I suggest splitting that change into its own PR so that we have a better understanding where the regression is coming from.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:723 on 2026-01-20 21:28</div>
            <div class="timeline-body"><p>Done: <a href="https://github.com/astral-sh/ruff/pull/22777">astral-sh/ruff#22777</a></p>
<p>(I have not addressed the other comments below yet; did this first to see what the performance looks like before considering a fallback for smaller vecs/etc)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-20 21:28</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 22:55:14 UTC
    </footer>
</body>
</html>
