```yaml
number: 6552
title: Memoize text width
type: pull_request
state: merged
author: MichaReiser
labels:
  - performance
  - formatter
assignees: []
merged: true
base: main
head: memoize-text-width
created_at: 2023-08-14T08:21:53Z
updated_at: 2023-09-06T07:10:15Z
url: https://github.com/astral-sh/ruff/pull/6552
synced_at: 2026-01-12T02:45:38Z
```

# Memoize text width

---

_Pull request opened by @MichaReiser on 2023-08-14 08:21_

<!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

## Summary

The formatter processes strings a couple of times:

* `propagate_expands`: Test if the string contains a newline and, if so, set `mode: Propagated` on all enclosing groups
* `print_text`: Measures the width of the text to compute the `line_width`
* `fits_text` (only if the text is inside of a group): Measures the width of the text to determine if the content fits. Runs `n` times where `n` is the number of parent groups. 


This PR adds a `TextWidth` field to all text `FormatElement`s that either stores the computed width or that it is a multiline string. 
This reduces the traversal for non-multiline strings to exactly once. Multiline strings still get traversed multiple times and you could argue this PR makes it worse because the implementation now computes the text width only to throw it away when realizing it is a multiline string. However, multiline strings are rare. 

Memoizing the text width improves performance by 2-12%.

The downsides of this change are:

* It will make it harder to add more fields to `Text` `FormatElement`s because we are now very close to the 24 bytes
* The same logic is now spread in multiple places, increasing the risk of one-off bugs

<!-- What's the purpose of the change? What does it do, and why? -->

## Test Plan

The tests are currently failing because I need to update them to pass `TextWidth`
<!-- How was it tested? -->


---

_Comment by @MichaReiser on 2023-08-14 08:22_

Current dependencies on/for this PR:
* main
  * **PR #7048** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7048" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #6552** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/6552" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ
      * **PR #7037** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7037" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 

This comment was auto-generated by [Graphite](https://app.graphite.dev/github/pr/astral-sh/ruff/6552?utm_source=stack-comment).

---

_Review requested from @charliermarsh by @MichaReiser on 2023-08-14 08:24_

---

_Comment by @github-actions[bot] on 2023-08-14 08:57_

## PR Check Results
### Benchmark
#### Linux
```
group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.01      3.8Â±0.03ms    10.8 MB/sec    1.00      3.7Â±0.03ms    10.9 MB/sec
formatter/numpy/ctypeslib.py               1.02   731.3Â±14.42Âµs    22.8 MB/sec    1.00    716.8Â±8.55Âµs    23.2 MB/sec
formatter/numpy/globals.py                 1.03     74.5Â±0.44Âµs    39.6 MB/sec    1.00     72.2Â±0.28Âµs    40.9 MB/sec
formatter/pydantic/types.py                1.02  1476.4Â±34.21Âµs    17.3 MB/sec    1.00  1443.0Â±24.24Âµs    17.7 MB/sec
linter/all-rules/large/dataset.py          1.00     10.6Â±0.03ms     3.8 MB/sec    1.00     10.6Â±0.04ms     3.8 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.01      2.9Â±0.00ms     5.7 MB/sec    1.00      2.9Â±0.01ms     5.8 MB/sec
linter/all-rules/numpy/globals.py          1.01    329.9Â±1.06Âµs     8.9 MB/sec    1.00    328.1Â±0.99Âµs     9.0 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.5Â±0.04ms     4.6 MB/sec    1.00      5.5Â±0.04ms     4.6 MB/sec
linter/default-rules/large/dataset.py      1.01      5.6Â±0.01ms     7.2 MB/sec    1.00      5.6Â±0.02ms     7.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1195.3Â±2.96Âµs    13.9 MB/sec    1.00   1197.6Â±3.37Âµs    13.9 MB/sec
linter/default-rules/numpy/globals.py      1.00    123.7Â±0.44Âµs    23.8 MB/sec    1.00    123.6Â±1.59Âµs    23.9 MB/sec
linter/default-rules/pydantic/types.py     1.00      2.5Â±0.01ms    10.1 MB/sec    1.00      2.5Â±0.02ms    10.1 MB/sec
```

#### Windows
```
group                                      main                                    pr
-----                                      ----                                    --
formatter/large/dataset.py                 1.01      4.5Â±0.31ms     9.0 MB/sec     1.00      4.5Â±0.25ms     9.0 MB/sec
formatter/numpy/ctypeslib.py               1.01   894.6Â±45.91Âµs    18.6 MB/sec     1.00   882.4Â±42.19Âµs    18.9 MB/sec
formatter/numpy/globals.py                 1.00     92.0Â±7.05Âµs    32.1 MB/sec     1.02     93.5Â±7.71Âµs    31.6 MB/sec
formatter/pydantic/types.py                1.00  1797.1Â±115.03Âµs    14.2 MB/sec    1.03  1851.1Â±111.61Âµs    13.8 MB/sec
linter/all-rules/large/dataset.py          1.00     15.1Â±0.48ms     2.7 MB/sec     1.02     15.4Â±0.67ms     2.6 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.2Â±0.16ms     4.0 MB/sec     1.04      4.3Â±0.23ms     3.9 MB/sec
linter/all-rules/numpy/globals.py          1.00   537.8Â±25.25Âµs     5.5 MB/sec     1.02   546.9Â±26.88Âµs     5.4 MB/sec
linter/all-rules/pydantic/types.py         1.00      7.8Â±0.29ms     3.3 MB/sec     1.05      8.2Â±0.52ms     3.1 MB/sec
linter/default-rules/large/dataset.py      1.00      8.4Â±0.28ms     4.8 MB/sec     1.00      8.4Â±0.30ms     4.8 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1794.2Â±76.48Âµs     9.3 MB/sec     1.01  1803.3Â±92.73Âµs     9.2 MB/sec
linter/default-rules/numpy/globals.py      1.01   220.2Â±12.23Âµs    13.4 MB/sec     1.00    218.0Â±8.44Âµs    13.5 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.7Â±0.14ms     6.9 MB/sec     1.01      3.8Â±0.16ms     6.8 MB/sec
```
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

---

_Label `formatter` added by @konstin on 2023-08-14 18:53_

---

_Marked ready for review by @MichaReiser on 2023-09-02 07:49_

---

_Label `performance` added by @MichaReiser on 2023-09-02 08:50_

---

_Review requested from @konstin by @MichaReiser on 2023-09-05 08:21_

---

_Review comment by @konstin on `crates/ruff_formatter/src/format_element.rs`:429 on 2023-09-05 10:38_

can you add a static assert for its (or the entire text elements) size?

---

_Review comment by @konstin on `crates/ruff_formatter/src/format_element.rs`:412 on 2023-09-05 10:43_

What about `NonZeroU32::MIN.saturating_add(width)` or `NonZerou32::new(1).unwrap().saturating_add(width)`?

---

_Review comment by @konstin on `crates/ruff_formatter/src/format_element.rs`:412 on 2023-09-05 10:44_

please add a comment about the +1/-1 trickery in general

---

_Review comment by @konstin on `crates/ruff_formatter/src/format_element.rs`:443 on 2023-09-05 10:45_

When does `c` not have a width and why would we go with 0 instead, is this about control characters?

---

_Review comment by @konstin on `crates/ruff_formatter/src/printer/mod.rs`:1111 on 2023-09-05 10:47_

it's inconsistent that it's once `width` and once `text_width`, both in a `Text`

---

_Review comment by @konstin on `crates/ruff_formatter/src/printer/mod.rs`:1343 on 2023-09-05 10:50_

nit: i think i'd use a match here

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/comments/format.rs`:375 on 2023-09-05 10:52_

```suggestion
            let width = 2 + TextWidth::from_text(&normalized_comment, f.options().tab_width())
                .width()
                .expect("Expected comment not to contain any newlines");
```
more intuitive for me because it's first the two spaces and then the comment. maybe even `"  ".text_len()`.

---

_@konstin approved on 2023-09-05 10:52_

---

_Comment by @konstin on 2023-09-05 10:53_

Sorry i had missed this PR.

I'll try to trigger codspeed for perf numbers.

---

_Closed by @konstin on 2023-09-05 10:53_

---

_Reopened by @konstin on 2023-09-05 10:53_

---

_Comment by @MichaReiser on 2023-09-05 10:56_

> Sorry i had missed this PR.
> 
> I'll try to trigger codspeed for perf numbers.

Code speed only comments on regressions but you can see the results in the run summary https://github.com/astral-sh/ruff/pull/6552/checks?check_run_id=16438240046

---

_Comment by @konstin on 2023-09-05 10:56_

![image](https://github.com/astral-sh/ruff/assets/6826232/1d300b39-f5f8-4be6-a43a-f9540c984910)
 3-12%, that's huge!

---

_@MichaReiser reviewed on 2023-09-06 06:59_

---

_Review comment by @MichaReiser on `crates/ruff_formatter/src/printer/mod.rs`:1343 on 2023-09-06 06:59_

Me too but our pedantic clippy rule doesn't allow me to

---

_@MichaReiser reviewed on 2023-09-06 07:01_

---

_Review comment by @MichaReiser on `crates/ruff_formatter/src/format_element.rs`:443 on 2023-09-06 07:01_

From the unicode width documentation

> Returns the character's displayed width in columns, or None if the character is a control character other than '\x00'.

So yes, this is about control characters and using 0 seems reasonable to me (this is the same logic as applied by the printer today)

---

_@MichaReiser reviewed on 2023-09-06 07:02_

---

_Review comment by @MichaReiser on `crates/ruff_formatter/src/format_element.rs`:414 on 2023-09-06 07:02_

I added this newtype wrapper to lock down the access to the inner `NonZeroU32`. Not that someone uses it and then gets values that are off by one. 

---

_Comment by @MichaReiser on 2023-09-06 07:05_

> ![image](https://user-images.githubusercontent.com/6826232/265675563-1d300b39-f5f8-4be6-a43a-f9540c984910.png) 3-12%, that's huge!

The win is bigger for formats that

a) Use more groups or best fitting elements because the printer has to measure `fits` for every group (there's some optimisation but the worst case scenario is that it computes it for every group)
b) Code that has many lines exceeding the line width (with nested groups), because the printer than has to measure fits for every inner group





---

_Merged by @MichaReiser on 2023-09-06 07:10_

---

_Closed by @MichaReiser on 2023-09-06 07:10_

---

_Branch deleted on 2023-09-06 07:10_

---
