<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Unify `Type::is_subtype_of()` and `Type::is_assignable_to()` - astral-sh/ruff #18430</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Unify <code>Type::is_subtype_of()</code> and <code>Type::is_assignable_to()</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18430">#18430</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-06-02 14:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>There's lots of duplication between <code>Type::is_subtype_of()</code> and <code>Type::is_assignable_to()</code>, and we've had multiple bugs in the past because we've remembered to update <code>Type::is_subtype_of()</code> but have not realised that <code>Type::is_assignable_to()</code> also needed to be updated. This PR unifies the two methods: they are now both thin wrappers over a <code>Type::has_assignability_relation</code> method.</p>
<h2>Test Plan</h2>
<ul>
<li>Existing tests</li>
<li>New tests.<ul>
<li>Some of these cover latent bugs that were accidentally fixed in this refactor</li>
<li>Some of them cover bugs that early versions of this PR introduced but were revealed by mypy_primer and have since been fixed.</li>
</ul>
</li>
<li>Property tests</li>
<li>mypy_primer</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-06-02 14:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-02 14:53</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">aioredis (https://github.com/aio-libs/aioredis)
- error[invalid-parameter-default] aioredis/connection.py:1541:9: Default value of type `&lt;class 'LifoQueue'&gt;` is not assignable to annotated parameter type `type[Queue]`
- Found 26 diagnostics
+ Found 25 diagnostics

graphql-core (https://github.com/graphql-python/graphql-core)
+ error[invalid-assignment] src/graphql/execution/execute.py:180:5: Object of type `staticmethod` is not assignable to `(Any, /) -&gt; bool`
- Found 440 diagnostics
+ Found 441 diagnostics

pydantic (https://github.com/pydantic/pydantic)
+ error[invalid-assignment] pydantic/json_schema.py:1681:9: Object of type `Any | list[Any]` is not assignable to `ConfigDict`
- Found 761 diagnostics
+ Found 762 diagnostics

hydra-zen (https://github.com/mit-ll-responsible-ai/hydra-zen)
- error[invalid-argument-type] src/hydra_zen/structured_configs/_implementations.py:2952:54: Argument to function `parse_strict_dataclass_options` is incorrect: Expected `Mapping[str, Any]`, found `DataclassOptions`
- error[invalid-argument-type] src/hydra_zen/structured_configs/_implementations.py:3229:21: Argument is incorrect: Expected `InitVar[ZenConvert | None]`, found `ZenConvert`
- error[invalid-argument-type] src/hydra_zen/structured_configs/_implementations.py:3241:21: Argument is incorrect: Expected `InitVar[ZenConvert | None]`, found `ZenConvert`
- error[invalid-argument-type] src/hydra_zen/structured_configs/_implementations.py:3311:13: Argument to function `parse_strict_dataclass_options` is incorrect: Expected `Mapping[str, Any]`, found `DataclassOptions`
- Found 613 diagnostics
+ Found 609 diagnostics

pwndbg (https://github.com/pwndbg/pwndbg)
- error[invalid-assignment] pwndbg/dbg/lldb/repl/readline.py:24:9: Object of type `(*args) -&gt; Unknown` is not assignable to attribute `set_completion_display_matches_hook` on type `&lt;module 'readline'&gt; &amp; ~&lt;Protocol with members 'set_completion_display_matches_hook'&gt;`
- Found 2301 diagnostics
+ Found 2300 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- error[invalid-argument-type] static_frame/test/property/test_archive_npy.py:36:13: Argument to function `get_frame` is incorrect: Expected `type[Index]`, found `&lt;class 'IndexDate'&gt;`
- error[invalid-argument-type] static_frame/test/property/test_archive_npy.py:38:13: Argument to function `get_frame` is incorrect: Expected `type[Index]`, found `&lt;class 'IndexDate'&gt;`
- error[invalid-argument-type] static_frame/test/property/test_index.py:22:25: Argument to function `property_values` is incorrect: Expected `type[Index]`, found `&lt;class 'IndexGO'&gt;`
- error[invalid-argument-type] static_frame/test/property/test_index.py:34:25: Argument to function `property_values` is incorrect: Expected `type[Index]`, found `&lt;class 'IndexGO'&gt;`
- error[invalid-argument-type] static_frame/test/property/test_index.py:46:38: Argument to function `property_loc_to_iloc_element` is incorrect: Expected `type[Index]`, found `&lt;class 'IndexGO'&gt;`
- error[invalid-argument-type] static_frame/test/property/test_index.py:63:36: Argument to function `property_loc_to_iloc_slice` is incorrect: Expected `type[Index]`, found `&lt;class 'IndexGO'&gt;`
- Found 1931 diagnostics
+ Found 1925 diagnostics

pytest (https://github.com/pytest-dev/pytest)
- error[invalid-argument-type] testing/typing_checks.py:48:25: Argument to bound method `setitem` is incorrect: Expected `Mapping[Literal[&quot;x&quot;], Literal[2]]`, found `Foo`
- error[invalid-argument-type] testing/typing_checks.py:49:25: Argument to bound method `delitem` is incorrect: Expected `Mapping[Literal[&quot;y&quot;], Unknown]`, found `Foo`
- Found 778 diagnostics
+ Found 776 diagnostics

discord.py (https://github.com/Rapptz/discord.py)
- error[invalid-argument-type] discord/message.py:2436:40: Argument to bound method `from_dict` is incorrect: Expected `Mapping[str, Any]`, found `Embed`
+ warning[unused-ignore-comment] discord/state.py:1151:70: Unused blanket `type: ignore` directive

meson (https://github.com/mesonbuild/meson)
- error[invalid-argument-type] mesonbuild/interpreter/interpreter.py:3398:50: Argument to function `extract_as_list` is incorrect: Expected `dict[Literal[&quot;dependencies&quot;], Unknown]`, found `Executable | StaticLibrary | SharedLibrary | SharedModule | Jar`
- error[invalid-argument-type] mesonbuild/modules/gnome.py:2223:56: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'CustomTargetHolder'&gt;`
- error[invalid-argument-type] mesonbuild/modules/gnome.py:2224:62: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'CustomTargetHolder'&gt;`
- error[invalid-argument-type] mesonbuild/modules/gnome.py:2225:50: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'CustomTargetHolder'&gt;`
- error[invalid-argument-type] mesonbuild/modules/gnome.py:2226:54: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'CustomTargetHolder'&gt;`
- error[invalid-argument-type] mesonbuild/modules/gnome.py:2227:51: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'CustomTargetHolder'&gt;`
- error[invalid-argument-type] mesonbuild/modules/hotdoc.py:485:53: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'HotdocTargetHolder'&gt;`
- error[invalid-argument-type] mesonbuild/modules/python.py:160:45: Argument to function `extract_as_list` is incorrect: Expected `dict[Literal[&quot;dependencies&quot;], Unknown]`, found `ExtensionModuleKw`
- error[invalid-argument-type] mesonbuild/modules/python.py:180:51: Argument to function `extract_as_list` is incorrect: Expected `dict[Literal[&quot;c_args&quot;], Unknown]`, found `ExtensionModuleKw`
- error[invalid-argument-type] mesonbuild/modules/python.py:184:53: Argument to function `extract_as_list` is incorrect: Expected `dict[Literal[&quot;cpp_args&quot;], Unknown]`, found `ExtensionModuleKw`
- error[invalid-argument-type] mesonbuild/modules/python.py:209:58: Argument to function `extract_as_list` is incorrect: Expected `dict[Literal[&quot;link_args&quot;], Unknown]`, found `ExtensionModuleKw`
- error[invalid-argument-type] mesonbuild/modules/python.py:558:62: Argument to bound method `append_holder_map` is incorrect: Expected `type[ObjectHolder]`, found `&lt;class 'PythonInstallation'&gt;`
- Found 1322 diagnostics
+ Found 1310 diagnostics

openlibrary (https://github.com/internetarchive/openlibrary)
- error[invalid-argument-type] openlibrary/core/lists/model.py:465:27: Argument to bound method `__init__` is incorrect: Expected `Thing | str | AnnotatedSeed`, found `str | ThingReferenceDict | AnnotatedSeedDict`
- Found 726 diagnostics
+ Found 725 diagnostics

aiohttp (https://github.com/aio-libs/aiohttp)
- error[invalid-raise] aiohttp/connector.py:1164:19: Cannot raise object of type `ClientConnectorCertificateError` (must be a `BaseException` subclass or instance)
- error[invalid-raise] aiohttp/connector.py:1166:19: Cannot raise object of type `ClientConnectorSSLError` (must be a `BaseException` subclass or instance)
- error[invalid-raise] aiohttp/connector.py:1273:19: Cannot raise object of type `ClientConnectorCertificateError` (must be a `BaseException` subclass or instance)
- error[invalid-raise] aiohttp/connector.py:1275:19: Cannot raise object of type `ClientConnectorSSLError` (must be a `BaseException` subclass or instance)
- Found 178 diagnostics
+ Found 174 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
+ warning[unused-ignore-comment] src/prefect/utilities/callables.py:321:67: Unused blanket `type: ignore` directive
- Found 4482 diagnostics
+ Found 4483 diagnostics

zulip (https://github.com/zulip/zulip)
- error[invalid-assignment] corporate/lib/remote_billing_util.py:155:5: Object of type `RemoteBillingIdentityDict | LegacyServerIdentityDict | None` is not assignable to `LegacyServerIdentityDict | None`
- error[invalid-argument-type] corporate/views/upgrade.py:222:66: Argument to function `render` is incorrect: Expected `Mapping[str, Any] | None`, found `UpgradePageContext | None`
- error[invalid-argument-type] corporate/views/upgrade.py:257:66: Argument to function `render` is incorrect: Expected `Mapping[str, Any] | None`, found `UpgradePageContext | None`
- error[invalid-argument-type] corporate/views/upgrade.py:292:66: Argument to function `render` is incorrect: Expected `Mapping[str, Any] | None`, found `UpgradePageContext | None`
- error[invalid-argument-type] zerver/actions/message_delete.py:94:33: Argument to function `send_event_on_commit` is incorrect: Expected `Mapping[str, Any]`, found `DeleteMessagesEvent`
- error[invalid-argument-type] zerver/actions/message_edit.py:864:33: Argument to function `send_event_on_commit` is incorrect: Expected `Mapping[str, Any]`, found `DeleteMessagesEvent`
- error[invalid-argument-type] zerver/views/users.py:888:34: Argument to function `json_success` is incorrect: Expected `Mapping[str, Any]`, found `APIUserDict`
- Found 6933 diagnostics
+ Found 6926 diagnostics

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-06-03 13:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @AlexWaygood on 2025-06-03 13:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-03 18:05</div>
            <div class="timeline-body"><blockquote>
<pre><code class="language-diff">+ error[invalid-assignment] src/graphql/execution/execute.py:180:5: Object of type `staticmethod` is not assignable to `(Any, /) -&gt; bool`
</code></pre>
</blockquote>
<p>I'm not totally sure why this diagnostic is being added by this PR. Note that <code>staticmethod.__call__</code> was added in Python 3.10; I'm not sure what Python version we're inferring for this project in CI. I do know that we don't really understand the stub for <code>builtins.staticmethod</code> at all right now, because of the fact that it's generic over a legacy <code>ParamSpec</code>, which seems to do quite odd things to our inference (we don't even think that's valid right now).</p>
<blockquote>
<pre><code class="language-diff">- error[invalid-assignment] pwndbg/dbg/lldb/repl/readline.py:24:9: Object of type `(*args) -&gt; Unknown` is not assignable to attribute `set_completion_display_matches_hook` on type `&lt;module 'readline'&gt; &amp; ~&lt;Protocol with members 'set_completion_display_matches_hook'&gt;`
</code></pre>
</blockquote>
<p>This error goes away because we now infer the type of the module <code>readline</code> in this branch as being <code>Never</code>, since we know that the module <code>readline</code> always has a <code>set_completion_display_matches_hook</code> attribute:</p>
<pre><code class="language-py">import readline

if not hasattr(readline, 'set_completion_display_matches_hook'):
    reveal_type(readline)
</code></pre>
<p>This seems like we're doing a better job now according to the information we've been given from typeshed's stubs.</p>
<blockquote>
<pre><code class="language-diff">+ warning[possibly-unbound-attribute] ddtrace/propagation/_database_monitoring.py:74:51: Attribute `tracer` on type `&lt;module 'ddtrace'&gt;` is possibly unbound
+ warning[possibly-unbound-attribute] ddtrace/propagation/_database_monitoring.py:76:17: Attribute `tracer` on type `&lt;module 'ddtrace'&gt;` is possibly unbound
</code></pre>
</blockquote>
<p>This is a pre-existing bug: https://github.com/astral-sh/ty/issues/578. The reason it's showing up now is that we didn't previously ever consider module-literal types to be subtypes of protocol-instance types, but now we do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2025-06-03 18:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-06-03 18:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-06-03 18:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2025-06-03 18:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-03 18:07</div>
            <div class="timeline-body"><p>(I don't love the name <code>Type::has_assignability_relation</code>. Better suggestions are welcome!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jelle-openai">@jelle-openai</a> on 2025-06-03 18:37</div>
            <div class="timeline-body"><p>Did you steal this from https://github.com/JelleZijlstra/pycroscope/blob/385397ac151199638c65d298997fd8298eb1abb2/pycroscope/relations.py#L154</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-03 18:40</div>
            <div class="timeline-body"><p>great minds think alike ðŸ˜œ</p>
<p>in all seriousness, though -- no, I hadn't seen that before writing this!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/intersection_types.md</code>:318 on 2025-06-03 19:00</div>
            <div class="timeline-body"><p><code>S</code> doesn't seem to be used?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1512 on 2025-06-03 19:08</div>
            <div class="timeline-body"><p>very nit: I feel like <code>has_assignability_relation</code> should appear after <code>is_assignable_to</code>. That mimics the pattern in a couple of other places, where the two methods that use the helper are defined before the helper.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1073 on 2025-06-03 19:11</div>
            <div class="timeline-body"><p>nit: Could this move into an <code>AssignabilityPolicy::is_equivalent_to</code> method? That would be nicely symmetric with the <code>is_satisfied_by</code> check above</p>
<pre><code class="language-suggestion">        if policy.is_equivalent_to(db, self, target) {
            return true;
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1194 on 2025-06-03 19:12</div>
            <div class="timeline-body"><p>Should <code>FunctionType</code> (and <code>Signature</code>) get the new refactored methods too?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1253 on 2025-06-03 19:13</div>
            <div class="timeline-body"><p>ditto for <code>ProtocolInstanceType</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1307 on 2025-06-03 19:13</div>
            <div class="timeline-body"><p>ditto <code>CallableType</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1352 on 2025-06-03 19:14</div>
            <div class="timeline-body"><p>Is &quot;gradual equivalent&quot; correct here, or should this call equivalent/gradual-equivalent based on the policy? (If so, and if you factor that our into an <code>AssignabilityPolicy</code> per above then you won't have to copy/paste the match here)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1347 on 2025-06-03 19:15</div>
            <div class="timeline-body"><p>I don't disagree, but is this just so that you don't have to perform a similar refactoring on <code>ClassType</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1403 on 2025-06-03 19:15</div>
            <div class="timeline-body"><p>Should this be <code>has_assignability_relation_to</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1493 on 2025-06-03 19:16</div>
            <div class="timeline-body"><p>ditto <code>NominalInstanceType</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-06-03 19:17</div>
            <div class="timeline-body"><p>I love this overall! My main questions are about whether we should go all the way and add <code>has_assignability_relation_to</code> to all of the subsidiary <code>Type</code> types</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-03 19:29</div>
            <div class="timeline-body"><blockquote>
<p>I love this overall! My main questions are about whether we should go all the way and add <code>has_assignability_relation_to</code> to all of the subsidiary <code>Type</code> types</p>
</blockquote>
<p>I think we should! I deliberately held off from that here though, as it was already a large change that was tricky to get right, and I didn't want to make it harder to review. I <em>can</em> make that change as part of this PR, but I feel like I'd prefer to do it as a followup?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-06-03 20:00</div>
            <div class="timeline-body"><blockquote>
<p>I think we should! I deliberately held off from that here though, as it was already a large change that was tricky to get right, and I didn't want to make it harder to review. I <em>can</em> make that change as part of this PR, but I feel like I'd prefer to do it as a followup?</p>
</blockquote>
<p>I have a slight preference for doing it all in one PR, though I'm happy to defer to you as the person doing the work! (It's a bit easier to turn off my brain and look for ~every call site to become <code>has_assignability_relation</code>, instead of having to decide for each hunk what the right change should be.)</p>
<p>Also note that <code>Signature</code> is already refactored like this (though it takes in a callback closure not the new enum), so it might not be as much extra effort.</p>
<p>But again, happy to defer to you!</p>
<blockquote>
<p>(I don't love the name <code>Type::has_assignability_relation</code>. Better suggestions are welcome!)</p>
</blockquote>
<p>It's called <code>is_assignable_to_impl</code> in <code>Signature</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/0079cc6817d070ff42bfc568c6652e260485983b/crates/ty_python_semantic/src/types/signatures.rs#L127</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/intersection_types.md</code>:333 on 2025-06-03 20:23</div>
            <div class="timeline-body"><p>I think the right answer here depends on variance.</p>
<p>We might infer the current definition of <code>R</code> as bivariant in <code>T</code> (since <code>T</code> is unused in the body of <code>R</code>), and given that, <code>R[P]</code> and <code>R[Q]</code> are equivalent, so this should perhaps simplify to <code>Never</code>? But it would probably be fine if we didn't consider that, since bivariance is not common.</p>
<p>If <code>R</code> is invariant in <code>T</code>, then <code>R[P]</code> and <code>R[Q]</code> are disjoint and this should simplify to just <code>R[P]</code>.</p>
<p>If <code>R</code> is covariant or contravariant in <code>T</code>, then I think the unsimplified answer you have here is correct; <code>R[P]</code> and <code>R[Q]</code> are not disjoint.</p>
<p>(Not suggesting any of this needs to be done in this PR, but I think we could either add a comment here, or make these tests use explicit variance legacy typevars instead; if the test used an explicitly covariant typevar, then this wouldn't require comment.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/intersection_types.md</code>:363 on 2025-06-03 20:27</div>
            <div class="timeline-body"><p>Similar to above, this depends on variance. If bivariant (as the current definition of <code>R</code> would be) this is <code>object</code>; if invariant it should simplify to <code>~R[Q]</code>, if covariant or contravariant it should stay unsimplified.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1051 on 2025-06-03 20:37</div>
            <div class="timeline-body"><p>Naming nit: the current naming approach in this PR (both in the name <code>has_assignability_relation_to</code> and the name <code>AssignabilityPolicy::OnlyFullyStatic</code>) is to mostly stop using the term &quot;subtype&quot;, and instead treat subtyping as &quot;assignability, but for fully static types.&quot;</p>
<p>I don't prefer that naming, both because it strays further from the typing spec (in type theory terms, subtyping is the more fundamental relation), and because we don't use subtyping when actually assigning something to something else (so it is never used directly to determine &quot;assignability&quot; in any context).</p>
<p>How would you feel about naming the enum <code>TypeRelation</code> (with variants <code>TypeRelation::Subtype</code> and <code>TypeRelation::Assignable</code>), and the method <code>has_relation_to</code>? I realize the method and the enum wouldn't (for now at least) cover <em>all</em> relations, but I don't think that's a strong argument against the naming?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-03 20:49</div>
            <div class="timeline-body"><p>This is awesome!</p>
<p>Not taking the time to do a full detailed review, since @dcreager is on it; just a few comments on the tests, and on naming.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-03 21:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/intersection_types.md</code>:333 on 2025-06-03 21:18</div>
            <div class="timeline-body"><p>Thanks, great point â€” I'll switch to using legacy typevars for now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-03 21:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1051 on 2025-06-03 21:19</div>
            <div class="timeline-body"><p>That all SGTM, I'm happy to make that change!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-04 12:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1347 on 2025-06-04 12:43</div>
            <div class="timeline-body"><p>Hmm, I don't think so -- we're comparing between two different variants here rather than between two instances of the same variant</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-04 13:26</div>
            <div class="timeline-body"><p>Okay, I think that's all the review comments addressed! There are still one or two <code>Type::is_subtype_of</code> and <code>Type::is_assignable_to</code> methods on this branch that are not thin wrappers around <code>Type::has_relation_to</code> methods. But I'm unwilling to make further refactors as part of <em>this PR</em>, since some of these methods are in areas of ty's codebase that I'm not an expert in (e.g. signature subtyping).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2025-06-04 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-06-04 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-06-05 06:25</div>
            <div class="timeline-body"><blockquote>
<p>But I'm unwilling to make further refactors as part of <em>this PR</em>, since some of these methods are in areas of ty's codebase that I'm not an expert in (e.g. signature subtyping).</p>
</blockquote>
<p>I'm happy to take this up as a follow-up unless someone else is interested in this :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6755 on 2025-06-05 06:30</div>
            <div class="timeline-body"><p>nit: this isn't a large method so feel free to ignore but I was wondering whether we should enforce <code>type_1: Type&lt;'db&gt;</code> instead of the <code>Into</code> trait and make the changes at the call side <code>.applies_to(db, self.into(), other.into())</code>. This is mainly to avoid monomorphization of this method to the different combinations of types used with this method.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6768 on 2025-06-05 06:31</div>
            <div class="timeline-body"><p>nit: <code>are_equivalent</code> since the parameter types are <code>Type</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-06-05 06:33</div>
            <div class="timeline-body"><p>I haven't looked too closely as there are already 2 reviewers but a couple of things I noticed while glancing through the changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-05 10:48</div>
            <div class="timeline-body"><blockquote>
<pre><code class="language-diff">+ warning[possibly-unbound-attribute] ddtrace/propagation/_database_monitoring.py:74:51: Attribute `tracer` on type `&lt;module 'ddtrace'&gt;` is possibly unbound
+ warning[possibly-unbound-attribute] ddtrace/propagation/_database_monitoring.py:76:17: Attribute `tracer` on type `&lt;module 'ddtrace'&gt;` is possibly unbound
</code></pre>
<p>This is a pre-existing bug: astral-sh/ty#578. The reason it's showing up now is that we didn't previously ever consider module-literal types to be subtypes of protocol-instance types, but now we do.</p>
</blockquote>
<p>Confirmed that this has now gone from the mypy_primer report following https://github.com/astral-sh/ruff/pull/18466, which fixed astral-sh/ty#578!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-05 16:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1347 on 2025-06-05 16:13</div>
            <div class="timeline-body"><p>I think I now see what you mean -- does https://github.com/astral-sh/ruff/pull/18430/commits/0385c7761e0f7c0050b68e9d0d46c1649af8d668 make the changes you were looking for here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md</code>:226 on 2025-06-06 16:21</div>
            <div class="timeline-body"><p>Should we add some counter-examples here as well? E.g. <code>Foo</code> specializations not being assignable to <code>Bar</code> specializations, and <code>Bar[int]</code> not being assignable to <code>Foo[bool]</code>?</p>
<p>I'm always wary of tests that would pass if everything were just <code>Unknown</code> ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1217 on 2025-06-06 16:37</div>
            <div class="timeline-body"><p>This looks wrong -- shouldn't we be looking up <code>__call__</code> only on the class, not on the instance?</p>
<p>It looks like this pre-exists this PR, and we probably shouldn't add more changes to this PR, but maybe we should add a TODO here, while we're here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1236 on 2025-06-06 16:38</div>
            <div class="timeline-body"><p>This comment looks out of place here, because the logic implementing this comment is inside <code>satisfies_protocol</code>, not here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1392 on 2025-06-06 16:41</div>
            <div class="timeline-body"><p>It doesn't seem right that this pattern is symmetrical, but the <code>has_relation_to</code> check is not symmetrical.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-06-06 16:43</div>
            <div class="timeline-body"><p>This is great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-06 16:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1392 on 2025-06-06 16:50</div>
            <div class="timeline-body"><p>I think this is correct. This branch upholds two properties:</p>
<ul>
<li>For any type <code>T</code> that is assignable to <code>type</code>, <code>T</code> shall be assignable to <code>type[Any]</code>.</li>
<li>For any type <code>T</code> that is assignable to <code>type</code>, <code>type[Any]</code> shall be assignable to <code>T</code>.</li>
</ul>
<p>This is really the same as the very first branch in this <code>match</code> statement that handles dynamic types. That branch upholds two properties:</p>
<ul>
<li>For any type <code>S</code> that is assignable to <code>object</code> (which is <em>all</em> types), <code>S</code> shall be assignable to <code>Any</code></li>
<li>For any type <code>S</code> that is assignable to <code>object</code> (which is <em>all</em> types), <code>Any</code> shall be assignable to <code>S</code>.</li>
</ul>
<p>The only difference between this branch and the first branch is that the first branch deals with the type <code>object &amp; Any</code> (which simplifies to <code>Any</code>!) whereas this branch deals with the type <code>type &amp; Any</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-06 17:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md</code>:226 on 2025-06-06 17:08</div>
            <div class="timeline-body"><p>Ugh, good callout. It turns out all <code>type[SomeSubscript[]]</code> type expressions are still <code>@Todo</code> types for us :-( So most of these are not testing the bug I wanted them to test. Which may not even be testable right now if we currently only ever synthesize these types, and don't yet support reading them from type expressions.</p>
<p>Still, these assertions seem useful to prevent regressions. I'll add the failing counter-examples with TODO comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-06 17:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/is_assignable_to.md</code>:226 on 2025-06-06 17:10</div>
            <div class="timeline-body"><p>hmm, maybe I can test this in a slightly more roundabout way, come to think of it (edit: no, that didn't work either)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-06 17:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1236 on 2025-06-06 17:20</div>
            <div class="timeline-body"><p>no? The logic implementing this comment is the</p>
<pre><code class="language-rs">            (Type::ProtocolInstance(_), _) =&gt; false,
</code></pre>
<p>branch immediately below this comment. The &quot;protocol types can be subtypes of <code>object</code>&quot; special case is handled in this branch higher up:</p>
<pre><code class="language-rs">            (_, Type::NominalInstance(instance)) if instance.class.is_object(db) =&gt; true,
</code></pre>
<p>but the branch immediately below this comment implements the &quot;and it cannot be a subtype of any other nominal type&quot; bit</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-06 17:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1217 on 2025-06-06 17:24</div>
            <div class="timeline-body"><p>this is okay because of the fact that we're passing the <code>NO_INSTANCE_FALLBACK</code> policy:</p>
<p>https://github.com/astral-sh/ruff/blob/1274521f9fda19507921c85442d0ca991b67b846/crates/ty_python_semantic/src/types.rs#L192-L200</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-06-06 17:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1392 on 2025-06-06 17:26</div>
            <div class="timeline-body"><p>I added this explanation as a comment in https://github.com/astral-sh/ruff/pull/18430/commits/40e68d09ef8b9a88fbdb173f34dd387360f07c83</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-06-06 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-06-06 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-06-06 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-07 01:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1217 on 2025-06-07 01:56</div>
            <div class="timeline-body"><p>Ah right, I forgot the details of how this works</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @dhruvmanila on 2025-06-11 10:51</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:13:05 UTC
    </footer>
</body>
</html>
