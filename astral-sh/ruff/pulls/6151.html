<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Call chain formatting in fluent style - astral-sh/ruff #6151</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Call chain formatting in fluent style</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/6151">#6151</a>
        opened by <a href="https://github.com/konstin">@konstin</a>
        on 2023-07-28 13:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/konstin">@konstin</a> on 2023-07-28 13:19</div>
            <div class="timeline-body"><p>Implement fluent style/call chains. See the <code>call_chains.py</code> formatting for examples.</p>
<p>This isn't fully like black because in <code>raise A from B</code> they allow <code>A</code> breaking can influence the formatting of <code>B</code> even if it is already multiline.</p>
<p>Similarity index:</p>
<p>| project      | main  | PR    |
|--------------|-------|-------|
| build        | ???   | 0.753 |
| django       | 0.991 | 0.998 |
| transformers | 0.993 | 0.994 |
| typeshed     | 0.723 | 0.723 |
| warehouse    | 0.978 | 0.994 |
| zulip        | 0.992 | 0.994 |</p>
<p>Call chain formatting is affected by https://github.com/astral-sh/ruff/issues/627, but i'm cutting scope here.</p>
<p>Closes #5343</p>
<p><strong>Test Plan</strong>:</p>
<ul>
<li>Added a dedicated call chains test file</li>
<li>The ecosystem checks found some bugs</li>
<li>I manually check django and zulip formatting</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-07-28 13:19</div>
            <div class="timeline-body"><p>Current dependencies on/for this PR:</p>
<ul>
<li>main<ul>
<li><strong>PR #6151</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/6151" target="_blank"><img src="https://static.graphite.dev/graphite-32x32.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ</li>
</ul>
</li>
</ul>
<p>This comment was auto-generated by <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/6151?utm_source=stack-comment">Graphite</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-07-28 13:51</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      9.3Â±0.02ms     4.4 MB/sec    1.11     10.3Â±0.09ms     3.9 MB/sec
formatter/numpy/ctypeslib.py               1.00   1885.3Â±8.59Âµs     8.8 MB/sec    1.06      2.0Â±0.01ms     8.3 MB/sec
formatter/numpy/globals.py                 1.02   231.6Â±14.37Âµs    12.7 MB/sec    1.00    226.2Â±7.00Âµs    13.0 MB/sec
formatter/pydantic/types.py                1.00      4.0Â±0.03ms     6.3 MB/sec    1.06      4.3Â±0.04ms     6.0 MB/sec
linter/all-rules/large/dataset.py          1.00     13.1Â±0.10ms     3.1 MB/sec    1.02     13.3Â±0.14ms     3.1 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.3Â±0.02ms     5.0 MB/sec    1.01      3.4Â±0.01ms     5.0 MB/sec
linter/all-rules/numpy/globals.py          1.00    458.6Â±0.76Âµs     6.4 MB/sec    1.00    457.8Â±1.70Âµs     6.4 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.0Â±0.05ms     4.3 MB/sec    1.01      6.0Â±0.02ms     4.2 MB/sec
linter/default-rules/large/dataset.py      1.00      6.5Â±0.24ms     6.3 MB/sec    1.05      6.8Â±0.04ms     6.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1356.7Â±7.79Âµs    12.3 MB/sec    1.05   1428.3Â±6.01Âµs    11.7 MB/sec
linter/default-rules/numpy/globals.py      1.01    159.5Â±7.98Âµs    18.5 MB/sec    1.00    157.3Â±0.61Âµs    18.8 MB/sec
linter/default-rules/pydantic/types.py     1.00      2.8Â±0.02ms     9.0 MB/sec    1.05      3.0Â±0.03ms     8.5 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00     10.4Â±0.13ms     3.9 MB/sec    1.06     11.1Â±0.11ms     3.7 MB/sec
formatter/numpy/ctypeslib.py               1.00  1974.8Â±38.30Âµs     8.4 MB/sec    1.04      2.0Â±0.04ms     8.1 MB/sec
formatter/numpy/globals.py                 1.00   222.4Â±10.07Âµs    13.3 MB/sec    1.02    225.9Â±8.00Âµs    13.1 MB/sec
formatter/pydantic/types.py                1.00      4.3Â±0.07ms     5.9 MB/sec    1.03      4.5Â±0.06ms     5.7 MB/sec
linter/all-rules/large/dataset.py          1.00     14.7Â±0.16ms     2.8 MB/sec    1.01     14.8Â±0.16ms     2.8 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.8Â±0.06ms     4.4 MB/sec    1.03      3.9Â±0.06ms     4.3 MB/sec
linter/all-rules/numpy/globals.py          1.00    452.9Â±8.58Âµs     6.5 MB/sec    1.02    462.0Â±6.85Âµs     6.4 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.7Â±0.09ms     3.8 MB/sec    1.01      6.8Â±0.10ms     3.8 MB/sec
linter/default-rules/large/dataset.py      1.00      7.3Â±0.11ms     5.6 MB/sec    1.08      7.9Â±0.15ms     5.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1470.6Â±26.20Âµs    11.3 MB/sec    1.07  1568.9Â±21.62Âµs    10.6 MB/sec
linter/default-rules/numpy/globals.py      1.00    165.7Â±3.23Âµs    17.8 MB/sec    1.08    178.2Â±5.09Âµs    16.6 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.2Â±0.08ms     7.9 MB/sec    1.07      3.4Â±0.08ms     7.4 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Fluent style" to "Call chain formatting in fluent style" by @konstin on 2023-07-30 12:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @konstin on 2023-07-31 07:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @konstin on 2023-07-31 07:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-07-31 07:54</div>
            <div class="timeline-body"><p>Blocked on unstable formatting of</p>
<pre><code class="language-python">y = (
    x.a()  #
    .b()
)

y = x.a().b()  #

y = (
    x.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()  #
    .b()
)

y = x.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa().b()  #
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @konstin on 2023-08-02 12:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @konstin on 2023-08-02 12:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/parentheses.rs</code>:77 on 2023-08-03 08:54</div>
            <div class="timeline-body"><p><code>FluentStyle</code> doesn't fit well into the <code>Parentheses</code> concept, which is intended to be generally applicable to all expressions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-08-03 09:00</div>
            <div class="timeline-body"><p>Woah, nice improvement on the compatibility!</p>
<p>The fluent style formatting now requires to route through the fluent style in many positions (which I like more than setting in on context).</p>
<p>Have you considered to, instead &quot;unroll&quot; the call chain in the <code>CallExpression</code> formatting? Meaning, we would have a single formatting that owns the whole call chain formatting without calling into format attribute and format subscript (maybe parts of it). I'm asking because I find it difficult to &quot;unroll&quot; the recursion in my head and wonder if it would be easier if the whole call chain formatting would be in its own file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-08-03 12:14</div>
            <div class="timeline-body"><p>Good point, i made fluent style a bool that gets passed through the call chain formatting. It's still recursive but i think that's better than unrolling</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-08-03 13:01</div>
            <div class="timeline-body"><p>This took some rotations but now it's just a <code>is_fluent_style_call_chain</code> function we call when formatting an expression. There is still a case we miss (<code>not a().b().c()</code>), but i'm happy how it looks now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-08-03 13:04</div>
            <div class="timeline-body"><blockquote>
<p>Good point, i made fluent style a bool that gets passed through the call chain formatting. It's still recursive but i think that's better than unrolling</p>
</blockquote>
<p>Could you explain your reasoning of why?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:201 on 2023-08-03 13:21</div>
            <div class="timeline-body"><p>As far as I know, <code>maybe_parenthesize</code> is only used on statement level</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_attribute.rs</code>:16 on 2023-08-03 13:22</div>
            <div class="timeline-body"><p>Can we use a <code>MemberLayout</code> type instead with <code>Default</code> and <code>Fluent</code> variants? It's otherwise difficult to understand what <code>with_options(true)</code> means.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:71 on 2023-08-03 13:25</div>
            <div class="timeline-body"><p>Is this still necessary here? It seems that <code>Call</code>, <code>Attribute</code> and <code>Subscript</code> now by-pass the <code>Expr</code> formatting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:188 on 2023-08-03 13:29</div>
            <div class="timeline-body"><p>Would it be possible to remove the code from here if:</p>
<ul>
<li>Replace the <code>boolean</code> option with an enum that has three variants:<ul>
<li><code>Fluent</code></li>
<li><code>NonFluent</code>: Left side of a call chain, but we don't use the fluent style</li>
<li><code>Root</code>: The root of a fluent chain (default)</li>
</ul>
</li>
<li><code>CallExpression</code> tests if it is inside of a fluent chain if the variant is <code>Root</code>. (or any node that can be the end of a call chain). If so, use <code>Fluent</code>, otherwise<code> NonFluent</code></li>
<li><code>Subscript</code>, <code>Call</code>, or <code>Attribute</code> wrap their content in a <code>group</code> if the layout is <code>Fluent</code>.</li>
<li>Change <code>can_omit_parentheses</code> to return <code>false</code> for call chains.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-08-03 13:29</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>Good point, i made fluent style a bool that gets passed through the call chain formatting. It's still recursive but i think that's better than unrolling</p>
</blockquote>
<p>Could you explain your reasoning of why?</p>
</blockquote>
<p>I think consistency, mainly: Every other expression is formatted from outermost to innermost, so this is no difference. The main thing we do differently is to put a newline between the closing parentheses and the dot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-08-03 13:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-08-03 19:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:201 on 2023-08-03 19:13</div>
            <div class="timeline-body"><p>it's unreachable with the check now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-08-03 19:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_formatter/src/expression/expr_attribute.rs</code>:16 on 2023-08-03 19:13</div>
            <div class="timeline-body"><p>good idea</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:71 on 2023-08-03 20:08</div>
            <div class="timeline-body"><p>I spent way to much time trying to come up with something better, but i'm afraid the answer is yes. I think the node level is the biggest problem here because e.g. just inlining helpers doesn't seem to work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-08-03 20:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:188 on 2023-08-03 20:25</div>
            <div class="timeline-body"><p>I don't think i really follow; Call chains can appear about everywhere except on statement level. For the MaybeParenthesize it's special because we need to switch parentheses mode, call chain formatting always has parentheses when breaking.</p>
<blockquote>
<p>Change can_omit_parentheses to return false for call chains.</p>
</blockquote>
<p>This is already the case.</p>
<p>Unfortunately I don't understand why exactly the current solution works but the alternatives i tried don't, the interaction of node level, context, parentheses, MaybeParenthesize and FormatExpr or not is still opaque to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-08-03 20:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:553 on 2023-08-04 06:44</div>
            <div class="timeline-body"><p><code>is_expression_parenthesized</code> returns false positives if it is the first argument in a call expression. I guess this is safe because the expression never has <code>attributes_after_parentheses</code> that is larger than 1.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:183 on 2023-08-04 06:47</div>
            <div class="timeline-body"><p>Can we inline the <code>can_omit_optional_parentheses</code> call again to avoid calling it for <code>OptionalParentheses::Always</code> and <code>Never</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:77 on 2023-08-04 07:04</div>
            <div class="timeline-body"><p>I played around with your PR locally, and moving the call chain formatting out of the <code>Expr</code> seems possible. It has the added benefit that we avoid adding unnecessary groups around <code>Subsccript</code> and <code>Attribute</code> accessors</p>
<pre><code class="language-patch">Subject: [PATCH] Move Fluent style out of `Expr` formatting
---
Index: crates/ruff_python_formatter/src/expression/expr_subscript.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_subscript.rs b/crates/ruff_python_formatter/src/expression/expr_subscript.rs
--- a/crates/ruff_python_formatter/src/expression/expr_subscript.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/expr_subscript.rs	(date 1691133618832)
@@ -34,6 +34,17 @@
             ctx: _,
         } = item;
 
+        let call_chain_layout = match self.call_chain_layout {
+            CallChainLayout::Default =&gt; {
+                if f.context().node_level().is_parenthesized() {
+                    CallChainLayout::from_expression(AnyNodeRef::from(item), f.context().source())
+                } else {
+                    CallChainLayout::NonFluent
+                }
+            }
+            layout @ (CallChainLayout::Fluent | CallChainLayout::NonFluent) =&gt; layout,
+        };
+
         let comments = f.context().comments().clone();
         let dangling_comments = comments.dangling_comments(item.as_any_node_ref());
         debug_assert!(
@@ -42,9 +53,9 @@
         );
 
         let format_value = format_with(|f| match value.as_ref() {
-            Expr::Attribute(expr) =&gt; expr.format().with_options(self.call_chain_layout).fmt(f),
-            Expr::Call(expr) =&gt; expr.format().with_options(self.call_chain_layout).fmt(f),
-            Expr::Subscript(expr) =&gt; expr.format().with_options(self.call_chain_layout).fmt(f),
+            Expr::Attribute(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Call(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Subscript(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f),
             _ =&gt; value.format().fmt(f),
         });
 
@@ -91,10 +102,16 @@
     fn needs_parentheses(
         &amp;self,
         _parent: AnyNodeRef,
-        _context: &amp;PyFormatContext,
+        context: &amp;PyFormatContext,
     ) -&gt; OptionalParentheses {
         {
-            OptionalParentheses::Never
+            if CallChainLayout::from_expression(self.into(), context.source())
+                == CallChainLayout::Fluent
+            {
+                OptionalParentheses::Multiline
+            } else {
+                self.value.needs_parentheses(self.into(), context)
+            }
         }
     }
 }
Index: crates/ruff_python_formatter/src/expression/expr_call.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_call.rs b/crates/ruff_python_formatter/src/expression/expr_call.rs
--- a/crates/ruff_python_formatter/src/expression/expr_call.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/expr_call.rs	(date 1691134353539)
@@ -1,6 +1,7 @@
 use crate::expression::CallChainLayout;
 use ruff_formatter::{write, FormatRuleWithOptions};
 use ruff_python_ast::node::AnyNodeRef;
+use ruff_python_ast::Expr::Call;
 use ruff_python_ast::{Expr, ExprCall};
 
 use crate::expression::parentheses::{NeedsParentheses, OptionalParentheses};
@@ -29,14 +30,41 @@
             arguments,
         } = item;
 
-        match func.as_ref() {
-            Expr::Attribute(expr) =&gt; expr.format().with_options(self.call_chain_layout).fmt(f)?,
-            Expr::Call(expr) =&gt; expr.format().with_options(self.call_chain_layout).fmt(f)?,
-            Expr::Subscript(expr) =&gt; expr.format().with_options(self.call_chain_layout).fmt(f)?,
-            _ =&gt; func.format().fmt(f)?,
-        }
+        let call_chain_layout = match self.call_chain_layout {
+            CallChainLayout::Default =&gt; {
+                if f.context().node_level().is_parenthesized() {
+                    CallChainLayout::from_expression(AnyNodeRef::from(item), f.context().source())
+                } else {
+                    CallChainLayout::NonFluent
+                }
+            }
+            layout @ (CallChainLayout::Fluent | CallChainLayout::NonFluent) =&gt; layout,
+        };
+
+        let fmt_inner = format_with(|f| {
+            match func.as_ref() {
+                Expr::Attribute(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f)?,
+                Expr::Call(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f)?,
+                Expr::Subscript(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f)?,
+                _ =&gt; func.format().fmt(f)?,
+            }
 
-        write!(f, [arguments.format()])
+            arguments.format().fmt(f)
+        });
+
+        // Allow to indent the parentheses while
+        // ```python
+        // g1 = (
+        //     queryset.distinct().order_by(field.name).values_list(field_name_flat_long_long=True)
+        // )
+        // ```
+        if call_chain_layout == CallChainLayout::Fluent
+            &amp;&amp; self.call_chain_layout == CallChainLayout::Default
+        {
+            group(&amp;fmt_inner).fmt(f)
+        } else {
+            fmt_inner.fmt(f)
+        }
     }
 }
 
@@ -46,6 +74,12 @@
         _parent: AnyNodeRef,
         context: &amp;PyFormatContext,
     ) -&gt; OptionalParentheses {
-        self.func.needs_parentheses(self.into(), context)
+        if CallChainLayout::from_expression(self.into(), context.source())
+            == CallChainLayout::Fluent
+        {
+            OptionalParentheses::Multiline
+        } else {
+            self.func.needs_parentheses(self.into(), context)
+        }
     }
 }
Index: crates/ruff_python_formatter/src/expression/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/mod.rs b/crates/ruff_python_formatter/src/expression/mod.rs
--- a/crates/ruff_python_formatter/src/expression/mod.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/mod.rs	(date 1691134350626)
@@ -65,17 +65,6 @@
     fn fmt(&amp;self, expression: &amp;Expr, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
         let parentheses = self.parentheses;
 
-        // All expressions that can have parentheses can be in fluent style. We need to exclude top
-        // expressions since they don't get parenthesized
-        let call_chain_layout = if matches!(
-            f.context().node_level(),
-            NodeLevel::CompoundStatement | NodeLevel::TopLevel
-        ) {
-            CallChainLayout::Default
-        } else {
-            CallChainLayout::from_expression(expression, f.context().source())
-        };
-
         let format_expr = format_with(|f| match expression {
             Expr::BoolOp(expr) =&gt; expr.format().with_options(Some(parentheses)).fmt(f),
             Expr::NamedExpr(expr) =&gt; expr.format().fmt(f),
@@ -93,12 +82,12 @@
             Expr::Yield(expr) =&gt; expr.format().fmt(f),
             Expr::YieldFrom(expr) =&gt; expr.format().fmt(f),
             Expr::Compare(expr) =&gt; expr.format().with_options(Some(parentheses)).fmt(f),
-            Expr::Call(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Call(expr) =&gt; expr.format().fmt(f),
             Expr::FormattedValue(expr) =&gt; expr.format().fmt(f),
             Expr::JoinedStr(expr) =&gt; expr.format().fmt(f),
             Expr::Constant(expr) =&gt; expr.format().fmt(f),
-            Expr::Attribute(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f),
-            Expr::Subscript(expr) =&gt; expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Attribute(expr) =&gt; expr.format().fmt(f),
+            Expr::Subscript(expr) =&gt; expr.format().fmt(f),
             Expr::Starred(expr) =&gt; expr.format().fmt(f),
             Expr::Name(expr) =&gt; expr.format().fmt(f),
             Expr::List(expr) =&gt; expr.format().fmt(f),
@@ -128,17 +117,7 @@
 
             let mut f = WithNodeLevel::new(level, f);
 
-            // Allow to indent the parentheses while
-            // ```python
-            // g1 = (
-            //     queryset.distinct().order_by(field.name).values_list(field_name_flat_long_long=True)
-            // )
-            // ```
-            if call_chain_layout == CallChainLayout::Fluent {
-                write!(f, [group(&amp;format_expr)])
-            } else {
-                write!(f, [format_expr])
-            }
+            write!(f, [format_expr])
         }
     }
 }
@@ -175,35 +154,6 @@
             parenthesize,
         } = self;
 
-        // Fluent style means that when we break we always add parentheses, so we don't need the
-        // checks below for existing parentheses, comments or `needs_parentheses`
-        if CallChainLayout::from_expression(expression, f.context().source())
-            == CallChainLayout::Fluent
-        {
-            match expression {
-                Expr::Attribute(expr) =&gt; {
-                    return parenthesize_if_expands(&amp;group(
-                        &amp;expr.format().with_options(CallChainLayout::Fluent),
-                    ))
-                    .fmt(f)
-                }
-                Expr::Call(expr) =&gt; {
-                    return parenthesize_if_expands(&amp;group(
-                        &amp;expr.format().with_options(CallChainLayout::Fluent),
-                    ))
-                    .fmt(f)
-                }
-                Expr::Subscript(expr) =&gt; {
-                    return parenthesize_if_expands(&amp;group(
-                        &amp;expr.format().with_options(CallChainLayout::Fluent),
-                    ))
-                    .fmt(f)
-                }
-                // `call_chain_layout` checks we're in one of the above
-                _ =&gt; unreachable!(),
-            };
-        }
-
         let comments = f.context().comments();
         let preserve_parentheses = parenthesize.is_optional()
             &amp;&amp; is_expression_parenthesized((*expression).into(), f.context().source());
@@ -527,30 +477,36 @@
 /// ```
 #[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
 pub enum CallChainLayout {
+    /// The root of a call chain
     #[default]
     Default,
+
+    /// A nested call chain element that uses fluent style.
     Fluent,
+
+    /// A nested call chain element not using fluent style.
+    NonFluent,
 }
 
 impl CallChainLayout {
-    pub(crate) fn from_expression(mut expr: &amp;Expr, source: &amp;str) -&gt; Self {
+    pub(crate) fn from_expression(mut expr: AnyNodeRef, source: &amp;str) -&gt; Self {
         let mut attributes_after_parentheses = 0;
         loop {
             match expr {
-                Expr::Attribute(ast::ExprAttribute { value, .. }) =&gt; {
+                AnyNodeRef::ExprAttribute(ast::ExprAttribute { value, .. }) =&gt; {
                     // `f().x` | `data[:100].T`
                     if matches!(value.as_ref(), Expr::Call(_) | Expr::Subscript(_)) {
                         attributes_after_parentheses += 1;
                     }
-                    expr = value;
+                    expr = AnyNodeRef::from(value.as_ref());
                 }
-                Expr::Call(ast::ExprCall { func: inner, .. })
-                | Expr::Subscript(ast::ExprSubscript { value: inner, .. }) =&gt; {
-                    expr = inner;
+                AnyNodeRef::ExprCall(ast::ExprCall { func: inner, .. })
+                | AnyNodeRef::ExprSubscript(ast::ExprSubscript { value: inner, .. }) =&gt; {
+                    expr = AnyNodeRef::from(inner.as_ref());
                 }
                 _ =&gt; {
                     // We to format the following in fluent style: `f2 = (a).w().t(1,)`
-                    if is_expression_parenthesized(AnyNodeRef::from(expr), source) {
+                    if is_expression_parenthesized(expr, source) {
                         attributes_after_parentheses += 1;
                     }
                     break;
@@ -558,7 +514,7 @@
             }
         }
         if attributes_after_parentheses &lt; 2 {
-            CallChainLayout::Default
+            CallChainLayout::NonFluent
         } else {
             CallChainLayout::Fluent
         }
Index: crates/ruff_python_formatter/src/expression/expr_attribute.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_attribute.rs b/crates/ruff_python_formatter/src/expression/expr_attribute.rs
--- a/crates/ruff_python_formatter/src/expression/expr_attribute.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/expr_attribute.rs	(date 1691133618832)
@@ -31,6 +31,17 @@
             ctx: _,
         } = item;
 
+        let call_chain_layout = match self.call_chain_layout {
+            CallChainLayout::Default =&gt; {
+                if f.context().node_level().is_parenthesized() {
+                    CallChainLayout::from_expression(AnyNodeRef::from(item), f.context().source())
+                } else {
+                    CallChainLayout::NonFluent
+                }
+            }
+            layout @ (CallChainLayout::Fluent | CallChainLayout::NonFluent) =&gt; layout,
+        };
+
         let needs_parentheses = matches!(
             value.as_ref(),
             Expr::Constant(ExprConstant {
@@ -51,18 +62,18 @@
         } else {
             match value.as_ref() {
                 Expr::Attribute(expr) =&gt; {
-                    expr.format().with_options(self.call_chain_layout).fmt(f)?;
+                    expr.format().with_options(call_chain_layout).fmt(f)?;
                 }
                 Expr::Call(expr) =&gt; {
-                    expr.format().with_options(self.call_chain_layout).fmt(f)?;
-                    if self.call_chain_layout == CallChainLayout::Fluent {
+                    expr.format().with_options(call_chain_layout).fmt(f)?;
+                    if call_chain_layout == CallChainLayout::Fluent {
                         // Format the dot on its own line
                         soft_line_break().fmt(f)?;
                     }
                 }
                 Expr::Subscript(expr) =&gt; {
-                    expr.format().with_options(self.call_chain_layout).fmt(f)?;
-                    if self.call_chain_layout == CallChainLayout::Fluent {
+                    expr.format().with_options(call_chain_layout).fmt(f)?;
+                    if call_chain_layout == CallChainLayout::Fluent {
                         // Format the dot on its own line
                         soft_line_break().fmt(f)?;
                     }
@@ -75,7 +86,7 @@
             hard_line_break().fmt(f)?;
         }
 
-        if self.call_chain_layout == CallChainLayout::Fluent {
+        if call_chain_layout == CallChainLayout::Fluent {
             // Fluent style has line breaks before the dot
             // ```python
             // blogs3 = (
@@ -139,7 +150,11 @@
         context: &amp;PyFormatContext,
     ) -&gt; OptionalParentheses {
         // Checks if there are any own line comments in an attribute chain (a.b.c).
-        if context
+        if CallChainLayout::from_expression(self.into(), context.source())
+            == CallChainLayout::Fluent
+        {
+            OptionalParentheses::Multiline
+        } else if context
             .comments()
             .dangling_comments(self)
             .iter()

</code></pre>
<p>There's room to remove some of the duplication in <code>Subscript</code>, <code>Attribute</code>, and the call formatting. I also haven't tested if there are no regressions on the django projects.</p>
<p>I would prefer this solution because it avoids by-passing <code>NeedsParentheses</code>, <code>can_omit_parentheses</code>, and the changes are local to the affected expression types. But interested to hear your opinion. It may be worth to schedule some sync time to avoid further forth and back.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-08-04 07:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-08-04 11:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:77 on 2023-08-04 11:46</div>
            <div class="timeline-body"><p>Should have checked first, there's a case of unstable formatting now:</p>
<pre><code class="language-python">class s():s=((()).r(Q(e=&quot;efinitive Guide to Django: Web Development Done Right&quot;)())).order_by()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @konstin on 2023-08-04 13:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2023-08-04 13:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-08-04 13:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-08-04 13:59</div>
            <div class="timeline-body"><p>oh i didn't turn of automerge; it should be fine anyway, i'll do a follow-up PR if anything comes up</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-08-04 15:41</div>
            <div class="timeline-body"><blockquote>
<p>oh i didn't turn of automerge; it should be fine anyway, i'll do a follow-up PR if anything comes up</p>
</blockquote>
<p>This looks good to me.</p>
<p>Does this implementation handle the case you shared with me earlier correctly where it must preserve parentheses around members of the call chain?</p>
<pre><code class="language-python">a = (
    b().c(
        &quot;asdfasfaefinitive Guidddddde to Django: Web Developfdddddddment Done Rdddight&quot;
    )
).d()
a = (
    b()
    .c(&quot;asdfasfaefinitive Guidddddde to Django: Web Developfdddddddment Done Rdddight&quot;)
    .d()
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-08-04 15:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:183 on 2023-08-04 15:42</div>
            <div class="timeline-body"><p>@konstin can we revert this change?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-08-07 09:12</div>
            <div class="timeline-body"><p>yep it does, it's</p>
<p>https://github.com/astral-sh/ruff/pull/6151/files#diff-dce5f767478405fd26c9245cf2e2bfb3358c6f61f5463570955ab0a2bc8a23abR117</p>
<p>and</p>
<p>https://github.com/astral-sh/ruff/pull/6151/files#diff-9e872df95d51e4a0160715ef3cda0d7aaa8244e20f1bd7c7b0886a648358dfbeR280-R282</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-08-08 12:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_formatter/src/expression/mod.rs</code>:183 on 2023-08-08 12:36</div>
            <div class="timeline-body"><p>already done</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 02:52:41 UTC
    </footer>
</body>
</html>
