<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Support unpacking `with` target - astral-sh/ruff #16469</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Support unpacking <code>with</code> target</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16469">#16469</a>
        opened by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a>
        on 2025-03-03 06:27
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a></div>
            <div class="timeline-body"><!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<p>Resolves astral-sh/ruff#16365</p>
<p>Add support for unpacking <code>with</code> statement targets.</p>
<h2>Test Plan</h2>
<!-- How was it tested? -->

<p>Added some test cases, alike the ones added by astral-sh/ruff#15058.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-03-03 06:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1574 on 2025-03-03 06:32</div>
            <div class="timeline-body"><p>I changed this because tests were panicking when using <code>infer_expression</code> in the else branch. Not sure I totally understand what happened here, but probably had to do with my changing the usage of <code>infer_context_expression</code> such that types are being inferred earlier?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-03-03 06:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:66 on 2025-03-03 06:33</div>
            <div class="timeline-body"><p>I almost missed this because it's not a match and the compiler didn't catch me. Would folks be okay with my refactoring it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-03-03 12:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-03-05 03:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3076 on 2025-03-05 03:58</div>
            <div class="timeline-body"><p>very small nit: we should probably be consistent with respect to &quot;doesn't&quot; vs &quot;does not&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ericmarkmartin on 2025-03-05 03:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @ericmarkmartin on 2025-03-05 03:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @ericmarkmartin on 2025-03-05 03:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @ericmarkmartin on 2025-03-05 03:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @ericmarkmartin on 2025-03-05 03:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1313 on 2025-03-05 07:36</div>
            <div class="timeline-body"><p>Nit: This code seems to be the same as for <code>for</code> targets with the exception of <code>UnpackValue::ContextManager</code>, <code>AttributeAssignment::ContextManager</code>. Would it be possible to reuse some more code by having a shared method that takes an <code>UnpackKind</code> argument that then constructs the <code>UnpackValue</code>, the <code>AttributeAssignment</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-05 07:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:361 on 2025-03-06 00:05</div>
            <div class="timeline-body"><p>We should also have a test similar to this, but with code like <code>with ContextManager() as (self.x, self.y):</code>. I think this would catch a change we are missing in the <code>ast::Expr::Attribute</code> branch of <code>SemanticIndexBuilder::visit_expr</code>, where we match on <code>Assign</code> and <code>For</code> unpacks, but also need to match on <code>With</code>.</p>
<p>Bonus points if we can find a way to make this mistake harder to make in future, e.g. with an <code>UnpackKind</code> enum that that code matches on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1313 on 2025-03-06 00:06</div>
            <div class="timeline-body"><p><code>Assign</code> has quite similar code as well, they should probably all three share a helper.</p>
<p>At the very least we should extract repetition around creation of the <code>Unpack</code>, things like the unsafe node-ref creation and the <code>countme::Count::default()</code> feel like details/boilerplate that don't belong at this level of abstraction and shouldn't be repeated for each node kind.</p>
<p>That said, I'd also be open to landing this PR with some duplication if we get all the behavior correct, and then doing the refactor as a separate PR for ease of review.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1289 on 2025-03-06 00:09</div>
            <div class="timeline-body"><p>This should really have a comment <code>// SAFETY: the node </code>optional_vars<code>is part of the</code>self.module<code> tree</code> or similar. But so should the same code in the <code>For</code> and <code>Assign</code> versions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1300 on 2025-03-06 00:13</div>
            <div class="timeline-body"><p>Small preference for going with arbitrary <code>true</code> over arbitrary <code>false</code> here, since it is technically still the first (of one).</p>
<p>But this change would also apply to the same code in <code>For</code> and <code>Assign</code>, so should be made in whichever PR we refactor for better code reuse.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:204 on 2025-03-06 00:14</div>
            <div class="timeline-body"><p>Is this comment obsolete? There's only one Option here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3076 on 2025-03-06 00:30</div>
            <div class="timeline-body"><p>I would go with &quot;does not&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2852 on 2025-03-06 00:33</div>
            <div class="timeline-body"><p>We should be quite careful about methods like these, because it means the path of least resistance for a caller is to ignore errors entirely. If we provide this, it should have a warning doc comment, like <code>Type::bool</code> and <code>Type::iterate</code> have.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2861 on 2025-03-06 00:36</div>
            <div class="timeline-body"><p>Doc comment for this method wouldn't hurt; similar to <code>try_iterate</code>, <code>try_bool</code>, etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:617 on 2025-03-06 00:48</div>
            <div class="timeline-body"><p>How about a test where evaluating the context_expr itself emits a diagnostic?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1574 on 2025-03-06 00:52</div>
            <div class="timeline-body"><p>I suspect it's related to the added support for <code>self.x</code> as a with statement target, meaning we are now inferring context managers with attribute targets as standalone expressions, and that leads to double inference of the same expression(s) if we don't always go through <code>infer_standalone_expression</code>.</p>
<p>I think this change is correct, given that the semantic index builder always creates a standalone expression for every <code>with</code> statement.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1271 on 2025-03-06 00:53</div>
            <div class="timeline-body"><p>This line looks redundant with line 1274? We shouldn't add <code>context_expr</code> as a standalone expression <em>twice</em>, and we shouldn't need to do it at all if there are no <code>optional_vars</code> (meaning we aren't going to create any Definition or register any attribute assignment).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:66 on 2025-03-06 00:54</div>
            <div class="timeline-body"><p>Totally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-06 00:55</div>
            <div class="timeline-body"><p>Looks great, very impressive first PR!</p>
<p>I didn't get a chance to explore the (lack of) duplicated diagnostics that we discussed on Discord, will try to look at that later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-06 06:14</div>
            <div class="timeline-body"><p>Ok, I looked into the diagnostics situation, and it is going to need some attention here. A bit of background will be needed to understand the issue.</p>
<p>We have type inference queries at several granularities: expression (but only some &quot;standalone&quot; expressions, so we don't create too many Salsa ingredients), definition (that is, a value assigned to some name), and scope. We use the definition granularity queries to do lazy type inference of names from scopes we aren't actually checking (e.g. imported libraries). When we are actually checking a file, we run the scope-level inference queries for every scope in the file, and it is those queries where we aggregate and emit diagnostics.</p>
<p>So the intent when we run scope-level inference is that as we walk the AST, anywhere we hit a node that is a definition of a name, we use <code>self.infer_definition</code> to find that Definition by key, query its types, and then merge those types and diagnostics into the scope-level <code>TypeInference</code>. What this achieves is that we never double-infer the same types (even if we first lazily query the type of a name from a scope, and then later do full scope type inference on that scope), because we always use the (Salsa-cached) <code>infer_definition_types</code> query whenever we hit a definition.</p>
<p>What is currently happening in this PR is that when we find an unpacked with statement in scope-level inference, we don't eagerly run <code>infer_definition_types</code> for the definitions of the unpack-target names at all. This is not good, because it means we are implicitly depending on a later load of one of those names to actually run <code>infer_definition_types</code>, go through the Unpacker, and catch any unpack errors.</p>
<p>We should add a test like this to demonstrate this:</p>
<pre><code class="language-py">class ContextManager:
    def __enter__(self) -&gt; tuple[int, str]:
        return (1, &quot;a&quot;)

    def __exit__(self, exc_type, exc_value, traceback) -&gt; None:
        pass

with ContextManager() as (a, b, c):
    pass
</code></pre>
<p>This should emit an error about trying to unpack two elements into three, but currently in this PR it does not.</p>
<p>The fix is that this PR needs to update <code>TypeInferenceBuilder::infer_with_statement</code>, and currently doesn't; there's even a relevant TODO statement there. In the case where the target is not a simple Name, we are currently just inferring the type of the context expression (just once! which is why you currently can't make duplicate diagnostics happen, regardless of <code>first</code>) and then we visit the optional-vars, and nothing in that visit will ever look up any of the definitions or run <code>self.infer_definition()</code> on them.</p>
<p>The <em>right</em> fix for this involves fixing https://github.com/astral-sh/ty/issues/185, since this duplicate-definition thing is already broken for <code>for</code> statements, as we discovered yesterday. But that fix is not going to be simple, and I don't think we should try to fix it in this PR.</p>
<p>Instead, I think the goal for this PR should be to emulate the current handling of <code>for</code> statements, and be just as broken as <code>for</code> in this regard, and then the fix for https://github.com/astral-sh/ty/issues/185 will fix them both in the same way. That will mean, in this PR, updating <code>TypeInferenceBuilder::infer_with_statement</code> to look a lot more like <code>TypeInferenceBuilder::infer_for_statement</code>, and use <code>TypeInferenceBuilder::infer_target</code>.</p>
<p>Hopefully that all made sense! If not, feel free to ask questions, here or in Discord. Or if it doesn't make sense and you don't have time to wrap your head around it and update the PR, that's totally fine too! Just let me know and one of us can pick it up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/attribute_assignment.rs</code>:27 on 2025-03-07 08:24</div>
            <div class="timeline-body"><p>nit: &quot;right-hand side&quot; is a bit confusing but I understand that it's how assignment statements are usually viewed. Maybe we can reword it as &quot;... where the (value|expression) to be assigned is a context-manager ...&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1988 on 2025-03-07 08:26</div>
            <div class="timeline-body"><p>Just for visibility as stated in Discord and it doesn't need to be done in this PR but we could possibly combine <code>first</code> and <code>unpack</code> into a <code>Option&lt;(UnpackPosition, Unpack&lt;'a&gt;)&gt;</code> where the position could be either <code>First</code> or <code>Other</code>. I'm not sure what the fallout of this change would be but that would at least solve the arbitrary boolean problem when the target is a name node.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3034 on 2025-03-07 08:47</div>
            <div class="timeline-body"><p>Can we use verbose name like <code>enter_return_type</code>? It's easier to read and can help future readers understand easily about this field.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3083 on 2025-03-07 08:49</div>
            <div class="timeline-body"><p>nit: I think I'd prefer to make this a closure inside <code>report_diagnostic</code> as I think that's the only place where it's being utilized.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1595 on 2025-03-07 08:53</div>
            <div class="timeline-body"><p>I think this TODO is resolved, no? The <code>infer_target</code> call will take care of inferring the targets involved in an unpacking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-07 09:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-03-07 23:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3083 on 2025-03-07 23:03</div>
            <div class="timeline-body"><p>I think that's true right now, but we could probably use it elsewhere, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:708 on 2025-03-08 02:32</div>
            <div class="timeline-body"><p>This is failing now because a PR that recently landed in main branch changed our policy on how we infer types on a failed unpacking: https://github.com/astral-sh/ruff/issues/15199</p>
<pre><code class="language-suggestion">    reveal_type(a)  # revealed: Unknown
    reveal_type(b)  # revealed: Unknown
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-03-08 02:32</div>
            <div class="timeline-body"><p>Looks great, thank you! Just one failing test with a trivial fix, so I'll push that and then merge.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-03-08 02:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-03-08 02:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-03-08 04:00</div>
            <div class="timeline-body"><p>@ericmarkmartin Awesome work! This is a really great first contribution. Thank you for taking this on and also surfacing an important issue related to the unpacking diagnostics.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-08 14:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:10:27 UTC
    </footer>
</body>
</html>
