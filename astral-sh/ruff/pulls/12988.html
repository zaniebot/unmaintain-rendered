<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add API to emit type-checking diagnostics - astral-sh/ruff #12988</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add API to emit type-checking diagnostics</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12988">#12988</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2024-08-19 12:23
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a></div>
            <div class="timeline-body">Summary
<p>This PR introduces a new API to <code>TypeInferenceBuilder</code> to emit type-checking diagnostics.</p>
<p>The API is intentionally kept simple. The PR doesn&#x27;t aim to resolve on how we represent rules/violations in Red Knot.</p>
Design considerations
<p>This PR wraps diagnostics in an <code>Arc</code> to make them cheap-cloneable. It&#x27;s desired to have cheap-cloneable diagnostics
because we have to copy them between <code>infer_expression</code> -&gt; <code>infer_definition</code> -&gt; <code>infer_scope</code>...</p>
<p>An alternative design that I think is worth exploring once the Salsa tables refactor lands is to introduce a
<code>TypeCheckDiagnosticIngredient</code> that has a single field, the diagnostic. The advantage of this approach would be that
we get &quot;Arena&quot; allocation for the diagnostics. The downside is that diagnostic must be verified everytime the revision changes which
isn&#x27;t entirely free.</p>
Rule Selector
<p>Long term, I think we want to have a <code>rule_selector(file) -&gt; RuleSelector</code> query that resolves the enabled rules per file.
As said before, this PR doesn&#x27;t try to resolve how and which rules are enabled per file. That&#x27;s why I omitted this part for now but the idea is that
<code>push_diagnostic</code> would call the <code>rule_selector</code> instead of just calling <code>is_file_open</code>.</p>
Example diagnostic
<p>I implemented an example diagnostic that flags unresolved imports.</p>
Why do we need <code>is_file_open</code>
<p>The check for <code>is_file_open</code> is mainly an optimization to avoid generating a lot of diagnostics that will never be shown.</p>
Test Plan
<p>I added a small unit test. I also verified that running the CLI shows the diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 12:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:48 on 2024-08-19 12:48</div>
            <div class="timeline-body"><p>Could we call this method <code>with_range()</code>? The name is currently the same as <code>ruff_text_size::Ranged::range()</code>, so I assumed it was going to return the range rather than set the range</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:46 on 2024-08-19 12:50</div>
            <div class="timeline-body"><p>Some of this comment feels more like a description of the internal implementation rather than a description of how to use the type; I&#x27;d move it to a comment above the field rather than a comment above the type:</p>
<pre><code>/// A collection of type check diagnostics.
#[derive(Default, Eq, PartialEq)]
pub struct TypeCheckDiagnostics {
	/// The diagnostics are wrapped in an `Arc` because they need to be cloned multiple times
	/// when going from `infer_expression` to `check_file`. We could consider
	/// making [`TypeCheckDiagnostic`] a Salsa struct to have them Arena-allocated (once the Tables refactor is done).
	/// Using Salsa struct does have the downside that it leaks the Salsa dependency into diagnostics and
	/// each Salsa-struct comes with an overhead.
    inner: Vec&lt;std::sync::Arc&lt;TypeCheckDiagnostic&gt;&gt;,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:55 on 2024-08-19 12:59</div>
            <div class="timeline-body"><p>Hmm, this method doesn&#x27;t actually build a diagnostic directly -- it creates a builder that can be used to build a diagnostic. Maybe it should be called <code>diagnostic_builder()</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:991 on 2024-08-19 13:08</div>
            <div class="timeline-body"><p>I&#x27;m quitting Astral if we use CamelCase for our red-knot error codes ðŸ˜†</p>
<p>I also find the builder interface that you&#x27;ve added in <code>diagnostics.rs</code> a little confusing, because:</p>
<ul>
<li><p><code>push_diagnostic()</code> doesn&#x27;t actually push any diagnostics onto the stack; it returns a builder that can be used to push diagnostics onto the stack</p>
</li>
<li><p>we&#x27;re doing two distinct things in the <code>finish()</code> method:</p>
<ul>
<li>We&#x27;re &quot;finishing&quot; the diagnostic that the builder is building</li>
<li>We&#x27;re pushing the diagnostic onto the stack of finished diagnostics</li>
</ul>
<p>I&#x27;d much prefer it if we could just do those in two steps so it&#x27;s a bit more explicit what&#x27;s going on</p>
</li>
</ul>
<p>My preferred API would be something like this:</p>
<pre><code>            if let Some(builder) = self.diagnostic_builder(node, &quot;reportMissingImport&quot;) {
                let diagnostic = builder.finish(format!(&quot;Import &#x27;{module_name}&#x27; could not be resolved.&quot;));
                self.push_diagnostic(diagnostic);
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:10</div>
            <div class="timeline-body"><p>Thanks! I&#x27;m not 100% sure about some of these interfaces. Some thoughts below:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_workspace/src/workspace.rs</code>:491 on 2024-08-19 13:13</div>
            <div class="timeline-body"><pre><code>        assert_eq!(check_file(&amp;db, file), Vec::&lt;String&gt;::new());
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 13:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:48 on 2024-08-19 13:15</div>
            <div class="timeline-body"><p>This is intentional. It&#x27;s common in builders to call the methods the same as the field names.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-08-19 13:18</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>âœ… ecosystem check detected no linter changes.</p>
Linter (preview)
<p>âœ… ecosystem check detected no linter changes.</p>
Formatter (stable)
<p>âœ… ecosystem check detected no format changes.</p>
Formatter (preview)
<p>âœ… ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:48 on 2024-08-19 13:21</div>
            <div class="timeline-body"><p>Fair enough -- I still feel like it breaks our local-to-this-repo convention where <code>.range()</code> almost always returns the text range of a thing and never mutates a thing, even if it&#x27;s a generally common pattern in Rust. But it doesn&#x27;t matter that much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 13:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:991 on 2024-08-19 13:23</div>
            <div class="timeline-body"><p>Fair enough. It just feels slightly more verbose because it now requires an extra <code>push_diagnostic</code> call, and this needs to be repeated at every call site.</p>
<p>The overall idea is that the API is similar to <code>map.entry</code> where we want to defer the insertion and also already pre-set the required values (the key).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:24</div>
            <div class="timeline-body"><p>You also need to emit &quot;unresolved import&quot; diagnostics on <code>from foo import bar</code> imports where <code>foo</code> can be resolved to a module but there is no <code>bar</code> symbol inside the <code>foo</code> module. We do so on <code>main</code>, but this PR means that we now only emit &quot;unresolved import&quot; diagnostics on <code>import foo</code> imports or <code>from foo import bar</code> imports where the module <code>foo</code> cannot be resolved.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 13:25</div>
            <div class="timeline-body"><blockquote>
<p>You also need to emit &quot;unresolved import&quot; diagnostics on <code>from foo import bar</code> imports where <code>foo</code> can be resolved to a module but there is no <code>bar</code> symbol inside the <code>foo</code> module. We do so on <code>main</code>, but this PR means that we now only emit &quot;unresolved import&quot; diagnostics on <code>import foo</code> imports or <code>from foo import bar</code> imports where the module <code>foo</code> cannot be resolved.</p>
</blockquote>
<p>Yeah, I&#x27;m not aiming for parity with the lint rule. The goal here is to add the API, and unresolved imports were the easiest example where I didn&#x27;t have to make something up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-19 13:53</div>
            <div class="timeline-body"><blockquote>
<p>Yeah, I&#x27;m not aiming for parity with the lint rule. The goal here is to add the API, and unresolved imports were the easiest example where I didn&#x27;t have to make something up.</p>
</blockquote>
<p>Fair enough -- but parity with <code>main</code> isn&#x27;t too hard here, and it also fixes the failing assertions you have currrently in the benchmarks. You just need to do this to your PR branch:</p>
<pre><code>--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -943,7 +943,7 @@ impl&lt;&#x27;db&gt; TypeInferenceBuilder&lt;&#x27;db&gt; {
             ModuleName::new(module_name)
         };
 
-        let module_ty = self.module_ty_from_name(module_name, import_from.into());
+        let module_ty = self.module_ty_from_name(module_name.clone(), import_from.into());
 
         let ast::Alias {
             range: _,
@@ -960,6 +960,15 @@ impl&lt;&#x27;db&gt; TypeInferenceBuilder&lt;&#x27;db&gt; {
             .member(self.db, &amp;Name::new(&amp;name.id))
             .replace_unbound_with(self.db, Type::Unknown);
 
+        // We&#x27;ll already have emitted a diagnostic if `module_name` is `None`
+        if let Some(module_name) = module_name {
+            if ty.is_unknown() {
+                if let Some(builder) = self.push_diagnostic(alias.into(), &quot;reportMissingImport&quot;) {
+                    builder.finish(format!(&quot;Could not resolve import of {name} from {module_name}&quot;));
+                }
+            }
+        }
+
         self.types.definitions.insert(definition, ty);
     }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:46 on 2024-08-19 14:12</div>
            <div class="timeline-body"><p>Agree, but it also is the only reason why the type exists. It would just be a <code>Vec&lt;TypeCheckDiagnostic&gt;</code> if it wasn&#x27;t for the <code>Arc</code> wrapping</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 14:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:991 on 2024-08-19 14:14</div>
            <div class="timeline-body"><p>I simplified the API to use <code>format_args</code> to defer the expensive message allocation for now. We may need to go back to a builder-like pattern in the future. But that depends on how we design our diagnostics</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 14:16</div>
            <div class="timeline-body"><blockquote>
<p>Fair enough -- but parity with main isn&#x27;t too hard here, and it also fixes the failing assertions you have currrently in the benchmarks. You just need to do this to your PR branch:</p>
</blockquote>
<p>I didn&#x27;t do it because I am unclear on whether the diagnostic shouldn&#x27;t be created in <code>ty.member</code>. That&#x27;s why I still prefer to not make this change as part of this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 14:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:46 on 2024-08-19 14:17</div>
            <div class="timeline-body"><p>Okay, but VSCode will display all this information on my screen if I&#x27;m hovering over the <code>TypeCheckDiagnostics</code> in another red-knot module. This feels like way more information than is necessary in that kind of situation :P</p>
<p><img src="https://github.com/user-attachments/assets/d3799e7a-7fee-4025-a9aa-b1139f6ed827" alt="image"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-19 14:19</div>
            <div class="timeline-body"><blockquote>
<p>I didn&#x27;t do it because I am unclear on whether the diagnostic shouldn&#x27;t be created in <code>ty.member</code>.</p>
</blockquote>
<p>(Definitely not, because we&#x27;ll also use <code>ty.member()</code> for e.g. <code>import foo; x = foo.bar</code> errors where the <code>foo</code> module has no member <code>bar</code> -- but there it&#x27;s an unresolved attribute access rather than an unresolved import, so it&#x27;ll need a different error message and a different code)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:989 on 2024-08-19 14:34</div>
            <div class="timeline-body"><pre><code>                &quot;unresolved-import&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-08-19 14:37</div>
            <div class="timeline-body"><p>Thanks, I like this much more now. I&#x27;d still prefer it if we could have parity with <code>main</code> in this PR, but <code>Â¯\_(ãƒ„)_/Â¯</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 14:38</div>
            <div class="timeline-body"><blockquote>
<p>(Definitely not, because we&#x27;ll also use ty.member() for e.g. import foo; x = foo.bar errors where the foo module has no member bar -- but there it&#x27;s an unresolved attribute access rather than an unresolved import, so it&#x27;ll need a different error message and a different code)</p>
</blockquote>
<p>Still, I don&#x27;t know ;) Feels annoying having to test this on every <code>ty.member</code> call-site</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-08-20 07:23</div>
            <div class="timeline-body"><a href="https://codspeed.io/astral-sh/ruff/branches/type-check">CodSpeed Performance Report</a>
Merging #12988 will <strong>improve performances by 7.07%</strong>
<p>Comparing <code>type-check</code> (de62da1) with <code>main</code> (38c19fb)</p>
Summary
<p><code>âš¡ 1</code> improvements
<code>âœ… 31</code> untouched benchmarks</p>
Benchmarks breakdown
<p>|     | Benchmark | <code>main</code> | <code>type-check</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| âš¡ | <code>linter/all-rules[numpy/globals.py]</code> | 778.7 Âµs | 727.3 Âµs | +7.07% |</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:06:13 UTC
    </footer>
</body>
</html>
