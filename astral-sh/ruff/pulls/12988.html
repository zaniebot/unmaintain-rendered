<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add API to emit type-checking diagnostics - astral-sh/ruff #12988</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add API to emit type-checking diagnostics</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12988">#12988</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2024-08-19 12:23
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR introduces a new API to <code>TypeInferenceBuilder</code> to emit type-checking diagnostics.</p>
<p>The API is intentionally kept simple. The PR doesn't aim to resolve on how we represent rules/violations in Red Knot.</p>
<h2>Design considerations</h2>
<p>This PR wraps diagnostics in an <code>Arc</code> to make them cheap-cloneable. It's desired to have cheap-cloneable diagnostics
because we have to copy them between <code>infer_expression</code> -&gt; <code>infer_definition</code> -&gt; <code>infer_scope</code>...</p>
<p>An alternative design that I think is worth exploring once the Salsa tables refactor lands is to introduce a
<code>TypeCheckDiagnosticIngredient</code> that has a single field, the diagnostic. The advantage of this approach would be that
we get &quot;Arena&quot; allocation for the diagnostics. The downside is that diagnostic must be verified everytime the revision changes which
isn't entirely free.</p>
<h2>Rule Selector</h2>
<p>Long term, I think we want to have a <code>rule_selector(file) -&gt; RuleSelector</code> query that resolves the enabled rules per file.
As said before, this PR doesn't try to resolve how and which rules are enabled per file. That's why I omitted this part for now but the idea is that
<code>push_diagnostic</code> would call the <code>rule_selector</code> instead of just calling <code>is_file_open</code>.</p>
<h2>Example diagnostic</h2>
<p>I implemented an example diagnostic that flags unresolved imports.</p>
<h2>Why do we need <code>is_file_open</code></h2>
<p>The check for <code>is_file_open</code> is mainly an optimization to avoid generating a lot of diagnostics that will never be shown.</p>
<h2>Test Plan</h2>
<p>I added a small unit test. I also verified that running the CLI shows the diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2024-08-19 12:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @MichaReiser on 2024-08-19 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @MichaReiser on 2024-08-19 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @MichaReiser on 2024-08-19 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:48 on 2024-08-19 12:48</div>
            <div class="timeline-body"><p>Could we call this method <code>with_range()</code>? The name is currently the same as <code>ruff_text_size::Ranged::range()</code>, so I assumed it was going to return the range rather than set the range</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:46 on 2024-08-19 12:50</div>
            <div class="timeline-body"><p>Some of this comment feels more like a description of the internal implementation rather than a description of how to use the type; I'd move it to a comment above the field rather than a comment above the type:</p>
<pre><code class="language-suggestion">/// A collection of type check diagnostics.
#[derive(Default, Eq, PartialEq)]
pub struct TypeCheckDiagnostics {
	/// The diagnostics are wrapped in an `Arc` because they need to be cloned multiple times
	/// when going from `infer_expression` to `check_file`. We could consider
	/// making [`TypeCheckDiagnostic`] a Salsa struct to have them Arena-allocated (once the Tables refactor is done).
	/// Using Salsa struct does have the downside that it leaks the Salsa dependency into diagnostics and
	/// each Salsa-struct comes with an overhead.
    inner: Vec&lt;std::sync::Arc&lt;TypeCheckDiagnostic&gt;&gt;,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:55 on 2024-08-19 12:59</div>
            <div class="timeline-body"><p>Hmm, this method doesn't actually build a diagnostic directly -- it creates a builder that can be used to build a diagnostic. Maybe it should be called <code>diagnostic_builder()</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:991 on 2024-08-19 13:08</div>
            <div class="timeline-body"><p>I'm quitting Astral if we use CamelCase for our red-knot error codes ðŸ˜†</p>
<p>I also find the builder interface that you've added in <code>diagnostics.rs</code> a little confusing, because:</p>
<ul>
<li><p><code>push_diagnostic()</code> doesn't actually push any diagnostics onto the stack; it returns a builder that can be used to push diagnostics onto the stack</p>
</li>
<li><p>we're doing two distinct things in the <code>finish()</code> method:</p>
<ul>
<li>We're &quot;finishing&quot; the diagnostic that the builder is building</li>
<li>We're pushing the diagnostic onto the stack of finished diagnostics</li>
</ul>
<p>I'd much prefer it if we could just do those in two steps so it's a bit more explicit what's going on</p>
</li>
</ul>
<p>My preferred API would be something like this:</p>
<pre><code class="language-rs">            if let Some(builder) = self.diagnostic_builder(node, &quot;reportMissingImport&quot;) {
                let diagnostic = builder.finish(format!(&quot;Import '{module_name}' could not be resolved.&quot;));
                self.push_diagnostic(diagnostic);
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:10</div>
            <div class="timeline-body"><p>Thanks! I'm not 100% sure about some of these interfaces. Some thoughts below:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_workspace/src/workspace.rs</code>:491 on 2024-08-19 13:13</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        assert_eq!(check_file(&amp;db, file), Vec::&lt;String&gt;::new());
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 13:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:48 on 2024-08-19 13:15</div>
            <div class="timeline-body"><p>This is intentional. It's common in builders to call the methods the same as the field names.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-08-19 13:18</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>âœ… ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>âœ… ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:48 on 2024-08-19 13:21</div>
            <div class="timeline-body"><p>Fair enough -- I still feel like it breaks our local-to-this-repo convention where <code>.range()</code> almost always returns the text range of a thing and never mutates a thing, even if it's a generally common pattern in Rust. But it doesn't matter that much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 13:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:991 on 2024-08-19 13:23</div>
            <div class="timeline-body"><p>Fair enough. It just feels slightly more verbose because it now requires an extra <code>push_diagnostic</code> call, and this needs to be repeated at every call site.</p>
<p>The overall idea is that the API is similar to <code>map.entry</code> where we want to defer the insertion and also already pre-set the required values (the key).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 13:24</div>
            <div class="timeline-body"><p>You also need to emit &quot;unresolved import&quot; diagnostics on <code>from foo import bar</code> imports where <code>foo</code> can be resolved to a module but there is no <code>bar</code> symbol inside the <code>foo</code> module. We do so on <code>main</code>, but this PR means that we now only emit &quot;unresolved import&quot; diagnostics on <code>import foo</code> imports or <code>from foo import bar</code> imports where the module <code>foo</code> cannot be resolved.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 13:25</div>
            <div class="timeline-body"><blockquote>
<p>You also need to emit &quot;unresolved import&quot; diagnostics on <code>from foo import bar</code> imports where <code>foo</code> can be resolved to a module but there is no <code>bar</code> symbol inside the <code>foo</code> module. We do so on <code>main</code>, but this PR means that we now only emit &quot;unresolved import&quot; diagnostics on <code>import foo</code> imports or <code>from foo import bar</code> imports where the module <code>foo</code> cannot be resolved.</p>
</blockquote>
<p>Yeah, I'm not aiming for parity with the lint rule. The goal here is to add the API, and unresolved imports were the easiest example where I didn't have to make something up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-19 13:53</div>
            <div class="timeline-body"><blockquote>
<p>Yeah, I'm not aiming for parity with the lint rule. The goal here is to add the API, and unresolved imports were the easiest example where I didn't have to make something up.</p>
</blockquote>
<p>Fair enough -- but parity with <code>main</code> isn't too hard here, and it also fixes the failing assertions you have currrently in the benchmarks. You just need to do this to your PR branch:</p>
<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -943,7 +943,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
             ModuleName::new(module_name)
         };
 
-        let module_ty = self.module_ty_from_name(module_name, import_from.into());
+        let module_ty = self.module_ty_from_name(module_name.clone(), import_from.into());
 
         let ast::Alias {
             range: _,
@@ -960,6 +960,15 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
             .member(self.db, &amp;Name::new(&amp;name.id))
             .replace_unbound_with(self.db, Type::Unknown);
 
+        // We'll already have emitted a diagnostic if `module_name` is `None`
+        if let Some(module_name) = module_name {
+            if ty.is_unknown() {
+                if let Some(builder) = self.push_diagnostic(alias.into(), &quot;reportMissingImport&quot;) {
+                    builder.finish(format!(&quot;Could not resolve import of {name} from {module_name}&quot;));
+                }
+            }
+        }
+
         self.types.definitions.insert(definition, ty);
     }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:46 on 2024-08-19 14:12</div>
            <div class="timeline-body"><p>Agree, but it also is the only reason why the type exists. It would just be a <code>Vec&lt;TypeCheckDiagnostic&gt;</code> if it wasn't for the <code>Arc</code> wrapping</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 14:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:991 on 2024-08-19 14:14</div>
            <div class="timeline-body"><p>I simplified the API to use <code>format_args</code> to defer the expensive message allocation for now. We may need to go back to a builder-like pattern in the future. But that depends on how we design our diagnostics</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 14:16</div>
            <div class="timeline-body"><blockquote>
<p>Fair enough -- but parity with main isn't too hard here, and it also fixes the failing assertions you have currrently in the benchmarks. You just need to do this to your PR branch:</p>
</blockquote>
<p>I didn't do it because I am unclear on whether the diagnostic shouldn't be created in <code>ty.member</code>. That's why I still prefer to not make this change as part of this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 14:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:46 on 2024-08-19 14:17</div>
            <div class="timeline-body"><p>Okay, but VSCode will display all this information on my screen if I'm hovering over the <code>TypeCheckDiagnostics</code> in another red-knot module. This feels like way more information than is necessary in that kind of situation :P</p>
<p><img src="https://github.com/user-attachments/assets/d3799e7a-7fee-4025-a9aa-b1139f6ed827" alt="image" /></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-19 14:19</div>
            <div class="timeline-body"><blockquote>
<p>I didn't do it because I am unclear on whether the diagnostic shouldn't be created in <code>ty.member</code>.</p>
</blockquote>
<p>(Definitely not, because we'll also use <code>ty.member()</code> for e.g. <code>import foo; x = foo.bar</code> errors where the <code>foo</code> module has no member <code>bar</code> -- but there it's an unresolved attribute access rather than an unresolved import, so it'll need a different error message and a different code)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:989 on 2024-08-19 14:34</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                &quot;unresolved-import&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-08-19 14:37</div>
            <div class="timeline-body"><p>Thanks, I like this much more now. I'd still prefer it if we could have parity with <code>main</code> in this PR, but <code>Â¯\_(ãƒ„)_/Â¯</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-19 14:38</div>
            <div class="timeline-body"><blockquote>
<p>(Definitely not, because we'll also use ty.member() for e.g. import foo; x = foo.bar errors where the foo module has no member bar -- but there it's an unresolved attribute access rather than an unresolved import, so it'll need a different error message and a different code)</p>
</blockquote>
<p>Still, I don't know ;) Feels annoying having to test this on every <code>ty.member</code> call-site</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-08-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-08-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-08-20 07:23</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/type-check">CodSpeed Performance Report</a></h2>
<h3>Merging #12988 will <strong>improve performances by 7.07%</strong></h3>
<p><sub>Comparing <code>type-check</code> (de62da1) with <code>main</code> (38c19fb)</sub></p>
<h3>Summary</h3>
<p><code>âš¡ 1</code> improvements
<code>âœ… 31</code> untouched benchmarks</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>type-check</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| âš¡ | <code>linter/all-rules[numpy/globals.py]</code> | 778.7 Âµs | 727.3 Âµs | +7.07% |</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:06:06 UTC
    </footer>
</body>
</html>
