<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add support for re-export conventions for imports - astral-sh/ruff #15848</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add support for re-export conventions for imports</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15848">#15848</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2025-01-31 12:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>This PR adds support for re-export conventions for imports.</p>
<p>The implementation differs for stub files and runtime files as follows:</p>
<ul>
<li>For stub files, this is enforced by using the <code>unresolved-import</code> and the inferred type is <code>Unknown</code> by way of making the symbol is unbound</li>
<li>For runtime files, this is enforced by using a new rule <code>implicit-reexport</code> and the type is inferred as usual</li>
</ul>
<p>The current implementation updates the <code>Symbol::Type</code> variant to include a new <code>ReExport</code> enum which specifies whether the symbol is defined in an import statement and if so if it&#x27;s being implicitly or explicitly re-exported. This is then used downstream to perform the check.</p>
<p>This implementation does not yet support <code>__all__</code> and <code>*</code> imports as both are features that needs to be implemented independently.</p>
Other potential solution
<p>While implementing this, another potential solution would be to use the visibility qualifier for a symbol to specify whether this is an implicitly exported symbol which translates to:</p>
<pre><code>enum Visibility {
    Public,
    Private,
    ImplicitExport,
}
</code></pre>
<p>This would then mean that this enum could be created for the <code>Definition</code> while building the semantic index and it could also consider the <code>__all__</code> values. One issue that I saw with this is that the values in <code>__all__</code> could come from another module which isn&#x27;t possible to do in the semantic index builder because that does not cross the file boundary.</p>
<p>closes: astral-sh/ruff#14099
closes: astral-sh/ruff#15476</p>
Test Plan
<p>Add test cases, update existing ones if required.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-01-31 12:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-01-31 12:20</div>
            <div class="timeline-body">



<a href="https://codspeed.io/astral-sh/ruff/branches/dhruv%2Fre-export">CodSpeed Performance Report</a>
Merging astral-sh/ruff#15848 will <strong>not alter performance</strong>
<p>Comparing <code>dhruv/re-export</code> (3f92a06) with <code>main</code> (1f7a29d)</p>
Summary
<p><code>✅ 32</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-04 12:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-04 12:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-04 12:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-04 12:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-04 12:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-04 13:07</div>
            <div class="timeline-body"><p>Hmm, it&#x27;s not obvious to me why we see a 4% regression in the incremental benchmark. It either suggests that we now create more ingredients (which I didn&#x27;t see) or that some queries are invalidated more often (which they shouldn&#x27;t, because the benchmark only inserts a comment). Did you look into where we&#x27;re spending more time?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-04 13:11</div>
            <div class="timeline-body"><blockquote>
<p>Hmm, it&#x27;s not obvious to me why we see a 4% regression in the incremental benchmark. It either suggests that we now create more ingredients (which I didn&#x27;t see) or that some queries are invalidated more often (which they shouldn&#x27;t, because the benchmark only inserts a comment). Did you look into where we&#x27;re spending more time?</p>
</blockquote>
<p>Oh, I missed that completely as I didn&#x27;t see the comment being updated and I didn&#x27;t expect this change to regress. Let me look into it. Thanks for catching that.</p>
<p>Edit: I think I&#x27;ve a hunch on where it might be but need to confirm. The <code>Symbol</code> type now includes one additional information for the <code>Type</code> variant. <code>Symbol</code> is the return type of various salsa queries so that might be it but as said need to confirm.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:19 on 2025-02-04 16:37</div>
            <div class="timeline-body"><p>Nit: it would be better to quote the typing spec rather than PEP 484. PEP 484 is now a historical document, the typing spec is authoritative.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:178 on 2025-02-04 16:39</div>
            <div class="timeline-body"><p>I didn&#x27;t actually realize this was the rule! I assume you verified that this is the way pyright/mypy implement it?</p>
<p>It looks like this is another reason to refer to the typing spec instead of PEP 484, because the text quoted from PEP 484 above would not suggest this aspect of the rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:219 on 2025-02-04 16:40</div>
            <div class="timeline-body"><p>Would it be clearer if our test for <code>__all__</code> didn&#x27;t also exercise the subtle same-name wrinkle? I.e. this could just be <code>from b import Foo</code> instead (and rename <code>AnyFoo</code> to <code>Foo</code> below)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:230 on 2025-02-04 16:45</div>
            <div class="timeline-body"><p>I thought we already support rule selection? See #15645</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:259 on 2025-02-04 17:13</div>
            <div class="timeline-body"><pre><code>Red knot does not special case `__init__.py` files, so if a symbol is imported in `__init__.py`
without an explicit re-export, it should raise an error.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:25 on 2025-02-04 17:40</div>
            <div class="timeline-body"><p>Why do we need both <code>Explicit</code> and <code>None</code>? I don&#x27;t think there is any difference in behavior between an import statement that <em>is</em> an explicit re-export, and some other definition that isn&#x27;t an import at all. They are both equally available for import from another module. The only case that needs to be distinguished, as far as I can see, is what you call <code>ReExport::Implicit</code> -- an import that is not an explicit re-export. (And per discussion above, I don&#x27;t think <code>ReExport::Implicit</code> is the best name for that.)</p>
<p>There might be a different reason for this to be tri-valued though; I think we might need a <code>Possibly_</code> variant, similar to <code>Boundness::PossiblyUnbound</code>, for cases where a symbol might be defined normally (by which I mean, either explicit re-export or some other kind of definition), or might be not re-exported in another path. E.g. a case like this:</p>
<pre><code>import foo, get_bool

if get_bool():
    foo = &quot;bar&quot;
</code></pre>
<p>If we have a stub file defined like the above, then I think importing <code>foo</code> from that stub file should act exactly like importing a possibly-unbound name (that is, emit <code>possibly-unbound-import</code>). If it&#x27;s a non-stub file, I think we should still raise the <code>implicit-reexport</code> diagnostic.</p>
<p>In the stub file case, the possibly harder part is that the type from <code>import foo</code> should ideally be ignored, and the inferred type would just be <code>Literal[&#x27;bar&#x27;]</code>. I think this might require changes in <code>symbol_from_bindings</code>?</p>
<p>I think we should add some tests for these conditionally-defined cases.</p>
<p>And it seems like maybe the variants for this enum should be <code>Yes</code>, <code>No</code>, <code>Maybe</code>? (Where <code>No</code> would be equivalent to what you currently name <code>Implicit</code>, <code>Yes</code> would be equivalent to either <code>Explicit</code> or <code>None</code>, and <code>Maybe</code> would be for the conditional cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:14 on 2025-02-04 17:43</div>
            <div class="timeline-body"><pre><code>re-exported.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:34 on 2025-02-04 17:43</div>
            <div class="timeline-body"><pre><code>Similarly, trying to import the symbols from the builtins module which aren&#x27;t re-exported
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:54 on 2025-02-04 17:44</div>
            <div class="timeline-body"><pre><code>When a symbol is re-exported, imporing it should not raise an error.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:80 on 2025-02-04 17:46</div>
            <div class="timeline-body"><p>I think we should be careful about the phrasing &quot;implicitly re-exported&quot;. That phrasing suggests that the symbol <em>is</em> re-exported, but &quot;implicitly&quot;. This is not really accurate -- if the symbol were re-exported, it would be available for import. The point is that it&#x27;s not re-exported.</p>
<p>I realize that mypy uses <code>--no-implicit-reexport</code> for enabling this rule, and I think it&#x27;s reasonable to name our rule similar. In the context of a rule name, it&#x27;s effectively saying &quot;you are treating this symbol as if it were implicitly re-exported, but it&#x27;s actually not re-exported&quot; -- I think it works in that context.</p>
<pre><code>## Non-exported symbols in stub files
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:107 on 2025-02-04 17:46</div>
            <div class="timeline-body"><pre><code>## Nested non-exports
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:109 on 2025-02-04 17:46</div>
            <div class="timeline-body"><pre><code>Here, a chain of modules all don&#x27;t re-export an import.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:144 on 2025-02-04 17:47</div>
            <div class="timeline-body"><pre><code>## Nested mixed re-export and not
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:147 on 2025-02-04 17:47</div>
            <div class="timeline-body"><pre><code>raise an error at that step in the chain.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:688 on 2025-02-04 17:48</div>
            <div class="timeline-body"><pre><code>    /// Checks for import statements that import names from a module which imports but does not explicitly
    /// re-export them.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:691 on 2025-02-04 17:51</div>
            <div class="timeline-body"><pre><code>    /// Imports may only be intended for local use, not intended for re-export as part of the public API of a module.
    /// Allowing other modules to import names that weren&#x27;t intended for re-export can create inconsistent import
    /// locations for the same symbol across the codebase, cause breakages if an import is removed, and make
    /// future refactors more difficult.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:720 on 2025-02-04 17:55</div>
            <div class="timeline-body"><pre><code>        summary: &quot;detects imports of imported names that are not explicitly re-exported&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:337 on 2025-02-04 17:58</div>
            <div class="timeline-body"><pre><code>Similarly, for an `__init__.pyi` (stub) file, importing a non-exported name should raise an error but the
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-04 18:22</div>
            <div class="timeline-body"><p>Thank you for adjusting here as we figured out on the fly what the right semantics should be! The difference in behavior between the stub and non-stub case definitely made this more complex than I&#x27;d initially realized. In hindsight we could have postponed the non-stub opt-in rule entirely, but I think we would have wanted it eventually, so this way it forces us to consider it in the design.</p>
<p>This first review pass is mostly just about the tests and the semantics; will do a more detailed review of the code changes once we have that stuff nailed down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:178 on 2025-02-04 18:23</div>
            <div class="timeline-body"><p>This is definitely correct, yes -- mypy and pyright do implement it this way. It needs to be a truly &quot;redundant&quot; alias for it to be considered an explicit re-export.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-04 18:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:178 on 2025-02-04 18:25</div>
            <div class="timeline-body"><blockquote>
<p>It looks like this is another reason to refer to the typing spec instead of PEP 484, because the text quoted from PEP 484 above would not suggest this aspect of the rule.</p>
</blockquote>
<p>PEP 484 is actually very clear on this specific point, FWIW. The sentence after the one Dhruv quotes above is:</p>
<blockquote>
<p>(<em>UPDATE</em>: To clarify, the intention here is that only names imported using the form X as X will be exported, i.e. the name before and after as must be the same.)</p>
</blockquote>
<p>https://peps.python.org/pep-0484/#stub-files</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 04:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:19 on 2025-02-05 04:37</div>
            <div class="timeline-body"><p>I think I&#x27;ll remove this part then as I&#x27;ve provided a reference link to the typing spec section related to this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 04:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:219 on 2025-02-05 04:38</div>
            <div class="timeline-body"><p>Yes, that makes sense.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 04:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:230 on 2025-02-05 04:40</div>
            <div class="timeline-body"><p>Oh, I think I misunderstood that PR (misread the first sentence). I&#x27;ll update this PR accordingly then:</p>
<ul>
<li>Remove <code>implicit-reexport</code> from the default rule set</li>
<li>Enable it on specific test cases where it&#x27;s required</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 04:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:230 on 2025-02-05 04:42</div>
            <div class="timeline-body"><p>I think I&#x27;ll need to add support for it in the test config. I&#x27;ll do that in a separate PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 05:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:80 on 2025-02-05 05:15</div>
            <div class="timeline-body"><p>Thanks, I think that makes sense.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 05:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:691 on 2025-02-05 05:18</div>
            <div class="timeline-body"><p>Thanks, I was planning to do this today :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-05 05:29</div>
            <div class="timeline-body"><p><strong>Todo:</strong></p>
<ul>
<li>[x] Address Carl&#x27;s review (<a href="https://github.com/astral-sh/ruff/pull/15848">astral-sh/ruff#15848</a>#discussion_r1941614832)</li>
<li>[ ] Check if the incremental regression still persists and figure out why that&#x27;s happening - Is the regression valid? Could it be addressed?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-05 09:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:25 on 2025-02-05 09:23</div>
            <div class="timeline-body"><blockquote>
<p>In the stub file case, the possibly harder part is that the type from <code>import foo</code> should ideally be ignored, and the inferred type would just be <code>Literal[&#x27;bar&#x27;]</code>. I think this might require changes in <code>symbol_from_bindings</code>?</p>
</blockquote>
<p>One challenge with this is that in <code>symbol_by_id</code> salsa query, if we were able to find the symbol using only declarations, we&#x27;d return that symbol. That would be the case in this scenario as <code>import foo</code> would provide a bound symbol, thus we would never consider the bindings:</p>
<p>https://github.com/astral-sh/ruff/blob/d757fc071b9d8fe914282bf73704f759f26bfbb4/crates/red_knot_python_semantic/src/types.rs#L128-L130</p>
<p>It might be related to #14297 reading the TODO mentioned in that issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-05 14:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2601 on 2025-02-05 14:05</div>
            <div class="timeline-body"><p>did you consider encoding the information on whether or not the type is a re-export in the <code>qualifiers</code> field? It feels like &quot;metadata carried along with the type&quot; in a similar way to the way that whether a symbol is a class variable or not is additional metadata that we carry around with the type of the symbol. We could possibly even rename <code>TypeQualifiers</code> to <code>TypeMetadata</code>, and add documentation saying that the metadata we record includes (but is not limited to) type qualifiers such as <code>ClassVar</code>?</p>
<p>I suppose the <code>ReExport::Maybe</code> variant means that we&#x27;d have to have two separate flags on the <code>TypeQualifiers</code> struct: <code>MAYBE_REEXPORT</code> and <code>DEFINITE_REEXPORT</code>.</p>
<p>Curious what @carljm thinks of this idea</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-06 05:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2601 on 2025-02-06 05:48</div>
            <div class="timeline-body"><p>I like that idea and it seems more prominent now because for the binding, the <code>Type</code> would also need to contain the re-export metadata. My only concern with this would be that the metadata structure would be shared for both declared and binding type so there&#x27;s a chance that we could mistakenly set metadata for binding type while it&#x27;s only relevant for a declared type. For example, setting the <code>Final</code> qualifier. Any thoughts on this? If it&#x27;s not a big concern then I might prefer to go this route.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-06 18:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:25 on 2025-02-06 18:01</div>
            <div class="timeline-body"><p>Hmm, yeah. That sample code I wrote is actually not valid, as we emit a diagnostic on <code>foo = &quot;bar&quot;</code> assignment, since it violates the import &quot;declaration&quot;. So I think it is actually OK that we ignore the invalid binding in this case. But if it were <code>foo: str = &quot;bar&quot;</code>, then I think my original point still holds; we&#x27;d want this to be a possibly-unbound symbol of type <code>str</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2601 on 2025-02-06 18:15</div>
            <div class="timeline-body"><p>The feeling I&#x27;ve had in looking at this PR is that this should be metadata on a <code>Definition</code> (possibly actually just on the <code>Import</code> and <code>ImportFrom</code> variants of <code>DefinitionKind</code>, which might save some space if those are not currently the largest variants). Then it would be handled in <code>symbol_from_bindings</code> and <code>symbol_from_declarations</code> (where we&#x27;d ignore non-re-exported definitions if querying a public global symbol from a stub file). In general, I think we should be looking for ways for this metadata to spread <em>less</em> widely, not more widely, because the cases where it is relevant are limited. I don&#x27;t think it needs to travel with Types in general, and I think ideally code in <code>TypeInferenceBuilder</code> would be totally unaffected by this change.</p>
<p>If we were just implementing the stub-file semantics this approach would be pretty simple, I think. The trickier part is the <code>implicit-reexport</code> rule, where we do want the type from the definition, plus some metadata that allows us to emit a diagnostic. To do this, we need <code>symbol_from_bindings</code>, <code>symbol_from_declarations</code>, and <code>symbol</code> to be able to pass back the metadata via <code>Symbol</code> that &quot;this type came from, or maybe came from, a not-re-exported definition&quot;, and then we do at least need the import handling code in <code>TypeInferenceBuilder</code> to inspect that metadata and emit a diagnostic.</p>
<p>I&#x27;m very tempted to just consider the opt-in <code>implicit-reexport</code> rule out of scope for now, because it&#x27;s adding a lot of complexity here, and I think the much more important thing right now is to fix the <code>builtins.pyi</code> problem. The ability to also opt-in to this rule in diagnostic form for non-stub files is nice to have, but not high priority right now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-06 18:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-06 18:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2601 on 2025-02-06 18:17</div>
            <div class="timeline-body"><p>Happy to go with Carl&#x27;s suggestion here; he&#x27;s looked at this more closely than I have and it sounds very reasonable!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-02-07 12:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2601 on 2025-02-07 12:34</div>
            <div class="timeline-body"><blockquote>
<p>The feeling I&#x27;ve had in looking at this PR is that this should be metadata on a <code>Definition</code> (possibly actually just on the <code>Import</code> and <code>ImportFrom</code> variants of <code>DefinitionKind</code>, which might save some space if those are not currently the largest variants). Then it would be handled in <code>symbol_from_bindings</code> and <code>symbol_from_declarations</code> (where we&#x27;d ignore non-re-exported definitions if querying a public global symbol from a stub file). In general, I think we should be looking for ways for this metadata to spread <em>less</em> widely, not more widely, because the cases where it is relevant are limited. I don&#x27;t think it needs to travel with Types in general, and I think ideally code in <code>TypeInferenceBuilder</code> would be totally unaffected by this change.</p>
</blockquote>
<p>I looked into implementing based on this comment, I originally thought of this as well but I didn’t pursue this because of the requirement of inferring the types.</p>
<p>To give context, the plan is to define a <code>is_reexported</code> field on both <code>ImportDefinitionKind</code> and <code>ImportFromDefinitionKind</code> and use that as <code>Definition::is_reeexported</code> which would default to <code>true</code> for non-import definitions.</p>
<p>This will be then used in <code>symbol_from_declarations</code> and <code>symbol_from_bindings</code> to filter out the definitions. This creates a problem as both functions does not know whether the symbol is coming from the current module or from another module. This means that for the following code (file <code>other.pyi</code>):</p>
<pre><code>from typing import Any

# error: Name `Any` used when not defined
reveal_type(Any)
</code></pre>
<p>The reason being that while looking up the <code>Any</code> symbol in the <code>reaveal_type</code> call, we’ll first encounter the import definition which doesn’t re-export the symbol but the <code>symbol_from_*</code> does not know that this symbol is coming from the current module itself. We’ll need to pass additional info for the <code>symbol_from_*</code> functions to only consider the re-exports from another module.</p>
<p>Implementation diff: https://github.com/astral-sh/ruff/compare/dhruv/re-export-2?expand=1</p>
<hr>
<p>Given the above context, I took a stab at addressing some of the short comings for conditional re-exports via the existing implementation and I think I&#x27;ve addressed Carl&#x27;s feedback from <a href="https://github.com/astral-sh/ruff/pull/15848">astral-sh/ruff#15848</a>#discussion_r1941614832.</p>
<p>I&#x27;ve added four more examples to test conditional re-exports.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conditional.md</code>:98 on 2025-02-07 17:38</div>
            <div class="timeline-body"><p>can we add a TODO here? once we are able to properly make <code>implicit-reexport</code> rule disabled by default, I would rather this test not use this explicit re-export syntax, it distracts from the point of the test</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conditional.md</code>:128 on 2025-02-07 17:38</div>
            <div class="timeline-body"><p>same here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2601 on 2025-02-07 17:49</div>
            <div class="timeline-body"><blockquote>
<p>We’ll need to pass additional info for the symbol_from_* functions to only consider the re-exports from another module.</p>
</blockquote>
<p>Yes, I meant to imply that with &quot;if querying a public global symbol from a stub file&quot;, but I should have been more explicit. Adding this extra context to <code>symbol</code> and friends doesn&#x27;t bother me because I think we&#x27;ll need it anyway in order to resolve #15777 -- our current conflation of &quot;type as seen by import&quot; and &quot;type as seen by use from nested scope&quot; is not going to last. We probably need a function specifically for getting an imported symbol from a different file.</p>
<p>I still think it would be better to switch to this approach and add this additional context. I don&#x27;t like how the re-export metadata in the current version of the diff infects everywhere we use <code>Symbol</code>, even though it is relevant in so few places, and I suspect this is also related to the regression.</p>
<p>I think it would actually be better to separate the stub-file unconditional behavior from the <code>implicit-reexport</code> rule as separate PRs. One small reason is just that it would be nice to add the <code>implicit-reexport</code> rule once we already have full support for making it opt-in, to avoid TODO churn in other tests. It is worth considering how we can implement the opt-in rule on top of the second approach, but I think the plan would be fairly clear: the function that implements getting a symbol&#x27;s type for import would return a wrapper around <code>Symbol</code> that also includes the re-exported metadata, so the importing code can issue the diagnostic if necessary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-07 18:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:378 on 2025-02-07 18:09</div>
            <div class="timeline-body"><p>This should be just <code>str</code>; the <code>Foo</code> class type should not be visible here at all. I think this behavior change will naturally fall out of the alternate implementation strategy.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/import/conventions.md</code>:368 on 2025-02-07 18:10</div>
            <div class="timeline-body"><p>These new tests look great! Modulo one comment below</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-07 18:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-11 04:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-11 07:51</div>
            <div class="timeline-body"><p>Closing in favor of astral-sh/ruff#16073</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-02-11 07:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-30 15:47</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:10:59 UTC
    </footer>
</body>
</html>
