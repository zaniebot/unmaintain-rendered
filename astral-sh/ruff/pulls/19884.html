<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] simplify return type of place_from_declarations - astral-sh/ruff #19884</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] simplify return type of place_from_declarations</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19884">#19884</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-08-12 19:05
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>A <a href="https://github.com/astral-sh/ruff/pull/19711#issuecomment-3169312014">passing comment</a> led me to explore why we didn't report a class attribute as possibly unbound if it was a method and defined in two different conditional branches.</p>
<p>I found that the reason was because of our handling of &quot;conflicting declarations&quot; in <code>place_from_declarations</code>. It returned a <code>Result</code> which would be <code>Err</code> in case of conflicting declarations.</p>
<p>But we only actually care about conflicting declarations when we are actually doing type inference on that scope and might emit a diagnostic about it. And in all cases (including that one), we want to otherwise proceed with the union of the declared types, as if there was no conflict.</p>
<p>In several cases we were failing to handle the union of declared types in the same way as a normal declared type if there was a declared-types conflict. The <code>Result</code> return type made this mistake really easy to make, as we'd match on e.g. <code>Ok(Place::Type(...))</code> and do one thing, then match on <code>Err(...)</code> and do another, even though really both of those cases should be handled the same.</p>
<p>This PR refactors <code>place_from_declarations</code> to instead return a struct which always represents the declared type we should use in the same way, as well as carrying the conflicting declared types, if any. This struct has a method to allow us to explicitly ignore the declared-types conflict (which is what we want in most cases), as well as a method to get the declared type and the conflict information, in the case where we want to emit a diagnostic on the conflict.</p>
<h2>Test Plan</h2>
<p>Existing CI; added a test showing that we now understand a multiply-conditionally-defined method as possibly-unbound.</p>
<p>This does trigger issues on a couple new fuzzer seeds, but the issues are just new instances of an already-known (and rarely occurring) problem which I already plan to address in a future PR, so I think it's OK to land as-is.</p>
<p>I happened to build this initially on top of https://github.com/astral-sh/ruff/pull/19711, which adds invalid-await diagnostics, so I also updated some invalid-syntax tests to not await on an invalid type, since the purpose of those tests is to check the syntactic location of the <code>await</code>, not the validity of the awaited type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @carljm on 2025-08-12 19:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-12 19:07</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-08-13 14:15:20.459792009 +0000
+++ new-output.txt	2025-08-13 14:15:20.528792019 +0000
@@ -1,5 +1,5 @@
 WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/918d35d/src/function/execute.rs:215:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(218b3)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/918d35d/src/function/execute.rs:215:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(2367a)): execute: too many cycle iterations`
 _directives_deprecated_library.py:15:31: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `int`
 _directives_deprecated_library.py:30:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `str`
 _directives_deprecated_library.py:36:41: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Self@__add__`
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-12 19:10</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅
No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-13 01:29</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @carljm on 2025-08-13 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2025-08-13 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @carljm on 2025-08-13 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @carljm on 2025-08-13 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-08-13 06:32</div>
            <div class="timeline-body"><p>Thank you for looking into this.</p>
<blockquote>
<p>But we only actually care about conflicting declarations when we are actually doing type inference on that scope and might emit a diagnostic about it. And in all cases (including that one), we want to otherwise proceed with the union of the declared types, as if there was no conflict.</p>
</blockquote>
<p>To me, this doesn't sound much different to the <code>Type::try_*</code> methods that all return a <code>Result</code>. It seems that the main issue isn't that the return type is a <code>Result</code>, but that</p>
<ol>
<li>We call <code>.ok()</code> on the result in some places when we shouldn't</li>
<li>We don't track the <code>PlaceAndQualifiers</code> for declarations with conflicts.</li>
</ol>
<p>I don't feel strongly but I would prefer, if possible without much added complexity, to follow the same pattern that we use in our <code>Type::try_</code> methods instead of establishing another pattern. Which means, <code>place_from_declarations</code> would still return a <code>Result</code> but the type wrapped in the <code>Err</code> variant has a method to get the <code>PlaceAndQualifiers</code> for situations where we don't care about conflicting declarations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-13 13:54</div>
            <div class="timeline-body"><blockquote>
<p>this doesn't sound much different to the <code>Type::try_*</code> methods</p>
</blockquote>
<p>It seems quite different to me, because <code>place_from_declarations</code> never &quot;fails&quot; -- it always succeeds, and always succeeds using exactly the same logic to determine its return type. It just in some cases also provides extra information that some callers may want to use to emit a diagnostic for the user. The key difference is that we <em>always</em> (at literally every possibly callsite) want to handle the returned value in <em>exactly</em> the same way, we <em>never</em> want to distinguish the handling between Ok and Err cases (except that in one callsite we <em>additionally</em> want to emit a diagnostic if conflicting-types were returned -- but we still handle the main return value identically.)</p>
<p>I think a better parallel is our <code>Place</code> type (the Bound and PossiblyUnbound cases), where we have a <code>.ignore_possibly_unbound()</code> method.</p>
<p>So I think this is following existing patterns in the codebase, just different ones (which I think are more similar to this case.)</p>
<blockquote>
<p><code>place_from_declarations</code> would still return a <code>Result</code> but the type wrapped in the <code>Err</code> variant has a method to get the <code>PlaceAndQualifiers</code> for situations where we don't care about conflicting declarations.</p>
</blockquote>
<p>I don't think this would address the problem I aimed to fix in this PR.  It isn't possible to add an <code>.ignore_conflicting_declarations()</code> method directly to <code>Result</code>, so it would remain the case that we would need separate paths in every callsite to handle the <code>Ok</code> and <code>Err</code> versions, introducing the risk that we fail to handle them the same. A match arm for <code>Ok(...)</code> would not match the <code>Err</code> variant, leading to bugs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-08-13 14:00</div>
            <div class="timeline-body"><blockquote>
<p>It seems quite different to me, because place_from_declarations never &quot;fails&quot; -- it always succeeds, and always succeeds using exactly the same logic to determine its return type.</p>
</blockquote>
<p>Thanks, I think this is the key distinction that wasn't clear to me</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/place.rs</code>:505 on 2025-08-13 14:02</div>
            <div class="timeline-body"><p>Nit: The <code>with</code> naming here suggests that this creates a new <code>PlaceFromDeclarationResult</code>. Should this be <code>into_conflicting_declarations</code> or similar?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-08-13 14:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-13 14:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/place.rs</code>:505 on 2025-08-13 14:07</div>
            <div class="timeline-body"><p>Yeah, I wasn't sure of the best naming for this method, probably the most clear name would be <code>into_place_and_qualifiers_and_conflicting_declarations</code> but that's quite a mouthful :) On the other hand, there's only one callsite, so maybe a mouthful is fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-08-13 14:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-08-13 14:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-08-13 14:17</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:15:01 UTC
    </footer>
</body>
</html>
