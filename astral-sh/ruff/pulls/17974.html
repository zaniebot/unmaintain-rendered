<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Support frozen dataclasses - astral-sh/ruff #17974</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Support frozen dataclasses</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17974">#17974</a>
        opened by <a href="https://github.com/thejchap">@thejchap</a>
        on 2025-05-09 02:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thejchap">@thejchap</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>https://github.com/astral-sh/ty/issues/111</p>
<p>This PR adds support for <code>frozen</code> dataclasses. It will emit a diagnostic with a similar message to mypy</p>
<p>Note: This does not include emitting a diagnostic if <code>__setattr__</code> or <code>__delattr__</code> are defined on the object as per the <a href="https://docs.python.org/3/library/dataclasses.html#module-contents">spec</a></p>
<h2>Test Plan</h2>
<p>mdtest</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @thejchap on 2025-05-09 02:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @thejchap on 2025-05-09 02:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @thejchap on 2025-05-09 02:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @thejchap on 2025-05-09 02:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/thejchap">@thejchap</a> on 2025-05-09 02:13</div>
            <div class="timeline-body"><p>@sharkdp ready for some feedback - let me know if this is headed in the right direction</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-05-09 02:16</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">attrs (https://github.com/python-attrs/attrs)
+ error[invalid-assignment] tests/dataclass_transform_example.py:32:1: Property `a` defined in `Frozen` is read-only
- error[invalid-assignment] tests/test_next_gen.py:219:13: Object of type `Literal[2]` is not assignable to attribute `x` of type `str`
+ error[invalid-assignment] tests/test_next_gen.py:219:13: Property `x` defined in `F` is read-only
+ error[invalid-assignment] tests/test_next_gen.py:258:13: Property `a` defined in `A` is read-only
+ error[invalid-assignment] tests/test_next_gen.py:261:13: Property `a` defined in `B` is read-only
+ error[invalid-assignment] tests/test_next_gen.py:264:13: Property `b` defined in `B` is read-only
- Found 617 diagnostics
+ Found 621 diagnostics

sympy (https://github.com/sympy/sympy)
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1683:13: Object of type `None` is not assignable to attribute `tendon_force_length` of type `CharacteristicCurveFunction`
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1683:13: Property `tendon_force_length` defined in `CharacteristicCurveCollection` is read-only
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1685:13: Object of type `None` is not assignable to attribute `tendon_force_length_inverse` of type `CharacteristicCurveFunction`
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1687:13: Object of type `None` is not assignable to attribute `fiber_force_length_passive` of type `CharacteristicCurveFunction`
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1689:13: Object of type `None` is not assignable to attribute `fiber_force_length_passive_inverse` of type `CharacteristicCurveFunction`
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1691:13: Object of type `None` is not assignable to attribute `fiber_force_length_active` of type `CharacteristicCurveFunction`
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1685:13: Property `tendon_force_length_inverse` defined in `CharacteristicCurveCollection` is read-only
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1687:13: Property `fiber_force_length_passive` defined in `CharacteristicCurveCollection` is read-only
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1689:13: Property `fiber_force_length_passive_inverse` defined in `CharacteristicCurveCollection` is read-only
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1691:13: Property `fiber_force_length_active` defined in `CharacteristicCurveCollection` is read-only
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1693:13: Object of type `None` is not assignable to attribute `fiber_force_velocity` of type `CharacteristicCurveFunction`
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1693:13: Property `fiber_force_velocity` defined in `CharacteristicCurveCollection` is read-only
- error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1695:13: Object of type `None` is not assignable to attribute `fiber_force_velocity_inverse` of type `CharacteristicCurveFunction`
+ error[invalid-assignment] sympy/physics/biomechanics/tests/test_curve.py:1695:13: Property `fiber_force_velocity_inverse` defined in `CharacteristicCurveCollection` is read-only

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:2930 on 2025-05-09 03:31</div>
            <div class="timeline-body"><p>Should we have a TODO here for generic dataclasses?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:2938 on 2025-05-09 03:32</div>
            <div class="timeline-body"><p>It looks like at the moment we'll emit this for any attempt to set any attribute on a frozen dataclass. If the attribute does not exist on the dataclass, this seems like a confusing error message, because the attribute is not in fact defined on the type at all. Would it be better in that case to not emit this message, and just the unresolved-attribute one below?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-09 03:33</div>
            <div class="timeline-body"><p>Code and ecosystem results look pretty good to me. A couple comments. Thanks for the PR!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/dataclasses.md</code>:372 on 2025-05-09 06:48</div>
            <div class="timeline-body"><pre><code class="language-suggestion">If true (the default is False), assigning to fields will generate a diagnostic. If `__setattr__()` or
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/dataclasses.md</code>:373 on 2025-05-09 06:48</div>
            <div class="timeline-body"><pre><code class="language-suggestion">`__delattr__()` is defined in the class, we should emit a diagnostic.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-05-09 06:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @MichaReiser on 2025-05-09 06:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thejchap">@thejchap</a> reviewed on 2025-05-09 23:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/thejchap">@thejchap</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:2938 on 2025-05-09 23:09</div>
            <div class="timeline-body"><p>@carljm ah thanks - this makes sense. i also checked how mypy handles this for <code>INVALID_ATTRIBUTE_ACCESS</code> above that and appears to be the same - they'll only emit the read-only diagnostic for frozen dataclasses if it looks like it would be assignable otherwise:</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import ClassVar

@dataclass(frozen=True)
class Starship:
    damage: ClassVar[int] = 1

s = Starship()
s.damage = 2 # error: Cannot assign to class variable &quot;damage&quot; via instance  [misc]
</code></pre>
<p>changed the logic so we only emit the read-only diagnostic if it looks like the attribute assignment would otherwise be valid</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thejchap">@thejchap</a> reviewed on 2025-05-09 23:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/thejchap">@thejchap</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:2930 on 2025-05-09 23:09</div>
            <div class="timeline-body"><p>implemented for generic dataclasses</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @thejchap on 2025-05-09 23:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:2936 on 2025-05-09 23:24</div>
            <div class="timeline-body"><p>This is a bit too cryptic for our usual coding style, we could call it <code>read_only</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3090 on 2025-05-09 23:28</div>
            <div class="timeline-body"><p>The change to prioritize &quot;unresolved-attribute&quot; over the read-only error looks great -- but I think I have the reverse issue now. If the assigned type is not assignable to the attribute type, and the attribute is read-only, which of those do you think should take priority? I think it would actually be fine to emit both, but if we emit only one of those two errors in that scenario, I think it should be the read-only error. It doesn't make sense to send the user on a mission to fix the assigned type, when we'll only then tell them the attribute is read-only; we should tell them it's read-only right upfront. WDYT?</p>
<p>The read-only error should also take precedence over the descriptor <code>__set__</code> handling, because that's what happens at runtime -- even if the attribute of a frozen dataclass is a descriptor, its <code>__set__</code> method is not called, you just get the read-only error.</p>
<p>I think this will require integrating the read-only error into the block of cases above (I think it should be the first thing we check in the block starting on 2957 for &quot;there is an attribute of this name&quot;) rather than trying to handle it externally. I think we can also move looking up whether this is a frozen dataclass into that arm, because I don't think we need it otherwise -- both the ClassVar error and the Unbound handling don't need to check for a frozen dataclass, I don't think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-09 23:38</div>
            <div class="timeline-body"><p>Thanks for the updates! On looking at the new version more closely, I think we still need to adjust the priority of this error relative to other ones. Sorry I didn't comment on this more thoroughly the first time around! More detailed comment inline.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thejchap">@thejchap</a> reviewed on 2025-05-10 01:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/thejchap">@thejchap</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3090 on 2025-05-10 01:39</div>
            <div class="timeline-body"><blockquote>
<p>It doesn't make sense to send the user on a mission</p>
</blockquote>
<p>yes this definitely makes sense from a ux perspective, good call</p>
<blockquote>
<p>if the attribute of a frozen dataclass is a descriptor, its <strong>set</strong> method is not called</p>
</blockquote>
<p>also makes sense, thank you!</p>
<blockquote>
<p>both the ClassVar error and the Unbound handling don't need to check for a frozen dataclass</p>
</blockquote>
<p>makes sense <code>ClassVar</code> doesn't, hadn't thought that through enough - although i <em>think</em> the unbound handling might also need to check for a frozen dataclass. if it doesn't, the <code>a.x = 2</code> assignment below won't emit a diagnostic because the <code>x: int</code> type declaration/meta attr is unbound for <code>A</code>:</p>
<pre><code class="language-python">from dataclasses import dataclass

@dataclass(frozen=True)
class A:
    x: int

a = A(1)
a.x = 2 # no diagnostic

@dataclass(frozen=True)
class B:
    x: int = 1

b = B()
b.x = 2 # emits read-only diagnostic
</code></pre>
<p>this wasn't super intuitive to me - i would have thought from <a href="https://github.com/thejchap/ruff/blob/09a0af526db2fe51e41c6baf7cf02d66a21c3057/crates/ty_python_semantic/src/symbol.rs#L446">this comment</a> that <code>x: int</code> would be considered bound in both cases, but i'm probably not fully grokking whats going on here</p>
<blockquote>
<p>Sorry I didn't comment on this more thoroughly</p>
</blockquote>
<p>no problem! i appreciate the guidance (and patience :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-10 03:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3090 on 2025-05-10 03:16</div>
            <div class="timeline-body"><p>Is that speculation or something you are seeing in your results? Because I also think (because we kind of conflate declaredness and boundness in a way we maybe shouldn't) that both <code>A.x</code> and <code>B.x</code> will actually report back Bound in that example. If that's not what you're seeing, I'd need to dig in further to understand it. It looks to me like the Unbound handling here is only for the cases where there is no such instance attribute at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/thejchap">@thejchap</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3090 on 2025-05-10 03:56</div>
            <div class="timeline-body"><p>that's what i'm seeing in results - added a failing test case to illustrate</p>
<p>in <a href="https://github.com/astral-sh/ruff/pull/17974/files#diff-b4041b42031acb5cb1ebfe219a8ce6fb02b3d73ada7e0605b1cf6353465f56c4R382">this test</a>, if the <code>1</code> is moved out of the constructor and instead set as a default value for <code>x</code>, it hits the other branch (now starting line 2958) and emits the diagnostic as expected</p>
<p>i can do a little more digging next week as well</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thejchap">@thejchap</a> reviewed on 2025-05-10 03:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-22 03:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3090 on 2025-05-22 03:58</div>
            <div class="timeline-body"><p>Sorry, this was my mistake; I'd failed to realize that the outer Unbound check was for looking up a <em>class</em> member. An <code>x: int</code> annotation at class level with no binding describes an instance-only attribute (in our model), so it comes back Unbound on the class. Which is why we then do an <code>instance_member</code> lookup. So I think the code you added (and then commented out) is necessary and correct. (I did make one small change to wrap up the dataclass work in a closure, so we only do that work if we need it.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-05-22 04:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-05-22 04:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-22 04:20</div>
            <div class="timeline-body"><p>Thank you for the PR! Merged.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-22 07:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3103 on 2025-05-22 07:12</div>
            <div class="timeline-body"><p>Sorry for the retroactive review, I somehow missed this PR until it was merged.</p>
<p>I think what you have here is a great initial step!</p>
<p>The check here seems like it might be slightly inaccurate for some cases though. For example, it would allow you to modify the field of a frozen dataclass through a derived class instance:</p>
<pre><code class="language-py">class InheritsFromDataclass(MyFrozenClass):
    pass

instance = InheritsFromDataclass(1)
instance.x = 2  # no error here, because `InheritsFromDataclass` has no dataclass params
</code></pre>
<p>I was wondering if <code>frozen</code> could be (more accurately?) modeled by actually synthesizing the <a href="https://docs.python.org/3/library/dataclasses.html#frozen-instances">generated <code>__setattr__</code> method</a>, and setting it up with a signature that returns <code>Never</code>. In the code here, we would then need to properly handle the <code>__setattr__</code> call (we already do, but only if the attribute is present... which seems wrong?). And if it returns <code>Never</code>, we would yield a <code>invalid-assignment</code> diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-22 14:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3103 on 2025-05-22 14:24</div>
            <div class="timeline-body"><p>I updated https://github.com/astral-sh/ty/issues/111 to mention this as a needed improvement</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thejchap">@thejchap</a> reviewed on 2025-05-27 07:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/thejchap">@thejchap</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3103 on 2025-05-27 07:39</div>
            <div class="timeline-body"><p>@sharkdp thanks! this is helpful - couple questions</p>
<blockquote>
<p>we already do, but only if the attribute is present</p>
</blockquote>
<p>do you mean if the attribute <em>isn't</em> present (or am i misinterpreting)? it looks to me like the <code>__setattr__</code> <a href="https://github.com/thejchap/ruff/blob/6453ac9ea13a6d7c684fc7a8e02d69cebf4339ff/crates/ty_python_semantic/src/types/infer.rs#L3240">lookup</a> is only done if the attribute <a href="https://github.com/thejchap/ruff/blob/6453ac9ea13a6d7c684fc7a8e02d69cebf4339ff/crates/ty_python_semantic/src/types/infer.rs#L3213">isn't found as an instance member</a></p>
<p>if so, then would the change be something like:</p>
<ul>
<li>when validating attribute assignment, look up if any classes in <code>obj</code>'s MRO have dataclass params</li>
<li>if so, only doing the <code>__setattr__</code> lookup instead of first trying the instance member lookup</li>
<li>adding a branch in <code>own_synthesized_member</code> for <code>(CodeGeneratorKind::DataclassLike, &quot;__setattr__&quot; | &quot;__delattr__&quot;)</code> with the <code>Never</code> return type like you mention</li>
<li>emitting the diagnostic if we get that <code>Never</code> return type</li>
</ul>
<p>as an aside/unrelated-</p>
<p>it looks like inheriting a class and redefining <code>x</code>s type on the subclass isn't emitting a diagnostic:</p>
<pre><code class="language-py">class A:
    x: int

class B(A):
    x: str
</code></pre>
<p>where on mypy we get:</p>
<p><code>../test.py:5: error: Incompatible types in assignment (expression has type &quot;str&quot;, base class &quot;A&quot; defined the type as &quot;int&quot;)  [assignment]</code></p>
<p>did a quick scan of issues and didn't see this anywhere, happy to add one if thats right</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-05-27 07:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3103 on 2025-05-27 07:43</div>
            <div class="timeline-body"><blockquote>
<p>it looks like inheriting a class and redefining <code>x</code>s type on the subclass isn't emitting a diagnostic:</p>
<pre><code class="language-python">class A:
    x: int

class B(A):
    x: str
</code></pre>
</blockquote>
<p>This is https://github.com/astral-sh/ty/issues/166 :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-27 08:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:3103 on 2025-05-27 08:08</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>we already do, but only if the attribute is present</p>
</blockquote>
<p>do you mean if the attribute <em>isn't</em> present (or am i misinterpreting)? it looks to me like the <code>__setattr__</code> <a href="https://github.com/thejchap/ruff/blob/6453ac9ea13a6d7c684fc7a8e02d69cebf4339ff/crates/ty_python_semantic/src/types/infer.rs#L3240">lookup</a> is only done if the attribute <a href="https://github.com/thejchap/ruff/blob/6453ac9ea13a6d7c684fc7a8e02d69cebf4339ff/crates/ty_python_semantic/src/types/infer.rs#L3213">isn't found as an instance member</a></p>
</blockquote>
<p>Oh, yes, sorry. The <code>__setattr__</code> call check is only done if the attribute isn't found as a class member and if it isn't found as an instance member. But that seems wrong. <a href="https://docs.python.org/3/reference/datamodel.html#object.__setattr__"><code>__setattr__</code> is called unconditionally</a> when trying to set an attribute on an instance. So in the following example, both attribute assignments fail. But we would only check the call to <code>__setattr__</code> in the <code>non_existing</code> case.</p>
<pre><code class="language-py">from typing import Never


class Frozen:
    existing: int = 1

    def __setattr__(self, name, value) -&gt; Never:
        raise AttributeError(&quot;Attributes can not be modified&quot;)


instance = Frozen()
instance.non_existing = 2  # fails at runtime
instance.existing = 2  # also fails at runtime
</code></pre>
<p>We currently don't emit any errors for this program (but it fails at runtime). So it seems reasonable to me to check the <code>__setattr__</code> call for both of these assignments. And because we see <code>Never</code> as a return type, emit a diagnostic for both of these assignments (which seems like the user intent).</p>
<p>Once this is implemented, we would only need to synthesize a <code>__setattr__</code> method (with a <code>Never</code> return type) for frozen dataclasses (which actually happens at runtime). And this would also solve the inheritance problem, I believe.</p>
<p>Maybe we should do the first step here in isolation (check <code>__setattr__</code> return type) to see the impact on the ecosystem (via the automated mypy_primer run when opening a PR)?</p>
<blockquote>
<p>when validating attribute assignment, look up if any classes in <code>obj</code>'s MRO have dataclass params</p>
</blockquote>
<p>I don't think that's necessary.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:12:21 UTC
    </footer>
</body>
</html>
