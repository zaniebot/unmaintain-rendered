<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`[DLINT]` Add Dlint plugin and first rule DUO138 - astral-sh/ruff #5614</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>[DLINT]</code> Add Dlint plugin and first rule DUO138</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/5614">#5614</a>
        opened by <a href="https://github.com/qdegraaf">@qdegraaf</a>
        on 2023-07-08 14:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Adds Dlint plugin port and a first rule <code>DUO138</code> <code>catastrophic_backtracking_regular_expression</code> which checks for regex statements which can potentially lead to catastrophic backtracking and hence are vulnerable to ReDoS attacks.</p>
<p>Upstream implementation uses <code>sre.parse</code>. We do not have this so we use the <code>regex_syntax</code> crate. We cannot directly copy the logic from dlint due to this so we have to find our own implementation</p>
<p>TODOs:</p>
<ul>
<li>[x] Implement unbounded repetition within repetition logic for catastrophic backtracking in <code>detect_redos()</code></li>
<li>[ ] Implement alternation with overlap logic for catastrophic backtracking in <code>detect_redos()</code></li>
</ul>
<h2>Test Plan</h2>
<p>Fixture added with many examples of catastrophic backtracking</p>
<h2>Issue links</h2>
<p>Refers: https://github.com/astral-sh/ruff/issues/4479</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/dlint/rules/catastrophic_re_use.rs</code>:45 on 2023-07-10 07:57</div>
            <div class="timeline-body"><p>Nit: I'm not sure if we need the word <code>dangerous</code> here, especially because it isn't entirely clear to what dangerous refers (I assume it is dangerous because of the performance).</p>
<p>How about:
<code>Regular expression with potential catastrophic backtracking</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/dlint/rules/catastrophic_re_use.rs</code>:40 on 2023-07-10 07:58</div>
            <div class="timeline-body"><p>Maybe <code>CatastrophicBacktrackingRegularExpression</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-07-10 07:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-07-10 09:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/src/rules/dlint/rules/catastrophic_re_use.rs</code>:45 on 2023-07-10 09:06</div>
            <div class="timeline-body"><p>The danger lies in the potential for ReDoS: https://owasp.org/www-community/attacks/Regular_expression_Denial_of_Service_-_ReDoS</p>
<p>I'll change the message anyway, or specify &quot;vulnerable to ReDoS&quot; to be more specific</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on 2023-07-10 11:20</div>
            <div class="timeline-body"><p>Seeing as you already had a look I will pose the following question to you @MichaReiser .</p>
<p>If I understand the rule correctly to cover the same heuristic ground as the upstream implementation we would have to check two scenarios:</p>
<ol>
<li>Unbounded repetition within repetition</li>
<li>Overlapping alternation within repetition</li>
</ol>
<p>The current code should cover scenario 1. I have been trying to get scenario 2 to work but I think we are limited by the <code>regex_syntax</code> parser here. As for example the following two test cases from dlint:</p>
<pre><code class="language-python">re.search(&quot;([a-c]|[c-e])+&quot;)  # DUO138

re.search(&quot;([a-c]|[d-e])+&quot;)  # OK
</code></pre>
<p>Both share the same HIR representation:</p>
<pre><code>Repetition(
    Repetition {
        min: 1,
        max: None,
        greedy: true,
        sub: Capture(
            Capture {
                index: 1,
                name: None,
                sub: Class(
                    {
                        'a'..='e',
                    },
                ),
            },
        ),
    },
)
Repetition(
    Repetition {
        min: 1,
        max: None,
        greedy: true,
        sub: Capture(
            Capture {
                index: 1,
                name: None,
                sub: Class(
                    {
                        'a'..='e',
                    },
                ),
            },
        ),
    },
)
</code></pre>
<p>So it would not be possible for us to determine overlap based on the HIR. The alternative is to write a custom parser or use the underlying AST of regex_syntax to detect this, which is outside of my current knowledge and skill level at the moment I think.</p>
<p>There's a couple things I could do with the PR I was wondering if you had any preference:</p>
<ol>
<li>We implement the rule with just a check for scenario 1 for now (cleaning up and thorough reviewing etc. in the process) and leave scenario 2 as a TODO for the future<ul>
<li><code>+</code> Potentially justifiable as vulnerable regex can come in many forms and catching all of them is outside the scope of upstream plugin too. Covering some cases is arguably better than covering no cases if we are clear about the coverage of the rule and minimise the risk of false positives.</li>
<li><code>-</code> might be confusing and sloppy</li>
<li><code>-</code> Judging by the benchmark, current implementation is quite slow, which might be due to the HIR parser. Meaning even if we are ok with the coverage of the rule, the performance might be undesirable.</li>
</ul>
</li>
<li>Refactor the PR to use a different or custom regex parser and cover both scenarios<ul>
<li><code>+</code> Best implementation of the rule, parity with upstream.</li>
<li><code>-</code> Outside of my capabilities in the short term, will either need a lot of help/input and/or a lot of time</li>
<li><code>-</code> Performance might still be an issue</li>
</ul>
</li>
<li>Close the PR<ul>
<li>If current implementation is subpar and scenario 2 is not feasible right now, probably best to close this and come back to it later</li>
</ul>
</li>
</ol>
<p>Let me know which option is preferred from a maintainer point-of-view.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluetech">@bluetech</a> on 2023-07-10 15:08</div>
            <div class="timeline-body"><p>I don't think the regex syntax implemented by <code>regex-syntax </code> is fully compatible with Python's regex syntax, so it might parse invalid Python regex, or inversely fail to parse valid Python regex. That might be a problem?</p>
<p>Relatedly, the code currently does <code>parser.parse(regex_string).unwrap()</code>. I think that <code>unwrap</code> shouldn't be used here, because it's possible for invalid regex to appear in Python source code and Ruff shouldn't crash due to this (I recommend adding a few tests with invalid regex syntax). As for what to do in this case, I think the only thing that can be done is to just skip. Possibly can be a separate &quot;invalid regex&quot; lint rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on 2023-07-10 15:38</div>
            <div class="timeline-body"><blockquote>
<p>I don't think the regex syntax implemented by <code>regex-syntax </code> is fully compatible with Python's regex syntax, so it might parse invalid Python regex, or inversely fail to parse valid Python regex. That might be a problem?</p>
<p>Relatedly, the code currently does <code>parser.parse(regex_string).unwrap()</code>. I think that <code>unwrap</code> shouldn't be used here, because it's possible for invalid regex to appear in Python source code and Ruff shouldn't crash due to this (I recommend adding a few tests with invalid regex syntax). As for what to do in this case, I think the only thing that can be done is to just skip. Possibly can be a separate &quot;invalid regex&quot; lint rule.</p>
</blockquote>
<p>Yeah that's another point of concern indeed. I have yet to find an overview of the differences between Rust and Python regex and thereby estimate the size of potential incompatibility. As for the <code>unwrap()</code> I'll handle that properly if this PR is worth continuing (skipping probably being the best option, though this could add false negatives to an already flaky implementation). I am leaning more towards closing this and looking at how we want to handle regex related rules holistically as I think on it though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on 2023-07-20 09:43</div>
            <div class="timeline-body"><p>Closing this for now. I think this is best picked up when Ruff has a more general plan for how to handle Python regex statements.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @qdegraaf on 2023-07-20 09:43</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:58:37 UTC
    </footer>
</body>
</html>
