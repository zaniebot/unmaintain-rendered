<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[syntax-errors] Start detecting compile-time syntax errors - astral-sh/ruff #16106</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[syntax-errors] Start detecting compile-time syntax errors</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16106">#16106</a>
        opened by <a href="https://github.com/ntBre">@ntBre</a>
        on 2025-02-11 21:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR implements the &quot;greeter&quot; approach for checking the AST for syntax errors emitted by the CPython compiler. It introduces two main infrastructural changes to support all of the compile-time errors:</p>
<ol>
<li>Adds a new <code>semantic_errors</code> module to the parser crate with public <code>SemanticSyntaxChecker</code> and <code>SemanticSyntaxError</code> types</li>
<li>Embeds a <code>SemanticSyntaxChecker</code> in the <code>ruff_linter::Checker</code> for checking these errors in ruff</li>
</ol>
<p>As a proof of concept, it also implements detection of two syntax errors:</p>
<ol>
<li>A reimplementation of <a href="https://docs.astral.sh/ruff/rules/late-future-import/"><code>late-future-import</code></a> (<code>F404</code>)</li>
<li>Detection of rebound comprehension iteration variables (https://github.com/astral-sh/ruff/issues/14395)</li>
</ol>
<h2>Test plan</h2>
<p>Existing F404 tests, new inline tests in the <code>ruff_python_parser</code> crate, and a linter CLI test showing an example of the <code>Message</code> output.</p>
<p>I also tested in VS Code, where <code>preview = false</code> and turning off syntax errors both disable the new errors:</p>
<p><img src="https://github.com/user-attachments/assets/cf453d95-04f7-484b-8440-cb812f29d45e" alt="image" /></p>
<p>And on the playground, where <code>preview = false</code> also disables the errors:</p>
<p><img src="https://github.com/user-attachments/assets/a97570c4-1efa-439f-9d99-a54487dd6064" alt="image" /></p>
<p>Fixes #14395</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2025-02-11 21:36</div>
            <div class="timeline-body"><p>I don't think we should use another collection here. We should either push directly into <code>TypeCheckDiagnostics</code> or, what I'd prefer, move this to the semantic index phase.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:96 on 2025-02-11 21:39</div>
            <div class="timeline-body"><p>I don't think I'd implement <code>SourceOrderVisitor</code> here because you never call into <code>walk_stmt</code> or similar, so it sort of feels unnecessary. Instead, I'd only implement the methods that you plan on calling from <code>Checker</code> / Red Knot's visiting logic. For now, all you'd need is to have a <code>enter_stmt(&amp;mut self, stmt: &amp;Stmt)</code> function.</p>
<p>The reason I recommend against implementing <code>SourceOrderVisitor</code> is because both the <code>Checker</code> and Red Knot's semantic index builder visit the tree in semantic and not source ordering. Using the <code>SourceOrderVisitor</code> trait here would give the wrong impression that the visiting happens in source order instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/settings/types.rs</code>:68 on 2025-02-11 21:40</div>
            <div class="timeline-body"><p>Oh no, more <code>PythonVersion</code> types :( I'm somewhat inclined to move red knot's <code>PythonVersion</code> to <code>ruff_db</code> and reuse that instead (Ruff already depends on the <code>ruff_db</code> crate so adding that dependency won't hurt.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-11 21:43</div>
            <div class="timeline-body"><p>I haven't done an in depth review (as this is also a draft PR) but I left a few comments that hopefully help clarify things.</p>
<p>Is the idea to emit version specific syntax errors (not semantic syntax errors) as part of the <code>SyntaxChecker</code> or do you still plan on emitting those as part of the parser?</p>
<p>I think we have to explore some alternative designs to decide on whether we want a rule code but it should definetely not block you from prototyping.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-02-11 22:20</div>
            <div class="timeline-body"><blockquote>
<p>I haven't done an in depth review (as this is also a draft PR) but I left a few comments that hopefully help clarify things.</p>
</blockquote>
<p>Thanks Micha! Our conversation earlier was very helpful, and I think these comments clear up some places where I was still confused.</p>
<blockquote>
<p>Is the idea to emit version specific syntax errors (not semantic syntax errors) as part of the <code>SyntaxChecker</code> or do you still plan on emitting those as part of the parser?</p>
</blockquote>
<p>In this draft, I tried emitting all of the errors, including version specific ones, in the <code>SyntaxChecker</code>, but I think your suggestion of keeping those in the parser still makes sense. Was your idea to keep the version-specific errors in the parser and use this <code>enter_stmt</code> approach just for the semantic errors?</p>
<p>Detecting <code>LateFutureImport</code> felt a bit easier here than in the parser version, so I can see a place for both. On the other hand, I thought it might be nice to isolate all of these checks in the <code>SyntaxChecker</code> instead of mixing some into the parser, but some of the errors might only be detectable in the parser anyway.</p>
<blockquote>
<p>I think we have to explore some alternative designs to decide on whether we want a rule code but it should definetely not block you from prototyping.</p>
</blockquote>
<p>I partially updated the design doc with your rule code suggestions from earlier, but I still need to add a more concrete proposal to help with this discussion. I'll do that tonight or first thing in the morning.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2025-02-11 22:37</div>
            <div class="timeline-body"><p>Ahh okay, I knew something felt wrong about where I was putting this in red-knot. I will try moving it to the semantic index phase!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-02-11 22:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-02-11 22:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:96 on 2025-02-11 22:40</div>
            <div class="timeline-body"><p>That totally makes sense. I took the <code>SourceOrderVisitor</code> suggestion from the design doc too literally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-02-11 22:43</div>
            <div class="timeline-body"><p>I haven't handled all of the review comments yet, but I rebased to get the new <code>Diagnostic</code> changes and hopefully fix the CI failures. I'm hoping this will be faster on codspeed than the other two prototypes too, or at least faster than the first one for sure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-02-11 22:51</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 08:14</div>
            <div class="timeline-body"><blockquote>
<p>In this draft, I tried emitting all of the errors, including version specific ones, in the SyntaxChecker, but I think your suggestion of keeping those in the parser still makes sense. Was your idea to keep the version-specific errors in the parser and use this enter_stmt approach just for the semantic errors?</p>
</blockquote>
<p>Exactly. My motivation for this is that:</p>
<ul>
<li>The parser already emits syntax errors today. So it feels seems like a good fit to emit the version specific syntax (not compile) errors in the parser too.</li>
<li>Our parser is used by other projects and I think it would be useful for them too if they can enforce a specific python version during parser without having to depend on the syntax-checker crate (which we'll likely remove if we unify Ruff/Red Knot)</li>
<li>I would love if the formatter tests could assert that there are no syntax errors in the source and formatted file. Doing so is much easier if this is a capability of the formatter than compared to calling into some visitor.</li>
<li>I'm sort of okay with not documenting version specific syntax errors. I do think we may want to have some documentation for compile errors, at least long term.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-12 11:59</div>
            <div class="timeline-body"><blockquote>
<p>I'm sort of okay with not documenting version specific syntax errors. I do think we may want to have some documentation for compile errors, at least long term.</p>
</blockquote>
<p>For most of these, I think we could get away without documentation. There's not that much to say about the <code>match</code> statement not being valid before Python 3.10, for example.</p>
<p>For some of them, though, I think docs would be really useful for our users. For example, the <a href="https://peps.python.org/pep-0614/">syntax differences between Python 3.8 and 3.9 due to PEP 614</a> are pretty subtle. And the details on when exactly you're able to parenthesize context managers in <code>with</code> statements on Python 3.8 are also pretty complicated -- I can never remember what they are!</p>
<p>This is invalid syntax on Python 3.8:</p>
<pre><code class="language-py">with (
    foo() as x,
    bar() as y,
):
    pass
</code></pre>
<p>But these are all valid syntax:</p>
<pre><code class="language-pycon">Python 3.8.18 (default, Feb 15 2024, 19:36:58) 
[Clang 15.0.0 (clang-1500.1.0.2.5)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; with (x, y) as foo:
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with (x,
...     y) as foo:
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with (x,
... y):
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with (
...     x,
... ):
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with (
...     x,
...     y
... ) as foo:
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with x, (
...     y
... ): pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with x as foo, (
... y
... ) as bar:
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'x' is not defined
&gt;&gt;&gt; with x() as foo, (
...     y()
... ) as bar:
...     pass
... 
Traceback (most recent call last):
  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;
NameError: name 'x' is not defined
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 12:11</div>
            <div class="timeline-body"><blockquote>
<p>For some of them, though, I think docs would be really useful for our users. For example, the <a href="https://peps.python.org/pep-0614/">syntax differences between Python 3.8 and 3.9 due to PEP 614</a> are pretty subtle. And the details on when exactly you're able to parenthesize context managers in with statements on Python 3.8 are also pretty complicated -- I can never remember what they are!</p>
</blockquote>
<p>That's fair. But how is it different from any other syntax error. E.g what if you get a comprehension wrong?</p>
<p>Either way. Having them in the parser doesn't mean that we can never have unique error codes. Red Knot would allow for it. It might just not be possible today and I think that's fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-12 12:19</div>
            <div class="timeline-body"><blockquote>
<p>That's fair. But how is it different from any other syntax error.</p>
</blockquote>
<p>Well, as we discussed earlier, we also probably want version-dependent syntax errors to be suppressible. If an error is suppressible and has documentation, it ends up looking <em>very much</em> like a lint rule, no? ;)</p>
<p>And that's not to say that I want them detected using the same infrastructure as a lint rule. I think you're right that it'll be more performant to detect them in the parser where possible, and I think you make a great point when you say that it would be great for the formatter tests to be able to assert that they don't introduce any new version-dependent syntax errors. But I think we should be <em>aware</em> that these in quite a few ways are going to end up looking a lot more like our existing linter rules than our existing syntax rules.</p>
<blockquote>
<p>E.g what if you get a comprehension wrong?</p>
</blockquote>
<p>Sure, it might be nice to have better docs for our existing syntax errors too ;-) but I do think it's especially confusing and subtle for users if whether or not they get a syntax error depends on the target Python version we've inferred for their project. And documenting clearly which Python version the new syntax was added in could really help users.</p>
<blockquote>
<p>Either way. Having them in the parser doesn't mean that we can never have unique error codes. Red Knot would allow for it. It might just not be possible today and I think that's fine.</p>
</blockquote>
<p>I don't have a strong opinion on whether we should detect these errors in the parser or elsewhere. But if we are going to detect them in the parser, I do think we should have a <em>plan</em> for how we'll provide docs for these errors. It doesn't have to be part of the initial PR adding these syntax diagnostics, but it <em>is</em> important to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 12:31</div>
            <div class="timeline-body"><blockquote>
<p>Well, as we discussed earlier, we also probably want version-dependent syntax errors to be suppressible. If an error is suppressible and has documentation, it ends up looking very much like a lint rule, no? ;)</p>
</blockquote>
<p>I don't think this is something we have an agreement on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-12 12:33</div>
            <div class="timeline-body"><blockquote>
<p>I don't think this is something we have an agreement on.</p>
</blockquote>
<p>Oh, sorry about that. I think I misunderstood our earlier conversation on Monday in that case -- that's on me :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Syntax errors prototype v3" to "[syntax-errors] Start detecting compile-time syntax errors" by @ntBre on 2025-03-17 19:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:29 on 2025-03-19 17:40</div>
            <div class="timeline-body"><p>I think these all need better names. I called many of the variable names below <code>semantic_syntax_error(s)</code>. What do you think about <code>SemanticSyntaxChecker</code>, <code>SemanticSyntaxError</code>, and <code>SemanticSyntaxErrorKind</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-19 17:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-19 17:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:20 on 2025-03-19 17:57</div>
            <div class="timeline-body"><p>This is not really used currently, but some of the errors in #11934 are both version-related and raised at compile time, so I expect to use it eventually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-19 18:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:194 on 2025-03-19 18:00</div>
            <div class="timeline-body"><p><code>rebound_variable</code> could also be a <code>Vec&lt;TextRange&gt;</code> and we could avoid returning here, if we want to look for additional violations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-03-19 18:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @ntBre on 2025-03-19 18:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-20 03:32</div>
            <div class="timeline-body"><p>I did notice one slightly surprising thing when testing the server integration. Because the greeter is tied to the AST visitor, if you have no AST-based rules enabled (e.g. <code>select = []</code>, which I had in my test config for some reason), you won't get any of these errors either.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-03-20 07:34</div>
            <div class="timeline-body"><blockquote>
<p>I did notice one slightly surprising thing when testing the server integration. Because the greeter is tied to the AST visitor, if you have no AST-based rules enabled (e.g. <code>select = []</code>, which I had in my test config for some reason), you won't get any of these errors either.</p>
</blockquote>
<p>We have to remove this check</p>
<p>https://github.com/astral-sh/ruff/blob/37fbe58b13b905bfafac326a74c922f72f3b54a1/crates/ruff_linter/src/linter.rs#L139-L142</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">core</span> added by @MichaReiser on 2025-03-20 07:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>Cargo.toml</code>:33 on 2025-03-20 07:35</div>
            <div class="timeline-body"><p>Maybe:</p>
<pre><code class="language-suggestion">ruff_python_syntax_errors = { path = &quot;crates/ruff_python_semantic_errors&quot; }
</code></pre>
<p>To clarify that it doesn't implement other syntax errors? We could also use <code>semantic_syntax_errors</code> but it feels very long.</p>
<p>Another alternative is to implement the checks inside the parser crate. Or does the crate have dependencies that would prevent us from doing that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/tests/lint.rs</code>:5496 on 2025-03-20 07:36</div>
            <div class="timeline-body"><p>Let's add a test verifying that the semantic syntax errors are reported even if a user disabled all ast rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/checkers/ast/analyze/statement.rs</code>:856 on 2025-03-20 07:37</div>
            <div class="timeline-body"><p>Can you tell me more about this change? Did you remove the rule because it is now covered by the new semantic syntax checks? If so, that would be a breaking change and would have to be gated behind preview mode.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:29 on 2025-03-20 07:38</div>
            <div class="timeline-body"><p>I like the suggested names. It aligns with what we use in the parser</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:525 on 2025-03-20 07:40</div>
            <div class="timeline-body"><p>Nit: I would rename the methods to <code>visit_stmt</code> because the <code>enter_</code> suggests that there's an <code>exit_</code> pendant for every enter method. Unless you plan on adding <code>exit_*</code> methods to the visitor.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:2772 on 2025-03-20 07:43</div>
            <div class="timeline-body"><p>Would you mind double-checking if/how Ruff sorts diagnostics? Does it sort diagnosics by file and their source location or only file? It's important that we sort by both, or late future import errors will now always appear last, even if their source location is earlier in a file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/linter.rs</code>:340 on 2025-03-20 07:45</div>
            <div class="timeline-body"><p>Let's move this check into <code>Checker</code> so that we avoid collecting the semantic syntax errors if the preview mode is off (Ideally, we'd skip the entire <code>SemanticSyntaxVisitor</code> but I think that would make the code unnecessarily awkward. Although it might be worth it if you're concerned about panics (it then gives users a way to opt out of the new semantic syntax visitor by disabling preview).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:21 on 2025-03-20 07:49</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    python_version: PythonVersion,
</code></pre>
<p><code>target_version</code> is the &quot;legacy&quot; ruff term.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 07:53</div>
            <div class="timeline-body"><p>It's unfortunate that it requires us to re-implement the <code>seen_docstring_boundary</code>.</p>
<p>It makes me wonder if we should pass a <code>context</code> variable to each <code>visit</code> method that allows to pass some state to the visitor.</p>
<p>For example:</p>
<pre><code class="language-rust">fn visit_stmt(&amp;mut self, contex: &amp;SemanticSyntaxContext) {...}

#[derive(Debug)]
struct SemanticSyntaxContext {
	seen_docstring_boundary: bool
}
</code></pre>
<p>Or we can add a <code>set_seen_docstring_boundary</code> method to the <code>SyntaxChecker</code> and require the <code>Checker</code> to call it when appropriate (this seems a bit more error-prone to me).</p>
<p>Another alternative is to make <code>Context</code> a trait with:</p>
<pre><code class="language-rust">trait SemanticSyntaxContext {
	fn python_version(&amp;self) -&gt; PythonVersion;

	fn seen_docstring_boundary(&amp;self) -&gt; bool;

	fn push_semantic_error(&amp;mut self, error ...);
}
</code></pre>
<p>Where <code>Checker would implement </code>SemanticSyntaxContext<code>. The </code>SyntaxChecker can either be generic over <code>SemanticSyntaxContext</code> (results in a lot of monomorphization but that should be fine because we only use it once in each top-level project) or use `&amp;mut dyn SemanticSyntaxContext)</p>
<p>I think I like the context most because it allows the <code>Checker</code> to push the syntax errors directly into the correct diagnostic vec.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:167 on 2025-03-20 07:59</div>
            <div class="timeline-body"><p>Always collecting the names here seems unfortunate because most generators never contain an <code>ExprNamed</code>. I would store the generators on the <code>ReboundComprehensionVisitor</code> and use an <code>Option&lt;FxHashSet&lt;&amp;'a Name&gt;&gt;</code> to lazily collect the target names (or a <code>OnceCell</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:194 on 2025-03-20 08:00</div>
            <div class="timeline-body"><p>I think it would be great to report all violations because it's annoying if you fix one violation only for the next to appear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:259 on 2025-03-20 08:02</div>
            <div class="timeline-body"><p>Moving the checker into the parser crate would have the added benefit that you could reuse its diagnostic rendering infrastructure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 08:03</div>
            <div class="timeline-body"><p>This looks good. I mainly have a few minor comments besides:</p>
<ul>
<li>I'd be open to move the checker into <code>ruff_python_parser</code>. Unless you forsee that the checks need to depend on additional crates</li>
<li>I'm a bit worried about having to reimplement state that's currently tracked on <code>Checker</code> (e.g. seen_docstring). That's why I'm leaning towards introducing a <code>SemanticSyntaxContext</code> trait that <code>Checker</code> implements and allows providing &quot;external&quot; state to the checker. See inline comment</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-20 11:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:194 on 2025-03-20 11:14</div>
            <div class="timeline-body"><p>+1, this is one of the main benefit of having an error resilient parser so that we can report all of the syntax errors compared to before where we would only report the first syntax error. We should continue doing that and not regress in that area if possible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-03-20 11:21</div>
            <div class="timeline-body"><p>Feel free to request my review if it's needed otherwise I agree with all of Micha's review comments.</p>
<p>I'd suggest doing some testing in an editor context considering the <code>ruff.configuration</code> and <code>ruff.showSyntaxErrors</code> setting.</p>
<p>One thing that I'm reminded of is to check if <code>--statistics</code> includes the count of these new syntax errors or not. I think it should, we might want to update the CLI test case for <code>--statistics</code> to include these new errors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-20 11:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 11:24</div>
            <div class="timeline-body"><p>I'm not exactly sure which context are you referring to by &quot;I like the context most&quot; but my preference would be to have a context struct that's owned by the <code>Checker</code> which is then passed to the <code>SyntaxChecker</code>'s <code>visit_stmt</code> and <code>visit_expr</code> methods aka your first suggestion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-20 11:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/checkers/ast/analyze/statement.rs</code>:856 on 2025-03-20 11:27</div>
            <div class="timeline-body"><p>I believe the idea is:</p>
<ul>
<li>Move the detection logic to the new crate so that red-knot can detect it using the same backend logic, which will also want to detect this syntax error</li>
<li>But from Ruff's side, make sure that this syntax error continues to be <em>reported</em> using a linter diagnostic and with the same error code that it has always had. This ensures backwards compatibility for Ruff users while also ensuring that we do not duplicate code between the two tools or risking inconsistent behaviour between the two tools.</li>
</ul>
<p>You can see that for Ruff, the diagnostic is still only reported if the lint rule is actually enabled. That logic has just been moved to line 2761 in <code>crates/ruff_linter/src/checkers/ast/mod.rs</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 11:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 11:46</div>
            <div class="timeline-body"><p>Good point. The context trait but I'm also fine with the context struct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 12:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/checkers/ast/analyze/statement.rs</code>:856 on 2025-03-20 12:45</div>
            <div class="timeline-body"><p>Yes, Alex is right. This does not remove the rule and shouldn't change any user-facing behavior (I'll double check the sorting behavior you mentioned elsewhere), it just implements it with the new checker. The main motivation for this change was just to show that it's straightforward to emit these new errors as either true <code>Diagnostic</code>s or as <code>Message</code>s. That way we can migrate existing ruff rules that fit into this category if/when we want.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 12:57</div>
            <div class="timeline-body"><p>The trait sounds a bit more natural to me because the <code>Checker</code> already has this state in its <code>SemanticModel</code>, so I think we'd have to repack it into a context struct for use by the <code>SyntaxChecker</code>.  Pushing the semantic errors directly is another nice benefit of the trait.</p>
<p>I'll play with these today and see how they feel.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 12:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 13:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:167 on 2025-03-20 13:40</div>
            <div class="timeline-body"><p>That's a good point. Is it even worth caching them like that, or should we just do a linear search each time? I think <code>generators</code> is likely to be small and most of them won't contain an <code>ExprNamed</code> anyway, like you said. That's the approach I've taken for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 14:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:2772 on 2025-03-20 14:03</div>
            <div class="timeline-body"><p>Empirically, I tested on this snippet:</p>
<pre><code class="language-python">import late_future_import  # F401

from __future__ import annotations  # F404

another_violation = unbound  # F821
</code></pre>
<p>and the diagnostics come out in the correct order (F401, F404, F821), so it looks like we sort by file and location, but I will look for where in the code we actually perform the sort too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 14:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:2772 on 2025-03-20 14:13</div>
            <div class="timeline-body"><p>It looks like they do get <a href="https://github.com/astral-sh/ruff/blob/main/crates/ruff/src/commands/check.rs#L171">sorted</a> in the <code>check</code> command and rely on this <code>Ord</code> impl, which will first sort by file and then by the start of the message range.
https://github.com/astral-sh/ruff/blob/cdafd8e32b1c4d76d61d6d6578a8a7fa5a63dab2/crates/ruff_linter/src/message/mod.rs#L251-L255</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 15:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:167 on 2025-03-20 15:08</div>
            <div class="timeline-body"><p>Either way seems fine to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 15:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/checkers/ast/mod.rs</code>:2772 on 2025-03-20 15:09</div>
            <div class="timeline-body"><p>Thanks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 15:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 15:54</div>
            <div class="timeline-body"><p>One downside of the trait approach is that I couldn't borrow the <code>Checker</code> mutably and immutably at the same time:</p>
<pre><code class="language-rust">    fn visit_stmt(&amp;mut self, stmt: &amp;'a Stmt) {
        self.syntax_checker.visit_stmt(stmt, self);
             ^^^^^^^^^^^^^^                  ^^^^
             mutable borrow                  immutable
        ...
    }
</code></pre>
<p>so I added some <code>RefCell</code>s in the <code>SemanticSyntaxChecker</code> to make them both immutable. This also means that it's not easy to have a <code>SemanticSyntaxContext::push_semantic_error</code> method; it would require another <code>RefCell</code> back on the implementer.</p>
<p>I still think it's okay, or maybe I'm missing something that would make it nicer too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 15:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 15:58</div>
            <div class="timeline-body"><p>Ugh, that's annoying but makes sense. Yeah, you would have to <code>std::mem::take</code> <code>syntax_checker</code> before calling <code>visit_stmt</code>.</p>
<p>Or we use the context struct, where you can copy over the relevant state.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 16:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/linter.rs</code>:340 on 2025-03-20 16:04</div>
            <div class="timeline-body"><p>Ah I see what you mean about it being awkward. I thought I could just do something like</p>
<pre><code class="language-rust">if self.settings.preview.is_enabled() {
    self.syntax_checker.visit_stmt(stmt);
}
</code></pre>
<p>But this loses F404 detection when preview is disabled. For now I moved this into <code>check_ast</code> to avoid pushing onto the <code>semantic_syntax_errors</code> <code>Vec</code> when preview is disabled.</p>
<p>I don't think there's any panic-prone code in here, but I'll look back over it with that in mind. If we keep the context trait, the <code>RefCell</code> stuff is the most panicky, I think, but the encapsulated usage here should be about as safe as it gets.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 16:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-20 16:18</div>
            <div class="timeline-body"><p>I guess I'm slightly averse to the struct because I think we'd have to construct one on each call? I'm picturing</p>
<pre><code class="language-rust">    fn visit_stmt(&amp;mut self, stmt: &amp;'a Stmt) {
        self.syntax_checker.visit_stmt(
            stmt,
            Context {
                python_version: self.target_version,
                seen_docstring_boundary: self.semantic.seen_docstring_boundary(),
            },
        );
        ....
    }
</code></pre>
<p>It's pretty minor either way for so few fields, but I'm not sure how big it will get over time. It would definitely require fewer lines of code changed in the current version, though.</p>
<p><code>Checker</code> could also hold onto a <code>Context</code> of course, but then we have to keep it up to date when the underlying state changes, or move the underlying state to the <code>Context</code>, I guess.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 16:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>Cargo.toml</code>:33 on 2025-03-20 16:32</div>
            <div class="timeline-body"><p>Moving it to the parser makes a lot of sense to me. I moved it to a public <code>ruff_python_parser::semantic_errors</code> module. Another possible location would be a private submodule of the <code>error</code> module (<code>ruff_python_parser::error::semantic_errors</code> or maybe just <code>semantic</code> at the end?) and then we could re-export the new related types like we do for <code>ParseError</code> and <code>UnsupportedSyntaxError</code>. Maybe <code>UnsupportedSyntaxError</code> should have had its own <code>error</code> submodule too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-20 16:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:259 on 2025-03-20 16:56</div>
            <div class="timeline-body"><p>Ooh that would be much nicer than the current snapshots. It looks like the rendering code is in the integration tests. Could I extend the inline tests to pick up the new module? I was definitely missing them after the unsupported syntax errors.</p>
<p>https://github.com/astral-sh/ruff/blob/c1971fdde24b37e64baa70386d933715aeec13c6/crates/ruff_python_parser/tests/generate_inline_tests.rs#L24-L26</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:259 on 2025-03-20 17:45</div>
            <div class="timeline-body"><p>Extending them might be fine. An alternative is to write some standalone tests and add them to the <code>valid</code> / <code>invalid</code> directories (but you would have to extend the testing to also run semantic checks)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 17:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 17:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>Cargo.toml</code>:33 on 2025-03-20 17:47</div>
            <div class="timeline-body"><p>I'm fine with any of it but I myself would go with <code>semantic_errors</code> because it's short and simple.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-20 22:14</div>
            <div class="timeline-body"><p>Thanks @dhruvmanila! I did test <code>ruff.showSyntaxErrors</code> initially, but I have now also tried <code>ruff.configuration</code>. It properly seems to override the local <code>ruff.toml</code> and setting <code>&quot;preview&quot;: false</code> there disables the new errors.</p>
<p>I also added a test for <code>--statistics</code>, which seems to be working properly for all of the syntax error kinds.</p>
<p>Otherwise, I think I've handled the other comments too. Thank you and @MichaReiser  for the reviews! This push should get the updated ecosystem check as well, just in case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-21 04:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-21 04:41</div>
            <div class="timeline-body"><blockquote>
<p><code>Checker</code> could also hold onto a <code>Context</code> of course, but then we have to keep it up to date when the underlying state changes, or move the underlying state to the <code>Context</code>, I guess.</p>
</blockquote>
<p>This is what I actually envisioned with my comment. The context would all be grouped under a single struct which the <code>Checker</code> owns and that context itself would be passed to the <code>SyntaxChecker</code> whenever required. So, it would be the <code>Checker</code>'s responsibility to keep the context up to date while the <code>SyntaxError</code> should only have a read-only copy / reference to the context.</p>
<p>This does has the disadvantage that the diff of this PR might get large because it'll require updating multiple fields so I'd be fine moving with your approach of using either trait or creating a context specific to <code>SyntaxChecker</code>.</p>
<blockquote>
<p>I guess I'm slightly averse to the struct because I think we'd have to construct one on each call? I'm picturing</p>
</blockquote>
<p>We could have a method on the <code>Checker</code> to create the context relevant to the <code>SyntaxChecker</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-21 04:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:259 on 2025-03-21 04:43</div>
            <div class="timeline-body"><p>Yeah, extending the path to pickup comments from non-parser crates should be fine</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/tests/generate_inline_tests.rs</code>:42 on 2025-03-21 04:57</div>
            <div class="timeline-body"><p>Is there a specific reason that semantic errors are separate from other parser tests?</p>
<p>I think I'd prefer to expand the current test infrastructure to include them but I might be missing something that's obvious to you. What I'd do is:</p>
<ul>
<li>Include the <code>semantic_error</code> crate in <code>generate_inline_tests</code>. This will also remove the need of <code>resources/inline/semantic</code> directory as I think the generated test files are just an abstraction so it doesn't matter where those files are located as long as the test picks them up</li>
<li>Expand <code>test_valid_syntax</code> and <code>test_invalid_syntax</code> to check the semantic errors using the <code>TestVisitor</code></li>
</ul>
<p>Curious to hear your thoughts on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/semantic_errors/mod.rs</code>:195 on 2025-03-21 04:59</div>
            <div class="timeline-body"><p>nit: can we move the test closer to where it's being added? So, above the <code>add_error</code> call below on line 220</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-21 05:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/semantic_errors/mod.rs</code>:1 on 2025-03-21 07:56</div>
            <div class="timeline-body"><p>I don't think this module has to have its own directory. Its only a single file. I'd move it to <code>src/semantic_errors.rs</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/semantic_errors/mod.rs</code>:128 on 2025-03-21 07:57</div>
            <div class="timeline-body"><p>Nit: The fact that all this code is between <code>SemanticSyntaxChecker</code> blocks makes the file a bit harder to navigate (I had to jump up and down to make changes)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/linter.rs</code>:48 on 2025-03-21 08:27</div>
            <div class="timeline-body"><p>Should this be <code>SemanticSyntaxError</code> instead of <code>SyntaxError</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/semantic_errors/mod.rs</code>:25 on 2025-03-21 08:32</div>
            <div class="timeline-body"><p>I'd prefer not to use a <code>RefCell</code> here because they are only needed because of how <code>Checker</code> is organized. I quickly looked at Red Knot and I don't think ref cells will be necessary in Red Knot because it also has a <code>context</code> type that is independent. That's why I think the mutability should be worked around in <code>Checker</code> and not here.</p>
<p>I had to play with the code to come up with a recommendation. That's why I'll share a patch here.</p>
<pre><code class="language-patch">Subject: [PATCH] Align server indexing with CLI behavior
---
Index: crates/ruff_python_parser/tests/fixtures.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_parser/tests/fixtures.rs b/crates/ruff_python_parser/tests/fixtures.rs
--- a/crates/ruff_python_parser/tests/fixtures.rs	(revision 88cbb9ba403d904f7e66025e9625adf076b79869)
+++ b/crates/ruff_python_parser/tests/fixtures.rs	(date 1742545597020)
@@ -1,3 +1,4 @@
+use std::cell::RefCell;
 use std::cmp::Ordering;
 use std::fmt::{Formatter, Write};
 use std::fs;
@@ -7,7 +8,9 @@
 use ruff_python_ast::visitor::source_order::{walk_module, SourceOrderVisitor, TraversalSignal};
 use ruff_python_ast::visitor::Visitor;
 use ruff_python_ast::{AnyNodeRef, Mod, PythonVersion};
-use ruff_python_parser::semantic_errors::{SemanticSyntaxChecker, SemanticSyntaxContext};
+use ruff_python_parser::semantic_errors::{
+    SemanticSyntaxCheckerVisitor, SemanticSyntaxContext, SemanticSyntaxError,
+};
 use ruff_python_parser::{parse_unchecked, Mode, ParseErrorType, ParseOptions, Token};
 use ruff_source_file::{LineIndex, OneIndexed, SourceCode};
 use ruff_text_size::{Ranged, TextLen, TextRange, TextSize};
@@ -194,15 +197,13 @@
 
     let parsed = parsed.try_into_module().expect(&quot;Parsed with Mode::Module&quot;);
 
-    let mut visitor = TestVisitor {
-        checker: SemanticSyntaxChecker::new(),
-    };
+    let mut visitor = SemanticSyntaxCheckerVisitor::new(TestContext::default());
 
     for stmt in parsed.suite() {
         visitor.visit_stmt(stmt);
     }
 
-    let semantic_syntax_errors = visitor.checker.finish();
+    let semantic_syntax_errors = visitor.into_context().diagnostics.into_inner();
 
     if !semantic_syntax_errors.is_empty() {
         let mut message = &quot;Expected no semantic syntax errors for a valid program:\n&quot;.to_string();
@@ -252,15 +253,13 @@
 
     let parsed = parsed.try_into_module().expect(&quot;Parsed with Mode::Module&quot;);
 
-    let mut visitor = TestVisitor {
-        checker: SemanticSyntaxChecker::new(),
-    };
+    let mut visitor = SemanticSyntaxCheckerVisitor::new(TestContext::default());
 
     for stmt in parsed.suite() {
         visitor.visit_stmt(stmt);
     }
 
-    let semantic_syntax_errors = visitor.checker.finish();
+    let semantic_syntax_errors = visitor.into_context().diagnostics.into_inner();
 
     assert!(
         !semantic_syntax_errors.is_empty(),
@@ -531,11 +530,12 @@
     }
 }
 
-struct TestVisitor {
-    checker: SemanticSyntaxChecker,
+#[derive(Debug, Default)]
+struct TestContext {
+    diagnostics: RefCell&lt;Vec&lt;SemanticSyntaxError&gt;&gt;,
 }
 
-impl SemanticSyntaxContext for TestVisitor {
+impl SemanticSyntaxContext for TestContext {
     fn seen_docstring_boundary(&amp;self) -&gt; bool {
         false
     }
@@ -543,16 +543,8 @@
     fn python_version(&amp;self) -&gt; PythonVersion {
         PythonVersion::default()
     }
-}
 
-impl Visitor&lt;'_&gt; for TestVisitor {
-    fn visit_stmt(&amp;mut self, stmt: &amp;ruff_python_ast::Stmt) {
-        self.checker.visit_stmt(stmt, self);
-        ruff_python_ast::visitor::walk_stmt(self, stmt);
-    }
-
-    fn visit_expr(&amp;mut self, expr: &amp;ruff_python_ast::Expr) {
-        self.checker.visit_expr(expr, self);
-        ruff_python_ast::visitor::walk_expr(self, expr);
+    fn report_semantic_error(&amp;self, error: SemanticSyntaxError) {
+        self.diagnostics.borrow_mut().push(error);
     }
 }
Index: crates/ruff_python_parser/src/semantic_errors/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_parser/src/semantic_errors/mod.rs b/crates/ruff_python_parser/src/semantic_errors/mod.rs
--- a/crates/ruff_python_parser/src/semantic_errors/mod.rs	(revision 88cbb9ba403d904f7e66025e9625adf076b79869)
+++ b/crates/ruff_python_parser/src/semantic_errors/mod.rs	(date 1742545597028)
@@ -4,7 +4,7 @@
 //! [`SemanticSyntaxChecker::visit_stmt`] and [`SemanticSyntaxChecker::visit_expr`] methods should
 //! be called in a parent `Visitor`'s `visit_stmt` and `visit_expr` methods, respectively.
 
-use std::{cell::RefCell, fmt::Display};
+use std::fmt::Display;
 
 use ruff_python_ast::{
     self as ast,
@@ -13,51 +13,25 @@
 };
 use ruff_text_size::TextRange;
 
-struct CheckerState {
+#[derive(Debug)]
+pub struct SemanticSyntaxChecker {
     /// these could be grouped into a bitflags struct like `SemanticModel`
     seen_futures_boundary: bool,
 }
 
-pub struct SemanticSyntaxChecker {
-    /// The cumulative set of syntax errors found when visiting the source AST.
-    errors: RefCell&lt;Vec&lt;SemanticSyntaxError&gt;&gt;,
-
-    state: RefCell&lt;CheckerState&gt;,
-}
-
 impl SemanticSyntaxChecker {
     pub fn new() -&gt; Self {
         Self {
-            errors: RefCell::new(Vec::new()),
-            state: RefCell::new(CheckerState {
-                seen_futures_boundary: false,
-            }),
+            seen_futures_boundary: false,
         }
     }
-
-    pub fn finish(self) -&gt; Vec&lt;SemanticSyntaxError&gt; {
-        self.errors.into_inner()
-    }
 
     fn seen_futures_boundary(&amp;self) -&gt; bool {
-        self.state.borrow().seen_futures_boundary
-    }
-
-    fn set_seen_futures_boundary(&amp;self, seen_futures_boundary: bool) {
-        self.state.borrow_mut().seen_futures_boundary = seen_futures_boundary;
+        self.seen_futures_boundary
     }
 
-    fn add_error(
-        &amp;self,
-        kind: SemanticSyntaxErrorKind,
-        range: TextRange,
-        python_version: PythonVersion,
-    ) {
-        self.errors.borrow_mut().push(SemanticSyntaxError {
-            kind,
-            range,
-            python_version,
-        });
+    fn set_seen_futures_boundary(&amp;mut self, seen_futures_boundary: bool) {
+        self.seen_futures_boundary = seen_futures_boundary;
     }
 }
 
@@ -125,22 +99,32 @@
 
     /// The target Python version for detecting backwards-incompatible syntax changes.
     fn python_version(&amp;self) -&gt; PythonVersion;
+
+    fn report_semantic_error(&amp;self, error: SemanticSyntaxError);
 }
 
 impl SemanticSyntaxChecker {
+    fn add_error&lt;Ctx: SemanticSyntaxContext&gt;(
+        context: &amp;Ctx,
+        kind: SemanticSyntaxErrorKind,
+        range: TextRange,
+    ) {
+        context.report_semantic_error(SemanticSyntaxError {
+            kind,
+            range,
+            python_version: context.python_version(),
+        });
+    }
+
     fn check_stmt&lt;Ctx: SemanticSyntaxContext&gt;(&amp;self, stmt: &amp;ast::Stmt, ctx: &amp;Ctx) {
         if let Stmt::ImportFrom(StmtImportFrom { range, module, .. }) = stmt {
             if self.seen_futures_boundary() &amp;&amp; matches!(module.as_deref(), Some(&quot;__future__&quot;)) {
-                self.add_error(
-                    SemanticSyntaxErrorKind::LateFutureImport,
-                    *range,
-                    ctx.python_version(),
-                );
+                Self::add_error(ctx, SemanticSyntaxErrorKind::LateFutureImport, *range);
             }
         }
     }
 
-    pub fn visit_stmt&lt;Ctx: SemanticSyntaxContext&gt;(&amp;self, stmt: &amp;ast::Stmt, ctx: &amp;Ctx) {
+    pub fn visit_stmt&lt;Ctx: SemanticSyntaxContext&gt;(&amp;mut self, stmt: &amp;ast::Stmt, ctx: &amp;Ctx) {
         // update internal state
         match stmt {
             Stmt::Expr(StmtExpr { value, .. })
@@ -160,7 +144,7 @@
         self.check_stmt(stmt, ctx);
     }
 
-    pub fn visit_expr&lt;Ctx: SemanticSyntaxContext&gt;(&amp;self, expr: &amp;Expr, ctx: &amp;Ctx) {
+    pub fn visit_expr&lt;Ctx: SemanticSyntaxContext&gt;(&amp;mut self, expr: &amp;Expr, ctx: &amp;Ctx) {
         match expr {
             Expr::ListComp(ast::ExprListComp {
                 elt, generators, ..
@@ -217,10 +201,10 @@
         // TODO(brent) with multiple diagnostic ranges, we could mark both the named expr (current)
         // and the name expr being rebound
         for range in rebound_variables {
-            self.add_error(
+            Self::add_error(
+                ctx,
                 SemanticSyntaxErrorKind::ReboundComprehensionVariable,
                 range,
-                ctx.python_version(),
             );
         }
     }
@@ -249,3 +233,37 @@
         walk_expr(self, expr);
     }
 }
+
+#[derive(Default)]
+pub struct SemanticSyntaxCheckerVisitor&lt;Ctx&gt; {
+    checker: SemanticSyntaxChecker,
+    context: Ctx,
+}
+
+impl&lt;Ctx&gt; SemanticSyntaxCheckerVisitor&lt;Ctx&gt; {
+    pub fn new(context: Ctx) -&gt; Self {
+        Self {
+            checker: SemanticSyntaxChecker::new(),
+            context,
+        }
+    }
+
+    pub fn into_context(self) -&gt; Ctx {
+        self.context
+    }
+}
+
+impl&lt;Ctx&gt; Visitor&lt;'_&gt; for SemanticSyntaxCheckerVisitor&lt;Ctx&gt;
+where
+    Ctx: SemanticSyntaxContext,
+{
+    fn visit_stmt(&amp;mut self, stmt: &amp;'_ Stmt) {
+        self.checker.visit_stmt(stmt, &amp;self.context);
+        ruff_python_ast::visitor::walk_stmt(self, stmt);
+    }
+
+    fn visit_expr(&amp;mut self, expr: &amp;'_ Expr) {
+        self.checker.visit_expr(expr, &amp;self.context);
+        ruff_python_ast::visitor::walk_expr(self, expr);
+    }
+}
Index: crates/ruff_linter/src/checkers/ast/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_linter/src/checkers/ast/mod.rs b/crates/ruff_linter/src/checkers/ast/mod.rs
--- a/crates/ruff_linter/src/checkers/ast/mod.rs	(revision 88cbb9ba403d904f7e66025e9625adf076b79869)
+++ b/crates/ruff_linter/src/checkers/ast/mod.rs	(date 1742545597025)
@@ -232,6 +232,7 @@
 
     #[allow(clippy::struct_field_names)]
     syntax_checker: SemanticSyntaxChecker,
+    semantic_errors: RefCell&lt;Vec&lt;SemanticSyntaxError&gt;&gt;,
 }
 
 impl&lt;'a&gt; Checker&lt;'a&gt; {
@@ -280,6 +281,7 @@
             docstring_state: DocstringState::default(),
             target_version,
             syntax_checker: SemanticSyntaxChecker::new(),
+            semantic_errors: RefCell::default(),
         }
     }
 }
@@ -520,6 +522,12 @@
     pub(crate) const fn target_version(&amp;self) -&gt; PythonVersion {
         self.target_version
     }
+
+    fn with_semantic_checker(&amp;mut self, f: impl FnOnce(&amp;mut SemanticSyntaxChecker, &amp;Checker)) {
+        let mut checker = std::mem::take(&amp;mut self.syntax_checker);
+        f(&amp;mut checker, self);
+        self.syntax_checker = checker;
+    }
 }
 
 impl SemanticSyntaxContext for Checker&lt;'_&gt; {
@@ -530,11 +538,27 @@
     fn python_version(&amp;self) -&gt; PythonVersion {
         self.target_version
     }
+
+    fn report_semantic_error(&amp;self, error: SemanticSyntaxError) {
+        match error.kind {
+            SemanticSyntaxErrorKind::LateFutureImport =&gt; {
+                if self.settings.rules.enabled(Rule::LateFutureImport) {
+                    self.report_diagnostic(Diagnostic::new(LateFutureImport, error.range));
+                }
+            }
+            SemanticSyntaxErrorKind::ReboundComprehensionVariable
+                if self.settings.preview.is_enabled() =&gt;
+            {
+                self.semantic_errors.borrow_mut().push(error);
+            }
+            SemanticSyntaxErrorKind::ReboundComprehensionVariable =&gt; {}
+        }
+    }
 }
 
 impl&lt;'a&gt; Visitor&lt;'a&gt; for Checker&lt;'a&gt; {
     fn visit_stmt(&amp;mut self, stmt: &amp;'a Stmt) {
-        self.syntax_checker.visit_stmt(stmt, self);
+        self.with_semantic_checker(|semantic, context| semantic.visit_stmt(stmt, context));
 
         // Step 0: Pre-processing
         self.semantic.push_node(stmt);
@@ -1147,7 +1171,7 @@
     }
 
     fn visit_expr(&amp;mut self, expr: &amp;'a Expr) {
-        self.syntax_checker.visit_expr(expr, self);
+        self.with_semantic_checker(|semantic, context| semantic.visit_expr(expr, context));
 
         // Step 0: Pre-processing
         if self.source_type.is_stub()
@@ -2759,32 +2783,11 @@
 
     let Checker {
         diagnostics,
-        syntax_checker,
-        settings,
+        semantic_errors,
         ..
     } = checker;
 
     // partition the semantic syntax errors into Diagnostics and regular errors
-    let mut diagnostics = diagnostics.take();
-    let mut semantic_syntax_errors = Vec::new();
-    for semantic_syntax_error in syntax_checker.finish() {
-        match semantic_syntax_error.kind {
-            SemanticSyntaxErrorKind::LateFutureImport =&gt; {
-                if settings.rules.enabled(Rule::LateFutureImport) {
-                    diagnostics.push(Diagnostic::new(
-                        LateFutureImport,
-                        semantic_syntax_error.range,
-                    ));
-                }
-            }
-            SemanticSyntaxErrorKind::ReboundComprehensionVariable
-                if settings.preview.is_enabled() =&gt;
-            {
-                semantic_syntax_errors.push(semantic_syntax_error);
-            }
-            SemanticSyntaxErrorKind::ReboundComprehensionVariable =&gt; {}
-        }
-    }
 
-    (diagnostics, semantic_syntax_errors)
+    (diagnostics.into_inner(), semantic_errors.into_inner())
 }

</code></pre>
<p>The main changes are:</p>
<ul>
<li>Use <code>std::mem::take</code> in <code>Checker</code> to work around the mutability problem. But use a helper method to do this to avoid the situation where we forget to put it back.</li>
<li>Add a <code>report_semantic_error</code> method to context. This will work better with Red Knot's error reporting (where errors are immediately checked for suppressions)</li>
<li>Introduce a <code>SemanticSyntaxCheckerVisitor</code> that can be used in tests. It should reduce the risk that we forget to update tests when adding new <code>visit_</code> methods.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-03-21 08:33</div>
            <div class="timeline-body"><p>This looks good. A few nits around how to work around the context mutability problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-21 09:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_syntax_errors/src/lib.rs</code>:27 on 2025-03-21 09:21</div>
            <div class="timeline-body"><p>Separating <code>Checker</code> and its context information would be nice and could help with some future work too, but I think it's a little out of scope for this PR. I commented with a solution that should allow us to work-around the mutability problem locally in <code>Checker</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-21 11:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_parser/tests/generate_inline_tests.rs</code>:42 on 2025-03-21 11:09</div>
            <div class="timeline-body"><p>I thought we might want to avoid the AST visitor in the existing tests, but if it's okay to check that for all of them, I can definitely combine these!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-21 11:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_parser/src/semantic_errors/mod.rs</code>:1 on 2025-03-21 11:10</div>
            <div class="timeline-body"><p>That makes sense. I mentioned in the PR summary that I thought about splitting &quot;rules&quot; into their own modules, but one file makes sense with the current arrangement.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/linter.rs</code>:48 on 2025-03-21 11:12</div>
            <div class="timeline-body"><p>Yes, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-21 11:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-03-21 12:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_python_parser/src/semantic_errors/mod.rs</code>:25 on 2025-03-21 12:06</div>
            <div class="timeline-body"><p>Thanks for the patch, this looks much nicer. I fixed one clippy lint for an unused <code>self</code> variable in <code>check_generator_expr</code>, but otherwise I applied it verbatim.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @ntBre on 2025-03-21 18:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ntBre on 2025-03-21 18:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-21 18:45</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:09:58 UTC
    </footer>
</body>
</html>
