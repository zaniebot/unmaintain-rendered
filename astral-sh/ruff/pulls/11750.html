<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>red-knot: Higher level, location independent AST - astral-sh/ruff #11750</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>red-knot: Higher level, location independent AST</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/11750">#11750</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2024-06-05 11:42
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR is mainly to explore a location independent, higher level AST for red knot.</p>
<p>The motivation for a location independent higher level AST is to have sub-level invalidation granularity.
What I mean by that is that e.g. whitespace only changes should not invalidate any type inference results
but they do because the AST stores location informations that change when adding or removing characters from a document.</p>
<p>A higher level AST (HAST) also allow to avoid infering the types when making local changes in a function.</p>
<p>Let's say we have</p>
<pre><code class="language-python">def add(x, y):
	x + y

def multiply(x, y):
	x * y

</code></pre>
<p>It shouldn't be necessary to do type inference for <code>add</code> when making changes to <code>multiply</code> because <code>add</code>'s body doesn't change nor does it depend on <code>multiply</code> in anyway (it doesn't call the function).</p>
<p>An HAST enables function level garnulariy, but it doesn't come for free:</p>
<ul>
<li>It requires building an additional AST that is very familiar to the AST created by the parser with the exception that it doesn't include TextRange's and that we build it per &quot;function&quot; rather than building the entire AST for the entire module</li>
<li>It requires rebuilding a lot of the infrastructure like visitors</li>
<li>We end up with two AST representations and need a way to map between the representations</li>
<li>The HAST, at least what I built so far, is awkward to use</li>
<li>While the HAST optimizes the time it takes to reanalyze when making local changes, the cost for reanalyzing in the worst case remains unchanged (or is now higher because of the extra intermediate representations). For example, adding a new symbol to the module scope requires type-checking the entire file because each sub scope depends on the root scope.
That means, while the HIR helps to improve the average response time in the LSP, it doesn't help improving the time of all requests. This is not a reason why we should not do it. But maybe it's more beneficial to reduce the cost of running the entire analysis so that an HIR isn't needed.</li>
</ul>
<h2>Test Plan</h2>
<!-- How was it tested? -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-06-11 13:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-12 07:53</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:04:40 UTC
    </footer>
</body>
</html>
