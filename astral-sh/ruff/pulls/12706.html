<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] type narrowing - astral-sh/ruff #12706</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] type narrowing</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12706">#12706</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-08-06 04:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>Extend the <code>UseDefMap</code> to also track which constraints (provided by e.g. <code>if</code> tests) apply to each visible definition.</p>
<p>Uses a custom <code>BitSet</code> and <code>BitSetArray</code> to track which constraints apply to which definitions, while keeping data inline as much as possible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-08-06 04:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] [WIP] initial narrowing work" to "[red-knot] [WIP] type narrowing" by @carljm on 2024-08-08 02:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-08-08 02:48</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/cjm/narrow">CodSpeed Performance Report</a></h2>
<h3>Merging #12706 will <strong>degrade performances by 13.78%</strong></h3>
<p><sub>Comparing <code>cjm/narrow</code> (15885c6) with <code>main</code> (a9847af)</sub></p>
<h3>Summary</h3>
<p><code>‚ùå 2 (üëÅ 2)</code> regressions
<code>‚úÖ 30</code> untouched benchmarks</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>cjm/narrow</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| üëÅ | <code>red_knot_check_file[cold]</code> | 51 ms | 59.2 ms | -13.78% |
| üëÅ | <code>red_knot_check_file[incremental]</code> | 2.7 ms | 3 ms | -9.39% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] [WIP] type narrowing" to "[red-knot] type narrowing" by @carljm on 2024-08-15 01:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-08-15 01:59</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>‚úÖ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>‚úÖ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @carljm on 2024-08-15 03:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-08-15 03:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-08-15 03:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:383 on 2024-08-15 06:23</div>
            <div class="timeline-body"><p>Collecting here only to receive the only public definition seems a bit wasteful and is also kind of hard to read. I suggest to add a helper method to <code>use_def</code> that returns an <code>Option</code>:</p>
<pre><code class="language-rust">`use_def.single_public_definition(..) -&gt; Option&lt;T&gt;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:427 on 2024-08-15 06:24</div>
            <div class="timeline-body"><p>Using a helpr method also makes this more readable because you don't have to use destructuring</p>
<pre><code class="language-suggestion">        let definition = use_def
            .single_public_definition(
                global_table
                    .symbol_id_by_name(&quot;foo&quot;)
                    .expect(&quot;symbol to exist&quot;),
            )
            .expect(&quot;one definition)
            .definition;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:170 on 2024-08-15 06:26</div>
            <div class="timeline-body"><p>You can use the <code>smallvec</code> crate to get a stack allocated array up to N elements. You may still want to wrap it to get the specific API you want</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:13 on 2024-08-15 06:28</div>
            <div class="timeline-body"><p>Is the motivation for using a <code>Set</code> over a <code>Vec</code> because the bitset is likely to dense?</p>
<p>I wonder if it is worth the complexity. Using a <code>Vec&lt;u64&gt;</code> could remove a lot of branching in your code. You could even consider using the smallvec crate to get the inline vs heap allocated representation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:31 on 2024-08-15 06:33</div>
            <div class="timeline-body"><p>The assertion above should be an <code>assert</code> if we use it to <em>assert</em> the correctness of the program. It should also not cost that much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:32 on 2024-08-15 06:40</div>
            <div class="timeline-body"><p>Nit: I would rename this to <code>INLINE_CAPACITY</code> because the <code>HEAP</code> variant can have more than that number of bits. Or maybe <code>INLINE_MAX</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:27 on 2024-08-15 06:49</div>
            <div class="timeline-body"><p>One problem of this implementation is that it assumes that <code>usize</code> &gt;= <code>u32</code> which isn't given on all platforms. That means, some of those clippy warnings are indeed issues. I'm even surprised why clippy doesn't complain about casting <code>value</code> to an <code>usize</code> because that could also truncate.</p>
<p>It may be worth adding some <code>assert</code> to ensure we aren't truncating values.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:58 on 2024-08-15 06:50</div>
            <div class="timeline-body"><p>Is this a python convention to use underscore? I don't think I've seen this in any rust code before</p>
<pre><code class="language-suggestion">                let missing = blocks[block] &amp; (1u64 &lt;&lt; index) == 0;
                blocks[block] |= 1u64 &lt;&lt; index;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:92 on 2024-08-15 06:53</div>
            <div class="timeline-body"><p>Isn't this implementing <code>union</code> instead of intersect?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:117 on 2024-08-15 06:53</div>
            <div class="timeline-body"><p>This seems more the <code>next_block_index</code> than the current because we increment it as soon as we move to the next block. It is then one index ahead of where <code>cur_block</code> points to</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:120 on 2024-08-15 06:54</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        current_block: u64,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:130 on 2024-08-15 06:59</div>
            <div class="timeline-body"><p>I find the name value hard to understand. Isn't it the index inside the block? Which is also why need to do some more math before returning it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:144 on 2024-08-15 06:59</div>
            <div class="timeline-body"><p>Nit</p>
<pre><code class="language-suggestion">								*cur_block ^= 1 &lt;&lt; value;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:183 on 2024-08-15 07:02</div>
            <div class="timeline-body"><p>I think that matches what in Rust commonly is named <code>with_capacity</code></p>
<pre><code class="language-suggestion">    pub(super) fn with_capacity(size: usize) -&gt; Self {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:176 on 2024-08-15 07:04</div>
            <div class="timeline-body"><p>I'm not sure if the compiler can see through this. Might be worth to have two extra branches</p>
<pre><code class="language-suggestion">				if size &lt;= N {
					Self::default()
				} else {
					Self::Heap(Vec::with_capacity(size))
				}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:182 on 2024-08-15 07:04</div>
            <div class="timeline-body"><p>Can we pre-allocate the vec with the right size?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:244 on 2024-08-15 07:07</div>
            <div class="timeline-body"><p>Could we slice the array instead and directly return an <code>std::slice::Iter</code>?</p>
<pre><code class="language-suggestion">                &amp;array[..*size],
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:57 on 2024-08-15 07:16</div>
            <div class="timeline-body"><p>Could you let me know how you determined this number? We could probably go higher than this because the size of a <code>BTreeSet</code> is 24 bytes. This means we should use at least two blocks to make the best use of the stack memory. Whether we want to use 3 depends if Rust is able to use a niche to represent the <code>BitSet</code> enum as 24 bytes if the array is small enough. If not, then we should use 3 blocks at least.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:64 on 2024-08-15 07:16</div>
            <div class="timeline-body"><p>Same here, we probably want to use a number higher than 1</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:66 on 2024-08-15 07:17</div>
            <div class="timeline-body"><p>What does it mean: It can handle that many visible definitions per symbol at a given time. What happens if there are more?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:157 on 2024-08-15 07:21</div>
            <div class="timeline-body"><p>Nit: I would use <code>expect</code> here instead of unreachable.</p>
<pre><code class="language-suggestion">            // SAFETY: we only ever create SymbolState with either no definitions and no
            // constraint bitsets (`::unbound`) or one definition and one constraint bitset
            // (`::with`), and `::merge` always pushes one definition and one constraint bitset
            // together (just below), so the number of definitions and the number of constraint
            // bitsets can never get out of sync.
            let constraints = constraints_iter.next().expect(&quot;definitions and constraints length mismatch&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:124 on 2024-08-15 07:28</div>
            <div class="timeline-body"><p>I'm unsure if we can make use of this but:</p>
<p>We should change <code>builder.flow_merge</code> to take an owned snapshot. I didn't had to insert a single <code>snapshot.clone</code>. This could help us to possibly avoid some <code>clone</code> calls because it seems we can consume the value.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:180 on 2024-08-15 07:33</div>
            <div class="timeline-body"><p>Same as above</p>
<pre><code class="language-suggestion">                        let b_constraints = b_constraints_iter.next().expect(&quot;definitions and constraints length mismatch&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:210 on 2024-08-15 07:36</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    pub(super) fn visible_definitions(&amp;self) -&gt; DefinitionIdWithConstraintsIterator {
</code></pre>
<p>The <code>iter</code> prefix is less common when iterating named parts of a struct as we do here. Just <code>visible_definitions</code> seems enough. The return type already specifies that it is an iterator.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:251 on 2024-08-15 07:40</div>
            <div class="timeline-body"><p>We could avoid for <code>from_u32</code> by making <code>BitSet</code> generic over <code>T</code> where <code>T: Into&lt;u32&gt; + From&lt;u32&gt;</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:256 on 2024-08-15 07:40</div>
            <div class="timeline-body"><p>It's unclear where <code>above</code> references to</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:117 on 2024-08-15 07:42</div>
            <div class="timeline-body"><p>Not sure if this method shows up in the profiles but the <code>IntersectionBuilder</code> now always allocates an <code>FxHashSet</code> even for definitions with no constraints.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:180 on 2024-08-15 07:46</div>
            <div class="timeline-body"><p>Nit: I prefer to call this <code>inner</code> and I think I saw this pattern in some other rust code</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:211 on 2024-08-15 07:46</div>
            <div class="timeline-body"><p>Implement <code>FusedIterator</code> (yes, it's annoying)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:12 on 2024-08-15 07:48</div>
            <div class="timeline-body"><p>I don't understand this comment</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:23 on 2024-08-15 07:49</div>
            <div class="timeline-body"><p>You want <code>return_ref</code> here or salsa clones the value everytime the query is called</p>
<pre><code class="language-suggestion">#[salsa::tracked(return_ref)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:49 on 2024-08-15 07:50</div>
            <div class="timeline-body"><p>Lol. <code>node().node()</code>. This is a bit awkward (probably my doing)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:83 on 2024-08-15 07:52</div>
            <div class="timeline-body"><p>Are these operations we expect to call often? Would it make sense to query them once instead of going through salsa multiple times?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:89 on 2024-08-15 07:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            let symbol = self.symbols().symbol_id_by_name(id).unwrap();
            let inference = self.inference();
            let scope = self.scope();
            
            for (op, comparator) in std::iter::zip(ops.as_ref(), comparators.as_ref()) {
                let comp_ty = inference.expression_ty(comparator.scoped_ast_id(self.db, scope));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-08-15 07:54</div>
            <div class="timeline-body"><p>This is great work and the documentation is excellent.</p>
<p>We may be able to remove quiet a bit of code from <code>BitSet</code> by using smallvec (if we want?) and we probably clone the narrowing constraints on every query run which we should avoid ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:383 on 2024-08-15 14:53</div>
            <div class="timeline-body"><p>Yeah I'll add a helper for this; it's test-only though so I'll just implement it for tests I think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 14:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 14:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:170 on 2024-08-15 14:54</div>
            <div class="timeline-body"><p>Yeah I knew about smallvec, not sure why I didn't use it for <code>BitSetArray</code>. I'll try that and see if it works; I've had lifetime-invariance problems before when I've tried using smallvec.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-15 14:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:383 on 2024-08-15 14:58</div>
            <div class="timeline-body"><p>Whoops. I didn't notice that this is all in tests. We need a testing framework</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:170 on 2024-08-15 14:59</div>
            <div class="timeline-body"><p>Yeah, you can run into lifetime errors with smallvec because the variance is incorrect https://github.com/servo/rust-smallvec/issues/146 I'm desperately waiting for small vec 2</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-15 14:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 15:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:13 on 2024-08-15 15:07</div>
            <div class="timeline-body"><p>The semantics of the overall type are ordered-set semantics: a u32 should only appear in it once, and it should stay ordered. These semantics are natural for a bitset representation.</p>
<p>The current design here is that we use a stack-allocated bitset for small values, and fall back to a <code>BTreeSet</code> of the u32 values if we overflow the size of the stack-allocated bitset, because a <code>BTreeSet</code> has the same ordered-set semantics that we need.</p>
<p>It sounds like you are suggesting an alternative design where we just have a growable bitset instead, using <code>SmallVec&lt;u64&gt;</code> to just extend the bitset as far as needed. That sounds like it could also work, and would probably be a bit more efficient when we do need to overflow. I can give it a try.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 15:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:32 on 2024-08-15 15:13</div>
            <div class="timeline-body"><p>The <code>Heap</code> variant in the current code is not a bitset at all, so I think the naming is good for the current code. But I think it probably should be a growable bitset instead, so I'll try making that change and address this as part of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:27 on 2024-08-15 15:15</div>
            <div class="timeline-body"><p>I can add an <code>assert!(usize::BITS &gt;= 32)</code> -- I assume we don't care about actually supporting any 16-bit platforms?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 15:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:58 on 2024-08-15 15:16</div>
            <div class="timeline-body"><p>No, I think the underscore is what clippy/rustc suggested when giving me an error here and suggesting I should clarify the type of the <code>1</code> literal. Doesn't matter to me either way, I can remove it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-15 15:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:13 on 2024-08-15 15:16</div>
            <div class="timeline-body"><p>Yeah. The basic idea is to use the same logic for both variants where we first find the block and then the index inside the block where the only difference is where the blocks are allocated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:92 on 2024-08-15 16:05</div>
            <div class="timeline-body"><p>Uh, yeah, good call -- I think I had a union implementation at some point and copy-pasted intersect from it, but apparently failed to update this mixed case, and don't have any tests for it. Will fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:117 on 2024-08-15 16:07</div>
            <div class="timeline-body"><p>I don't think so; <code>cur_block_index</code> is always the index of <code>cur_block</code>. We initialize with <code>cur_block_index = 0</code> and <code>cur_block = blocks[0]</code>, and when we increment <code>cur_block_index</code> the very next line is <code>*cur_block = blocks[*cur_block_index]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:130 on 2024-08-15 16:09</div>
            <div class="timeline-body"><p>Yeah, it's the low set bit in the current block, which is the next value to return only if the current block is block 0, otherwise we need to account for the bits in all the other blocks. I'll find a better name for it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-15 16:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:58 on 2024-08-15 16:09</div>
            <div class="timeline-body"><p>Same. Up to you</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-15 16:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:27 on 2024-08-15 16:10</div>
            <div class="timeline-body"><p>Probably not but Ruff supports a large range of targets</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:144 on 2024-08-15 16:11</div>
            <div class="timeline-body"><p>I might check how Rust compiles each of these; I thought the <code>wrapping_sub(1)</code> trick might be a bit more efficient. But it probably doesn't matter. I agree your version is easier to understand, which is why I added the comment :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:183 on 2024-08-15 16:18</div>
            <div class="timeline-body"><p>I think it's different; the &quot;capacity&quot; here is already fixed by the const generic parameter. This constructor is actually creating a non-empty array of <code>size</code> user-visible empty bitset values. The name <code>with_capacity</code> would wrongly suggest that it's creating an empty bitset array with a capacity to hold a certain number of bitsets without resizing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:176 on 2024-08-15 16:20</div>
            <div class="timeline-body"><p>This suggestion won't work as written for the reason described above: the semantics of this method are not <code>with_capacity</code> semantics. The first branch would also need to increment <code>self.size</code>, and the second branch needs to also actually push <code>size</code> elements onto the vec, after creating it.</p>
<p>But it still may be worth the separate branches here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:244 on 2024-08-15 16:22</div>
            <div class="timeline-body"><p>Good idea, will try that!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:57 on 2024-08-15 16:24</div>
            <div class="timeline-body"><p>I think I initially had this set as 4, and found that 1 performed better, and 1-3 didn't show any meaningful difference. It's a good point though that it should be at least as big as the <code>BTreeSet</code> (though this factor may disappear if I go with your growable-bitset suggestion.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:64 on 2024-08-15 16:25</div>
            <div class="timeline-body"><p>I initially had a higher number and switched to 1 because it performed best. In this case I'm not sure the argument for using a bigger number is as strong, because I suspect an array of 1 <code>BitSet</code> is already as large as a <code>Vec</code>? But I'll double check both the sizes and the actual performance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:66 on 2024-08-15 16:27</div>
            <div class="timeline-body"><p>The key word &quot;inline&quot; is at the end of the sentence. I'll re-phrase to make it clearer.</p>
<p>What happens if there are more is that our <code>BitSetArray</code> of constraints-per-definition (where there is a <code>BitSet</code> per definition, and the constraints are individual bits in the <code>BitSet</code>) will overflow to the heap-allocated vector representation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 16:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:57 on 2024-08-15 16:30</div>
            <div class="timeline-body"><p>I think currently, given the factor I mentioned in our 1:1 (that the performance bottleneck in this PR is cloning the entire IndexVec of SymbolStates at every branch point), the dominating factor in performance is the size of that <code>IndexVec</code>, which means wasting as little memory here as possible seems to be more important than keeping the data always inline (though likely only to a point; I suspect it would be a regression if we always had to allocate everything as vectors-of-vectors.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-15 16:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:57 on 2024-08-15 16:37</div>
            <div class="timeline-body"><p>Storing more inline can help with reducing the cost of cloning.</p>
<blockquote>
<p>(though this factor may disappear if I go with your growable-bitset suggestion.)</p>
</blockquote>
<p>An <code>IndexVec</code> has the same constraints except that it already uses a niche to determine the variant, in which case we would have to go with 2 (I don't expect it to help much because 64 is already a lot of values)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:256 on 2024-08-15 17:46</div>
            <div class="timeline-body"><p>It refers to the previous safety comment about this same assertion that definitions and constraints length should match. I can just repeat the comment instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 17:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:117 on 2024-08-15 17:47</div>
            <div class="timeline-body"><p>I'll check the profile. Could easily special-case no-constraints here to avoid this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 17:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 17:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:12 on 2024-08-15 17:50</div>
            <div class="timeline-body"><p>The expression <code>test</code> might (or might not) apply some constraint on <code>definition</code>. E.g. if the <code>definition</code> is of symbol <code>x</code>, then the <code>test</code> <code>x is not None</code> does apply a constraint on that definition, and we'd return the type <code>~None</code> here. But the <code>test</code> expression <code>y is not None</code> does not apply any constraint to the definition of <code>x</code>, so we'd return <code>None</code>.</p>
<p>I can add a fuller description/example like this to the doc comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 17:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:49 on 2024-08-15 17:53</div>
            <div class="timeline-body"><p>I guess the field on <code>Expression</code> could be called <code>node_ref</code> instead of <code>node</code>, so this would be <code>.node_ref(self.db).node()</code> which is probably a bit clearer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 17:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:83 on 2024-08-15 17:54</div>
            <div class="timeline-body"><p>It would be really nice if we could think of calling a cached Salsa query as &quot;free&quot;, but I guess we can't :/ Yeah, I'll cache these on the builder.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 20:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:49 on 2024-08-15 20:15</div>
            <div class="timeline-body"><p>I thought maybe we could provide an <code>Expression::node</code> method that would return a reference to the actual expression, but that causes borrowing problems because then the caller thinks the lifetime of the <code>&amp;ast::Expr</code> is tied to the entire <code>Expression</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-15 23:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:251 on 2024-08-15 23:57</div>
            <div class="timeline-body"><p>I tried this, but I wasn't convinced it was a net benefit. It introduces a <em>lot</em> of extra noise in the BitSet implementation, in exchange for eliminating very little noise in <code>symbol_state.rs</code>. And in making the change I somehow introduced a bug; it didn't seem worth tracking it down, I just reverted the change instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 00:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:124 on 2024-08-16 00:03</div>
            <div class="timeline-body"><p>I think I used to have this but I changed it to take a reference because clippy doesn't like it if it's passed by value but not consumed. And it doesn't seem like we can gain anything by consuming it; it isn't cloned anywhere in this method. We already reuse <code>self</code> in-place and merge the data from <code>snapshot</code> into it; we can't reuse both of them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 00:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:244 on 2024-08-16 00:16</div>
            <div class="timeline-body"><p>Great suggestion, this allowed totally removing <code>BitSetArrayIterator</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 01:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:83 on 2024-08-16 01:40</div>
            <div class="timeline-body"><p>On looking at this more, for a given <code>NarrowingConstraintsBuilder</code> we'd expect to usually call any of these zero or one times; if the constraint is particularly complex, maybe several times. I moved the calls outside the loop over comparators as you suggested below, but I don't think further caching of these is worth it. We could try it later once we have more kinds of constraints supported.</p>
<p>Unconditionally querying these on construction of a <code>NarrowingConstraintsBuilder</code> is like a 10-15% regression, because currently most of the time we query these zero times (because the constraint is not in the form <code>x is not y</code>, which is the only constraint form we support in this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 02:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:64 on 2024-08-16 02:57</div>
            <div class="timeline-body"><p><code>[BitSet&lt;1&gt;; 1]</code> is 32 bytes, <code>Vec&lt;BitSet&gt;</code> is 24 bytes, so there's no wasted memory in leaving this at 1. Empirically 1 and 2 perform the same on the benchmark, 3 is a small regression, 4 is a large regression, so I'll set this to 2 for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 03:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:57 on 2024-08-16 03:05</div>
            <div class="timeline-body"><p>A <code>BitSet&lt;1&gt;</code> is 32 bytes, suggesting Rust isn't able to use a niche to differentiate the enum. And indeed, BitSets of size 1, 2, and 3 are all 32 bytes; 4 increases to 40 bytes.</p>
<p>Empirically I'm not able to detect any performance difference between 1, 2, 3, or 4. I'll leave it at 3 for now; 3 * 64 is quite a lot of definitions in one scope.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 03:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:57 on 2024-08-16 03:06</div>
            <div class="timeline-body"><p>I'll revisit this after I implement the growable-bitset version.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 03:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:176 on 2024-08-16 03:15</div>
            <div class="timeline-body"><p>The two explicit branches don't seem to affect benchmark performance detectably, but the code is still quite concise and I think it is likely the compiler doesn't see through the other version, so I'll leave the two branches.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 04:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:144 on 2024-08-16 04:22</div>
            <div class="timeline-body"><p>Going to leave this; the <code>wrapping_sub(1)</code> way looks a bit more efficient; possibly most importantly it doesn't have a data dependence on storing the lowest set bit first, so it can allow a bit more parallel execution. I think with the comment it's sufficiently understandable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 05:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:23 on 2024-08-16 05:02</div>
            <div class="timeline-body"><p>Surprisingly (to me) this didn't make a detectable difference in the benchmarks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 05:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:23 on 2024-08-16 05:04</div>
            <div class="timeline-body"><p>I think perhaps that's just because in practice <code>NarrowingConstraints</code> will usually be quite small: either an empty <code>FxHashMap</code> or an <code>FxHashMap</code> with a single entry in it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 05:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:13 on 2024-08-16 05:48</div>
            <div class="timeline-body"><p>This was a good suggestion, thanks! Doesn't seem to have a significant impact on perf either way, but the code is simpler.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-16 05:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:23 on 2024-08-16 05:52</div>
            <div class="timeline-body"><p>Interesting. This is not for this PR, but it might be worth considering returning a <code>Vec</code> instead of a <code>HashSet</code> (or implementing our own <code>TinySet</code> that is based on <code>SmallVec</code>). Vecs are cheaper to create and can also be faster to search when they are only very few items.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-16 05:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:13 on 2024-08-16 05:54</div>
            <div class="timeline-body"><p>Did you made the changes locally? Because I don't see them here yet :D</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 06:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:170 on 2024-08-16 06:06</div>
            <div class="timeline-body"><p>This is a great suggestion too; no lifetime errors, no effect on perf, but allows removing a lot of code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-16 06:13</div>
            <div class="timeline-body"><p>@MichaReiser Thanks for the excellent review! I think I've addressed all the comments. Lots of changes, so you may want to take another look.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:20 on 2024-08-16 06:15</div>
            <div class="timeline-body"><p>Nit: Could this also be a static assertion?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:57 on 2024-08-16 06:16</div>
            <div class="timeline-body"><p>Nit <a href="https://rust-lang.github.io/api-guidelines/naming.html#getter-names-follow-rust-convention-c-getter">naming-conventions</a></p>
<pre><code class="language-suggestion">    fn blocks(&amp;self) -&gt; &amp;[u64] {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:45 on 2024-08-16 06:17</div>
            <div class="timeline-body"><p>Nit: I guess the method now does slightly more than just &quot;overflowing&quot;. Maybe rename to <code>reserve</code> or <code>resize</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:124 on 2024-08-16 06:19</div>
            <div class="timeline-body"><p>I do think we could make use of it but it would probably complicate the logic a bit because you need two versions of <code>push</code> and a <code>into_iter</code> version for <code>constraints</code></p>
<p>For example, couldn't we avoid cloning the constraints and instead take them right from the symbol state?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-08-16 06:21</div>
            <div class="timeline-body"><p>I only skimmed through. Thanks for addressing all the feedback and we're down to a 13% perf regression :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 22:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:20 on 2024-08-16 22:15</div>
            <div class="timeline-body"><p>No, it can't, I tried; using const generic parameters in const expressions is not supported (or at least not in stable) yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-16 23:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:124 on 2024-08-16 23:14</div>
            <div class="timeline-body"><p>Ok, yeah, I was too tired yesterday after going through all the other comments to push this all the way through :) You're right, I can eliminate the <code>constraints.clone()</code> this way; I don't even need two variants of <code>push</code> because I can use <code>into_iter</code> for iterating both incoming constraint sets.</p>
<p>Sadly this doesn't seem to move the needle at all on the benchmarks, but it makes sense to do it this way so I'll leave it.</p>
<p>Going to go ahead and merge this, but feel free to take a look at the updated <code>SymbolState::merge</code> and <code>UseDefMapBuilder::merge</code> and tell me if you see anywhere else I'm leaving potential perf on the floor. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-16 23:28</div>
            <div class="timeline-body"><p>Hmm, I made a reply comment about the &quot;taking ownership in merge&quot; thing but now I don't see it in the UI anywhere. Anyway the upshot was that you're right, I was able to do that; it didn't help the benchmarks but I left it in anyway. Going to go ahead and merge this, but if you see anything in those latest changes that looks dumb, don't hesitate to comment and I'll fix!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-08-16 23:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-08-16 23:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-16 23:34</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:05:44 UTC
    </footer>
</body>
</html>
