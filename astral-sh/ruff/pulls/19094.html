<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Rewrite `Type::any_over_type` using a new generalised `TypeVisitor` trait - astral-sh/ruff #19094</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Rewrite <code>Type::any_over_type</code> using a new generalised <code>TypeVisitor</code> trait</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19094">#19094</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-07-02 15:05
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Our <code>Type::any_over_type()</code> method has two problems:</p>
<ol>
<li>There are several types where it does not recurse into all nested types!</li>
<li>It doesn't guard against recursion at all. This isn't much of a problem now, but becomes more of a problem when we introduce more recursive types, such as in https://github.com/astral-sh/ruff/pull/18659</li>
</ol>
<p>This PR introduces a new <code>TypeVisitor</code> trait that aims to solve both of these issues in a generalized way:</p>
<ol>
<li>Walking nested types is delegated down to <code>walk_*_type</code> functions that live close to the structs they walk. For example, walking all nested types in a <code>NominalInstanceType</code> is handled by a <code>walk_nominal_instance_type</code> function that lives next to the <code>NominalInstanceType</code> struct in <code>instance.rs</code>. This makes it less likely that we'll forget to update the function if we add a new field to <code>NominalInstanceType</code> in the future.</li>
<li>The trait makes it easy to write concrete implementations that guard against recursion in an efficient way.</li>
</ol>
<p><code>Type::any_over_type</code> is reimplemented as a standalone <code>any_over_type</code> function that uses a concrete implementation of the new <code>TypeVisitor</code> trait as its implementation.</p>
<p>If we like the direction this PR is going in, we might want to rename the existing <code>TypeVisitor</code> struct that @carljm added in https://github.com/astral-sh/ruff/pull/19003. We <em>may</em> also want to reimplement <code>Type::normalize</code> and <code>Type::apply_type_mapping</code> using a similar <code>TypeTransformer</code> trait, but I'll defer to @carljm on that point, since he has ongoing work in this area.</p>
<h2>Test Plan</h2>
<p>All existing tests pass.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-07-02 15:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-07-02 15:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2025-07-02 15:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @AlexWaygood on 2025-07-02 15:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-07-02 15:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-02 15:14</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">Expression (https://github.com/cognitedata/Expression)
-     memo fields = ~54MB
+     memo fields = ~49MB

operator (https://github.com/canonical/operator)
- TOTAL MEMORY USAGE: ~97MB
+ TOTAL MEMORY USAGE: ~106MB
-     memo fields = ~80MB
+     memo fields = ~88MB

hydra-zen (https://github.com/mit-ll-responsible-ai/hydra-zen)
- TOTAL MEMORY USAGE: ~80MB
+ TOTAL MEMORY USAGE: ~88MB

rich (https://github.com/Textualize/rich)
- TOTAL MEMORY USAGE: ~142MB
+ TOTAL MEMORY USAGE: ~129MB

discord.py (https://github.com/Rapptz/discord.py)
- TOTAL MEMORY USAGE: ~228MB
+ TOTAL MEMORY USAGE: ~251MB

pydantic (https://github.com/pydantic/pydantic)
- TOTAL MEMORY USAGE: ~156MB
+ TOTAL MEMORY USAGE: ~142MB

mkosi (https://github.com/systemd/mkosi)
-     memo fields = ~106MB
+     memo fields = ~97MB

vision (https://github.com/pytorch/vision)
- TOTAL MEMORY USAGE: ~368MB
+ TOTAL MEMORY USAGE: ~334MB

bandersnatch (https://github.com/pypa/bandersnatch)
-     memo fields = ~66MB
+     memo fields = ~72MB

paasta (https://github.com/yelp/paasta)
- TOTAL MEMORY USAGE: ~189MB
+ TOTAL MEMORY USAGE: ~207MB

psycopg (https://github.com/psycopg/psycopg)
- TOTAL MEMORY USAGE: ~228MB
+ TOTAL MEMORY USAGE: ~207MB

sphinx (https://github.com/sphinx-doc/sphinx)
- TOTAL MEMORY USAGE: ~304MB
+ TOTAL MEMORY USAGE: ~276MB

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/lib.rs</code>:46 on 2025-07-02 17:49</div>
            <div class="timeline-body"><p>I wonder if some of our existing uses of <code>FxOrderSet</code> should actually be <code>FxIndexSet</code>, if we don't need the stronger equality and order-maintenance guarantees provided by the <code>ordermap</code> wrapper crate? Not something for this PR, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7524 on 2025-07-02 18:00</div>
            <div class="timeline-body"><p>These are the sorts of cases that made me somewhat hesitant to implement a generic walk-types facility (or at least, unclear how it should be implemented). Is the RHS of a PEP695 type alias &quot;part of&quot; its type? It's certainly relevant to the meaning of the type. Is the answer the same for every possible type walk? I would probably expect <code>any_over_type</code> to descend into the RHS, but I'm not sure what a type transformer could be expected to do here, unless we implemented a &quot;Synthesized&quot; variant of PEP 695 type aliases. (Maybe we will need that in order to support recursive type aliases?)</p>
<p>It seems somewhat parallel to the case of class-defined (non-synthesized) protocols, where the semantics of the type includes details that require further queries and aren't stored directly in the type itself.</p>
<p>I think this is fine for this PR, just musing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-02 18:52</div>
            <div class="timeline-body"><p>The code here looks nice. My main hesitation here is that I'm not totally clear that <code>any_over_type</code> is even a clearly defined operation for all types (see inline comment), and it's only currently used in deciding whether to issue a redundant-cast diagnostic. This seems like a lot of machinery to introduce for that small edge case, in the absence of a clear understanding (which I at least don't currently have) of the semantics of the generalized operation, and the future use cases for it.</p>
<p>I'm tempted to say that we should instead try to remove the need for <code>any_over_type</code> (as we already did for <code>is_fully_static</code>), and aim to avoid the need for these generalized recursive type walk tests entirely. To me, the ecosystem report on https://github.com/astral-sh/ruff/pull/19099 suggests that this is feasible. Removing the use of <code>any_over_type</code> entirely does not fail any existing tests or introduce many new diagnostics, and it seems like a fairly limited effort to address some Todos would remove most of the diagnostics it does introduce. (Plus, I don't think the current existence of todos and the desire to silence false positives arising from them should drive significant design decisions.)</p>
<p>I do think this PR is useful regardless, because I think a lot of it could be reused for a similar <code>TypeTransformer</code> trait, and that's something I do think we will need.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-02 19:09</div>
            <div class="timeline-body"><p>Thank you for putting this together! I think my current feeling is we should go with https://github.com/astral-sh/ruff/pull/19099 instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-07-03 11:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/lib.rs</code>:46 on 2025-07-03 11:40</div>
            <div class="timeline-body"><p>I don't think an <code>FxIndexSet</code> is hashable, so I think we do need to use <code>FxOrderSet</code> for the fields on <code>IntersectionType</code>, for example. But yeah, it does look like a bunch of places are using an <code>OrderSet</code> right now when they probably only really need an <code>IndexSet</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-03 16:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7524 on 2025-07-03 16:36</div>
            <div class="timeline-body"><p>Follow-up from in-person discussion: this should be fixed to walk the RHS</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-07-03 16:40</div>
            <div class="timeline-body"><p>After discussing in person, I'm convinced that we will likely have other future uses for this. I don't love that we do this potentially-expensive walk on two different types every time we see a <code>cast</code>, but it doesn't seem in practice like that's causing noticeable perf issues on any ecosystem project; we can deal with it later if it comes up.</p>
<p>So this looks good to me, modulo the PEP 695 type aliases fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-03 16:41</div>
            <div class="timeline-body"><p>Oh, and I do think we should rename my existing <code>TypeVisitor</code> to avoid confusion, either in this PR or as a follow-up. It could already be called <code>TypeTransformer</code> maybe?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-07-03 18:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-07-03 18:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-03 18:19</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:13:53 UTC
    </footer>
</body>
</html>
