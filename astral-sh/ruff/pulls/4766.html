<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Replace deletion-tracking with enforced isolation levels - astral-sh/ruff #4766</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Replace deletion-tracking with enforced isolation levels</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/4766">#4766</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-05-31 21:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body">

Summary
<p>We tend to apply all of our edits in one pass, similar to ESLint&#x27;s model. However, there&#x27;s one common case where it&#x27;s not safe to apply edits in this way: deleting statements from indented bodies, where we run the risk of leading behind an empty body (and, instead, should leave behind a <code>pass</code> statement).</p>
<p>For example, if we remove both imports here independently, we&#x27;ll generate a syntax error:</p>
<pre><code>if True:
  import os
  import sys
</code></pre>
<p>Historically, the way we solved this problem was by tracking statement deletions in the AST checker. So, when we generate the edit to delete <code>import os</code>, we&#x27;ll mark that statement as deleted. When we go to delete <code>import sys</code>, we&#x27;ll note that deleting this statement will leave the body empty (assuming all edits are applied), and instead create an edit to replace the statement with a <code>pass</code> (rather than deleting it outright).</p>
<p>This makes the edit process stateful, since we&#x27;re generating edits based on assumptions about how the code will change when <em>other</em> edits are applied. It also leads to subtle bugs when edits end up being applied in isolation, as in the LSP -- e.g., removing the second import here erroneously leaves the user with a <code>pass</code>:</p>
<p>https://github.com/charliermarsh/ruff/assets/1309177/a4d743cc-138d-46ae-8b41-89ba9602c740</p>
<p>One alternative solution would be to only apply one edit at a time, then re-run Ruff, etc. We tried this previously, and it can really hurt performance for large codebases, since your we have to run Ruff as up to the maximum number of fixable errors in your file.</p>
<p>This PR proposes a middle-ground solution, whereby fixes can declare themselves as require isolation. We only apply one isolation-requiring fix per run (though we will batch it with other, non-isolation-requiring fixes). It&#x27;s rare that fixes require isolation, but in short, any fix that involves a statement deletion within a nested block must be isolated. (We already tracked these anyway, since we have a common helper for it.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-31 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/konstin">@konstin</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-31 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-31 21:14</div>
            <div class="timeline-body"><p>How does this affect performance. Do you know how rare is i practice?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-31 21:17</div>
            <div class="timeline-body"><p>I&#x27;m not sure yet, but one thing I&#x27;m going to do to improve performance is add a key to the isolation groups, so that we can fix both of these in one pass:</p>
<pre><code>if False:
  import os

if False:
  import sys
</code></pre>
<p>So the maximum number of runs will be equal to the maximum number of deletions within any indent block (as opposed to the total number of deletions across all indented blocks in the file).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-05-31 21:36</div>
            <div class="timeline-body">PR Check Results
Ecosystem
<p>✅ ecosystem check detected no changes.</p>
Benchmark
Linux
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.00     14.3±0.08ms     2.9 MB/sec    1.01     14.4±0.10ms     2.8 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.02      3.5±0.18ms     4.8 MB/sec    1.00      3.4±0.02ms     4.9 MB/sec
linter/all-rules/numpy/globals.py          1.01    422.7±0.46µs     7.0 MB/sec    1.00    420.2±0.51µs     7.0 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.9±0.02ms     4.3 MB/sec    1.00      5.9±0.04ms     4.3 MB/sec
linter/default-rules/large/dataset.py      1.03      7.0±0.03ms     5.8 MB/sec    1.00      6.8±0.04ms     6.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.02   1517.6±3.71µs    11.0 MB/sec    1.00   1491.8±2.43µs    11.2 MB/sec
linter/default-rules/numpy/globals.py      1.02    172.3±0.63µs    17.1 MB/sec    1.00    168.8±0.36µs    17.5 MB/sec
linter/default-rules/pydantic/types.py     1.02      3.1±0.01ms     8.2 MB/sec    1.00      3.1±0.01ms     8.3 MB/sec
parser/large/dataset.py                    1.00      5.2±0.01ms     7.9 MB/sec    1.00      5.2±0.02ms     7.8 MB/sec
parser/numpy/ctypeslib.py                  1.00   1008.9±0.44µs    16.5 MB/sec    1.00   1012.3±1.19µs    16.4 MB/sec
parser/numpy/globals.py                    1.00    105.3±0.18µs    28.0 MB/sec    1.00    105.1±0.26µs    28.1 MB/sec
parser/pydantic/types.py                   1.00      2.2±0.00ms    11.5 MB/sec    1.00      2.2±0.00ms    11.4 MB/sec
</code></pre>
Windows
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.00     16.6±0.35ms     2.4 MB/sec    1.00     16.6±0.24ms     2.5 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.03      4.3±0.12ms     3.9 MB/sec    1.00      4.2±0.04ms     4.0 MB/sec
linter/all-rules/numpy/globals.py          1.03   514.4±17.81µs     5.7 MB/sec    1.00    500.6±9.34µs     5.9 MB/sec
linter/all-rules/pydantic/types.py         1.01      7.1±0.16ms     3.6 MB/sec    1.00      7.0±0.12ms     3.6 MB/sec
linter/default-rules/large/dataset.py      1.01      8.3±0.13ms     4.9 MB/sec    1.00      8.3±0.14ms     4.9 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1766.1±35.76µs     9.4 MB/sec    1.00  1772.4±34.86µs     9.4 MB/sec
linter/default-rules/numpy/globals.py      1.00    208.0±6.54µs    14.2 MB/sec    1.00    207.6±6.95µs    14.2 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.8±0.07ms     6.8 MB/sec    1.00      3.8±0.08ms     6.8 MB/sec
parser/large/dataset.py                    1.00      6.4±0.05ms     6.4 MB/sec    1.02      6.5±0.09ms     6.2 MB/sec
parser/numpy/ctypeslib.py                  1.01  1229.8±31.22µs    13.5 MB/sec    1.00  1217.9±24.88µs    13.7 MB/sec
parser/numpy/globals.py                    1.00    124.4±2.08µs    23.7 MB/sec    1.01    125.9±2.48µs    23.4 MB/sec
parser/pydantic/types.py                   1.00      2.8±0.06ms     9.2 MB/sec    1.01      2.8±0.07ms     9.1 MB/sec
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-01 03:12</div>
            <div class="timeline-body"><p>Ok, I improved the performance (and added some commentary) in #4774. (I want to keep them as separate PRs, since they can both stand on their own.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-01 04:01</div>
            <div class="timeline-body"><p>It looks like in CPython, there are 143 unused imports in nested blocks, but many of these are tied to the same statement (e.g., <code>crates/ruff/resources/test/cpython/Lib/subprocess.py</code> reports 18 unused imports in nested block, but they&#x27;re all part of one import-from statement, and so are fixed in one pass).</p>
<p>The worst offender is <code>crates/ruff/resources/test/cpython/Lib/test/test_import/__init__.py</code>, which has 34 unused imports, all of which seem to come from separate statements. (It&#x27;s a file that includes a bunch of imports within tests, to test the imports themselves.)</p>
<p>Most other files that have at least one unused import in a nested block have ~1-4 such imports. So it&#x27;s pretty rare.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff/src/rules/flake8_type_checking/rules/empty_type_checking_block.rs</code>:56 on 2023-06-01 06:31</div>
            <div class="timeline-body"><p>(not your code) i&#x27;m surprised this didn&#x27;t trigger clippy</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> approved on 2023-06-01 06:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/autofix/edits.rs</code>:180 on 2023-06-01 06:33</div>
            <div class="timeline-body"><p>Nit: Does <code>matches!(vec.as_slice(), [value])</code> work?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/autofix/mod.rs</code>:71 on 2023-06-01 06:34</div>
            <div class="timeline-body"><p>Nit</p>
<pre><code>        if fix.isolation().is_isolated() {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2023-06-01 06:37</div>
            <div class="timeline-body"><p>Instead of setting isolation as a binary flag, would it be possible to set Isolation with a text range or a dummy edit on the parent node?</p>
<pre><code>if True:
  import os
  import sys

if 1==1:
  import re
  import platform
</code></pre>
<p>The os and sys edits could mark the whole <code>if True</code> node as affected, the re and platform edits on the <code>if 1==1</code>. We would then apply the os and re edit in one pass (not inserting a pass) and the sys and platform edit in the second one (inserting a pass)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/autofix/mod.rs</code>:70 on 2023-06-01 06:40</div>
            <div class="timeline-body"><p>Oh, this is interesting. I expected that we run <code>isolated</code> fixes in full isolation -&gt; We apply no other fixes in that pass. But that&#x27;s not what we do. Is there another word that may describe this behavior better?</p>
<p>I guess I expected <code>Serializable</code> isolation (using SQL terminology) and our default isolation level is <code>NO_OVERLAPPING</code>. The way I think about this new isolation level is similar to NON_CONCURRENT but that feels wrong too. Hmm</p>
<p>On naming:</p>
<ul>
<li>Should we rename <code>Isolation</code> to <code>IsolationLevel</code></li>
<li>Should we rename the default isolation to <code>NoOverlapping</code> (or similar) because all fixes have an isolation.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:5290 on 2023-06-01 06:40</div>
            <div class="timeline-body"><p>Yeeess! Weird magic <code>fix.content() == Some(&quot;pass&quot;)</code> is gone</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pyflakes/rules/unused_variable.rs</code>:218 on 2023-06-01 06:42</div>
            <div class="timeline-body"><p>Thanks for categorizing the fixes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:151 on 2023-06-01 06:43</div>
            <div class="timeline-body"><p>Hehe, <code>Isolation</code>... level ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-06-01 06:43</div>
            <div class="timeline-body"><p>Nice. I love how this removes complexity throughout the whole code base.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-01 20:35</div>
            <div class="timeline-body"><p>@konstin - Yes! I ended up doing this in <a href="https://github.com/charliermarsh/ruff/pull/4774">charliermarsh/ruff#4774</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-01 20:36</div>
            <div class="timeline-body"><p>We could probably go even further if we&#x27;re willing to accept more heuristics. E.g., we could check if the body contains at least one statement that we would <em>never</em> delete (huge hack), we could avoid isolation levels...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-06-02 02:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/autofix/edits.rs</code>:180 on 2023-06-02 02:34</div>
            <div class="timeline-body"><p>No, <code>matches!(vec, [v] if v == value)</code> does, though is that better?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-02 02:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-02 02:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-06-02 02:45</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:54:07 UTC
    </footer>
</body>
</html>
