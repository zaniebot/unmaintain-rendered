<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] linear variance inference for PEP-695 type parameters - astral-sh/ruff #18713</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] linear variance inference for PEP-695 type parameters</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18713">#18713</a>
        opened by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a>
        on 2025-06-17 06:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on 2025-06-17 06:16</div>
            <div class="timeline-body"><!--
Thank you for contributing to Ruff/ty! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title? (Please prefix with `[ty]` for ty pull
  requests.)
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<p>Implement linear-time variance inference for type variables (https://github.com/astral-sh/ty/issues/488).</p>
<p>Inspired by Martin Huschenbett's <a href="https://www.youtube.com/watch?v=7uixlNTOY4s&amp;t=9705s">PyCon 2025 Talk</a>.</p>
<h2>Test Plan</h2>
<p>update tests
add new test case for mutually recursive classes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-06-17 08:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-18 03:40</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅
No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:411 on 2025-06-25 01:16</div>
            <div class="timeline-body"><p>The last bullet point of the <a href="https://typing.python.org/en/latest/spec/generics.html#scoping-rules-for-type-variables">scoping rules</a> section of the spec says that the typevar scope of an outer class does not cover an inner class, so it should be an error for <code>D</code> to refer to <code>T</code>. (We don't currently check this correctly yet.)</p>
<p>The pattern that they suggest for this example would be</p>
<pre><code class="language-py">class C[T]:
    class D[U]:
        def f(self, value: U) -&gt; None: ...

    def f(self, value: D[T]) -&gt; None: ...
</code></pre>
<p>I'm not sure if this invalidates your reasoning in the next paragraph.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:838 on 2025-06-25 01:22</div>
            <div class="timeline-body"><p>We should see if Martin has a linkable copy of his slides that we can cite as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/semantic_index/place.rs</code>:492 on 2025-06-25 01:23</div>
            <div class="timeline-body"><p>nit: you should't need the qualifier, <code>PartialOrd</code> is in the prelude</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:286 on 2025-06-25 01:24</div>
            <div class="timeline-body"><p>We are (starting to) try to cut back on the size of this file. Could you move the new variance-related stuff into a new <code>types/variance.rs</code> submodule?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:329 on 2025-06-25 01:26</div>
            <div class="timeline-body"><p>nit: <code>TypeVarVariance</code> is a non-data-carrying enum that implements <code>Eq</code>, so you can just use an equality comparison here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6351 on 2025-06-25 01:30</div>
            <div class="timeline-body"><p>There's a helper method for printing out a nicer rendering of the type:</p>
<pre><code class="language-suggestion">        tracing::debug!(
            &quot;Checking variance of '{tvar}' in `{ty}`&quot;,
            tvar = type_var.name(db),
            ty = self.display(db),
        );
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6291 on 2025-06-25 01:32</div>
            <div class="timeline-body"><p>My hunch is that we <em>don't</em> want the alternative you suggest in the TODO, since this method should materialize the containing type as it is, and not perform other operations on it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6297 on 2025-06-25 01:35</div>
            <div class="timeline-body"><p>I don't think we want <code>track_caller</code> here. That's intended more for e.g. assertion helpers, where locations within the function aren't useful to include in a panic message or stack trace</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6313 on 2025-06-25 01:37</div>
            <div class="timeline-body"><p>add a <code>use</code> statement for <code>NodeWithScopeKind</code> up top, this is an awful lot of redundant qualifiers</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6328 on 2025-06-25 01:38</div>
            <div class="timeline-body"><p>Make this a <code>panic!</code> instead of an <code>unreachable!</code>. The speed difference will not be noticeable, and the extra safety of a panic will be important</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6448 on 2025-06-25 01:42</div>
            <div class="timeline-body"><p>Should we change <code>TypeVarVariance</code> to be a bitset? Co- and contravariant would be the individual bits; bivariant would be both set; invariant would be both unset.  Then this function would just be bitwise-AND.</p>
<p>(I'm not convinced by this suggestion — I worry it would be more clever than useful.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6600 on 2025-06-25 01:46</div>
            <div class="timeline-body"><p>The short-circuiting behavior here isn't semantically important, is it? Will we be folding over large enough iterators for it to be important from a performance standpoint? I feel like a simple non-short-circuiting <code>fold</code> will be much easier to understand.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:18 on 2025-06-25 01:48</div>
            <div class="timeline-body"><p>Is the <code>ide_support</code> import spurious?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:232 on 2025-06-25 01:48</div>
            <div class="timeline-body"><p>Our house style would be to call <code>.chain</code> on the first iterator directly</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2118 on 2025-06-25 01:52</div>
            <div class="timeline-body"><p>This is a minor style nit, but we (or at least I!) try to avoid too much abbreviation in variable names. So I would prefer <code>spec</code> → <code>specialization</code>; <code>ctx</code> → <code>generic_context</code>; <code>tvar</code> → <code>typevar</code>; etc here and elsewhere</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2334 on 2025-06-25 01:53</div>
            <div class="timeline-body"><p>The usage here suggests that <code>all_declarations_and_bindings</code> belongs somewhere other than <code>ide_support</code>, though that might be out of scope for this PR, especially if it's already being used elsewhere for type inference purposes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-06-25 01:55</div>
            <div class="timeline-body"><p>Some initial comments</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-06-28 23:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types.rs</code>:286 on 2025-06-28 23:24</div>
            <div class="timeline-body"><p>Would you move all the trait impls too?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-06-28 23:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6291 on 2025-06-28 23:25</div>
            <div class="timeline-body"><p>Okay, that's what I figured, just wanted to double-check</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-06-28 23:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6600 on 2025-06-28 23:46</div>
            <div class="timeline-body"><p>It's definitely not semantically important, just a performance optimization.</p>
<p>I do actually think this one is worth it: suppose we have a class where there's an early invariant occurrence (this is actually relatively common, as any mutable instance member would be). The short-circuit here saves us traversing the entire rest of the class members. If the class references other classes, or even a mutual recursive class, this could save us a lot of work (especially since in the latter case, we're not truly linear due to how salsa handles Fixpoint iterations).</p>
<p>We actually do something similar in <a href="https://github.com/astral-sh/ruff/blob/9218bf72ad84f56f48c3cca985be8565ae1600e7/crates/ty_python_semantic/src/semantic_index/reachability_constraints.rs#L628">reachability analysis</a> where we short-circuit with the same trick.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-06-29 15:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2118 on 2025-06-29 15:34</div>
            <div class="timeline-body"><p>Do you have opinions about <code>typevar</code> vs <code>type_var</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:18 on 2025-06-30 03:38</div>
            <div class="timeline-body"><p>No, it's used in the below <code>all_declarations_and_bindings</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-06-30 03:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[ty] linear variance inference" to "[ty] linear variance inference for PEP-695 type parameters" by @AlexWaygood on 2025-07-09 08:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:374 on 2025-07-22 23:48</div>
            <div class="timeline-body"><p>I would find this explanation of the example a bit clearer if it acknowledged the existence of <code>Y</code> (the type parameter in <code>D</code>). It seems to entirely conflate that type parameter with <code>X</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:5564 on 2025-07-23 00:14</div>
            <div class="timeline-body"><p>I think the PEP / spec suggests an equivalence of <code>Self</code> to an invariant typevar, and I'm not sure it would ever make a difference. I don't think we need to trigger variance inference on <code>Self</code>. It doesn't seem to impact any tests if I do this:</p>
<pre><code class="language-suggestion">                        Some(TypeVarVariance::Invariant),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6310 on 2025-07-23 00:40</div>
            <div class="timeline-body"><p>Do we have tests for these cases? As an experiment, I changed <code>Contravariant</code> to <code>Covariant</code> for intersection negative contributions, and it didn't seem to change any test results.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7150 on 2025-07-23 00:43</div>
            <div class="timeline-body"><p>Eventually we should support also legacy typevars with <code>infer_variance=True</code> kwarg... but I think this method wouldn't really be used for those? Because in that case there is no variance for the <code>TypeVarInstance</code> per se, only for its use in a particular class.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7169 on 2025-07-23 00:50</div>
            <div class="timeline-body"><p>I don't think variance is meaningful for either type alias type parameters or function type parameters, because unlike generic classes, neither of those can have persistent generic instances which participate in subtyping. So I think that we could safely just return invariant here for those two, without doing any further work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6564 on 2025-07-23 00:53</div>
            <div class="timeline-body"><p>This is only possible for synthesized typevars; I think returning Invariant is fine there; if we care about the variance of a synthesized typevar, we'll specify it explicitly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/variance.rs</code>:72 on 2025-07-23 01:16</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    // instead have it evaluate to bivariant. This is a valid choice, as
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/protocol_class.rs</code>:246 on 2025-07-23 01:36</div>
            <div class="timeline-body"><p>I think we might need to switch on <code>member.kind</code> here? Some protocol member kinds (e.g. regular attributes) will be invariant. (I'm not sure if those are currently represented as <code>ProtocolMemberKind::Other</code>, or aren't represented yet; @AlexWaygood would know. It may be this is just a TODO for when further protocol member kinds are added.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:418 on 2025-07-23 01:37</div>
            <div class="timeline-body"><p>Where are we using this? Could we add an accessor method instead?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:40 on 2025-07-23 01:42</div>
            <div class="timeline-body"><p>General note: it's great that we are eliminating all these TODOs, and that we have the mutually-recursive case from Martin, but those two together cover pretty much the bare-bones minimal cases (plus mutual recursion). There's a lot of logic included in this PR that doesn't seem to be covered by any test. Ideally we'd have at least one test for every case of variance inference we have dedicated handling for in the PR. If you don't have time to add those tests, let us know and we can try to find someone on the team to do it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:349 on 2025-07-23 01:49</div>
            <div class="timeline-body"><p>What if <code>generic_type_var</code> is a legacy type var with explicitly specified variance? Should <code>Type::variance_of</code> itself short-circuit and return the explicit variance in this case?</p>
<p>(Possibly related: at some point we'll probably also want to issue a diagnostic if explicitly-specified-variance type vars are used in a position that contradicts their explicit variance; not sure if it will make sense to reuse some of this logic for that diagnostic as well.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2481 on 2025-07-23 01:51</div>
            <div class="timeline-body"><p>It seems like <code>type_var_in_generic_context</code> would be a better name for this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2496 on 2025-07-23 02:00</div>
            <div class="timeline-body"><p>I'm pretty sure once we get all the details right here (including checking qualifiers), we'll no longer be sharing this function with <code>ide_support</code>, we'll need our own version of it dedicated to this purpose.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2499 on 2025-07-23 02:06</div>
            <div class="timeline-body"><p>I think properties are another case where we should visit them in a covariant context, not invariant.</p>
<p>Also <code>Final</code> annotated members can be visited covariantly.</p>
<p>And <code>ClassVar</code> members are a little odd -- they shouldn't include the typevar directly, but they could potentially be a callable type with the typevar in the signature. This can be a TODO maybe.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2518 on 2025-07-23 02:17</div>
            <div class="timeline-body"><p>I don't think we need to consider classmethods here -- they cannot define instance attributes that could use the typevar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6362 on 2025-07-23 02:19</div>
            <div class="timeline-body"><p>I think this question applies to <code>FunctionLiteral</code> above as well (or even more -- since we are pulling member types directly out of the class scope I think it would be pretty difficult for us to even encounter a BoundMethod type). I <em>think</em> it should be safe to ignore the type of <code>self</code>, but I'm not sure if we <em>need</em> to. In most cases it won't be explicitly annotated. Probably fine to leave this as a TODO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:2496 on 2025-07-23 02:22</div>
            <div class="timeline-body"><p>I think we need to ignore <code>__init__</code> and <code>__new__</code> methods here. It looks like currently in this branch, if <code>__init__</code> accepts an argument <code>val: T</code> we take that as making the class contravariant in <code>T</code>, but that's not right. Constructors aren't instance methods. (We should have a test for this.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-23 02:26</div>
            <div class="timeline-body"><p>This is looking good! I think we can leave a lot of stuff as TODOs for follow-up PRs, just want to make sure we clearly record all the TODOs. I would really like to have more thorough tests here.</p>
<p>Regarding the failing test, I suspect what is happening is that we now see that type as bivariant in <code>T</code> (because <code>T</code> is unused), and that means that every specialization of <code>C</code> is equivalent to every other specialization, so the <code>__init__</code> overloads no longer discriminate the instantiation argument, the overloads just all match, resulting in <code>Unknown</code>.</p>
<p>If I change the class like this (to make it covariant in <code>T</code>), the test passes:</p>
<pre><code class="language-py">class C[T]:
    @overload
    def __init__(self: C[str], x: str) -&gt; None: ...
    @overload
    def __init__(self: C[bytes], x: bytes) -&gt; None: ...
    @overload
    def __init__(self: C[int], x: bytes) -&gt; None: ...
    @overload
    def __init__(self, x: int) -&gt; None: ...
    def __init__(self, x: str | bytes | int) -&gt; None:
        self.x = x

    def method(self) -&gt; T:
        return self.x
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-24 00:14</div>
            <div class="timeline-body"><p>I'm kind of shocked that there is zero ecosystem impact reported here? Is PEP 695 uptake still that low? Or maybe because we previously assumed &quot;invariant&quot; for PEP 695 typevars, this doesn't actually result in any new diagnostics? (Also maybe due to some issues pointed out above, e.g. the <code>__init__</code> thing, in practice we are still inferring ~all PEP 695 typevars in the ecosystem as invariant?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7150 on 2025-07-24 01:29</div>
            <div class="timeline-body"><p>In some ways we're well set up for this because we also have a form of variance inferrence that is for a variable <em>in</em> a type, but over there our heuristic for checking if the type variable was defined in the class scope is gonna bite us...perhaps we can instead have an invariant that we never attempt to do inference in a class that's not relevant?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-07-24 01:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7169 on 2025-07-24 05:59</div>
            <div class="timeline-body"><p>Updated to return invariant for function type parameters, but it seems like we probably do want to support inference for type alias parameters</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-07-24 05:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-24 23:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7150 on 2025-07-24 23:20</div>
            <div class="timeline-body"><p>What is that heuristic? Isn't it checking if the typevar is in the class' generic context? I think that might be fine -- we also add legacy typevars mentioned in a class' bases (e.g. where it inherits <code>Generic</code>) into its generic context.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7150 on 2025-07-30 02:23</div>
            <div class="timeline-body"><p>Oh good point, I totally forgot we changed that</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-07-30 02:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7150 on 2025-08-05 17:37</div>
            <div class="timeline-body"><blockquote>
<p>Eventually we should support also legacy typevars with <code>infer_variance=True</code> kwarg... but I think this method wouldn't really be used for those? Because in that case there is no variance for the <code>TypeVarInstance</code> per se, only for its use in a particular class.</p>
</blockquote>
<p>We can now track different uses of a legacy typevar as of #19604. The <code>binding_context</code> of the <code>TypeVarInstance</code> will be <code>None</code> for each reference to the typevar outside of a generic context, and will have different non-<code>None</code> values for each use in a generic context. So while still likely out of scope for this PR, I think we can now also use this method for legacy <code>infer_variance=True</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-08-05 17:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-15 03:51</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-08-20 00:39:59.104775161 +0000
+++ new-output.txt	2025-08-20 00:40:01.565795171 +0000
@@ -580,21 +580,15 @@
 generics_variance_inference.py:19:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `T3@ClassA`
 generics_variance_inference.py:24:5: error[invalid-assignment] Object of type `ClassA[int | float, int, int]` is not assignable to `ClassA[int, int, int]`
 generics_variance_inference.py:25:5: error[invalid-assignment] Object of type `ClassA[int | float, int, int]` is not assignable to `ClassA[int | float, int | float, int]`
-generics_variance_inference.py:26:5: error[invalid-assignment] Object of type `ClassA[int | float, int, int]` is not assignable to `ClassA[int | float, int, int | float]`
 generics_variance_inference.py:28:5: error[invalid-assignment] Object of type `ClassA[int, int | float, int | float]` is not assignable to `ClassA[int, int, int]`
-generics_variance_inference.py:29:5: error[invalid-assignment] Object of type `ClassA[int, int | float, int | float]` is not assignable to `ClassA[int, int, int | float]`
 generics_variance_inference.py:33:42: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `T@ShouldBeCovariant1`
 generics_variance_inference.py:36:27: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Iterator[T@ShouldBeCovariant1]`
-generics_variance_inference.py:40:1: error[invalid-assignment] Object of type `ShouldBeCovariant1[int]` is not assignable to `ShouldBeCovariant1[int | float]`
 generics_variance_inference.py:41:1: error[invalid-assignment] Object of type `ShouldBeCovariant1[int | float]` is not assignable to `ShouldBeCovariant1[int]`
-generics_variance_inference.py:48:1: error[invalid-assignment] Object of type `ShouldBeCovariant2[int]` is not assignable to `ShouldBeCovariant2[int | float]`
 generics_variance_inference.py:49:1: error[invalid-assignment] Object of type `ShouldBeCovariant2[int | float]` is not assignable to `ShouldBeCovariant2[int]`
 generics_variance_inference.py:53:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `ShouldBeCovariant2[T@ShouldBeCovariant3]`
-generics_variance_inference.py:57:1: error[invalid-assignment] Object of type `ShouldBeCovariant3[int]` is not assignable to `ShouldBeCovariant3[int | float]`
 generics_variance_inference.py:58:1: error[invalid-assignment] Object of type `ShouldBeCovariant3[int | float]` is not assignable to `ShouldBeCovariant3[int]`
 generics_variance_inference.py:66:1: error[invalid-assignment] Object of type `ShouldBeCovariant4[int]` is not assignable to `ShouldBeCovariant4[int | float]`
 generics_variance_inference.py:67:1: error[invalid-assignment] Object of type `ShouldBeCovariant4[int | float]` is not assignable to `ShouldBeCovariant4[int]`
-generics_variance_inference.py:79:1: error[invalid-assignment] Object of type `ShouldBeCovariant5[int]` is not assignable to `ShouldBeCovariant5[int | float]`
 generics_variance_inference.py:80:1: error[invalid-assignment] Object of type `ShouldBeCovariant5[int | float]` is not assignable to `ShouldBeCovariant5[int]`
 generics_variance_inference.py:96:1: error[invalid-assignment] Object of type `ShouldBeInvariant1[int]` is not assignable to `ShouldBeInvariant1[int | float]`
 generics_variance_inference.py:97:1: error[invalid-assignment] Object of type `ShouldBeInvariant1[int | float]` is not assignable to `ShouldBeInvariant1[int]`
@@ -607,12 +601,9 @@
 generics_variance_inference.py:130:1: error[invalid-assignment] Object of type `ShouldBeInvariant4[int]` is not assignable to `ShouldBeInvariant4[int | float]`
 generics_variance_inference.py:138:1: error[invalid-assignment] Object of type `ShouldBeInvariant5[int]` is not assignable to `ShouldBeInvariant5[int | float]`
 generics_variance_inference.py:149:1: error[invalid-assignment] Object of type `ShouldBeContravariant1[int]` is not assignable to `ShouldBeContravariant1[int | float]`
-generics_variance_inference.py:150:1: error[invalid-assignment] Object of type `ShouldBeContravariant1[int | float]` is not assignable to `ShouldBeContravariant1[int]`
 generics_variance_inference.py:169:1: error[invalid-assignment] Object of type `ShouldBeInvariant6[int | float]` is not assignable to `ShouldBeInvariant6[int]`
 generics_variance_inference.py:170:1: error[invalid-assignment] Object of type `ShouldBeInvariant6[int]` is not assignable to `ShouldBeInvariant6[int | float]`
 generics_variance_inference.py:181:1: error[invalid-assignment] Object of type `ShouldBeCovariant6[int | float]` is not assignable to `ShouldBeCovariant6[int]`
-generics_variance_inference.py:182:1: error[invalid-assignment] Object of type `ShouldBeCovariant6[int]` is not assignable to `ShouldBeCovariant6[int | float]`
-generics_variance_inference.py:193:1: error[invalid-assignment] Object of type `ShouldBeContravariant2[int | float]` is not assignable to `ShouldBeContravariant2[int]`
 generics_variance_inference.py:194:1: error[invalid-assignment] Object of type `ShouldBeContravariant2[int]` is not assignable to `ShouldBeContravariant2[int | float]`
 literals_interactions.py:15:5: error[index-out-of-bounds] Index 5 is out of bounds for tuple `tuple[int, str, list[bool]]` with length 3
 literals_interactions.py:16:5: error[index-out-of-bounds] Index -5 is out of bounds for tuple `tuple[int, str, list[bool]]` with length 3
@@ -859,5 +850,5 @@
 typeddicts_operations.py:60:1: error[type-assertion-failure] Argument does not have asserted type `str | None`
 typeddicts_type_consistency.py:101:1: error[invalid-assignment] Object of type `Unknown | None` is not assignable to `str`
 typeddicts_usage.py:40:24: error[invalid-type-form] The special form `typing.TypedDict` is not allowed in type expressions. Did you mean to use a concrete TypedDict or `collections.abc.Mapping[str, object]` instead?
-Found 860 diagnostics
+Found 851 diagnostics
 WARN A fatal error occurred while checking some files. Not all project files were analyzed. See the diagnostics list above for details.
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ericmarkmartin on 2025-08-15 04:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @ericmarkmartin on 2025-08-15 04:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @ericmarkmartin on 2025-08-15 04:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> reviewed on 2025-08-15 05:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/classes.md</code>:240 on 2025-08-15 05:15</div>
            <div class="timeline-body"><p>Do you mean bivariant? I'd expect the <code>x: T</code> to actually make it invariant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:397 on 2025-08-15 05:16</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Normal attributes are mutable, and so are invariant (see [inv]).
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:413 on 2025-08-15 05:16</div>
            <div class="timeline-body"><p>... unfinished sentences?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:397 on 2025-08-15 05:17</div>
            <div class="timeline-body"><p>Perhaps pedantically, I don't think you can say that the attribute itself is invariant; rather, their presence leads us to infer that the enclosing generic class in invariant over this TypeVar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:416 on 2025-08-15 05:18</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Immutable attributes can't be written to, and so don't have the same behavior as mutable ones.
</code></pre>
<p>Who said that invariance is a problem?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:512 on 2025-08-15 05:19</div>
            <div class="timeline-body"><p>D doesn't have an <code>x</code> attribute</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:465 on 2025-08-15 05:19</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    def y(self, value: U): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:520 on 2025-08-15 05:19</div>
            <div class="timeline-body"><pre><code class="language-suggestion">This holds likewise for dataclasses with synthesized `__init__`:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3154 on 2025-08-15 05:25</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                        // we want to be robust to new qualifiers
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> on <code>crates/ty_python_semantic/src/types/variance.rs</code>:20 on 2025-08-15 05:27</div>
            <div class="timeline-body"><p>is this a term of art?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/JelleZijlstra">@JelleZijlstra</a> reviewed on 2025-08-15 05:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/classes.md</code>:240 on 2025-08-15 19:55</div>
            <div class="timeline-body"><pre><code class="language-suggestion">We have to add `x: T` to the classes to ensure they're not bivariant in `T` (__new__ and __init__
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:371 on 2025-08-15 21:04</div>
            <div class="timeline-body"><blockquote>
<p><code>X</code> has one bivariant occurrence</p>
</blockquote>
<p>It's not clear to me where this bivariant occurrence is? Is it the occurrence in the return type of <code>f</code>, because we are currently assuming that <code>D</code> is bivariant in <code>Y</code>? If so, that seems like the key point here, but it isn't really mentioned at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:375 on 2025-08-15 21:05</div>
            <div class="timeline-body"><p>I'm not sure this description currently captures the cyclic nature of this resolution? It's presented as if we can independently conclude that <code>X</code> is contravariant in <code>C</code>, and then based on that, conclude that <code>Y</code> is contravariant in <code>D</code>. But that entirely glosses over the interesting part (the cycle), and the fact that we at some point have to make a co-inductive assumption when we hit a cycle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:362 on 2025-08-15 21:08</div>
            <div class="timeline-body"><p>I think that the more common usage would be to say that &quot;<code>C</code> is contravariant in <code>X</code>&quot; rather than the other way around.</p>
<p>Also, we shouldn't ignore <code>Y</code> here.</p>
<pre><code class="language-suggestion">`C` is contravariant in `X`, and `D` in `Y`:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:397 on 2025-08-15 21:14</div>
            <div class="timeline-body"><p>I think there might be a sense in which you could talk about the variance of an attribute itself, if you are talking about how the type of the attribute is allowed to vary in subclasses (if it has a concrete type, not a TypeVar)? But I agree that here we could use more precise language:</p>
<pre><code class="language-suggestion">Normal attributes are mutable, and so make the enclosing class invariant in this typevar (see [inv]).
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:416 on 2025-08-15 21:17</div>
            <div class="timeline-body"><p>I'd probably go even a bit more explicit here</p>
<pre><code class="language-suggestion">Immutable attributes can't be written to, and thus constrain the typevar to covariance, not
invariance:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:448 on 2025-08-15 21:29</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Properties constrain to covariance if they are get-only and invariant if they are get-set:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:512 on 2025-08-15 21:31</div>
            <div class="timeline-body"><p>I'm having trouble understanding what this sentence is trying to say; where did <code>int</code> come from?</p>
<p>Not sure this sentence is even needed, we could just join the two code snippets.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:603 on 2025-08-15 21:37</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Implicit attributes work like normal ones:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:614 on 2025-08-15 21:42</div>
            <div class="timeline-body"><p>A dataclass with no fields typed as <code>T</code> won't include <code>T</code> anywhere in the <code>__init__</code> signature, so I'm not sure what this example actually demonstrates.</p>
<p>Really, the example above with a frozen dataclass already demonstrates this better: that one will include <code>T</code> in the synthesized <code>__init__</code>, and if we considered that <code>__init__</code> then we'd still infer it as invariant, even though the attribute is read-only.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:838 on 2025-08-15 21:51</div>
            <div class="timeline-body"><p>I've asked Martin and can add the link here if/when he replies, but I don't think this is a blocker</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:752 on 2025-08-15 21:52</div>
            <div class="timeline-body"><p>Not clear to me why we need this example here (in addition to the explicit subtype/assignable checks) but not in any of the above cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/variance.rs</code>:20 on 2025-08-15 22:00</div>
            <div class="timeline-body"><p>Yes: https://en.wikipedia.org/wiki/Infimum_and_supremum</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/variance.rs</code>:97 on 2025-08-15 22:05</div>
            <div class="timeline-body"><p>I might be missing something here, but how is this the infimum? Isn't it the supremum of all variances we've seen so far in this iterator?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6998 on 2025-08-15 22:08</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// The explicitly specified variance of the TypeVar
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3074 on 2025-08-15 22:25</div>
            <div class="timeline-body"><p>I think this won't find subclasses of classed defined with <code>NamedTuple</code> -- we'll probably want a better way to identify <code>NamedTuple</code> fields than this. (But this could be a follow-up TODO.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:349 on 2025-08-15 22:28</div>
            <div class="timeline-body"><p>Ignoring the second part for now (I just filed https://github.com/astral-sh/ty/issues/1017 to track that for later), it still seems to me there might be something we could do differently here if <code>generic_type_var</code> has explicit variance? But it might be just an optimization to do less work in that case, and it might only make a difference if the explicit-variance legacy typevar is being used in a way that doesn't actually match its explicit variance. So this can probably just be a TODO for later follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3114 on 2025-08-15 22:29</div>
            <div class="timeline-body"><p>Pretty sure we do not, we only need to consider symbols</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-15 22:32</div>
            <div class="timeline-body"><p>Didn't quite get the whole way through reviewing this, but to me it's looking pretty much land-ready so far with some minor adjustments. I would probably just make the adjustments myself and land it now, but I'm out of time for today. Will try to get back to it as soon as I can; would love to get it landed before it accumulates more conflicts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 22:33</div>
            <div class="timeline-body"><p>Looks like there are also a couple clippy / <code>cargo doc</code> issues we need to address, and then we also need to review the conformance-suite diff for correctness.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3145 on 2025-08-16 15:12</div>
            <div class="timeline-body"><p>No tests fail if I remove this line. I don't think there is actually any way for the signatures of synthesized ordering methods, <code>__eq__</code>, <code>__repr__</code>, or <code>__hash__</code> to ever contain a typevar, so I don't think we can write a test that would require this line. Given that, I'm inclined to remove this extra logic and replace it with a comment that dataclasses may have some additional synthesized methods which we don't consider since they won't affect variance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 15:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-16 15:27</div>
            <div class="timeline-body"><p>Finished my code review, and I reviewed the conformance suite impact. Mostly the result is good (we stop emitting wrong diagnostics where previously we assumed invariance and now we infer correct variance.)</p>
<p>On <a href="https://github.com/python/typing/blob/main/conformance/tests/generics_variance_inference.py#L169-L194">these lines</a>, which are testing variance in derived classes, we now miss all the errors; it seems like we are inferring all these as bivariant now somehow? Will explore this a bit more.</p>
<p>ETA: Oh, I think this is the issue I mentioned inline in my code review, where when we encounter another generic class while inferring variance, we are ignoring explicit variance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3074 on 2025-08-16 16:36</div>
            <div class="timeline-body"><p>I realized that we don't <em>want</em> to match <code>NamedTuple</code> subclasses here, because we are only considering own-attributes; we do variance inference on base classes separately. Only own-attributes of actual named tuples are immutable; attributes tacked on in a subclass are mutable. Adding some tests for these cases.</p>
<p>But I also realized there is an easier way to do this, using <code>CodeGeneratorKind::matches</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 16:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 16:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3145 on 2025-08-16 16:59</div>
            <div class="timeline-body"><p>I realized in making this change that there is (in newer Python versions) the <code>__replace__</code> method, which breaks this covariance, as discussed in https://discuss.python.org/t/make-replace-stop-interfering-with-variance-inference/96092/16</p>
<p>Added some tests and handling for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 17:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 17:01</div>
            <div class="timeline-body"><p>it surprises me that we have to special-case NamedTuples here. Our NamedTuple handling is such that if you access an attribute on a NamedTuple class object using <code>Type::member()</code>, you'll get a <code>Type::PropertyInstance()</code> back that has no setter. In general we should surely consider any attribute on any class to be covariant if <code>Type::member()</code> on the class object returns a <code>Type::PropertyInstance()</code> with no setter. So this indicates to me that perhaps the generalised logic for non-namedtuples maybe isn't generalised enough?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 17:02</div>
            <div class="timeline-body"><p>I'd guess this is because the code is using the low-level <code>all_end_of_scope_symbol_declarations()</code> and <code>all_end_of_scope_symbol_bindings()</code> APIs rather than the high-level <code>Type::member()</code> API. The low-level APIs will just look directly at the annotation on the <code>NamedTuple</code> class, leading us to infer a mutable attribute annotation; the high-level <code>Type::member()</code> API will return a <code>Type::PropertyInstance</code> type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 17:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:349 on 2025-08-16 17:06</div>
            <div class="timeline-body"><p>I realized (thanks to the conformance test suite) that this is important for correctness, because explicit (legacy) variance can also enforce a stricter variance than we would otherwise infer here. Adding some tests and looking at fixing this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 17:17</div>
            <div class="timeline-body"><p>The logic here doesn't access members (other than implicit instance members) individually using the full individual member lookup methods. To do that, we'd first have to query names of all &quot;own members&quot; using the use-def map (and throwing away qualifier information), then re-lookup those same attributes one by one (effectively re-doing the initial use-def map queries).</p>
<p>We could choose to do this, if we judge that the gain in simplicity / robustness outweighs the loss in efficiency. But it's not clear to me that that's the case. The logic here for namedtuples and dataclasses is fairly simple, and I think it's correct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 17:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 17:33</div>
            <div class="timeline-body"><p>My feeling is that using the high-level API is likely to be much more robust here in the long term. We already synthesize attributes on a variety of types -- as well as dataclasses and namedtuples, we also synthesize methods on other tuple types (currently, <code>__new__</code>, <code>__bool__</code>, <code>__len__</code> and <code>__getitem__</code>) and <code>TypedDict</code> types. (<code>TypedDict</code>s are currently always mutable IIRC, but we'd need to remember to update this logic in the future if something like the <code>TypedMapping</code> that's previously been proposed was ever accepted.) In the future, I could easily see us synthesizing more methods for <code>attrs</code> classes and Django models.</p>
<p>I don't want to block this PR if you feel strongly, but this method is also cached, so I would lean towards doing the more robust thing here unless and until we see this method show up on profiles as a hot routine that's slowing us down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 17:34</div>
            <div class="timeline-body"><p>for full correctness, this should probably also check for function-like <code>CallableType</code>s</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3215 on 2025-08-16 17:35</div>
            <div class="timeline-body"><p>shouldn't this also check that the <code>setter</code> of the <code>PropertyInstanceType</code> is <code>None</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-16 17:35</div>
            <div class="timeline-body"><p>With the fix I just pushed, the conformance suite changes all look correct now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 17:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 17:42</div>
            <div class="timeline-body"><p>If we want this method to be robust against new synthesized attributes/methods and not require special-casing types that provide them, it will take more than just using the high-level member-lookup API that we already have; it will require new &quot;get me all member names&quot; API that doesn't currently exist, that uses a shared source of truth for what synthesized members can exist on a given type. I think such API would be very useful (it could also fix the fact that I think currently our autocomplete doesn't consider synthesized members), but it's a non-trivial project. IMO this PR has already been sitting long enough and is already complex enough; I don't want it to be blocked on that project as well. And I don't think there is enough benefit to justify going only halfway, using the high-level member-lookup API when we'd still have to special-case dataclasses and namedtuples in order to even consider what synthesized methods might exist.</p>
<p>I've already added a TODO comment for this improvement and can open an issue for it as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3215 on 2025-08-16 17:46</div>
            <div class="timeline-body"><p>Yes, this is on my list to look into -- there are tests that show this is working, but I'm not sure why...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 17:47</div>
            <div class="timeline-body"><p>I don't think that it should? A function literal type represents an actual method -- we treat those as immutable, but only as a side effect of the fact that function literals are singleton types, so there's nothing else we'd ever allow you to assign to a declared function literal. Any other callable-type attribute is mutable and thus I think shouldn't be treated as covariant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3215 on 2025-08-16 17:50</div>
            <div class="timeline-body"><p>Oh never mind, I know why. Effectively this line is just saying &quot;we don't consider that the property instance itself could be replaced on an instance&quot; -- this is equivalent to the case for function literals above, we're basically just saying &quot;properties, like methods, are implicitly <code>ClassVar</code>&quot;.</p>
<p>But we still visit the property instance type itself in variance inference below, so we'll still observe the signatures of its getter and setter methods (just like we'll observe the signature of a method), and we'll see that the setter (if it exists) has the type variable in contravariant position.</p>
<p>I can add some comments to clarify what's going on here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-16 17:54</div>
            <div class="timeline-body"><p>Ok, I pushed some things here, but didn't address all the comments yet. Out of time for now. I don't have any more changes locally, so @ericmarkmartin if you have time/inclination, feel free to push changes addressing additional comments! I'll come back to this next week (but I'll comment before I make any further changes.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 17:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 17:57</div>
            <div class="timeline-body"><p>When I come back to this next week, I'll re-consider the &quot;going halfway&quot; option for this PR.</p>
<p>This thread also made me realize that we might need to add explicit consideration of the other synthesized <code>NamedTuple</code> methods that come from <code>NamedTupleFallback</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 18:01</div>
            <div class="timeline-body"><p>So we're saying that this class is covariant:</p>
<pre><code class="language-py">class Foo[T]:
    def __or__(self, other: Foo[T]) -&gt; Foo[T]: ...
    __ror__ = __or__
</code></pre>
<p>But this one is not?</p>
<pre><code class="language-py">from typing import Callable

class Foo[T]:
    __or__: Callable[[Foo[T], Foo[T]], Foo[T]] = lambda self, other: self
</code></pre>
<p>FWIW for the purposes of protocol interfaces, we currently treat any function-like callable that is bound on the class as a method member, just like function-literal types that are bound on the class</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 18:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 18:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 18:03</div>
            <div class="timeline-body"><p>I think what we are kind of missing here is a clear mental model (as well as clear documentation, and ideally a single source of truth) for which &quot;declared&quot; class members (that aren't explicitly declared with <code>ClassVar</code>) we implicitly treat as class-only variables (which also means we can treat them covariantly here.)</p>
<p>The current answer here is &quot;methods and properties&quot;, which I think is roughly reasonable, but it would be good if this were more explicit and centralized.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 18:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 18:03</div>
            <div class="timeline-body"><blockquote>
<p>it will require new &quot;get me all member names&quot; API that doesn't currently exist, that uses a shared source of truth for what synthesized members can exist on a given type</p>
</blockquote>
<p>I thought we <em>did</em> already have that, and it was called <code>types::ide_support::all_members()</code> 😄</p>
<p>If that routine doesn't currently include certain attributes/methods synthesized on NamedTuples or dataclasses, that seems like a pre-existing bug in that routine</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 18:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 18:12</div>
            <div class="timeline-body"><blockquote>
<p>But this one is not?</p>
</blockquote>
<p>We would currently allow <code>__or__</code> to be mutated on an instance of the second <code>Foo</code>, as long as you assign a compatible callable type. So it shouldn't be covariant, unless we establish some principle by which that annotated <code>__or__</code> can be considered class-only, despite not being annotated with <code>ClassVar</code>. I'm not sure &quot;callable types are always implicitly <code>ClassVar</code>&quot; is the right rule here.</p>
<p>If <code>__or__</code> were explicitly annotated with <code>ClassVar</code>, then that second <code>Foo</code> would be covariant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 18:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 18:14</div>
            <div class="timeline-body"><p>Also, the first <code>Foo</code> there is not covariant either, because the type of <code>__ror__</code> is <code>Unknown | FunctionLiteral(...)</code> (it has no declared type), and we don't special-case that union here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 18:23</div>
            <div class="timeline-body"><p><code>ide_support::all_members</code> isn't usable here because it includes superclass members also, here we only want to include own-members.</p>
<p>Definitely possible that the right answer here involves increased code sharing between the class-types branch of <code>all_members</code> and this code, but it's definitely more complicated than &quot;just use <code>all_members</code>&quot;. I still think that's a big enough project that it would be better to make it a TODO and separate PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 18:23</div>
            <div class="timeline-body"><p>Thank you for the corrections. Something like this might be more interesting as a talking point:</p>
<pre><code class="language-py">from typing import Final

class Foo[T]:
    def __or__(self, other: Foo[T]) -&gt; Foo[T]: ...
    __ror__: Final = __or__
</code></pre>
<p>Vs</p>
<pre><code class="language-py">from typing import Callable, ClassVar

class Foo[T]:
    __or__: ClassVar[Callable[[Foo[T], Foo[T]], Foo[T]]] = lambda self, other: self
</code></pre>
<p>Though that second one might not be legal, because there are rules against using type variables inside <code>ClassVar</code>s? Can't remember the exact details.</p>
<p>Anyway, my point is that it seems somewhat arbitrary to distinguish between functions that are defined using <code>def</code>, and other callables that we also know are instances of <code>FunctionType</code> (they wouldn't be marked as function-like callables if they weren't), also have method-binding behaviour when accessed on instances, and are also bound on the class object itself. At runtime, the two are identical in their behaviour if you're defining a method on the class.</p>
<p>I agree that we don't have a particularly consistent mental model about this right now, though, and it's hardly high-priority. I'm definitely fine with deferring this discussion to a later date and landing the PR with this logic as-is!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-16 18:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3157 on 2025-08-16 18:24</div>
            <div class="timeline-body"><p>Fair enough.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-16 18:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:3212 on 2025-08-16 18:27</div>
            <div class="timeline-body"><p>Just a note that I think the rule against using type variables inside a ClassVar should not apply to typevars used in the signature of a callable type. If the spec doesn't have that carve-out, it probably should.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-08-16 21:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/src/types/variance.rs</code>:97 on 2025-08-16 21:28</div>
            <div class="timeline-body"><p>Ope--I either forgot to change this after I flipped the lattice (initially i had it upside-down) or I'm just cursed to never remember join vs meet correctly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> reviewed on 2025-08-17 02:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/pep695/variance.md</code>:512 on 2025-08-17 02:47</div>
            <div class="timeline-body"><p>I think this was me trying to communicate a point you made in discord---we want to access members without going through the descriptor protocol.</p>
<p>The int thing is a goof on my part. I was trying to come up with an example where the return type of the getter would be deceiving versus that of the descriptor variance-wise, and was trying to imagine a descriptor whose getter would return <code>int</code> even though it stored a <code>T</code>, but I couldn't really do it, and never cleaned this up--sorry!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ericmarkmartin">@ericmarkmartin</a> on 2025-08-17 02:57</div>
            <div class="timeline-body"><p>I think I've addressed the last few comments that you didn't resolve yourself, thanks!</p>
<p>I tried to push out the code quickly the other night because I'm away for a little bit now and didn't want to delay the PR more, and I appreciate the thorough review. Fortunately the WiFi up here is actually quite good 😃.</p>
<p>I'm noticing that with the bound typevars, you write <code>typevar</code> and not <code>type_var</code>. Would you like me to update my code likewise?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-19 01:32</div>
            <div class="timeline-body"><blockquote>
<p>I'm noticing that with the bound typevars, you write <code>typevar</code> and not <code>type_var</code>. Would you like me to update my code likewise?</p>
</blockquote>
<p>I don't have strong feelings between the two, but consistency is good. Maybe a mild preference for avoiding unnecessary underscores.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-19 22:43</div>
            <div class="timeline-body"><p>I'm about to rebase this and make some more updates to it, hopefully resulting in a merge. (Just commenting in advance so as to avoid simultaneous duplication of work.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-08-19 23:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6448 on 2025-08-19 23:22</div>
            <div class="timeline-body"><p>Just scanning this PR for unresolved comments and ran across this. I agree this would be conceptually neat; I also agree that I struggle to see practical benefit. Will leave it as an enum for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-08-20 00:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-08-20 00:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-20 00:54</div>
            <div class="timeline-body"><p>Merged! Thank you @ericmarkmartin for all your excellent work here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-09-01 02:46</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:46:47 UTC
    </footer>
</body>
</html>
