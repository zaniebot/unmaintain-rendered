<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Track &quot;delayed&quot; annotations in the semantic model - astral-sh/ruff #5070</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Track &quot;delayed&quot; annotations in the semantic model</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/5070">#5070</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-06-14 01:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body">Summary
<p>This PR tackles a corner case that we&#x27;ll need to support local symbol renaming. It relates to a nuance in how we want handle annotations (i.e., <code>AnnAssign</code> statements with no value, like <code>x: int</code> in a function body).</p>
<p>When we see a statement like:</p>
<pre><code>x: int
</code></pre>
<p>We create a <code>BindingKind::Annotation</code> for <code>x</code>. This is a special <code>BindingKind</code> that the resolver isn&#x27;t allowed to return. For example, given:</p>
<pre><code>x: int
print(x)
</code></pre>
<p>The second line will yield an <code>undefined-name</code> error.</p>
<p>So why does this <code>BindingKind</code> exist at all? In Pyflakes, to support the <code>unused-annotation</code> lint:</p>
<pre><code>def f():
    x: int  # unused-annotation
</code></pre>
<p>If we don&#x27;t track <code>BindingKind::Annotation</code>, we can&#x27;t lint for unused variables that are only &quot;defined&quot; via annotations.</p>
<p>There are a few other wrinkles to <code>BindingKind::Annotation</code>. One is that, if a binding already exists in the scope, we actually just discard the <code>BindingKind</code>. So in this case:</p>
<pre><code>x = 1
x: int
</code></pre>
<p>When we go to create the <code>BindingKind::Annotation</code> for the second statement, we notice that (1) we&#x27;re creating an annotation but (2) the scope already has binding for the name -- so we just drop the binding on the floor. This has the nice property that annotations aren&#x27;t considered to &quot;shadow&quot; another binding, which is important in a bunch of places (e.g., if we have <code>import os; os: int</code>, we still consider <code>os</code> to be an import, as we should). But it also means that these &quot;delayed&quot; annotations are one of the few remaining references that we don&#x27;t track anywhere in the semantic model.</p>
<p>This PR adds explicit support for these via a new <code>delayed_annotations</code> attribute on the semantic model. These should be extremely rare, but we do need to track them if we want to support local symbol renaming.</p>
This isn&#x27;t the right way to model this
<p>This isn&#x27;t the right way to model this.</p>
<p>Here&#x27;s an alternative:</p>
<ul>
<li>Remove <code>BindingKind::Annotation</code>, and treat annotations as their own, separate concept.</li>
<li>Instead of storing a map from name to <code>BindingId</code> on each <code>Scope</code>, store a map from name to... <code>SymbolId</code>.</li>
<li>Introduce a <code>Symbol</code> abstraction, where a symbol can point to a current binding, and a list of annotations, like:</li>
</ul>
<pre><code>pub struct Symbol {
  binding: Option&lt;BindingId&gt;,
  annotations: Vec&lt;AnnotationId&gt;
}
</code></pre>
<p>If we did this, we could appropriately model the semantics described above. When we go to resolve a binding, we ignore annotations (always). When we try to find unused variables, we look through the list of symbols, and have sufficient information to discriminate between annotations and bound variables. Etc.</p>
<p>The main downside of this <code>Symbol</code>-based approach is that it&#x27;s going to take a lot more work to implement, and it&#x27;ll be less performant (we&#x27;ll be storing more data per symbol, and our binding lookups will have an added layer of indirection).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-06-14 01:25</div>
            <div class="timeline-body">PR Check Results
Ecosystem
<p>✅ ecosystem check detected no changes.</p>
Benchmark
Linux
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      6.8±0.01ms     6.0 MB/sec    1.01      6.8±0.03ms     5.9 MB/sec
formatter/numpy/ctypeslib.py               1.00   1383.9±4.22µs    12.0 MB/sec    1.02   1405.5±1.51µs    11.8 MB/sec
formatter/numpy/globals.py                 1.00    136.4±0.40µs    21.6 MB/sec    1.02    138.5±8.13µs    21.3 MB/sec
formatter/pydantic/types.py                1.00      2.8±0.02ms     9.3 MB/sec    1.01      2.8±0.01ms     9.2 MB/sec
linter/all-rules/large/dataset.py          1.01     14.5±0.03ms     2.8 MB/sec    1.00     14.4±0.09ms     2.8 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.6±0.01ms     4.7 MB/sec    1.00      3.6±0.00ms     4.6 MB/sec
linter/all-rules/numpy/globals.py          1.00    370.7±1.47µs     8.0 MB/sec    1.00    369.7±1.47µs     8.0 MB/sec
linter/all-rules/pydantic/types.py         1.01      6.2±0.05ms     4.1 MB/sec    1.00      6.2±0.04ms     4.1 MB/sec
linter/default-rules/large/dataset.py      1.01      7.2±0.01ms     5.7 MB/sec    1.00      7.1±0.03ms     5.7 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.01   1528.6±6.45µs    10.9 MB/sec    1.00   1511.5±3.67µs    11.0 MB/sec
linter/default-rules/numpy/globals.py      1.00    163.3±0.47µs    18.1 MB/sec    1.00    162.5±1.43µs    18.2 MB/sec
linter/default-rules/pydantic/types.py     1.01      3.3±0.00ms     7.7 MB/sec    1.00      3.3±0.01ms     7.8 MB/sec
</code></pre>
Windows
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      7.8±0.05ms     5.2 MB/sec    1.01      7.9±0.04ms     5.2 MB/sec
formatter/numpy/ctypeslib.py               1.00  1592.4±18.14µs    10.5 MB/sec    1.01  1605.4±29.36µs    10.4 MB/sec
formatter/numpy/globals.py                 1.00    155.6±2.02µs    19.0 MB/sec    1.00    156.2±2.84µs    18.9 MB/sec
formatter/pydantic/types.py                1.00      3.2±0.03ms     7.9 MB/sec    1.00      3.2±0.03ms     7.9 MB/sec
linter/all-rules/large/dataset.py          1.00     16.7±0.16ms     2.4 MB/sec    1.01     16.9±0.16ms     2.4 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.3±0.04ms     3.9 MB/sec    1.01      4.3±0.05ms     3.8 MB/sec
linter/all-rules/numpy/globals.py          1.01    441.3±9.61µs     6.7 MB/sec    1.00    436.8±5.47µs     6.8 MB/sec
linter/all-rules/pydantic/types.py         1.01      7.4±0.12ms     3.5 MB/sec    1.00      7.3±0.06ms     3.5 MB/sec
linter/default-rules/large/dataset.py      1.00      8.5±0.08ms     4.8 MB/sec    1.00      8.5±0.16ms     4.8 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1775.0±22.64µs     9.4 MB/sec    1.00  1775.2±23.26µs     9.4 MB/sec
linter/default-rules/numpy/globals.py      1.00    189.7±1.73µs    15.6 MB/sec    1.00    190.4±5.23µs    15.5 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.8±0.03ms     6.6 MB/sec    1.00      3.9±0.04ms     6.6 MB/sec
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-14 17:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-14 17:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-06-14 17:54</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:54:28 UTC
    </footer>
</body>
</html>
