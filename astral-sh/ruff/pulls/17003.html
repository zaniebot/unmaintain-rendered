<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add autofix for PYI051 - astral-sh/ruff #17003</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add autofix for PYI051</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17003">#17003</a>
        opened by <a href="https://github.com/kiran-4444">@kiran-4444</a>
        on 2025-03-26 20:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a></div>
            <div class="timeline-body"><p>This commit closes <a href="https://github.com/astral-sh/ruff/issues/14185">astral-sh/ruff#14185</a>.</p>
<pre><code>from __future__ import annotations

from typing import Literal

x: Literal[&quot;A&quot;, &quot;B&quot;, b&quot;c&quot;] | Literal[&quot;D&quot;, b&quot;f&quot;] | str

</code></pre>
<p>will be refactored to:</p>
<pre><code>from __future__ import annotations

from typing import Literal

x: Literal[b&quot;c&quot;] | Literal[b&quot;f&quot;] | str

</code></pre>
<p>It does not handle the case where a  <code>Literal</code> expr completely contains subtypes (e.g. <code>Literal[&quot;a&quot;, &quot;b&quot;] | str</code>). I need help implementing this.</p>
Summary


Test Plan


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-03-26 20:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fixes</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-26 21:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-03-27 12:11</div>
            <div class="timeline-body"><p>Can you tell us a bit more about the status of this PR? Why is it WIP? What&#x27;s the kind of feedback you&#x27;re looking for?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-03-27 12:18</div>
            <div class="timeline-body"><blockquote>
<p>Can you tell us a bit more about the status of this PR? Why is it WIP? What&#x27;s the kind of feedback you&#x27;re looking for?</p>
</blockquote>
<p>Currently, I‚Äôm replacing the <code>Literal</code> type elements with a non-subtype elements. This method fails when <code>Literal</code> contains only subtype elements. For example, it changes <code>Literal[‚Äúa‚Äù, ‚Äúb‚Äù] | str</code> to <code>| str</code>.</p>
<p>Also, it doesn‚Äôt handle multiple <code>Literal</code> elements. Like <code>Literal[‚Äúa‚Äù, ‚Äúb‚Äù] | Literal[‚Äúc‚Äù] | str</code></p>
<p>I‚Äôll work on these tonight.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-03-27 12:19</div>
            <div class="timeline-body"><p>Thanks for explaining. I&#x27;ll put this PR back into draft because I understand that you aren&#x27;t looking for feedback or help.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-03-27 12:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-03-30 18:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;wip: Add autofix for PYI051&quot; to &quot;Add autofix for PYI051&quot; by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-03-30 18:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-03-30 18:53</div>
            <div class="timeline-body"><p>This PR handles all the cases except when <code>Literal</code> expr contains wholely subtypes. It raises an error with the current implementation:</p>
<pre><code>from __future__ import annotations

from typing import Literal

x: Literal[&quot;A&quot;, &quot;B&quot;, b&quot;c&quot;] | Literal[&quot;D&quot;, b&quot;f&quot;] | Literal[&quot;G&quot;] | str

</code></pre>
<pre><code>‚ûú  ruff git:(feature/PYI051-autofix) ‚úó cargo run -p ruff check --fix --preview --select=PYI051 --isolated test.py --unsafe-fixes --no-cache
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.13s
     Running `target/debug/ruff check --fix --preview --select=PYI051 --isolated test.py --unsafe-fixes --no-cache`
error: Fix introduced a syntax error in `test.py` with rule codes PYI051: Expected an expression at byte range 100..101
---
from __future__ import annotations

from typing import Literal

x: Literal[b&quot;c&quot;] | Literal[b&quot;f&quot;] |  | str


---
</code></pre>
<p>Can someone help me with this? I&#x27;ve written a <code>range_deletion</code>, but the result is not correct. Is there a function in <code>Edit</code> that&#x27;ll delete the expr and produce a semantically correct expr? I don&#x27;t think there&#x27;s anything like that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-30 20:28</div>
            <div class="timeline-body"><p>I haven&#x27;t looked super closely at the code to know if this is a good idea, but from the description, it might be best to replace the entire annotation instead of trying to delete part of it. Then you can control the contents exactly. I don&#x27;t think there&#x27;s an API to handle this kind of thing automatically.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-03-31 18:43</div>
            <div class="timeline-body"><p>This changes:</p>
<pre><code>from __future__ import annotations

import typing
from typing import Literal, TypeAlias, Union

x: Literal[&quot;A&quot;, &quot;B&quot;, b&quot;c&quot;] | str | Literal[&quot;D&quot;, b&quot;f&quot;] | Literal[&quot;E&quot;]


A: str | Literal[&quot;foo&quot;]
B: TypeAlias = typing.Union[Literal[b&quot;bar&quot;, b&quot;foo&quot;], bytes, str]
C: TypeAlias = typing.Union[Literal[5], int, typing.Union[Literal[&quot;foo&quot;], str]]
D: TypeAlias = typing.Union[Literal[b&quot;str_bytes&quot;, 42], bytes, int]
E: TypeAlias = typing.Union[typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], str]]]]
F: TypeAlias = typing.Union[str, typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], int]]]]
G: typing.Union[str, typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], int]]]]

def func(x: complex | Literal[1J], y: Union[Literal[3.14], float]): ...

# OK
A: Literal[&quot;foo&quot;]
B: TypeAlias = Literal[b&quot;bar&quot;, b&quot;foo&quot;]
C: TypeAlias = typing.Union[Literal[5], Literal[&quot;foo&quot;]]
D: TypeAlias = Literal[b&quot;str_bytes&quot;, 42]

def func(x: Literal[1J], y: Literal[3.14]): ...
</code></pre>
<p>to:</p>
<pre><code>from __future__ import annotations

import typing
from typing import Literal, TypeAlias, Union

x: Union[Literal[b&quot;c&quot;], str, Literal[b&quot;f&quot;]]


A: Union[str]
B: TypeAlias = Union[bytes, str]
C: TypeAlias = Union[int, str]
D: TypeAlias = Union[bytes, int]
E: TypeAlias = Union[str]
F: TypeAlias = Union[str, int]
G: Union[str, int]

def func(x: Union[complex], y: Union[float]): ...

# OK
A: Literal[&quot;foo&quot;]
B: TypeAlias = Literal[b&quot;bar&quot;, b&quot;foo&quot;]
C: TypeAlias = typing.Union[Literal[5], Literal[&quot;foo&quot;]]
D: TypeAlias = Literal[b&quot;str_bytes&quot;, 42]

def func(x: Literal[1J], y: Literal[3.14]): ...

</code></pre>
<p>Hey @ntBre I&#x27;ve implemented the idea that you gave. There are few things to point out here:</p>
<ol>
<li>I don&#x27;t know how to handle multiple fixes, so I&#x27;m sending same <code>fix</code> for all the <code>diagnostics</code>. Not sure if this is the right way, would be happy to hear your thoughts.</li>
<li>I&#x27;m not handling the <code>get_or_import_symbol</code> properly here. Can you explain why that is used for? I understand that is used for importing <code>Union</code> from <code>typing</code> for <code>Python&lt;3.10</code>. What I don&#x27;t understand is that where should that import be? There&#x27;s a <code>at</code> argument to that function, what should that be?</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-03-31 21:04</div>
            <div class="timeline-body"><blockquote>
<ul>
<li>I don&#x27;t know how to handle multiple fixes, so I&#x27;m sending same <code>fix</code> for all the <code>diagnostics</code>. Not sure if this is the right way, would be happy to hear your thoughts.</li>
</ul>
</blockquote>
<p>This doesn&#x27;t sound right, but I&#x27;m not sure I&#x27;m following exactly. Could you include an example of the current and desired output? It might also help to go ahead and include the snapshot changes in the PR. Then you could link to the changes in the relevant cases.</p>
<p>I&#x27;m guessing one of the examples in your comment is related, but I&#x27;m not sure which one(s) :sweat_smile:</p>
<blockquote>
<ul>
<li>I&#x27;m not handling the <code>get_or_import_symbol</code> properly here. Can you explain why that is used for? I understand that is used for importing <code>Union</code> from <code>typing</code> for <code>Python&lt;3.10</code>. What I don&#x27;t understand is that where should that import be? There&#x27;s a <code>at</code> argument to that function, what should that be?</li>
</ul>
</blockquote>
<p>I searched for other uses of <code>get_or_import_symbol</code>, and it looks like you&#x27;re using it correctly. If you follow some of the calls in the function, you&#x27;ll end up in <a href="https://github.com/astral-sh/ruff/blob/a1535fbdbd660e9010982019cf045199cf4ac62a/crates/ruff_linter/src/importer/mod.rs#L304"><code>find_symbol</code></a>, which uses <code>at</code> to see if the import is before or after the <code>at</code> position. So I think you just want to pass it the start of the expression you need the import for, as you&#x27;re doing. I believe the function will take care of putting the import in the right place, if it&#x27;s needed. We can add a test case where the import is needed but not present to double check.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-01 05:31</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>‚úÖ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>‚ÑπÔ∏è ecosystem check <strong>detected linter changes</strong>. (+0 -0 violations, +24 -0 fixes in 1 projects; 54 projects unchanged)</p>
<a href="https://github.com/python/typeshed">python/typeshed</a> (+0 -0 violations, +24 -0 fixes)
<p>
<pre>ruff check --no-cache --exit-zero --ignore RUF9 --no-fix --output-format concise --preview --select E,F,FA,I,PYI,RUF,UP,W</pre>
</p>
<p>

<pre>
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:35:</a> PYI051 [*] `Literal[&quot;single&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:35:</a> PYI051 `Literal[&quot;single&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:45:</a> PYI051 [*] `Literal[&quot;browse&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:45:</a> PYI051 `Literal[&quot;browse&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:55:</a> PYI051 [*] `Literal[&quot;multiple&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:55:</a> PYI051 `Literal[&quot;multiple&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:67:</a> PYI051 [*] `Literal[&quot;extended&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2398">stdlib/tkinter/__init__.pyi:2398:67:</a> PYI051 `Literal[&quot;extended&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:35:</a> PYI051 [*] `Literal[&quot;single&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:35:</a> PYI051 `Literal[&quot;single&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:45:</a> PYI051 [*] `Literal[&quot;browse&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:45:</a> PYI051 `Literal[&quot;browse&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:55:</a> PYI051 [*] `Literal[&quot;multiple&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:55:</a> PYI051 `Literal[&quot;multiple&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:67:</a> PYI051 [*] `Literal[&quot;extended&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stdlib/tkinter/__init__.pyi#L2433">stdlib/tkinter/__init__.pyi:2433:67:</a> PYI051 `Literal[&quot;extended&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/docutils/docutils/parsers/rst/directives/__init__.pyi#L33">stubs/docutils/docutils/parsers/rst/directives/__init__.pyi:33:66:</a> PYI051 [*] `Literal[&quot;tab&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/docutils/docutils/parsers/rst/directives/__init__.pyi#L33">stubs/docutils/docutils/parsers/rst/directives/__init__.pyi:33:66:</a> PYI051 `Literal[&quot;tab&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/docutils/docutils/parsers/rst/directives/__init__.pyi#L33">stubs/docutils/docutils/parsers/rst/directives/__init__.pyi:33:73:</a> PYI051 [*] `Literal[&quot;space&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/docutils/docutils/parsers/rst/directives/__init__.pyi#L33">stubs/docutils/docutils/parsers/rst/directives/__init__.pyi:33:73:</a> PYI051 `Literal[&quot;space&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/geopandas/geopandas/io/_geoarrow.pyi#L16">stubs/geopandas/geopandas/io/_geoarrow.pyi:16:36:</a> PYI051 [*] `Literal[&quot;WKB&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/geopandas/geopandas/io/_geoarrow.pyi#L16">stubs/geopandas/geopandas/io/_geoarrow.pyi:16:36:</a> PYI051 `Literal[&quot;WKB&quot;]` is redundant in a union with `str`
+ <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/geopandas/geopandas/io/_geoarrow.pyi#L16">stubs/geopandas/geopandas/io/_geoarrow.pyi:16:43:</a> PYI051 [*] `Literal[&quot;geoarrow&quot;]` is redundant in a union with `str`
- <a href="https://github.com/python/typeshed/blob/41eb1a6731aae4b429781704b09e9d0cc12379d0/stubs/geopandas/geopandas/io/_geoarrow.pyi#L16">stubs/geopandas/geopandas/io/_geoarrow.pyi:16:43:</a> PYI051 `Literal[&quot;geoarrow&quot;]` is redundant in a union with `str`
</pre>

</p>

Changes by rule (1 rules affected)
<p>

<p>| code | total | + violation | - violation | + fix | - fix |
| ---- | ------- | --------- | -------- | ----- | ---- |
| PYI051 | 24 | 0 | 0 | 24 | 0 |</p>
</p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-04-03 05:38</div>
            <div class="timeline-body"><p>Hey @ntBre can you review this please when you get time? Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI051_PYI051.py.snap</code>:60 on 2025-04-03 18:23</div>
            <div class="timeline-body"><p>I don&#x27;t think this should alter the type of union, even if the Python version supports it. In other words, this should end up as</p>
<pre><code>  5 |+B: TypeAlias = typing.Union[bytes, str]
</code></pre>
<p><a href="https://docs.astral.sh/ruff/rules/non-pep604-annotation-union/#non-pep604-annotation-union-up007">non-pep604-annotation-union (UP007)</a> should handle the union type conversion, if the user has that rule enabled.</p>
<p>This relates to the help message as well. &quot;Replace <code>Literal[b&quot;foo&quot;] | bytes</code> with <code>bytes</code>&quot; could be pretty confusing because there&#x27;s no <code>Literal[b&quot;foo&quot;] | bytes</code> in the original code. It looks like this will end up affecting most of the test cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:256 on 2025-04-03 18:35</div>
            <div class="timeline-body"><p>I convinced myself that the <code>unwrap</code> in the other function was okay because it&#x27;s a syntax error to have an empty union, but I think it&#x27;s more plausible for <code>get_or_import_symbol</code> to fail. That means this function should return a <code>Result&lt;Fix&gt;</code> and thus the fix availability will need to be <code>Sometimes</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:256 on 2025-04-03 18:37</div>
            <div class="timeline-body"><p>In that case, I would also suggest removing the other <code>unwrap</code> and returning an <code>Option</code> or <code>Result</code> from the PEP 604 version too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:274 on 2025-04-03 18:40</div>
            <div class="timeline-body"><p>Like the comment above, this can panic if <code>new_exprs</code> is empty (even though it shouldn&#x27;t be), so it would be preferable to use <code>new_exprs.get(0)</code> and bail out if it doesn&#x27;t exist.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:282 on 2025-04-03 18:44</div>
            <div class="timeline-body"><p>I believe you can also squeeze comments into these unions, especially the <code>typing.Union</code> kind, so we will need to check for comments and mark the fix unsafe if they are present. Here&#x27;s an example of doing that:</p>
<p>https://github.com/astral-sh/ruff/blob/64e7e1aa648625359fdbdcaf5fe055c34ff5a783/crates/ruff_linter/src/rules/flake8_pytest_style/rules/parametrize.rs#L676-L678</p>
<p>and an example of the code I&#x27;m picturing where the fix could drop comments:</p>
<pre><code>B: TypeAlias = typing.Union[ # a comment
    Literal[b&quot;bar&quot;, b&quot;foo&quot;], # another
    bytes, # three
    str,  # four
]  # this comment will probably be okay
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:88 on 2025-04-03 18:46</div>
            <div class="timeline-body"><p>tiny nit: I think you can remove these parens. I&#x27;m surprised clippy doesn&#x27;t complain.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-03 19:21</div>
            <div class="timeline-body"><p>I haven&#x27;t fully understood the code yet, but do we really need multiple diagnostics? I think I would expect a single diagnostic for the whole literal, not a separate diagnostic for each redundant part. Is that what&#x27;s being tracked here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:206 on 2025-04-03 19:21</div>
            <div class="timeline-body"><p>Do we need to traverse the union again here, or could this <code>func</code> be combined with the one above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:182 on 2025-04-03 19:23</div>
            <div class="timeline-body"><p>Could this be a bit earlier? It looks like we could return right after the first traversal (if the second ends up being needed).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:204 on 2025-04-03 19:24</div>
            <div class="timeline-body"><p>Again I&#x27;d prefer <code>group.get(0)</code> or <code>group.first()</code> or pattern matching in the <code>match</code> arm itself than a subscript that could panic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> requested changes on 2025-04-03 19:27</div>
            <div class="timeline-body"><p>Thanks for working on this! I think the general approach looks reasonable, but I think we will want to preserve the input union style, be a bit more careful with unwrapping, and make the fix unsafe if there are comments present.</p>
<p>I also think we may be able to reduce some redundancy in the union traversals and avoid emitting multiple diagnostics, but I&#x27;m not as sure about those. Let me know if I&#x27;m off base there!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/ntBre">@ntBre</a> by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-03 20:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI051_PYI051.py.snap</code>:60 on 2025-04-03 20:51</div>
            <div class="timeline-body"><p>I think even the <code>fix_title</code> can be modified based on the union type used. Currently, I hardcoded the message to have <code>typing.Union[...]</code> in the title whenever the <code>UnionKind</code> is <code>TypingUnion</code>. But if the actual import is <code>from typing import Union</code> instead of <code>import typing</code> the fix title can be quite confusing. Do we need fine-grained messages for this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-03 20:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-03 21:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI051_PYI051.py.snap</code>:60 on 2025-04-03 21:07</div>
            <div class="timeline-body"><p>@ntBre</p>
<p>I have one more doubt,</p>
<pre><code>5   |-B: TypeAlias = typing.Union[Literal[b&quot;bar&quot;, b&quot;foo&quot;], bytes, str]
  5 |+B: TypeAlias = bytes | str
</code></pre>
<p>When I do <code>cargo insta review</code> I don&#x27;t have any screen shots to upload. But when I use:</p>
<pre><code>from __future__ import annotations

import typing
from typing import Literal, TypeAlias, Union

x: Literal[&quot;A&quot;, &quot;B&quot;, b&quot;c&quot;, &quot;D&quot;, b&quot;f&quot;, &quot;E&quot;] | str


A: str | Literal[&quot;foo&quot;]
A: typing.Union[Literal[&quot;foo&quot;], str]
B: TypeAlias = typing.Union[Literal[b&quot;bar&quot;, b&quot;foo&quot;], bytes, str]
C: TypeAlias = typing.Union[Literal[5, &quot;foo&quot;], int, str]
D: TypeAlias = typing.Union[Literal[b&quot;str_bytes&quot;, 42], bytes, int]
E: TypeAlias = typing.Union[typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], str]]]]
F: TypeAlias = typing.Union[str, typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], int]]]]
G: typing.Union[str, typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], int]]]]


def func(x: complex | Literal[1J], y: Union[Literal[3.14], float]): ...


# OK
A: Literal[&quot;foo&quot;]
B: TypeAlias = Literal[b&quot;bar&quot;, b&quot;foo&quot;]
C: TypeAlias = Literal[5, &quot;foo&quot;]
D: TypeAlias = Literal[b&quot;str_bytes&quot;, 42]


def func(x: Literal[1J], y: Literal[3.14]): ...
</code></pre>
<p>This gets converted to:</p>
<pre><code>from __future__ import annotations

import typing
from typing import Literal, TypeAlias, Union

x: Union[Literal[b&quot;c&quot;, b&quot;f&quot;], str]


A: str
A: str
B: TypeAlias = Union[bytes, str]
C: TypeAlias = Union[int, str]
D: TypeAlias = Union[bytes, int]
E: TypeAlias = str
F: TypeAlias = Union[str, int]
G: Union[str, int]


def func(x: complex, y: float): ...


# OK
A: Literal[&quot;foo&quot;]
B: TypeAlias = Literal[b&quot;bar&quot;, b&quot;foo&quot;]
C: TypeAlias = Literal[5, &quot;foo&quot;]
D: TypeAlias = Literal[b&quot;str_bytes&quot;, 42]


def func(x: Literal[1J], y: Literal[3.14]): ...
</code></pre>
<p>Here, <code>B: TypeAlias = typing.Union[Literal[b&quot;bar&quot;, b&quot;foo&quot;], bytes, str]</code> gets converted to <code>B: TypeAlias = Union[bytes, str]</code> which is the expected behaviour. Why can I not get this reflected in snapshots?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-04-03 22:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI051_PYI051.py.snap</code>:60 on 2025-04-03 22:33</div>
            <div class="timeline-body"><blockquote>
<p>I think even the <code>fix_title</code> can be modified based on the union type used. Currently, I hardcoded the message to have <code>typing.Union[...]</code> in the title whenever the <code>UnionKind</code> is <code>TypingUnion</code>. But if the actual import is <code>from typing import Union</code> instead of <code>import typing</code> the fix title can be quite confusing. Do we need fine-grained messages for this?</p>
</blockquote>
<p>Can you just use the fix you generate for the title? That should keep them in sync no matter what.</p>
<p>And what do you mean by</p>
<blockquote>
<p>But when I use:</p>
</blockquote>
<p>The fixes are applied when you run ruff manually but not in the snapshot? It looked like the snapshots were updating before, so you might just need to bisect through your recent changes to see what happened. I don&#x27;t see anything obvious in the last couple of commits that would change that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 13:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI051_PYI051.py.snap</code>:60 on 2025-04-04 13:18</div>
            <div class="timeline-body"><p>My bad, I forgot to use <code>--target-version</code> during <code>cargo run</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 13:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:274 on 2025-04-04 13:21</div>
            <div class="timeline-body"><p>This will never happen in the current implementation. But I do agree that using <code>new_exprs.get(0)</code> is safer than <code>new_exprs[0]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-04 13:31</div>
            <div class="timeline-body"><blockquote>
<p>I think I would expect a single diagnostic for the whole literal, not a separate diagnostic for each redundant part. Is that what&#x27;s being tracked here?</p>
</blockquote>
<p>Hmm, we have a diagnostic for each redundant literal in the union. That is what is being returned in the help message as well. If you want to make it a single diagnostic for a union, I&#x27;m ok with making the changes. That&#x27;ll actually simplify the code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 13:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 13:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:182 on 2025-04-04 13:41</div>
            <div class="timeline-body"><p>This is to handle cases where the literal can be <code>Literal</code> or <code>typing.Literal</code>. This should never be null when checking this rule, but I don&#x27;t know how to handle it when <code>literal_subscript</code> is null. Should we <code>panic!</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-04-04 18:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:182 on 2025-04-04 18:11</div>
            <div class="timeline-body"><p>I just meant to move the code earlier in the function. There&#x27;s a lot of code between where <code>literal_subscript</code> is assigned and where this check is performed. We could avoid some work if we do the check as early as possible :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 18:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:182 on 2025-04-04 18:43</div>
            <div class="timeline-body"><p>ü§¶‚Äç‚ôÇÔ∏è I might be low on my ‚òï here. Should&#x27;ve read it more clearly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-04-04 18:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-04 18:43</div>
            <div class="timeline-body"><p>Okay sorry, I think I&#x27;m understanding now. The current implementation also emits a separate diagnostic for each redundant part. Could a simpler implementation of the fix just delete each redundant literal in this loop:</p>
<p>https://github.com/astral-sh/ruff/blob/4d641cf6c89179c656fbd7d6d21d5660b2132c63/crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs#L87-L103</p>
<p>That might run into issues with the empty union parts you mentioned earlier, but that seems like a simpler approach if you can filter out empty parts at that stage.</p>
<p>It seems strange to attach the same cloned <code>Fix</code> to different diagnostics, so I guess I&#x27;m looking for a way to pair up each fix with the diagnostic that would be emitted in the current version.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 18:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-04 18:49</div>
            <div class="timeline-body"><blockquote>
<p>but that seems like a simpler approach if you can filter out empty parts at that stage.</p>
</blockquote>
<p>I agree, but I had a hard time deleting each redundant literal, though that&#x27;ll align perfectly with the generated diagnostics. It would&#x27;ve been very useful if there was a helper function to remove a node from the AST syntactically.</p>
<blockquote>
<p>It seems strange to attach the same cloned Fix to different diagnostics, so I guess I&#x27;m looking for a way to pair up each fix with the diagnostic that would be emitted in the current version.</p>
</blockquote>
<p>Yup, this is a dirty way to do it. The only other thing to do is to try that deletion approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 19:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:206 on 2025-04-04 19:08</div>
            <div class="timeline-body"><p>I don&#x27;t think this can be merged due to the way I&#x27;ve implemented it. The first <code>traverse_union</code> collects all the literal exprs and builtins in the union. Then, the following loop generates diagnostics for each redundant literal expr and also creates a <code>Vec</code> of non-redundant literal exprs (<code>non_redundant_literal_types</code>), which will be used in the next <code>traverse_union</code> for grouping. Next, <code>traverse_union</code>  groups all the non-redundant literal exprs in each <code>Literal</code>s into various groups.</p>
<p>The only thing that blocks merging these two union traversals is <code>non_redundant_literal_types</code>. Let me know if you have any thoughts on removing this dependency.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-04-04 19:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-04 19:10</div>
            <div class="timeline-body"><p>Yeah, sorry for possibly misleading you with my initial suggestion! I think I have a much better understanding of what&#x27;s going on now.</p>
<p>I still don&#x27;t know of an existing API for deleting a node, but you might be able to cobble one together with the <code>generator</code>, somewhat like you are doing already.</p>
<p>Another benefit of this approach, at least in my head, is that we might not have to worry about the type of union in the replacement. If we just delete from what&#x27;s already there, we don&#x27;t have to import anything new, especially.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-04 19:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-04 19:37</div>
            <div class="timeline-body"><blockquote>
<p>you might be able to cobble one together with the generator, somewhat like you are doing already</p>
</blockquote>
<p>Yes, this will make the implementation a lot simpler (as well as the fix titles will be intact with the fixes), and the only place where additional care must be taken is for full deletion of the <code>Literal</code> and handling nested <code>Literal</code>s like:</p>
<pre><code>B: TypeAlias = typing.Union[Literal[b&quot;bar&quot;, b&quot;foo&quot;], bytes, str]
F: TypeAlias = typing.Union[str, typing.Union[typing.Union[typing.Union[Literal[&quot;foo&quot;], int]]]]
...
</code></pre>
<p>To be honest, handling nested unions seems more difficult than handling full deletions or I don&#x27;t know which will be tougher ü´°</p>
<p>But I&#x27;m more than willing to go with this deletion approach than the current one. It&#x27;d be very helpful if you have any suggestions on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-04 19:44</div>
            <div class="timeline-body"><p>I&#x27;ll think about this. I tested in the REPL and saw that empty <code>Literal</code>s cause a syntax error, so we&#x27;ll definitely want to watch out for that, like you said. Empty <code>Union</code>s also cause problems, but I don&#x27;t think we should ever delete <em>everything</em> from a <code>Union</code> here, and <code>Union[int]</code>, for example, is okay, if a bit silly. We can defer to another rule for that :laughing:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-04-04 19:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-06 16:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-06 16:47</div>
            <div class="timeline-body"><p>Hmm.. How about this: Can we change the diagnostics itself? Instead of having a diagnostic for every <code>Literal</code> type element, can we have a single diagnostic for all the redundant groups?  This will make the current group-based implementation reusable, and we can have a single fix for a single diagnostic. We can have a message like:
&quot;<code>Literal[&quot;a&quot;, &quot;b&quot;, &quot;c]</code> is redundant with type <code>str</code>&quot; and fix title can be &quot;Replace <code>Literal[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] with </code>str`&quot;. This way, the error messages, fix titles, and the fixes to diagnostics will be right in place.</p>
<p>Again, I&#x27;m not very sure how other rules play out to these kinds of difficulties, but this seems like another possibility for implementing this.</p>
<blockquote>
<p>We can defer to another rule for that üòÜ</p>
</blockquote>
<p>üòÇ Yeah, I&#x27;m really surprised that there&#x27;s no existing rule in Ruff for this yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-07 06:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-07 06:37</div>
            <div class="timeline-body"><blockquote>
<p>Hmm.. How about this: Can we change the diagnostics itself? Instead of having a diagnostic for every Literal type element, can we have a single diagnostic for all the redundant groups</p>
</blockquote>
<p>That&#x27;s possible but it&#x27;s a breaking change because it changes the primary diagnostic range. That&#x27;s not a reason for not doing it but it requires gating the change behind preview. Having a single diagnostic will look better once we support multi-span diagnostics (with which we plan to start soon)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-04-07 06:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-04-07 06:54</div>
            <div class="timeline-body"><p>Got it, and I&#x27;ll wait for that change cause it&#x27;ll definitely make things much easier (from the user POV as well). What do you think about this implementation? How do you think we should go forward?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:216 on 2025-04-07 11:45</div>
            <div class="timeline-body"><p>This can still panic, just with a nicer error message. I think I was picturing something more like this:</p>
<pre><code>                        let Some(group) = group.first() else {
                            return;
                         };
                         group //.clone() if necessary
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:313 on 2025-04-07 11:46</div>
            <div class="timeline-body"><p>Same as above, we should return early instead of <code>expect</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-04-07 11:58</div>
            <div class="timeline-body"><p>Thanks for handling all of these changes! Since my last review, I happened to review another rule with that pattern of looping over <code>Diagnostic</code>s and adding the same fix to each one, so that&#x27;s definitely not unprecedented. Does the current implementation work as well as that version? I think it would be okay to go back to that, if it would help you.</p>
<p>Also, if you still haven&#x27;t handled the case with a full deletion, I think it&#x27;s okay not to offer a fix in that case, at least for now. We would just need to drop the <code>FixAvailability</code> to <code>Sometimes</code> (which is actually needed anyway now that you&#x27;re using <code>try_set_optional_fix</code>) and document this case in a <code>## Fix availability</code> section in the rule docs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-04-09 18:29</div>
            <div class="timeline-body"><blockquote>
<p>Thanks for handling all of these changes! Since my last review, I happened to review another rule with that pattern of looping over <code>Diagnostic</code>s and adding the same fix to each one, so that&#x27;s definitely not unprecedented. Does the current implementation work as well as that version? I think it would be okay to go back to that, if it would help you.</p>
</blockquote>
<p>So, we&#x27;ll just go back to the previous deletion-based implementation? But if another rule also has the same kind of looping over diagnostics, can we move forward with the current implementation?</p>
<blockquote>
<p>Also, if you still haven&#x27;t handled the case with a full deletion, I think it&#x27;s okay not to offer a fix in that case, at least for now.</p>
</blockquote>
<p>That should help if we decide to go with the deletion approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-24 20:54</div>
            <div class="timeline-body"><blockquote>
<p>So, we&#x27;ll just go back to the previous deletion-based implementation? But if another rule also has the same kind of looping over diagnostics, can we move forward with the current implementation?</p>
</blockquote>
<p>Sorry for the delay on this. I think either implementation is fine. I think I steered you away from the looping version before, but I didn&#x27;t realize that was an existing pattern in other rules. All I wanted to say in my last message is that that approach is totally fine, if it makes it easier for you. The current implementation is fine too, if you prefer that.</p>
<p>I&#x27;ll try to refresh myself on this PR and re-review soon. I think it should be close to finished, thanks again for your work and your patience.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-05-07 09:12</div>
            <div class="timeline-body"><blockquote>
<p>The current implementation is fine too, if you prefer that.</p>
</blockquote>
<p>@ntBre If we can go forward with this, I prefer this implementation over the previous one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:206 on 2025-05-07 19:37</div>
            <div class="timeline-body"><p>You&#x27;re right, this makes sense. I finally looked at the PR for PYI041 and it does the same.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-05-07 19:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-05-07 19:44</div>
            <div class="timeline-body"><p>Thanks again for your work on this! I&#x27;m trying to remember all of the context here. From the discussion above, it sounds like the open questions are:</p>
<ul>
<li>Are we avoiding the breaking change Micha mentioned <a href="https://github.com/astral-sh/ruff/pull/17003#discussion_r2030543917">here</a>? I think this means we still need one diagnostic for each redundant element, if I&#x27;m remembering/reading correctly.</li>
<li>Do we properly handle the empty <code>Literal</code>/<code>| str</code> case mentioned above? I&#x27;m happy to leave that and other tricky cases as a follow-up item if needed, but I don&#x27;t want there to be any cases where we cause a syntax error.</li>
<li>Is the fix restricted to preview? It looks like the fix for PYI041 was also initially added in preview, which might be a good idea here too.</li>
</ul>
<p>I&#x27;ll try to answer these myself as I review the code again now. Thanks again for your patience, and let&#x27;s try to merge this soon!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:101 on 2025-05-07 19:48</div>
            <div class="timeline-body"><p>Can we detect the union kind from the code itself rather than the Python version? It&#x27;s still allowed to use <code>typing.Union</code> on more recent versions, and I don&#x27;t think we should make the unrelated change to the PEP-604 form if we can help it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:167 on 2025-05-07 19:51</div>
            <div class="timeline-body"><p>I think right here would be a good place for an early return if preview is disabled. Something like:</p>
<pre><code>if checker.settings.preview.is_disabled() {
    checker.report_diagnostics(diagnostics);
    return;
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:224 on 2025-05-07 19:55</div>
            <div class="timeline-body"><p>Does this <code>collect</code> change the type here? It looks like this could possibly just be <code>group</code> or <code>group.clone()</code> if we really need to use it later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:233 on 2025-05-07 19:56</div>
            <div class="timeline-body"><p>Similar to the above, can we just use <code>group</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:254 on 2025-05-07 19:58</div>
            <div class="timeline-body"><p>I&#x27;d slightly prefer something like</p>
<pre><code>if let [new_expr] = new_exprs { ... }
</code></pre>
<p>To tie the length and the index together instead of <code>if len == 1</code>/<code>new_exprs[0]</code> separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:312 on 2025-05-07 20:01</div>
            <div class="timeline-body"><p>We may be able to get away without this if we can check the union kind initially present in the source code. In other words, if we know they&#x27;ve already used a <code>typing.Union</code> we won&#x27;t have to import it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/snapshots/ruff_linter__rules__flake8_pyi__tests__PYI051_PYI051.py.snap</code>:40 on 2025-05-07 20:02</div>
            <div class="timeline-body"><p>This is the kind of thing I was picturing with my suggestion to detect the union kind from the initial code. Ideally we would still use a <code>typing.Union</code> here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-05-07 20:06</div>
            <div class="timeline-body"><p>Nice, I only had some minor suggestions besides hoping we can preserve the input union kind and gating this behind preview. The code looks good to me overall.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-05-07 20:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:224 on 2025-05-07 20:42</div>
            <div class="timeline-body"><p>Here, group is of type <code>Vec&lt;&amp;Expr&gt;</code> but the <code>elts</code> needs <code>Vec&lt;Expr&gt;</code>. To avoid this, I can do <code>.to_owned()</code> on every append to the <code>group</code> but I don&#x27;t think that looks good.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-05-07 20:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:224 on 2025-05-07 20:44</div>
            <div class="timeline-body"><p>This makes sense then, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kiran-4444">@kiran-4444</a> reviewed on 2025-05-07 20:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:233 on 2025-05-07 20:45</div>
            <div class="timeline-body"><p><code>group</code> turns out to be <code>&amp;&amp;Expr</code> but the return type should be <code>Expr</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kiran-4444">@kiran-4444</a> on 2025-05-09 06:28</div>
            <div class="timeline-body"><p>@ntBre Strange, my recent changes make test failures and force me to use <code>FixAvailability::Sometime</code>. But when I copy the content in <code>PYI051.py</code> (which is what I believe the tests will run against for this rule?) and try running <code>cargo run</code> on this rule, the formats the whole perfectly. What could be the issue?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-05-09 12:49</div>
            <div class="timeline-body"><p>Oh yeah, I think I meant to mention that at some point. Because you&#x27;re returning <code>Option&lt;Fix&gt;</code> and <code>Result&lt;Option&lt;Fix&gt;&gt;</code> the fix <em>is</em> only sometimes available. I&#x27;m not sure why you&#x27;re getting different results in tests and in interactive use, but <code>FixAvailability::Sometimes</code> should be correct.</p>
<p>Currently we could fail to get a fix if the <code>typing.Union</code> import is requested and fails for some reason or if the <code>fold</code> call in the PEP 604 function somehow returns <code>None</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Avasam">@Avasam</a> reviewed on 2025-09-16 01:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Avasam">@Avasam</a> on <code>crates/ruff_linter/src/rules/flake8_pyi/rules/redundant_literal_union.rs</code>:122 on 2025-09-16 01:20</div>
            <div class="timeline-body"><p>I may be mistaken, but looking at <a href="https://github.com/astral-sh/ruff/issues/17203">astral-sh/ruff#17203</a> it seems like multi-span diagnostics are either now or soon available?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-10-30 17:00</div>
            <div class="timeline-body"><p>If I&#x27;m not mistaken, this is on hold waiting for <a href="https://github.com/astral-sh/ruff/issues/17203">astral-sh/ruff#17203</a> right ? It&#x27;s the last feature I&#x27;d need to cleanup https://github.com/microsoft/python-type-stubs/blob/692c37c3969d22612b295ddf7e7af5907204a386/pyproject.toml#L81-L82</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-10-30 17:33</div>
            <div class="timeline-body"><p>It&#x27;s been a while since I looked at this, but from a quick skim, I think changing the union type (<a href="https://github.com/astral-sh/ruff/pull/17003">astral-sh/ruff#17003</a>#discussion_r2078391767) would be a bigger blocker than multi-span diagnostics.</p>
<p>I think the current state of the rule is to emit one diagnostic per violation, which doesn&#x27;t need multiple spans.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-17 15:13</div>
            <div class="timeline-body"><p>Thanks for all of your work here. I think I&#x27;ll go ahead and close this for now since it&#x27;s become a bit stale, but please don&#x27;t hesitate to reopen or resubmit the PR if you plan to continue working on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/ntBre">@ntBre</a> on 2025-12-17 15:13</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:12:37 UTC
    </footer>
</body>
</html>
