<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Handle unions of callables better - astral-sh/ruff #16716</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Handle unions of callables better</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16716">#16716</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-03-13 20:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-13 20:37</div>
            <div class="timeline-body"><p>This cleans up how we handle calling unions of types.  astral-sh/ruff#16568 adding a three-level structure for callable signatures (<code>Signatures</code>, <code>CallableSignature</code>, and <code>Signature</code>) to handle unions and overloads.</p>
<p>This PR updates the bindings side to mimic that structure.  What used to be called <code>CallOutcome</code> is now <code>Bindings</code>, and represents the result of binding actual arguments against a possible union of callables.  <code>CallableBinding</code> is the result of binding a single, possibly overloaded, callable type.  <code>Binding</code> is the result of binding a single overload.</p>
<p>While we're here, this also cleans up <code>CallError</code> greatly.  It was previously extracting error information from the bindings and storing it in the error result.  It is now a simple enum, carrying no data, that's used as a status code to talk about whether the overall binding was successful or not.  We are now more consistent about walking the binding itself to get detailed information about <em>how</em> the binding was unsucessful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2167 on 2025-03-14 01:24</div>
            <div class="timeline-body"><p>This has to be separated out into two match arms since the <code>Err</code> outcome is boxed and the <code>Ok</code> one is not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-14 01:28</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2365 on 2025-03-14 01:33</div>
            <div class="timeline-body"><p>The <code>signatures</code> function as a whole is now tracked, instead of tracking each of these individual special case clauses.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3992 on 2025-03-14 01:41</div>
            <div class="timeline-body"><p>These lints are now handled by <code>Bindings::report_diagnostics</code>, which means that all call-site-related lints are now in the same place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/conditional/match.md</code>:51 on 2025-03-14 01:44</div>
            <div class="timeline-body"><p>Without these changes, we infer the type of <code>__bool__</code> to be <code>int | Unknown</code>. Only one of the union branches is non-callable, which changes the content of the error message below. I decided to add the type annotations instead of updating the expected error messages, since this seems to more accurately reflect the intent of these <code>NotBoolable</code> types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/expression/boolean.md</code>:138 on 2025-03-14 01:45</div>
            <div class="timeline-body"><p>Here <code>__bool__</code> is a union, but unlike above, both elements are non-callable, so we treat the union as a whole as non-callable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-14 01:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dcreager on 2025-03-14 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-03-14 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dcreager on 2025-03-14 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-03-14 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dcreager on 2025-03-14 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] [WIP] Handle unions of callables better" to "[red-knot] Handle unions of callables better" by @dcreager on 2025-03-14 01:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-14 07:48</div>
            <div class="timeline-body"><p>Does making this a salsa query help with performance? It's one of the cases where salsa has to do one extra interning for the cache key (because the key is a combination of <code>self</code> and <code>Type</code>.</p>
<p>Should we instead intern <code>Signatures</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2636 on 2025-03-14 07:51</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        for binding in bindings.bindings_mut() {
</code></pre>
<p>This reads very repetitively. Should it be renamed to <code>iter_mut</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:91 on 2025-03-14 07:54</div>
            <div class="timeline-body"><p>Nit: Would it amke sense to track a boolean flag whether we've seen any binding with errors and only perform the second iteration if the flag is <code>true</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:140 on 2025-03-14 07:55</div>
            <div class="timeline-body"><p>Nit: <code>bindings.bindings()</code> reads very repetitively on the call site. I suggest going with <code>iter</code>, <code>iter_mut</code> and implementing <code>IntoIterator for &amp;Bindings</code></p>
<p>Oh, I see now that we return a slice. Do we need to return a slice or is an iterator enough (<code>std::slice::Iter</code>)?</p>
<p>If it has to be a slice, then I'm leaning towards <code>as_slice</code> and <code>as_slice_mut</code> and/or implementing <code>Deref</code> and <code>DerefMut</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2633 on 2025-03-14 08:02</div>
            <div class="timeline-body"><p>I overall like the change, but I'm a bit concerned about <code>call</code> returning <code>Bindings</code> directly and relying on the caller's <em>good behavior</em> to only call <code>bindings.return_type</code> if they're okay ignoring any possible binding error. It somewhat undoes what I tried to accomplish with my <code>try_</code> refactor to make all error handling explicit.</p>
<p>The method name also doesn't fit into the <code>try_</code> for faliable operations naming-convention anymore. It should also simplify the call-sites because every call site immediately calls <code>as_result</code>.</p>
<p>I very much like the outcome that bindings now stores the relevant information.
A possible solution here is to change <code>CallError</code> to a struct with two fields: <code>Bindings</code> and <code>kind</code> where kind is what is <code>CallError</code> in your PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2319 on 2025-03-14 08:11</div>
            <div class="timeline-body"><p>Similar to <code>call</code>. I think this is going in a slightly different direction to what I started with my <code>try_</code> work where error handling is no longer explicit but implicit again. I'm not tied to that approach but what my PR showed is that implicit error handling is very easy to get wrong and it's very tempting to call methods directly on <code>Signatures</code> if they're directly available.</p>
<p>That's why I'm wondering of what your reasoning was to not return a <code>Result&lt;Signatures, SignaturesErr&gt;</code> here. I suspect it has to do with the union error handling where the <code>Result</code> doesn't compose well?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-14 08:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2025-03-14 08:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2633 on 2025-03-14 12:01</div>
            <div class="timeline-body"><p>Yeah I was going back on forth on that.  I had thought that some callers would want to inspect the bindings before converting to a result.  But no one is doing that, and even if they did, I can probably add a helper method to make that easier.</p>
<p>If you look a couple of commits back that's sort of how it was...though the lower layer bindings need to return a <code>CallError</code> without the attached <code>Bindings</code>, so I had it with a parameterized type...  Anyway I think I can pull out a <code>CallErrorKind</code> to make this work.  Will try that now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2319 on 2025-03-14 12:07</div>
            <div class="timeline-body"><blockquote>
<p>I suspect it has to do with the union error handlin</p>
</blockquote>
<p>Yes that's right!  This originally returned <code>Option&lt;Signatures&gt;</code>, since the only &quot;error&quot; condition is that the type isn't callable, and therefore doesn't really have a signature.</p>
<p>But with unions, you can have some element types that are callable and some that are not.  So we already need the signature types to track &quot;callable or not&quot; internally, and once we have that, <code>Signatures::not_callable</code> works for that &quot;error&quot; condition just as well as <code>None</code>.</p>
<p>So every type now has a <code>Signatures</code> object.  And it's perfectly fine to try to create a <code>Bindings</code> for it at a call site, even if the type isn't actually callable.  The resulting <code>Bindings</code> (and per your above comment, the <code>Err</code> that you'll get back from that <code>try_call</code> call) will tell you that the type isn't actually callable.  (And if you <em>want</em> to skip the <code>try_call</code> for types that are completely non-callable, there's an <code>is_callable</code> method that you can call.)</p>
<p>I can add some more documentation about this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-14 12:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2319 on 2025-03-14 12:33</div>
            <div class="timeline-body"><p>Makes sense. I also think that returning a <code>Result</code> here is less important than for <code>call</code> as it's <em>more internal</em> and <code>Signatures</code> provides less helpful methods (e.g. no <code>return_type</code>). So I think it's different enough that it is okay to diverge from the pattern we use for other type operations and documentation should help to make this clear</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-14 12:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-14 14:53</div>
            <div class="timeline-body"><p>Before we <a href="https://github.com/astral-sh/ruff/pull/16568/#discussion_r1988118843">were using salsa queries to cache the signatures</a> we were creating by hand for special-case calls, since the contents of the signature don't depend on the arguments of each call site anymore.  I had done this to try to simplify that caching.</p>
<p>I like your suggestion better, though, so I've done that.  I'm just tracking the signatures, not interning them, since we don't need the faster equality comparison.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2636 on 2025-03-14 14:56</div>
            <div class="timeline-body"><p>Changed to <code>iter_mut</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:140 on 2025-03-14 14:56</div>
            <div class="timeline-body"><p>Ditto other comment, made this <code>iter</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:91 on 2025-03-14 14:58</div>
            <div class="timeline-body"><p>I don't think it will matter for performance, since we shouldn't have hundreds or thousands of union elements. So I'd rather decide this based on code readability. Do you feel like it reads better with the flag and skipping the second loop if we can?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2633 on 2025-03-14 14:59</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-14 14:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-03-14 15:04</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_INSTRUMENTATION_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Funion-callables">CodSpeed Performance Report</a></h2>
<h3>Merging astral-sh/ruff#16716 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>dcreager/union-callables</code> (e460c80) with <code>main</code> (75a562d)</sub></p>
<h3>Summary</h3>
<p><code>âœ… 32</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-14 15:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-14 15:25</div>
            <div class="timeline-body"><p>Tracking (and interning, tried that too) <code>Signatures</code> adds the performance regression that Codspeed is showing.  Which thinking through it, makes sense, since when tracking the <code>signatures</code> function, the cache key is just two u32s (<code>self</code> and <code>Type</code>).  But tracking the struct means that we have to do a hash lookup based on the content of the more complex <code>Signatures</code> type.  (Unless I'm misunderstanding the underlying salsa machinery!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-14 15:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:91 on 2025-03-14 15:43</div>
            <div class="timeline-body"><blockquote>
<p>Do you feel like it reads better with the flag and skipping the second loop if we can?</p>
</blockquote>
<p>that's very unlikely because it introduces more control flow and not less ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-14 15:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-14 15:45</div>
            <div class="timeline-body"><p>Makes sense. Thanks for trying. The main finding here is that the extra allocations for repeated signatures matter less.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2763 on 2025-03-14 17:11</div>
            <div class="timeline-body"><p>I would prefer to do inner matches over the value of <code>function.known()</code> and <code>class.known()</code> in this method, rather than having lots of branches with <code>if function.is_known()</code> and <code>if class.is_known()</code> guards. The <code>is_known()</code> functions each do a Salsa lookup, which can be surprisingly expensive; it's better to just do the lookup once and then have a <code>match</code> over it rather than doing it repeatedly in each <code>match</code> branch:</p>
<pre><code class="language-rs">                Type::FunctionLiteral(function) =&gt; match function.known(db) {
                    Some(KnownFunction::IsEquivalentTo) =&gt; {
                        if let [ty_a, ty_b] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(
                                ty_a.is_equivalent_to(db, *ty_b),
                            ));
                        }
                    }

                    Some(KnownFunction::IsSubtypeOf) =&gt; {
                        if let [ty_a, ty_b] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(
                                ty_a.is_subtype_of(db, *ty_b),
                            ));
                        }
                    }

                    Some(KnownFunction::IsAssignableTo) =&gt; {
                        if let [ty_a, ty_b] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(
                                ty_a.is_assignable_to(db, *ty_b),
                            ));
                        }
                    }

                    Some(KnownFunction::IsDisjointFrom) =&gt; {
                        if let [ty_a, ty_b] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(
                                ty_a.is_disjoint_from(db, *ty_b),
                            ));
                        }
                    }

                    Some(KnownFunction::IsGradualEquivalentTo) =&gt; {
                        if let [ty_a, ty_b] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(
                                ty_a.is_gradual_equivalent_to(db, *ty_b),
                            ));
                        }
                    }

                    Some(KnownFunction::IsFullyStatic) =&gt; {
                        if let [ty] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(ty.is_fully_static(db)));
                        }
                    }

                    Some(KnownFunction::IsSingleton) =&gt; {
                        if let [ty] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(ty.is_singleton(db)));
                        }
                    }

                    Some(KnownFunction::IsSingleValued) =&gt; {
                        if let [ty] = overload.parameter_types() {
                            overload.set_return_type(Type::BooleanLiteral(ty.is_single_valued(db)));
                        }
                    }

                    Some(KnownFunction::Len) =&gt; {
                        if let [first_arg] = overload.parameter_types() {
                            if let Some(len_ty) = first_arg.len(db) {
                                overload.set_return_type(len_ty);
                            }
                        };
                    }

                    Some(KnownFunction::Repr) =&gt; {
                        if let [first_arg] = overload.parameter_types() {
                            overload.set_return_type(first_arg.repr(db));
                        };
                    }

                    Some(KnownFunction::Cast) =&gt; {
                        // TODO: Use `.parameter_types()` exclusively when overloads are supported.
                        if let Some(casted_ty) = arguments.first_argument() {
                            if let [_, _] = overload.parameter_types() {
                                overload.set_return_type(casted_ty);
                            }
                        };
                    }

                    Some(KnownFunction::Overload) =&gt; {
                        overload.set_return_type(todo_type!(&quot;overload(..) return type&quot;));
                    }

                    Some(KnownFunction::GetattrStatic) =&gt; {
                        let [instance_ty, attr_name, default] = overload.parameter_types() else {
                            continue;
                        };

                        let Some(attr_name) = attr_name.into_string_literal() else {
                            continue;
                        };

                        let default = if default.is_unknown() {
                            Type::Never
                        } else {
                            *default
                        };

                        let union_with_default = |ty| UnionType::from_elements(db, [ty, default]);

                        // TODO: we could emit a diagnostic here (if default is not set)
                        overload.set_return_type(
                            match instance_ty.static_member(db, attr_name.value(db)) {
                                Symbol::Type(ty, Boundness::Bound) =&gt; {
                                    if instance_ty.is_fully_static(db) {
                                        ty
                                    } else {
                                        // Here, we attempt to model the fact that an attribute lookup on
                                        // a non-fully static type could fail. This is an approximation,
                                        // as there are gradual types like `tuple[Any]`, on which a lookup
                                        // of (e.g. of the `index` method) would always succeed.

                                        union_with_default(ty)
                                    }
                                }
                                Symbol::Type(ty, Boundness::PossiblyUnbound) =&gt; {
                                    union_with_default(ty)
                                }
                                Symbol::Unbound =&gt; default,
                            },
                        );
                    }

                    _ =&gt; {}
                },

                Type::ClassLiteral(ClassLiteralType { class }) =&gt; match class.known(db) {
                    Some(KnownClass::Bool) =&gt; {
                        overload.set_return_type(
                            arguments
                                .first_argument()
                                .map(|arg| arg.bool(db).into_type(db))
                                .unwrap_or(Type::BooleanLiteral(false)),
                        );
                    }

                    Some(KnownClass::Str) if overload_index == 0 =&gt; {
                        overload.set_return_type(
                            arguments
                                .first_argument()
                                .map(|arg| arg.str(db))
                                .unwrap_or_else(|| Type::string_literal(db, &quot;&quot;)),
                        );
                    }

                    Some(KnownClass::Type) if overload_index == 0 =&gt; {
                        if let Some(arg) = arguments.first_argument() {
                            overload.set_return_type(arg.to_meta_type(db));
                        }
                    }
                    _ =&gt; {}
                },
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:13 on 2025-03-14 17:12</div>
            <div class="timeline-body"><p>nit: I think I'd prefer named fields?</p>
<pre><code class="language-suggestion">pub(super) struct CallError&lt;'db&gt; {
    pub(super) kind: CallErrorKind,
    pub(super) bindings: Box&lt;Bindings&lt;'db&gt;&gt;,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:26 on 2025-03-14 17:18</div>
            <div class="timeline-body"><p>hmm, what's meant by &quot;directly callable&quot; here? <em>All</em> callable objects in Python have a <code>__call__</code> method, even functions; this is core to the definition of what it means for an object to be callable in the language:</p>
<pre><code class="language-py">&gt;&gt;&gt; def foo():
...     print('hi')
...     
&gt;&gt;&gt; foo.__call__()
hi
</code></pre>
<p>For <em>some</em> types, like function-literal types, we don't attempt to lookup the <code>__call__</code> method in red-knot in order to infer the signature of the callable. But that doesn't mean that the <code>__call__</code> method doesn't exist!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:72 on 2025-03-14 17:20</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">    pub(crate) const fn is_single(&amp;self) -&gt; bool {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:91 on 2025-03-14 17:21</div>
            <div class="timeline-body"><blockquote>
<p>I don't think it will matter for performance, since we shouldn't have hundreds or thousands of union elements. So</p>
</blockquote>
<p>you'd be surprised! A lot of pathological edge cases to do with type-checker performance are to do with large unions. I listed some of the ones mypy and pyright have come across in the past in https://github.com/astral-sh/ruff/issues/13549</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:238 on 2025-03-14 17:23</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">    const fn is_callable(&amp;self) -&gt; bool {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:312 on 2025-03-14 17:23</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">    pub(crate) const fn dunder_is_possibly_unbound(&amp;self) -&gt; bool {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:578 on 2025-03-14 17:24</div>
            <div class="timeline-body"><p>heh, &quot;descriptor&quot; is quite an overloaded word in red-knot ðŸ˜† maybe <code>CallableDescription</code>?</p>
<pre><code class="language-suggestion">pub(crate) struct CallableDescription&lt;'a&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:92 on 2025-03-14 17:29</div>
            <div class="timeline-body"><p>nit: we changed our naming convention in https://github.com/astral-sh/ruff/pull/15617 to use <code>type</code> rather than <code>ty</code> where possible. That obviously isn't ergonomic for the first field in this struct (as it conflicts with a Rust keyword), but I'd prefer for this to be called <code>signature_type</code> (and similar for various other fields on various other structs in this PR)</p>
<pre><code class="language-suggestion">    pub(crate) signature_type: Type&lt;'db&gt;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:130 on 2025-03-14 17:30</div>
            <div class="timeline-body"><p>Does this still panic if the iterator is empty? It doesn't <em>look</em> to me like it does</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-14 17:31</div>
            <div class="timeline-body"><p>Not really a full review (sorry!), just a couple of things I spotted while skimming</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2763 on 2025-03-14 20:31</div>
            <div class="timeline-body"><p>That's a good callout!  I had done it this way because I like to avoid too must nesting if possible, but I hadn't realized the performance implications.  Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:13 on 2025-03-14 20:35</div>
            <div class="timeline-body"><p>Normally I agree but this type is only ever consumed in pattern matches, and my thought was that</p>
<pre><code class="language-rust">Err(CallDunderError::CallError(CallErrorKind::BindingError, bindings)) =&gt; ...
</code></pre>
<p>is easier to read than</p>
<pre><code class="language-rust">Err(CallDunderError::CallError {
    kind: CallErrorKind::BindingError,
    bindings,
})) =&gt; ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:26 on 2025-03-14 20:38</div>
            <div class="timeline-body"><p>Ah that's a good clarification!  The idea I'm trying to convey is whether we use type of the object or the type of the <code>__call__</code> method in certain error messages.  Is there existing terminology that we can use here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:91 on 2025-03-14 20:45</div>
            <div class="timeline-body"><p>Good to know!  Added the boolean</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:578 on 2025-03-14 20:46</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:130 on 2025-03-14 20:47</div>
            <div class="timeline-body"><p>It doesn't!  Good catch</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:92 on 2025-03-14 20:50</div>
            <div class="timeline-body"><p>Done (and <code>ty</code> â†’ <code>callable_type</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-14 20:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:26 on 2025-03-14 21:49</div>
            <div class="timeline-body"><p>I think the names <code>callable_type</code> and <code>signature_type</code> are reasonable here. Here's what I'd propose for this wording:</p>
<pre><code class="language-suggestion">    /// The type we'll use for error messages referring to details of the called signature. For calls to functions this
    /// will be the same as `callable_type`; for other callable instances it may be a `__call__` method.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:52 on 2025-03-14 21:54</div>
            <div class="timeline-body"><p>Does this method panic on receiving an empty iterator? It doesn't look like it would, it looks like it would just create a <code>Signatures</code> with empty <code>elements</code>.</p>
<p>Also I think it takes an iterator of <code>Signatures</code>s, not <code>Signature</code>s :)</p>
<pre><code class="language-suggestion">    /// Creates a new `Signatures` from an iterator of [`Signatures`].
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:108 on 2025-03-14 21:59</div>
            <div class="timeline-body"><p>For vectors that will usually be length 1, I always wonder whether <code>SmallVec</code> would be a win (by reducing allocation/fragmentation in the common case). But it may not be. (And sometimes it introduces bogus lifetime variance problems, because the current version of the <code>smallvec</code> crate has a lifetime annotations bug.)</p>
<p>Or I guess an enum like you did with <code>BindingsInner</code> is another option. Is there a clear principle by which you chose simple vectors for signatures but a more complex representation for bindings?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:98 on 2025-03-14 22:01</div>
            <div class="timeline-body"><p>Let's not forget to update this along with the above similar comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:136 on 2025-03-14 22:03</div>
            <div class="timeline-body"><p>It seems like there's nothing actually requiring the iterator to be non-empty; if it's empty we'll just create a not-callable <code>CallableSignature</code>? Which seems fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:108 on 2025-03-14 22:06</div>
            <div class="timeline-body"><p>Maybe add a comment here noting that an empty <code>overloads</code> indicates an object that is not callable?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:30 on 2025-03-14 22:14</div>
            <div class="timeline-body"><p>I guess <code>&amp;'db</code> lifetime is right because this is a reference returned from a <code>#[return_ref]</code> Salsa query, so it really is borrowed from the db?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:105 on 2025-03-14 22:21</div>
            <div class="timeline-body"><p>It's not clear to me why this is important. Do you judge it important for the user experience? The only effect of the significant simplification below is that we get <code>Unknown | int</code> instead of <code>int | Unknown</code> in a few places, which doesn't seem like a problem to me (in fact it seems potentially better, if the ordering of the return types maps directly to the ordering of elements in the original callable union):</p>
<pre><code class="language-suggestion">                UnionType::from_elements(db, bindings.iter().map(|b| b.return_type()))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:59 on 2025-03-14 22:25</div>
            <div class="timeline-body"><p>So <code>BindingError</code> may also represent a union that is possibly not callable, but we prioritize surfacing the binding error over the fact that it may not be callable at all? That may be OK, but I feel like ideally I'd want both problems surfaced at once. (I'm not worried about the details of how that is reflected in diagnostics until we have the new diagnostics system in use, just about whether the representation is capable of carrying the necessary information.)</p>
<p>In principle it seems like <code>PossiblyNotCallable</code> and <code>BindingError</code> are orthogonal, so to flatten to a single enum we have to choose one of them to prioritize.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:58 on 2025-03-14 22:27</div>
            <div class="timeline-body"><p>Is <code>PossiblyNotCallable</code> a possible result from a binding of a single <code>CallableSignature</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:103 on 2025-03-14 22:45</div>
            <div class="timeline-body"><p>It seems like in practice this is really just a single bit of information. Either we aren't explicitly representing <code>__call__</code> at all (e.g. for a function type), which is equivalent to (and is actually at runtime) &quot;<code>__call__</code> is definitely bound&quot;, or we have &quot;<code>__call__</code> is possibly bound&quot;. It doesn't seem like <code>Unbound</code> is actually possible, because then we wouldn't have a signature at all.</p>
<p>So would it be simpler to represent this as <code>dunder_call_may_be_unbound: bool</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:382 on 2025-03-14 22:52</div>
            <div class="timeline-body"><p>nit: if we'll rename the type (which I like), let's do the variable too</p>
<pre><code class="language-suggestion">        let callable_description =
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:742 on 2025-03-14 22:53</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        callable_description: Option&lt;&amp;CallableDescription&gt;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:21 on 2025-03-14 22:57</div>
            <div class="timeline-body"><p>I think it's worth noting here that the type may also be possibly not callable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-14 23:12</div>
            <div class="timeline-body"><p>What are the &quot;extra allocations for repeated Signatures&quot; here? We'll create one for each <code>(self, callable_ty)</code> combo, which is I think the minimum we need regardless (barring a different way of handling <code>callable_ty</code> entirely).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2325 on 2025-03-14 23:25</div>
            <div class="timeline-body"><p>It feels to me like it should be possible to get rid of this <code>callable_ty</code> argument (and thus the Salsa interning) entirely, but it might require a recursive <code>Signature::set_callable_ty</code> method; not sure if that's worth it or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2330 on 2025-03-14 23:27</div>
            <div class="timeline-body"><p>nit: what about a <code>CallableSignature.with_bound_type()</code> method that wouldn't require wrapping in <code>Some</code> or publicly exposing the <code>bound_type</code> field directly?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2658 on 2025-03-14 23:31</div>
            <div class="timeline-body"><p>Not sure, but does this break handling of these special known callables when they occur inside a union? Should we be matching on a <code>callable_type</code> or <code>signature_type</code> from the binding's specific signature, rather than on <code>self</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-03-14 23:35</div>
            <div class="timeline-body"><p>Overall I like this a lot!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2325 on 2025-03-15 12:23</div>
            <div class="timeline-body"><p>there's too many comments already on this line of code ðŸ˜† but if we <em>do</em> keep this argument, I'd prefer it to be named</p>
<pre><code class="language-suggestion">    fn signatures(self, db: &amp;'db dyn Db, callable_type: Type&lt;'db&gt;) -&gt; Signatures&lt;'db&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2941 on 2025-03-15 12:24</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        callable_type: Option&lt;Type&lt;'db&gt;&gt;,
        name: &amp;str,
    ) -&gt; Option&lt;(&amp;'db Signatures&lt;'db&gt;, Boundness)&gt; {
        match self
            .member_lookup_with_policy(db, name.into(), MemberLookupPolicy::NoInstanceFallback)
            .symbol
        {
            Symbol::Type(dunder_callable, boundness) =&gt; {
                let callable_type = callable_type.unwrap_or(dunder_callable);
                Some((dunder_callable.signatures(db, callable_type), boundness))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-15 12:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-15 12:29</div>
            <div class="timeline-body"><p>I just want to note quickly that there is a 2% incremental benchmark regression being reported for this PR, which <em>may</em> be due to the changes in the Salsa tracking that we're discussing in this thread? I think a 2% regression is probably fine, and we probably shouldn't overfit on <code>tomllib</code>[^1] So I'm not necessarily asking for any change here, just wanted to note that there is a <em>small</em> regression being reported by Codspeed.</p>
<p>[^1]: At some point we should add better benchmarks that also include red-knot being run on larger codebases, and on code that's less typed than tomllib, and on code that's generally lower quality than tomllib, and on code that contains bigger unions, etc. etc. etc. Once we've added those benchmarks, we'll have much better data on which exact functions should be Salsa-tracked and what the best granularity of caching is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-15 12:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3864 on 2025-03-15 12:39</div>
            <div class="timeline-body"><p>Consider implementing <code>IntoIterator</code> for <code>&amp;Bindings</code> and <code>&amp;mut Bindings</code>; it would mean we could avoid the explicit <code>.iter()</code> and <code>.iter_mut()</code> calls:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types.rs b/crates/red_knot_python_semantic/src/types.rs
index adad3f189..8d238378f 100644
--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -2647,7 +2647,7 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
     ) -&gt; Result&lt;Bindings&lt;'db&gt;, CallError&lt;'db&gt;&gt; {
         let signatures = self.signatures(db, self);
         let mut bindings = Bindings::bind(db, signatures, arguments).into_result()?;
-        for binding in bindings.iter_mut() {
+        for binding in &amp;mut bindings {
             // For certain known callables, we have special case logic to determine the return type
             // in a way that isn't directly expressible in the type system. Each special case
             // listed here should have a corresponding clause above in `signatures`.
diff --git a/crates/red_knot_python_semantic/src/types/call.rs b/crates/red_knot_python_semantic/src/types/call.rs
index 7d82d449e..b994c18de 100644
--- a/crates/red_knot_python_semantic/src/types/call.rs
+++ b/crates/red_knot_python_semantic/src/types/call.rs
@@ -10,7 +10,7 @@ pub(super) use bind::Bindings;
 /// Wraps a [`Bindings`] for an unsuccessful call with information about why the call was
 /// unsuccessful.
 #[derive(Debug, Clone, PartialEq, Eq)]
-pub(super) struct CallError&lt;'db&gt;(pub(super) CallErrorKind, pub(super) Box&lt;Bindings&lt;'db&gt;&gt;);
+pub(crate) struct CallError&lt;'db&gt;(pub(super) CallErrorKind, pub(super) Box&lt;Bindings&lt;'db&gt;&gt;);
 
 /// The reason why calling a type failed.
 #[derive(Debug, Clone, Copy, PartialEq, Eq)]
diff --git a/crates/red_knot_python_semantic/src/types/call/bind.rs b/crates/red_knot_python_semantic/src/types/call/bind.rs
index e2b6d24ac..e04e85867 100644
--- a/crates/red_knot_python_semantic/src/types/call/bind.rs
+++ b/crates/red_knot_python_semantic/src/types/call/bind.rs
@@ -128,7 +128,7 @@ impl&lt;'db&gt; Bindings&lt;'db&gt; {
         let mut all_ok = true;
         let mut any_binding_error = false;
         let mut all_not_callable = true;
-        for binding in self.iter() {
+        for binding in &amp;self {
             let result = binding.as_result();
             all_ok &amp;= result.is_ok();
             any_binding_error |= matches!(result, Err(CallErrorKind::BindingError));
@@ -149,14 +149,14 @@ impl&lt;'db&gt; Bindings&lt;'db&gt; {
         }
     }
 
-    pub(crate) fn iter(&amp;self) -&gt; impl Iterator&lt;Item = &amp;CallableBinding&lt;'db&gt;&gt; + '_ {
+    pub(crate) fn iter(&amp;self) -&gt; std::slice::Iter&lt;'_, CallableBinding&lt;'db&gt;&gt; {
         match &amp;self.inner {
             BindingsInner::Single(binding) =&gt; std::slice::from_ref(binding).iter(),
             BindingsInner::Union(bindings) =&gt; bindings.iter(),
         }
     }
 
-    pub(crate) fn iter_mut(&amp;mut self) -&gt; impl Iterator&lt;Item = &amp;mut CallableBinding&lt;'db&gt;&gt; + '_ {
+    pub(crate) fn iter_mut(&amp;mut self) -&gt; std::slice::IterMut&lt;'_, CallableBinding&lt;'db&gt;&gt; {
         match &amp;mut self.inner {
             BindingsInner::Single(binding) =&gt; std::slice::from_mut(binding).iter_mut(),
             BindingsInner::Union(bindings) =&gt; bindings.iter_mut(),
@@ -192,6 +192,24 @@ impl&lt;'db&gt; Bindings&lt;'db&gt; {
     }
 }
 
+impl&lt;'a, 'db&gt; IntoIterator for &amp;'a Bindings&lt;'db&gt; {
+    type Item = &amp;'a CallableBinding&lt;'db&gt;;
+    type IntoIter = std::slice::Iter&lt;'a, CallableBinding&lt;'db&gt;&gt;;
+
+    fn into_iter(self) -&gt; Self::IntoIter {
+        self.iter()
+    }
+}
+
+impl&lt;'a, 'db&gt; IntoIterator for &amp;'a mut Bindings&lt;'db&gt; {
+    type Item = &amp;'a mut CallableBinding&lt;'db&gt;;
+    type IntoIter = std::slice::IterMut&lt;'a, CallableBinding&lt;'db&gt;&gt;;
+
+    fn into_iter(self) -&gt; Self::IntoIter {
+        self.iter_mut()
+    }
+}
+
 /// Binding information for a single callable. If the callable is overloaded, there is a separate
 /// [`Binding`] for each overload.
 ///
diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index fde224c34..2da8a9df5 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -3861,7 +3861,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
         let call_arguments = self.infer_arguments(arguments, parameter_expectations);
         match function_type.try_call(self.db(), &amp;call_arguments) {
             Ok(bindings) =&gt; {
-                for binding in bindings.iter() {
+                for binding in &amp;bindings {
                     let Some(known_function) = binding
                         .signature
                         .callable_type
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2642 on 2025-03-15 12:43</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// the arguments are not compatible with the formal parameters.
    ///
    /// You get back a [`Bindings`] for both successful and unsuccessful calls.
    /// It contains information about which formal parameters each argument was matched to,
    /// and about any errors matching arguments and parameters.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2651 on 2025-03-15 12:43</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            // For certain known callables, we have special-case logic to determine the return type
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2683 on 2025-03-15 12:48</div>
            <div class="timeline-body"><p>you can reduce the indentation a little here:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types.rs b/crates/red_knot_python_semantic/src/types.rs
index adad3f189..306455196 100644
--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -2669,17 +2669,13 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                                 BoundMethodType::new(db, function, instance.to_meta_type(db)),
                             )));
                         }
-                    } else {
-                        if let Some(first) = arguments.first_argument() {
-                            if first.is_none(db) {
-                                overload.set_return_type(Type::FunctionLiteral(function));
-                            } else {
-                                overload.set_return_type(Type::Callable(
-                                    CallableType::BoundMethod(BoundMethodType::new(
-                                        db, function, first,
-                                    )),
-                                ));
-                            }
+                    } else if let Some(first) = arguments.first_argument() {
+                        if first.is_none(db) {
+                            overload.set_return_type(Type::FunctionLiteral(function));
+                        } else {
+                            overload.set_return_type(Type::Callable(CallableType::BoundMethod(
+                                BoundMethodType::new(db, function, first),
+                            )));
                         }
                     }
                 }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2959 on 2025-03-15 12:56</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let (signature, boundness) = self
            .dunder_signature(db, None, name)
            .ok_or(CallDunderError::MethodNotAvailable)?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2605 on 2025-03-15 13:07</div>
            <div class="timeline-body"><p>A small suggested tweak to the comment here: if a type has <code>__call__</code> set to <code>None</code>, it is not callable from the language's perspective: in order for an object to be callable, it has to have a <code>__call__</code> method that is itself callable. So it's a <em>little</em> confusing to say here that an object might be &quot;callable via a <code>__call__</code> method&quot; but then later in the same paragraph say that attempting to call the <code>__call__</code> method might then cause us to emit an error saying that &quot;<code>__call__</code> is not callable&quot;.</p>
<pre><code class="language-suggestion">                // Note that for objects that have a (possibly not callable!) `__call__` attribute,
                // we will get the signature of the `__call__` attribute, but will pass in the type
                // of the original object as the &quot;callable type&quot;. That ensures that we get errors
                // like &quot;`X` is not callable&quot; instead of &quot;`&lt;type of illegal '__call__'&gt;` is not
                // callable&quot;.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:13 on 2025-03-15 13:21</div>
            <div class="timeline-body"><p>could you add a comment saying that we use <code>Box&lt;Bindings&gt;</code> rather than simply <code>Bindings</code> because otherwise we would be passing around very large <code>Err</code> variants around on the stack? It wasn't immediately clear to me why we were doing the boxing here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:53 on 2025-03-15 13:25</div>
            <div class="timeline-body"><p>It seems like every time we call <code>Bindings::bind()</code> we immediately call <code>.into_result()</code> on it. And if I understand correctly, I think it would be incorrect to call <code>Bindings::bind()</code> and <em>not</em> call <code>.into_result()</code> on it (because then you would have constructed a <code>Bindings</code> that might represent a successful call <em>or</em> an unsuccessful call). So maybe <code>Bindings::bind()</code> should just return <code>Result&lt;Self, CallError&lt;'db&gt;&gt;</code> (and we get rid of <code>Bindings::into_result()</code>) rather than splitting the logic into two methods?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:65 on 2025-03-15 13:26</div>
            <div class="timeline-body"><p>you can <code>.collect()</code> directly into a boxed slice:</p>
<pre><code class="language-suggestion">            .collect();
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:266 on 2025-03-15 13:28</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            .collect();
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-15 13:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-03-15 13:32</div>
            <div class="timeline-body"><p>This looks great. Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:52 on 2025-03-15 14:18</div>
            <div class="timeline-body"><p>Ah yes! This is from an earlier version where we actually did panic, on the assumption that a union type is never empty. The rest of the code does assume that the <code>signatures</code> field is non-empty, so this should either panic as before or construct <code>non_callable</code> for an empty union. I'm putting it back to panicking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:108 on 2025-03-15 14:22</div>
            <div class="timeline-body"><p>I did have an enum before, actually, and then as part of @MichaReiser suggestion's to track/intern these structs, I moved it to a plain vector since (a) it made the code simpler and (b) the extra allocations for non-union non-overloaded callables mattered less when we were going through the extra work to have salsa track/intern the thing. Signatures are still only created inside of a salsa-tracked method, so (b) still seems to hold.</p>
<p>That said, I do like your <code>SmallVec&lt;1&gt;</code> idea as a way to get the best of both.  Will give that a shot.</p>
<p>Update: I'm getting salsa-related lifetime errors when switching to <code>SmallVec</code>, due to <code>Type::signatures</code> being marked <code>return_ref</code>. (Removing <code>return_ref</code> eliminates the lifetime errors.)  I'm going to table this for now, address the rest of the comments, and then come back to it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:108 on 2025-03-15 14:25</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:98 on 2025-03-15 14:55</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:136 on 2025-03-15 14:56</div>
            <div class="timeline-body"><p>Updated comment</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:30 on 2025-03-15 14:56</div>
            <div class="timeline-body"><p>Yep that's right</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:105 on 2025-03-15 14:58</div>
            <div class="timeline-body"><p>Works for me! This was me trying to faithfully mimic the logic that was there before, which also specifically put the errorful types at the end. The code is certainly simpler this way!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:59 on 2025-03-15 15:01</div>
            <div class="timeline-body"><blockquote>
<p>In principle it seems like <code>PossiblyNotCallable</code> and <code>BindingError</code> are orthogonal, so to flatten to a single enum we have to choose one of them to prioritize.</p>
</blockquote>
<p>This was me mimicking the previous behavior, where we were already making this prioritization.</p>
<blockquote>
<p>I'm not worried about the details of how that is reflected in diagnostics until we have the new diagnostics system in use, just about whether the representation is capable of carrying the necessary information.</p>
</blockquote>
<p>All of the information is definitely there in the bindings types themselves, so I'm not worried about being able to make this change as part of the larger diagnostics reworking. So I'd suggest holding off on that until then.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:58 on 2025-03-15 15:03</div>
            <div class="timeline-body"><p>No, for that either there's an overload that matches the argument list, in which case the <code>CallableSignature</code> is callable, or there isn't, in which case it's (completely, not possibly) non-callable.  <code>PossiblyNotCallable</code> only comes into play with union types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:103 on 2025-03-15 17:42</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:382 on 2025-03-15 17:43</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:742 on 2025-03-15 17:43</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:21 on 2025-03-15 17:49</div>
            <div class="timeline-body"><p>Reworded the comments for all three variants to hopefully be clearer</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2325 on 2025-03-15 18:10</div>
            <div class="timeline-body"><p>I had it before as <code>replace_type</code>, which I can bring back. Removing the interning might also help with the salsa lifetime errors I mention in another comment.  (I did not bring back the salsa-cached <code>overloads</code> functions that we had before â€” it's not clear that cloning the result from that salsa query will be faster than constructing a new <code>Signatures</code> on the fly for our special case methods.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2330 on 2025-03-15 18:27</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2658 on 2025-03-15 19:05</div>
            <div class="timeline-body"><p>It sure does, great catch!  Fixed and added an mdtest for this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2325 on 2025-03-15 19:06</div>
            <div class="timeline-body"><p>I removed the param but did a (hopefully) more thorough search/replace on this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2941 on 2025-03-15 19:06</div>
            <div class="timeline-body"><p>This function is gone now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3864 on 2025-03-15 19:16</div>
            <div class="timeline-body"><p>Done.  I did this for <code>CallableBinding</code>, too, as well as for the corresponding <code>Signatures</code> types</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2683 on 2025-03-15 19:17</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2959 on 2025-03-15 19:18</div>
            <div class="timeline-body"><p>I ended up inline the <code>dunder_signature</code> function so this is moot</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2605 on 2025-03-15 19:18</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:13 on 2025-03-15 19:20</div>
            <div class="timeline-body"><p>Done. (As an aside, it offends my sense of fairness that clippy thinks it's okay to pass around a large <code>Ok</code> variant! :smile:)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:53 on 2025-03-15 19:22</div>
            <div class="timeline-body"><p>Good idea, done.  (I kept <code>into_result</code> as a separate method since there are two return sites in <code>bind</code> and I wanted to avoid copy-pasting the logic twice.  But I made <code>into_result</code> private and called it on behalf of the caller.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:65 on 2025-03-15 19:24</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-15 19:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-15 19:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/signatures.rs</code>:108 on 2025-03-15 19:39</div>
            <div class="timeline-body"><p>With the other suggestions that led to us not tracking this function anymore, I got the <code>SmallVec</code> update to work.  Using that now for both signatures and bindings</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-15 19:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:53 on 2025-03-15 19:39</div>
            <div class="timeline-body"><p>hmm, did you maybe forget to commit and push that change? It looks to me like <code>into_result()</code> is still <code>pub(crate)</code> and <code>Bindings::bind()</code> still returns <code>Self</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-15 19:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:53 on 2025-03-15 19:48</div>
            <div class="timeline-body"><p>Gah, you're right! Not sure where that went. Pushed for real this time â€” and now with <code>SmallVec</code>, there <em>aren't</em> multiple return sites, and so I did into <code>into_result</code> into <code>bind</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4337 on 2025-03-15 19:53</div>
            <div class="timeline-body"><p>the TODO seems done?</p>
<pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2458 on 2025-03-15 19:55</div>
            <div class="timeline-body"><p>we could probably micro-optimize this slightly by doing an inner <code>match</code> over <code>class.known()</code> again rather than lots of <code>Type::ClassLiteral</code> branches with <code>if class.is_known()</code> guards</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-03-15 19:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4337 on 2025-03-15 20:00</div>
            <div class="timeline-body"><p>I think it's partly done; we still aren't handling <code>@overload</code> decorators, which I think are needed to address the first part of the TODO</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2458 on 2025-03-15 20:02</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-15 20:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4032 on 2025-03-15 20:42</div>
            <div class="timeline-body"><p>oops -- the change to the snapshot makes me realise that there was a pre-existing bug here; this should be</p>
<pre><code class="language-suggestion">                        and its `__getitem__` method (with type `{dunder_getitem_type}`) \
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-15 20:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-03-17 07:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @AlexWaygood on 2025-03-17 07:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-17 08:09</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>âœ… ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>âœ… ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-17 14:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4032 on 2025-03-17 14:10</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-17 14:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:30 on 2025-03-17 14:11</div>
            <div class="timeline-body"><p>(This is no longer relevant now that we're not <code>return_ref</code> tracking the <code>signatures</code> result)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-17 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2318 on 2025-03-17 14:12</div>
            <div class="timeline-body"><p>On the latest version of the PR, this seems now to be down to only a 1% regression</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-03-17 14:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-03-17 14:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-17 14:35</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:49:32 UTC
    </footer>
</body>
</html>
