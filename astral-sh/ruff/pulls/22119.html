<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Respect `fmt: skip` for multiple statements on same logical line - astral-sh/ruff #22119</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Respect <code>fmt: skip</code> for multiple statements on same logical line</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22119">#22119</a>
        opened by <a href="https://github.com/dylwil3">@dylwil3</a>
        on 2025-12-20 21:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a></div>
            <div class="timeline-body"><p>This PR adjusts the logic for skipping formatting so that a <code>fmt: skip</code> can affect multiple statements if they lie on the same line.</p>
<p>Specifically, a <code>fmt: skip</code> comment will now suppress all the statements in the suite in which it appears whose range intersects the line containing the skip directive. For example:</p>
<pre><code class="language-python">x=[
'1'
];x=2 # fmt: skip
</code></pre>
<p>remains unchanged after formatting.</p>
<p>(Note that compound statements are somewhat special and were handled in a previous PR - see #20633).</p>
<p>Closes #17331 and #11430.</p>
<p>Simplest to review commit by commit - the key diffs of interest are the commit introducing the core logic, and the diff between the snapshots introduced in the last commit (compared to the second commit).</p>
<h1>Implementation</h1>
<p>On <code>main</code> we format a suite of statements by iterating through them. If we meet a statement with a leading or trailing (own-line)<code>fmt: off</code> comment, then we suppress formatting until we meet a <code>fmt: on</code> comment. Otherwise we format the statement using its own formatting rule.</p>
<p>How are <code>fmt: skip</code> comments handled then? They are handled internally to the formatting of each statement. Specifically, calling <code>.fmt</code> on a statement node will first check to see if there is a trailing, end-of-line <code>fmt: skip</code> (or <code>fmt: off</code>/<code>yapf: off</code>), and if so then write the node with suppressed formatting.</p>
<p>In this PR we move the responsibility for handling <code>fmt: skip</code> into the formatting logic of the suite itself. This is done as follows:</p>
<ul>
<li>Before beginning to format the suite, we do a pass through the statements and collect the data of ranges with skipped formatting. More specifically, we create a map with key given by the <em>first</em> skipped statement in a block and value a pair consisting of the <em>last</em> skipped statement and the <em>range</em> to write verbatim.</li>
<li>We iterate as before, but if we meet a statement that is a key in the map constructed above, we pause to write the associated range verbatim. We then advance the iterator to the last statement in the block and proceed as before.</li>
</ul>
<h2>Addendum on range formatting</h2>
<p>We also had to make some changes to range formatting in order to support this new behavior. For example, we want to make sure that</p>
<pre><code class="language-python">&lt;RANGE_START&gt;x=1&lt;RANGE_END&gt;;x=2 # fmt: skip
</code></pre>
<p>formats verbatim, rather than becoming</p>
<pre><code class="language-python">x = 1;x=2 # fmt: skip
</code></pre>
<p>Recall that range formatting proceeds in two steps:</p>
<ol>
<li>Find the smallest enclosing node containing the range AND that has enough info to format the range (so it may be larger than you think, e.g. a docstring has enclosing node given by the suite, not the string itself.)</li>
<li>Carve out the formatted range from the result of formatting that enclosing node.</li>
</ol>
<p>We had to modify (1), since the suite knows how to format skipped nodes, but nodes may not &quot;know&quot; they are skipped. To do this we altered the <code>visit_body</code> bethod of the <code>FindEnclosingNode</code> visitor: now we iterate through the statements and check for skipped ranges intersecting the format range. If we find them, we return without descending. The result is to consider the statement containing the suite as the enclosing node in this case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @dylwil3 on 2025-12-20 21:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by @dylwil3 on 2025-12-20 21:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-20 21:53</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1027 on 2025-12-22 16:14</div>
            <div class="timeline-body"><p>If you don't like increasing the visibility of <code>NodeRefEqualityKey</code> there are other things we could do here. For example, we could enumerate with the indices of the statements within the suite - this has the downside of requiring lots of changes to code that expects to receive an <code>iter</code> over statements to instead receive an iter over pairs of indices and statements.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1042 on 2025-12-22 16:14</div>
            <div class="timeline-body"><p>Copying <code>NodeRefEqualityKey</code> is cheap right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/other/decorator.rs</code>:16 on 2025-12-22 16:16</div>
            <div class="timeline-body"><p>This is now the only place <code>suppressed_node</code> is used. Should we inline it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2025-12-22 16:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dylwil3 on 2025-12-22 16:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dylwil3 on 2025-12-22 16:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/lib.rs</code>:63 on 2025-12-22 16:41</div>
            <div class="timeline-body"><p>Let's add some new tests for range formatting a <code>fmt: skip</code>ed statement list</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1071 on 2025-12-22 16:48</div>
            <div class="timeline-body"><p>Could we extract this data in <code>Comments::from_ast</code> instead? That would fit better into the overall formatter design where there's one pre-processing pass to extract comments (which then are stored on <code>Comments</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1042 on 2025-12-22 16:48</div>
            <div class="timeline-body"><p>It's as cheap as copying a reference</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:200 on 2025-12-22 16:51</div>
            <div class="timeline-body"><p>Let's move this into a helper function similar to how we handle <code>fmt_off</code> comments and mark that function as cold. The function is already rather big</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:449 on 2025-12-22 16:52</div>
            <div class="timeline-body"><p>Is this whole block the same as above? Can we avoid duplicating the logic?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1031 on 2025-12-22 16:53</div>
            <div class="timeline-body"><p>What's the reason we need the last statement too? Would it be enough to test whether the next statement is covered by <code>verbatim_range</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1027 on 2025-12-22 16:55</div>
            <div class="timeline-body"><p>Would it be possible to use an interval map (<code>Vec&lt;TextRange&gt;</code>) over an <code>FxHashMap</code> keyed by <code>NodeRefEqualityKey</code>. A node is suppressed if its range intersects with any range in the interval map.</p>
<p>(Similar to <code>ExpressionsScopeMap</code> in ty but for ranges instead of node ids https://github.com/astral-sh/ruff/blob/b4c2825afdd8c1010c3a5859521629d2d1e0a6df/crates/ty_python_semantic/src/semantic_index.rs#L734)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1079 on 2025-12-22 16:56</div>
            <div class="timeline-body"><p>It's rather unfortunate that this is <code>O(statements)</code> rather than <code>O(comments)</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-22 16:57</div>
            <div class="timeline-body"><p>Thanks for looking into this long standing issues.</p>
<p>I haven't done an in-depth review but I left some initial questions. We can also use our 1:1 to discuss some of them</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-22 18:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1106 on 2025-12-22 18:17</div>
            <div class="timeline-body"><p>Looking at this code makes me wonder whether we need the pre-processing at all.</p>
<p>Given the current statement and an <code>std::slice::Iter</code> (that you can cheaply clone) over the remaining statements: Can't we implement this roughly like this:</p>
<pre><code class="language-rust">let Some(mut trailing_semicolon) = trailing_semicolon(stmt.into(), source) else {
	return; 
}


let mut lookahead = statements_iter.clone();
while let Some(next_statement) = lookahead.next() {
	if has_skip_comment(next_statement) {
		break;
	} else if let Some(trailing) = trailing_semicolon(next_statement.into()) {
		trailing_semicolon = trailing;
		// Keep going
	} else {
		// Has no skip comment
		return false;
}

// Call fmt:skip suppressed formatting, passing in the original `statements_iter` (and move it forward
</code></pre>
<p>The downside of this approach is that it's <code>O(n^2)</code> where <code>n</code> is the number of statements on the same line. But I'm not sure this is a big issue because a) it would only be slow on the first format call and b) it's unlikely anyone has that many statements on a single line for this to be an issue.</p>
<p>If this indeed becomes a problem, we can then add a caching similar to your <code>FxHashMap</code> where we store the already checked ranges, so that we skip the same work on the next call.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-22 20:28</div>
            <div class="timeline-body"><p>Regarding the benchmark. I don't think using hyperfine will give you meaningful numbers. There's just too much overhead in ruff's cli (config discovery, directory walking, io) in addition to the noise of measuring a cli tool.</p>
<p>If you want to get meaningful numbers, I suggest adding a benchmark to ruff_benchmark. Even if it's just locally</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @dylwil3 on 2025-12-26 21:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Respect `fmt: skip` for multiple statements on same line" to "Respect `fmt: skip` for multiple statements on same logical line" by @dylwil3 on 2026-01-05 17:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:976 on 2026-01-05 20:35</div>
            <div class="timeline-body"><p>I experimented with computing the tokens within the suite range just once, then passing the slice along to this method and mutating it like</p>
<pre><code>tokens = tokens[last_statement.end()..]
</code></pre>
<p>as I went along. I thought this could help performance since then the binary search should terminate more quickly, but this did not lead to an improvement compared to the present approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@fmt_skip__semicolons.py.snap</code>:178 on 2026-01-05 20:37</div>
            <div class="timeline-body"><p>See #22406</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:983 on 2026-01-05 22:02</div>
            <div class="timeline-body"><p>It is tempting to do something like check the source code directly for a newline. This does not work because there may be a line continuation character. So maybe you could get around that, but how do you know it's a line continuation character instead of something like:</p>
<pre><code class="language-python">x=1 # a comment with _not_ a line continuation \
x=2
</code></pre>
<p>At this point it seemed like we were re-inventing lexing, so why not use the tokens instead? There is the cost of the binary searches, but in the most common case we only do it once per statement in the suite, and it appears to not affect performance very much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2026-01-05 22:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dylwil3 on 2026-01-05 22:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-05 22:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:976 on 2026-01-05 22:12</div>
            <div class="timeline-body"><p>Could we use the simple tokenizer instead (it has the advantage that it doesn't require O(n) scanning, instead, it's a single lookahead at the current text position)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-05 22:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:983 on 2026-01-05 22:13</div>
            <div class="timeline-body"><p>It seems <code>SimpleTokenizer</code> does support <code>Continuation</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2026-01-05 23:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:976 on 2026-01-05 23:26</div>
            <div class="timeline-body"><p>Nice, thanks! That's a little perf bump... although it's hard to tell whether it was just noise - the actual diffs in the perf comparison aren't very illuminating. In any case we can use the <code>SimpleTokenizer</code> if it's preferred!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-06 08:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:976 on 2026-01-06 08:01</div>
            <div class="timeline-body"><p>I would prefer it simply because it's what we use almost everywhere in the formatter.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:966 on 2026-01-06 08:11</div>
            <div class="timeline-body"><p>and use <code>iter.as_slice()</code> at the call site</p>
<pre><code class="language-suggestion">    statements: &amp;[Stmt],
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1004 on 2026-01-06 08:25</div>
            <div class="timeline-body"><p>I always feel a bit uneasy about tokenizer calls where we have a blanket match arm that eats over any tokens.</p>
<p>I would write this as</p>
<pre><code class="language-rust">    while let Some(token) = tokenizer.next() {
        match token {
            SimpleTokenKind::Continuation =&gt; {
                // Skip over the newline
                tokenizer.next();
            }
            SimpleTokenKind::Newline =&gt; {
                return true;
            }
            kind =&gt; {
                if !kind.is_trivia() {
                    return false;
                }
            }
        }
    }
</code></pre>
<p>We could even consider making the <code>kind.is_trivia</code> a debug assertion</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/verbatim.rs</code>:466 on 2026-01-06 08:39</div>
            <div class="timeline-body"><p>I think you could use <code>statements.peeking_next</code> here instead of <code>statements.clone().next</code></p>
<pre><code class="language-suggestion">    while let Some(prec) = statements.peeking_next(|next| next.end() &lt;= verbatim_range.end())
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:970 on 2026-01-06 08:42</div>
            <div class="timeline-body"><p>I think it would be ncie if we wouldn't need <code>new_logical_line_between_statements</code> and instead could use <code>trailing_semicolon</code> directly because both functions give you the same answer: Are these multiple statements on a single line.</p>
<p>I did try to rewrite the function to only make use of <code>trailing_semicolon</code> but I messed up somewhere. Maybe you've an idea on how to make it work, this is what I ended up with:</p>
<pre><code class="language-rust">    let source = f.context().source();
    let comments = f.context().comments();
    let start = first.start();

    // Handle the common case first where a statement has no trailing semicolon.
    let Some(trailing_semicolon) = trailing_semicolon(first.into(), source) else {
        return if has_skip_comment(comments.trailing(first), source) {
            Some(first.range())
        } else {
            None
        };
    };

    let mut last_statement = first;
    let mut end = trailing_semicolon.end();

    for statement in statements.clone() {
        last_statement = statement;

        if let Some(trailing_semicolon) =
            crate::statement::trailing_semicolon(statement.into(), source)
        {
            end = trailing_semicolon.end();
        } else {
            end = statement.end();
            break;
        }
    }

    if has_skip_comment(comments.trailing(last_statement), source) {
        Some(TextRange::new(start, end))
    } else {
        None
    }
</code></pre>
<p>And I changed <code>trailing_semicolon</code> to:</p>
<pre><code class="language-rust">pub(super) fn trailing_semicolon(node: AnyNodeRef, source: &amp;str) -&gt; Option&lt;TextRange&gt; {
    debug_assert!(node.is_statement());

    let mut tokenizer = SimpleTokenizer::starts_at(node.end(), source);

    while let Some(token) = tokenizer.next() {
        match token.kind() {
            SimpleTokenKind::Continuation =&gt; {
                // Skip over the newline
                tokenizer.next();
            }
            SimpleTokenKind::Newline =&gt; {
                return None;
            }
            SimpleTokenKind::Semi =&gt; {
                return Some(token.range());
            }
            kind if kind.is_trivia() =&gt; {
                // continue
            }
            _ =&gt; {
                return None;
            }
        }
    }

    None
}

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/fmt_skip/semicolons.py</code>:8 on 2026-01-06 08:45</div>
            <div class="timeline-body"><p>Let's add an example with a trailing semicolon</p>
<pre><code class="language-suggestion">    x=2;x=3.  ; # fmt: skip
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@range_formatting__fmt_skip.py.snap</code>:80 on 2026-01-06 08:52</div>
            <div class="timeline-body"><p>The outputs here look wrong to me. I would expect <code>x=1</code> and <code>x=3</code> to be formatted.</p>
<p>This may be a pre-existing bug, in which case we can fix it separately but we should verify that this is indeed the case (and isn't an issue with how we emit source positions in this new PR)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-06 08:53</div>
            <div class="timeline-body"><p>Nice, this looks pretty simple now.</p>
<p>Do we still need the <code>is_suppressed</code> logic in the statement formatting?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2026-01-06 12:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:970 on 2026-01-06 12:17</div>
            <div class="timeline-body"><blockquote>
<p>and instead could use trailing_semicolon directly because both functions give you the same answer: Are these multiple statements on a single line.</p>
</blockquote>
<p>I can try but is this really true?</p>
<pre><code class="language-python">x = 1;
x = 2
</code></pre>
<p>The first statement has a trailing semicolon but they are on different logical lines.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-06 12:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:970 on 2026-01-06 12:20</div>
            <div class="timeline-body"><p>You're right, we need the newline handling</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2026-01-06 13:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1004 on 2026-01-06 13:58</div>
            <div class="timeline-body"><p>I'll add this but observe that, since we are specifically in a range between statements, I don't think any non-trivia tokens can actually occur.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2026-01-09 21:23</div>
            <div class="timeline-body"><p>While fixing the behavior for range formatting, I noticed that, unrelated to any suppression comments, we do the following:</p>
<pre><code class="language-python">x=1;&lt;RANGE_START&gt;x=2&lt;RANGE_END&gt;
</code></pre>
<p>becomes:</p>
<pre><code class="language-python">x=1;    x = 2
</code></pre>
<p>Is this expected or should I make an issue for it?</p>
<p>The enclosing node of the range here is correctly determined to be the full suite (because it can't find the indentation for <code>x=2</code>), but then something must go wrong when narrowing from the formatted</p>
<pre><code class="language-python">x=1
x=2
</code></pre>
<p>back down. My guess is that this comes down to the <code>is_logical_line</code> helper being not quite right, or else maybe we aren't emitting/interpreting source positions correctly here? I haven't looked closely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2026-01-09 21:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:1004 on 2026-01-09 21:35</div>
            <div class="timeline-body"><p>I ended up keeping this as is but adding a comment with the justification I gave above - let me know if you feel strongly and I'll commit your suggestion!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dylwil3 on 2026-01-09 21:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2026-01-09 21:38</div>
            <div class="timeline-body"><p>As you predicted, removing <code>is_suppressed</code> got rid of what little perf regression was left: https://codspeed.io/astral-sh/ruff/runs/compare/69615827861fdc44a0a9aaea..6961718d1af8d4524db090e5</p>
<p>(except for a teensy one on <code>numpy/globals.py</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-10 09:44</div>
            <div class="timeline-body"><blockquote>
<p>Is this expected or should I make an issue for it?</p>
</blockquote>
<p>Yeah, this looks very wrong. Opening an issue for it would be great</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/decorator.rs</code>:15 on 2026-01-10 09:46</div>
            <div class="timeline-body"><p>I don't think it's necessary to clone <code>comments</code> here because we don't borrow them across a <code>write!( or </code>fmt` call</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/decorator.rs</code>:18 on 2026-01-10 09:48</div>
            <div class="timeline-body"><p>We only need the trailing comments</p>
<pre><code class="language-rust">        let trailing_comments = comments.trailing(item);

        if has_skip_comment(trailing_comments, f.context().source()) {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/range.rs</code>:273 on 2026-01-10 09:50</div>
            <div class="timeline-body"><p>Do we need to reset <code>self.suppressed</code> even when early exiting? Maybe just break here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2026-01-10 09:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dylwil3 on 2026-01-10 14:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dylwil3 on 2026-01-10 14:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/madduck">@madduck</a> on 2026-01-11 21:46</div>
            <div class="timeline-body"><p>Thanks a lot for your work on this @dylwil3, and everyone who was also involved! ♥</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:18:18 UTC
    </footer>
</body>
</html>
