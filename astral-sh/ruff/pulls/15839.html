<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Should A ∧ !A always be false? - astral-sh/ruff #15839</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Should A ∧ !A always be false?</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15839">#15839</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-01-30 22:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>This mimics a simplification we have on the OR side, where we simplify <code>A ∨ !A</code> to true.  This requires changes to how we add <code>while</code> statements to the semantic index, since we now need distinct <code>VisibilityConstraint</code>s if we need to model evaluating a <code>Constraint</code> multiple times at different points in the execution of the program.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-01-30 22:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dcreager on 2025-01-30 22:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-01-30 22:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dcreager on 2025-01-30 22:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @dcreager on 2025-01-30 22:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @dcreager on 2025-01-30 22:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-31 00:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2025-01-31 00:53</div>
            <div class="timeline-body"><p>I don't think this holds, because we are dealing with three-valued logic (there is the <code>Ambiguous</code> possibility), and a value of <code>Ambiguous</code> truthiness can change truthiness between one time it is checked and another.</p>
<p>Multiple checks of the truthiness of the same condition only occur in while loops, which is why all of the test failures occur in while-loop tests. This PR models the premise that a while-loop test can never change truthiness over time, which would indeed lead to the conclusion seen in the test failures, that a <code>while</code> loop with no <code>break</code> must either be never entered at all, or must be an infinite loop once entered.</p>
<p>I think in order for this PR to be valid, we would need to create two separate visibility constraints for the same while-loop test expression, one for &quot;as checked on first entry&quot; and another for &quot;as checked on subsequent iteration&quot;, so that we wouldn't actually see those as &quot;the same constraint&quot;, and would thus model the possibility of entering the loop and then leaving it on a later iteration. (I think this same change in <code>while</code> loop visibility constraints would be necessary if we switch to BDDs for visibility constraints.)</p>
<p>I think technically the existing OR simplification is wrong for the same reason? But in practice it doesn't cause a problem, either because the OR simplification case doesn't arise with while loops, or because simplifying to <code>ALWAYS_TRUE</code> doesn't lead us to eliminate paths as unreachable, or for both reasons.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-31 00:56</div>
            <div class="timeline-body"><p>cc @sharkdp, you might find this interesting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-31 01:26</div>
            <div class="timeline-body"><blockquote>
<p>a value of <code>Ambiguous</code> truthiness can change truthiness between one time it is checked and another.</p>
</blockquote>
<p>Yep, that makes sense!  The part that I wasn't sure about was what the scope of &quot;one time it is checked and another&quot; is.  My intuition would be that a literal (in the boolean formula sense, not the Python source sense) might evaluate to <code>Ambiguous</code>, meaning that we don't know if it's true or false — but that within the context of a particular evaluation of the boolean formula, it would have the same true or false value each time it appears.  Which would make <code>A ∧ !A == 0</code> hold.</p>
<blockquote>
<p>Multiple checks of the truthiness of the same condition only occur in while loops, which is why all of the test failures occur in while-loop tests.</p>
</blockquote>
<p>Or put another way, while-loop tests are the only place (at least for now) where we need a visibility constraint to model the relationship between two different states in the execution trace of the program.</p>
<blockquote>
<p>I think technically the existing OR simplification is wrong for the same reason?</p>
</blockquote>
<p>Definitely agree — and I think that's a better wording of my question! :smile:   Either both <code>A ∧ !A == 0</code> and <code>A ∨ !A == 1</code> should hold, or neither should.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-31 01:34</div>
            <div class="timeline-body"><blockquote>
<p>within the context of a particular evaluation of the boolean formula, it would have the same true or false value each time it appears</p>
</blockquote>
<p>The problem is that we construct boolean formulae (for visibility of paths through a <code>while</code> loop) which contain a single constraint that represents checks of the while-test expression's truthiness at different points in execution state (first entry vs later iteration). Because we do this, we create the scenario that &quot;the same constraint&quot; in the same boolean formula doesn't necessarily have a consistent truthiness value, even for a single evaluation of the formula.</p>
<p>If we instead created separate visibility constraints (referring to the same test expression) for the truthiness checks in these two different execution states, then the simplification would hold. (I think this change in the semantic index builder's handling of <code>while</code> loops would not be too difficult, but I haven't tried to make the change.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-31 01:43</div>
            <div class="timeline-body"><p>Once we model the back-edge in control flow in a while loop, we <em>could</em> even evaluate the test expression under two different conditions, one without the back-edge (for first entry) and one with the back-edge (for later iteration). This could change our evaluation of its static truthiness, too. (Imagine an <code>x = True; while x: x = get_bool()</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-31 17:36</div>
            <div class="timeline-body"><blockquote>
<p>I think in order for this PR to be valid, we would need to create two separate visibility constraints for the same while-loop test expression, one for &quot;as checked on first entry&quot; and another for &quot;as checked on subsequent iteration&quot;, so that we wouldn't actually see those as &quot;the same constraint&quot;, and would thus model the possibility of entering the loop and then leaving it on a later iteration. (I think this same change in <code>while</code> loop visibility constraints would be necessary if we switch to BDDs for visibility constraints.)</p>
</blockquote>
<p>This is done!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1012 on 2025-01-31 17:48</div>
            <div class="timeline-body"><p>Doesn't <code>(first ∨ (first ∧ later))</code> simplify to just <code>first</code>? If <code>first</code> is true, it is always true; if <code>first</code> is false, it is always false.</p>
<p>Which I think is also intuitive, because for the body of the while loop to be reachable, it is both necessary and sufficient that the first evaluation of the test condition be truthy.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:990 on 2025-01-31 17:58</div>
            <div class="timeline-body"><p>I wonder if this could be a bit more ergonomic, and not have to expose <code>VisibilityConstraintAtom</code> and the implementation detail of its internal <code>u8</code> to the semantic index builder? But I see there are complexities there, and with only one call site at the moment I don't think it matters much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-31 17:59</div>
            <div class="timeline-body"><p>Looks like this fixes the test failures, sweet!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1012 on 2025-01-31 18:21</div>
            <div class="timeline-body"><p>Yes, good catch!  I had thought I needed to assert that later evaluations of the condition also evaluate to true.  But this shows that that's not the right interpretation — we don't know that we <em>did</em> evaluate the condition a second time, and so executing the body does not imply that (there was) a later evaluation (and it) evaluated to true.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:990 on 2025-01-31 18:22</div>
            <div class="timeline-body"><p>Done. I removed the <code>Atom</code> wrapper.  My thought here was to reduce the number of <code>, 0</code>s I'd have to add, but most of those were already hidden behind helper methods</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-31 18:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-31 18:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:990 on 2025-01-31 18:31</div>
            <div class="timeline-body"><p>(Making the <code>u8</code> not visible at all would be more invasive, since that's how the caller up in the semantic index builder specifies that it wants distinct copies.  It's up to the caller to choose the values, such that distinct <code>u8</code>s refer to different evaluations of the constraint.  Do you have thoughts on a different API shape to express that?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:990 on 2025-01-31 18:48</div>
            <div class="timeline-body"><p>I think I was vaguely envisioning some kind of <code>copy</code> API that would take an existing constraint ID and bump the counter behind the scenes. But the awkwardness there is that a constraint ID might not represent a <code>VisibleIf</code> constraint at all, making the API error prone. So I'm not sure that would be an improvement. It's already much nicer without the extra <code>Atom</code> type, I think what you have is good.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 18:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-31 18:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-01-31 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-01-31 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-31 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/visibility_constraints.rs</code>:185 on 2025-01-31 20:40</div>
            <div class="timeline-body"><p>It's late here already, but just reading this, I wonder why it applies to while conditions, but not to something like</p>
<pre><code class="language-py">for _ in iterable:
    if &lt;cond&gt;:
        # …
</code></pre>
<p>Is it because we merge control flow twice here (after the if, after the for) instead of just once in the while loop? Would a <code>break</code> point inside the <code>if</code> complicate the situation?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 20:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/visibility_constraints.rs</code>:185 on 2025-01-31 20:49</div>
            <div class="timeline-body"><p>~I think it's because currently a <code>for</code> loop generates no visibility constraints. (We don't attempt to detect statically-known-empty iterables.) If we did add that feature, we might need to consider this, but I'm still not sure it would apply unless we also tried to detect statically-known-infinite iterables! Which I doubt we would ever do.~</p>
<p>EDIT: ignore the above, I totally missed the point of your comment, which was the nested <code>if</code> test. Thinking about it...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 20:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 21:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/visibility_constraints.rs</code>:185 on 2025-01-31 21:19</div>
            <div class="timeline-body"><p>Not sure I've totally thought through all the possible concrete visibility constraint trees we might generate here, but my intuition says it's not an issue in this scenario, because there is no difference between any one iteration of the loop and any other one, in terms of the effect on which code is visible or not. Which is not true in a <code>while</code> loop, where the key fact is that a static <code>True</code> means we'll never exit the loop, a static <code>False</code> means we'll never enter it, and a <code>True</code> that later changes to <code>False</code> means we can enter and then exit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 08:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/visibility_constraints.rs</code>:185 on 2025-02-03 08:08</div>
            <div class="timeline-body"><p>It seems to me like the following two are similar control flow constructs (ignoring <code>else</code> branches in loops…):</p>
<pre><code class="language-py">while cond:
    # &lt;code block&gt;
</code></pre>
<p>and</p>
<pre><code class="language-py">for _ in itertools.repeat(None):
    if not cond:
        break
    # &lt;code block&gt;
</code></pre>
<p>It looks like we can handle the former, but not the latter:</p>
<pre><code class="language-py">import itertools

cond = False

w = 1
f = 1

while cond:
    w = 2

for _ in itertools.repeat(None):
    if not cond:
        break

    f = 2

print(reveal_type(w))  # Literal[1]
print(reveal_type(f))  # Literal[1, 2] ?
</code></pre>
<p>Or am I missing something? This might not be related to this PR at all(?).</p>
<p>(Edit: I guess I could only expect the latter to be working with https://github.com/astral-sh/ruff/pull/15817)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-03 14:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/visibility_constraints.rs</code>:185 on 2025-02-03 14:17</div>
            <div class="timeline-body"><p>I think it's more than #15817. The latter example is only equivalent to the former if we are able to detect that an iterator is infinite. This is not reflected in the type system, and would require special casing for certain iterables (like ‘itertools.repeat`); it's not possible in general.</p>
<p>If the iterator is not infinite (or not known to be infinite), then exit from the loop is always possible at every iteration, regardless of the value of <code>cond</code>, and the result we currently give is correct.</p>
<p>Detecting known-empty iterators and their effect on <code>for</code> loop control flow is similarly difficult to do in general.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:09:37 UTC
    </footer>
</body>
</html>
