```yaml
number: 12716
title: "[red-knot] Derive `site-packages` from a venv path"
type: pull_request
state: merged
author: AlexWaygood
labels:
  - ty
assignees: []
merged: true
base: main
head: alex/derive-site-packages
created_at: 2024-08-06T14:41:13Z
updated_at: 2024-08-07T07:08:25Z
url: https://github.com/astral-sh/ruff/pull/12716
synced_at: 2026-01-12T15:55:42Z
```

# [red-knot] Derive `site-packages` from a venv path

---

_@AlexWaygood_

## Summary

This adds very basic `site-packages` discovery to red-knot: if we're passed a path to a virtual environment, we figure out where the `site-packages` directory is inside that virtual environment. There are however several subtleties to take note of:
- On Windows `site-packages` is always found in a `Lib/site-packages` subdirectory of the venv directory.
- On Unix:
  - If you're on a free-threaded build (only applicable to Python 3.13 and newer), `site-packages` could be in one or both of the following subdirectories:
    - `lib/python3.${MINOR_VERSION}t/site-packages`
    - `lib64/python3.${MINOR_VERSION}t/site-packages`
  - Otherwise, `site-packages` will be in one or both of the following subdirectories:
    - `lib/python3.${MINOR_VERSION}/site-packages`
    - `lib64/python3.${MINOR_VERSION}/site-packages`

Some further notes on the Unix variants:
- If the `sys`-module documentation is to be believed, we can safely ignore the `lib64` `site-packages` variants, since they are only used for C extensions, which we don't care about.
- The `MINOR_VERSION` cannot be inferred from the `--target-version` passed by the user, since they might be asking us to type check they're code "as if" they're running Python 3.8 (the lowest version of Python their library supports) even though they're running Python 3.12 locally.

## Test Plan

I verified that red-knot was able to successfully find `site-packages` directories from existing virtual environments by running commands such as `cargo run -p red_knot -- -v --venv-path .venv` locally.

I haven't added any tests as part of this PR yet. I'm happy to do so if we think they'd be valuable, but they might be quite complex to set up. (I think the only way to write a test that actually makes useful assertions would be to create a Python virtual environment in the test and then verify that red-knot is able to find the `site-packages` directory inside that virtual environment.)


---

_Label `red-knot` added by @AlexWaygood on 2024-08-06 14:41_

---

_Review requested from @carljm by @AlexWaygood on 2024-08-06 14:41_

---

_Review requested from @MichaReiser by @AlexWaygood on 2024-08-06 14:41_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:142 on 2024-08-06 14:48_

Planning on tackling this TODO in a followup. I wanted to keep the logic in this PR as simple as possible for now.

---

_@AlexWaygood reviewed on 2024-08-06 14:48_

---

_@MichaReiser reviewed on 2024-08-06 14:49_

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 14:49_

Could you tell me more about how such a setup looks like? Would they create a windows venv on linux? How would that be done?

I think a test for this would be valuable. We can simply commit a test project. Take a look at uv's [test workspaces](https://github.com/astral-sh/uv/tree/main/scripts/workspaces)

---

_@AlexWaygood reviewed on 2024-08-06 14:55_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 14:55_

You're on Windows (because it's the weekend, and you're away from the office, and your personal computer is a Windows machine for some reason), and you create a Windows virtual environment, but you pass `--platform=linux` to red-knot, because you know that in production your servers run on Linux, and you want to emulate the production environment when you're type-checking things locally.

The `--platform=linux` argument allows red-knot to statically infer that [branches like this](https://github.com/python/typeshed/blob/8a7f09e3511f3a1d04281c60167b8dcc3b78938b/stdlib/time.pyi#L13-L14) in stubs are always true for type-checking purposes, and that [branches like this](https://github.com/python/typeshed/blob/8a7f09e3511f3a1d04281c60167b8dcc3b78938b/stdlib/time.pyi#L28-L32) are always false. (This is [specified in the typing spec](https://typing.readthedocs.io/en/latest/spec/directives.html#version-and-platform-checking).)

However, when it comes to figuring out where the `site-packages` directory is in the virtual environment, the `--platform` argument is totally irrelevant. We need to figure out the actual platform of the host machine (which in this case is Windows), not the `--platform` argument that the user may or may not have passed.

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 14:59_

(We don't actually have a `--platform` argument yet for red-knot, but this is something that all other Python type checkers offer.)

---

_@AlexWaygood reviewed on 2024-08-06 14:59_

---

_Comment by @github-actions[bot] on 2024-08-06 14:59_

<!-- generated-comment ecosystem -->
## `ruff-ecosystem` results
### Linter (stable)
✅ ecosystem check detected no linter changes.

### Linter (preview)
✅ ecosystem check detected no linter changes.

### Formatter (stable)
ℹ️ ecosystem check **encountered format errors**. (no format changes; 1 project error)

<details><summary><a href="https://github.com/openai/openai-cookbook">openai/openai-cookbook</a> (error)</summary>
<p>

```
warning: Detected debug build without --no-cache.
error: Failed to parse examples/Chat_finetuning_data_prep.ipynb:6:18:25: Unparenthesized generator expression cannot be used here
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_confluence.ipynb:15:1:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_gmail.ipynb:15:1:1: Expected an expression
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_jira.ipynb:15:1:1: Expected an expression
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_notion.ipynb:15:1:1: Expected an expression
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc.ipynb:28:1:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text.ipynb:28:1:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_sql_database.ipynb:2:2:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function.ipynb:37:1:13: Simple statements must be separated by newlines or semicolons
```

</p>
</details>

### Formatter (preview)
ℹ️ ecosystem check **encountered format errors**. (no format changes; 1 project error)

<details><summary><a href="https://github.com/openai/openai-cookbook">openai/openai-cookbook</a> (error)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

```
warning: Detected debug build without --no-cache.
error: Failed to parse examples/Chat_finetuning_data_prep.ipynb:6:18:25: Unparenthesized generator expression cannot be used here
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_confluence.ipynb:15:1:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_gmail.ipynb:15:1:1: Expected an expression
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_jira.ipynb:15:1:1: Expected an expression
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_notion.ipynb:15:1:1: Expected an expression
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_doc.ipynb:28:1:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_sharepoint_text.ipynb:28:1:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_action_sql_database.ipynb:2:2:5: Simple statements must be separated by newlines or semicolons
error: Failed to parse examples/chatgpt/gpt_actions_library/gpt_middleware_azure_function.ipynb:37:1:13: Simple statements must be separated by newlines or semicolons
```

</p>
</details>




---

_@AlexWaygood reviewed on 2024-08-06 16:06_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 16:06_

> I think a test for this would be valuable. We can simply commit a test project. Take a look at uv's [test workspaces](https://github.com/astral-sh/uv/tree/main/scripts/workspaces?rgh-link-date=2024-08-06T14%3A49%3A10Z)

In order to create a realistic temporary virtual environment to use as part of a test, I believe we'll need to have our tests depend on either Python or uv (we'll need to use one or the other to create the virtual environment). Do you have a preference?

---

_@MichaReiser reviewed on 2024-08-06 16:14_

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 16:14_

Thanks for the explanation but I think I'm now more confused than before :laughing: 

> However, when it comes to figuring out where the site-packages directory is in the virtual environment, the --platform argument is totally irrelevant.

Wouldn't that mean that we could just use `if cfg!(target_os = "windows") { .... }`?

> , I believe we'll need to have our tests depend on either Python or uv (we'll need to use one or the other to create the virtual environment). Do you have a preference?

I would just commit the created venv. 




---

_@AlexWaygood reviewed on 2024-08-06 16:16_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 16:16_

> Wouldn't that mean that we could just use `if cfg!(target_os = "windows") { .... }`?

Yes, that also works!

> I would just commit the created venv.

Ah, that's a nice idea

---

_@MichaReiser reviewed on 2024-08-06 16:25_

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 16:25_

> Yes, that also works!

Oh okay. In that case, I would prefer to use `cfg` because we then only ship the relevant code in the released binary. It's also how we do this kind of branching in `uv`.

---

_@AlexWaygood reviewed on 2024-08-06 16:27_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:15 on 2024-08-06 16:27_

Yes, that makes sense. I forgot that `cfg` was the Rusty way of doing this kind of thing. I'm working on the changes :-)

---

_Comment by @AlexWaygood on 2024-08-06 16:44_

Okay, I created an empty venv using `uv` and committed it to `red_knot_workspace/resource/test/empty-test-venv`, so that I could add a test

---

_Review requested from @MichaReiser by @AlexWaygood on 2024-08-06 16:44_

---

_Review comment by @carljm on `crates/red_knot_workspace/resources/test/empty-test-venv/bin/activate`:1 on 2024-08-06 16:47_

Personally I'd be inclined to remove some totally-irrelevant files from the virtualenv (all the activate scripts), but it's not a big deal either way.

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 16:55_

This routine (at least as currently written) isn't really specific to a venv, it's just encoding knowledge about Python installation layouts in general. Given a Python binary, you go up one directory to find the "base" of the installation (which could be a venv, or not), and there you expect to find `lib/` or `Lib/`. I would be inclined to name the functions accordingly and not over-fit to the case of a virtualenv; we should also support non-virtualenv Pythons.

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:82 on 2024-08-06 16:56_

If you're going to tackle system site packages as a follow up, it seems like the need to parse `pyvenv.cfg` is going to come quite soon?

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:86 on 2024-08-06 16:56_

In the non-Windows case, do we not validate that `site-packages` actually exists and is a directory?

---

_@carljm approved on 2024-08-06 16:57_

---

_@AlexWaygood reviewed on 2024-08-06 16:58_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:82 on 2024-08-06 16:58_

Spoilers!

---

_@AlexWaygood reviewed on 2024-08-06 17:01_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:86 on 2024-08-06 17:01_

Oh, good point. We verify that `<venv_path>/lib` exists and is a directory, but not `<venv_path>/lib/site-packages`. This is a result of some refactoring I did of my patch while working on it; good catch.

---

_@carljm reviewed on 2024-08-06 17:02_

---

_Review comment by @carljm on `crates/red_knot/src/main.rs`:50 on 2024-08-06 17:02_

Along the lines of another comment below -- could we make this more general and just take the path to a Python binary to use? Virtual environments are not that "special" , and I don't think our CLI should make them seem more special than they are. We can easily support both virtual and non-virtual Python installations, and I think we should.

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:05_

Are you sure you can generalise to that extent? For example, here's what I get with my Brew-installed system Python installation:

```pycon
/dev % /opt/homebrew/bin/python
Python 3.12.4 (main, Jun  6 2024, 18:26:44) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import site, sys
>>> sys.executable
'/opt/homebrew/opt/python@3.12/bin/python3.12'
>>> site.getsitepackages()
['/opt/homebrew/opt/python@3.12/Frameworks/Python.framework/Versions/3.12/lib/python3.12/site-packages']
```

---

_@AlexWaygood reviewed on 2024-08-06 17:05_

---

_@carljm reviewed on 2024-08-06 17:16_

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:16_

Pretty sure, yeah :) The behavior of "start with binary location, go up one directory, then look for `lib/...` (specifically it looks for the `os.py` file in the standard library) is hardcoded directly into CPython as the way to determine where the standard library is found in the first place, so someone would have to change that code in CPython itself to change that behavior.

Of course it is possible to modify `site.py` (or do whatever you want in `sitecustomize.py`) to divorce the location of site-packages from the `lib` directory, but that kind of trickery we can't handle at all with the approach in this PR, the only way to handle it is to run Python and query it, like `uv` does.

In your Homebrew case, I suspect you'll find that `/opt/homebrew/opt/python@3.12/bin/python3.12` is a symlink (possibly via several symlink steps) to `/opt/homebrew/opt/python@3.12/Frameworks/Python.framework/Versions/3.12/bin/python`. You do have to resolve symlinks of the python binary to get this correct in general, because CPython does.

---

_@AlexWaygood reviewed on 2024-08-06 17:20_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:20_

> Of course it is possible to modify `site.py` (or do whatever you want in `sitecustomize.py`) to divorce the location of site-packages from the `lib` directory, but that kind of trickery we can't handle at all with the approach in this PR, the only way to handle it is to run Python and query it, like `uv` does.

Right, but I understood that this kind of "trickery" was pretty common for system Python installations provided by Homebrew and Linux distros. Common enough, I'd argue, that you can only guarantee that this routine -- as it currently stands -- will work for a virtual environment, not really for an arbitrary system installation. I think the "standard" way Python installation layouts are "meant" to be is pretty irrelevant if that doesn't reflect the experience of people who actually have system installations of Python.

---

_Comment by @AlexWaygood on 2024-08-06 17:23_

The test I added doesn't work on Windows, because I committed a virtual environment with a Unix layout, and part of the point of these utilities is that they account for the fact that virtual environments created on a Windows machine have a different layout to ones on Unix. There are three options here:
1. Also commit a virtual environment created on a Windows machine, and use that for the test if the test is being run on Windows. I don't have a Windows machine to hand; maybe someone else does?
2. Add a dependency on Python or uv to create the virtual environment dynamically as part of the test
3. Remove the test

@MichaReiser, thoughts?

---

_@carljm reviewed on 2024-08-06 17:28_

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:28_

I don't think it is common at all to move site-packages elsewhere; I've never heard of a distro (or Homebrew) doing that. Debian adds an extra `dist-packages` directory; that's the only similar case I've heard of; we can special-case that. (I'm not sure if you processed the last paragraph of my response, which clarifies that your case is not an example of Homebrew breaking the usual layout; it's following the usual layout, once you follow the symlinks on the binary.)

The more important point is, however we handle system Python oddities, we have to handle them regardless, if we are to support `include-system-site-packages` in venvs. So if we have to make at least a best effort to handle system Pythons regardless, why treat venvs specially?

---

_@AlexWaygood reviewed on 2024-08-06 17:28_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:28_

> In your Homebrew case, I suspect you'll find that `/opt/homebrew/opt/python@3.12/bin/python3.12` is a symlink (possibly via several symlink steps) to `/opt/homebrew/opt/python@3.12/Frameworks/Python.framework/Versions/3.12/bin/python`. You do have to resolve symlinks of the python binary to get this correct in general, because CPython does.

Looks like there are some symlinks in there, yup, but even after resolving the symlinks, the Python executable is nowhere near the `site-packages` directory:

```pycon
/dev % /opt/homebrew/bin/python
Python 3.12.4 (main, Jun  6 2024, 18:26:44) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> import pathlib, sys, site
>>> pathlib.Path(sys.executable).resolve()
PosixPath('/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/bin/python3.12')
>>> pathlib.Path(site.getsitepackages()[0]).resolve()
PosixPath('/opt/homebrew/lib/python3.12/site-packages')
```

---

_Comment by @carljm on 2024-08-06 17:37_

I think we should go with option 1; add a Windows-layout virtualenv. I don't have Windows. But I also don't think it's blocking that the committed test venv be an actual virtualenv created on Windows; we know what a Windows venv looks like inasmuch as it matters for this test, and can create that layout manually for now and someone with a Windows machine handy can improve it later. (Or if you prefer, skip the test on Windows for now.)

---

_Comment by @AlexWaygood on 2024-08-06 17:39_

> I also don't think it's blocking that the committed test venv be an actual virtualenv created on Windows; we know what a Windows venv looks like inasmuch as it matters for this test, and can create that layout manually for now

Right, we could easily do this, but I'm just not sure what we'd actually be testing. We'd just be repeating the logic in the function itself inside the test. I think I'd prefer to just skip the test on Windows for now.

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:43_

What is in `/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib`?

And note that `/opt/homebrew/lib/python3.12/site-packages` is exactly where you'd expect to find it relative to `/opt/homebrew/bin/python`.

I don't have access to your system, and I may have forgotten the details about which paths should be symlink-resolved and which shouldn't (`Modules/getpath.py` in CPython is the source of truth here), but I am pretty sure that while Homebrew may do some symlinking stuff, it doesn't hack the site-packages location, it sets it up in a way that works with CPython's lib-finding code.

But like I said above, the more important point is that we have to solve these complexities either way, if we will support include-system-site-packages. So we can't get out of handling these by claiming to only support virtualenvs.

---

_@carljm reviewed on 2024-08-06 17:43_

---

_@AlexWaygood reviewed on 2024-08-06 17:47_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:47_

> But like I said above, the more important point is that we have to solve these complexities either way, if we will support include-system-site-packages. So we can't get out of handling these by claiming to only support virtualenvs.

`include-system-site-packages` is somewhat unusual (I think?). I was wondering about simply invoking Python to figure out where the system `site-packages` are if we find that setting in the `pyvenv.cfg` file. But I suppose we could try the static method first, and then if we can't find a directory where we "expect", just fall back to invoking Python.

---

_@AlexWaygood reviewed on 2024-08-06 17:49_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:49_

> What is in `/opt/homebrew/Cellar/python@3.12/3.12.4/Frameworks/Python.framework/Versions/3.12/lib`?

Looks like we've got a `libpython3.12.dylib` file, a `pkgconfig` directory with some `.pc` files in it, and a `python3.12` directory that contains the standard library

---

_Comment by @carljm on 2024-08-06 17:50_

> We'd just be repeating the logic in the function itself inside the test.

That's not necessarily a problem; it's OK for a test to just test that the code actually does what we think it does. The value of the test is still that it will fail in CI if someone accidentally breaks or bypasses the Windows logic in future (probably because they also aren't using or testing on Windows locally.)

But I also agree that it would be ideal to commit something we've verified is what a real Windows venv looks like, and I'm OK skipping on Windows until then.

---

_Review comment by @AlexWaygood on `crates/red_knot/src/main.rs`:50 on 2024-08-06 17:56_

One other reason why I called it `--venv-path` is that that's the name pyright gives this option

How would we name it if we wanted it to be more general? `--python` isn't quite right, because it's not the path to the Python installation that's being passed. `red_knot --venv-path .venv` doesn't point to a Python installation (`red_knot --venv-path .venv/bin/python` would, but that's more for users to type, and not all users will necessarily know where the Python installation is inside their venv directory)

---

_@AlexWaygood reviewed on 2024-08-06 17:56_

---

_@carljm reviewed on 2024-08-06 17:57_

---

_Review comment by @carljm on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 17:57_

> and a python3.12 directory that contains the standard library

Within which (if your Homebrew install is like mine) there's a `site-packages` which is a symlink all the way back to `/opt/homebrew/lib/python3.12/site-packages` :) So yeah, Homebrew's just playing a lot of symlinking tricks in a way that still works as a normal layout.

> I was wondering about simply invoking Python to figure out where the system site-packages are if we find that setting in the pyvenv.cfg file. But I suppose we could try the static method first, and then if we can't find a directory where we "expect", just fall back to invoking Python.

Ah, makes sense. I do think it's reasonable if you prefer to only use the static-finding approach for virtualenvs, and always fall back to invoking Python for system Pythons. I agree include-system-site-packages isn't super common, and venvs should be the most common scenario we deal with.


---

_@AlexWaygood reviewed on 2024-08-06 18:02_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:21 on 2024-08-06 18:02_

> Within which (if your Homebrew install is like mine) there's a `site-packages` which is a symlink all the way back to `/opt/homebrew/lib/python3.12/site-packages` :) So yeah, Homebrew's just playing a lot of symlinking tricks in a way that still works as a normal layout.

I see... you're quite right!

I think I'll rename this routine to something more generic (so that we can reuse it for system site-packages, as you suggest), but keep the CLI command as `--venv-path` (unless you have suggestions in response to my question at https://github.com/astral-sh/ruff/pull/12716#discussion_r1705919180)

---

_@carljm reviewed on 2024-08-06 18:06_

---

_Review comment by @carljm on `crates/red_knot/src/main.rs`:50 on 2024-08-06 18:06_

`--python-home` would be a name that matches CPython's `PYTHONHOME` env var, and CPython's naming in general, to refer to the directory containing `lib` / `Lib`.

Given the value of matching pyright, and the fact that many users who do just always use a virtualenv might find the `--venv-path` name more discoverable, I think it might make sense to have both `--venv-path` and `--python-home` as options (they might even just be aliases that do the same thing)? And it's fine with me if we just call it `--venv-path` for now and defer the system Pythons question for now; we aren't locking in any CLI choices yet.

---

_Comment by @carljm on 2024-08-06 18:23_

Rename and added comments look excellent!

---

_Comment by @AlexWaygood on 2024-08-06 18:31_

Thanks both for the excellent reviews!

---

_Merged by @AlexWaygood on 2024-08-06 18:34_

---

_Closed by @AlexWaygood on 2024-08-06 18:34_

---

_Branch deleted on 2024-08-06 18:34_

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/resources/test/empty-unix-venv/bin/activate.bat`:1 on 2024-08-06 19:29_

We may want to remove files that aren't strictly necessary unless we plan to use the venv for other tests as well

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/src/site_packages.rs`:33 on 2024-08-06 19:31_

We generally prefer usinf if cfg over replacing entire functions. The former has the advantage that the code compiles on all platforms. That makes it easier to change the code

---

_@MichaReiser reviewed on 2024-08-06 19:31_

---

_@MichaReiser reviewed on 2024-08-06 19:35_

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/src/site_packages.rs`:33 on 2024-08-06 19:35_

See https://doc.rust-lang.org/rust-by-example/attribute/cfg.html

Llvm should still remove the dead code 

---

_@AlexWaygood reviewed on 2024-08-06 19:36_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:33 on 2024-08-06 19:36_

Ah, perhaps I misunderstood how `if cfg!()` worked. My understanding was that `if cfg!()` (unlike `#[cfg()]`) didn't remove any code from the shipped binary

---

_@carljm reviewed on 2024-08-06 19:37_

---

_Review comment by @carljm on `crates/red_knot_workspace/resources/test/empty-unix-venv/bin/activate.bat`:1 on 2024-08-06 19:37_

These activate scripts will never be relevant to any test we will ever write in red-knot, which is why I'd suggested to remove them.

---

_@AlexWaygood reviewed on 2024-08-06 19:38_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:33 on 2024-08-06 19:38_

Sorry, I posted ^that comment before I saw your second comment!

---

_@AlexWaygood reviewed on 2024-08-06 19:41_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/resources/test/empty-unix-venv/bin/activate.bat`:1 on 2024-08-06 19:41_

I don't have a strong objection to removing them, just that it feels like the more we "tamper" with the virtual environment, the less it feels like a "real" virtual environment and the more it feels like just a mock

---

_Review comment by @MichaReiser on `crates/red_knot_workspace/src/site_packages.rs`:33 on 2024-08-07 05:31_

I do find the use of the term *runtime* in the `cfg!` documentation confusing. That's why I created a small test in [compiler explorer](https://godbolt.org/z/WEveE9Mc4). Looking at the generated assembly, you can see that only the string "Linux" makes it into the binary. 

The way I understand it is that the Rust compiler only generates code for the matching target when using `#[cfg]`, which is what you want when using platform-specific instructions (because that code wouldn't compile on other platforms). With `cfg!`, rust does generate the instructions for all code, but it replaces the `cfg!` expression with a constant `true` or `false`, which LLVM then can remove when doing dead code detection.

---

_@MichaReiser reviewed on 2024-08-07 05:31_

---

_Review comment by @AlexWaygood on `crates/red_knot_workspace/src/site_packages.rs`:33 on 2024-08-07 07:08_

I'll fix this up as part of the followup PR I'm working on 

---

_@AlexWaygood reviewed on 2024-08-07 07:08_

---
