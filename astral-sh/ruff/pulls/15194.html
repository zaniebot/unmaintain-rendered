<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Support `assert_type` - astral-sh/ruff #15194</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Support <code>assert_type</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15194">#15194</a>
        opened by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a>
        on 2024-12-30 03:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>See #15103.</p>
<h2>Test Plan</h2>
<p>Markdown tests and unit tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @InSyncWithFoo on 2024-12-30 03:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @InSyncWithFoo on 2024-12-30 03:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @InSyncWithFoo on 2024-12-30 03:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @InSyncWithFoo on 2024-12-30 03:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-30 03:59</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2024-12-30 04:02</div>
            <div class="timeline-body"><p>This is largely a proof-of-concept. <code>is_equals_to()</code> is not a thing in the specification, and I'm quite sure its name is not the best.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2024-12-30 08:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-03 13:35</div>
            <div class="timeline-body"><p>Can you go into a bit more detail in how this is different from <code>is_equivalent_to</code>? The main difference seems to be that this can also handle non-fully-static types and return <code>true</code> for something like <code>Any ~ Any</code>? If so, could it handle those gradual types (+ intersections/unions/tuples) and then fall back to <code>is_equivalent_to</code> for fully static types?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:79 on 2025-01-03 13:39</div>
            <div class="timeline-body"><p>It feels like this should be tested elsewhere? Or what exactly is the <code>assert_type</code> property that is tested here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:1 on 2025-01-03 13:42</div>
            <div class="timeline-body"><p>Remove?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:1 on 2025-01-03 13:44</div>
            <div class="timeline-body"><p>One thing that we should probably test here somewhere (if only to document our behavior) is the handling of <code>Literal</code> types. And whether we use the inferred type or the declared type. For example, pyright behaves like this:</p>
<pre><code class="language-py">from typing import assert_type

x: int = 1

assert_type(x, int)  # &quot;assert_type&quot; mismatch: expected &quot;int&quot; but received &quot;Literal[1]&quot;

def f():
    assert_type(x, int)  # fine (uses declared type)
</code></pre>
<p>It looks like we would currently have the same behavior?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:33 on 2025-01-03 13:47</div>
            <div class="timeline-body"><p>Again, we should specify somewhere what &quot;precisely&quot; or &quot;exactly the same&quot; means. Because it's not &quot;structural equivalence&quot; or <code>Eq</code> on <code>Type</code> (because <code>int | str</code> and <code>str | int</code> should match, for example)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:120 on 2025-01-03 13:49</div>
            <div class="timeline-body"><p>:+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 13:50</div>
            <div class="timeline-body"><p>Thank you very much for working on this. I added a few initial review comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-03 16:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-03 16:20</div>
            <div class="timeline-body"><p>I think it's quite possible that a function like this could help fix https://github.com/astral-sh/ruff/issues/14899, FWIW, so it doesn't seem like an unreasonable addition to me. I'm also not sure what name would clearly distinguish it from <code>Type::is_equivalent_to()</code>, though ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 16:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-03 16:38</div>
            <div class="timeline-body"><p>To be clear, I was not suggesting that this function is not useful. I just think there's some overlap with <code>is_equivalent_to</code>, and I'd like to understand it and possibly make use of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-03 17:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:501 on 2025-01-03 17:36</div>
            <div class="timeline-body"><p>Should this be an <code>Error</code>? I'd expect any assertion that doesn't match the expected type to fail my build.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-03 20:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:1 on 2025-01-03 20:15</div>
            <div class="timeline-body"><p>We should always use the inferred types in the specific scope/code flow. What Pyright is doing seems to be the most user-friendly way; there is no way to know when functions will be called, but it is fine to narrow or infer a more precise type (as is currently done) for even global-scoped flows.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-03 20:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:79 on 2025-01-03 20:17</div>
            <div class="timeline-body"><p>A bare <code>Literal</code> should cause an error and be treated as <code>Unknown</code>. <code>type[Unknown]</code> should then be treated the same as <code>type[Any]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-03 20:59</div>
            <div class="timeline-body"><p>Another notable exception is <code>type[Any] != type != type[object]</code>. I'm not too sure about the former, but I think it is better to be strict.</p>
<p>Also, as it currently is, <code>int | Unknown | Any != int | Any</code>. This is supposedly due to <code>Unknown</code> not being foldable into <code>Any</code>, but <code>int | Any</code> is just <code>Any</code>; could such union types even be emitted in the first place?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-03 20:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-08 01:02</div>
            <div class="timeline-body"><p>This relation is defined in the type specification, but it's mentioned as a bit of an aside, and unfortunately not given a distinct name from the equivalence relation on fully static types. See https://typing.readthedocs.io/en/latest/spec/concepts.html#summary-of-type-relations :</p>
<blockquote>
<p>We can also define equivalence on gradual types. Two gradual types A and B are equivalent (that is, the same gradual type, not merely consistent with one another) if and only if all materializations of A are also materializations of B, and all materializations of B are also materializations of A.</p>
</blockquote>
<p>I think we should link to that definition in the doc comment here, and name the method <code>is_gradual_equivalent_to</code>.</p>
<p>I think it's more useful for this doc comment to give this overall conceptual definition than to outline what that means for every concrete type variant; that's what the code is for. (If anything, the per-type-variant descriptions should be individual comments above each case within the method.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1458 on 2025-01-08 01:04</div>
            <div class="timeline-body"><p>Todo is supposed to behave like <code>Any</code> or <code>Unknown</code> in the typing system, so I think our default approach should be that all three are gradually-equivalent to each other. Is there a concrete reason you felt it necessary to make <code>Todo != Todo</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1468 on 2025-01-08 01:06</div>
            <div class="timeline-body"><p>For all fully-static types, I think we could just defer to <code>is_equivalent_to</code>? And/or we could have a fast-path at the top of this method for <code>if self == other { return true; }</code>, similar to <code>is_equivalent_to</code>. Either one would eliminate the need for many of these cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1515 on 2025-01-08 01:09</div>
            <div class="timeline-body"><p>Nice; this is a fix we need in <code>is_equivalent_to</code> as well. It would be nice if there were a way to do it without allocating so many hashsets...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2015 on 2025-01-08 01:11</div>
            <div class="timeline-body"><p>These todos can be solved by rebasing this on top of call-checking, which has landed, and https://github.com/astral-sh/ruff/pull/15103, which hopefully will land soon, and has many examples of similar methods.</p>
<p>The one thing we'll need to do that https://github.com/astral-sh/ruff/pull/15103 doesn't yet do is provide a way to say that some arguments of a function must be interpreted as type expressions, and others as value expressions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 01:14</div>
            <div class="timeline-body"><p>This looks good, thank you for working on it! I think if we rebase on top of https://github.com/astral-sh/ruff/pull/15103 we can address some of the limitations and get it ready to land.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1458 on 2025-01-08 07:43</div>
            <div class="timeline-body"><p>I just thought that it would be rather nonsensical to do something like this:</p>
<pre><code class="language-py">def _(a: tuple[int, ...]):
	assert_type(a, tuple[str, ...])  # Pass because both are Todos
</code></pre>
<p>No strong feelings though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 07:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-08 09:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1449 on 2025-01-08 09:35</div>
            <div class="timeline-body"><p>Do we need to compare the <code>first_positive</code> and <code>second_positive</code> lengths (and same for negative) before calling zip?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-08 09:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 09:37</div>
            <div class="timeline-body"><p>What makes this set ordered? This is just a regular hash set, isn't it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-08 09:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1446 on 2025-01-08 09:38</div>
            <div class="timeline-body"><p>Why do we need to collect the positive elements into another set when they are already set in <code>IntersectionType</code>? Could we instead compute the difference between <code>a</code> and <code>b</code> and then compare if those elements are equivalent?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1446 on 2025-01-08 10:05</div>
            <div class="timeline-body"><p><code>int &amp; Unknown &amp; ~Any</code> is supposed to be gradual equivalent to <code>int &amp; Any &amp; ~Unknown</code>; I did mention this in <a href="https://github.com/astral-sh/ruff/pull/15194#discussion_r1902163652">a previous comment</a>. Since I'm not sure whether such types can exist, I took the safe route.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 10:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 10:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 10:06</div>
            <div class="timeline-body"><p>True. I just thought its name should reflect the fact that the order of iteration is depended upon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-08 10:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 10:08</div>
            <div class="timeline-body"><p>The problem is that the order isn't guaranteed. The element ordering may depend on insertion order. The <code>IntersectionType</code> <code>positive</code> and <code>negative</code> sets are ordered (although I don't remember the details of how they're ordered)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 12:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 12:42</div>
            <div class="timeline-body"><p><code>IntersectionType</code> uses <code>OrderedSet</code>, whose iteration order is the same as insertion order. The comparison in question needs a self-ordered set type.</p>
<p>I have so far been unsuccessful in finding such a type. Any suggestions?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-08 12:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 12:55</div>
            <div class="timeline-body"><p>You could collect the types into a vec and then order them. I'm just not sure why the order is important. I suspect that we instead have to implement an <code>O(n^2)</code> algorithm that, for every type in <code>a</code>, searches a type in <code>b</code> to which it is equivalent, disregarding ordering entirely. But I'm not sure if doing so is too naive.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 13:04</div>
            <div class="timeline-body"><p>Indeed, this was done to avoid $$O(n^2)$$ time at the cost of a few $$O(n)$$ iterations and allocations. However, even for a $$O(n^2)$$ algorithm, I suspect $$O(n)$$ space is still needed to store paired indices.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 13:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-08 15:45</div>
            <div class="timeline-body"><p><code>int | Any</code> is not just <code>Any</code>; it is a gradual type with a known lower bound. It is an unknown type that must be at least as large as <code>int</code>, whereas plain <code>Any</code> is an unknown type that could be a smaller type than <code>int</code>. It is thus intentional that we don't simplify <code>int | Any</code>, and <code>int | Any</code> can be treated differently in the type system than plain <code>Any</code>. For instance, given an object of type <code>int | Any</code>, it is an error to assign that object to a destination expecting e.g. a <code>str</code>, whereas <code>Any</code> is assignable to <code>str</code>. Using terms from the typing spec, <code>Any</code> can materialize to <code>str</code>, but <code>int | Any</code> cannot; at best it can materialize to <code>int | str</code>.</p>
<p>The thing that causes more difficulty here is our choice to not simplify <code>Any | Unknown</code>. Because both of these simply represent the dynamic/unknown type, just with different origin. From a type system perspective, they should simplify, but we choose to preserve the information that the type may have come from an explicit <code>Any</code> annotation or may have come from a lack of annotation. But we should still ideally treat <code>Any | Unknown</code> as equivalent to <code>Any</code> and equivalent to <code>Unknown</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-01-08 15:47</div>
            <div class="timeline-body"><blockquote>
<p>type[Any] != type != type[object]</p>
</blockquote>
<p>I'm not sure if this is describing current behavior or correct behavior. Correct behavior would be that <code>type</code> == <code>type[object]</code>, but both are not equivalent to <code>type[Any]</code>. (In our internal representation, <code>type</code> would be <code>Type::Instance(&lt;builtins.type&gt;)</code> and <code>type[object]</code> would be <code>Type::SubclassOf(&lt;builtins.object&gt;)</code>, but these are equivalent types and we should treat them as such.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1458 on 2025-01-08 15:49</div>
            <div class="timeline-body"><p>I understand the reasoning, but I think it is OK for that <code>assert_type</code> to pass, until we actually are able to properly differentiate those types. It is more important that we consistently treat <code>Todo</code> in the type system as the dynamic type, just with more provenance information.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 16:43</div>
            <div class="timeline-body"><p>After thinking this over more, I agree with Micha, in that I don't think naive <code>Type</code> ordering (even if we were to find/create a self-ordering set implementation) will be able to get us the right results here. The problem is that we can have equivalent &quot;atomic&quot; types that are not represented as the same <code>Type</code> enum bit pattern. (Examples already discussed include <code>Any</code> and <code>Unknown</code>, or <code>Type::Instance(&lt;builtins.type&gt;)</code> and <code>Type::SubclassOf(&lt;builtins.object&gt;)</code>. So our definition of equivalence for unions and intersections needs to recurse into a full understanding of atomic type equivalence, not be built solely on <code>Type</code> enum identity.</p>
<p>Given that we already have this as an unsolved problem with the existing <code>is_equivalent_to</code> implementation, I'm OK with punting on this for this PR. (In other words, I think we can, and probably should, separate the problems of &quot;implement <code>assert_type</code>&quot; and &quot;fully correct gradual type equivalence&quot; into separate PRs.) In which case, I would suggest just removing the set stuff from this PR, and implementing <code>is_gradual_equivalent_to</code> for now without any handling for differently-ordered unions and intersections (just like <code>is_equivalent_to</code>), and a <code>TODO</code> comment for improving that in a separate PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 16:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-08 16:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:561 on 2025-01-08 16:45</div>
            <div class="timeline-body"><p>I actually briefly tried looking at the problem of equivalence for differently ordered unions over the Christmas break, and, yeah, it is Not Easy</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:49 on 2025-01-08 16:50</div>
            <div class="timeline-body"><p>I see this issue (and all other TODOs that say &quot;infer the second argument as a type expression&quot;) as fundamental to the nature of <code>assert_type</code>, and thus something we should solve before merging this PR. (In contrast to, say, ironing out all the details of <code>is_gradual_equivalent_to</code>, which I think can be left as an exercise for future.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1489 on 2025-01-08 16:54</div>
            <div class="timeline-body"><p>Since this isn't a complete handling of differently-ordered unions (and it's not even well-specified how correct it is, since <code>HashSet</code> doesn't provide any self-ordering guarantees at all), I think we should just remove it for now, compare the elements in whatever we have them, and leave a <code>TODO</code> for handling ordering separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1511 on 2025-01-08 16:55</div>
            <div class="timeline-body"><p>Same as above, let's remove the <code>OrderedTypeSet</code> stuff in favor of a <code>TODO</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2018 on 2025-01-08 16:57</div>
            <div class="timeline-body"><p>This I don't think we should leave as a TODO. This PR should implement a finer-grained version of <code>takes_type_expression_arguments</code> that allows us to infer the second argument as a type expression. We'll need this for <code>typing.cast</code> as well. (One implementation option that seems reasonably straightforward would be to make <code>takes_type_expression_arguments</code> a bitmask u32 instead of a boolean.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 16:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:116 on 2025-01-10 00:36</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO: order-independent union handling in type equivalence
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:140 on 2025-01-10 00:36</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        # TODO: order-independent intersection handling in type equivalence
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:105 on 2025-01-10 00:37</div>
            <div class="timeline-body"><p>Can we also add a test showing union equivalence when the elements <em>are</em> actually in the same order? (This one should actually pass now.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/directives/assert_type.md</code>:125 on 2025-01-10 00:37</div>
            <div class="timeline-body"><p>Same as above, let's also add a test for intersection equivalence when ordering is the same? It doesn't have to highlight ordering, just show two identical unions and that <code>assert_type</code> considers them equivalent.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1114 on 2025-01-10 00:39</div>
            <div class="timeline-body"><p>What about Todo?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1129 on 2025-01-10 00:40</div>
            <div class="timeline-body"><p>What about Todo?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1159 on 2025-01-10 00:42</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            // TODO handle equivalent intersections with items in different order
            (Type::Intersection(first), Type::Intersection(second)) =&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1147 on 2025-01-10 00:42</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            // TODO handle equivalent unions with items in different order
            (Type::Union(first), Type::Union(second)) =&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4748 on 2025-01-10 00:45</div>
            <div class="timeline-body"><p>also test <code>Todo</code> vs <code>Any</code> and <code>Todo</code> vs <code>Unknown</code>, also all equivalent</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2548 on 2025-01-10 00:51</div>
            <div class="timeline-body"><p>I don't think overload matching is the feature that will allow removing this; <code>TypeForm</code> and contextual type inference might. But since the current approach is not buggy, just hardcoded, I don't think we need a TODO for that. We could make a note of it, but I'd probably put that in the doc comment for <code>takes_type_expression_arguments</code>, not here.</p>
<pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-10 00:51</div>
            <div class="timeline-body"><p>Looks great, thank you! A few nits here and there, but basically this looks just right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1141 on 2025-01-10 12:15</div>
            <div class="timeline-body"><p>Calling <code>.len(db)</code> and then <code>.elements(db)</code> in quick succession like this means that you're doing two lookups in the Salsa database for each <code>Tuple</code> type when you only really need to do one. You can optimise it like this:</p>
<pre><code class="language-suggestion">            (Type::Tuple(left), Type::Tuple(right)) =&gt; {
                let left_elements = left.elements(db);
                let right_elements = right.elements(db);
                left_elements.len() == right_elements.len()
                    &amp;&amp; iter::zip(left_elements, right_elements).all(equivalent)
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-10 12:21</div>
            <div class="timeline-body"><p>You need to merge/rebase and fix some compilation failures now that https://github.com/astral-sh/ruff/pull/15386 has landed :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-10 16:44</div>
            <div class="timeline-body"><p>Awesome, thank you for this, and for managing all the rebasing on top of other refactors that landed in the meantime!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-01-10 16:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-01-10 16:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-10 16:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:08:47 UTC
    </footer>
</body>
</html>
