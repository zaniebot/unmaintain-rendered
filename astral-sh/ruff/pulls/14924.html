<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Make `is_subtype_of` exhaustive - astral-sh/ruff #14924</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Make <code>is_subtype_of</code> exhaustive</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14924">#14924</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-12-11 20:25
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-11 20:25</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR removes the fallback <code>_</code> branch at the end of <code>Type::is_subtype_of()</code>: the function now uses an exhaustive match over the first element of the <code>(self, target)</code> pair. This means that we can have much more confidence that we've covered all cases, and it means that it's impossible to forget to update this function if we add more variants to <code>Type</code> in the future (which we will).</p>
<p>The PR reworks our handling of most literal types in the <code>match</code> statement so that they explicitly fallback to builtin types. This has several advantages:</p>
<ul>
<li>We now understand that <code>Type::ModuleLiteral(&quot;typing&quot;)</code> is a subtype of <code>types.ModuleType</code></li>
<li>We now understand that <code>Type::SliceLiteral([:2])</code> is a subtype of <code>builtins.slice</code></li>
<li>We now understand that all heterogeneous tuple types are subtypes of <code>Type::Instance(Tuple)</code> (which represents the static set of all possible tuples, so in Python type annotations it would be written as <code>tuple[object, ...]</code>)</li>
<li>We will naturally understand that all string literal types are subtypes of <code>typing.Sequence</code> as soon as we understand generics -- we won't have to make any manual updates to this function</li>
<li>We can get rid of the explicit handling of <code>builtins.object</code> being the top type from the function; we now naturally understand this without any special-casing due to the fact that we understand that all classes have <code>object</code> in their MROs.</li>
</ul>
<h2>Test Plan</h2>
<p>Several new subtyping tests have been added, and all existing tests pass.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-12-11 20:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-11 20:31</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2024-12-11 20:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:639 on 2024-12-11 20:34</div>
            <div class="timeline-body"><p>Perhaps you mean &quot;non-fully-static types&quot;?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-11 20:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:639 on 2024-12-11 20:49</div>
            <div class="timeline-body"><p>yes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2024-12-12 18:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-12-12 18:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-12-12 18:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2024-12-12 18:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:616 on 2024-12-12 18:29</div>
            <div class="timeline-body"><p>This seems like a tautology? I'm not sure what it's trying to say. I would expect it to say this instead:</p>
<pre><code class="language-suggestion">        // Two equivalent types are always subtypes of each other.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:619 on 2024-12-12 18:30</div>
            <div class="timeline-body"><p>&quot;can be determined to point to&quot; feels like a roundabout and unnecessarily vague phrasing: for a fully static type there should never be any ambiguity about what set of objects it refers to</p>
<pre><code class="language-suggestion">        // and name exactly the same set of possible runtime objects.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:633 on 2024-12-12 18:31</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // But the set of objects named by a non fully static type is (either partially or wholly) unknown,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:634 on 2024-12-12 18:31</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // so the question is simply unanswerable for non fully static types.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:795 on 2024-12-12 20:01</div>
            <div class="timeline-body"><p>This works for all our existing <code>ClassLiteral</code> cases above, but in principle it's risky. Usually (e.g. with the <code>Literal</code> types above) when we delegate, we delegate to a <em>wider</em> type, so the delegation can give a false negative if we missed a case for the narrower type, but it can't give a false positive answer.</p>
<p>In this case, we are delegating in the other direction, from a wider type <code>type[T]</code> to a narrower type <code>Literal[T]</code>, which in principle opens the door to a false positive.</p>
<p>I'm not seeing why we can't just flip this: write the cases above in terms of <code>Type::SubclassOf</code> instead of <code>Type::ClassLiteral</code>, and then have <code>ClassLiteral</code> delegate to <code>SubclassOf</code> instead. This seems safer and easier to reason about its correctness.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-12-12 22:39</div>
            <div class="timeline-body"><p>Awesome, thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-12 22:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:633 on 2024-12-12 22:47</div>
            <div class="timeline-body"><p>oops, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-13 07:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:698 on 2024-12-13 07:51</div>
            <div class="timeline-body"><p>Not related to your PR, but it would look a bit more symmetric if we change the order here to what we have above for the subtype-of check for positive elements:</p>
<pre><code class="language-suggestion">                        .all(|&amp;neg_ty| self.is_disjoint_from(db, neg_ty))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:795 on 2024-12-13 08:07</div>
            <div class="timeline-body"><p>I just ran the property tests on this branch, and I think the following failure is related to this exact case:</p>
<pre><code>thread 'types::property_tests::stable::subtype_of_is_transitive' panicked at /home/shark/.cargo/registry/src/index.crates.io-6f17d22bba15001f/quickcheck-1.0.3/src/tester.rs:165:28:
[quickcheck] TEST FAILED. Arguments: (BuiltinInstance(&quot;type&quot;), SubclassOfBuiltinClass(&quot;object&quot;), BuiltinClassLiteral(&quot;object&quot;))
</code></pre>
<p>This means we currently model <code>type &lt;: type[object]</code> and <code>type[object] &lt;: Literal[object]</code>, but not <code>type &lt;: Literal[object]</code>.</p>
<p>The problem seems to be that second subtype relation <code>type[object] &lt;: Literal[object]</code>, which looks wrong. And seems to be handled by this exact match pattern.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-13 08:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 11:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:616 on 2024-12-13 11:21</div>
            <div class="timeline-body"><p>Thanks, sorry for the shoddy quality of the comments in this PR! I guess I started off with the goal of adding comments to make sure each branch was explicitly documented, but then got distracted by bugs in the semantics and forgot to do a second pass on the comments to make sure they made sense ðŸ™ƒ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:619 on 2024-12-13 11:22</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // and point to exactly the same set of possible runtime objects.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 11:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 11:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:633 on 2024-12-13 11:23</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // But the set of objects described by a non-fully-static type is (either partially or wholly) unknown,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 11:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:634 on 2024-12-13 11:23</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // so the question is simply unanswerable for non-fully-static types.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 11:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:619 on 2024-12-13 11:28</div>
            <div class="timeline-body"><p>I weakly prefer &quot;described by&quot; or &quot;point to&quot; rather than &quot;name&quot;, because it feels slightly off to say that any type has a canonical &quot;name&quot;. Perhaps you might say that any type can have multiple names, but that also feels confusing.</p>
<p><code>type</code> (== <code>Instance(&quot;type&quot;)</code>) and <code>type[object]</code> (== <code>SubclassOf(&quot;object&quot;)</code>) both describe the same set of possible runtime objects, but I wouldn't really describe either as a more valid name than the other.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 11:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:795 on 2024-12-13 11:30</div>
            <div class="timeline-body"><p>Great observation from both of you, thank you! I confirmed that this test currently fails on my branch, when it should pass:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types.rs b/crates/red_knot_python_semantic/src/types.rs
index aed779e53..6cd2139c0 100644
--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -3526,6 +3526,7 @@ pub(crate) mod tests {
     #[test_case(Ty::BuiltinInstance(&quot;type&quot;), Ty::SubclassOfBuiltinClass(&quot;str&quot;))]
     #[test_case(Ty::BuiltinClassLiteral(&quot;str&quot;), Ty::SubclassOfAny)]
     #[test_case(Ty::AbcInstance(&quot;ABCMeta&quot;), Ty::SubclassOfBuiltinClass(&quot;type&quot;))]
+    #[test_case(Ty::SubclassOfBuiltinClass(&quot;str&quot;), Ty::BuiltinClassLiteral(&quot;str&quot;))]
     fn is_not_subtype_of(from: Ty, to: Ty) {
         let db = setup_db();
         assert!(!from.into_type(&amp;db).is_subtype_of(&amp;db, to.into_type(&amp;db)));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-13 12:02</div>
            <div class="timeline-body"><p>Thanks again! Would appreciate it if somebody could take another quick look before I land, since this is all quite subtle stuff</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2024-12-13 12:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-12-13 12:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-13 14:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:795 on 2024-12-13 14:24</div>
            <div class="timeline-body"><p>Aha, yes! When I reviewed the &quot;above cases&quot; to make sure they worked with this delegation, I of course forgot to consider the &quot;is the same type&quot; above case :) Chalk up another win for the property tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-13 14:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:619 on 2024-12-13 14:30</div>
            <div class="timeline-body"><p>I don't agree that to &quot;name&quot; a set of objects implies &quot;to uniquely name&quot; a set of objects, or even &quot;to preferentially name&quot; a set of objects. A type can have multiple equally-valid names, and it is still perfectly accurate to say that any one of them &quot;names&quot; the type.</p>
<p>So I still (weakly :) ) prefer &quot;name&quot;, and my second favorite options are &quot;refers to&quot; to or &quot;describes&quot;. I find &quot;points to&quot; a bit awkward, personally. But I think any of them communicate well enough; as the author of the PR, you get to paint the bikeshed :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 14:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:619 on 2024-12-13 14:35</div>
            <div class="timeline-body"><p>I pushed a commit switching the verb to &quot;describe&quot;, since it sounds like that's something we're both okay with ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-12-13 14:37</div>
            <div class="timeline-body"><p>Looks good to me!</p>
<p>Did you re-run the property tests on the latest version of the PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-13 19:19</div>
            <div class="timeline-body"><p>Okay, I had to add a couple of new branches to <code>is_disjoint_from</code> to make the property tests happy (we weren't recognising that <code>tuple[()]</code> was disjoint from <code>Literal[object]</code>, which was causing <code>is_subtype_from</code> not to be transitive w.r.t. intersections, since the <code>Type::Intersection</code> branch in <code>is_subtype_of</code> calls <code>is_disjoint_from</code> if there are negative elements in the intersection).</p>
<p>This PR now causes no new property-test failures relative to <code>main</code>! I tested using this invocation:</p>
<pre><code>QUICKCHECK_TESTS=100000 cargo test -p red_knot_python_semantic -- --ignored types::property_tests::stable
</code></pre>
<p>The <code>types::property_tests::stable::assignable_to_is_reflexive</code> still fails instantly on this branch, but it also fails on <code>main</code>, so I didn't look at that too much. All other property tests pass.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1033 on 2024-12-13 19:22</div>
            <div class="timeline-body"><p>Am I understanding right that this line (along with the similar ones removed below for <code>BytesLiteral</code> and <code>SliceLiteral</code>) were already redundant before this PR, because they were caught by the big union for single-valued types above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-12-13 19:23</div>
            <div class="timeline-body"><p>Looks good, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-13 19:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1033 on 2024-12-13 19:24</div>
            <div class="timeline-body"><p>Exactly. And the compiler can now verify that this is the case, which led to me getting lots of warnings about unreachable branches locally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2024-12-13 19:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-12-13 19:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-12-13 19:31</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 20:42:56 UTC
    </footer>
</body>
</html>
