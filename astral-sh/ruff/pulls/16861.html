<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] detect non-deferred self-references in annotations - astral-sh/ruff #16861</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] detect non-deferred self-references in annotations</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16861">#16861</a>
        opened by <a href="https://github.com/mtshiba">@mtshiba</a>
        on 2025-03-20 04:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR closes #16341.</p>
<h2>Test Plan</h2>
<p>New test cases are added in <code>annotations/deferred.md</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-03-20 04:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @mtshiba on 2025-03-20 04:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @mtshiba on 2025-03-20 04:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @mtshiba on 2025-03-20 04:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-20 04:47</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2025-03-20 07:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:5906 on 2025-03-20 10:58</div>
            <div class="timeline-body"><p>Hmm, I don't think special-casing the immediate enclosing class here is the correct fix. With this PR branch, red-knot emits a diagnostic on the <code>x</code> annotation in the <code>Foo.Bar.f</code> method in the following example, but we do not emit an error on the <code>x</code> annotation in the <code>Foo.Bar.g</code> method. Both annotations raise <code>NameError</code> at runtime:</p>
<pre><code class="language-py">class Foo:
    class Bar:
        def f(self, x: Bar): ...
        def g(self, x: Foo): ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md</code>:61 on 2025-03-20 11:00</div>
            <div class="timeline-body"><p>I'd feel a bit more comfortable if we used non-<code>self</code> parameters in these assertions, just because the questions &quot;What is the type of <code>self</code>?&quot; and &quot;What are the legal annotations to apply to <code>self</code>?&quot; are both somewhat complex questions. Both are irrelevant questions to the thing that's being tested here, and it's useful to make it clear that this test doesn't have any bearing on those questions, I think:</p>
<pre><code class="language-suggestion">    def f(self, x: &quot;Bar&quot;):
        reveal_type(self)  # revealed: Bar

    def g(self, x: Bar):
        reveal_type(self)  # revealed: Bar
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md</code>:79 on 2025-03-20 11:01</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    def f(self, x: &quot;Bar&quot;):
        reveal_type(self)  # revealed: Bar
    # error: [unresolved-reference]
    def g(self, x: Bar):
        reveal_type(self)  # revealed: Bar
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-20 11:01</div>
            <div class="timeline-body"><p>Thank you! Unfortunately I'm not sure that the special-casing here is the correct approach. I think we need a more general approach to ensure that <code>NameError</code>s in annotation expressions are always detected.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/binary/instances.md</code>:19 on 2025-03-20 22:23</div>
            <div class="timeline-body"><p>Might be less verbose to use stringified annotations in tests like these?</p>
<pre><code class="language-suggestion">class A:
    def __add__(self, other) -&gt; &quot;A&quot;:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:1217 on 2025-03-20 22:24</div>
            <div class="timeline-body"><p>I don't think this case is special enough to require a dedicated lint rule and error message. It should just result in the same undefined-reference error we would normally raise for any undefined name.</p>
<p>(And as discussed in another comment, that error should fall out naturally from correct handling of definitions in the semantic index.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:5906 on 2025-03-20 22:48</div>
            <div class="timeline-body"><p>Yes, I agree with Alex. The bug here arises from incorrect visibility of definitions in the semantic index. Specifically, in the <code>ClassDef</code> branch of <code>SemanticIndexBuilder::visit_stmt</code>, we call <code>self.add_definition(...)</code> to record a definition for the class name, before we visit the class body. This is wrong, because it doesn't match the runtime semantics, and it causes the name to be wrongly considered defined in the class body. The fix here should simply be a matter of moving that line after we visit the class body instead.</p>
<p>In practice I've tried that locally and it looks like it fixes one case (self-referential inheritance) but it doesn't fix e.g. use of a class' own name in annotations of a method on that class. The reason for this appears to be a bug in our handling of eager nested scopes (cc @dcreager ). Our eager nested scope handling (see <code>SemanticIndexBuilder::pop_scope</code>) snapshots bindings, if any, but it doesn't snapshot <em>lack of bindings</em>. And then in <code>TypeInferenceBuilder::infer_name_load</code>, if we don't find any snapshotted bindings, we just fall back to looking for the name as a public symbol (that is, as we would in a reference from a lazily-executed nested scope.) So in a case like this:</p>
<pre><code class="language-py">class A:
    def f(self) -&gt; A:
        pass
</code></pre>
<p>Even though the class scope of <code>A</code> (which is the scope where the method annotations are evaluated) is an eager nested scope, because we don't find any bindings of <code>A</code> in the outer (global) scope at the point where <code>class A:</code> occurs, we don't snapshot any eager bindings for <code>A</code>, and then <code>infer_name_load</code>, not finding any eager bindings, wrongly falls back to looking up <code>A</code> in the global scope as a non-eager reference.</p>
<p>I think it would make sense to fix the two issues I describe above in two separate PRs: one for the wrong ordering in <code>ClassDef</code> visit in semantic index building, and another for fixing eager-nested-scope handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-20 22:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-03-22 14:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:5906 on 2025-03-22 14:35</div>
            <div class="timeline-body"><p>OK, I'll create PRs to fix the issues you pointed out and close this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-03-23 14:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-23 14:19</div>
            <div class="timeline-body"><p>Closed in favor of #16915 and #16916</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-24 14:29</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:10:53 UTC
    </footer>
</body>
</html>
