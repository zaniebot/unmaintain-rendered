<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement rules around star expressions with different precedence - astral-sh/ruff #10623</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement rules around star expressions with different precedence</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/10623">#10623</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2024-03-27 08:39
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>This PR adds implementations around the following grammar rules to support the other expression and statement parsing. This PR doesn&#x27;t update the related expressions and statements as they will be done in their own PRs.</p>
<ul>
<li><code>star_expressions</code></li>
<li><code>star_expression</code></li>
<li><code>&#x27;*&#x27; bitwise_or</code></li>
</ul>
Problem
<p>There are two grammar entries around star expressions:</p>
<pre><code>star_expression:
    | &#x27;*&#x27; bitwise_or 
    | expression

starred_expression:
    &#x27;*&#x27; expression
</code></pre>
<p>The main difference is the precedence at which the expression should be parsed if a <code>*</code> token is encountered. Currently, we parse both rules at the same precedence which makes the parser more lenient. There are various expressions and statements which uses either one of the above rules.</p>
Solutions
Current solution
<p>Add the following new methods to the parser:</p>
<ol>
<li><code>parse_star_expression_list</code> which would be similar to <code>parse_expression_list</code> and would match the <code>star_expressions</code> grammar rule</li>
<li><code>parse_star_expression_or_higher</code> which would match the <code>star_expression</code> or <code>star_named_expression</code> grammar rule</li>
<li><code>parse_expression_with_bitwise_or_precedence</code> which would match the <code>bitwise_or</code> grammar rule</li>
</ol>
<p>Here, we could possibly merge the <code>parse_expression_list</code> and <code>parse_star_expression_list</code> into a single function as it only differs in the method it delegates the parsing to. The parameter could be called <code>allow_star_expression</code>. It could be confusing because even if it’s false, we would allow starred expression but at a higher binding power.</p>
<p>This solution closely resembles the actual grammar and is easier to follow in the parser code. It doesn&#x27;t require a lot of verification by the caller as the precedence parser makes sure to not allow that.</p>
Other solution
<p>Add a new <code>verify_bitwise_or_precedence</code> method which reports an error if the grammar expected a starred expression with <code>bitwise_or</code> precedence:</p>
<pre><code>pub(super) fn verify_star_expressions(
    &amp;mut self,
    expr: &amp;Expr,
    allow_named_expression: AllowNamedExpression,
) {
    match expr {
        Expr::Tuple(ast::ExprTuple { elts, .. }) =&gt; {
            for expr in elts {
                self.verify_star_expressions(expr, allow_named_expression);
            }
        }
        Expr::Starred(ast::ExprStarred { value, .. }) =&gt; {
            let expr_kind = match &amp;**value {
                Expr::Compare(_) =&gt; &quot;comparison&quot;,
                Expr::UnaryOp(ast::ExprUnaryOp {
                    op: ast::UnaryOp::Not,
                    ..
                }) =&gt; &quot;unary `not`&quot;,
                Expr::BoolOp(_) =&gt; &quot;boolean&quot;,
                Expr::If(_) =&gt; &quot;`if-else`&quot;,
                Expr::Lambda(_) =&gt; &quot;lambda&quot;,
                Expr::Named(_) if allow_named_expression.is_no() =&gt; &quot;named&quot;,
                _ =&gt; return,
            };

            self.add_error(
                ParseErrorType::OtherError(format!(
                    &quot;{expr_kind} expression cannot be used here&quot;,
                )),
                expr.range(),
            );
        }
        _ =&gt; {}
    }
}
</code></pre>
<p>For this solution, the parser will need to verify the precedence of a starred expression wherever grammar expected the <code>star_expressions</code>, <code>star_expression</code> or <code>star_named_expression</code> rule.</p>
<p>We could possibly adopt this solution for better error recovery but I think for now having a strict parser is better suited because we don&#x27;t really know what complete error recovery looks like.</p>
Follow-up
<p>There&#x27;s a related follow-up issue which I&#x27;m working on and is related to starred expressions.
The starred expression is only allowed in certain expressions and context which the parser needs to make sure and report an error if found otherwise.</p>
Test Plan
<p>Tested this locally by changing various expression and statement to use these methods. As mentioned they will be in their own PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">parser</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-27 08:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-27 08:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-27 08:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-27 08:57</div>
            <div class="timeline-body"><p>(Converting to draft because I think it might be better to use the second solution as described in the PR description.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-03-27 08:58</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
Formatter (stable)
<p>✅ ecosystem check detected no format changes.</p>
Formatter (preview)
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-27 09:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/parser/expression.rs</code>:86 on 2024-03-27 10:10</div>
            <div class="timeline-body"><p>Nit: i find the <code>postfix</code> list a bit confusing because we aren&#x27;t parsing a list (and the term is overloaded in the <code>Parser</code> context where we have <code>parse_list</code> and <code>parse_list_expression</code>) but I don&#x27;t have a better name recommendation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-03-27 10:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-29 07:47</div>
            <div class="timeline-body"><p>For future reference, this change is going to be updated to use the &quot;other&quot; solution mentioned in the PR description. Not all will be reverted but instead of having a <code>parse_expression_with_bitwise_or_precedence</code>, we&#x27;ll allow the starred expression to be parsed with the highest precedence and limit it later by checking if it&#x27;s allowed as per &quot;bitwise or&quot; precedence and report an error.</p>
<p>I don&#x27;t want to add the change here as it&#x27;ll require updating all of the PRs in the stack. I&#x27;ll link the PR when it&#x27;s opened.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-29 07:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-03-29 07:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-03-29 07:48</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:02:43 UTC
    </footer>
</body>
</html>
