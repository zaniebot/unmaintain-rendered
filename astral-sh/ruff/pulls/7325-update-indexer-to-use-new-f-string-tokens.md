```yaml
number: 7325
title: "Update `Indexer` to use new f-string tokens"
type: pull_request
state: merged
author: dhruvmanila
labels:
  - core
  - python312
assignees: []
merged: true
base: dhruv/pep-701
head: dhruv/issue-7290
created_at: 2023-09-13T04:41:42Z
updated_at: 2023-09-28T03:58:50Z
url: https://github.com/astral-sh/ruff/pull/7325
synced_at: 2026-01-12T02:39:09Z
```

# Update `Indexer` to use new f-string tokens

---

_Pull request opened by @dhruvmanila on 2023-09-13 04:41_

## Summary

This PR updates the `Indexer` to use the new f-string tokens to compute the `f_string_ranges` for f-strings. It adds a new abstraction which exposes two methods to support extracting the range for the surrounding innermost and outermost f-string. It uses the builder pattern to build the f-string ranges which is similar to how the comment ranges are built.

## Test Plan

Add new test cases for f-strings for:
* Tab indentation rule
* Line continuation detection in the indexer
* To get the innermost / outermost f-string range
* All detected f-string ranges

fixes: #7290


---

_Comment by @dhruvmanila on 2023-09-13 04:41_

Current dependencies on/for this PR:
* main
  * **PR #7376** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7376" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7690** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7690" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7667** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7667" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7597** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7597" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7588** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7588" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
      * **PR #7589** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7589" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7586** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7586" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7515** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7515" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7477** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7477" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7387** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7387" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7378** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7378" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7329** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7329" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7328** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7328" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7327** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7327" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7326** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7326" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a> 
    * **PR #7325** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/7325" target="_blank"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ

This comment was auto-generated by [Graphite](https://app.graphite.dev/github/pr/astral-sh/ruff/7325?utm_source=stack-comment).

---

_Label `python312` added by @dhruvmanila on 2023-09-13 05:12_

---

_Label `core` added by @dhruvmanila on 2023-09-13 05:12_

---

_@dhruvmanila reviewed on 2023-09-14 02:54_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/indexer.rs`:92 on 2023-09-14 02:54_

In previous implementation, triple-quoted f-strings were only stored in `triple_quoted_string_ranges` and not in `f_string_ranges`. Was that an expected behavior?

Currently, I'm storing in both ranges but I can revert back to the original bahavior.

---

_Marked ready for review by @dhruvmanila on 2023-09-14 02:55_

---

_Review requested from @charliermarsh by @dhruvmanila on 2023-09-14 02:55_

---

_Review requested from @MichaReiser by @dhruvmanila on 2023-09-14 02:55_

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/indexer.rs`:84 on 2023-09-14 06:43_

We need to use `saturating_sub` because we use `.flatten` which filters out `Err` token. Meaning, it could happen that we skip an arbitrary number of valid tokens.

Or you rewrite it to guarantee that `if f_string_start_count == 0` can only be true exactly once. 

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/indexer.rs`:75 on 2023-09-14 06:48_

I don't think that only storing the full f-string ranges is sufficient anymore. E.g. the `tab_indentation` needs to know whether it is inside of a multiline string. But that should only return true if it is inside a FString-Middle part of a multiline string, e.g. the following should trigger but would not

```python
f"""test{
    tab_indented_should_be_flagged
}   <- this tab is fine"""
```

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/indexer.rs`:73 on 2023-09-14 06:49_

Can we add a test for line continuations inside of strings and that is properly handled by the indexer?

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/indexer.rs`:94 on 2023-09-14 06:53_

`f_string_quote_style` is the only usage of `f_string_ranges`. It tries to find the f string quote style of the enclosing f-string. Does the current implementation support nested fstrings? Does the binary search still work with nested fstrings or how do we ensure we find the "smallest" range that fully encloses the expression. 

https://github.com/astral-sh/ruff/blob/04f2842e4f187a26ff74d7b845f3cdc6abacf765/crates/ruff/src/checkers/ast/mod.rs#L179-L195

---

_@MichaReiser requested changes on 2023-09-14 06:53_

Can you add tests for the upstream functions that use the metadata extracted by the `Indexer` to ensure they are working as intended. 

---

_@dhruvmanila reviewed on 2023-09-14 07:47_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/indexer.rs`:75 on 2023-09-14 07:47_

I agree with this but this isn't triggered on the stable version as well. I think I would prefer to have a 1-1 change between the stable version and with the new f-string tokens version. We can fix this bug later on (#7379).

---

_Comment by @dhruvmanila on 2023-09-14 10:45_

## Nested f-strings:

Pre 3.12, nested f-strings were possible but up to an extent. For example,

```python
f"outside {f'inside'} outside"
# or
f'outside {f"inside"} outside'
```

The rules which performs checks on strings donâ€™t support nested f-strings. For example,

```python
f"{f"\y"}"
```

For the above code snippet, the `W605` (`invalid-escape-sequence`) incorrectly auto-fixes by adding the `r` prefix to the outermost f-string while it should be added to the f-string which contains the escape character.

### F-string ranges:

The `Indexer` includes the range of the outermost f-string while it should probably include the actual range of all the f-strings. This creates a challenge in the way f-string ranges are inserted as the vector needs to be sorted for the binary search to work but thatâ€™s an implementation detail.

Currently, the f-string range is only being utilized to get the f-string quote style but this would be incorrect in the case of nested f-strings. For example, in `f"foo {f'{bar}'}"`, for the variable `bar`, the quote style would give `Quote::Double`.

The question is: do we want to proceed with how the current implementation is (use the outermost f-string range) or have separate ranges for each f-strings even if itâ€™s nested?

### Triple-quoted string ranges:

Currently, if a triple-quoted f-string is encountered, then the range is only recorded as a triple-quoted string but not as a f-string i.e., itâ€™s only being inserted to `indexer.triple_quoted_string_ranges` and not `indexer.f_string_ranges`. Iâ€™m not sure if thatâ€™s intentional or not but with the current changes, Iâ€™m inserting it into both.

This is only being utilized in `W191` (`tab-indentation`) which works on physical lines. This creates a problem as we canâ€™t really know if this line is part of a f-string expression or non-expression part (thus, https://github.com/astral-sh/ruff/issues/7379).

Another challenge here is that with f-strings even the triple-quoted strings can be nested:

```python
f"""first level
of triple-quoted {f"""second level
of triple-quoted"""}
f-strings"""
```

This again brings up the question of how granular we want the triple-quoted string ranges to be?

---

I'm leaning towards keeping the behavior same and we can iterate to fix the issues around nested f-strings. But, if we're sure on how to handle nested f-strings I can make the changes here.

---

_Comment by @MichaReiser on 2023-09-15 06:08_

> F-string ranges:

Technically, I think we can solve this by using a `BTreeMap<TextSize, TextRange>` where the key is the start position of the f-string and the value is the string range. Finding the enclosing f-strings for an offset is then `map.range(...Include(offset)).rev().filter(|range| range.contains(offset))`. This doesn't just give you the enclosing f-string but an iterator over all enclosing fstrings. 

> Currently, the f-string range is only being utilized to get the f-string quote style but this would be incorrect in the case of nested f-strings. 

More specifically, it seems this is only used to guess the appropriate quote style for an fstring. This logic won't be needed for Python 3.12+ because we can pick any quote style (ideally, the default quote style). 

It might be okay to leave the implementation as is but we should document the limitation and its intended use case. Not that more call sites are introduced that incorrectly assume it supports nested FStrings correctly. 

> Currently, if a triple-quoted f-string is encountered, then the range is only recorded as a triple-quoted string but not as a f-string i.e., itâ€™s only being inserted to indexer.triple_quoted_string_ranges and not indexer.f_string_ranges. Iâ€™m not sure if thatâ€™s intentional or not but with the current changes, Iâ€™m inserting it into both.

I don't think this was intentional. 

> This is only being utilized in W191 (tab-indentation) which works on physical lines. This creates a problem as we canâ€™t really know if this line is part of a f-string expression or non-expression part (thus, https://github.com/astral-sh/ruff/issues/7379).

I wonder if it would be easier to rewrite that rule to a token-based rule rather than trying to extract all the data at a granularity level close to the individual tokens. 

Except if we plan to to re-use the multiline-string ranges for `add-noqa` as well: 

https://github.com/astral-sh/ruff/blob/fc89976c24d1c8b9d13d88ef70b619e8a2ac393a/crates/ruff/src/directives.rs#L90-L114


I would be interested to get @charliermarsh's opinion on this, who is more familiar with the use cases (I only know the `Indexer` from when I refactored from column to byte offsets).

---

_Comment by @codspeed-hq[bot] on 2023-09-18 16:56_

## [CodSpeed Performance Report](https://codspeed.io/astral-sh/ruff/branches/dhruv/issue-7290)

### Merging #7325 will **not alter performance**

<sub>Comparing <code>dhruv/issue-7290</code> (0b2e6bb) with <code>dhruv/pep-701</code> (c496d9c)</sub>



### Summary

`âœ… 25` untouched benchmarks






---

_Comment by @MichaReiser on 2023-09-18 19:15_

Could you rebase your PRs so that we get clear benchmark numbers? This all looks worrying but they're probably false positives

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/fstring_ranges.rs`:20 on 2023-09-18 19:19_

The worst-case complexity of this is that this function traverses all values in the map. Would it be sufficient to only look at the last element in the range?
```suggestion
				self.raw.range(..=offset).last().filter(|range| range.contains(offset)).copied()
```

It may be worth a comment why the filter is necessary

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/fstring_ranges.rs`:50 on 2023-09-18 19:21_

This has a worst time complexity of `O(n)` if the searched offset is the last in the map. 

I think it would be better to iterate from the back and take the last entry where `range.contains` is still true. This should be `O(log(n))` for almost all entries

---

_Review comment by @MichaReiser on `crates/ruff_python_index/src/fstring_ranges.rs`:82 on 2023-09-18 19:22_

Nit; Maybe add a debug assertion that `start_locations` is empty

---

_@MichaReiser approved on 2023-09-18 19:22_

---

_@dhruvmanila reviewed on 2023-09-19 03:33_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/fstring_ranges.rs`:20 on 2023-09-19 03:33_

> Would it be sufficient to only look at the last element in the range?

Unfortunately no. Let me explain using an example:

```python
f"first {f"second"} first"
```

Here, there are 2 f-strings with the following range:
1. `0..26` (outer)
2. `9..17` (inner)

Now, when we want to find the f-string for the offset 20 which is _after_ the inner f-string that's where the `find` comes in handy.

The `range` method will give both ranges because `range(..=20)` satisfies both. But, when iterating backwards, it isn't in (2) but in (1).

---

_@dhruvmanila reviewed on 2023-09-19 04:27_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/fstring_ranges.rs`:20 on 2023-09-19 04:27_

Per your suggestion, we need to filter first and then get the last element:
```rust
        self.raw
            .range(..=offset)
            .filter(|(_, range)| range.contains(offset))
            .last()
            .map(|(_, range)| *range)
```

But, I think the original version is optimal as it'll short circuit on the first find while the filter would go through all the ranges and then get the last `Some` element.

---

_@dhruvmanila reviewed on 2023-09-19 04:50_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/fstring_ranges.rs`:50 on 2023-09-19 04:50_

Yes, this is correct. Thanks for the suggestion. One thing to note is that we'll have to skip the initial ranges where the offset doesn't belong because those will be part of the inner ranges while the offset might be part of an outer range. The iterator of nested ranges goes from the innermost to the outermost.

For example:
```python
#                                                     v
  f"normal" f"another" f"first {f"second {f"third"} second"} first"
#                                         ^^^1^^^^
#                               ^^^^^^^^^^^^^2^^^^^^^^^^^^^
#                      ^^^^^^^^^^^^^^^^^^^^^^3^^^^^^^^^^^^^^^^^^^^^
#           ^^^^4^^^^^
# ^^^^5^^^^
```

If the offset is where `v` is at, then the iterator would yield the range in the order mentioned above. Now, the offset doesn't belong in (1) so we will skip until we get a range where the offset belongs to. Then, we'll continue until we get a range which _doesn't_ contain the offset and the last range will be the outermost range.

So, skip (1), next (2), next (3), stop. Outermost range is (3).

---

_@dhruvmanila reviewed on 2023-09-19 06:06_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/indexer.rs`:75 on 2023-09-19 06:06_

Added a test case for single and triple-quoted f-strings

---

_@dhruvmanila reviewed on 2023-09-19 06:16_

---

_Review comment by @dhruvmanila on `crates/ruff_python_index/src/indexer.rs`:73 on 2023-09-19 06:16_

Added test cases for line continuation within f-strings (and nested).

---

_Merged by @dhruvmanila on 2023-09-19 06:25_

---

_Closed by @dhruvmanila on 2023-09-19 06:25_

---

_Branch deleted on 2023-09-19 06:25_

---
