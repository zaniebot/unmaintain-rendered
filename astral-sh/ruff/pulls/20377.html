<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Heterogeneous unpacking support for unions - astral-sh/ruff #20377</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Heterogeneous unpacking support for unions</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20377">#20377</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-09-14 16:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body">Summary
<p>This PR adds precise heterogeneous unpacking support for unions.</p>
<p>For a tuple such as <code>tuple[int, str]</code>, we&#x27;ve long recognised that if you unpack this tuple, the first element will be an <code>int</code> and the second will be a <code>str</code>. But the same has not been true for <code>tuple[Literal[42], str] | tuple[Literal[56], str]</code> -- if a user unpacked this union of tuples, we would infer that both first and second elements were of type <code>Literal[42, 56] | str</code>. This PR fixes that: we now infer that the first element will be of type <code>Literal[42, 56]</code> and the second element will be of type <code>str</code>.</p>
<p>This doesn&#x27;t add much complexity to our iteration logic, fixes a number of false positives in the ecosystem, and (surprisingly!) leads to a <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Ftuplespec-union">nice performance boost</a> on the colour-science benchmark.</p>
Test Plan
<p>Mdtests added</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-09-14 16:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-14 16:48</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests ‚úÖ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-09-14 19:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-09-14 19:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-14 19:31</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>scrapy (https://github.com/scrapy/scrapy)
- scrapy/http/headers.py:39:21: error[not-iterable] Object of type `AnyStr@update` may not be iterable
- scrapy/utils/datatypes.py:91:66: error[not-iterable] Object of type `AnyStr@update` may not be iterable
- Found 1067 diagnostics
+ Found 1065 diagnostics

vision (https://github.com/pytorch/vision)
- references/classification/utils.py:420:5: error[invalid-assignment] Object of type `tuple[type | Unknown, ...]` is not assignable to `list[type] | None`
+ references/classification/utils.py:420:5: error[invalid-assignment] Object of type `tuple[type, ...] | tuple[Unknown, ...]` is not assignable to `list[type] | None`

xarray (https://github.com/pydata/xarray)
- xarray/tests/test_groupby.py:3059:32: error[parameter-already-assigned] Multiple values provided for parameter `freq` of function `date_range`
- Found 1617 diagnostics
+ Found 1616 diagnostics

koda-validate (https://github.com/keithasaurus/koda-validate)
- koda_validate/generic.py:236:21: error[not-iterable] Object of type `ListOrTupleOrSetAny@UniqueItems` may not be iterable
- Found 69 diagnostics
+ Found 68 diagnostics

scikit-learn (https://github.com/scikit-learn/scikit-learn)
- sklearn/utils/tests/test_multiclass.py:410:27: warning[possibly-missing-attribute] Attribute `toarray` on type `(Unknown &amp; SparseABC) | (list[Unknown | list[Unknown | int]] &amp; SparseABC) | (list[Unknown | list[Unknown | str]] &amp; SparseABC) | ... omitted 11 union elements` may be missing
+ sklearn/utils/tests/test_multiclass.py:410:27: warning[possibly-missing-attribute] Attribute `toarray` on type `(Unknown &amp; SparseABC) | (list[Unknown | list[Unknown | int]] &amp; SparseABC) | (_NotAnArray &amp; SparseABC) | ... omitted 11 union elements` may be missing

pandas (https://github.com/pandas-dev/pandas)
- pandas/tests/util/test_assert_extension_array_equal.py:108:41: error[invalid-argument-type] Argument to function `assert_extension_array_equal` is incorrect: Expected `bool | Literal[&quot;equiv&quot;]`, found `@Todo | SparseArray`
- pandas/tests/util/test_assert_extension_array_equal.py:108:41: error[invalid-argument-type] Argument to function `assert_extension_array_equal` is incorrect: Expected `str`, found `@Todo | SparseArray`
- Found 3389 diagnostics
+ Found 3387 diagnostics

core (https://github.com/home-assistant/core)
- homeassistant/components/lovelace/websocket.py:58:46: error[invalid-argument-type] Argument to bound method `send_error` is incorrect: Expected `dict[str, Any] | None`, found `str`
- Found 13756 diagnostics
+ Found 13755 diagnostics

</code></pre>

No memory usage changes detected ‚úÖ

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-11 12:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-11 12:36</div>
            <div class="timeline-body">

<code>ecosystem-analyzer</code> results
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>invalid-argument-type</code> | 0 | 6 | 0 |
| <code>parameter-already-assigned</code> | 0 | 1 | 0 |
| <strong>Total</strong> | <strong>0</strong> | <strong>7</strong> | <strong>0</strong> |</p>
<p><strong><a href="https://alex-tuplespec-union.ecosystem-663.pages.dev/diff">Full report with detailed diff</a></strong> (<a href="https://alex-tuplespec-union.ecosystem-663.pages.dev/timing">timing results</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-10-11 12:37</div>
            <div class="timeline-body">

<a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Ftuplespec-union">CodSpeed Performance Report</a>
Merging #20377 will <strong>improve performances by 6.26%</strong>
<p>Comparing <code>alex/tuplespec-union</code> (8dde577) with <code>main</code> (4b7f184)</p>
Summary
<p><code>‚ö° 1</code> improvement<br>
<code>‚úÖ 20</code> untouched<br>
<code>‚è© 30</code> skipped[^skipped]</p>
Benchmarks breakdown
<p>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | ---- | --------- | ------ | ------ | ------ |
| ‚ö° | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Ftuplespec-union?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Amedium%5Bcolour-science%5D&amp;runnerMode=WallTime"><code>medium[colour-science]</code></a> | 11.2 s | 10.5 s | +6.26% |
[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Ftuplespec-union?sectionId=benchmark-comparison-section-baseline-result-skipped">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-11 13:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:5534 on 2025-10-11 13:48</div>
            <div class="timeline-body"><p>other than the <code>Type::Union</code> branch, this is exactly the same code that used to exist in the <code>match</code> statement slightly lower down. It&#x27;s just been extracted into a standalone function (so that it can be called recursively), and moved higher up to satisfy Clippy.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-11 14:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-11 14:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-11 14:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-11 14:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-13 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-13 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-10-14 00:51</div>
            <div class="timeline-body"><p>We&#x27;ve supported unpacking of unions like this <a href="https://github.com/astral-sh/ruff/blob/5e08e5451df62398caf16034ae50621e46688641/crates/ty_python_semantic/resources/mdtest/unpacking.md#L762">in assignments</a>, but it looks like this implementation might be more general. Can we replace the older union-related code in <code>types/unpacker.rs</code> with calls to this new logic?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/sharkdp">@sharkdp</a> removed by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-10-14 07:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-14 11:42</div>
            <div class="timeline-body"><blockquote>
<p>We&#x27;ve supported unpacking of unions like this <a href="https://github.com/astral-sh/ruff/blob/5e08e5451df62398caf16034ae50621e46688641/crates/ty_python_semantic/resources/mdtest/unpacking.md#L762">in assignments</a>, but it looks like this implementation might be more general. Can we replace the older union-related code in <code>types/unpacker.rs</code> with calls to this new logic?</p>
</blockquote>
<p>That&#x27;s a great question. I&#x27;ve just spent a while looking at this (probably longer than I should have!), and my answer is... I don&#x27;t think so, unfortunately. Obtaining a different tuple spec for each union member, like <code>unpacker.rs</code> is doing, is still preferable to calling <code>try_iterate()</code> directly on a union type -- it&#x27;s still less lossy, yields better fallback results in the case of errors, and gives better error messages.</p>
<p>I experimented with having <code>Type::try_iterate()</code> return <code>Result&lt;IterationOutcome&lt;&#x27;db&gt;, IterationError&lt;&#x27;db&gt;&gt;</code>, where <code>IterationOutcome</code> is an abstraction that looks like this:</p>
<pre><code>struct IterationOutcome&lt;&#x27;db&gt;(smallvec::SmallVec&lt;[Cow&lt;&#x27;db, TupleSpec&lt;&#x27;db&gt;&gt;; 1]&gt;);
</code></pre>
<p>but even that is too lossy a representation for <code>unpacker.rs</code>. <code>unpacker.rs</code> really needs to know whether each individual union element is iterable, and what kind of diagnostic it emits if it&#x27;s not. So for <code>unpacker.rs</code> to be able to use <code>try_iterate</code> without manually mapping over the union elements, <code>try_iterate</code> would need to return <code>IterationOutcome&lt;&#x27;db&gt;</code>, where <code>IterationOutcome</code> looks like</p>
<pre><code>struct IterationOutcome&lt;&#x27;db&gt;(
    smallvec::SmallVec&lt;[Result&lt;Cow&lt;&#x27;db, TupleSpec&lt;&#x27;db&gt;&gt;, IterationError&lt;&#x27;db&gt;&gt;; 1]&gt;
);
</code></pre>
<p>At which point the abstraction becomes so complicated, that I think it&#x27;s probably not worth it anymore.</p>
<p>So the question is: what does this PR actually get us?</p>
<p>Firstly it gets us much better call-binding for calls with variadic parameters: unlike in <code>unpacker.rs</code>, we do not map over the union elements manually in <code>call/bind.rs</code>. Maybe we <em>should</em> map over the union elements there, like in <code>unpacker.rs</code>, but it looks awkward to pull off: https://github.com/astral-sh/ruff/blob/ac2c5303775bcf52d40eea406939a6961774e6af/crates/ty_python_semantic/src/types/call/bind.rs#L2283-L2291</p>
<p>Secondly, it gets us much more precise inference even if all you want is the <em>homogeneous</em> element type. For example:</p>
<pre><code>from typing import Literal

def f(x: Literal[&quot;abc&quot;, &quot;def&quot;]):
    for item in x:
        # main: LiteralString
        # This PR: Literal[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]
        reveal_type(item)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/call/function.md</code>:735 on 2025-10-14 19:39</div>
            <div class="timeline-body"><p>bit of a nit: Using <code>&quot;a&quot;</code>, etc as the values in <code>my_args</code> and <code>my_other_args</code> made me assume at first that you would be exercising <code>**</code> unpacking, where it&#x27;s important that some of the values line up with parameter names. Maybe use integer literals instead of string literals to eliminate that confusion?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/call/bind.rs</code>:1116 on 2025-10-14 19:44</div>
            <div class="timeline-body"><p>Not blocking for this PR, but this pattern seems to come up enough to deserve a helper method on <code>Type</code> ‚Äî a <code>map_over_union</code> that applies the function to each union element if it&#x27;s a union, or to the individual type if not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/tuple.rs</code>:1586 on 2025-10-14 19:45</div>
            <div class="timeline-body"><p>nit: Can you throw a <code>copied</code> onto each iterator so that this can return <code>Iterator&lt;Item = Type&gt;</code>? I find it good karma to not make the caller have to worry about that</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/tuple.rs</code>:1626 on 2025-10-14 19:47</div>
            <div class="timeline-body"><p>To be fair, such a branch wouldn&#x27;t be <em>that</em> much longer than the explanation for why it&#x27;s not present... üòÑ  But I don&#x27;t disagree with your argument, and am fine with leaving it out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> approved on 2025-10-14 19:51</div>
            <div class="timeline-body"><blockquote>
<p>That&#x27;s a great question. I&#x27;ve just spent a while looking at this (probably longer than I should have!), and my answer is... I don&#x27;t think so, unfortunately.</p>
</blockquote>
<p>Thanks for looking at that! No argument with your findings. Can you summarize them in the code? Possibly in <code>unpacker.rs</code>, to explain why you can&#x27;t use the union-handling logic that we use for argument splatting</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-14 20:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/tuple.rs</code>:1626 on 2025-10-14 20:09</div>
            <div class="timeline-body"><p>Yeah, I had it originally, but then couldn&#x27;t figure out a test for it that actually reflected something that might come up in real-world code, and the virtue of a comment is it doesn&#x27;t need tests üòÜ so I ripped it out</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-15 18:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/tuple.rs</code>:1586 on 2025-10-15 18:02</div>
            <div class="timeline-body"><p>Hmm, I feel like here it&#x27;s more ergonomic to have it return <code>Iterator&lt;Item = &amp;Type&lt;&#x27;db&gt;&gt;</code>, because then it matches the signature of <code>TupleSpec::all_elements</code> (and, indeed, the two other <code>all_elements()</code> methods in this module!):</p>
<p>https://github.com/astral-sh/ruff/blob/6f468ae8e33bf3ad1d342d29c049fb620c701ca0/crates/ty_python_semantic/src/types/tuple.rs#L343-L345</p>
<p>it seems like strictly more code for not much gain here, if I make it return <code>Iterator&lt;Item = Type&lt;&#x27;db&gt;&gt;</code> rather than <code>Iterator&lt;Item = &amp;Type&lt;&#x27;db&gt;&gt;</code>?</p>
<pre><code>diff --git a/crates/ty_python_semantic/src/types/tuple.rs b/crates/ty_python_semantic/src/types/tuple.rs
index dcb3df675d..cc39e696f8 100644
--- a/crates/ty_python_semantic/src/types/tuple.rs
+++ b/crates/ty_python_semantic/src/types/tuple.rs
@@ -1583,7 +1583,7 @@ impl&lt;&#x27;db&gt; TupleSpecBuilder&lt;&#x27;db&gt; {
         }
     }
 
-    fn all_elements(&amp;self) -&gt; impl Iterator&lt;Item = &amp;Type&lt;&#x27;db&gt;&gt; {
+    fn all_elements(&amp;self) -&gt; impl Iterator&lt;Item = Type&lt;&#x27;db&gt;&gt; {
         match self {
             TupleSpecBuilder::Fixed(elements) =&gt; Either::Left(elements.iter()),
             TupleSpecBuilder::Variable {
@@ -1592,6 +1592,7 @@ impl&lt;&#x27;db&gt; TupleSpecBuilder&lt;&#x27;db&gt; {
                 suffix,
             } =&gt; Either::Right(prefix.iter().chain(std::iter::once(variable)).chain(suffix)),
         }
+        .copied()
     }
 
     /// Return a new tuple-spec builder that reflects the union of this tuple and another tuple.
@@ -1625,8 +1626,10 @@ impl&lt;&#x27;db&gt; TupleSpecBuilder&lt;&#x27;db&gt; {
             // would actually lead to more precise inference, so it&#x27;s probably not worth the
             // complexity.
             _ =&gt; {
-                let unioned =
-                    UnionType::from_elements(db, self.all_elements().chain(other.all_elements()));
+                let unioned = UnionType::from_elements(
+                    db,
+                    self.all_elements().chain(other.all_elements().copied()),
+                );
                 TupleSpecBuilder::Variable {
                     prefix: vec![],
                     variable: unioned,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-15 18:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-15 18:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-10-15 18:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:18:36 UTC
    </footer>
</body>
</html>
