<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Implement equivalence for protocols with method members - astral-sh/ruff #18659</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Implement equivalence for protocols with method members</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18659">#18659</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-06-13 12:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR implements the following pieces of <code>Protocol</code> semantics:</p>
<ol>
<li>A protocol with a method member that does not have a fully static signature should not be considered fully static. I.e., this protocol is not fully static because <code>Foo.x</code> has no return type; we previously incorrectly considered that it was:</li>
</ol>
<pre><code class="language-py">class Foo(Protocol):
    def f(self): ...
</code></pre>
<ol start="2">
<li>Two protocols <code>P1</code> and <code>P2</code>, both with method members <code>x</code>, should be considered equivalent if the signature of <code>P1.x</code> is equivalent to the signature of <code>P2.x</code>. Currently we do not recognize this.</li>
</ol>
<p>Implementing these semantics requires distinguishing between method members and non-method members. The stored type of a method member must be eagerly upcast to a <code>Callable</code> type when collecting the protocol's interface: doing otherwise would mean that it would be hard to implement equivalence of protocols even in the face of differently ordered unions, since the two equivalent protocols would have different Salsa IDs even when normalized.</p>
<p>The semantics implemented by this PR are that we consider something a method member if:</p>
<ol>
<li>It is accessible on the class itself; and</li>
<li>It is a function-like callable: a callable type that also has a <code>__get__</code> method, meaning it can be used as a method when accessed on instances.</li>
</ol>
<p>Note that the spec has complicated things to say about classmethod members and staticmethod members. These semantics are not implemented by this PR; they are all deferred for now.</p>
<p>The infrastructure added in this PR fixes bugs in its own right, but also lays the groundwork for implementing subtyping and assignability rules for method members of protocols. A (currently failing) test is added to verify this.</p>
<h2>Test Plan</h2>
<p>mdtests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-06-13 12:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-06-13 12:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2025-06-13 12:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-06-13 12:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 12:13</div>
            <div class="timeline-body"><p>Hooray... more protocol-related stack overflows...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 12:17</div>
            <div class="timeline-body"><p>In the corpus test, we're overflowing our stack when pulling types for <a href="https://github.com/astral-sh/ruff/blob/3aae1cd59b6490c72af055d28add6cc2f983e545/crates/ty_vendored/vendor/typeshed/stdlib/hashlib.pyi"><code>hashlib.pyi</code> in typeshed</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 12:28</div>
            <div class="timeline-body"><p>Minimal repro for the overflow:</p>
<pre><code class="language-py">from typing_extensions import Protocol, Self

class _HashObject(Protocol):
    def copy(self) -&gt; Self: ...

class Foo: ...

x: Foo | _HashObject
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 12:58</div>
            <div class="timeline-body"><p>The stack overflow is because <code>Self</code> is implemented as a TypeVar where the upper bound is a self-reference. In order to build the union <code>Foo | _HashObject</code> we need to know whether <code>_HashObject</code> is fully static. This now requires us to look at the return annotation of any method members; previously, we did not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 13:08</div>
            <div class="timeline-body"><p>I fixed the issue with <code>Self</code> in https://github.com/astral-sh/ruff/pull/18659/commits/cae39bb4230351715e01129df31742f12ced86ef (at least, we no longer panic when running ty on typeshed üòÑ -- let's see what primer says...).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 13:52</div>
            <div class="timeline-body"><p>The stack overflow in mypy_primer is on psycopg. I'm attempting to minimize it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-13 14:37</div>
            <div class="timeline-body"><p>Self-contained repro for the psycopg overflow:</p>
<pre><code class="language-py">from typing_extensions import Protocol, Self

class PGconn(Protocol):
    def connect(self) -&gt; Self: ...

class Connection:
    pgconn: PGconn

def is_crdb(conn: PGconn) -&gt; bool:
    isinstance(conn, Connection)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-17 10:55</div>
            <div class="timeline-body"><p>This also repros the overflow: it's the fact that the <code>Self</code> type parameter has a recursive upper bound that matters:</p>
<pre><code class="language-py">from typing_extensions import Protocol

class PGconn(Protocol):
    def connect[T: PGconn](self: T) -&gt; T: ...

class Connection:
    pgconn: PGconn

def f(x: PGconn):
    isinstance(x, Connection)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-17 15:03</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">parso (https://github.com/davidhalter/parso)
-     memo fields = ~49MB
+     memo fields = ~54MB

attrs (https://github.com/python-attrs/attrs)
-     struct metadata = ~2MB
+     struct metadata = ~3MB

anyio (https://github.com/agronholm/anyio)
-     memo metadata = ~6MB
+     memo metadata = ~7MB

Expression (https://github.com/cognitedata/Expression)
-     memo metadata = ~6MB
+     memo metadata = ~7MB

mypy-protobuf (https://github.com/dropbox/mypy-protobuf)
-     struct fields = ~1MB
+     struct fields = ~2MB

discord.py (https://github.com/Rapptz/discord.py)
-     memo fields = ~189MB
+     memo fields = ~207MB

ignite (https://github.com/pytorch/ignite)
-     memo fields = ~189MB
+     memo fields = ~171MB

mkosi (https://github.com/systemd/mkosi)
-     memo metadata = ~10MB
+     memo metadata = ~11MB
-     memo fields = ~129MB
+     memo fields = ~117MB

flake8 (https://github.com/pycqa/flake8)
-     memo fields = ~60MB
+     memo fields = ~66MB

SinbadCogs (https://github.com/mikeshardmind/SinbadCogs)
-     memo metadata = ~4MB
+     memo metadata = ~5MB

colour (https://github.com/colour-science/colour)
- TOTAL MEMORY USAGE: ~405MB
+ TOTAL MEMORY USAGE: ~445MB

pandas-stubs (https://github.com/pandas-dev/pandas-stubs)
-     memo metadata = ~28MB
+     memo metadata = ~30MB

AutoSplit (https://github.com/Toufool/AutoSplit)
- TOTAL MEMORY USAGE: ~207MB
+ TOTAL MEMORY USAGE: ~228MB

django-stubs (https://github.com/typeddjango/django-stubs)
-     struct metadata = ~6MB
+     struct metadata = ~7MB

openlibrary (https://github.com/internetarchive/openlibrary)
-     memo fields = ~171MB
+     memo fields = ~189MB

scrapy (https://github.com/scrapy/scrapy)
-     memo fields = ~207MB
+     memo fields = ~189MB

bokeh (https://github.com/bokeh/bokeh)
- TOTAL MEMORY USAGE: ~276MB
+ TOTAL MEMORY USAGE: ~251MB

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-06-17 15:19</div>
            <div class="timeline-body"><p>@AlexWaygood I wouldn't spend too much time digging into those psycopg2 stack overflows -- they seem like pretty straightforward cases of recursive protocols, where I'd expect us to stack overflow currently. I think either adding psycopg2 to <code>bad.txt</code>, or holding off on this PR until we support recursive protocols (if we're worried about users seeing new stack overflows) are probably the right answers here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-17 15:33</div>
            <div class="timeline-body"><blockquote>
<p>@AlexWaygood I wouldn't spend too much time digging into those psycopg2 stack overflows -- they seem like pretty straightforward cases of recursive protocols, where I'd expect us to stack overflow currently. I think either adding psycopg2 to <code>bad.txt</code>, or holding off on this PR until we support recursive protocols (if we're worried about users seeing new stack overflows) are probably the right answers here.</p>
</blockquote>
<p>Alrighty -- in that case, this PR is ready for review. It adds 3 projects to <code>bad.txt</code>: psycopg, pytest and scrapy. (That might be too much, but I think if that's the case then we can essentially implement no new protocol features until we get the recursive-protocol issue fixed ‚òπÔ∏è)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-17 16:13</div>
            <div class="timeline-body"><p>(I do still wish I understood more specifically what difference the <code>isinstance()</code> call makes here. https://github.com/astral-sh/ruff/pull/18659/commits/6db4b6c7048064df64d7e83b4ceeb2db3e50f776 <em>did</em> fix the original stack overflow from https://github.com/astral-sh/ruff/pull/18659#issuecomment-2970240270, but not the new one that has the <code>isinstance()</code> call.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @AlexWaygood on 2025-07-01 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-01 14:05</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/pull/18659#issuecomment-2970609588 and https://github.com/astral-sh/ruff/pull/18659#issuecomment-2979899363 no longer cause stack overflows now this branch has been rebased on top of https://github.com/astral-sh/ruff/pull/19003... but there are still stack overflows on kopf/jinja that are causing the mypy_primer run to fail...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-07-01 14:13</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_WALLTIME_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Fmethod-members?runnerMode=WallTime">CodSpeed WallTime Performance Report</a></h2>
<h3>Merging #18659 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>alex/method-members</code> (f81ba79) with <code>main</code> (e0b7f49)</sub></p>
<h3>Summary</h3>
<p><code>‚úÖ 7</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-01 15:42</div>
            <div class="timeline-body"><p>Here's a minimized repro for the overflow on jinja on this branch:</p>
<pre><code class="language-py">from typing import cast, Protocol

class Iterator[T](Protocol):
    def __iter__(self) -&gt; Iterator[T]: ...

def f(value: Iterator):
    cast(Iterator, value)
</code></pre>
<p>It only occurs if the <code>Iterator</code> protocol is generic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-01 16:32</div>
            <div class="timeline-body"><blockquote>
<p>Here's a minimized repro for the overflow on jinja on this branch:</p>
<pre><code class="language-python">from typing import cast, Protocol

class Iterator[T](Protocol):
    def __iter__(self) -&gt; Iterator[T]: ...

def f(value: Iterator):
    cast(Iterator, value)
</code></pre>
<p>It only occurs if the <code>Iterator</code> protocol is generic.</p>
</blockquote>
<p>Okay, the overflow goes away if I apply this change:</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/function.rs b/crates/ty_python_semantic/src/types/function.rs
index 8149dad8d3..895ef45377 100644
--- a/crates/ty_python_semantic/src/types/function.rs
+++ b/crates/ty_python_semantic/src/types/function.rs
@@ -1148,8 +1148,6 @@ impl KnownFunction {
                 let contains_unknown_or_todo =
                     |ty| matches!(ty, Type::Dynamic(dynamic) if dynamic != DynamicType::Any);
                 if source_type.is_equivalent_to(db, *casted_type)
-                    &amp;&amp; !casted_type.any_over_type(db, &amp;|ty| contains_unknown_or_todo(ty))
-                    &amp;&amp; !source_type.any_over_type(db, &amp;|ty| contains_unknown_or_todo(ty))
                 {
                     let builder = context.report_lint(&amp;REDUNDANT_CAST, call_expression)?;
                     builder.into_diagnostic(format_args!(
</code></pre>
<p>So it's the <code>any_over_type</code> calls that are causing the overflow here, not the <code>is_equivalent_to</code> call! We likely need to apply a similar change to <code>Type::any_over_type()</code> to the one @carljm applied to <code>Type::normalized()</code> in https://github.com/astral-sh/ruff/pull/19003.</p>
<p>This possibly makes the idea of a generalized <code>TypeVisitor</code> trait (which could have specialized implementations both for implementing <code>Type::normalized()</code> and for implementing <code>Type::any_over_type()</code>?) more appealing? Not sure, though; would need to try it out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-01 18:46</div>
            <div class="timeline-body"><p>Huzzah! No stack overflows, and a clean mypy_primer report.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2025-07-01 18:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-01 18:55</div>
            <div class="timeline-body"><p>I'll clean this up a bit more</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @AlexWaygood on 2025-07-01 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-01 20:38</div>
            <div class="timeline-body"><p>On second thought, I do think that a recursive fallback of <code>false</code> should be hardcoded for <code>any_over_type</code>; there's no (present or future) value in carrying around the <code>recursive_fallback</code> parameter.</p>
<p><code>any_over_type</code> answers the question &quot;does any type anywhere inside this type match the given predicate?&quot; By the very nature of that question, <code>false</code> is the only possible reasonable recursive fallback answer. <code>true</code> could only make sense for a hypothetical <code>all_over_type</code> -- which <code>is_fully_static</code> could have been an example of, had I not removed it :)</p>
<p>If we were implementing some kind of more generic recursive type traversal that we might use for <code>all_over_type</code> questions in future, then I think it might make sense, but I can't see a case for it in an implementation specific to <code>any_over_type</code>, as this one is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-02 15:14</div>
            <div class="timeline-body"><blockquote>
<p><code>any_over_type</code> answers the question &quot;does any type anywhere inside this type match the given predicate?&quot; By the very nature of that question, <code>false</code> is the only possible reasonable recursive fallback answer. <code>true</code> could only make sense for a hypothetical <code>all_over_type</code> -- which <code>is_fully_static</code> could have been an example of, had I not removed it :)</p>
</blockquote>
<p>Couldn't you check to see whether a type is itself recursive by calling <code>ty.any_over_type(db, |_| false, true)</code>? (I.e., the closure itself would never return <code>true</code>, but the overall evaluation would return <code>true</code> if we ever encountered a type that we'd already seen while recursing into it?)</p>
<p>I think I prefer https://github.com/astral-sh/ruff/pull/19094 as a solution over what I have here now though:</p>
<ul>
<li>we only insert non-atomic types into the <code>seen_types</code> cache (avoids unnecessary hashing)</li>
<li>much harder to forget to recurse into nested types</li>
<li>more generalized; it allows us to easily build other functions on top of it as well as <code>any_over_type</code>. E.g. if you wanted to write that <code>is_recursive_type</code> function, you could easily do it using a new <code>TypeVisitor</code> implementation; there's no need to use <code>any_over_type</code> for it at all.</li>
</ul>
<p>The codspeed report for #19094 does overall seem to be better than on this PR, though this PR obviously does a few other things aside from the <code>any_over_type</code> rewrite.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2025-07-03 19:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-03 19:34</div>
            <div class="timeline-body"><p>This is once again ready for review (and really quite a minimal change at this point!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @AlexWaygood on 2025-07-04 13:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-04 14:17</div>
            <div class="timeline-body"><p>This PR unfortunately appears to cause catastrophic execution time on the following snippet, where we're asked to determine in the final line whether one (very large) protocol is assignable to another (also very large) protocol:</p>
<details>

<pre><code class="language-py">from __future__ import annotations

from typing import TypeVar, overload, Protocol
from ty_extensions import is_assignable_to, static_assert

class Foo: ...
class Bar: ...
class Baz: ...

_D = TypeVar(&quot;_D&quot;, bound=&quot;Date&quot;)
_GMaybeTZT = TypeVar(&quot;_GMaybeTZT&quot;, bound=Baz|None, covariant=True)
_GMaybeTZDT = TypeVar(&quot;_GMaybeTZDT&quot;, bound=Baz|None, covariant=True)
_FuncTZ = TypeVar(&quot;_FuncTZ&quot;, bound=Baz)
_FuncOptionalTZ = TypeVar(&quot;_FuncOptionalTZ&quot;, bound=Baz|None)
Self = TypeVar(&quot;Self&quot;)

class Date(Protocol):
    def _subclass_check_hook(cls, instance: object) -&gt; bool: ...
    min: Date
    max: Date
    resolution: Bar
    def fromtimestamp(cls, __timestamp: float) -&gt; Date: ...
    def today(cls) -&gt; Date: ...
    def fromordinal(cls, __n: int) -&gt; Date: ...
    def fromisoformat(cls, __date_string: str) -&gt; Date: ...
    def fromisocalendar(cls, year: int, week: int, day: int) -&gt; Date: ...
    def year(self) -&gt; int: ...
    def month(self) -&gt; int: ...
    def day(self) -&gt; int: ...
    def ctime(self) -&gt; str: ...
    def strftime(self, __format: str) -&gt; str: ...
    def __format__(self, __fmt: str) -&gt; str: ...
    def isoformat(self) -&gt; str: ...
    def timetuple(self) -&gt; Foo: ...
    def toordinal(self) -&gt; int: ...
    def replace(self: Self, year: int = ..., month: int = ..., day: int = ...) -&gt; Self: ...
    def __le__(self, __other: Date) -&gt; bool: ...
    def __lt__(self, __other: Date) -&gt; bool: ...
    def __ge__(self, __other: Date) -&gt; bool: ...
    def __gt__(self, __other: Date) -&gt; bool: ...
    def __add__(self: Self, __other: Bar) -&gt; Self: ...
    def __radd__(self: Self, __other: Bar) -&gt; Self: ...
    def __hash__(self) -&gt; int: ...
    def weekday(self) -&gt; int: ...
    def isoweekday(self) -&gt; int: ...
    @overload
    def __sub__(self: Self, __other: Bar) -&gt; Self: ...
    @overload
    def __sub__(self: _D, __other: _D) -&gt; Bar: ...


class Time(Protocol[_GMaybeTZT]):
    min: Time[None]
    max: Time[None]
    resolution: Bar
    def hour(self) -&gt; int: ...
    def minute(self) -&gt; int: ...
    def second(self) -&gt; int: ...
    def microsecond(self) -&gt; int: ...
    def tzinfo(self) -&gt; _GMaybeTZT: ...
    def fold(self) -&gt; int: ...
    def __le__(self: Self, __other: Self) -&gt; bool: ...
    def __lt__(self: Self, __other: Self) -&gt; bool: ...
    def __ge__(self: Self, __other: Self) -&gt; bool: ...
    def __gt__(self: Self, __other: Self) -&gt; bool: ...
    def __hash__(self) -&gt; int: ...
    def isoformat(self, timespec: str = ...) -&gt; str: ...
    def strftime(self, __format: str) -&gt; str: ...
    def __format__(self, __fmt: str) -&gt; str: ...
    def utcoffset(self) -&gt; Bar | None: ...
    def tzname(self) -&gt; str | None: ...
    def dst(self) -&gt; Bar | None: ...
    @overload
    def replace(
        self: Self,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        *,
        fold: int = ...,
    ) -&gt; Self: ...
    @overload
    def replace(
        self,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        *,
        tzinfo: _FuncTZ,
        fold: int = ...,
    ) -&gt; Time[_FuncTZ]: ...
    @overload
    def replace(
        self,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        *,
        tzinfo: None,
        fold: int = ...,
    ) -&gt; Time[None]: ...
    @overload
    def replace(
        self,
        hour: int,
        minute: int,
        second: int,
        microsecond: int,
        tzinfo: None,
        *,
        fold: int,
    ) -&gt; Time[None]: ...
    @overload
    def replace(
        self,
        hour: int,
        minute: int,
        second: int,
        microsecond: int,
        tzinfo: _FuncTZ,
        *,
        fold: int,
    ) -&gt; Time[_FuncTZ]: ...
    def fromisoformat(cls, __time_string: str) -&gt; Time[Baz | None]: ...


class NaiveTime(Time[None], Protocol): ...


DTSelf = TypeVar(&quot;DTSelf&quot;, bound=&quot;DateTime&quot;)


class DateTime(Protocol[_GMaybeTZDT]):
    resolution: Bar
    def hour(self) -&gt; int: ...
    def minute(self) -&gt; int: ...
    def second(self) -&gt; int: ...
    def microsecond(self) -&gt; int: ...
    def tzinfo(self) -&gt; _GMaybeTZDT: ...
    def fold(self) -&gt; int: ...
    def timestamp(self) -&gt; float: ...
    def utctimetuple(self) -&gt; Foo: ...
    def date(self) -&gt; Date: ...
    def time(self) -&gt; NaiveTime: ...
    @overload
    def replace(
        self: Self,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        *,
        tzinfo: _FuncTZ,
        fold: int = ...,
    ) -&gt; DateTime[_FuncTZ]: ...
    @overload
    def replace(
        self,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        second: int,
        microsecond: int,
        tzinfo: _FuncTZ,
        *,
        fold: int,
    ) -&gt; DateTime[_FuncTZ]: ...
    @overload
    def replace(
        self,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        *,
        tzinfo: None,
        fold: int = ...,
    ) -&gt; NaiveDateTime: ...
    @overload
    def replace(
        self: Self,
        year: int,
        month: int,
        day: int,
        hour: int,
        minute: int,
        second: int,
        microsecond: int,
        tzinfo: None,
        *,
        fold: int,
    ) -&gt; NaiveDateTime: ...
    @overload
    def replace(
        self: Self,
        year: int = ...,
        month: int = ...,
        day: int = ...,
        hour: int = ...,
        minute: int = ...,
        second: int = ...,
        microsecond: int = ...,
        *,
        fold: int = ...,
    ) -&gt; Self: ...

    def fromtimestamp(
        cls: type[Self], __timestamp: float, tz: _FuncOptionalTZ
    ) -&gt; DateTime[_FuncOptionalTZ]: ...

    @overload
    def now(cls, tz: _FuncOptionalTZ) -&gt; DateTime[_FuncOptionalTZ]: ...

    @overload
    def now(cls) -&gt; DateTime[None]: ...

    def now(cls, tz: Baz | None = None) -&gt; DateTime[Baz | None]: ...


class NaiveDateTime(DateTime[None], Protocol): ...


static_assert(is_assignable_to(NaiveDateTime, DateTime[Baz | None]))
</code></pre>
</details>

<p>(The snippet above uses simplified versions of some protocols found in the <a href="https://github.com/glyph/DateType/blob/trunk/src/datetype/__init__.py">DateType library</a>. If you comment out the final line, where we're asked to determine whether one protocol is a subtype of the other, we check the code almost instantly on this branch.)</p>
<p>Since <code>DateType</code> actually appears in the MRO of <code>NaiveDateTime</code> here, as an optimization we might be able to do a quick MRO check (the same as we would do for nominal instance types) before doing the full structural check between the two protocol instance types. IIRC mypy does a similar optimization.</p>
<p>I'll look into adding something similar to the above snippet as a regression benchmark.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-07-05 12:51</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_INSTRUMENTATION_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Fmethod-members?runnerMode=Instrumentation">CodSpeed Instrumentation Performance Report</a></h2>
<h3>Merging #18659 will <strong>degrade performances by 20.45%</strong></h3>
<p><sub>Comparing <code>alex/method-members</code> (f81ba79) with <code>main</code> (e0b7f49)</sub></p>
<h3>Summary</h3>
<p><code>‚ùå 1 (üëÅ 1)</code> regressions<br />
<code>‚úÖ 39</code> untouched benchmarks</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| üëÅ | <code>DateType</code> | 211.1 ms | 265.3 ms | -20.45% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-05 13:03</div>
            <div class="timeline-body"><blockquote>
<p>Merging #18659 will <strong>degrade performances by 18.48%</strong></p>
</blockquote>
<p>Which is nonetheless much better than the previous commit on this PR branch, on which this benchmark timed out üòÜ</p>
<p>I'm looking to see if there are further optimisations we could apply that are reasonable and effective</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-05 14:24</div>
            <div class="timeline-body"><blockquote>
<p>I'm looking to see if there are further optimisations we could apply that are reasonable and effective</p>
</blockquote>
<p>None of my other ideas made any significant difference to the runtime of that benchmark. I think ultimately we're just doing a lot more (necessary!) work on this branch. So I think this is once again ready for review.</p>
<p>Things I tried:</p>
<ul>
<li>Adding <code>#[salsa::tracked]</code> to <code>Type::normalized()</code> and <code>Type::has_relation_to()</code></li>
<li>Using the unsafe <a href="https://docs.rs/hashbrown/latest/hashbrown/struct.HashMap.html#method.insert_unique_unchecked"><code>insert_unique_unchecked</code></a> method to insert values into the <code>cache</code> field of the <code>CycleDetector</code> struct.</li>
<li>Checking whether a nominal instance or a protocol instance <code>T</code> was an explicit subclass of the class of a class-based protocol instance <code>P</code> before doing a full structural check in <code>Type::has_relation_to</code> and <code>Type::is_disjoint_from()</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2025-07-05 14:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-07-05 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/cyclic.rs</code>:1 on 2025-07-05 14:28</div>
            <div class="timeline-body"><p>I observed that the reason we never finished when trying to type-check <code>DateType</code> on earlier versions of this PR was that we were repeatedly calling <code>Type::normalized_impl</code> on the same types over and over again. Caching the results within any one call to <code>Type::normalized()</code> fixes this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-07-07 10:35</div>
            <div class="timeline-body"><p>Thank you!</p>
<p>I'm not 100% sure I understand why this new <code>cache</code> in <code>CycleDetector</code> is necessary in addition to <code>seen</code>. And if it is necessary, if <code>seen</code> and <code>cache</code> couldn't be merged into a single <code>HashMap</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-07 10:53</div>
            <div class="timeline-body"><blockquote>
<p>I'm not 100% sure I understand why this new <code>cache</code> in <code>CycleDetector</code> is necessary in addition to <code>seen</code>. And if it is necessary, if <code>seen</code> and <code>cache</code> couldn't be merged into a single <code>HashMap</code>?</p>
</blockquote>
<p>If the type we're trying to normalize is present in <code>seen</code>, it indicates that we've hit a cycle (due to a recursive type); we need to immediately short circuit the whole normalization and return <code>Any</code>. That's why we <code>pop</code> items off the end of <code>seen</code> after we've normalized them.</p>
<p>But if the type we're trying to normalize is present in <code>cache</code>, it doesn't necessarily mean we've hit a cycle: it just means that we've already normalized this inner type as part of a bigger <code>Type::normalized()</code> call chain we're currently in. Since this cache is just a performance optimisation, it doesn't make sense to pop items off the end of the cache after they've been normalized (it would sort-of defeat the point of a cache if we did!)</p>
<p>I'll add some doc-comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-07-07 11:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-07-07 11:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-07 11:28</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:13:23 UTC
    </footer>
</body>
</html>
