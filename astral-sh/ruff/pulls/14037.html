<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Implement type narrowing for boolean conditionals - astral-sh/ruff #14037</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Implement type narrowing for boolean conditionals</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14037">#14037</a>
        opened by <a href="https://github.com/TomerBin">@TomerBin</a>
        on 2024-11-01 11:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a></div>
            <div class="timeline-body">Summary
<p>This PR enables red-knot to support type narrowing based on <code>and</code> and <code>or</code> conditionals, including nested combinations and their negation (for <code>elif</code> / <code>else</code> blocks and for <code>not</code> operator). Part of #13694.</p>
<p>In order to address this properly (hopefully ðŸ˜…), I had to run <code>NarrowingConstraintsBuilder</code> functions recursively. In the first commit I introduced a minor refactor - instead of mutating <code>self.constraints</code>, the new constraints are now returned as function return values. I also modified the constraints map to be optional, preventing unnecessary hashmap allocations.
Thanks @carljm for your support on this :)</p>
<p>The second commit contains the logic and tests for handling boolean ops, with improvements to intersections handling in <code>is_subtype_of</code> .</p>
<p>As I&#x27;m still new to Rust and the internals of type checkers, Iâ€™d be more than happy to hear any insights or suggestions.
Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-01 11:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-01 11:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-01 11:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-01 11:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-01 11:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-11-01 11:31</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>âœ… ecosystem check detected no linter changes.</p>
Linter (preview)
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-11-01 15:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_boolean.md</code>:42 on 2024-11-01 18:04</div>
            <div class="timeline-body"><p>With detection of statically-known <code>True</code>, this could be <code>B</code> or <code>B &amp; ~A</code>, right?</p>
<p>Not saying we have to do it in this PR, but it could be a) worth a TODO comment, and/or b) worth having a test that uses <code>and bool_instance()</code> for the &quot;adds no narrowing constraint&quot; condition rather than <code>and True</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_boolean.md</code>:72 on 2024-11-01 18:04</div>
            <div class="timeline-body"><p>same as above</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_boolean.md</code>:83 on 2024-11-01 18:07</div>
            <div class="timeline-body"><p>This is arguable. The type <code>C &amp; ~A &amp; ~B</code> is technically correct here, and it is technically correct not to simplify it, because of multiple inheritance.</p>
<p>Whether it is <em>practically useful</em> not to simplify it is another question, but we can let that be driven by future real-world experience, I don&#x27;t think we need a TODO for it.</p>
<pre><code></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_boolean.md</code>:130 on 2024-11-01 18:10</div>
            <div class="timeline-body"><p>Should this test also demonstrate a case where all arms <em>do</em> add the constraint? Or, even more subtly, where all arms add overlapping constraints, and the OR of those constraints still does apply a constraint? E.g.</p>
<pre><code>x: int | None

if x or x is not None:
    reveal_type(x)  # revealed: int
</code></pre>
<p>or</p>
<pre><code>if isinstance(x, A) or isinstance(x, B):
    reveal_type(x)  # revealed: A | B
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_boolean.md</code>:121 on 2024-11-01 18:11</div>
            <div class="timeline-body"><p>I think this test is stronger if all arms make the same assertion, but about different symbols. Since otherwise we could pass the test just due to &quot;different constraints&quot; logic already tested above.</p>
<pre><code>if isinstance(x, A) or isinstance(y, A):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:557 on 2024-11-01 18:26</div>
            <div class="timeline-body"><p>I think this should rather be &quot;all negative elements are disjoint with <code>ty</code>&quot;.</p>
<p>Example case is that <code>bool</code>, <code>BooleanLiteral[False]</code>, and <code>BooleanLiteral[True]</code> should all be subtypes of <code>int &amp; ~Literal[0]</code>.</p>
<p>Testing this for a <code>BooleanLiteral</code> will require adding a case for <code>BooleanLiteral[_] &lt;: int</code>, which we are currently missing -- but that&#x27;s easy to add in this diff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:545 on 2024-11-01 18:43</div>
            <div class="timeline-body"><p>I think here, if this check fails, the other thing we need to check is &quot;is at least one positive element of <code>self_intersection</code> disjoint from this negative element of <code>target_intersection</code>&quot; -- if so, that should also satisfy this negative element of `target_intersection.</p>
<p>Example case would be that <code>A &amp; int</code> is a subtype of <code>~Literal[False]</code>, because <code>A</code> is disjoint from <code>Literal[False]</code> (even though <code>int</code> is not -- or should not be).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:202 on 2024-11-01 18:53</div>
            <div class="timeline-body"><p>Nit: now that these methods do not have side effects, but rather return their constraints, I think we should rename from <code>add_*</code> to <code>evaluate_*</code> (e.g. <code>self.evaluate_expr_call</code> etc)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:374 on 2024-11-01 18:56</div>
            <div class="timeline-body"><p>It looks like both branches have this iterator in common, it could be extracted into a variable above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:394 on 2024-11-01 19:07</div>
            <div class="timeline-body"><p>I think this is too strict, and will mean we can&#x27;t understand a more complex constraint like <code>if (isinstance(x, A) and isinstance(y, B)) or (isinstance(x, B) and isinstance(y, A)):</code></p>
<p>In this case of course we have no way to represent the precise relationship between the types of <code>x</code> and <code>y</code>, but it is correct to narrow both <code>x</code> and <code>y</code> to <code>A | B</code>. Your current code will refuse to do that.</p>
<p>I think the code might be clearer here if you structure it more similarly to the above branch, rename the current <code>merge_constraints</code> function to <code>merge_constraints_and</code>, and write a new <code>merge_constraints_or</code> to use in this branch.</p>
<p>The <code>merge_constraints_or</code> function should union the constraints (instead of intersecting them like <code>merge_constraints_and</code> does), and should eliminate any variables not constrained by both sides, or where the union of constraints results in <code>object</code> (these two cases are really the same: no constraint for a variable is implicitly &quot;constrained to <code>object</code>&quot;).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-11-01 19:08</div>
            <div class="timeline-body"><p>This is fantastic work!</p>
<p>I do have a few comments: feel free to push back if any of my comments don&#x27;t seem right, it&#x27;s quite possible I&#x27;ve missed something important!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-01 21:27</div>
            <div class="timeline-body"><blockquote>
<p>This is fantastic work!</p>
<p>I do have a few comments: feel free to push back if any of my comments don&#x27;t seem right, it&#x27;s quite possible I&#x27;ve missed something important!</p>
</blockquote>
<p>Thanks for the review! I&#x27;ll address all comments soon</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a> reviewed on 2024-11-03 16:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/TomerBin">@TomerBin</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:557 on 2024-11-03 16:00</div>
            <div class="timeline-body"><p>Nice catch :)
Can we test it with just int variants? As <code>Literal[1]</code> should be a subtype of <code>int  &amp; ~Literal[0]</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-11-03 16:01</div>
            <div class="timeline-body"><p>I think i&#x27;ve addressed all comments, it is ready for another review now :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2154 on 2024-11-04 21:20</div>
            <div class="timeline-body"><p>I&#x27;m not sure which case this was intended to test, but I don&#x27;t think it is testing intersection subtype-of logic; it is only testing that <code>int &amp; Literal[2]</code> immediately simplifies to <code>Literal[2]</code>, because <code>Literal[2] &lt;: int</code>. So then of course <code>Literal[2] &lt;: Literal[2]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-11-04 21:24</div>
            <div class="timeline-body"><p>This is awesome!! One nit on one test, then it&#x27;s good to go.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a> reviewed on 2024-11-04 22:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/TomerBin">@TomerBin</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2154 on 2024-11-04 22:53</div>
            <div class="timeline-body"><p>Thanks!
I wanted to test that not all positive intersection members must be subtypes of the target, only one is required.
Fixed in this commit - <a href="https://github.com/astral-sh/ruff/pull/14037">astral-sh/ruff#14037</a>/commits/1fd24024801cec1899640e7b611864ea6061ad2f</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/carljm">@carljm</a> on 2024-11-04 22:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2024-11-04 22:54</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:07:58 UTC
    </footer>
</body>
</html>
