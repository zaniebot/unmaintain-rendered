<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Implicit instance attributes - astral-sh/ruff #15811</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Implicit instance attributes</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15811">#15811</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-01-29 16:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-29 16:04</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Add support for implicitly-defined instance attributes, i.e. support type inference for cases like this:</p>
<pre><code class="language-py">class C:
    def __init__(self) -&gt; None:
        self.x: int = 1
        self.y = None

reveal_type(C().x)  # int
reveal_type(C().y)  # Unknown | None
</code></pre>
<p>A lot of things have been intentionally left out of this PR:</p>
<ul>
<li>Type inference for <code>self</code></li>
<li>Support attributes which are implicitly &quot;declared&quot; via their parameter types (<code>self.x = param</code>)</li>
<li>Tuple-unpacking attribute assignments: <code>self.x, self.y = â€¦</code></li>
<li>Diagnostic for conflicting declared types</li>
<li>Attributes in statically-known-to-be-false branches are still visible:<pre><code class="language-py">class C:
    def __init__(self) -&gt; None:
        if 2 + 3 &lt; 4:
            self.x: str = &quot;a&quot;

# # TODO: Ideally, this would result in a `unresolved-attribute` error. But mypy and pyright
# do not support this either (for conditions that can only be resolved to `False` in type
# inference), so it does not seem to be particularly important.
reveal_type(C().x)  # revealed: str
</code></pre>
</li>
</ul>
<p>Part of: https://github.com/astral-sh/ruff/issues/14164</p>
<h2>Benchmarks</h2>
<p>Codspeed reports no change in a cold-cache benchmark, and a -1% regression in the incremental benchmark. On <code>black</code>'s <code>src</code> folder, I don't see a statistically significant difference between the branches (Reminder to self: always set the CPU frequency scaling governor to <code>performance</code> when benchmarking on a laptop):</p>
<p>| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| <code>./red_knot_main check --project /home/shark/black/src</code> | 133.7 Â± 9.5 | 126.7 | 164.7 | 1.01 Â± 0.08 |
| <code>./red_knot_feature check --project /home/shark/black/src</code> | 132.2 Â± 5.1 | 118.1 | 140.9 | 1.00 |</p>
<h2>Test Plan</h2>
<p>Updated and new Markdown tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-01-29 16:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-29 16:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:31 on 2025-01-29 16:41</div>
            <div class="timeline-body"><p>I think this doesn't work because we don't know what the type of <code>self</code> is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-29 16:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:182 on 2025-01-29 16:41</div>
            <div class="timeline-body"><p>See above: this does not work because we don't know what the type of <code>self</code> is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-29 16:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:449 on 2025-01-29 16:43</div>
            <div class="timeline-body"><p>Probably not something that we're going to address here. This would require narrowing on attribute expressions. <code>Unknown | Literal[&quot;value set in class method&quot;]</code> is not wrong.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2025-01-31 13:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-01-31 13:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-01-31 13:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-01-31 13:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/expression.rs</code>:49 on 2025-01-31 14:41</div>
            <div class="timeline-body"><p>Reading the docs on <a href="https://salsa-rs.netlify.app/overview.html?highlight=%23%5Bid%5D#id-fields"><code>#[id]</code></a>, it's still not clear to me if this is correct or not. So please review this change of the <code>Expression</code> struct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 14:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:354 on 2025-01-31 19:03</div>
            <div class="timeline-body"><p>Perhaps there's no need here to make the reader think about precedence? We can either add parens or eliminate the addition. (I guess you were trying to make it &quot;complex enough&quot; that it's unlikely it could ever be special-cased without type inference?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:239 on 2025-01-31 19:09</div>
            <div class="timeline-body"><p>it might also be interesting to add a version of this test where <code>a</code> and <code>b</code> are declared in the class body</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:293 on 2025-01-31 19:09</div>
            <div class="timeline-body"><p>we gotta add support for generics soon so we can write tests for <code>for</code> loops that don't involve all this tedious boilerplate ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:77 on 2025-01-31 19:15</div>
            <div class="timeline-body"><p>nit: is it time to create a <code>ScopeInfo</code> struct so that we can access named fields on the items in this stack?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:61 on 2025-01-31 19:20</div>
            <div class="timeline-body"><p>Is there a lot of unpleasant fallout from just distinguishing functions and lambdas in <code>ScopeKind</code>? I wouldn't expect so, since we already have <code>ScopeId::is_function_like</code> when we want to check if a scope is &quot;function-like&quot;. I don't think there's a principled reason <code>ScopeKind</code> <em>shouldn't</em> distinguish them, we just haven't needed to yet. So unless there's a factor I'm missing, I'd just do that instead of introducing this new enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:470 on 2025-01-31 19:23</div>
            <div class="timeline-body"><p>it looks to me like you might be able to get away without the clone here? All tests pass if I apply this diff to your branch:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/semantic_index.rs b/crates/red_knot_python_semantic/src/semantic_index.rs
index 71abd2dfe..d8e79d4b6 100644
--- a/crates/red_knot_python_semantic/src/semantic_index.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index.rs
@@ -144,7 +144,8 @@ pub(crate) struct SemanticIndex&lt;'db&gt; {
 
     /// Maps from class body scopes to attribute assignments that were found
     /// in methods of that class.
-    attribute_assignments: FxHashMap&lt;FileScopeId, FxHashMap&lt;String, Vec&lt;AttributeAssignment&lt;'db&gt;&gt;&gt;&gt;,
+    attribute_assignments:
+        FxHashMap&lt;FileScopeId, FxHashMap&lt;&amp;'db str, Vec&lt;AttributeAssignment&lt;'db&gt;&gt;&gt;&gt;,
 }
 
 impl&lt;'db&gt; SemanticIndex&lt;'db&gt; {
diff --git a/crates/red_knot_python_semantic/src/semantic_index/builder.rs b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
index 659e17e68..55e661ba6 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/builder.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
@@ -102,7 +102,8 @@ pub(super) struct SemanticIndexBuilder&lt;'db&gt; {
     definitions_by_node: FxHashMap&lt;DefinitionNodeKey, Definition&lt;'db&gt;&gt;,
     expressions_by_node: FxHashMap&lt;ExpressionNodeKey, Expression&lt;'db&gt;&gt;,
     imported_modules: FxHashSet&lt;ModuleName&gt;,
-    attribute_assignments: FxHashMap&lt;FileScopeId, FxHashMap&lt;String, Vec&lt;AttributeAssignment&lt;'db&gt;&gt;&gt;&gt;,
+    attribute_assignments:
+        FxHashMap&lt;FileScopeId, FxHashMap&lt;&amp;'db str, Vec&lt;AttributeAssignment&lt;'db&gt;&gt;&gt;&gt;,
 }
 
 impl&lt;'db&gt; SemanticIndexBuilder&lt;'db&gt; {
@@ -453,7 +454,7 @@ impl&lt;'db&gt; SemanticIndexBuilder&lt;'db&gt; {
     fn register_attribute_assignment(
         &amp;mut self,
         object: &amp;ast::Expr,
-        attr: &amp;ast::Identifier,
+        attr: &amp;'db str,
         attribute_assignment: AttributeAssignment&lt;'db&gt;,
     ) {
         if let Some(class_body_scope) = self.is_method_of_class() {
@@ -467,7 +468,7 @@ impl&lt;'db&gt; SemanticIndexBuilder&lt;'db&gt; {
                 self.attribute_assignments
                     .entry(class_body_scope)
                     .or_default()
-                    .entry(attr.id().as_str().to_owned())
+                    .entry(attr)
                     .or_default()
                     .push(attribute_assignment);
             }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:77 on 2025-01-31 19:24</div>
            <div class="timeline-body"><p>If we don't introduce <code>BuilderScopeKind</code>, then I think the scope kind is derivable from the <code>FileScopeId</code>, and we don't need to add a third element to this tuple?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:828 on 2025-01-31 19:25</div>
            <div class="timeline-body"><p>What about assignments to attributes of the first argument of a classmethod or staticmethod?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:84 on 2025-01-31 19:27</div>
            <div class="timeline-body"><p>I think here again you can avoid some clones by using <code>&amp;'db str</code> rather than <code>Name</code>:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/semantic_index/builder.rs b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
index 659e17e68..abf51f956 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/builder.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
@@ -81,7 +81,7 @@ pub(super) struct SemanticIndexBuilder&lt;'db&gt; {
     /// The match case we're currently visiting.
     current_match_case: Option&lt;CurrentMatchCase&lt;'db&gt;&gt;,
     /// The name of the first function parameter of the innermost function that we're currently visiting.
-    current_first_parameter_name: Option&lt;Name&gt;,
+    current_first_parameter_name: Option&lt;&amp;'db str&gt;,
 
     /// Flow states at each `break` in the current loop.
     loop_break_states: Vec&lt;FlowSnapshot&gt;,
@@ -460,8 +460,8 @@ impl&lt;'db&gt; SemanticIndexBuilder&lt;'db&gt; {
             // We only care about attribute assignments to the first parameter of a method,
             // i.e. typically `self` or `cls`.
             let accessed_object_refers_to_first_parameter =
-                object.as_name_expr().map(|name| &amp;name.id)
-                    == self.current_first_parameter_name.as_ref();
+                object.as_name_expr().map(|name| name.id.as_str())
+                    == self.current_first_parameter_name;
 
             if accessed_object_refers_to_first_parameter {
                 self.attribute_assignments
@@ -795,7 +795,7 @@ where
                         let mut first_parameter_name = parameters
                             .iter_non_variadic_params()
                             .next()
-                            .map(|first_param| first_param.parameter.name.id().clone());
+                            .map(|first_param| first_param.parameter.name.id.as_str());
                         std::mem::swap(
                             &amp;mut builder.current_first_parameter_name,
                             &amp;mut first_parameter_name,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:522 on 2025-01-31 19:30</div>
            <div class="timeline-body"><p>I wonder if we could use this enum here (or do something like it) for the second parameter of <code>add_standalone_expression_impl</code>, rather than using a <code>bool</code>? We could move it (and rename it -- <code>ValueOrTypeExpression</code>?).</p>
<p>https://github.com/astral-sh/ruff/blob/fab86de3ef91460e58496f74ba1ce3edc4b9d69c/crates/red_knot_python_semantic/src/types.rs#L3701-L3711</p>
<p>I find it hard to tell why a <code>true</code> or <code>false</code> argument is being passed into a function in Rust without jumping to the definition of the function in question (which is hard if I'm reading a diff on GitHub).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-31 19:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/expression.rs</code>:49 on 2025-01-31 19:34</div>
            <div class="timeline-body"><p>I think it's fine. This will get cleared up in a future rev of Salsa.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 19:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:293 on 2025-01-31 19:35</div>
            <div class="timeline-body"><p>I tried <code>[1, 2]</code> multiple times over the past months and it <em>still</em> doesn't work! ðŸ˜€</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4138 on 2025-01-31 19:37</div>
            <div class="timeline-body"><p>This TODO confused me for a bit. I think it is now obsolete and should be removed in this PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4144 on 2025-01-31 19:38</div>
            <div class="timeline-body"><p>I guess at this point we do attribute lookup fully lazily, and without any Salsa caching. I wonder if there's enough work repeated here to make some Salsa caching of attribute types worth it? But we can evaluate this separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 19:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:522 on 2025-01-31 19:39</div>
            <div class="timeline-body"><blockquote>
<p>I find it hard to tell why a true or false argument is being passed into a function in Rust without jumping to the definition of the function in question</p>
</blockquote>
<p>... which is why I created two variants of this function that call ..._impl, so you don't have to see it in the &quot;actual&quot; code :-).</p>
<p>But I'm also fine with an enum, if you think that's clearer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 19:41</div>
            <div class="timeline-body"><p>Review not complete yet, just submitting partway through</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:522 on 2025-01-31 19:42</div>
            <div class="timeline-body"><p>heh, yeah. To give the full story here: while reading through the diff, I persuaded myself that it wasn't worth making this nit comment (for the reason you give), carried on reading the diff... and then saw that you were also adding an <code>infer_as_type_expression: bool</code> field to the <code>Expression</code> struct, which made me wonder if an enum like this could be more generally useful :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-31 19:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 19:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:77 on 2025-01-31 19:43</div>
            <div class="timeline-body"><p>My suggestion is that we may not need to add a third item to this tuple in this PR? But making it a struct could be a good idea regardless.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4164 on 2025-01-31 19:46</div>
            <div class="timeline-body"><p>I suppose we could add a comment here about why <code>Unknown</code> is in this union? It probably repeats something you already have in the tests, but it might be useful for a reader. Something short like &quot;When an attribute type is only inferred, not declared, we add <code>Unknown</code> to the union to reflect that assigning any type to this attribute is allowed.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-31 20:03</div>
            <div class="timeline-body"><p>Ok, finished review, only had one more comment.</p>
<p>This is, as usual, awesome work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 21:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:470 on 2025-01-31 21:06</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 22:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:61 on 2025-01-31 22:09</div>
            <div class="timeline-body"><p>To be honest, I wasn't completely sure if that would have confused two different meanings of &quot;scope kind&quot;, and if that merging of function+lambda was important for some reason.</p>
<p>I now tried to split the <code>ScopeKind::Function</code> case in to <code>Function</code>+<code>Lambda</code> and then used <code>ScopeKind</code> instead of <code>BuilderScopeKind</code>, but that leads to salsa cycles. I think it's because <code>ScopeId::scope</code> calls <code>semantic_index</code>, but I can look into that again next week.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-31 22:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:828 on 2025-01-31 22:15</div>
            <div class="timeline-body"><p>Those are not (properly) supported yet. We do have one pre-existing test for attribute assignments in <code>@classmethod</code>s in this file, but we do not yet find these implicitly-declared attributes when calling <code>.member</code> on the class object. With this PR, we're potentially in a weird state where we find those attributes on instances, but not on the class object. If that's acceptable, I'll open an issue and add that to my goals for next week. Otherwise, I can also include it in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 22:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:828 on 2025-01-31 22:59</div>
            <div class="timeline-body"><p>I don't think the functionality scope of this PR needs to be expanded, this can definitely be a follow-up. I was more just thinking that some TODO tests around it would clarify the intention and fit in well with the existing tests in this PR, which are already a mix of &quot;complete&quot; and &quot;TODO&quot;. But there's certainly no need for that, the tests can come with the feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-31 23:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:61 on 2025-01-31 23:12</div>
            <div class="timeline-body"><p>Yeah, makes sense. Semantically I think there's no distinction (and no reason lambdas and functions need to be merged), so it's nicer if we don't proliferate enums for the same concept.</p>
<p>In terms of the cycles, we should avoid using <code>ScopeId</code> API in semantic index building. It's not necessary to use it, since semantic index building is already inherently per-file, and the only <em>information</em> added by <code>ScopeId</code> over <code>FileScopeId</code> is the file. Beyond that it's just a matter of some minor API rearrangements or additions for ergonomics, we have the needed information. Given a <code>FileScopeId</code>, <code>SemanticIndexBuilder::scopes</code> map can get us a <code>Scope</code>, which has a <code>NodeScopeWithKind</code>, from which we can get a <code>ScopeKind</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:153 on 2025-02-02 17:13</div>
            <div class="timeline-body"><p>What about cases where the method is conditionally defined by using an if statement?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4144 on 2025-02-02 17:16</div>
            <div class="timeline-body"><p>We may want to have salsa caching here to avoid invalidating types from module a if the class is defined in module b. Or is it guaranteed that this method is only ever called from within the same module (or if it is called across-modules, that it goes through a salsa query?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:147 on 2025-02-02 17:19</div>
            <div class="timeline-body"><p>This is a fairly heavy data structure with a nested map that stores a list.</p>
<p>It may be worth considering if there are any constraints that allow us to simplify the nesting or e.g use an IndexVec by ScopeId and accept that many entries are empty</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-02 17:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-02 19:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:153 on 2025-02-02 19:40</div>
            <div class="timeline-body"><p><code>if</code> statements do not introduce new scopes, so this works fine (see also the &quot;Conditionally declared / bound attributes&quot; test)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 10:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:147 on 2025-02-03 10:56</div>
            <div class="timeline-body"><p>I tried to investigate this, so I auto-generated a <a href="https://gist.github.com/sharkdp/87e3454d765c3927e4243d40fbcb42dd">pathological example</a> with many attribute assignments. This file intentionally does <em>not access</em> those attributes, in order not trigger type inference for these attributes (in which case this branch <em>is</em> quite a bit slower than main). But we still build the full semantic index when checking this file.</p>
<p>Even for this file, with thousands of attribute accesses, <code>register_attribute_assignment</code> only makes up 1.5% of the whole profile:</p>
<p><img src="https://github.com/user-attachments/assets/92dc65ef-ef91-4ae9-93a5-918ced7cef4f" alt="image" /></p>
<p>And I hardly see any difference in overall performance between <em>main</em> and this feature branch (which not just registers attribute accesses but also creates many more standalone expressions):</p>
<p>| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| <code>main</code> | 141.9 Â± 6.1 | 136.2 | 159.1 | 1.00 |
| <code>feature</code> | 144.6 Â± 3.2 | 138.5 | 153.6 | 1.02 Â± 0.05 |</p>
<p>One optimization that seems sensible to me would be to use a <code>SmallVec</code> instead of a <code>Vec</code>, since most real-world classes probably just assign once or twice to the same attribute. So I generated another version of the file where there are exactly two methods assigning to the same attribute, expecting to see a difference between an inline-capacity of 1 and 2. But it's all just noise:</p>
<p>| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| <code>Vec&lt;â€¦&gt;</code> | 99.6 Â± 1.3 | 97.3 | 102.4 | 1.00 |
| <code>SmallVec&lt;[â€¦, 1]&gt;</code> | 100.1 Â± 2.8 | 97.2 | 112.9 | 1.01 Â± 0.03 |
| <code>SmallVec&lt;[â€¦, 2]&gt;</code> | 99.8 Â± 1.4 | 97.2 | 103.1 | 1.00 Â± 0.02 |</p>
<p>I personally think it's something worth revisiting when we introduce micro-benchmarks, but until then, it seems hard to measure, and I'd rather not introduce any complications here without being confident that they actually make the code faster. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 11:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4144 on 2025-02-03 11:13</div>
            <div class="timeline-body"><p>I think I need some help answering these questions.</p>
<blockquote>
<p>Or is it guaranteed that this method is only ever called from within the same module</p>
</blockquote>
<p>I don't think so.</p>
<blockquote>
<p>or if it is called across-modules, that it goes through a salsa query?</p>
</blockquote>
<p>This function is only called from <code>Class::instance_member</code> (via <code>own_instance_member</code>), which in turn can be called from:</p>
<ul>
<li><code>Type::member</code></li>
<li><code>TypeInferenceBuilder::infer_attribute_expression</code></li>
</ul>
<p>The former (<code>Type::member</code>) is called from all sorts of different places.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-03 11:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4144 on 2025-02-03 11:24</div>
            <div class="timeline-body"><p>Thanks. Yeah, in that case, I think <code>implicit_instance_attribute</code> or <code>own_instance_member</code> or <code>member</code> should be a salsa query because: <code>semantic_index</code> changes whenever the file where the class is declared changes, and nothing is constraining <code>member</code> calls to be from the same file.</p>
<p>An alternative is to introduce a <code>attribute_assignments(db, class_body_scope)</code> query that returns the assignments just for that scope. That might be cheaper but it still has the benefit that <code>implicit_instance_attribute</code> only gets invalidated when the attribute assignments in that specific scope changed.</p>
<p>We use a similar pattern for <code>use_def_map</code> and <code>symbol_table</code> where those queries return a specific &quot;slice&quot; of the <code>SemanticIndex</code> which is less likely to change.</p>
<p>Let me know if that helps or if you need some more input (also happy to discuss on Discord/sync)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-03 11:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:148 on 2025-02-03 11:37</div>
            <div class="timeline-body"><p>I'm unsure if using a <code>&amp;'db str</code> here is actually safe... I thought that references is generally disallowed (by having to implement the <code>Update</code> trait) but it Salsa seems to allow it here.</p>
<p>The issue I see here is that the AST might get collected between two revisions (because of LRU caching), in which case the map keys would point to invalid memory addresses.</p>
<p>I posted in <a href="https://salsa.zulipchat.com/#narrow/channel/145099-Using-Salsa/topic/Query.20result.20with.20.26%27db.20lifetime.20field">salsa's zullip</a> but maybe @carljm remembers</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 14:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:148 on 2025-02-03 14:16</div>
            <div class="timeline-body"><p>Thanks, Micha. I think both Alex and I had hesitations when replacing <code>String</code> with <code>&amp;'db str</code> here, but we assumed it would be fine when it compiled.</p>
<p>Not this exact <code>&amp;'db</code> reference, but I managed to make red_knot segfault today when I returned a <code>&amp;'db</code> reference from a query. As noted in the zulip thread, this seems to be a known salsa bug: https://github.com/salsa-rs/salsa/issues/610.</p>
<p>Will revert 59d112f6cb537907e4dd4e10605a881c1254f401</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-03 14:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:148 on 2025-02-03 14:25</div>
            <div class="timeline-body"><p>You may want to use <code>Name</code> instead of <code>String</code> to avoid allocations in most cases.</p>
<p>We may want to explore interning <code>Name</code>s... now that we're storing them in many tables.  Or could we store a <code>FileSymbolId</code> instead? Ah no, that doesn't work because <code>x</code> in <code>self.x</code> is not a symbol, only <code>self</code> is</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-03 14:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:148 on 2025-02-03 14:25</div>
            <div class="timeline-body"><blockquote>
<p>I think both Alex and I had hesitations when replacing <code>String</code> with <code>&amp;'db str</code> here, but we assumed it would be fine when it compiled.</p>
</blockquote>
<p>heh, yes!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4158 on 2025-02-03 15:48</div>
            <div class="timeline-body"><p>I wonder if this would be useful to have as a general query and if it should be defined next to <code>infer_expression_types</code> instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-03 15:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 15:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4158 on 2025-02-03 15:52</div>
            <div class="timeline-body"><p>I had a similar thought. It could certainly be used in more places, but I wasn't sure if we want the additional query in those places? I'll note it down as a task and open a small PR after this has been merged.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 15:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4144 on 2025-02-03 15:56</div>
            <div class="timeline-body"><p>For other reviewers: I implemented something that I discussed with Micha.</p>
<p>Removing <code>salsa::tracked</code> from either <code>attribute_assignments</code> or the inline <code>infer_expression_type</code> query makes the newly added test fail.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-02-03 18:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-02-03 18:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:828 on 2025-02-03 18:33</div>
            <div class="timeline-body"><p>I'll note this down as a task for a follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-02-03 18:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-02-03 18:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-02-03 18:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-03 19:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4158 on 2025-02-03 19:38</div>
            <div class="timeline-body"><p>It is intuitive to me why <code>attribute_assignments</code> should be a query, but it's less intuitive to me why this should be a query. I don't see what additional dependencies are introduced here above those that the underlying <code>infer_expression_types</code> query would have anyway. So I guess this is not about dependencies, but rather about a smaller returned value so backdating can be more effective?</p>
<p>It feels intuitively to me that we would get more caching value with fewer cached memos if we placed the salsa query caching at the level of <code>Class::own_instance_member</code> or <code>Type::member</code>, rather than at such a fine-grained level that does such little work over the underlying <code>infer_expression_types</code>. But we should of course validate any such changes with observed performance differences.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-03 19:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4158 on 2025-02-03 19:40</div>
            <div class="timeline-body"><p>The problem is the <code>expression.node_ref</code>. It accesses the AST node from the module where the class is declared, meaning the enclosing query has to re-run whenever the declaring module changes -- which we don't want.</p>
<p>Doing it here is mainly about avoiding calling a query (and caching the value which is expensive) in cases where we don't need to. Although I admit, I don't have any numbers on whether caching here is a significantly lower number than caching at the <code>own_instance_member</code> level.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:57:51 UTC
    </footer>
</body>
</html>
