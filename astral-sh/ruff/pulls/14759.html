<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Statically known branches (first take) - astral-sh/ruff #14759</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Statically known branches (first take)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14759">#14759</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-12-03 15:07
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Rendered version of the test suite including a proper introduction to the topic / motivation: <a href="https://github.com/astral-sh/ruff/blob/david/statically-known-branches/crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md"><strong>click</strong></a>.</p>
<p>This changeset adds support for precise type-inference and boundness-handling of definitions inside control-flow branches with statically-known conditions, i.e. test-expressions whose truthiness we can unambiguously infer as <em>always false</em> or <em>always true</em>. In code:</p>
<pre><code class="language-py">x = 1

if &quot;z&quot; in &quot;haystack&quot;:  # Literal[False]
    x = 2

reveal_type(x)  # revealed: Literal[1]
</code></pre>
<p>and:</p>
<pre><code class="language-py">x = 1

if &quot;y&quot; in &quot;haystack&quot;:  # Literal[True]
    x = 2

reveal_type(x)  # revealed: Literal[2]
</code></pre>
<p>One option to implement this would have been to add special handling for a limited set of test-expressions in semantic index-building. We would then analyze expressions like <code>sys.version_info &gt;= (x, y)</code>, <code>typing.TYPE_CHECKING</code>, <code>True</code> and <code>False</code> without any type inference and consequently close down (or unconditionally open) branches whose truthiness we can analyze in this way. This would simplify the implementation, but is much less general than the approach taken here.</p>
<p>Instead, we collect all necessary information during semantic index building, and then re-analyze the control flow during type-checking. The way this works is by recording the list of 'active' branching conditions for each introduced binding. Consider this example:</p>
<pre><code class="language-py">if test1:
    x = 1  # active conditions: [test1]

    if test2:
        x = 2  # active conditions: [test1, test2]

if test3:
    x = 3  # active conditions: [test3]

use(x)
</code></pre>
<p>In semantic-index building, when we reach the <code>use(x)</code> statement, we have three live bindings. But when we later analyze the test-conditions in type inference, we may potentially conclude that some of them are not present/visible.</p>
<p>One possibility to do so is to detect test-conditions to be <em>always false</em>. For example, if <code>test3</code> is statically known to be false, we can infer that the <code>x = 3</code> branch is never taken. This binding is then not considered in type inference and in boundness-handling. For the <code>x = 2</code> binding, we need to consider the possibility that <em>either</em> <code>test1</code> <em>or</em> <code>test2</code> can be statically false. In summary, if any of the active branching conditions is statically false, the binding is cancelled.</p>
<p>Another possibility is that we can infer a test-condition to be <em>always true</em>. This can also hide bindings. For example, if we can infer <code>test2</code> to always be true, we know that the <code>x = 1</code> binding is never visible. This is slightly more complex to handle, as we haven't even seen the <code>test2</code> condition when we analyze the <code>x = 1</code> binding in semantic-index building.</p>
<p>The way we solve this in type-inference is by going through all live bindings in reverse order (starting at <code>x = 3</code>), stopping whenever we detect a binding that is <em>unconditionally visible</em>. A binding is unconditionally visible if all of its active conditions are statically known to be true. This is slightly complicated by the fact that we have unconditional branching as well. For example, consider:</p>
<pre><code class="language-py">if test1:
    for _ in iterable():
        x = 1
</code></pre>
<p>This binding is <em>not</em> unconditionally visible, even if <code>test1</code> is always true, as the loop body may never be executed. This is currently handled by adding a <code>BranchingCondition::Unconditional</code> marker to the active conditions of the binding, which always evaluates to an ambiguous truthiness.</p>
<p>Some of this might sound similar to what we achieve with the <code>may_be_unbound</code> and <code>may_be_undeclared</code> flags. However, the new mechanism does not allow us to get rid of these flags, as there are also cases like this:</p>
<pre><code class="language-py">if test:  # type: bool
    x = 1
else:
    x = 2
</code></pre>
<p>The symbol <code>x</code> is always bound, but seeing the <code>x = 1</code> or <code>x = 2</code> definitions with a branching condition of <code>test: bool</code> is not enough to see that. We also need the global information that these two branches will be merged (where we logically OR the two <code>may_be_unbound = false</code> flags to a global <code>may_be_unbound = false</code>).</p>
<p>This branch also includes:</p>
<ul>
<li>statically-known branches handling for Boolean expressions and while loops</li>
<li>support for <code>typing.TYPE_CHECKING</code></li>
<li>support for narrowing in <code>while</code> loops</li>
<li>new <code>target-version</code> requirements in some Markdown tests which were now required due to the understanding of <code>sys.version_info</code> branches.</li>
</ul>
<p>closes astral-sh/ruff#12700
closes astral-sh/ruff#14170
closes astral-sh/ruff#14861</p>
<h2>Test plan</h2>
<ul>
<li>New Markdown tests for the main feature in <code>statically-known-branches.md</code></li>
<li>New Markdown tests for <code>typing.TYPE_CHECKING</code> in <code>known_constants.md</code></li>
<li>New Markdown tests for <code>while</code>-loop narrowing in <code>narrow/while.md</code></li>
<li>Regression test for boundness-handling in while loops</li>
<li>Adapted tests for <code>EllipsisType</code>, <code>Never</code>, etc</li>
</ul>
<h2>Performance investigation</h2>
<p>(thanks to @MichaReiser for some input!)</p>
<h3>Measurements</h3>
<p>I can reproduce the regression locally. It's not as pronounced as on codspeed, which could be attributed to the fact that the codspeed results do not involve any I/O overhead (they are based on CPU counters, not wall time). So the local results might be &quot;diluted&quot; a bit:</p>
<p><strong>tomllib</strong>, -13%</p>
<p>| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| <code>./red_knot_main</code> | 21.8 ± 1.5 | 18.8 | 27.0 | 1.00 |
| <code>./red_knot_feature</code> | 24.6 ± 1.6 | 21.2 | 29.1 | 1.13 ± 0.11 |</p>
<p><strong>Black codebase</strong>, -7%</p>
<p>| Command | Mean [ms] | Min [ms] | Max [ms] | Relative |
|:---|---:|---:|---:|---:|
| <code>./red_knot_main</code> | 123.4 ± 5.4 | 115.6 | 135.4 | 1.00 |
| <code>./red_knot_feature</code> | 131.6 ± 3.5 | 123.7 | 137.3 | 1.07 ± 0.05 |</p>
<h3>Analysis (ongoing)</h3>
<ul>
<li>With this feature enabled, we need to perform more work. For every binding/declaration, we need to infer the type of all active branching conditions and call <code>Type::bool</code> on it (which may involve looking up other symbols). This can entail loading entire new modules. For example: in the <code>tomllib</code> benchmark, we do not need to resolve <code>sys</code> on main, but we do on this branch. The reason for this are various <code>sys.version_info &gt;= (M, m)</code> conditions in <code>builtins.pyi</code> which now need to be resolved. I tried to account for this by adding a <code>import sys; sys.version_info</code> line in a local copy of <code>tomllib</code>, so the version on main would also have to import <code>sys</code>. This reduces the difference from 13% to 11%, but the comparison is still not fair. There are a lot more symbol-lookups on this feature branch (mostly <code>__bool__</code>).</li>
<li>In semantic-index building, we need to collect, store (and clone, when snapshotting) more information with the addition of the branching-condition data.</li>
</ul>
<h2>To do</h2>
<ul>
<li>[ ] Investigate performance regression</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2024-12-03 15:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">no-test</span> added by @sharkdp on 2024-12-03 15:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-12-03 15:13</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/david%2Fstatically-known-branches">CodSpeed Performance Report</a></h2>
<h3>Merging astral-sh/ruff#14759 will <strong>degrade performances by 21.62%</strong></h3>
<p><sub>Comparing <code>david/statically-known-branches</code> (0a0e5e6) with <code>main</code> (c3a64b4)</sub></p>
<h3>Summary</h3>
<p><code>❌ 2</code> regressions<br />
<code>✅ 30</code> untouched benchmarks</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/david%2Fstatically-known-branches">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>david/statically-known-branches</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ❌ | <code>red_knot_check_file[cold]</code> | 68 ms | 86.8 ms | -21.62% |
| ❌ | <code>red_knot_check_file[incremental]</code> | 4.2 ms | 4.4 ms | -4.31% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-03 15:14</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-05 12:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:277 on 2024-12-05 12:16</div>
            <div class="timeline-body"><p>Sorry for looking at the pr :) Just an idea: Maybe consider adding a <code>debug(db)</code> method that returns a type that implements <code>Debug</code>. I think this could be useful outside of tests too</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-05 12:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:277 on 2024-12-05 12:18</div>
            <div class="timeline-body"><p>My plan was to eventually remove this entirely. But I needed something to understand the use def map. If it turns out to be more generally useful, I'll consider such a refactoring, thanks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-05 12:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:277 on 2024-12-05 12:20</div>
            <div class="timeline-body"><p>I'd be very thankful for it if I ever have to debug the use def map!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-12-06 14:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:277 on 2024-12-06 14:58</div>
            <div class="timeline-body"><p>I did something similar for control flow (<code>FlowSnapshot</code>) to understand what's visible at each point although it's more of an ad hoc format but it was really useful for me to understand #13966.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">no-test</span> removed by @sharkdp on 2024-12-08 21:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/never.md</code>:73 on 2024-12-09 21:33</div>
            <div class="timeline-body"><p>I'm not sure I understand how the linked bug is relevant to our failure to emit a diagnostic here. <code>Never</code> is not unconditionally declared in <code>typing.pyi</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:6 on 2024-12-09 21:36</div>
            <div class="timeline-body"><pre><code class="language-suggestion">`False` at runtime. In typeshed, it is annotated as `bool`. This test makes sure that we infer
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-09 21:42</div>
            <div class="timeline-body"><p>So this is weird, not mentioned in the typing spec, and contrary to the behavior of every other known constant, but <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=02d2b9621a82c46fac926e3ea7c042c4">mypy</a> and <a href="https://pyright-play.net/?enableExperimentalFeatures=true&amp;code=CoTQCgog%2BgwgEhGBpAkgOQOIAIC8WBiAhgDYDOApgFCUCWAZlqJLAsuhgFyVY9YAeuLKQAuAJ269KATw79BAIjoB7JfOqjyAN3IkowqQAdyACikBKapaA">pyright</a> both actually respect any variable named <code>TYPE_CHECKING</code>, no matter where it is defined. The reason for this is that if people are using <code>if TYPE_CHECKING</code> to avoid extra runtime import costs from typing, they may also want to avoid the cost of importing the <code>typing</code> module itself, so <code>TYPE_CHECKING = False; if TYPE_CHECKING: ...</code> is the pseudo-officially recommended pattern in this case.</p>
<p>Curious what @AlexWaygood thinks, but I suspect we will have to emulate this behavior. Sorry I didn't think to mention it sooner.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_alias.md</code>:3 on 2024-12-09 21:46</div>
            <div class="timeline-body"><p>There are other forms of type alias (implicit type aliases, and those annotated with <code>typing.TypeAlias</code>) available in earlier versions, so it's clearer to be explicit here. (Probably we should rename the file and h1 to be clearer also.)</p>
<pre><code class="language-suggestion">PEP 695 type aliases are only available in Python 3.12 and later:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:87 on 2024-12-09 21:56</div>
            <div class="timeline-body"><p>Just a stylistic nit: I would probably prefer to use nested headings rather than filenames here? And save filenames for actual multi-file tests (that is, tests with imports). But I don't feel strongly; I realize the headings take up more vertical space.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:632 on 2024-12-09 21:59</div>
            <div class="timeline-body"><p>Maybe a test like this but where the <code>for</code> loop has a <code>break</code> in it? Also tests where the <code>break</code> is inside an <code>if True</code>, etc?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:316 on 2024-12-09 22:13</div>
            <div class="timeline-body"><p>This should have the same behavior without the <code>== 1</code>, right? Worth testing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-09 22:15</div>
            <div class="timeline-body"><p>Impressively comprehensive tests, thank you!!</p>
<p>Per request, I only looked at the mdtests.</p>
<p>Just a few comments, nothing significant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-09 23:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-09 23:27</div>
            <div class="timeline-body"><p>Hrm... not sure... I feel like I'd prefer for users to explicitly opt into something like that using something like mypy's <a href="https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-always-true"><code>--always-true</code> option</a>. Pyright also has a similar option. It has the advantage that it's more general, more explicit, more configurable and less magical.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-09 23:29</div>
            <div class="timeline-body"><p>Looks like pyright's version of this configuration knob is the <code>defineConstant</code> setting: https://github.com/microsoft/pyright/blob/main/docs/configuration.md#environment-options</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-09 23:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-09 23:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-09 23:57</div>
            <div class="timeline-body"><p>Hmm, I'm curious where else (and why else) people use this feature, other than for <code>TYPE_CHECKING</code>. But apparently people do, if pyright and mypy both support it?</p>
<p>I'm fine with leaving this as a separate feature to be handled later. According to GH code search, it seems like there's a reasonable amount of <code>TYPE_CHECKING = False</code> out there; I won't be surprised if we end up feeling like we need to support it by default.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-10 00:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-10 00:04</div>
            <div class="timeline-body"><p>I know that people who use both mypy and pyright often use it for cross-type-checker compatibility. You can configure mypy with <code>--always-true=MYPY</code> and pyright with <code>defineConstant = {&quot;MYPY&quot;: False}</code>, and then do things like this so that mypy will only see the first branch and pyright will only see the second:</p>
<pre><code class="language-py">if MYPY:
    ...
else:
    ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-10 08:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:316 on 2024-12-10 08:35</div>
            <div class="timeline-body"><p>Correct. Changed to the more concise form.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-10 10:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/never.md</code>:73 on 2024-12-10 10:48</div>
            <div class="timeline-body"><p>You're right. I was able to fix this. It's not related to #14297</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-10 11:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-10 11:10</div>
            <div class="timeline-body"><blockquote>
<p>mypy's <a href="https://mypy.readthedocs.io/en/stable/command_line.html#cmdoption-mypy-always-true"><code>--always-true</code> option</a>.</p>
</blockquote>
<blockquote>
<p>pyright's version of this configuration knob is the <code>defineConstant</code> setting</p>
</blockquote>
<p>Yes. And @MichaReiser planned a feature for this in Red Knot here: https://www.notion.so/astral-sh/CLI-14548797e1ca80bc98abd50730bbf63a?pvs=4#14948797e1ca80189ad6c8073b45ebf7</p>
<p>This is why I called the test file <code>known_constants.md</code>.</p>
<blockquote>
<p>I'm fine with leaving this as a separate feature to be handled later</p>
</blockquote>
<p>Ok. Let me know if you think any changes should be made to the test here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-10 15:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/known_constants.md</code>:42 on 2024-12-10 15:53</div>
            <div class="timeline-body"><p>I think the test is fine as-is for now; we can add the known-constants feature separately, and later evaluate if we feel we need to follow mypy and pyright in making <code>TYPE_CHECKING</code> a known-constant by default.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:277 on 2024-12-10 20:21</div>
            <div class="timeline-body"><p>I removed my print function as it was painful to update it while working on the code. A debug method sounds interesting, especially if I'm not the only one with that need. But I'll postpone that to another day/PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-10 20:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-10 21:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:87 on 2024-12-10 21:06</div>
            <div class="timeline-body"><p>Done. We now have five levels of nesting, but it does look nicer, I agree.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-10 22:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:632 on 2024-12-10 22:05</div>
            <div class="timeline-body"><blockquote>
<p>Maybe a test like this but where the <code>for</code> loop has a <code>break</code> in it?</p>
</blockquote>
<p>Yes, thanks!</p>
<p>Story time: That actually revealed a missing unconditional-branching point for <code>else</code>-clauses in for loops. I had that in the code previously, tried to write a test for it, and couldn't get it to fail. I then removed that line of code (somewhat puzzled why it wasn't required), but the new test clearly shows that it is in fact required, which makes a lot more sense to me.</p>
<blockquote>
<p>Also tests where the <code>break</code> is inside an <code>if True</code></p>
</blockquote>
<p>I was about to comment: <em>&quot;are you looking for trouble, sir?&quot;</em>, but then we settled things on Discord :smile:. We'll postpone things like support for <code>if False: break</code> to another PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2024-12-11 16:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-11 18:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/conditional/match.md</code>:12 on 2024-12-11 18:34</div>
            <div class="timeline-body"><p>We are &quot;too smart&quot; now and infer <code>Literal[3]</code> here, as we can see that the first pattern can never match. To keep the original intent of the test, I changed the match target to an unknown <code>int</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-11 18:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md</code>:73 on 2024-12-11 18:39</div>
            <div class="timeline-body"><p>This is a regression-test for something that was broken mid-way into this implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-11 19:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:822 on 2024-12-11 19:20</div>
            <div class="timeline-body"><p>I just realized that this is problematic in cases with multiple &quot;always True&quot; patterns. At runtime, we'll take the first of these branches. But in our current implementation here, since we always walk definitions backwards, we'll take the last instead:</p>
<pre><code class="language-py">x = 1

match &quot;a&quot;:
    case &quot;a&quot; if 1 == 1:
        x = 2
    case &quot;a&quot;:
        x = 3

reveal_type(x)  # we infer Literal[3], but it should be Literal[2]
</code></pre>
<p>Before I attempt to fix this, it would be good to get some feedback on whether or not we want static-truthiness checking in <code>match</code> statements at all. I thought it was a nice stretch-task, but maybe it causes more trouble than it's worth. The examples presented here are not particularly useful, but there might be some use cases involving enums? Not sure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md</code>:83 on 2024-12-11 23:36</div>
            <div class="timeline-body"><p>nit: I think putting the code inside a function is a nicer way to get a value of a less-precise type? The other thing I like about it is that it's resilient to the possibility that in the future we do some inlining / return-type inference that lets us infer <code>True</code> as the return value of <code>bool_instance()</code> (though I'm not sure we'd ever do that when it has an annotated return type)</p>
<pre><code class="language-suggestion">def _(flag: bool):
    while flag:
        x = 1

    # error: [possibly-unresolved-reference]
    x
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:13 on 2024-12-11 23:43</div>
            <div class="timeline-body"><p>We should probably have an <code>import sys</code> here? I assume we get away without it because of https://github.com/astral-sh/ruff/issues/14099</p>
<pre><code class="language-suggestion">import sys
if sys.version_info &gt;= (3, 9):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:796 on 2024-12-11 23:56</div>
            <div class="timeline-body"><p>Would make this test clearer if we didn't have two different <code>x = 1</code> in it</p>
<pre><code class="language-suggestion">        x = 2
    case &quot;b&quot;:
        x = 3
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:208 on 2024-12-12 00:00</div>
            <div class="timeline-body"><p>What about multiple <code>elif</code> branches, where multiple of them are always true?</p>
<pre><code class="language-py">if flag():
    x = 1
elif True:
    x = 2
elif True:
    x = 3
</code></pre>
<p>It seems like this <em>could</em> be subject the same problem as you describe below for match patterns, where we'd infer <code>3</code> here when it should be <code>2</code>? Apparently it isn't, but perhaps it's still worth testing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:822 on 2024-12-12 00:03</div>
            <div class="timeline-body"><p>I don't think we should spend a lot of extra time on implementation work that is specific to statically-known branches with match patterns; it's nice to have, but not clear how often it will be relevant.</p>
<p>I'm curious why this seems to affect match statements with multiple always-matching cases, but not <code>elif</code> chains with multiple always-true branches? The two would seem to have a lot in common. In both cases the key fact is that an always-true condition in an <code>elif</code> or <code>case</code> does not mean &quot;we definitely take this path&quot; (we might have already taken a previous one instead). It only means &quot;we definitely do not take any branch after this one.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">great writeup</span> added by @carljm on 2024-12-12 00:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:935 on 2024-12-12 01:14</div>
            <div class="timeline-body"><p>I find this name a bit confusing. An &quot;unconditional branch&quot; I would usually understand to mean &quot;a branch that is always taken.&quot; Here it seems to instead mean &quot;a branch that may or may not be taken, and we aren't recording any test expression (a condition) whose truthiness we can later check to see whether we know if it was taken or not.&quot;</p>
<p>(Note that this isn't a fundamental limitation: in principle we could also use type inference to decide that an iterable expression in a <code>for</code> loop is definitely empty, or definitely non-empty, in some cases, so we could also know if that branch is never or always taken. We just aren't choosing to do that analysis. And I don't necessarily think we should, possibly not ever, certainly not in this PR. But a <code>for</code> branch is a conditional branch just like an <code>if</code>, it's just one we aren't currently choosing to analyze for statically-known branching.)</p>
<p>I would suggest naming this method <code>record_possible_branching()</code> or <code>record_ambiguous_branching()</code> or something similar to that instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-12 05:24</div>
            <div class="timeline-body"><p>Haven't finished my review yet, but submitting a few minor comments I have so far, along with a couple higher-level thoughts/questions on the implementation approach.</p>
<p>(It is possible I'm rehashing here something we already discussed in 1:1 that doesn't work, in which case I apologize for wasting your time rehashing it. Alternatively, if this does make sense, I apologize for not thinking through this carefully enough to suggest it earlier in our 1:1s!)</p>
<p>I wonder if we can do this entirely with the existing constraints support in the use-def map, without the need to add a parallel system for tracking branch-conditions in the use-def map, or the need for the Branch::Ambiguous thing, or the need for the reverse-walking definitions with cutoff.</p>
<p>The constraints system already has the ability to add a constraint to all currently-live definitions. I think this is all we need, <em>if</em> we add the constraints at the right moment.</p>
<p>We would create a new <code>VisibilityConstraint</code> kind of constraint (name to-be-improved?), which can be either positive or negative (like any other constraint). Then in code like this:</p>
<pre><code class="language-py">x = 1
y = 1

if test:
    x = 2
</code></pre>
<p>Right before we merge the two control flow paths (so at the <em>end</em> of the <code>if</code> block) we would add a positive <code>VisibilityConstraint(test)</code> to all live definitions in the &quot;branch taken&quot; path (so <code>y = 1</code> and <code>x = 2</code> would get this constraint), and add a negative <code>VisibilityConstraint(~test)</code> to all live definitions in the &quot;branch not taken&quot; path (that's <code>x = 1</code> and <code>y = 1</code>).</p>
<p>In type inference, if a positive <code>VisibilityConstraint</code> evaluates to definitely falsy, or a negative <code>VisibilityConstraint</code> evaluates to definitely truthy, it eliminates the definition it applies to.</p>
<p>Note that when we merge control flow paths, if the same definition is live in both paths, any constraints not present for that definition on <em>both</em> paths are dropped. This will mean that in the above code we'll correctly end up with an unconstrained visibility of <code>y = 1</code> everywhere (at the merge point, it will have two different constraints from the two paths, and so both will be dropped). After the <code>if</code> block, we'll have visibility of <code>x = 2</code> constrained by positive <code>VisibilityConstraint(test)</code>, and visibility of <code>x = 1</code> constrained by negative <code>VisibilityConstraint(~test)</code>.</p>
<p>I <em>think</em> this can handle all cases correctly? To take a slightly more complex case:</p>
<pre><code class="language-py">x = 1
y = 1

if True:
    y = 2
else:
    x = 2
</code></pre>
<p>Here, right before merging the post-body state we'd apply a <code>VisibilityConstraint(True)</code> to all live definitions in that path: <code>x = 1</code> and <code>y = 2</code>. Right before merging the post-else state we'd apply a <code>VisibilityConstraint(~True)</code> to all live definitions in that path: <code>y = 1</code> and <code>x = 2</code>. This would give us the correct visible definitions of both at the end: <code>x = 1</code> and <code>y = 2</code> (because <code>y = 1</code> and <code>x = 2</code> would be eliminated by visibility).</p>
<p>What I like about this approach is a) it fits more neatly into the existing use-def map infrastructure, without needing to add as many new concepts to it, b) it eliminates the need for the &quot;walk definitions backwards and stop when we reach some definition&quot; logic, which still makes me feel a bit uncomfortable (I can't totally put my finger on it, but it feels like it's somehow breaking the abstraction of the use-def map in a way that might cause us problems later), and seems to cause issues at least in the match-statement case.</p>
<p>What do you think of this? Have I missed some important factor?</p>
<p>The other thing I wonder about is handling of boundness. If we take the above approach for definitions, I wonder if we can make boundness just fall out naturally by treating it as just another possible live definition for a symbol -- always the sole initial live definition for a symbol, until another definition is encountered. (I considered this when originally building the use-def map, but decided it was heavier than needed and a simple boolean would suffice, because narrowing constraints don't apply to the &quot;unbound&quot; &quot;definition&quot; -- but now we would have constraints that <em>do</em> apply to it, so the calculus changes.) In this scenario, checking boundness would be a simple matter of &quot;if the 'unbound' definition is live, we are maybe-unbound; if no other definition is live, we are definitely-unbound.&quot;</p>
<p>Again, curious for your thoughts on this!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-12 08:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:935 on 2024-12-12 08:11</div>
            <div class="timeline-body"><blockquote>
<p>I find this name a bit confusing. An &quot;unconditional branch&quot; I would usually understand to mean &quot;a branch that is always taken.&quot;</p>
</blockquote>
<p>Right. I was not happy with the name either. I introduced it for <code>try</code>…<code>except</code>, but it's confusing for something like a <code>for</code> loop. Changing to <code>record_ambiguous_branching</code> for now.</p>
<blockquote>
<p>Note that this isn't a fundamental limitation: in principle we could also use type inference to decide that an iterable expression in a for loop is definitely empty, or definitely non-empty, in some cases, so we could also know if that branch is never or always taken. We just aren't choosing to do that analysis. And I don't necessarily think we should, possibly not ever, certainly not in this PR. But a for branch is a conditional branch just like an if, it's just one we aren't currently choosing to analyze for statically-known branching.</p>
</blockquote>
<p>Yes. I don't see any value in doing that either. I just added it for <code>while</code> branches because it was trivial to do so, not because I think it's a particularly helpful feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-12 08:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/loops/while_loop.md</code>:83 on 2024-12-12 08:15</div>
            <div class="timeline-body"><p>Yes, thanks. This test predates function parameter inference, and I wasn't &quot;notified&quot; by Git when rebasing onto main that the structure of the tests changed here. Did so now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/bitset.rs</code>:109 on 2024-12-12 08:29</div>
            <div class="timeline-body"><p>I'm leaning towards making this a hard assert and add a debug message. It shouldn't add any significant performance cost
because it just replaces the bounds check on line 115 with the assert here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:102 on 2024-12-12 08:35</div>
            <div class="timeline-body"><p>Do we push a branching condition for every live binding? If we're only pushing an entry for bindings that are known to be always false or true, then I think it might be worth to consider using a <code>HashMap</code> instead (or a <code>Vec</code> and to linear search) because most code will only have very few &quot;conditions&quot; (the list is not dense).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:224 on 2024-12-12 08:37</div>
            <div class="timeline-body"><p>I don't fully crasp how this works yet, so I might be very wrong here.</p>
<p>I understand that we'll now iterate from the back when ever looking up a binding. Does that mean that checking now becomes <code>O(n^2)</code> if we have something like</p>
<pre><code class="language-python">x = 1
x += 1 # (iterates over x = 1)
x += 1 # (iterates over x +1, x=1)
x += 1 # (iterates over x + 1, x + 1, x = 1)
... 
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:137 on 2024-12-12 08:50</div>
            <div class="timeline-body"><p>This is not really related to your change but I'm surprised that <code>symbol</code> isn't a <code>salsa::tracked</code>... It is called across modules, but it might be fine, at least for as long as <code>symbol_by_id</code> never references any AST nodes (or anything that is directly derived from).</p>
<p>However, it does seem like that <code>symbol_id</code> now calls <code>node_ref</code> methods in <code>StaticTruthiness</code></p>
<p>https://github.com/astral-sh/ruff/blob/224e4b95fc0ee3d6a33a5f931dc57d180b949d86/crates/red_knot_python_semantic/src/types/static_truthiness.rs#L72-L76</p>
<p>We can't do that because it makes type inference of a single file dependent on the AST nodes of another file.</p>
<p>This might already be a problem with how we use <code>Constraint</code>s today</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:346 on 2024-12-12 08:54</div>
            <div class="timeline-body"><p>TODO ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-12 08:57</div>
            <div class="timeline-body"><p>This is great. I haven't reviewed the changes in detail but I left a few understand questions.</p>
<p>I think it would be great to have a test that demonstrates that statically-known dead branches don't emit diagnostics (or at least demonstrate that they do and have a TODO that we have to handle it). We need to avoid emitting diagnostics for known-dead branches so that it's e.g. possible to use newer python apis in branches that are known to support them without emitting diagnostics if checking for an older python version</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-12 09:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:224 on 2024-12-12 09:46</div>
            <div class="timeline-body"><blockquote>
<p>Does that mean that checking now becomes <code>O(n^2)</code> if we have something like</p>
</blockquote>
<p>I don't think so. We would only ever iterate over one <em>live</em> binding in this example. Rewriting using <code>x = x + 1</code> to distinguish stores and reads:</p>
<pre><code class="language-py">x = 1   # binding 1
x = x + 1  # binding 2; read of x only has one visible binding: 1
x = x + 1  # binding 3; read of x only has one visible binding: 2
</code></pre>
<p>In general, we never iterate over more bindings than we did before on this branch (there is more work to be done in each iteration though). We only changed the order of the iteration. But we might iterate over <em>fewer</em> bindings due to short circuiting in an example like this:</p>
<pre><code class="language-py">x = 1

if True:
    x = 2

x
</code></pre>
<p>Previously, we would iterate over both bindings of <code>x</code>. Now, while iterating in reverse, we can stop at the <code>x = 2</code> binding, because nothing else is visible &quot;beyond&quot; this binding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-12 10:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:102 on 2024-12-12 10:53</div>
            <div class="timeline-body"><blockquote>
<p>Do we push a branching condition for every live binding? If we're only pushing an entry for bindings that are known to be always false or true</p>
</blockquote>
<p>We don't know that yet while building the semantic index. So we push an empty branching conditions bitset for every binding we encounter.</p>
<blockquote>
<p>it might be worth to consider using a HashMap instead (or a Vec and to linear search) because most code will only have very few &quot;conditions&quot; (the list is not dense).</p>
</blockquote>
<p>I guess you are imagining a ScopedDefinitionId =&gt; BitSet HashMap?</p>
<p>There are two questions here:</p>
<ul>
<li>How many bindings come with branching conditions attached?</li>
<li>For those that do, out of the set of all possible branching conditions, how many are set for this binding?</li>
</ul>
<p>Is the concern that there are many bindings without any branching conditions? Or that there are many conditions and bindings usually only refer to a sparse subset?</p>
<p>If it's the former, I'm not sure that is the case. For every given scope, variables that appear directly in that scope would not have any branching conditions attached. But every binding that appears inside a <code>try</code> block, any kind of loop, an <code>if</code> block etc. would have at least one such branching condition.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-12 11:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:208 on 2024-12-12 11:04</div>
            <div class="timeline-body"><p>Good suggestion, I added the tests. Thanks.</p>
<blockquote>
<p>It seems like this <em>could</em> be subject the same problem as you describe below for match patterns, where we'd infer <code>3</code> here when it should be <code>2</code>? Apparently it isn't,</p>
</blockquote>
<p>Right. It works. But there is another case where it doesn't work. I'll explain in the other thread).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-12 12:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:102 on 2024-12-12 12:07</div>
            <div class="timeline-body"><blockquote>
<p>If it's the former, I'm not sure that is the case. For every given scope, variables that appear directly in that scope would not have any branching conditions attached. But every binding that appears inside a try block, any kind of loop, an if block etc. would have at least one such branching condition.</p>
</blockquote>
<p>Okay, I wasn't aware of that. My assumption was that we'd only push a condition if:</p>
<ul>
<li>It's known to be true</li>
<li>It's known to be false</li>
<li>An enclosing condition is known to be true or false (to now flag that it's unknown)</li>
</ul>
<p>I then assumed that this is relatively rare and that a different representation might be faster because it is just &quot;empty&quot; for most scopes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:822 on 2024-12-12 12:08</div>
            <div class="timeline-body"><blockquote>
<p>I'm curious why this seems to affect match statements with multiple always-matching cases, but not <code>elif</code> chains with multiple always-true branches?</p>
</blockquote>
<p>It currently works for <code>elif</code> chains but not for match patterns because of negative constraints. The way it currently works is that we record all constraints (including negative ones) when a binding is created:</p>
<pre><code class="language-py">if flag:
    x = 1  # conditional on flag
elif True:
    x = 2  # conditional on ~flag and True
elif True:
    x = 3  # conditional on ~flag, ~True and True
</code></pre>
<p>The <code>x = 3</code> binding is therefore <em>not</em> unconditionally visible, which currently leads us to correctly infer <code>Literal[1, 2]</code> for this case.</p>
<p>But now that I write it out like this, I also realize that this reveals a problem with my approach. Consider this example:</p>
<pre><code class="language-py">x = 1

if flag:
    x = 2  # conditional on flag
elif True:
    x = 3  # conditional on ~flag, True
</code></pre>
<p>Here, we currently infer <code>Literal[1, 2, 3]</code>, while it would be more correct to infer <code>Literal[2, 3]</code>. The problem is that we have the negative <code>~flag</code> condition in the <code>x = 3</code> binding, which prevents us from detecting it as &quot;unconditionally visible&quot;. And if we <em>would</em> detect it as unconditionally visible, we would run into the problem you mentioned. We would block off any previous bindings and incorrectly infer <code>Literal[3]</code>.</p>
<p>We could clearly do better.</p>
<p>I'm currently thinking that there are two problems:</p>
<ul>
<li>It seems to me like the set of constraints that we apply for static truthiness analysis needs to be different from the set of constraints that we apply for narrowing. For narrowing, we need that <code>~flag</code> constraint. But for static truthiness analysis, we don't care if <code>flag</code> has ambiguous truthiness or not, we always take an <code>elif True</code> branch.</li>
<li>When iterating the list of bindings in reverse, we should not stop at the first &quot;unconditionally visible&quot; binding, we need to go back to the earliest possible &quot;unconditionally visible&quot; binding.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-12 12:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-12 12:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:137 on 2024-12-12 12:21</div>
            <div class="timeline-body"><p>Okay, I think I was incorrect when I said that it isn't related to your changes. I did a quick review and it seems that the existing code all ends in a salsa query before accessing the constraint node. We should do the same for static thruthiness OR evaluate if we want to make <code>symbol_ty</code> a salsa query and remove the more fine-grained queries instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-12-12 12:29</div>
            <div class="timeline-body"><blockquote>
<p>(It is possible I'm rehashing here something we already discussed in 1:1 that doesn't work, in which case I apologize for wasting your time rehashing it. Alternatively, if this does make sense, I apologize for not thinking through this carefully enough to suggest it earlier in our 1:1s!)</p>
</blockquote>
<p>I appreciate the comment either way. It's also possible we discussed it and I simply didn't fully understand everything.</p>
<blockquote>
<p>The constraints system already has the ability to add a constraint to all currently-live definitions. I think this is all we need, <em>if</em> we add the constraints at the right moment.</p>
</blockquote>
<blockquote>
<p>We would create a new <code>VisibilityConstraint</code> kind of constraint</p>
</blockquote>
<blockquote>
<p>Right before we merge the two control flow paths (so at the <em>end</em> of the <code>if</code> block) we would add a positive <code>VisibilityConstraint(test)</code> to all live definitions in the &quot;branch taken&quot; path […], and add a negative <code>VisibilityConstraint(~test)</code> to all live definitions in the &quot;branch not taken&quot; path […].</p>
</blockquote>
<p>Let's consider this example:</p>
<pre><code class="language-py">x = 1

if True:
    if flag:
        x = 2
</code></pre>
<p>The correct thing to do is to consider both of these bindings to be potentially visible, i.e. we should infer <code>Literal[1, 2]</code>. But if I understand correctly, you would apply a <code>VisibilityConstraint(~True)</code> to the <code>x = 1</code> binding due to the outer condition. This would render the <code>x = 1</code> binding invisible.</p>
<p>The inner condition does not play a role here because the <code>flag</code> constraint vanishes as soon as we merge control flow at the end of the inner <code>if</code>. If that's confusing, we can also consider something like:</p>
<pre><code class="language-py">x = 1

if True:
    try:
        may_raise_value_error()
        x = 2
    except ValueError:
        pass
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-12 15:33</div>
            <div class="timeline-body"><blockquote>
<p>if I understand correctly, you would apply a <code>VisibilityConstraint(~True)</code> to the <code>x = 1</code> binding due to the outer condition. This would render the <code>x = 1</code> binding invisible.</p>
</blockquote>
<p>That constraint would be applied in the outer path, but it would disappear in the outer flow merge because <code>x = 1</code> is also live from the inner control flow path, without that constraint. So in this example we would still see <code>x = 1</code> as live and infer <code>Literal[1, 2]</code>.</p>
<p>But there is still a problem here; not a problem of &quot;not enough visibility&quot; but one of &quot;too much visibility&quot;. The logic we use for narrowing &quot;a constraint only applies to a definition after merge if it applies from both paths&quot; is not adequate for visibility. In this example:</p>
<pre><code class="language-py">x = 1
if True:
    if True:
        x = 2
</code></pre>
<p>We would have <code>V(~outerTrue)</code> for <code>x = 1</code> in the outer path, and both <code>V(outerTrue)</code> and <code>V(~innerTrue)</code> for it in the inner path. All of these would disappear in the outer flow merge, because none of them apply in both paths, so we'd wrongly see <code>x = 1</code> as visible. What we actually would need is to preserve a disjunction of the constraints from both paths: <code>V(~outerTrue) OR (V(outerTrue) AND V(~innerTrue))</code>.</p>
<p>I think this approach of building up a binary decision diagram of constraints is a reliable way to get the right answer, but it no longer fits cleanly into the existing narrowing-constraints infrastructure in the use-def map; it will require something new.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @sharkdp on 2024-12-12 15:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-12 15:44</div>
            <div class="timeline-body"><blockquote>
<p>I think it would be great to have a test that demonstrates that statically-known dead branches don't emit diagnostics (or at least demonstrate that they do and have a TODO that we have to handle it)</p>
</blockquote>
<p>I think for now this will need to be a test showing we don't suppress diagnostics, with a TODO. (Or we can just file an issue for it and skip the test and TODO.) Detecting dead code is a related, but somewhat different, problem than the one this PR tries to tackle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:1 on 2024-12-12 15:57</div>
            <div class="timeline-body"><p>nit: I think we use snake_case rather than kebab-case for most of our mdtest filenames</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/statically-known-branches.md</code>:112 on 2024-12-12 15:58</div>
            <div class="timeline-body"><p>nit: we support parameter types now ;)</p>
<p>(Same goes for many of other other tests in this file)</p>
<pre><code class="language-suggestion">def _(flag: bool):
    x = 1

    if flag:
        x = 2

    reveal_type(x)  # revealed: Literal[1, 2]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2612 on 2024-12-12 16:23</div>
            <div class="timeline-body"><p>hmm, do we need this, considering we already implement <code>From&lt;bool&gt;</code> for Truthiness?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2614 on 2024-12-12 16:23</div>
            <div class="timeline-body"><p>might be nice to make this <code>pub(crate)</code> as well, just for consistency with the other two you've added</p>
<pre><code class="language-suggestion">    pub(crate) const fn is_ambiguous(self) -&gt; bool {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/static_truthiness.rs</code>:31 on 2024-12-12 16:24</div>
            <div class="timeline-body"><pre><code class="language-suggestion">#[derive(Debug)]
pub(crate) struct StaticTruthiness {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:4064 on 2024-12-12 16:25</div>
            <div class="timeline-body"><p>this change seems worth doing on its own -- could consider splitting it off into a separate refactor. (But it's also pretty small, so I definitely don't mind it being part of this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-12 16:29</div>
            <div class="timeline-body"><p>I haven't looked in depth (since Micha and Carl already have), just a couple of very small things from skimming</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-12 17:06</div>
            <div class="timeline-body"><p>Now that this has gone back into Draft and we are exploring other implementation strategies -- it might also make sense to extract the narrowing support for <code>while</code> loops and <code>match</code> statements into separate PRs, to focus the scope on just the statically-known branches part?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Statically known branches" to "[red-knot] Statically known branches (first take)" by @sharkdp on 2024-12-16 12:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2024-12-19 16:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-23 16:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:08:14 UTC
    </footer>
</body>
</html>
