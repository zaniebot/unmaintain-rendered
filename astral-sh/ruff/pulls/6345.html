<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Store expression hierarchy in semantic model snapshots - astral-sh/ruff #6345</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Store expression hierarchy in semantic model snapshots</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/6345">#6345</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-08-04 16:23
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-04 16:23</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>When we iterate over the AST for analysis, we often process nodes in a &quot;deferred&quot; manner. For example, if we're analyzing a function, we push the function body onto a deferred stack, along with a snapshot of the current semantic model state. Later, when we analyze the body, we restore the semantic model state from the snapshot. This ensures that we know the correct scope, hierarchy of statement parents, etc., when we go to analyze the function body.</p>
<p>Historically, we <em>haven't</em> included the <em>expression</em> hierarchy in the model snapshot -- so we track the current expression parents in the visitor, but we never save and restore them when processing deferred nodes. This can lead to subtle bugs, in that methods like <code>expr_parent()</code> aren't guaranteed to be correct, if you're in a deferred visitor.</p>
<p>This PR migrates expression tracking to mirror statement tracking exactly. So we push all expressions onto an <code>IndexVec</code>, and include the current expression on the snapshot. This ensures that <code>expr_parent()</code> and related methods are &quot;always correct&quot; rather than &quot;sometimes correct&quot;.</p>
<p>There's a performance cost here, both at runtime and in terms of memory consumption (we now store an additional pointer for every expression). In my hyperfine testing, it's about a 1% performance decrease for all-rules on CPython (up to 533.8ms, from 528.3ms) and a 4% performance decrease for default-rules on CPython (up to 212ms, from 204ms). However... I think this is worth it given the incorrectness of our current approach. In the future, we may want to reconsider how we do these upward traversals (e.g., with something like a red-green tree). (<strong>Note</strong>: in https://github.com/astral-sh/ruff/pull/6351, the slowdown seems to be entirely removed.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-04 16:24</div>
            <div class="timeline-body"><p>This will also fix https://github.com/astral-sh/ruff/issues/6285, but I'll handle that in a separate PR, I want to update the fixtures and it would be too noisy here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2023-08-04 16:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-08-04 16:50</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Ecosystem</h3>
<p>✅ ecosystem check detected no changes.</p>
<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      8.2±0.15ms     4.9 MB/sec    1.00      8.2±0.13ms     5.0 MB/sec
formatter/numpy/ctypeslib.py               1.00  1632.6±39.05µs    10.2 MB/sec    1.00  1634.7±39.80µs    10.2 MB/sec
formatter/numpy/globals.py                 1.00    182.8±6.00µs    16.1 MB/sec    1.01    184.1±7.57µs    16.0 MB/sec
formatter/pydantic/types.py                1.01      3.5±0.09ms     7.4 MB/sec    1.00      3.4±0.05ms     7.4 MB/sec
linter/all-rules/large/dataset.py          1.00     11.0±0.07ms     3.7 MB/sec    1.02     11.3±0.16ms     3.6 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      2.8±0.01ms     6.0 MB/sec    1.00      2.8±0.01ms     6.0 MB/sec
linter/all-rules/numpy/globals.py          1.00    384.1±0.57µs     7.7 MB/sec    1.01    387.1±0.66µs     7.6 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.0±0.05ms     5.1 MB/sec    1.02      5.1±0.03ms     5.0 MB/sec
linter/default-rules/large/dataset.py      1.00      5.4±0.03ms     7.6 MB/sec    1.02      5.5±0.03ms     7.4 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1139.3±5.59µs    14.6 MB/sec    1.02   1157.0±6.87µs    14.4 MB/sec
linter/default-rules/numpy/globals.py      1.00    127.5±1.16µs    23.1 MB/sec    1.03    131.1±3.65µs    22.5 MB/sec
linter/default-rules/pydantic/types.py     1.00      2.4±0.01ms    10.7 MB/sec    1.02      2.4±0.02ms    10.4 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00     13.2±0.70ms     3.1 MB/sec    1.00     13.3±0.73ms     3.1 MB/sec
formatter/numpy/ctypeslib.py               1.06      2.7±0.29ms     6.2 MB/sec    1.00      2.6±0.16ms     6.5 MB/sec
formatter/numpy/globals.py                 1.00   293.5±33.83µs    10.1 MB/sec    1.01   297.9±56.58µs     9.9 MB/sec
formatter/pydantic/types.py                1.00      5.5±0.32ms     4.7 MB/sec    1.01      5.5±0.27ms     4.6 MB/sec
linter/all-rules/large/dataset.py          1.00     18.3±0.78ms     2.2 MB/sec    1.04     19.1±0.86ms     2.1 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.7±0.27ms     3.5 MB/sec    1.02      4.9±0.26ms     3.4 MB/sec
linter/all-rules/numpy/globals.py          1.00   582.3±30.81µs     5.1 MB/sec    1.00   579.5±40.79µs     5.1 MB/sec
linter/all-rules/pydantic/types.py         1.03      8.6±0.47ms     3.0 MB/sec    1.00      8.3±0.52ms     3.1 MB/sec
linter/default-rules/large/dataset.py      1.02     10.0±0.63ms     4.1 MB/sec    1.00      9.8±0.45ms     4.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1922.4±98.52µs     8.7 MB/sec    1.01  1932.4±77.76µs     8.6 MB/sec
linter/default-rules/numpy/globals.py      1.00   216.2±19.84µs    13.6 MB/sec    1.06   228.8±25.06µs    12.9 MB/sec
linter/default-rules/pydantic/types.py     1.00      4.2±0.26ms     6.0 MB/sec    1.06      4.5±0.39ms     5.7 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-04 18:07</div>
            <div class="timeline-body"><p>Hmm, we don't need back references for expressions (we never need to be able to go from a node to its ID, or from a node to its parent -- we can always go from an ID to its parent), so perhaps we can improve performance here by omitting the hash map from <code>Nodes</code> in that case. I will test it out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-04 18:36</div>
            <div class="timeline-body"><p>Ok, I'm going to resolve the performance degradation in a separate PR because I think it's easier to review this as-is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @charliermarsh on 2023-08-04 18:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/flake8_pytest_style/rules/assertion.rs</code>:251 on 2023-08-07 07:14</div>
            <div class="timeline-body"><p>Is this change intentional?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:43 on 2023-08-07 07:17</div>
            <div class="timeline-body"><p>Nit: We now store both a stack of statements and expressions. This gives us almost a full fidelity parent chain, except that it isn't possible to get the <code>parent</code> statement of an expression (except for the current expression).</p>
<p>What do you think of introducing a <code>Vec&lt;AnyNodeRef&gt;</code> that stores all parent nodes (Ultimately means <code>O(n)</code> pointers to be written, where <code>n</code> = len(AST)) instead? You can retrieve the current statement by traversing upwards until you find the first <code>is_statement()</code> node.</p>
<p>The one issue of that is that there's currently no way to go from <code>AnyNodeRef</code> to <code>&amp;Stmt</code>. We would need to introduce a <code>AnyStatementRef</code> enum for that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:864 on 2023-08-07 07:19</div>
            <div class="timeline-body"><p>Why is it necessary to <code>skip(1)</code>? Shouldn't <code>ancestor_ids</code> return the ancestors only?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:867 on 2023-08-07 07:20</div>
            <div class="timeline-body"><p>Nit: Use successors?</p>
<pre><code class="language-suggestion">std::iter::successors(self.expr_id, |id| self.exprs.ancestor_ids(id).skip(1).map(|id| self.exprs[id])))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-08-07 07:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-08-07 07:21</div>
            <div class="timeline-body"><p>Could we add some tests for the new introduced APIs? Or how did you test that this works as expected?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:43 on 2023-08-07 13:34</div>
            <div class="timeline-body"><p>I will consider this separately, it makes sense to me, although it may come with the performance regression that I documented here and fixed in https://github.com/astral-sh/ruff/pull/6351.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-07 13:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-07 13:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/rules/flake8_pytest_style/rules/assertion.rs</code>:251 on 2023-08-07 13:35</div>
            <div class="timeline-body"><p>Yes! Not necessary. See the identical change in <code>crates/ruff/src/rules/pandas_vet/rules/inplace_argument.rs</code> that removes the large comment around Case 3. The fact that these tests still pass is a evidence that this change is working as expected.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-07 13:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:864 on 2023-08-07 13:36</div>
            <div class="timeline-body"><p>Right now, <code>ancestor_ids</code> starts with the current ID IIRC, probably because it's convenient with the <code>successors</code> API.  Do you find that confusing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-08-07 13:37</div>
            <div class="timeline-body"><blockquote>
<p>Could we add some tests for the new introduced APIs? Or how did you test that this works as expected?</p>
</blockquote>
<p>I'm going to add some tests in a separate PR, I wanted to make sure that this had a clean snapshot suite.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-07 13:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:867 on 2023-08-07 13:41</div>
            <div class="timeline-body"><p>This doesn't quite do the same thing. The awkwardness is that <code>self.expr_id</code> can be <code>None</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-08-07 13:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-08-07 13:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-08-07 13:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-07 13:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:864 on 2023-08-07 13:42</div>
            <div class="timeline-body"><p>(This is current behavior on <code>main</code> so I'll look into it separately.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-08-07 13:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:867 on 2023-08-07 13:51</div>
            <div class="timeline-body"><p>I'm not sure if I understand. The first argument to <code>std::iter::successors</code> is an <code>Option</code>. Both <code>successors and </code>expr_id.flat_map<code>should short circuit if expr_id is</code>None`.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-07 13:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:867 on 2023-08-07 13:57</div>
            <div class="timeline-body"><p>Oh, I think you just had misplaced parentheses in your suggestion and I misunderstood.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:43 on 2023-08-15 00:18</div>
            <div class="timeline-body"><p>I was looking into this and I want to understand the last paragraph here. Is the suggestion that methods like <code>SemanticModel#current_statement</code> would now return <code>AnyStatementRef</code>? And so we'd change all consumers of that method to work with <code>AnyStatementRef</code> rather than <code>&amp;Stmt</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-15 00:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-15 00:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:43 on 2023-08-15 00:18</div>
            <div class="timeline-body"><p>If so, we also need <code>AnyExpressionRef</code>, and I'd ultimately like to store the full-fidelity chain here including <code>Parameters</code>, <code>Arguments</code>, etc...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-15 00:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:43 on 2023-08-15 00:37</div>
            <div class="timeline-body"><p>E.g., these kinds of changes: https://github.com/astral-sh/ruff/compare/charlie/any-node-ref?expand=1#diff-c2c8422959405016e1fb54ca23edee9716bd06ad64e610ceea9612a8291122fcR1815. It's feasible but a lot of call sites to work through, so I want to make sure I understand what's being suggested before I think on it further.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-08-15 01:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:43 on 2023-08-15 01:39</div>
            <div class="timeline-body"><p>I might propose that we do this incrementally by adding an internal type to the semantic crate that's like <code>AnyNodeRef</code>, but less granular:</p>
<pre><code class="language-rust">#[derive(Debug, Clone)]
pub enum AnyNodeRef&lt;'a&gt; {
    Stmt(&amp;'a Stmt),
    Expr(&amp;'a Expr),
}

impl&lt;'a&gt; AnyNodeRef&lt;'a&gt; {
    pub fn as_statement(&amp;self) -&gt; Option&lt;&amp;'a Stmt&gt; {
        match self {
            AnyNodeRef::Stmt(stmt) =&gt; Some(stmt),
            AnyNodeRef::Expr(_) =&gt; None,
        }
    }
}
</code></pre>
<p>That way, we wouldn't need to change the <code>SemanticModel</code> interface at all for now.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 02:52:41 UTC
    </footer>
</body>
</html>
