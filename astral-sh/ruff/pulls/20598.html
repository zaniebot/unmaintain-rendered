<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] defer inference of legacy TypeVar bound/constraints/defaults - astral-sh/ruff #20598</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] defer inference of legacy TypeVar bound/constraints/defaults</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20598">#20598</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-09-27 01:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2025-09-27 01:53</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This allows us to handle self-referential bounds/constraints/defaults without panicking.</p>
<p>Handles more cases from https://github.com/astral-sh/ty/issues/256</p>
<p>This also changes the way we infer the types of legacy TypeVars. Rather than understanding a constructor call to <code>typing[_extension].TypeVar</code> inside of any (arbitrarily nested) expression, and having to use a special <code>assigned_to</code> field of the semantic index to try to best-effort figure out what name the typevar was assigned to, we instead understand the creation of a legacy <code>TypeVar</code> only in the supported syntactic position (RHS of a simple un-annotated assignment with one target). In any other position, we just infer it as creating an opaque instance of <code>typing.TypeVar</code>. (This behavior matches all other type checkers.)</p>
<p>So we now special-case TypeVar creation in <code>TypeInferenceBuilder</code>, as a special case of an assignment definition, rather than deeper inside call binding. This does mean we re-implement slightly more of argument-parsing, but in practice this is minimal and easy to handle correctly.</p>
<p>This is easier to implement if we also make the RHS of a simple (no unpacking) one-target assignment statement no longer a standalone expression. Which is fine to do, because simple one-target assignments don't need to infer the RHS more than once. This is a bonus performance (0-3% across various projects) and significant memory-usage win, since most assignment statements are simple one-target assignment statements, meaning we now create many fewer standalone-expression salsa ingredients.</p>
<p>This change does mean that inference of manually-constructed <code>TypeAliasType</code> instances can no longer find its Definition in <code>assigned_to</code>, which regresses go-to-definition for these aliases. In a future PR, <code>TypeAliasType</code> will receive the same treatment that <code>TypeVar</code> did in this PR (moving its special-case inference into <code>TypeInferenceBuilder</code> and supporting it only in the correct syntactic position, and lazily inferring its value type to support recursion), which will also fix the go-to-definition regression. (I decided a temporary edge-case regression is better in this case than doubling the size of this PR.)</p>
<p>This PR also tightens up and fixes various aspects of the validation of <code>TypeVar</code> creation, as seen in the tests.</p>
<p>We still (for now) treat all typevars as instances of <code>typing.TypeVar</code>, even if they were created using <code>typing_extensions.TypeVar</code>. This means we'll wrongly error on e.g. <code>T.__default__</code> on Python 3.11, even if <code>T</code> is a <code>typing_extensions.TypeVar</code> instance at runtime. We share this wrong behavior with both mypy and pyrefly. It will be easier to fix after we pull in https://github.com/python/typeshed/pull/14840.</p>
<p>There are some issues that showed up here with typevar identity and <code>MarkTypeVarsInferable</code>; the fix here (using the new <code>original</code> field and <code>is_identical_to</code> methods on <code>BoundTypeVarInstance</code> and <code>TypeVarInstance</code>) is a bit kludgy, but it can go away when we eliminate <code>MarkTypeVarsInferable</code>.</p>
<h2>Test Plan</h2>
<p>Added and updated mdtests.</p>
<h3>Conformance suite impact</h3>
<p>The impact here is all positive:</p>
<ul>
<li>We now correctly error on a legacy TypeVar with exactly one constraint type given.</li>
<li>We now correctly error on a legacy TypeVar with both an upper bound and constraints specified.</li>
</ul>
<h3>Ecosystem impact</h3>
<p>Basically none; in the setuptools case we just issue slightly different errors on an invalid TypeVar definition, due to the modified validation code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @carljm on 2025-09-27 01:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-27 01:55</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-10-09 21:06:16.051150791 +0000
+++ new-output.txt	2025-10-09 21:06:19.328159431 +0000
@@ -1,6 +1,6 @@
 WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
 fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_type_statement.py`: `PEP695TypeAliasType &lt; 'db &gt;::value_type_(Id(cc17)): execute: too many cycle iterations`
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(1643f)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(1603f)): execute: too many cycle iterations`
 _directives_deprecated_library.py:15:31: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `int`
 _directives_deprecated_library.py:30:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `str`
 _directives_deprecated_library.py:36:41: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Self@__add__`
@@ -364,6 +364,7 @@
 generics_base_class.py:49:22: error[too-many-positional-arguments] Too many positional arguments to class `LinkedList`: expected 1, got 2
 generics_base_class.py:61:18: error[too-many-positional-arguments] Too many positional arguments to class `MyDict`: expected 1, got 2
 generics_basic.py:34:12: error[unsupported-operator] Operator `+` is unsupported between objects of type `AnyStr@concat` and `AnyStr@concat`
+generics_basic.py:49:44: error[invalid-legacy-type-variable] A `TypeVar` cannot have exactly one constraint
 generics_basic.py:139:5: error[type-assertion-failure] Argument does not have asserted type `int`
 generics_basic.py:140:5: error[type-assertion-failure] Argument does not have asserted type `int`
 generics_basic.py:157:5: error[invalid-argument-type] Method `__getitem__` of type `bound method MyMap1[str, int].__getitem__(key: str, /) -&gt; int` cannot be called with key of type `Literal[0]` on object of type `MyMap1[str, int]`
@@ -575,7 +576,8 @@
 generics_upper_bound.py:43:1: error[type-assertion-failure] Argument does not have asserted type `list[int] | set[int]`
 generics_upper_bound.py:51:8: error[invalid-argument-type] Argument to function `longer` is incorrect: Argument type `Literal[3]` does not satisfy upper bound `Sized` of type variable `ST`
 generics_upper_bound.py:51:11: error[invalid-argument-type] Argument to function `longer` is incorrect: Argument type `Literal[3]` does not satisfy upper bound `Sized` of type variable `ST`
-generics_variance.py:14:6: error[invalid-legacy-type-variable] A legacy `typing.TypeVar` cannot be both covariant and contravariant
+generics_upper_bound.py:56:10: error[invalid-legacy-type-variable] A `TypeVar` cannot have both a bound and constraints
+generics_variance.py:14:6: error[invalid-legacy-type-variable] A `TypeVar` cannot be both covariant and contravariant
 generics_variance.py:26:27: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Iterator[T_co@ImmutableList]`
 generics_variance.py:57:28: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `B_co@func`
 generics_variance.py:175:25: error[non-subscriptable] Cannot subscript object of type `&lt;class 'Contra[typing.TypeVar]'&gt;` with no `__class_getitem__` method
@@ -898,5 +900,5 @@
 typeddicts_usage.py:28:17: error[missing-typed-dict-key] Missing required key 'name' in TypedDict `Movie` constructor
 typeddicts_usage.py:28:18: error[invalid-key] Invalid key access on TypedDict `Movie`: Unknown key &quot;title&quot;
 typeddicts_usage.py:40:24: error[invalid-type-form] The special form `typing.TypedDict` is not allowed in type expressions. Did you mean to use a concrete TypedDict or `collections.abc.Mapping[str, object]` instead?
-Found 899 diagnostics
+Found 901 diagnostics
 WARN A fatal error occurred while checking some files. Not all project files were analyzed. See the diagnostics list above for details.
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-27 01:56</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">spack (https://github.com/spack/spack)
- lib/spack/spack/vendor/typing_extensions.py:313:12: error[invalid-legacy-type-variable] A legacy `typing.TypeVar` must be immediately assigned to a variable
+ lib/spack/spack/vendor/typing_extensions.py:313:12: error[invalid-legacy-type-variable] A `TypeVar` definition must be a simple variable assignment

setuptools (https://github.com/pypa/setuptools)
- setuptools/_vendor/typing_extensions.py:256:12: error[invalid-legacy-type-variable] A legacy `typing.TypeVar` must be immediately assigned to a variable
+ setuptools/_vendor/typing_extensions.py:256:12: error[invalid-legacy-type-variable] A `TypeVar` definition must be a simple variable assignment
- setuptools/_vendor/typing_extensions.py:1517:27: error[invalid-legacy-type-variable] The `contravariant` parameter of a legacy `typing.TypeVar` cannot have an ambiguous value
- setuptools/_vendor/typing_extensions.py:1517:68: error[invalid-type-form] Variable of type `None` is not allowed in a type expression
+ setuptools/_vendor/typing_extensions.py:1517:48: error[invalid-legacy-type-variable] Starred arguments are not supported in `TypeVar` creation
- Found 800 diagnostics
+ Found 799 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/build/_wheelfile.py:51:22: error[no-matching-overload] No overload of function `field` matches arguments
- Found 52 diagnostics
+ Found 51 diagnostics

</code></pre>
</details>
<details>
<summary>Memory usage changes were detected when running on open source projects</summary>

<pre><code class="language-diff">trio (https://github.com/python-trio/trio)
-     memo fields = ~108MB
+     memo fields = ~103MB

sphinx (https://github.com/sphinx-doc/sphinx)
-     memo metadata = ~42MB
+     memo metadata = ~40MB

prefect (https://github.com/PrefectHQ/prefect)
- TOTAL MEMORY USAGE: ~541MB
+ TOTAL MEMORY USAGE: ~515MB
-     struct metadata = ~30MB
+     struct metadata = ~28MB
-     struct fields = ~35MB
+     struct fields = ~33MB
-     memo fields = ~384MB
+     memo fields = ~366MB

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @carljm on 2025-09-27 02:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-27 02:28</div>
            <div class="timeline-body"><!-- generated-comment ty ecosystem-analyzer -->

<h2><code>ecosystem-analyzer</code> results</h2>
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>invalid-legacy-type-variable</code> | 1 | 1 | 0 |
| <code>invalid-type-form</code> | 0 | 1 | 0 |
| <code>no-matching-overload</code> | 1 | 0 | 0 |
| <strong>Total</strong> | <strong>2</strong> | <strong>2</strong> | <strong>0</strong> |</p>
<p><strong><a href="https://cjm-legacytv.ecosystem-663.pages.dev/diff">Full report with detailed diff</a></strong> (<a href="https://cjm-legacytv.ecosystem-663.pages.dev/timing">timing results</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-09-27 23:30</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Flegacytv">CodSpeed Performance Report</a></h2>
<h3>Merging #20598 will <strong>improve performances by 5.56%</strong></h3>
<p><sub>Comparing <code>cjm/legacytv</code> (75eda5e) with <code>main</code> (b086ffe)</sub></p>
<h3>Summary</h3>
<p><code>‚ö° 1</code> improvement<br />
<code>‚úÖ 20</code> untouched<br />
<code>‚è© 30</code> skipped[^skipped]</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | ---- | --------- | ------ | ------ | ------ |
| ‚ö° | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Flegacytv?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Asmall%5Bfreqtrade%5D&amp;runnerMode=WallTime"><code>small[freqtrade]</code></a> | 5.2 s | 4.9 s | +5.56% |
[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Flegacytv?sectionId=benchmark-comparison-section-baseline-result-skipped">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @carljm on 2025-10-06 20:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @carljm on 2025-10-06 20:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @carljm on 2025-10-08 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @carljm on 2025-10-08 00:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @carljm on 2025-10-08 00:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @carljm on 2025-10-08 00:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @carljm on 2025-10-08 23:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @carljm on 2025-10-08 23:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @carljm on 2025-10-09 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2025-10-09 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @carljm on 2025-10-09 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @carljm on 2025-10-09 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2025-10-09 00:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/goto_type_definition.rs</code>:311 on 2025-10-09 06:50</div>
            <div class="timeline-body"><p>Can we create an issue for this. It's otherwise hard to remember</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-09 06:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/classes.md</code>:3 on 2025-10-09 12:45</div>
            <div class="timeline-body"><pre><code class="language-suggestion">We use TypeVar defaults here, which were added in Python 3.13 for legacy typevars.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/classes.md</code>:3 on 2025-10-09 12:47</div>
            <div class="timeline-body"><p>(Though as we've discussed, we should really permit users to pass <code>default=whatever</code> even on lower Python versions if the user is making use of <code>typing_extensions.TypeVar</code>. Doesn't need to be fixed in this PR, but the prose could possibly be adjusted here to reflect that?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:42 on 2025-10-09 12:51</div>
            <div class="timeline-body"><p>these assertions still pass (and still seem useful) -- what's the motivation for getting rid of them?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:74 on 2025-10-09 12:52</div>
            <div class="timeline-body"><p>similarly here, what's the motivation for getting rid of the error message from the assertion?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:105 on 2025-10-09 12:54</div>
            <div class="timeline-body"><p>are these mandated by the spec? They almost feel like lints to me, given that (I assume) we'll infer the type just fine for each value passed into each parameter</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:158 on 2025-10-09 12:54</div>
            <div class="timeline-body"><p>I think we probably only need one copy of this assertion? üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:265 on 2025-10-09 12:57</div>
            <div class="timeline-body"><p>I still think it would be fine to treat stubs the same way as runtime files here -- I'd happily make the necessary changes to typeshed... but I guess other stub file authors may be relying on the behaviour of mypy and pyright here, and might get annoyed with us if we complained about this. Blegh.</p>
<p>Maybe it's worth saying explicitly in the prose that this isn't specified very well, but that we emulate other type checkers' behaviour here for maximum compatibility?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:404 on 2025-10-09 13:02</div>
            <div class="timeline-body"><p>hrm... on line 351 you said that they <em>cannot</em> be cyclic, but here you say that they <em>can</em> &quot;cyclically&quot; refer back to their own type?</p>
<p>Though FWIW I think it's debatable whether this example really counts as a cycle. <code>G</code> as it appears in the bound of <code>list[G]</code> here is syntactic sugar for the default specialization of <code>G</code>, which is <code>G[Unknown]</code> -- so this type variable's upper bound is <code>list[G[Unknown]]</code>, which is not a type that refers back to <code>T</code> in any way since <code>T</code> has been fully &quot;specialized away&quot; from the type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:388 on 2025-10-09 13:03</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Defaults can be generic, but can only refer to typevars already defined in the same scope:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:438 on 2025-10-09 13:05</div>
            <div class="timeline-body"><pre><code class="language-suggestion"># TODO: should never leak a typevar like this in type inference
reveal_type(D().x)  # revealed: V@D
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:462 on 2025-10-09 13:08</div>
            <div class="timeline-body"><p>did this break in an earlier version of this PR? It seems to work fine on <code>main</code>: https://play.ty.dev/d6e5578c-31fa-4e0e-b54d-64c920e7a478</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 13:10</div>
            <div class="timeline-body"><p>Only reviewed the tests so far</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:1632 on 2025-10-09 14:50</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                // Optimization for the common case: if there's just one target, and it's not an
                // unpacking, and the target is a simple name, we don't need the RHS to be a
                // standalone expression at all.
                if let [target @ ast::Expr::Name(_)] = &amp;node.targets[..]
</code></pre>
<p>also, this seems like quite a big win from the Codspeed report -- I think it could also be safely applied for lots of non-name expressions? <code>x.foo = 42</code> and <code>x[0] = 42</code> can also definitely be excluded from being possible unpackable assignments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7957 on 2025-10-09 14:53</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let ty = match definition.kind(db) {
            // PEP 695 typevar
            DefinitionKind::TypeVar(typevar) =&gt; {
                let typevar_node = typevar.node(&amp;module);
                definition_expression_type(
                    db,
                    definition,
                    typevar_node.bound.as_ref()?,
                )
            }
            // legacy typevar
            DefinitionKind::Assignment(assignment) =&gt; {
                let call_expr = assignment.value(&amp;module).as_call_expr()?;
                let expr = &amp;call_expr.arguments.find_keyword(&quot;bound&quot;)?.value;
                definition_expression_type(db, definition, expr)
            }
            _ =&gt; return None,
        };
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7996 on 2025-10-09 14:55</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let ty = match definition.kind(db) {
            // PEP 695 typevar
            DefinitionKind::TypeVar(typevar) =&gt; {
                let typevar_node = typevar.node(&amp;module);
                definition_expression_type(db, definition, typevar_node.bound.as_ref()?)
                    .into_union()?
            }
            // legacy typevar
            DefinitionKind::Assignment(assignment) =&gt; {
                let call_expr = assignment.value(&amp;module).as_call_expr()?;
                // We don't use `UnionType::from_elements` or `UnionBuilder` here,
                // because we don't want to simplify the list of constraints as we would with
                // an actual union type.
                // TODO: We probably shouldn't use `UnionType` to store these at all? TypeVar
                // constraints are not a union.
                UnionType::new(
                    db,
                    call_expr
                        .arguments
                        .args
                        .iter()
                        .skip(1)
                        .map(|arg| definition_expression_type(db, definition, arg))
                        .collect::&lt;Box&lt;_&gt;&gt;(),
                )
            }
            _ =&gt; return  None,
        };
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4029 on 2025-10-09 15:17</div>
            <div class="timeline-body"><p>a little less nested indentation:</p>
<pre><code class="language-suggestion">                let value_ty = if let Some(standalone_expression) = self.index.try_expression(value)
                {
                    self.infer_standalone_expression_impl(value, standalone_expression, tcx)
                } else if let ast::Expr::Call(call_expr) = value {
                    // If the RHS is not a standalone expression, this is a simple assignment
                    // (single target, no unpackings). That means it's a valid syntactic form
                    // for a legacy TypeVar creation; check for that.
                    let callable_type = self.infer_maybe_standalone_expression(
                        call_expr.func.as_ref(),
                        TypeContext::default(),
                    );

                    let typevar_class = callable_type
                        .into_class_literal()
                        .and_then(|cls| cls.known(self.db()))
                        .filter(|cls| {
                            matches!(cls, KnownClass::TypeVar | KnownClass::ExtensionsTypeVar)
                        });

                    let ty = if let Some(typevar_class) = typevar_class {
                        self.infer_legacy_typevar(target, call_expr, definition, typevar_class)
                    } else {
                        self.infer_call_expression_impl(call_expr, callable_type, tcx)
                    };
                    self.store_expression_type(value, ty);
                    ty
                } else {
                    self.infer_expression(value, tcx)
                };
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:105 on 2025-10-09 15:25</div>
            <div class="timeline-body"><p>Oh, I see that with the new implementation of <code>TypeVar</code> definition parsing, this probably simplifies the implementation a lot. So feel free to disregard this comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 15:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4113 on 2025-10-09 15:29</div>
            <div class="timeline-body"><p>maybe a slightly clearer error message?</p>
<pre><code class="language-suggestion">                                &quot;The `covariant` parameter of `typing.TypeVar` \
                                cannot have an ambiguous truthiness&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4130 on 2025-10-09 15:29</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                                cannot have an ambiguous truthiness&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4201 on 2025-10-09 15:32</div>
            <div class="timeline-body"><p>Hmm:</p>
<pre><code>error[invalid-legacy-type-variable]: The first argument to `typing.TypeVar` must be a string literal.
 --&gt; foo.py:3:5
  |
1 | import typing
2 |
3 | T = typing.TypeVar()
  |     ^^^^^^^^^^^^^^^^
  |
info: rule `invalid-legacy-type-variable` is enabled by default

Found 1 diagnostic
</code></pre>
<p>shouldn't the error message there be something like &quot;must pass a <code>name</code> parameter to <code>typing.TypeVar</code>&quot;? It sounds like it's complaining about the type of the first argument, but no arguments were passed</p>
<p>Similarly, I think it's totally fine if we don't want to support this (I don't think any other type checker does), but this isn't a <em>great</em> set of error messages here:</p>
<pre><code>error[invalid-legacy-type-variable]: The first argument to `typing.TypeVar` must be a string literal.
 --&gt; foo.py:3:5
  |
1 | from typing import TypeVar
2 |
3 | T = TypeVar(name=&quot;T&quot;)
  |     ^^^^^^^^^^^^^^^^^
  |
info: rule `invalid-legacy-type-variable` is enabled by default

error[invalid-legacy-type-variable]: Unknown keyword argument `name` in `typing.TypeVar` creation
 --&gt; foo.py:3:13
  |
1 | from typing import TypeVar
2 |
3 | T = TypeVar(name=&quot;T&quot;)
  |             ^^^^^^^^
  |
info: rule `invalid-legacy-type-variable` is enabled by default
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4203 on 2025-10-09 15:33</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let ast::Expr::Name(ast::ExprName { id, .. }) = target_name else {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4206 on 2025-10-09 15:33</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                &quot;A `typing.TypeVar` definition must be a simple variable assignment&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4268 on 2025-10-09 15:35</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        let ast::Expr::Call(ast::ExprCall { arguments, .. }) = value else {
            return;
        };
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4182 on 2025-10-09 15:49</div>
            <div class="timeline-body"><p>You're not calling <code>self.infer_expression()</code> on <code>kwarg.value</code> here, which then results in <code>Unknown</code> if you hover over <code>infer_variance</code> in the TypeVar call in the playground. This is a screenshot from a playground build on your branch:</p>
<p><img width="1184" height="298" alt="image" src="https://github.com/user-attachments/assets/b113b9a0-9ab2-4831-8eff-a951551d0cbb" /></p>
<pre><code class="language-suggestion">                    // TODO support `infer_variance` in legacy TypeVars
                    self.infer_expression(&amp;kwarg.value, TypeContext::default());
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4205 on 2025-10-09 15:50</div>
            <div class="timeline-body"><p>same here -- for an unknown keyword argument, you're never recursing into the value of the argument to infer the type at the moment</p>
<pre><code class="language-suggestion">                    );
                    self.infer_expression(&amp;kwarg.value, TypeContext::default());
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:6452 on 2025-10-09 15:51</div>
            <div class="timeline-body"><p>should this be</p>
<pre><code class="language-suggestion">                if matches!(class.known(self.db(), Some(KnownClass::TypeVar | KnownClass::ExtensionsTypeVar)) {
</code></pre>
<p>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-10-09 15:51</div>
            <div class="timeline-body"><p>üöÄ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/goto_type_definition.rs</code>:311 on 2025-10-09 16:22</div>
            <div class="timeline-body"><p>I don't think it will be hard to remember, because I have to fix it in order to fix the cases in https://github.com/astral-sh/ty/issues/256 related to <code>TypeAliasType</code>. So in that sense we already have an issue that ensures we won't forget it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/goto_type_definition.rs</code>:311 on 2025-10-09 16:23</div>
            <div class="timeline-body"><p>(And I plan to do this PR next.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/classes.md</code>:3 on 2025-10-09 16:26</div>
            <div class="timeline-body"><blockquote>
<p>we should really permit users to pass <code>default=whatever</code> even on lower Python versions if the user is making use of <code>typing_extensions.TypeVar</code></p>
</blockquote>
<p>This PR already does that (and has tests for it, in another file below).</p>
<p>The thing this PR doesn't do is allow you to access the <code>__default__</code> attribute on the resulting typevar created via <code>typing_extensions.TypeVar</code>, because we don't yet track how a given TypeVar was originally created.</p>
<p>The change here is because some tests in this file import <code>typing.TypeVar</code>, not <code>typing_extensions.TypeVar</code>. Would you rather I change them all to import from <code>typing_extensions</code>, instead of changing the Python version for this file?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:42 on 2025-10-09 16:30</div>
            <div class="timeline-body"><p>It seemed like an odd thing to test in this file, because it includes this diagnostic &quot;function call not allowed in type expression&quot;, which is arguably the more basic/important error in this case, and is not an error related to TypeVars at all. So I replaced the test with a mostly-equivalent version that only tests the (same) TypeVar-related diagnostic, without the distraction of the unrelated diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:74 on 2025-10-09 16:32</div>
            <div class="timeline-body"><p>I think I got rid of the error message with the intent to snapshot-diagnostics instead, but then decided against that because these tests make too much use of <code>reveal_type</code>, which clutters diagnostic snapshots horribly.</p>
<p>I can put the error message back, but it feels odd/arbitrary to inconsistently have one or two error messages tested and the majority not, for no particular reason.</p>
<p>I could consistently add error messages everywhere, but in general I prefer not doing that, because they are painful to update when error messages change. I'd rather use snapshot-diagnostics for testing the content of diagnostic messages.</p>
<p>I can add a dedicated set of snapshot-diagnostics tests for all the cases tested here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:105 on 2025-10-09 16:35</div>
            <div class="timeline-body"><p>Yes, it was a combination of &quot;easier to implement without it&quot;, &quot;no other type checker supports it&quot;, and &quot;given the other restrictions on TypeVar argument values, it seems unlikely there's a compelling use case for this.&quot;</p>
<p>If we ever run into a compelling use case, it wouldn't actually be <em>that</em> hard to add support for it later. But doesn't seem worth it right now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:158 on 2025-10-09 16:36</div>
            <div class="timeline-body"><p>Huh, weird! Good catch :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:265 on 2025-10-09 16:41</div>
            <div class="timeline-body"><p>Yes, the fact that other type checkers allow this is what convinced me we should too. And to be honest, I think other type checkers are right to allow it; there's really only upside. The point of a type checker is to catch things that will error at runtime. A TypeVar definition in a stub file that uses more recent features will not error at runtime. So what's the point of being pedantic about making users use <code>typing_extensions.TypeVar</code> in a stub file?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:265 on 2025-10-09 16:41</div>
            <div class="timeline-body"><p>I can extend the prose here a bit, but I'm inclined to actually make the case for the feature, not just say &quot;other type checkers do it, so we also do it for compatibility.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:316 on 2025-10-09 16:45</div>
            <div class="timeline-body"><p>Note that we (correctly) don't error on the TypeVar creation here. The only part of this test that is a TODO is accessing the <code>__default__</code> attribute afterwards.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:404 on 2025-10-09 16:54</div>
            <div class="timeline-body"><blockquote>
<p>hrm... on line 351 you said that they <em>cannot</em> be cyclic, but here you say that they <em>can</em> &quot;cyclically&quot; refer back to their own type?</p>
</blockquote>
<p>I said they &quot;cannot be generic, cyclic or otherwise&quot;, which does not say they can't be cyclic.</p>
<p>The bound here is not generic, because <code>list[G]</code> is a fully specialized type (as you point out below), so the above statement doesn't apply here.</p>
<blockquote>
<p>Though FWIW I think it's debatable whether this example really counts as a cycle. <code>G</code> as it appears in the bound of <code>list[G]</code> here is syntactic sugar for the default specialization of <code>G</code>, which is <code>G[Unknown]</code> -- so this type variable's upper bound is <code>list[G[Unknown]]</code>, which is not a type that refers back to <code>T</code> in any way since <code>T</code> has been fully &quot;specialized away&quot; from the type.</p>
</blockquote>
<p>It counts as a cycle in the way that's IMO most relevant, which is that it causes a divergent Salsa query cycle and panics on current main branch :) The cycle occurs because when specializing <code>G</code>, we have to compare the specialization type against the upper bound of the typevar of <code>G</code>, which means we have to evaluate <code>G</code>, which is <code>G[Unknown]</code>, which means we have to specialize <code>G</code>... and we are in a cycle.</p>
<p>I think there might be an alternative fix for this specific cycle, where we special-case &quot;unknown specialization&quot; and don't bother checking for assignability to the upper bound (since we know that <code>Unknown</code> will be assignable to it, whatever it is). But we don't bother with that in this PR, since the more general laziness fix handles it anyway. I might try it (separately) and see if it shows a meaningful performance benefit, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 16:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:462 on 2025-10-09 16:58</div>
            <div class="timeline-body"><p>Yes, it broke in an earlier version of the PR. This is the bug that is fixed with the new <code>TypeVarInstance::original</code> field and the new <code>is_identical_to</code> methods.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 17:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:1632 on 2025-10-09 17:02</div>
            <div class="timeline-body"><p>I did that in an earlier version of the PR, but doing it for attribute targets breaks our implicit instance attributes handling. I might be able to do it for subscript expressions? But I suspect they are not common enough to move the needle noticeably on performance. I can experiment with that separately, but there's no need to include it in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 17:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:1632 on 2025-10-09 17:19</div>
            <div class="timeline-body"><p>Interesting. And, yeah, definitely not a blocker!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 17:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/classes.md</code>:3 on 2025-10-09 17:23</div>
            <div class="timeline-body"><blockquote>
<p>Would you rather I change them all to import from <code>typing_extensions</code>, instead of changing the Python version for this file?</p>
</blockquote>
<p>Yeah, that does make more sense to me -- I think it's nice to try to avoid using version blocks like this where possible, or it makes it look a little like the feature is only available on newer versions of Python, and we'll emit an error on it on older versions.</p>
<p>It obviously doesn't matter a huge amount, but it made me raise my eyebrow when reading through the tests :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:74 on 2025-10-09 17:25</div>
            <div class="timeline-body"><blockquote>
<p>I could consistently add error messages everywhere, but in general I prefer not doing that, because they are painful to update when error messages change. I'd rather use snapshot-diagnostics for testing the content of diagnostic messages.</p>
<p>I can add a dedicated set of snapshot-diagnostics tests for all the cases tested here?</p>
</blockquote>
<p>That's fair. Adding a dedicated set of snapshot-diagnostics tests sounds like a good solution!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 17:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 17:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:265 on 2025-10-09 17:37</div>
            <div class="timeline-body"><p>Meh. Yeah, it's useful, sure, but so would a number of other ad-hoc special cases that you <em>could</em> apply to stubs if you wanted to. I feel like there's also a strong case to say that &quot;stubs should mostly work the same way as runtime files, except for a narrow series of exceptions&quot;, and I'm not sure that this exception is really useful <em>enough</em>. There's also a strong benefit in keeping special cases to a minimum -- it reduces the cognitive overhead of understanding stub files. And <code>typing_extensions</code> is always available as an import in stub files, even if you don't depend on it, because typeshed pretends it's part of the stdlib, so I'm just really not sure it brings much benefit.</p>
<p>To me it feels kinda confusing that we'd complain about <code>typing.TypeVar(infer_variance=True)</code> in a <code>.py</code> file on Python &lt;3.12 but not in a stub file. I'm not suggesting we change the behaviour, given that compatibility with other type checkers is important, but it's not a special case I'd introduce if I were starting from a blank slate, personally</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-09 17:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:404 on 2025-10-09 17:38</div>
            <div class="timeline-body"><blockquote>
<p>I said they &quot;cannot be generic, cyclic or otherwise&quot;, which does not say they can't be cyclic.</p>
</blockquote>
<p>oh, sorry. I misread that as being &quot;three separate things that they cannot be&quot; rather than &quot;one thing that they cannot be, which has two subcategories&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 18:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:6452 on 2025-10-09 18:53</div>
            <div class="timeline-body"><p>Yes, thanks! I'll also add a test for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 19:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4201 on 2025-10-09 19:42</div>
            <div class="timeline-body"><p>I improved the error message for the first case.</p>
<p>I checked the second case; mypy does not support it, but pyright and pyrefly both do. It's not hard to support, so I will go ahead and add support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:74 on 2025-10-09 19:42</div>
            <div class="timeline-body"><p>Done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 19:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/diagnostics/legacy_typevars.md</code>:100 on 2025-10-09 20:17</div>
            <div class="timeline-body"><p>The same applies for <code>infer_variance=True</code>... Though we can defer adding that check until we add full support for that keyword, I suppose</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-10-09 20:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 20:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/diagnostics/legacy_typevars.md</code>:100 on 2025-10-09 20:58</div>
            <div class="timeline-body"><p>I went ahead and added this check for consistency.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-10-09 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-10-09 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-10-09 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:1632 on 2025-10-09 22:59</div>
            <div class="timeline-body"><p>Testing the impact of this at https://github.com/astral-sh/ruff/pull/20795</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 22:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 23:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/legacy/variables.md</code>:404 on 2025-10-09 23:15</div>
            <div class="timeline-body"><blockquote>
<p>The cycle occurs because when specializing <code>G</code>, we have to compare the specialization type against the upper bound of the typevar of <code>G</code>, which means we have to evaluate <code>G</code>, which is <code>G[Unknown]</code>, which means we have to specialize <code>G</code>... and we are in a cycle.</p>
</blockquote>
<p>This was not actually an accurate summary of why there was a cycle here, before this PR. The correct description is this: as part of inferring the type of the symbol <code>T</code>, we had to eagerly infer the type of its upper bound, which required knowing the type of <code>G</code>, and since <code>G</code> is generic over <code>T</code>, that requires knowing the type of <code>T</code>, and right there we have a cycle.</p>
<p>I think this is reasonably described as a cycle between the definitions of <code>T</code> and <code>G</code>.</p>
<p>The &quot;alternative fix&quot; I described above is not actually an alternative at all -- we still need the lazy bounds to even get to the point of having independently-inferrable types for <code>T</code> and <code>G</code>. And it's not an optimization, either, because we actually already do this -- we don't check against upper bounds when applying an unknown or default specialization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-09 23:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:1632 on 2025-10-09 23:17</div>
            <div class="timeline-body"><p>As I'd suspected, the impact does not appear to be detectable in either memory usage or CPU. Given that I think it makes the invariants slightly harder to understand, and requires changing a use of <code>infer_standalone_expression</code> to <code>infer_maybe_standalone_expression</code>, I'm going to close that PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-09 23:19</div>
            <div class="timeline-body"><p>Thanks @AlexWaygood for the excellent review here!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:34:59 UTC
    </footer>
</body>
</html>
