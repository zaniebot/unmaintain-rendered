<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Initial tests for instance attributes - astral-sh/ruff #15474</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Initial tests for instance attributes</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15474">#15474</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-01-14 11:13
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Adds some initial tests for class and instance attributes, mostly to document (and discuss) what we want to support eventually. <strong>These tests are not exhaustive yet</strong>. The idea is to specify the coarse-grained behavior first.</p>
<p>Things that we'll eventually want to test:</p>
<ul>
<li>Interplay with inheritance</li>
<li>Support <code>Final</code> in addition to <code>ClassVar</code></li>
<li>Specific tests for <code>ClassVar</code>, like making sure that we support things like <code>x: Annotated[ClassVar[int], &quot;metadata&quot;]</code></li>
<li>â€¦ or making sure that we raise an error here:<pre><code class="language-py">class Foo:
    def __init__(self):
        self.x: ClassVar[str] = &quot;x&quot;
</code></pre>
</li>
<li>Add tests for <code>__new__</code> in addition to the tests for <code>__init__</code></li>
<li>Add tests that show that we use the union of types if multiple methods define the symbol with different types</li>
<li>Make sure that diagnostics are raised if, e.g., the inferred type of an assignment within a method does not match the declared type in the class body.</li>
<li>https://github.com/astral-sh/ruff/pull/15474#discussion_r1916556284</li>
<li>Method calls are completely left out for now.</li>
<li>Same for <code>@property</code></li>
<li>â€¦ and the descriptor protocol</li>
</ul>
<h2>Test Plan</h2>
<p>New Markdown tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-01-14 11:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-14 11:19</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">testing</span> added by @sharkdp on 2025-01-15 12:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2025-01-15 12:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-01-15 12:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-01-15 12:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-01-15 12:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 12:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/unsupported_type_qualifiers.md</code>:9 on 2025-01-15 12:23</div>
            <div class="timeline-body"><p>I removed <code>ClassVar</code> as &quot;unsupported&quot; here, but left the <code>invalid-base</code> test below, as it does not have an analog yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 12:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:5350 on 2025-01-15 12:24</div>
            <div class="timeline-body"><p>This is obviously not the full <code>ClassVar</code> support, but it seems reasonable to already do the trivial type-inference part of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:24 on 2025-01-15 12:24</div>
            <div class="timeline-body"><p>For completeness, maybe you could also have an <code>__init__</code> instance variable that is explicitly declared on assignment and is bound to a value?</p>
<pre><code class="language-suggestion">        self.pure_instance_variable3: bytes
        self.pure_instance_variable4: bytes = b&quot;Declared and bound&quot;
</code></pre>
<p>I suppose it might also be good to have an instance attribute that's possible unbound as well, e.g.</p>
<pre><code class="language-py">class C:
    def __init__(self, flag: bool):
        if flag:
            self.x: str = &quot;oh no&quot;
</code></pre>
<p>Not sure if we should emit an error if a possibly unbound instance attribute is accessed on an instance -- I think probably not; my instinct is that this would have a large number of false positives.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:5350 on 2025-01-15 12:28</div>
            <div class="timeline-body"><p>Per @carljm's comment in my Notion doc, though, we might actually want to &quot;strip away&quot; the <code>ClassVar</code> part of this in <code>infer_annotation_expression</code>, so that it's actually not possible for us to get a <code>ClassVar</code> inside <code>infer_type_expression</code> and the &quot;lower&quot; methods from that (such as this one).</p>
<p>Having said that, I think you are correct that this change will reduce false positives in the short term, and probably doesn't do any harm right now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:11 on 2025-01-15 12:30</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Variables only defined in `__init__` are pure instance variables. They cannot be accessed on the
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:103 on 2025-01-15 12:32</div>
            <div class="timeline-body"><p>Not saying we shouldn't but this will require traversing the entire class body. This could be somewhat expensive (at least it's more expensive than only doing so for <code>__init__</code>).</p>
<ul>
<li>Does that include accesses inside of nested classes, functions or lambdas?</li>
<li>Does this include accesses where the variable isn't self</li>
</ul>
<pre><code class="language-py">class C:
	pure_instance_variable: str
	
	def test(self, other: Self, value: str):
		other.pure_instance_variable = value
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:42 on 2025-01-15 12:33</div>
            <div class="timeline-body"><pre><code class="language-suggestion"># TODO: this should be an error (pure instance variables cannot be overwritten on the class)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:66 on 2025-01-15 12:33</div>
            <div class="timeline-body"><pre><code class="language-suggestion"># TODO: should ideally be `Literal[&quot;value set on instance&quot;]`
# (due to earlier assignment of the attribute from the global scope)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:194 on 2025-01-15 12:34</div>
            <div class="timeline-body"><p>What's the expected behavior if a variable is used both in a <code>@classmethod</code> and a regular method?</p>
<pre><code class="language-py">class C:
	@classmethod
	def class_method(cls):
		cls.a = &quot;test&quot;

	def instance_method(self):
		self.a = &quot;test&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 12:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:173 on 2025-01-15 12:35</div>
            <div class="timeline-body"><p>Wording stolen from @AlexWaygood</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:186 on 2025-01-15 12:35</div>
            <div class="timeline-body"><p>Should this be an error because the documentation only mentions that <em>reading the value from the class body is also permitted</em>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-15 12:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:173 on 2025-01-15 12:36</div>
            <div class="timeline-body"><p>Though @carljm pointed out that the word &quot;binding&quot; here might be better than &quot;definition&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:64 on 2025-01-15 12:37</div>
            <div class="timeline-body"><p>I think the explicit declaration in the class body here makes it unambiguous that the public type (the type seen from other scopes) should be <code>str</code> rather than a <code>Literal</code> type</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:103 on 2025-01-15 12:41</div>
            <div class="timeline-body"><p>Mypy and pyright both support this, so I think we have to, expensive though it may be. Users will expect their type checker to support this and will complain if it doesn't. It's also unfortunately reasonably common in Python to do things like</p>
<pre><code class="language-py">class Foo:
    def __init__(self):
        self.initialize_x_variable()

    def initialize_x_variable(self):
        # many lines of complicated logic
        self.x = 42
</code></pre>
<blockquote>
<ul>
<li><p>Does that include accesses inside of nested classes, functions or lambdas?</p>
</li>
<li><p>Does this include accesses where the variable isn't self</p>
</li>
</ul>
</blockquote>
<p>I think we probably don't need to support these, certainly not initially</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:194 on 2025-01-15 12:42</div>
            <div class="timeline-body"><p>I think it would be reasonable in that case to complain about ambiguity if we're in strict mode, and demand an explicit annotation in the class body.</p>
<p>If strict mode is disabled, I guess we have to assume it's an instance variable with a class-level default?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-15 12:43</div>
            <div class="timeline-body"><p>not a full review yet, but gotta go for lunch!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:194 on 2025-01-15 12:51</div>
            <div class="timeline-body"><p>The current CLI proposal doesn't propose a strict mode. But it could be an off-by-default rule that warns about this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-15 12:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-15 12:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:103 on 2025-01-15 12:57</div>
            <div class="timeline-body"><p>We can also experiment with varying degrees of laziness here. For first-party code that we're actually checking, I think we'll probably need to know all instance attributes of every class. But for third-party/stdlib code that our first-party code is interacting with, it often probably isn't necessary to know what instance attributes the class has and, even if it is, it might not be necessary to materialize the <em>full set</em> of instance attributes the class has. For something like the following, we could plausibly short-circuit if we find the <code>foo</code> attribute defined in <code>__init__</code> or <code>__new__</code>, and not bother analyzing the other methods the <code>SomeClass</code> defines:</p>
<pre><code class="language-py">from third_party import SomeClass

x = SomeClass()
print(x.foo + 5)  # all we need to know here is whether `SomeClass` has a `foo` attribute
                  # and what its type is
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:110 on 2025-01-15 12:59</div>
            <div class="timeline-body"><p>&quot;cannot be accessed on instances&quot; isn't correct -- they can be <em>read</em> on instances but not <em>written to</em> on instances; they can only be <em>written to</em> on the class</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:118 on 2025-01-15 13:01</div>
            <div class="timeline-body"><p>ahh... a test that actually passes already ðŸŽ‰ ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:148 on 2025-01-15 13:03</div>
            <div class="timeline-body"><p>you could also possibly include an example of a <code>ClassVar</code> attribute being overridden on a subclass with a consistent subtype, since this is one of the ways in which <code>ClassVar</code> class variables differ from <code>Final</code> class variables</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:151 on 2025-01-15 13:04</div>
            <div class="timeline-body"><p>(I vote for pyright's behaviour here, especially if we infer instance attributes even when they're assigned in non-<code>__init__</code>/<code>__new__</code> methods)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:169 on 2025-01-15 13:09</div>
            <div class="timeline-body"><p>I think this subheading is a bit confusing -- these aren't class variables at all; they're instance variables that just happen to have a default in the class body. Though it's a bit wordier, I'd go with</p>
<pre><code class="language-suggestion">### Instance variables with class-level default values
</code></pre>
<p>or</p>
<pre><code class="language-suggestion">### Instance variables with default values in the class body
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:186 on 2025-01-15 13:18</div>
            <div class="timeline-body"><p>For this specific example, I think so, yes. The <code>: str</code> annotation in the class body explicitly declares that this is an instance attribute rather than a class attribute, so it shouldn't be writable from the class, only from instances. The only way it should differ from &quot;pure&quot; instance variables is that it's readable from the class as well as from instances.</p>
<p>Where it gets muddier is if the variable is unannotated. What do we do for something like this?</p>
<pre><code class="language-py">class Foo:
    X = 42

Foo.X = 56
</code></pre>
<p>To a human who can see the whole code holistically (including how it's used from outside the class scope), it's pretty clear here that <code>Foo.X</code> is meant to be a class variable. But red-knot won't be able to see the uses of the variable from outside the class when it's doing its initial analysis of the set of instance and class attributes, and there's no annotation here to help us figure out whether this should be inferred as a class variable or an instance variable with a class-level default. Nor are there any uses of the variable in the class's classmethods or instance methods to help us out.</p>
<p>I don't have a great answer for this right now. Curious if anybody else has thoughts for how we could avoid false positives here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:179 on 2025-01-15 13:19</div>
            <div class="timeline-body"><p>same as my comment above about the subheading, I think calling this variable <code>regular_class_variable</code> is somewhat confusing, as this category really has more in common with &quot;pure&quot; instance variables than with pure class variables</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-15 13:25</div>
            <div class="timeline-body"><p>Great, this is fantastic! Good call on leaving out <code>Final</code> for now.</p>
<p>Two notable things that you haven't covered are that we need to infer an instance variable for any declaration in the class body, even if there is no binding for the variable in any method at all. We could have a disabled-by-default rule that warns if you try to access the variable when it's not bound in any method, but pyright's experience with such a rule has been very mixed; it's hard to get it right without lots of false positives:</p>
<pre><code class="language-py">class Foo:
    x: int
</code></pre>
<p>and we need to infer an instance variable for a variable that is defined in a non-<code>__init__</code> variable but <em>not</em> declared in a class body:</p>
<pre><code class="language-py">class Foo:
    def __init__(self):
        self.initialize_x()

    def initialize_x(self):
        self.x = 42  # TODO: should the attribute have `Unknown`, `int`, `Literal[42]` or `Unknown | Literal[42]`
                     # from the perspective of code from other scopes?
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 14:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:169 on 2025-01-15 14:01</div>
            <div class="timeline-body"><p>&quot;Regular class variable&quot; is the term used in pyright's docu. I'm okay with deviating from that. I agree that it's slightly confusing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:29 on 2025-01-15 14:03</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        # possibly undeclared/unbound
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 14:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:194 on 2025-01-15 14:04</div>
            <div class="timeline-body"><blockquote>
<p>What's the expected behavior if a variable is used both in a <code>@classmethod</code> and a regular method?</p>
</blockquote>
<p>I'll leave this test case out for now, but I added a note in the PR description (which will eventually serve as a TODO list for me)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 14:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:186 on 2025-01-15 14:07</div>
            <div class="timeline-body"><blockquote>
<p>Should this be an error because the documentation only mentions that <em>reading the value from the class body is also permitted</em>?</p>
</blockquote>
<p>Yes. I removed this method for now. I think the behavior should be the same as from outside the class, so this should be an error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:148 on 2025-01-15 14:07</div>
            <div class="timeline-body"><p>one more case that might be worth adding is the case where a variable is annotated with &quot;bare&quot; <code>ClassVar</code> -- here we know that it's a pure class variable, but we still have to infer the type!</p>
<pre><code class="language-py">class Foo:
    X: ClassVar = 42  # `int`, `Unknown`, `Literal[42]`, or `Unknown | Literal[42]`?
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:131 on 2025-01-15 14:08</div>
            <div class="timeline-body"><pre><code class="language-suggestion">cannot be overwritten on instances, but can be read from instances.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:487 on 2025-01-15 14:12</div>
            <div class="timeline-body"><p>is it also worth linking to https://typing.readthedocs.io/en/latest/spec/class-compat.html here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-15 14:14</div>
            <div class="timeline-body"><p>Looks great -- though I'd still personally add the cases I mentioned in https://github.com/astral-sh/ruff/pull/15474#pullrequestreview-2552685457 prior to landing</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-15 14:20</div>
            <div class="timeline-body"><p>Depending on how exhaustive you're looking to be for <code>ClassVar</code> tests here, you could also consider adding this test, on which we should emit a diagnostic:</p>
<pre><code class="language-py">class Foo:
    def __init__(self):
        self.x: ClassVar[str] = &quot;x&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:493 on 2025-01-15 14:26</div>
            <div class="timeline-body"><p>nit: this actually links to the spec (docs for folks writing type checkers -- that's us!) rather than docs that are meant to be user-facing. (I think that's the correct page for us to link to here but &quot;typing documentation on <code>classvar</code>&quot; is maybe a slightly confusing way to describe the page?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-15 14:26</div>
            <div class="timeline-body"><blockquote>
<p>though I'd still personally add the cases I mentioned in <a href="https://github.com/astral-sh/ruff/pull/15474#pullrequestreview-2552685457">#15474 (review)</a> prior to landing</p>
</blockquote>
<p>I was planning to, you are too fast Alex :smile:. I think those should be covered now. I actually changed a previous test to cover the &quot;not declared in body, only bound in non-<code>__init__</code> method&quot; case (by removing the declaration from the body). This should only make the test more general, I think. But again, I am planning to increase the overall test coverage eventually. This is mostly to get the initial design right. Thank you for the detailed review and your help!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-15 14:27</div>
            <div class="timeline-body"><blockquote>
<p>Depending on how exhaustive you're looking to be for <code>ClassVar</code> tests here, you could also consider adding this test</p>
</blockquote>
<p>I'll add it to the list in the PR description.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:166 on 2025-01-15 14:28</div>
            <div class="timeline-body"><p>(valid answers could also include <code>int</code>, <code>Unknown</code>, <code>Unknown | Literal[1]</code> and <code>Unknown | int</code>...)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:108 on 2025-01-15 14:31</div>
            <div class="timeline-body"><p>nit: I'd either remove the annotation, or also add an example without an annotation, because otherwise I think this could be seen to imply that we intend to only infer the instance attribute on non-<code>__init__</code>-method assignments if the attribute is declared as well as bound in the non-<code>__init__</code>-method</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-15 14:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-15 14:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:493 on 2025-01-15 14:36</div>
            <div class="timeline-body"><p>Ahrg, I had &quot;typing spec on â€¦&quot; first, then changed it to documentation after I saw the title of the page. Changing back. The <code>classvar</code> thing is done by mdformat. I actually wrote <code>ClassVar</code>, but that get's lowercased.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-01-15 14:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-01-15 14:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-15 14:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:35 on 2025-01-15 17:10</div>
            <div class="timeline-body"><p>This is an interesting question. Both pyright and mypy have heuristics to widen literal types when they think it's &quot;probably more useful.&quot; This seems a bit unprincipled to me, but I'm open to the possibility that we'll also need to do it. I guess my question is, if the only assignment to <code>self.pure_instance_variable1</code> that occurs anywhere in the class is <code>self.pure_instance_variable1 = &quot;value set in __init__&quot;</code>, then why <em>wouldn't</em> you want it typed as <code>Literal[&quot;value set in __init__&quot;]</code>? Just to accommodate external code setting it to some other value? That seems like an edge case, and not too much to ask you to add an explicit <code>: str</code> if that's what you wanted.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:52 on 2025-01-15 17:11</div>
            <div class="timeline-body"><p>Depending on how we answer the above question, arguably this should be an error</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:68 on 2025-01-15 17:14</div>
            <div class="timeline-body"><p>I think there is some question about the extent to which we'll want to do this narrowing. It's unsound in general (because we can't really say with any certainty what happens to <code>c_instance</code> between that assignment and this check), and particularly likely to be unsound in global scope. But we'll probably need to do some of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:113 on 2025-01-15 17:19</div>
            <div class="timeline-body"><p>Probably the even more realistic example would have this method called from <code>__init__</code>, but if we do that in the test it raises more questions about whether we're trying to detect that call...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-15 17:22</div>
            <div class="timeline-body"><p>Nice!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-15 17:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:35 on 2025-01-15 17:34</div>
            <div class="timeline-body"><blockquote>
<p>if the only assignment to <code>self.pure_instance_variable1</code> that occurs anywhere in the class is <code>self.pure_instance_variable1 = &quot;value set in __init__&quot;</code>, then why <em>wouldn't</em> you want it typed as <code>Literal[&quot;value set in __init__&quot;]</code>? Just to accommodate external code setting it to some other value?</p>
</blockquote>
<p>Subclasses also won't be able to assign a type to the attribute unless the type is assignable to the <code>Literal[...]</code> type</p>
<blockquote>
<p>That seems like an edge case</p>
</blockquote>
<p>Hmm, I don't agree. I think it's quite common for code to only assign an instance variable in the <code>__init__</code> method of the class, but with the intention that it should be possible to reassign the attribute from other scopes.</p>
<blockquote>
<p>and not too much to ask you to add an explicit <code>: str</code> if that's what you wanted.</p>
</blockquote>
<p>Surely that violates the gradual guarantee? And this doesn't seem to tackle at all the problem of typed code interacting with untyped third-party code, which may be unwilling to add type annotations in a timely manner?</p>
<p>I'm leaning towards either <code>Unknown | Literal[...]</code> or <code>Unknown | str</code> for cases like these. Haven't made my mind up about which is preferable there (haven't thought too deeply about it yet!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-15 17:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:68 on 2025-01-15 17:37</div>
            <div class="timeline-body"><p>We've had this conversation several times now ðŸ˜† I still favour the more pragmatic behaviour of mypy and pyright over the stricter behaviour of pyre here. But yeah, we can debate the details at a later stage</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-15 17:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:35 on 2025-01-15 17:39</div>
            <div class="timeline-body"><blockquote>
<p>Surely that violates the gradual guarantee</p>
</blockquote>
<p>Yes, but so does widening the literal type to <code>str</code>. That's what I mean by &quot;unprincipled&quot; -- it doesn't fundamentally change anything, just arbitrarily chooses some wider type because we think it's &quot;probably what you meant.&quot;</p>
<p>I like the idea of a union with <code>Unknown</code> for inferred attribute types! I think that is the principled gradual-guarantee approach here. It will be more forgiving than what people are used to, but I generally like it if we take the gradual guarantee more seriously than existing type checkers: if you want more strictness, annotate.</p>
<p>(I don't see why we would special-case converting it to <code>Unknown | str</code> instead of <code>Unknown | Literal[...]</code> if we're unioning with <code>Unknown</code> -- I think the union already takes care of the problematic aspects of the literal inference, by allowing you to assign anything.)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:09:08 UTC
    </footer>
</body>
</html>
