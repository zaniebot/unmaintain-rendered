<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>add support for formatting reStructuredText code snippets - astral-sh/ruff #9003</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>add support for formatting reStructuredText code snippets</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/9003">#9003</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2023-12-05 00:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-12-05 00:11</div>
            <div class="timeline-body"><p>(This is not possible to actually use until https://github.com/astral-sh/ruff/pull/8854 is merged.)</p>
<p>ruff_python_formatter: add reStructuredText docstring formatting support</p>
<p>This commit makes use of the refactoring done in prior commits to slot
in reStructuredText support. Essentially, we add a new type of code
example and look for <em>both</em> literal blocks and code block directives.
Literal blocks are treated as Python by default because it seems to be a
<a href="https://github.com/adamchainz/blacken-docs/issues/195">common practice</a>.</p>
<p>That is, literal blocks like this:</p>
<pre><code>def example():
    &quot;&quot;&quot;
    Here's an example::

        foo( 1 )

    All done.
    &quot;&quot;&quot;
    pass
</code></pre>
<p>Will get reformatted. And code blocks (via reStructuredText directives)
will also get reformatted:</p>
<pre><code>def example():
    &quot;&quot;&quot;
    Here's an example:

    .. code-block:: python

        foo( 1 )

    All done.
    &quot;&quot;&quot;
    pass
</code></pre>
<p>When looking for a code block, it is possible for it to become invalid.
In which case, we back out of looking for a code example and print the
lines out as they are. As with doctest formatting, if reformatting the
code would result in invalid Python or if the code collected from the
block is invalid, then formatting is also skipped.</p>
<p>A number of tests have been added to check both the formatting and
resetting behavior. Mixed indentation is also tested a fair bit, since
one of my initial attempts at dealing with mixed indentation ended up
not working.</p>
<p>I recommend working through this PR commit-by-commit. There is in
particular a somewhat gnarly refactoring before reST support is added.</p>
<p>Closes #8859</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">docstring</span> added by @BurntSushi on 2023-12-05 00:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by @BurntSushi on 2023-12-05 00:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @BurntSushi on 2023-12-05 00:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @charliermarsh by @BurntSushi on 2023-12-05 00:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Formatter: Stable" by @BurntSushi on 2023-12-05 00:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-12-05 00:24</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples.py</code>:523 on 2023-12-05 03:04</div>
            <div class="timeline-body"><p>Interesting. We'll need to consider this when deciding on how to format docstrings when using <code>indent_style = 'tab'</code>. See https://github.com/astral-sh/ruff/issues/8430</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:625 on 2023-12-05 03:14</div>
            <div class="timeline-body"><p>The comment here now seems outdated considering that the function no longer returns an action.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples.py</code>:348 on 2023-12-05 03:16</div>
            <div class="timeline-body"><p>I may have missed it, but in case there's no such test. Could we add a test that tests mixing restructured text and markdown exmaples in a single docstring? Including when we have an unclosed markdown test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:676 on 2023-12-05 03:17</div>
            <div class="timeline-body"><p>The documentation needs updating, considering that the function no longer returns the unchanged line.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:685 on 2023-12-05 03:20</div>
            <div class="timeline-body"><p>Does this mean that we'll push to the <code>VecDeque</code> even in case where the docstring contains no code exampels? I would be interested in understanding the performance implication of allocating here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:316 on 2023-12-05 03:21</div>
            <div class="timeline-body"><p>Do you mean <code>queue</code> here?</p>
<pre><code class="language-suggestion">                        // of the queue to get processed before any other action.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:467 on 2023-12-05 03:26</div>
            <div class="timeline-body"><p>I would be interested in your opinion on https://github.com/astral-sh/ruff/issues/8430 after dealing with tab/space indentation in code examples.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:834 on 2023-12-05 03:31</div>
            <div class="timeline-body"><p>Nit: I believe we use newlines between fields for most of our code base but I'm okay leaving it as is, considering that this isn't enforced by a formatter. Is it your preference to omit new lines between fields (I also noticed that you omit newlines between control flow blocks).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:875 on 2023-12-05 03:33</div>
            <div class="timeline-body"><p>What's the unit in which the <code>indent</code> is measured? Is it the byte length of the indentation string, meaning that <code>\t</code> and <code> </code> space both count as one?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:899 on 2023-12-05 03:34</div>
            <div class="timeline-body"><p>This sentence seems incomplete</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:956 on 2023-12-05 03:36</div>
            <div class="timeline-body"><p>If I remember correctly, the Regex multithreading performance cost has been mitigated, right?</p>
<p>We could otherwise use our <code>Cursor</code> implementation for parsing out the string. Although skipping the whitespace could be somewhat annoying</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:959 on 2023-12-05 03:38</div>
            <div class="timeline-body"><p>I find it unexpected that a function called <code>code</code> mutates the lines. It may take me a while to figure out where <code>self.lines</code> gets changed due to it. Could we trim the lines already when adding it or is this not possible because we don't know the <code>min_indent</code> yet?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:1002 on 2023-12-05 03:40</div>
            <div class="timeline-body"><p>What happens with empty lines at the end of a docstring (with a unclosed example above). Does it get trimmed by the formatter?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:1302 on 2023-12-05 03:46</div>
            <div class="timeline-body"><p>Python only supports <code>\t</code> and <code> </code> (space) as valid indentation characters (and <code>\f</code> form feeds that reset the indentation). It's unclear to me if supporting all white space is okay because we're inside a docstring or should limit it to Python-whitespace only (the same applies for <code>indent_with_suffix</code>, we have <code>trim_whitespace_start</code> helper to do so)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:1263 on 2023-12-05 03:49</div>
            <div class="timeline-body"><p>Nit: I had to think about whether assigning to <code>line</code> here is/should impact the <code>line.chars()</code> call at the top of the loop. It does not, but I would find it easier to understand if we assign the trimmed result to a new variable instead of mutating <code>line</code> in place (by adding a <code>let mut trimmed = line</code> at the top)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-12-05 03:54</div>
            <div class="timeline-body"><p>Nice work.</p>
<p>My only concern is that I find it difficult to assess how the changes introducing the action queue impact performance.</p>
<p>I think we can get a good answer to this by simply enabling docstring formatting for our benchmarks until we find the time to add dedicated docstring tests. This gives us at least an idea on how expensive the feature is for docstring not containing code examples.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-05 03:55</div>
            <div class="timeline-body"><p>@zanieb should we remove the formatter label from the PR, considering that the functionality isn't available yet or will we remove the changelog entry manually?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-05 03:59</div>
            <div class="timeline-body"><p>@MichaReiser - We clean the changelogs manually, so no issue keeping the label on there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 13:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples.py</code>:523 on 2023-12-05 13:33</div>
            <div class="timeline-body"><p>Yeah there may be some reshuffling needed here.</p>
<p>We could also choose not to support reformatting code examples with mixed indentation. That might be simplify some things. Not quite sure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 13:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/resources/test/fixtures/ruff/docstring_code_examples.py</code>:348 on 2023-12-05 13:42</div>
            <div class="timeline-body"><p>We don't have Markdown support yet (that's next), but that's a good idea. I'll add those mixed tests when I add Markdown.</p>
<p>However, your suggestion prompted me to add tests that mix doctests and reStructuredText blocks. I think things work there how we'd want them to (doctests inside of literal blocks get skipped, but doctests inside of a <code>pycon</code> code block get formatted), but I could also see user feedback leading us to change it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:685 on 2023-12-05 14:04</div>
            <div class="timeline-body"><p>Yeah it will. Although it will push to the queue for every line, it should only allocate the first time. Even in the case where a code example is present, I don't expect the queue to ever grow beyond more than a couple elements, so the allocation should be amortized. But it's only amortized within each docstring.</p>
<p>It does indeed look like the happy path in the status quo does not allocate. I still perceive this to likely be a marginal cost, but I'll see about adding some benchmarks to this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:316 on 2023-12-05 14:09</div>
            <div class="timeline-body"><p>Yes. I'll swap it out with &quot;queue.&quot; I was using &quot;line&quot; as a synonym for &quot;queue&quot; hah. But it is quite confusable in this context. (And it may also be an American meaning? Not sure.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:467 on 2023-12-05 14:12</div>
            <div class="timeline-body"><p>Aye. I left a comment. To me it feels like one of the issues here is hard-coding tabwidth=8. So long as that's there, it will be tough for us to cleanly solve the problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:834 on 2023-12-05 14:18</div>
            <div class="timeline-body"><p>I do indeed omit empty lines between fields in type definitions. I think I've just perceived that to be the common style, but looking a bit, the standard library seems to use a wild mix haha.</p>
<p>As for control flow blocks, I have less of a consistent style there. I tend to use empty lines when logical groupings make sense. But that's just somewhat of a judgment call. Looking a bit, probably some empty lines would help in places. But no, my preference wouldn't be to always insert an empty line.</p>
<p>With that said, I like consistent styling, so I'll add some line breaks here and try to remember to do so in the future. But yeah, without the formatter doing this for us, it's bound to get out-of-whack.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:875 on 2023-12-05 14:48</div>
            <div class="timeline-body"><p>No, it's computed by <code>indentation_length</code>:</p>
<pre><code class="language-rust">/// For docstring indentation, black counts spaces as 1 and tabs by increasing the indentation up
/// to the next multiple of 8. This is effectively a port of
/// [`str.expandtabs`](https://docs.python.org/3/library/stdtypes.html#str.expandtabs),
/// which black [calls with the default tab width of 8](https://github.com/psf/black/blob/c36e468794f9256d5e922c399240d49782ba04f1/src/black/strings.py#L61).
fn indentation_length(line: &amp;str) -&gt; TextSize {
    let mut indentation = 0u32;
    for char in line.chars() {
        if char == '\t' {
            // Pad to the next multiple of tab_width
            indentation += 8 - (indentation.rem_euclid(8));
        } else if char.is_whitespace() {
            indentation += u32::from(char.text_len());
        } else {
            break;
        }
    }
    TextSize::new(indentation)
}
</code></pre>
<p>I added a clarifying comment to the docs here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:956 on 2023-12-05 14:51</div>
            <div class="timeline-body"><p>Mostly mitigated, yeah. And this only runs on lines that start with <code>.. </code>. So it should be very infrequently called.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 14:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:959 on 2023-12-05 14:56</div>
            <div class="timeline-body"><p>Correct. We don't know the <code>min_indent</code>.</p>
<p>I agree that the naming here is not ideal. I don't like it either. I would have liked to define an <code>into_code</code> that consumes <code>self</code> and spits back the code, but then you lose other parts of <code>self</code> that are needed to print the reformatted lines. I could also define a <code>take_code</code> instead that plucks the code out of an <code>&amp;mut self</code>, which might make the mutation a little less surprising, but then you're left with an empty code example whose other state is still useful. Which is weird. Another choice would be to add a new method, something like, <code>indent_lines</code> that does the mutation and then provide the <code>code</code> method as a simple accessor. I probably like that approach the best, but it means you can forget to run <code>indent_lines</code> and get a bug.</p>
<p>The benefit of this approach is that callers can't get it wrong, which is ultimately what I ended up favoring.</p>
<p>Still, the name isn't great. I changed it to <code>indented_code</code> and tweaked the docs a touch. Still not great, but maybe a little better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 16:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:1002 on 2023-12-05 16:20</div>
            <div class="timeline-body"><p>Nice test case. I added one:</p>
<pre><code class="language-python"># If a literal block is never properly ended (via a non-empty unindented line),
# then the end of the block should be the last non-empty line. And subsequent
# empty lines should be preserved as-is.
def rst_literal_extra_blanks_at_end():
    &quot;&quot;&quot;
    Do cool stuff::


        cool_stuff( 1 )



    &quot;&quot;&quot;
    pass
</code></pre>
<p>In this case, just the code snippet should get reformatted to <code>cool_stuff(1)</code>, but the empty lines are preserved as they are not part of the code snippet. The reST renderer I'm using seems to agree.</p>
<p>Ah, but I figured you were noticing something awry, so I revisited the logic with this prompt in mind and indeed, a bug has been found! Namely, in this code:</p>
<pre><code># A literal block can contain many empty lines and it should not end the block
# if it continues.
def rst_literal_extra_blanks_in_snippet():
    &quot;&quot;&quot;
    Do cool stuff::

        cool_stuff( 1 )


        cool_stuff( 2 )

    Done.
    &quot;&quot;&quot;
    pass
</code></pre>
<p><code>cool_stuff( 1 )</code> will get formatted, but <code>cool_stuff( 2 )</code> will not because the block is prematurely closed.</p>
<p>OK, fixed that while not regressing the first test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 16:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:1302 on 2023-12-05 16:30</div>
            <div class="timeline-body"><p>Hmmm. I see. I hadn't known about this or the <code>trim_whitespace_start</code> helper.</p>
<p>One possible issue I see here is that the docstring whitespace normalization uses just the bare <code>trim_start()</code> and <code>trim_end()</code> routines in places. Is that correct, or should those be switched to the Python specific definition too? Same deal with <code>indentation_length</code>. It uses <code>char::is_whitespace</code> from std, which covers all the Unicode forms of whitespace too.</p>
<p>In any case, I've updated my uses of whitespace to <code>trim_whitespace_start</code> and <code>is_python_whitespace</code>. (Probably that module should get re-tooled a bit. i.e., Add an extension trait for <code>char</code> and rename <code>trim_whitespace_start</code> and assorted methods to <code>trim_python_start</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ruff_python_formatter/src/expression/string/docstring.rs</code>:1263 on 2023-12-05 16:34</div>
            <div class="timeline-body"><p>Ah yeah you'd get a borrow checker error if it were otherwise. The key is that we're just re-binding a name.</p>
<p>In any case, I've added a new <code>trimmed</code> variable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-05 16:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-12-05 19:12</div>
            <div class="timeline-body"><p>In lieu of micro-benchmarks, I decided to do a little ad hoc benchmarking with hyperfine on <a href="https://github.com/dagster-io/dagster">dagster</a>.</p>
<p>Using this branch with a cherry-pick of #8854, I ran formatting with the default config and formatting with <code>format-code-in-docstrings</code> enabled:</p>
<pre><code>$ hyperfine \
    --warmup 3 \
    --prepare 'git reset --hard master' \
    --cleanup 'git reset --hard master' \
    'ruff format --config /tmp/emptyruff.toml ./' \
    'ruff format --config /tmp/ruff.toml ./'
Benchmark 1: ruff format --config /tmp/emptyruff.toml ./
  Time (mean ± σ):      84.4 ms ±   1.8 ms    [User: 1084.2 ms, System: 155.3 ms]
  Range (min … max):    80.8 ms …  88.2 ms    16 runs

Benchmark 2: ruff format --config /tmp/ruff.toml ./
  Time (mean ± σ):      85.1 ms ±   2.1 ms    [User: 1104.4 ms, System: 160.0 ms]
  Range (min … max):    82.1 ms …  89.5 ms    16 runs

Summary
  ruff format --config /tmp/emptyruff.toml ./ ran
    1.01 ± 0.03 times faster than ruff format --config /tmp/ruff.toml ./
</code></pre>
<p>Where:</p>
<pre><code>$ git remote -v
origin  git@github.com:dagster-io/dagster (fetch)
origin  git@github.com:dagster-io/dagster (push)

$ git rev-parse HEAD
dbb064c2ddda74265b8174edd9775e1302ca6ba0

$ cat /tmp/emptyruff.toml
$ cat /tmp/ruff.toml
[format]
format-code-in-docstrings = true
</code></pre>
<p>I ran it multiple times, and the same result occurred. So there is just a very slight observable slow-down here. But, this particular pile of code does have a large number of reStructuredText code blocks. So you'd expect it to possibly run a little more slowly since it is doing more work.</p>
<p>On a profile, I can see <code>run_action_queue</code>, but it is barely a blip. To be sure, I tweaked the top-level entry point for code snippet formatting to do this:</p>
<pre><code class="language-rust">if !self.code_example.kind.is_none()
    || CodeExampleDoctest::new(line).is_some()
    || CodeExampleRst::new(line).is_some()
{
    self.code_example.add(line, &amp;mut self.action_queue);
    self.run_action_queue()
} else {
    self.print_one(&amp;line.as_output())
}
</code></pre>
<p>So basically, as long as we weren't already collecting a code example and the current line didn't look like the start of one, then we could avoid the queue and just print the line directly. I then baked this off against what I had:</p>
<pre><code>$ hyperfine \
    --warmup 3 \
    --prepare 'git reset --hard master' \
    --cleanup 'git reset --hard master' \
    'ruff-rst-formatting-with-queue format --config /tmp/emptyruff.toml ./' \
    'ruff-rst-formatting-with-queue format --config /tmp/ruff.toml ./' \
    'ruff-rst-formatting-with-fast-path format --config /tmp/ruff.toml ./'
Benchmark 1: ruff-rst-formatting-with-queue format --config /tmp/emptyruff.toml ./
  Time (mean ± σ):      84.9 ms ±   2.2 ms    [User: 1077.6 ms, System: 163.4 ms]
  Range (min … max):    80.1 ms …  89.4 ms    17 runs

Benchmark 2: ruff-rst-formatting-with-queue format --config /tmp/ruff.toml ./
  Time (mean ± σ):      85.2 ms ±   2.5 ms    [User: 1119.1 ms, System: 148.7 ms]
  Range (min … max):    81.7 ms …  92.3 ms    17 runs

Benchmark 3: ruff-rst-formatting-with-fast-path format --config /tmp/ruff.toml ./
  Time (mean ± σ):      86.0 ms ±   2.2 ms    [User: 1098.4 ms, System: 163.7 ms]
  Range (min … max):    81.4 ms …  89.7 ms    16 runs

Summary
  ruff-rst-formatting-with-queue format --config /tmp/emptyruff.toml ./ ran
    1.00 ± 0.04 times faster than ruff-rst-formatting-with-queue format --config /tmp/ruff.toml ./
    1.01 ± 0.04 times faster than ruff-rst-formatting-with-fast-path format --config /tmp/ruff.toml ./
</code></pre>
<p>I ran this a few times and sometimes the fast path would be a hair faster and other times it would be flipped. Running <em>without</em> docstring formatting enabled at all was consistently faster by 1.00-1.01 times.</p>
<p>I think this satisfies me personally that the queue overhead is probably negligible, at least until we have some data suggesting otherwise. (I'm sure there are more synthetic benchmarks one could construct that might show a bigger difference.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-12-05 19:14</div>
            <div class="timeline-body"><p>Going to bring this, but @MichaReiser feel free to leave more feedback and I'll address it in a follow-up PR. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @BurntSushi on 2023-12-05 19:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @BurntSushi on 2023-12-05 19:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-12-05 19:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-05 23:34</div>
            <div class="timeline-body"><p>Thanks for running the manual benchmark. This looks good to me.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 02:13:24 UTC
    </footer>
</body>
</html>
