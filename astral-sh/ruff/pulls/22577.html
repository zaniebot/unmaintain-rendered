<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Build constraint set sequent maps lazily - astral-sh/ruff #22577</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Build constraint set sequent maps lazily</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22577">#22577</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2026-01-14 18:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>Before, when building a <code>SequentMap</code> for a constraint set, we would immediately iterate through all of the constraints in the set, and compare each pair of them looking for intersection/implication relationships. It turns out that we often don&#x27;t need to examine every pair when walking the BDD tree of a constraint set. Instead, we can visit each constraint as we encounter it for the first time in our BDD walk. We do still need to collect all of the constraints in the BDD to ensure that they remain ordered in a consistent way, but we can track that separately and without having to immediately build up the actual sequents.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-14 18:06</div>
            <div class="timeline-body">

<a href="https://github.com/python/typing/blob/dece44f2922ca390fe314145d09939514a21e76e/conformance/">Typing conformance results</a>
<p>No changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-14 18:07</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/build/wheel.py:99:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 47 diagnostics
+ Found 46 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Any, TVDtype@Index]`
+ static_frame/core/index.py:580:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@loc, TVDtype@Index]`, found `InterGetItemLocReduces[Any | Bottom[Series[Any, Any]], TVDtype@Index]`
- static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Unknown | Bottom[Series[Any, Any]], Any]`
+ static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Unknown, Any]`


</code></pre>



Memory usage changes were detected when running on open source projects

<pre><code>trio (https://github.com/python-trio/trio)
-     struct fields = ~11MB
+     struct fields = ~12MB


</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-14 18:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-14 18:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2026-01-14 18:26</div>
            <div class="timeline-body">

Merging this PR will <strong>improve performance by 5.14%</strong>
<p><code>⚡ 1</code> improved benchmark<br>
<code>✅ 22</code> untouched benchmarks<br>
<code>⏩ 30</code> skipped benchmarks[^skipped]</p>
Performance Changes
|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Efficiency |
| --- | ---- | --------- | ------ | ------ | ---------- |
| ⚡ | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Flazy-sequent-map?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Apydantic&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=benchmark"><code>pydantic</code></a> | 8 s | 7.6 s | +5.14% |
<p>Comparing <code>dcreager/lazy-sequent-map</code> (30edce9) with <code>main</code> (6a2cc89)</p>
<a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Flazy-sequent-map?utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=button">
  
    
    
    <img alt="Open in CodSpeed" src="https://codspeed.io/pr-report/open-in-codspeed-light.svg">
  
</a>

<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Flazy-sequent-map?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-15 14:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 14:19</div>
            <div class="timeline-body"><p>I think this is the same as setting <code>[no_eq]</code> on the query (salsa will not do any backdating, meaning all queries reading the <code>sequent_map</code> of a particular interior node will re-run even if it creates the exact same <code>SeqMap</code>. Are there any other fields that we could base <code>Eq</code> on (e.g., the ones that don&#x27;t change :)).</p>
<p>Looks very straightforward otherwise :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-15 14:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:73 on 2026-01-15 14:22</div>
            <div class="timeline-body"><p>We might need to use a parkinglot <code>Mutex</code> or have a way to not get stuck after Salsa cancelled a query by unwinding with  <code>Cancelled</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-15 14:29</div>
            <div class="timeline-body"><p>Cool to see that the internal mutability is good for performance :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-15 14:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 14:40</div>
            <div class="timeline-body"><p>I did confirm that this is equivalent to setting <code>#[no_eq]</code> on the query method. And if I do that, I can remove the <code>PartialEq</code> impl entirely.</p>
<p>But does that mean we would get a separate <code>SequentMap</code> each time we call the tracked query? My intent is that there will be one created for each interior node. (And the updated performance numbers suggests that&#x27;s what&#x27;s happening.) I&#x27;m okay with a <em>different</em> <code>SequentMap</code> being created for that interior node if it appears again in a later revision, since I think it&#x27;s correct to invalidate that cache then.</p>
<p>Although maybe we do want to reuse the cache in later revisions? The interior node should entirely determine the contents of the BDD, and walking the BDD later on should yield the same results. Okay I think you&#x27;ve convinced me. (Assuming I understand your suggestion correctly.) To do this I can add the <code>InteriorNode</code> as a field of <code>SequentMap</code>, to record which node the sequent map belongs to, and then have that be the only field that <code>PartialEq</code> checks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-15 15:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:73 on 2026-01-15 15:01</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-15 15:07</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
Formatter (stable)
<p>✅ ecosystem check detected no format changes.</p>
Formatter (preview)
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-15 15:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 15:09</div>
            <div class="timeline-body"><blockquote>
<p>But does that mean we would get a separate SequentMap each time we call the tracked query? My intent is that there will be one created for each interior node. (And the updated performance numbers suggests that&#x27;s what&#x27;s happening.) I&#x27;m okay with a different SequentMap being created for that interior node if it appears again in a later revision, since I think it&#x27;s correct to invalidate that cache then.</p>
</blockquote>
<p>No, you get the same instance within the same revision and the instance is cached for as long as no data read by the <code>::sequent_map()</code> query changes.</p>
<p>Taking <code>exported_names</code> as an example here because it&#x27;s easier to explain the concept. Salsa re-exeuctes the <code>exported_names</code> query every time the file&#x27;s AST changes. When Salsa&#x27;s done, it compares the result from running <code>exported_names</code> the last time with the newly computed result. If the two results are equal, then the query didn&#x27;t change (even though the AST changed). This allows Salsa to reuse the cached result for a query that only depends <code>exported_names</code> (or only depends on queries that all haven&#x27;t changed).</p>
<p>If you set <code>no_eq</code>, then you opt out of this optimization and Salsa will always assume that the result changed when any of the query&#x27;s inputs changed. Which is probably fine in your case.</p>
<p>The one thing we need to be careful is that the internal mutability code doesn&#x27;t access <code>db</code> because a query reading a cached result wouldn&#x27;t see all its dependencies, breaking Salsa&#x27;s cache invalidation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-15 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-15 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-15 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-15 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-15 15:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 15:34</div>
            <div class="timeline-body"><blockquote>
<p>The one thing we need to be careful is that the internal mutability code doesn&#x27;t access <code>db</code> because a query reading a cached result wouldn&#x27;t see all its dependencies, breaking Salsa&#x27;s cache invalidation.</p>
</blockquote>
<p>Is this part true in general? That might be a deal-breaker for this approach, because the interior mutability code will definitely need to access the <code>db</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-15 15:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 15:39</div>
            <div class="timeline-body"><blockquote>
<p>Is this part true in general? That might be a deal-breaker for this approach, because the interior mutability code will definitely need to access the db.</p>
</blockquote>
<p>It depends on what you read, but how salsa tracks dependencies is something I&#x27;d consider internal to Salsa (or at least requires a lot of documentation)</p>
<p>I don&#x27;t think we add read dependencies for interned structs, but we used to (CC: @ibraheemdev). But calling any salsa query, reading a tracked field of a tracked struct, or reading any input makes this approach unsound.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-15 15:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 15:43</div>
            <div class="timeline-body"><p>Creating any new interned values I think would be unsound.</p>
<p>I guess so is reading because reading an interned value with low durability <strong>must</strong> propagate to the outer query. So it&#x27;s not just about the dependencies, it&#x27;s also about the query&#x27;s metadata that need to be reflected accordingly</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-15 15:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 15:49</div>
            <div class="timeline-body"><p>Okay that tells me I need to rethink this...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2026-01-15 21:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-15 21:14</div>
            <div class="timeline-body"><p>Yeah, interior mutability will not play well with Salsa here. If the interior mutability code creates an interned value without the <code>sequent_map</code> query having a dependency on that interned value, the interned value may be garbage collected, and later calls to <code>sequent_map</code> will read stale data.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/carljm">@carljm</a> removed by <a href="https://github.com/carljm">@carljm</a> on 2026-01-16 00:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-17 19:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:3304 on 2026-01-17 19:12</div>
            <div class="timeline-body"><p>I found a different way to do this that keeps the performance win but doesn&#x27;t require interior mutability</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:2178 on 2026-01-19 08:31</div>
            <div class="timeline-body"><p>Nit: Maybe for a separate PR: Would it make sense to maybe use <code>SmallVec</code> here? (what&#x27;s a &quot;typcial&quot; size of `constraints?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:2219 on 2026-01-19 08:34</div>
            <div class="timeline-body"><p>The old <code>sequent_map</code> query had cycle handling, but not all queries calling <code>path_assignments</code> have. Was it only the <code>SequentMap::add</code> call that could result in cycles? If so, are there any queries where we need to add cycle handling, now that the cycle is no longer &quot;contained&quot; by the <code>sequent_map</code> query?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2026-01-19 08:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-19 08:39</div>
            <div class="timeline-body"><p>Nice. I don&#x27;t have a lot of context on the BDD work but the cachng makes sense to me. Probably something that would also benefit from within-same-revision LRU caching, to cap the memory usage (see prefect).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:2178 on 2026-01-20 21:01</div>
            <div class="timeline-body"><p>Good idea, done! (I don&#x27;t have specific numbers but it&#x27;s definitely true that most constraint sets will have a smallish number of constraints. I chose 8 more or less at random)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:2219 on 2026-01-20 21:08</div>
            <div class="timeline-body"><blockquote>
<p>Was it only the <code>SequentMap::add</code> call that could result in cycles?</p>
</blockquote>
<p>Yes, because of the subtype checks that we have to perform to compare the lower/upper bounds of each constraint. That could cause a cycle if we had to create a sequent map while we were in the middle of inferring the lower/upper bound type.</p>
<p>I was using the mdtests + ecosystem tests to verify that the cycle handler isn&#x27;t needed with this change. My intuition for why is that (a) the lazy processing delays the <code>add</code> calls enough that we&#x27;re no longer in the middle of inferring the types of the lower/upper bounds, and (b) we might not have to analyze certain constraints at all anymore, since we only look at a constraint once we actually encounter it when walking a BDD tree.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2026-01-20 21:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-20 21:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-20 21:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2026-01-20 21:15</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 21:56:37 UTC
    </footer>
</body>
</html>
