<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Add stub mapping support to signature help - astral-sh/ruff #19570</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Add stub mapping support to signature help</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19570">#19570</a>
        opened by <a href="https://github.com/UnboundVariable">@UnboundVariable</a>
        on 2025-07-26 18:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-26 18:02</div>
            <div class="timeline-body"><p>This PR improves the &quot;signature help&quot; language server feature in two ways:</p>
<ol>
<li>It adds support for the recently-introduced &quot;stub mapper&quot; which maps symbol declarations within stubs to their implementation counterparts. This allows the signature help to display docstrings from the original implementation.</li>
<li>It incorporates a more robust fix to a bug that was addressed in a <a href="https://github.com/astral-sh/ruff/pull/19542">previous PR</a>. It also adds more comprehensive tests to cover this case.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @UnboundVariable on 2025-07-26 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @UnboundVariable on 2025-07-26 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @UnboundVariable on 2025-07-26 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @UnboundVariable on 2025-07-26 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @UnboundVariable on 2025-07-26 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-26 18:06</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅
No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">server</span> added by @AlexWaygood on 2025-07-26 18:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-07-26 18:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/signature_help.rs</code>:103 on 2025-07-28 08:26</div>
            <div class="timeline-body"><p>What's the benefit of using a 1 byte offset? I think this is a bit dangerous as it might panic if anyone ends up using the passed range to take a peek at the source text (or calls any method on <code>tokens</code> where some methods enforce that the range falls directly at a token boundary).</p>
<p>It might be better to use the actual len of the character at <code>offset</code> over using an incorrect range.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-07-28 08:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> approved on 2025-07-28 09:17</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-28 15:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/signature_help.rs</code>:103 on 2025-07-28 15:46</div>
            <div class="timeline-body"><p>This is currently required to &quot;trick&quot; <code>covering_node</code> to not return the node to the left of the cursor position. Is there a reason why <code>covering_node</code> returns a node to the left of a zero-length range? Do other callers rely on this behavior? If not, perhaps the best fix here is to modify <code>covering_node</code> to not return the node to the left of a zero-length range?</p>
<p>Is there an existing function that retrieves the length of the character at <code>offset</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @UnboundVariable on 2025-07-28 17:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @UnboundVariable on 2025-07-28 17:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-28 17:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-28 19:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/signature_help.rs</code>:103 on 2025-07-28 19:43</div>
            <div class="timeline-body"><p>To get the size of a character at a given offset:</p>
<pre><code class="language-rust">a[offset..].chars().next().map(TextLen::text_len);
</code></pre>
<blockquote>
<p>Is there a reason why covering_node returns a node to the left of a zero-length range?</p>
</blockquote>
<p><code>covering_node</code> uses <code>contains</code> to test if two ranges overlap. Which I find the correct behavior in case we start with a range (in which case the nodes don't overlap).</p>
<p>The idea behind the API is that <code>covering_node</code> is very low level and unopinionated. It's also not the idea that it is used directly with an offset because there are cases where your offset falls directly between two nodes, in which case it requires some prioritization. The way we've implemented this in other LSP methods is by using <code>tokens.at</code></p>
<pre><code class="language-rust">let token = parsed
        .tokens()
        .at_offset(offset)
        .max_by_key(|token| match token.kind() {
            TokenKind::Name
            | TokenKind::String
            | TokenKind::Complex
            | TokenKind::Float
            | TokenKind::Int =&gt; 1,
            _ =&gt; 0,
        })?;
</code></pre>
<p>This allows the caller to customize which tokens should be preferred. I'm not sure what the heuristic should be for signature help. We can consider extracting the above logic from <code>find_goto_target</code> if it is the same or we can deploy our own here.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:58:39 UTC
    </footer>
</body>
</html>
