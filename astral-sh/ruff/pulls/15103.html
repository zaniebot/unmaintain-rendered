<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] `knot_extensions` Python API - astral-sh/ruff #15103</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] <code>knot_extensions</code> Python API</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15103">#15103</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-12-22 23:05
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Adds a type-check-time Python API that allows us to create and manipulate types and to test various of their properties. For example, this can be used to write a Markdown test to make sure that <code>A &amp; B</code> is a subtype of <code>A</code> and <code>B</code>, but not of an unrelated class <code>C</code> (something that requires quite a bit more code to do in Rust):</p>
<pre><code class="language-py">from knot_extensions import Intersection, is_subtype_of, static_assert

class A: ...
class B: ...

type AB = Intersection[A, B]

static_assert(is_subtype_of(AB, A))
static_assert(is_subtype_of(AB, B))

class C: ...
static_assert(not is_subtype_of(AB, C))
</code></pre>
<p>I think this functionality is also helpful for interactive debugging sessions, in order to query various properties of Red Knot's type system. Which is something that otherwise requires a custom Rust unit test, some boilerplate code and constant re-compilation.</p>
<h2>Comparison Rust â†” Python: <code>is_assignable_to</code> tests</h2>
<details>
  <summary>Rust</summary>

<pre><code class="language-rs">#[test_case(Ty::BuiltinInstance(&quot;str&quot;), Ty::BuiltinInstance(&quot;object&quot;))]
#[test_case(Ty::BuiltinInstance(&quot;int&quot;), Ty::BuiltinInstance(&quot;object&quot;))]
#[test_case(Ty::Unknown, Ty::IntLiteral(1))]
#[test_case(Ty::Any, Ty::IntLiteral(1))]
#[test_case(Ty::Never, Ty::IntLiteral(1))]
#[test_case(Ty::IntLiteral(1), Ty::Unknown)]
#[test_case(Ty::IntLiteral(1), Ty::Any)]
#[test_case(Ty::IntLiteral(1), Ty::BuiltinInstance(&quot;int&quot;))]
#[test_case(Ty::StringLiteral(&quot;foo&quot;), Ty::BuiltinInstance(&quot;str&quot;))]
#[test_case(Ty::StringLiteral(&quot;foo&quot;), Ty::LiteralString)]
#[test_case(Ty::LiteralString, Ty::BuiltinInstance(&quot;str&quot;))]
#[test_case(Ty::BytesLiteral(&quot;foo&quot;), Ty::BuiltinInstance(&quot;bytes&quot;))]
#[test_case(Ty::IntLiteral(1), Ty::Union(vec![Ty::BuiltinInstance(&quot;int&quot;), Ty::BuiltinInstance(&quot;str&quot;)]))]
#[test_case(Ty::IntLiteral(1), Ty::Union(vec![Ty::Unknown, Ty::BuiltinInstance(&quot;str&quot;)]))]
#[test_case(Ty::Union(vec![Ty::IntLiteral(1), Ty::IntLiteral(2)]), Ty::Union(vec![Ty::IntLiteral(1), Ty::IntLiteral(2)]))]
#[test_case(
    Ty::Union(vec![Ty::IntLiteral(1), Ty::IntLiteral(2)]),
    Ty::BuiltinInstance(&quot;int&quot;)
)]
#[test_case(
    Ty::Union(vec![Ty::IntLiteral(1), Ty::None]),
    Ty::Union(vec![Ty::BuiltinInstance(&quot;int&quot;), Ty::None])
)]
#[test_case(Ty::Tuple(vec![Ty::Todo]), Ty::Tuple(vec![Ty::IntLiteral(2)]))]
#[test_case(Ty::Tuple(vec![Ty::IntLiteral(2)]), Ty::Tuple(vec![Ty::Todo]))]
#[test_case(Ty::SubclassOfAny, Ty::SubclassOfAny)]
#[test_case(Ty::SubclassOfAny, Ty::SubclassOfBuiltinClass(&quot;object&quot;))]
#[test_case(Ty::SubclassOfAny, Ty::SubclassOfBuiltinClass(&quot;str&quot;))]
#[test_case(Ty::SubclassOfAny, Ty::BuiltinInstance(&quot;type&quot;))]
#[test_case(Ty::SubclassOfBuiltinClass(&quot;object&quot;), Ty::SubclassOfAny)]
#[test_case(
    Ty::SubclassOfBuiltinClass(&quot;object&quot;),
    Ty::SubclassOfBuiltinClass(&quot;object&quot;)
)]
#[test_case(Ty::SubclassOfBuiltinClass(&quot;object&quot;), Ty::BuiltinInstance(&quot;type&quot;))]
#[test_case(Ty::SubclassOfBuiltinClass(&quot;str&quot;), Ty::SubclassOfAny)]
#[test_case(
    Ty::SubclassOfBuiltinClass(&quot;str&quot;),
    Ty::SubclassOfBuiltinClass(&quot;object&quot;)
)]
#[test_case(Ty::SubclassOfBuiltinClass(&quot;str&quot;), Ty::SubclassOfBuiltinClass(&quot;str&quot;))]
#[test_case(Ty::SubclassOfBuiltinClass(&quot;str&quot;), Ty::BuiltinInstance(&quot;type&quot;))]
#[test_case(Ty::BuiltinInstance(&quot;type&quot;), Ty::SubclassOfAny)]
#[test_case(Ty::BuiltinInstance(&quot;type&quot;), Ty::SubclassOfBuiltinClass(&quot;object&quot;))]
#[test_case(Ty::BuiltinInstance(&quot;type&quot;), Ty::BuiltinInstance(&quot;type&quot;))]
#[test_case(Ty::BuiltinClassLiteral(&quot;str&quot;), Ty::SubclassOfAny)]
#[test_case(Ty::SubclassOfBuiltinClass(&quot;str&quot;), Ty::SubclassOfUnknown)]
#[test_case(Ty::SubclassOfUnknown, Ty::SubclassOfBuiltinClass(&quot;str&quot;))]
#[test_case(Ty::SubclassOfAny, Ty::AbcInstance(&quot;ABCMeta&quot;))]
#[test_case(Ty::SubclassOfUnknown, Ty::AbcInstance(&quot;ABCMeta&quot;))]
fn is_assignable_to(from: Ty, to: Ty) {
    let db = setup_db();
    assert!(from.into_type(&amp;db).is_assignable_to(&amp;db, to.into_type(&amp;db)));
}

#[test_case(Ty::BuiltinInstance(&quot;object&quot;), Ty::BuiltinInstance(&quot;int&quot;))]
#[test_case(Ty::IntLiteral(1), Ty::BuiltinInstance(&quot;str&quot;))]
#[test_case(Ty::BuiltinInstance(&quot;int&quot;), Ty::BuiltinInstance(&quot;str&quot;))]
#[test_case(Ty::BuiltinInstance(&quot;int&quot;), Ty::IntLiteral(1))]
#[test_case(
    Ty::Union(vec![Ty::IntLiteral(1), Ty::None]),
    Ty::BuiltinInstance(&quot;int&quot;)
)]
#[test_case(
    Ty::Union(vec![Ty::IntLiteral(1), Ty::None]),
    Ty::Union(vec![Ty::BuiltinInstance(&quot;str&quot;), Ty::None])
)]
#[test_case(
    Ty::SubclassOfBuiltinClass(&quot;object&quot;),
    Ty::SubclassOfBuiltinClass(&quot;str&quot;)
)]
#[test_case(Ty::BuiltinInstance(&quot;type&quot;), Ty::SubclassOfBuiltinClass(&quot;str&quot;))]
fn is_not_assignable_to(from: Ty, to: Ty) {
    let db = setup_db();
    assert!(!from.into_type(&amp;db).is_assignable_to(&amp;db, to.into_type(&amp;db)));
}
</code></pre>
</details>

<details>
  <summary>Python (grouped by topic instead of assignable/not-assignable)</summary>

<pre><code class="language-py">from knot_extensions import static_assert, is_assignable_to, Unknown, TypeOf
from typing_extensions import Never, Any, Literal, LiteralString
from abc import ABCMeta

static_assert(is_assignable_to(str, object))
static_assert(is_assignable_to(int, object))
static_assert(not is_assignable_to(object, int))
static_assert(not is_assignable_to(int, str))

static_assert(is_assignable_to(Unknown, Literal[1]))
static_assert(is_assignable_to(Any, Literal[1]))
static_assert(is_assignable_to(Never, Literal[1]))
static_assert(is_assignable_to(Literal[1], Unknown))
static_assert(is_assignable_to(Literal[1], Any))
static_assert(is_assignable_to(Literal[1], int))
static_assert(not is_assignable_to(Literal[1], str))
static_assert(not is_assignable_to(int, Literal[1]))

static_assert(is_assignable_to(Literal[&quot;foo&quot;], str))
static_assert(is_assignable_to(Literal[&quot;foo&quot;], LiteralString))
static_assert(is_assignable_to(LiteralString, str))
static_assert(is_assignable_to(Literal[b&quot;foo&quot;], bytes))

static_assert(is_assignable_to(Literal[1], int | str))
static_assert(is_assignable_to(Literal[1], Unknown | str))
static_assert(is_assignable_to(Literal[1] | Literal[2], Literal[1] | Literal[2]))
static_assert(is_assignable_to(Literal[1] | Literal[2], int))
static_assert(is_assignable_to(Literal[1] | None, int | None))
static_assert(not is_assignable_to(Literal[1] | None, int))
static_assert(not is_assignable_to(Literal[1] | None, str | None))

static_assert(is_assignable_to(type[Any], type[Any]))
static_assert(is_assignable_to(type[Any], type[object]))
static_assert(is_assignable_to(type[Any], type[str]))
static_assert(is_assignable_to(type[object], type[Any]))
static_assert(is_assignable_to(type[object], type[object]))
static_assert(is_assignable_to(type[object], type))
static_assert(is_assignable_to(type[str], type[Any]))
static_assert(is_assignable_to(type[str], type[object]))
static_assert(not is_assignable_to(type[object], type[str]))
static_assert(is_assignable_to(type[str], type[str]))
static_assert(is_assignable_to(type[str], type))
static_assert(not is_assignable_to(type, type[str]))
static_assert(is_assignable_to(type, type[Any]))
static_assert(is_assignable_to(type, type[object]))
static_assert(is_assignable_to(type, type))
static_assert(is_assignable_to(TypeOf[str], type[Any]))
static_assert(is_assignable_to(type[str], type[Unknown]))
static_assert(is_assignable_to(type[Unknown], type[str]))
static_assert(is_assignable_to(type[Any], type[Unknown]))
static_assert(is_assignable_to(type[Any], ABCMeta))
static_assert(is_assignable_to(type[Unknown], ABCMeta))
</code></pre>
</details>

<h2>Other ideas</h2>
<ul>
<li>[x] Introduce <code>assert_true(â€¦)</code> to replace <code>reveal_type(â€¦)  # revealed: Literal[True]</code></li>
<li>[x] Introduce <code>knot_extensions.Unknown</code> as a spelling for the <code>Unknown</code> type.</li>
<li>[ ] ~~Should we have a way to spell the empty intersection type? Like <code>Intersection[()]</code>?~~ It's probably okay not to support this. Empty <code>Union</code>s or <code>Union</code>s with a single type are not supported either (even if they would have a well defined meaning).</li>
<li>[ ] Support <a href="https://docs.python.org/3/library/typing.html#typing.assert_type"><code>typing.assert_type</code></a>, and maybe alias it as <code>knot_extensions.assert_type</code></li>
</ul>
<h2>To do</h2>
<ul>
<li>[x] Proper error handling</li>
<li>[x] Put the stubs for the <code>knot_extensions</code> module in a dedicated package</li>
<li>[x] Think about whether or not <code>TypeOf</code> is needed. Maybe introduce something like <code>knot_extensions.ClassLiteral[â€¦]</code> instead for that specific purpose?</li>
</ul>
<h2>Test Plan</h2>
<p>New Markdown tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2024-12-22 23:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-22 23:11</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-22 23:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS</code>:344 on 2024-12-22 23:12</div>
            <div class="timeline-body"><p>We would obviously <em>not</em> put this in our vendored copy of <code>typeshed</code>. This was just the easiest option for this PoC.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/red_knot.pyi</code>:19 on 2024-12-23 08:43</div>
            <div class="timeline-body"><p>These functions could potentially be annotated using https://discuss.python.org/t/pep-747-typeexpr-type-hint-for-a-type-expression/55984 (?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-12-23 08:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:3 on 2024-12-24 13:36</div>
            <div class="timeline-body"><p>nit: I'd probably call it <code>knot_extensions</code>, as it feels quite analogous to https://pypi.org/project/mypy-extensions/ and https://pypi.org/project/pyre-extensions/. (We could even consider publishing a <code>knot_extensions</code> package to PyPI... though with the current API, I'm not sure there'd be <em>much</em> utility in doing so, since you'd likely never want to execute at runtime the snippets using this API -- they're most useful for static assertions.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:107 on 2024-12-24 13:39</div>
            <div class="timeline-body"><p>nit: I think we actually don't need this one. <code>assert_false(is_subtype_of(X, Y))</code> can be written as <code>assert_true(not is_subtype_of(X, Y))</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:46 on 2024-12-24 13:42</div>
            <div class="timeline-body"><p>nit: in most proposals for this feature (e.g. https://github.com/python/typing/issues/801), this is generally referred to as a <code>Not</code> type rather than a <code>Negate</code> type, so that would be the name I'd be most familiar with for this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4210 on 2024-12-24 13:45</div>
            <div class="timeline-body"><p>nit: you can iterate directly over the tuple:</p>
<pre><code class="language-suggestion">                        tuple
                            .iter()
                            .map(|element| self.infer_type_expression(element)),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-24 13:47</div>
            <div class="timeline-body"><p>This is great! I'm impressed how simple the implementation is</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-02 08:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:46 on 2025-01-02 08:17</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 09:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS</code>:344 on 2025-01-03 09:17</div>
            <div class="timeline-body"><p>I tried to implement this, but it seems a bit involved. I'm opening this PR for review first, so we can discuss if we actually want this, before I invest more time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2025-01-03 09:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-01-03 09:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-01-03 09:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 09:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:3 on 2025-01-03 09:59</div>
            <div class="timeline-body"><p>Happy to change the name, if we decide to go forward with this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:10 on 2025-01-03 10:35</div>
            <div class="timeline-body"><pre><code class="language-suggestion">and `type[int]` to create new types. But some type-level operations that we rely on in Red Knot,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:11 on 2025-01-03 10:35</div>
            <div class="timeline-body"><p>(There are active/dormant proposals for several of these to be standardised)</p>
<pre><code class="language-suggestion">like intersections, cannot yet be expressed in Python. The `red_knot` module provides the
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:41 on 2025-01-03 10:40</div>
            <div class="timeline-body"><p>nit: <code>int</code> and <code>str</code> are not the best example here, because this happens at runtime:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; class Foo(int, str): ...
... 
Traceback (most recent call last):
  File &quot;&lt;python-input-0&gt;&quot;, line 1, in &lt;module&gt;
    class Foo(int, str): ...
TypeError: multiple bases have instance lay-out conflict
</code></pre>
<p>Ideally we'd detect this, and therefore infer that the intersection <code>int &amp; str</code> is equivalent to <code>Never</code>. Achieving that might require us to special-case some builtin classes in Python, unfortunately (it has to do with the very special way that certain builtin classes are implemented at the C level). But it may still be worth doing, since subclassing a builtin isn't an uncommon thing in user code.</p>
<p>If/when we do start inferring <code>Never</code> for that intersection, presumably this example would break (and if it were naively fixed, it would no longer demonstrate what you're trying to demonstrate here).</p>
<p>TL;DR: it might be best to construct your own classes here rather than using builtins.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:67 on 2025-01-03 10:42</div>
            <div class="timeline-body"><p>Bikeshedding: I wonder if <code>static_assert</code> might be a better name than <code>assert_true</code>?</p>
<ul>
<li><code>assert_true</code> doesn't feel like it differentiates the concept very much from the <code>assert</code> keyword at runtime, since <code>assert</code> statements at runtime also assert that a certain expression is true(thy).</li>
<li><code>static_assert</code> helps emphasise that the function only has an effect at type-checking time, not at runtime, and it's useful to be reminded of that when you're reading these mdtests</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2599 on 2025-01-03 10:48</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    RedKnotUnknown,
    // TODO: fill this enum out with more special forms, etc.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4201 on 2025-01-03 10:52</div>
            <div class="timeline-body"><p>Something like this seems a little simpler?</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index 98cd6ee4f..e6d1a1820 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -4198,14 +4198,14 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
         api_type: Type&lt;'db&gt;,
         arguments: &amp;ast::Expr,
     ) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
-        match api_type.into_class_literal() {
-            Some(class)
-                if file_to_module(self.db(), class.class.file(self.db()))
+        match api_type {
+            Type::ClassLiteral(ClassLiteralType { class })
+                if file_to_module(self.db(), class.file(self.db()))
                     .is_some_and(|module| module.is_known(KnownModule::RedKnot)) =&gt;
             {
                 let db = self.db();
 
-                let is_type_of = class.class.name(db).as_str() == &quot;TypeOf&quot;;
+                let is_type_of = class.name(db).as_str() == &quot;TypeOf&quot;;
 
                 let argument_types = match arguments {
                     ast::Expr::Tuple(tuple) =&gt; Either::Left(
@@ -4220,7 +4220,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
                     })),
                 };
 
-                let result = type_api::resolve_type_operation(db, class.class, argument_types);
+                let result = type_api::resolve_type_operation(db, class, argument_types);
 
                 match result {
                     Ok(ty) =&gt; ty,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4208 on 2025-01-03 10:59</div>
            <div class="timeline-body"><p>You can simplify your handling of comparisons between <code>Name</code>s and <code>str</code>s, as <code>Name</code> implements <code>PartialEq&lt;str&gt;</code>:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index 98cd6ee4f..617f07d58 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -4205,7 +4205,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
             {
                 let db = self.db();
 
-                let is_type_of = class.class.name(db).as_str() == &quot;TypeOf&quot;;
+                let is_type_of = class.class.name(db) == &quot;TypeOf&quot;;
 
                 let argument_types = match arguments {
                     ast::Expr::Tuple(tuple) =&gt; Either::Left(
@@ -4254,9 +4254,9 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
                 if file_to_module(self.db(), function.body_scope(self.db()).file(self.db()))
                     .is_some_and(|module| module.is_known(KnownModule::RedKnot)) =&gt;
             {
-                let name = function.name(db).as_str();
+                let function_name = function.name(db);
 
-                let is_assertion = matches!(name, &quot;assert_true&quot;);
+                let is_assertion = function_name == &quot;assert_true&quot;;
 
                 let argument_types = arguments.args.iter().map(|arg| {
                     if is_assertion {
@@ -4266,11 +4266,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
                     }
                 });
 
-                let result = type_api::resolve_type_predicate(
-                    db,
-                    function.name(db).as_str(),
-                    argument_types,
-                );
+                let result = type_api::resolve_type_predicate(db, function_name, argument_types);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4254 on 2025-01-03 11:00</div>
            <div class="timeline-body"><p>nit: you assigned <code>self.db()</code> to a variable just a couple of lines above ;)</p>
<pre><code class="language-suggestion">                if file_to_module(db, function.body_scope(db).file(db))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS</code>:344 on 2025-01-03 11:11</div>
            <div class="timeline-body"><p>Mypy has a solution for this for <code>mypy_extensions</code> that doesn't involve tinkering with typeshed's <code>VERSIONS</code> file. <code>mypy_extensions</code> exists as a runtime package published to PyPI, but the runtime package isn't <code>py.typed</code>. The type information for the package is published as a separate stubs package, <code>types-mypy-extensions</code>, and the source code for that stubs package is found in the <a href="https://github.com/python/typeshed/tree/main/stubs/mypy-extensions"><code>stubs/mypy-extensions</code> directory</a> in typeshed.</p>
<p>The <code>stubs/</code> directory in typeshed confusingly does not contain all typeshed's stubs. It only contains typeshed's stubs for third-party packages outside the stdlib. Unlike typeshed's standard-library stubs, the stubs for these third-party packages in typeshed are not generally vendored by mypy (though pyright <em>does</em> vendor them), as they're published as standalone packages to PyPI that you can <code>(uv) pip install</code> if you want your type checker to benefit from the type information provided by these packages. However, mypy makes an exception for the <code>mypy_extensions</code> package: it needs these types to always be available, and so it vendors just that package from typeshed's <code>stubs/</code> directory: https://github.com/python/mypy/tree/master/mypy/typeshed.</p>
<p>Is this relevant for us? Eh, after typing this all out, I'm not sure ðŸ¤· We almost certainly don't want to contribute our stubs for this package to typeshed upstream just yet, so that would mean that we'd be &quot;injecting&quot; these stubs into a <code>stubs/knot_extensions</code> package at typeshed-sync time. This would involve a bunch of special casing in both our module resolver (we'd need to understand the <code>stubs/</code> directory) and our typeshed-sync GitHub workflow. So a solution where we just apply a patch to typeshed's <code>VERSIONS</code> file at typeshed-sync time might indeed be simplest for now...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/red_knot.pyi</code>:5 on 2025-01-03 11:17</div>
            <div class="timeline-body"><p>I'm not sure how much this matters (since these APIs don't (yet?) exist at runtime), but I don't really love having <code>TypeOf</code>, <code>Not</code> and <code>Intersection</code> as generic classes in the stub. Although these APIs are similar to generic classes in that they accept type arguments, they're ultimately a pretty different concept to generic classes (they're special forms). If I were to add an implementation of these to the <code>typing</code> module at runtime, I definitely wouldn't implement them as classes, because it doesn't make sense to &quot;create an instance of <code>Not</code>&quot;, nor does it make sense to use <code>issubclass()</code> with <code>Not</code>, nor does it make sense to create a subclass of <code>Not</code>, etc.</p>
<p>I'd prefer it if we could implement these as instances of <code>_SpecialForm</code> in the stubs, similar to what typeshed does for <code>Union</code> and <code>Optional</code>: https://github.com/python/typeshed/blob/33d1b169c1780529e8c2b91858caf58852d73220/stdlib/typing.pyi#L205-L219. This has the added advantage that I think the implementation of these special forms will become a little more similar to the implementations we've already added in <code>infer.rs</code> for <code>Union</code> and <code>Optional</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/red_knot.pyi</code>:11 on 2025-01-03 11:20</div>
            <div class="timeline-body"><p>I think this variable is unused! The PEP-695 type parameters you're using in the class and function definitions below all create their own local-to-the-scope variables</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-03 11:21</div>
            <div class="timeline-body"><p>This is really nice. Considering how much more readable this makes our tests, I'm sold that this is the way to go. As such, my review here is mostly a review/commentary of your implementation rather than of the concept itself :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 11:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:67 on 2025-01-03 11:27</div>
            <div class="timeline-body"><p>I like it! That's also the name used in C++, which has the same distinction between <code>assert</code> and <code>static_assert</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-03 12:28</div>
            <div class="timeline-body"><p>More of a question than a comment: What are your thoughts on whether we should gate this behind a feature or make it testing only?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 12:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/red_knot.pyi</code>:5 on 2025-01-03 12:28</div>
            <div class="timeline-body"><p>Great suggestion â€” thank you. The implementation is also a bit cleaner now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:110 on 2025-01-03 12:43</div>
            <div class="timeline-body"><p>minor: this might not be the best example, as I <em>believe</em> <code>static_assert(int == int)</code> would also pass (or it <em>should</em> do anyway, since it will evaluate to <code>True</code> at runtime, and we should be able to statically determine that). But the <code>is_equivalent_to</code> relation is not (necessarily) the same as a simple runtime equality relation. A better demonstration here might be <code>static_assert(is_equivalent_to(type, type[object]))</code> or <code>static_assert(is_equivalent_to(Intersection[LiteralString, Literal[&quot;a&quot;]], Literal[&quot;a&quot;]))</code></p>
<p>(There might be simpler examples -- my main point is just that something where the runtime equality relation doesn't hold true would be best)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 12:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS</code>:344 on 2025-01-03 12:45</div>
            <div class="timeline-body"><blockquote>
<p>The type information for the package is published as a separate stubs package, <code>types-mypy-extensions</code>, and the source code for that stubs package is found in the <a href="https://github.com/python/typeshed/tree/main/stubs/mypy-extensions"><code>stubs/mypy-extensions</code> directory</a> in typeshed.</p>
</blockquote>
<p>Oh, interesting.</p>
<blockquote>
<p>Unlike typeshed's standard-library stubs, the stubs for these third-party packages in typeshed are not generally vendored by mypy (though pyright <em>does</em> vendor them), as they're published as standalone packages to PyPI that you can <code>(uv) pip install</code> if you want your type checker to benefit from the type information provided by these packages. However, mypy makes an exception for the <code>mypy_extensions</code> package</p>
</blockquote>
<p>:upside_down_face:</p>
<blockquote>
<p>Is this relevant for us? Eh, after typing this all out, I'm not sure ðŸ¤·</p>
</blockquote>
<p>I think so! If there is precedent for having these stubs in typeshed, that seems like a valid (future) solution to me.</p>
<blockquote>
<p>We almost certainly don't want to contribute our stubs for this package to typeshed upstream just yet</p>
</blockquote>
<p>Of course</p>
<blockquote>
<p>This would involve a bunch of special casing in both our module resolver (we'd need to understand the <code>stubs/</code> directory) and our typeshed-sync GitHub workflow.</p>
</blockquote>
<p>Seems like something I could try. Should we wait for the next Red Knot meeting to decide on whether we want this changeset or not?</p>
<blockquote>
<p>So a solution where we just apply a patch to typeshed's <code>VERSIONS</code> file at typeshed-sync time might indeed be simplest for now...</p>
</blockquote>
<p>To be clear, here you are talking about yet another (simpler) solution that wouldn't put <code>red_knot.pyi</code> in <code>stubs/knot_extensions</code>, but in <code>stdlib/</code>, and then apply a patch to <code>stdlib/VERSIONS</code>, in order not having to add special casing logic to the module resolver?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS</code>:344 on 2025-01-03 12:48</div>
            <div class="timeline-body"><blockquote>
<p>To be clear, here you are talking about yet another (simpler) solution that wouldn't put <code>red_knot.pyi</code> in <code>stubs/knot_extensions</code>, but in <code>stdlib/</code>, and then apply a patch to <code>stdlib/VERSIONS</code>, in order not having to add special casing logic to the module resolver?</p>
</blockquote>
<p>correct!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2875 on 2025-01-03 12:50</div>
            <div class="timeline-body"><p>nit: I'd probably add an <code>is_red_knot</code> method to the <code>KnownModule</code> enum and then do this:</p>
<pre><code class="language-suggestion">            | Self::RedKnotTypeOf =&gt; module.is_red_knot(),
</code></pre>
<p>which would be similar to the first branch of this big <code>match</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/class_base.rs</code>:97 on 2025-01-03 12:51</div>
            <div class="timeline-body"><p>hmm, maybe we <em>should</em> allow subclassing from <code>Unknown</code>, since we allow subclassing from <code>Any</code> (and that's allowed at runtime as well)? Happy for us to just add a TODO comment with this question for now, though</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4283 on 2025-01-03 12:55</div>
            <div class="timeline-body"><p>I think the <code>class</code> variable here is actually an <code>InstanceType</code> object:</p>
<pre><code class="language-suggestion">                    Err(TypeApiPredicateError::StaticAssertionError(Type::Instance(instance_ty)))
                        if instance_ty.class.is_known(db, KnownClass::Bool) =&gt;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-03 13:18</div>
            <div class="timeline-body"><blockquote>
<p>More of a question than a comment: What are your thoughts on whether we should gate this behind a feature or make it testing only?</p>
</blockquote>
<p>Seeing that mypy and pyre have similar public APIs, I could imagine (part of) this becoming a public API for red knot that isn't feature-gated? The <code>Intersection</code>/<code>Not</code> constructors and <code>static_assert</code> are potentially interesting for users which don't care too much about compatibility with other type checkers (cf https://github.com/python/typing/issues/213). Some less-interesting parts like <code>is_singleton</code> could also be moved to <code>knot_extensions.internal</code> maybe?</p>
<p>Do we need to decide this right away? If not, can this stay public for now, or should we approach it very carefully and hide everything (by default)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:12 on 2025-01-03 13:28</div>
            <div class="timeline-body"><p>A decent amount of logic in this file is devoted to call-signature checking for this API, and Carl has a draft PR up for a generalized solution to call-signature checking (https://github.com/astral-sh/ruff/pull/15200). I think currently you would <em>not</em> benefit from the generalized solution there, because you have an early return on line 3000 in <code>infer.rs</code>, and Carl's solution is all implemented as part of the enum returned by <code>Type::call()</code>.</p>
<p>I do feel like ideally we wouldn't special-case these functions when it comes to emitting diagnostics for an incorrect number of arguments, we'd just use the generalized logic. But I'm also okay with adding this for now, since it helps us ensure that we use the APIs correctly while we're in a state where we don't yet have generalised call-signature checking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-03 13:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-03 13:30</div>
            <div class="timeline-body"><blockquote>
<p>Do we need to decide this right away? If not, can this stay public for now, or should we approach it very carefully and hide everything (by default)?</p>
</blockquote>
<p>I'm generally leaning toward keeping the API intentionally limited and only expose features that we want to support long term (and consider part of the public API) because users will using them and it's very easy that we forget to revisit this decision before the release (unless we note it down somewhere?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 14:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:110 on 2025-01-03 14:18</div>
            <div class="timeline-body"><p>Oh, absolutely. I added the <code>is_equivalent_to(type, type[object])</code> example as well as <code>is_equivalent_to(tuple[int, Never], Never)</code>. I also added some other examples such as <code>is_equivalent_to(int | str, Union[int, str])</code> even if they evaluate to <code>True</code> at runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:12 on 2025-01-03 14:28</div>
            <div class="timeline-body"><blockquote>
<p>I do feel like ideally we wouldn't special-case these functions when it comes to emitting diagnostics for an incorrect number of arguments, we'd just use the generalized logic.</p>
</blockquote>
<p>Yes, I was expecting that some of this would be superfluous once we have call signature checking. I think some of this is still required for the special forms, but I'd be glad to have this more generally be solved by call signature checking for predicates. I'll note it down as a future TODO, which I'll add to this PR in case #15200 will be merged first.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Red Knot Type API" to "[red-knot] `knot_extensions` Python API" by @sharkdp on 2025-01-03 14:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:91 on 2025-01-03 14:51</div>
            <div class="timeline-body"><p>What if we had an inner enum inside a <code>KnownFunction</code> variant, similar to our existing solution for describing the subset of known functions that are constraint functions?</p>
<p>https://github.com/astral-sh/ruff/blob/0837cdd9314cb9ee1df087142af975d492e3e7ba/crates/red_knot_python_semantic/src/types.rs#L3064-L3086</p>
<p>I think that might be more extensible in the long run, since (as you've already identified), <code>assert_type()</code> is a predicate function very similar to the ones in <code>knot_extensions</code>, but it comes from a different module to these ones (<code>typing</code>/<code>typing_extensions</code>).</p>
<p>Using the <code>KnownFunction</code> enum for identifying these predicate functions would also have the advantage that it's less &quot;stringly typed&quot; here, and it would help maintain the property that the <code>KnownFunction</code> enum is an exhaustive enumeration of all functions that are special-cased in some way by red-knot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-03 14:55</div>
            <div class="timeline-body"><pre><code class="language-suggestion">// TODO: redundant once more generalized call-signature checking is implemented?
#[derive(Debug)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-03 14:56</div>
            <div class="timeline-body"><p>LGTM, thank you!!</p>
<p>A couple more minor comments below, and we need to sort out the open question of where the <code>knot_extensions</code> stub will live (or it will get deleted in the next automated typeshed-sync PR). But other than that, this now looks great to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 15:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-03 15:02</div>
            <div class="timeline-body"><p>Note that this error is also returned when passing a wrong number of arguments to special forms like <code>Not</code> and <code>TypeOf</code>, which will not be handled by call signature checking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-03 15:14</div>
            <div class="timeline-body"><p>Oh, I missed that. Hmm, I think I'd probably prefer to emit those errors in the same <code>match</code> as we emit the equivalent errors for all our other special forms here: https://github.com/astral-sh/ruff/blob/706d87f239cb3af6562581d221bf6cd1f1636b66/crates/red_knot_python_semantic/src/types/infer.rs#L4963-L4980</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-03 15:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:91 on 2025-01-03 15:15</div>
            <div class="timeline-body"><p>Done â€” thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-03 15:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-03 15:41</div>
            <div class="timeline-body"><p>My initial idea (and my initial implementation) was trying to be very defensive in the sense that I tried to move the type API &quot;out of the way&quot;, with most of the code in a separate module and only very few places where it interacted with existing type inference code. With all of your (great) suggestions, we have now moved to a version that has a tighter coupling to the existing code. This is fine for me, but it might be rather annoying to feature-gate all of this (see @MichaReiser's comment).</p>
<p>I can write separate argument handling logic for <code>TypeOf</code>/<code>Not</code> similar to what we have for <code>Annotated</code>, or try to unite that somehow, but it will make the coupling even stronger (and maybe lead to more code overall?). Does it make sense to wait with this until with have decisions on some higher-level questions (do we want to keep the currently proposed API? do we want to make it public or will all of the code be feature-gated? â€¦)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-03 15:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4242 on 2025-01-03 15:54</div>
            <div class="timeline-body"><p>Oh, when I suggested using <code>KnownFunction</code>, I was imagining we'd set the <code>known</code> field on the <code>FunctionType</code> at inference time, like we do for our other <code>KnownFunction</code>s -- something like this (which is admittedly more verbose than what you currently have, but means that the <code>known()</code> and <code>is_known()</code> methods on <code>FunctionType</code> will continue to work as expected for all <code>KnownFunction</code> variants):</p>
<details>

<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/semantic_index/definition.rs b/crates/red_knot_python_semantic/src/semantic_index/definition.rs
index fc75d252d..d8d60d048 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/definition.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/definition.rs
@@ -74,6 +74,11 @@ impl&lt;'db&gt; Definition&lt;'db&gt; {
             Some(KnownModule::Typing | KnownModule::TypingExtensions)
         )
     }
+
+    pub(crate) fn is_knot_extensions_definition(self, db: &amp;'db dyn Db) -&gt; bool {
+        file_to_module(db, self.file(db))
+            .is_some_and(|module| module.is_known(KnownModule::KnotExtensions))
+    }
 }
 
 #[derive(Copy, Clone, Debug)]
diff --git a/crates/red_knot_python_semantic/src/types.rs b/crates/red_knot_python_semantic/src/types.rs
index 64103b7a1..e42b2fa52 100644
--- a/crates/red_knot_python_semantic/src/types.rs
+++ b/crates/red_knot_python_semantic/src/types.rs
@@ -3137,6 +3137,17 @@ impl KnownFunction {
         }
     }
 
+    pub fn into_type_api_function(self) -&gt; Option&lt;TypeApiFunction&gt; {
+        match self {
+            Self::TypeApiFunction(function) =&gt; Some(function),
+            Self::RevealType
+            | Self::Len
+            | Self::Final
+            | Self::NoTypeCheck
+            | Self::ConstraintFunction(_) =&gt; None,
+        }
+    }
+
     fn try_from_definition_and_name&lt;'db&gt;(
         db: &amp;'db dyn Db,
         definition: Definition&lt;'db&gt;,
@@ -3155,6 +3166,31 @@ impl KnownFunction {
             &quot;no_type_check&quot; if definition.is_typing_definition(db) =&gt; {
                 Some(KnownFunction::NoTypeCheck)
             }
+            &quot;static_assert&quot; if definition.is_knot_extensions_definition(db) =&gt; Some(
+                KnownFunction::TypeApiFunction(TypeApiFunction::StaticAssert),
+            ),
+            &quot;is_subtype_of&quot; if definition.is_knot_extensions_definition(db) =&gt; {
+                Some(KnownFunction::TypeApiFunction(TypeApiFunction::IsSubtypeOf))
+            }
+            &quot;is_disjoint_from&quot; if definition.is_knot_extensions_definition(db) =&gt; {
+                Some(KnownFunction::TypeApiFunction(TypeApiFunction::IsDisjointFrom))
+            }
+            &quot;is_equivalent_to&quot; if definition.is_knot_extensions_definition(db) =&gt; Some(
+                KnownFunction::TypeApiFunction(TypeApiFunction::IsEquivalentTo),
+            ),
+            &quot;is_assignable_to&quot; if definition.is_knot_extensions_definition(db) =&gt; Some(
+                KnownFunction::TypeApiFunction(TypeApiFunction::IsAssignableTo),
+            ),
+            &quot;is_fully_static&quot; if definition.is_knot_extensions_definition(db) =&gt; Some(
+                KnownFunction::TypeApiFunction(TypeApiFunction::IsFullyStatic),
+            ),
+            &quot;is_singleton&quot; if definition.is_knot_extensions_definition(db) =&gt; {
+                Some(KnownFunction::TypeApiFunction(TypeApiFunction::IsSingleton))
+            }
+            &quot;is_single_valued&quot; if definition.is_knot_extensions_definition(db) =&gt; Some(
+                KnownFunction::TypeApiFunction(TypeApiFunction::IsSingleValued),
+            ),
+
             _ =&gt; None,
         }
     }
diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index b92722c36..cdea434c0 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -69,12 +69,12 @@ use crate::types::{
     typing_extensions_symbol, Boundness, CallDunderResult, Class, ClassLiteralType, FunctionType,
     InstanceType, IntersectionBuilder, IntersectionType, IterationOutcome, KnownClass,
     KnownFunction, KnownInstanceType, MetaclassCandidate, MetaclassErrorKind, SliceLiteralType,
-    Symbol, Truthiness, TupleType, Type, TypeAliasType, TypeApiFunction, TypeArrayDisplay,
+    Symbol, Truthiness, TupleType, Type, TypeAliasType, TypeArrayDisplay,
     TypeVarBoundOrConstraints, TypeVarInstance, UnionBuilder, UnionType,
 };
 use crate::unpack::Unpack;
 use crate::util::subscript::{PyIndex, PySlice};
-use crate::{Db, KnownModule};
+use crate::Db;
 
 use super::context::{InNoTypeCheck, InferContext, WithDiagnostics};
 use super::diagnostic::{
@@ -4234,22 +4234,21 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
     ) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
         let db = self.db();
 
-        match function.into_function_literal() {
-            Some(function)
-                if file_to_module(db, function.body_scope(db).file(db))
-                    .is_some_and(|module| module.is_known(KnownModule::KnotExtensions)) =&gt;
-            {
-                let function = TypeApiFunction::try_from(function.name(db).as_str()).ok()?;
-
+        match function
+            .into_function_literal()
+            .and_then(|function| function.known(db))
+            .and_then(KnownFunction::into_type_api_function)
+        {
+            Some(api_function) =&gt; {
                 let argument_types = arguments.args.iter().map(|arg| {
-                    if function == TypeApiFunction::StaticAssert {
+                    if api_function.is_static_assert() {
                         self.infer_expression(arg)
                     } else {
                         self.infer_type_expression(arg)
                     }
                 });
 
-                let result = type_api::resolve_predicate(db, function, argument_types);
+                let result = type_api::resolve_predicate(db, api_function, argument_types);
 
                 match result {
                     Ok(ty) =&gt; Some(ty),
diff --git a/crates/red_knot_python_semantic/src/types/type_api.rs b/crates/red_knot_python_semantic/src/types/type_api.rs
index f1d5f945e..72360d8fb 100644
--- a/crates/red_knot_python_semantic/src/types/type_api.rs
+++ b/crates/red_knot_python_semantic/src/types/type_api.rs
@@ -81,21 +81,9 @@ pub enum TypeApiFunction {
     IsSingleValued,
 }
 
-impl TryFrom&lt;&amp;str&gt; for TypeApiFunction {
-    type Error = ();
-
-    fn try_from(value: &amp;str) -&gt; Result&lt;Self, Self::Error&gt; {
-        match value {
-            &quot;static_assert&quot; =&gt; Ok(Self::StaticAssert),
-            &quot;is_equivalent_to&quot; =&gt; Ok(Self::IsEquivalentTo),
-            &quot;is_subtype_of&quot; =&gt; Ok(Self::IsSubtypeOf),
-            &quot;is_assignable_to&quot; =&gt; Ok(Self::IsAssignableTo),
-            &quot;is_disjoint_from&quot; =&gt; Ok(Self::IsDisjointFrom),
-            &quot;is_fully_static&quot; =&gt; Ok(Self::IsFullyStatic),
-            &quot;is_singleton&quot; =&gt; Ok(Self::IsSingleton),
-            &quot;is_single_valued&quot; =&gt; Ok(Self::IsSingleValued),
-            _ =&gt; Err(()),
-        }
+impl TypeApiFunction {
+    pub const fn is_static_assert(self) -&gt; bool {
+        matches!(self, TypeApiFunction::StaticAssert)
     }
 }
</code></pre>
</details>

<p>But this would make the problem you pointed out elsewhere even worse -- we'd be integrating the handling of these functions into red-knot in a way such that they'd be harder to feature-gate.</p>
<p>I'm not sure feature-gating is a realistic possibility though... if we want to stop external users from making use of these APIs for now (which I agree is a reasonable idea), I think we might want to do that using a runtime check somehow rather than a compile-time check. While it would be <em>possible</em> to try to squirrel away all the logic in a separate module, I think in the long run it'll be really confusing to have the logic for some special forms in a different place to the logic for all our other special forms. (And same for type-predicate functions -- I don't really want the logic for <code>is_subtype_of</code> to live in a completely different submodule to the logic for <code>assert_type</code>, since they're so similar conceptually!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:32 on 2025-01-06 18:48</div>
            <div class="timeline-body"><p>Use <code>static_assert</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:32 on 2025-01-06 18:50</div>
            <div class="timeline-body"><p>Nit that may not be worth all the changes it would imply in this PR: I weakly prefer using annotated function arguments over non-local name references, because the semantics of the former are very clear, whereas our handling of non-local name references (particularly declared but unbound ones, as used here) could change in future. For example, I can easily imagine that in future all of these references might emit an unbound-name diagnostic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:244 on 2025-01-06 19:00</div>
            <div class="timeline-body"><p>Interesting. Given that this is Python code, I could see an argument for using Python semantics here (silently accepting anything whose <code>__bool__</code> evaluates to <code>Literal[True]</code>) rather than the stricter Rust semantics (requiring explicit conversion to bool). (In other words, not emitting any error here.)</p>
<p>Based on your usage of this API so far, do you feel that this would be too error-prone?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 19:47</div>
            <div class="timeline-body"><p>Why is <code>TypeOf</code> a bracketed special form, rather than a function <code>type_of</code>?</p>
<p>If it were a function, it seems like once we have generics it wouldn't even require special-casing, it would just be a function with signature <code>def type_of[T](obj: T) -&gt; T: ...</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-06 19:58</div>
            <div class="timeline-body"><p>I would prefer to not maintain different ways of doing the same thing in different places, depending on whether they are &quot;red knot type API&quot; vs &quot;standardized type API&quot; -- for example, I think <code>reveal_type</code> and <code>assert_type</code> should be implemented in the same way as red-knot type API functions. (Currently this PR implements red-knot type API functions differently from <code>reveal_type</code>.) The distinction of whether some API is standardized vs red-knot-specific is incidental and subject to change (I could easily see <code>static_assert</code> becoming standardized in the future, for example), and I would rather minimize the extent to which such differences are hardcoded in Rust.</p>
<p>I also don't think that the question of what we expose publicly needs to be closely tied to the question of code-level integration. I think whatever feature gating we do should probably not happen at the Rust implementation level (that is, trying to turn off or on certain Rust code paths in type inference), but rather at the Python level; that is, in the type stub for the <code>knot_extensions</code> module. This could mean only conditionally including the type stub for <code>knot_extensions</code> at all, or having some conditional definitions of things in the type stub. If you can't import the known-function and known-instance types that make up the type API, then it doesn't matter whether the code paths exist for those; you won't be able to enter those code paths anyway.</p>
<p>So I am generally in favor of making the code in this PR more integrated with the rest of red-knot, not less. That includes using our general support for call-checking (once it lands) to implement checking arguments to type-API functions, and implementing bracketed-special-form handling for type API special forms in the same place we do so for other bracketed special forms.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-06 20:04</div>
            <div class="timeline-body"><blockquote>
<p>I'm generally leaning toward keeping the API intentionally limited and only expose features that we want to support long term (and consider part of the public API)</p>
</blockquote>
<p>For what it's worth, there's nothing in the API added in this PR that I have reservations about supporting long-term as public API, in principle. Of course it's always possible that we realize we made mistakes in details of how we defined or named the API, and we want to change these things in future and potentially have to take backward-compatibility into account with those changes. But this is inevitable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS</code>:344 on 2025-01-06 20:09</div>
            <div class="timeline-body"><p>Given that we will need some kind of typeshed-patching for now, I think we should do whatever form of it is easiest to implement.</p>
<p>At some point we'll definitely need to add support to our module resolver for non-stdlib stubs packages, but it's not clear yet if we'll specifically need support for vendoring <code>typeshed/stubs</code>, and I don't think this PR needs to be the driver for adding that support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2602 on 2025-01-06 20:11</div>
            <div class="timeline-body"><p>I have mixed feelings even about using the <code>KnotExtensions</code> prefix here; we don't do that for special forms from other modules, unless it's necessary for other reasons (e.g. <code>TypingSelf</code>, due to Rust keyword <code>Self</code>), and I can easily see any of these becoming not red-knot-specific in future. But I don't feel strongly, it's easy to remove this prefix in future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3125 on 2025-01-06 20:12</div>
            <div class="timeline-body"><p>Similarly, I wonder why we need <code>TypeApiFunction</code> nested enum here, rather than including the type-api functions as top-level known functions in <code>KnownFunction</code> enum?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 20:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-06 20:14</div>
            <div class="timeline-body"><p>(More for @carljm's benefit: I responded to this a little bit at https://github.com/astral-sh/ruff/pull/15103#discussion_r1901926256)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3001 on 2025-01-06 20:14</div>
            <div class="timeline-body"><p>As mentioned in another comment, I would prefer not to have special handling for &quot;red knot type api&quot; functions; I think they should work in the same way as <code>reveal_type</code> and <code>assert_type</code> (which are not red-knot specific).</p>
<p>Perhaps we don't like the way <code>reveal_type</code> is currently handled in <code>Type::call</code> and <code>CallOutcome</code>, and want to adjust it. But I don't think there should be different paths for it vs red-knot type API.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4218 on 2025-01-06 20:24</div>
            <div class="timeline-body"><p>I think this should just use the existing <code>INVALID_TYPE_FORM</code> diagnostic rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4196 on 2025-01-06 20:29</div>
            <div class="timeline-body"><p>Nit: I would expect this method to be located down near the other type-expression inference methods (that is, near where it's used.)</p>
<p>And similar to other comments, I would rather see unified/integrated slice/arity handling for all of our special forms, rather than special handling just for the red-knot-specific ones. They are all just bracketed special forms; whether they are red-knot specific or not should not be fundamental to their implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4266 on 2025-01-06 20:29</div>
            <div class="timeline-body"><p>I would expect this to emit the same diagnostic as any other wrong-arity call, not a special diagnostic specific to red-knot type-api.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-06 20:33</div>
            <div class="timeline-body"><p>What's the advantage of using these dedicated types vs just having them all return <code>bool</code> in the stub? Either way the stub-annotated return type isn't used as-is, we have to special-case it. But this way it seems like the stub is just lying about the actual inferred return type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-06 20:33</div>
            <div class="timeline-body"><p>This is really excellent, thank you! I look forward to using it, and I think red-knot users will also find it valuable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 20:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 20:39</div>
            <div class="timeline-body"><blockquote>
<p>it would just be a function with signature <code>def type_of[T](obj: T) -&gt; T: ...</code>?</p>
</blockquote>
<p>That would imply that if the function were passed an object of type <code>int</code>, it would return an object of type <code>int</code>, but that's not what the function does at all (it returns the type <code>int</code> itself, not an object of type <code>int</code>). I think we would need the TypeForm proposal to annotate such a function in such a way that it would require no red-knot special-casing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 20:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 20:40</div>
            <div class="timeline-body"><p>However, I agree that a special-cased function feels like it might be a nicer API here than a bracketed special form!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-06 21:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-06 21:28</div>
            <div class="timeline-body"><p>I was expecting this question to come up :smile:. Honestly, I didn't really know what to put here. Yes, <code>bool</code> is the union of both possible return types that we would could infer (either <code>Literal[True]</code> or <code>Literal[False]</code>). But it wouldn't ever be useful for a type checker to fall back to this <code>bool</code> return type annotation, since no static conclusions can be drawn from it, right? Or is that exactly why you want it to be annotated as <code>bool</code>? For other type checkers that do not special case these functions?</p>
<p>I think I wanted to express that these are functions on types, not on objects. Using <code>_Xyz[S, T]</code> as a return type was my way of saying: the return type depends on the argument types. But of course I couldn't express that the return type does not <em>also</em> depend on those &quot;phantom data&quot; objects <code>x</code>/<code>y</code>.</p>
<p>This is also why I implemented these predicates as generic classes like <code>IsEquivalentTo[S, T]</code> initially, as that seemed to imply to me that a new type (<code>IsEquivalentTo[S, T]</code>) is being computed from two other types (<code>S</code> and <code>T</code>). But I understand that that's not great either.</p>
<p>So I'm happy to change it to <code>bool</code>. And I can also add some documentation for readers of that stub file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-06 21:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-06 21:32</div>
            <div class="timeline-body"><p>Yes, it makes sense how you got here :) But my feeling is that neither return type is directly useful, and <code>bool</code> is both accurate and simple.</p>
<blockquote>
<p>I wanted to express that these are functions on types</p>
</blockquote>
<p>Yeah; I think the way to do this is would be via annotating the arguments as <code>TypeForm</code>, once PEP 747 is accepted.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-06 21:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:244 on 2025-01-06 21:46</div>
            <div class="timeline-body"><p>No, that makes sense to me, I hadn't thought about that.</p>
<blockquote>
<p>Based on your usage of this API so far, do you feel that this would be too error-prone?</p>
</blockquote>
<p>I don't think so.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-06 21:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 21:53</div>
            <div class="timeline-body"><blockquote>
<p>Why is <code>TypeOf</code> a bracketed special form, rather than a function <code>type_of</code>?</p>
</blockquote>
<p>Because I wanted it to be usable in a type annotation, and it seems like a function call as in <code>x: type_of(str) = â€¦</code> would not be valid syntax according to the <a href="https://typing.readthedocs.io/en/latest/spec/annotations.html">typing spec</a>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-06 21:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 21:55</div>
            <div class="timeline-body"><p>Oh, interesting! That's a good reason. Perhaps we should include a test of using it in an annotation here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-06 21:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 21:58</div>
            <div class="timeline-body"><p><code>TypeOf[str]</code> <em>would</em> be valid syntax (similar to <code>Union</code> etc). But that doesn't eradicate all syntax problems with <code>TypeOf</code>. Because I might want to write <code>TypeOf[2 + 3]</code>, but that's not valid according to:</p>
<pre><code>                           | &lt;type&gt; '[' &lt;Any&gt; ']'
                           | &lt;type&gt; '[' name ']'
                                 (where name must refer to a valid in-scope class
                                  or TypeVar)
</code></pre>
<p>This is also why I wrote in the PR description that I was thinking about replacing <code>TypeOf[â€¦]</code> with <code>ClassLiteral[â€¦]</code>, which could only be used for naming class literal types and nothing else.</p>
<p>It seems like <code>TypeOf[â€¦]</code> could be more generally useful, but I haven't actually come up with any other examples yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-06 22:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3125 on 2025-01-06 22:00</div>
            <div class="timeline-body"><p>It allows me to exhaustively match on all type API functions later without having to use <code>unreachable!</code>. But if we're all okay with a tighter integration of this code here, I can see if it makes sense to flatten this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 22:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-06 22:06</div>
            <div class="timeline-body"><p>Maybe something like this would follow the letter (though possibly not the spirit ðŸ˜…) of the spec:</p>
<pre><code class="language-py">type X = type_of(2 + 3)
spam: X
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 00:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3125 on 2025-01-07 00:47</div>
            <div class="timeline-body"><blockquote>
<p>It allows me to exhaustively match on all type API functions later</p>
</blockquote>
<p>Right. I think the idea of flattening is predicated on the idea that we <em>shouldn't</em> have any place where we match on &quot;all type API functions&quot; (as opposed to &quot;all known functions with special-cased call handling&quot;).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 00:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-07 00:53</div>
            <div class="timeline-body"><p>I don't think we need to worry about making <code>TypeOf</code> usable in an annotation with arbitrary non-typeform expressions. You can always just assign the expression to a variable <code>x</code> and use <code>TypeOf[x]</code> instead.</p>
<p>I will say that <code>TypeOf</code> is the API in this PR whose use cases are least clear to me. If we really only have use cases for expressing class literal types in an annotation, it would probably be trivial to allow <code>Literal[A]</code> for that (the same way we currently output those types). Though we may want to find a different syntax to output those types, in which case we'd want to add matching red-knot API for spelling them, too.</p>
<blockquote>
<p>Maybe something like this would follow the letter (though possibly not the spirit ðŸ˜…) of the spec:</p>
<pre><code class="language-python">type X = type_of(2 + 3)
spam: X
</code></pre>
</blockquote>
<p>I don't think this follows the letter or spirit of <a href="https://typing.readthedocs.io/en/latest/spec/aliases.html#type-statement">the spec</a> :)</p>
<blockquote>
<p>As with typing.TypeAlias, type checkers should restrict the right-hand expression to expression forms that are allowed within type annotations.</p>
</blockquote>
<p>But there's no need to use a <code>type</code> statement for this at all, the simpler way would be:</p>
<pre><code class="language-py">x = 2 + 3
spam: TypeOf[x]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 13:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:320 on 2025-01-07 13:22</div>
            <div class="timeline-body"><p>Ok, I understand I can leave it as is for now. I added a test which uses <code>TypeOf</code> in annotation position and demonstrates the difference between <code>TypeOf[str]</code> and <code>type[str]</code>:</p>
<pre><code class="language-py">class Base: ...
class Derived(Base): ...

# `TypeOf` can be used in annotations:
def type_of_annotation() -&gt; None:
    t1: TypeOf[Base] = Base
    t2: TypeOf[Base] = Derived  # error: [invalid-assignment]

    # Note how this is different from `type[â€¦]` which includes subclasses:
    s1: type[Base] = Base
    s2: type[Base] = Derived  # no error here
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 20:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/type_api.rs</code>:8 on 2025-01-07 20:11</div>
            <div class="timeline-body"><blockquote>
<p>So I am generally in favor of making the code in this PR more integrated with the rest of red-knot, not less. That includes using our general support for call-checking (once it lands) to implement checking arguments to type-API functions, and implementing bracketed-special-form handling for type API special forms in the same place we do so for other bracketed special forms.</p>
</blockquote>
<p>This is all resolved now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 20:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3125 on 2025-01-07 20:12</div>
            <div class="timeline-body"><p>Ok, the type API functions are now handled in the same places like <code>RevealType</code> etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4266 on 2025-01-07 20:13</div>
            <div class="timeline-body"><p>Ok, rebased my branch on top of your call-signature checking branch, so this now uses your implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 20:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 20:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-07 20:27</div>
            <div class="timeline-body"><p>So I'm just going to mention this one last time and then I'll be quiet :smile:. The current version of the API does feel good to me and I think it's more or less intuitive. I'm personally fine with merging it as is.</p>
<p>But upon closer inspection, there are some things that are &quot;special&quot;.</p>
<p>The type predicates like <code>is_fully_static</code> etc. do not work like usual Python functions: For all other functions, we call <code>infer_expression</code> on the arguments in a function call. But for these predicates, we call <code>infer_type_expression</code>.</p>
<p>Similarly, the special form <code>TypeOf</code> does not work like usual special forms (although <code>Annotated</code> can also contain an non-type-expression in the second argument). For all other special forms, we call <code>infer_type_expression</code> for the bracketed arguments to the special form. For <code>TypeOf</code>, we call <code>infer_expression</code>.</p>
<p>For <code>TypeOf</code>, we already discussed that it might be necessary to leave it as a special form, as a call expression can not occur in type annotations.</p>
<p>But the functions still feel a bit strange to me, and also require some special-casing in the implementation. It seems to me that even if we had PEP 747 and annotated the parameter types of these functions as <code>TypeForm</code>s, we should <em>still</em> call <code>infer_expression</code> instead of <code>infer_type_expression</code> for calls to such functions (I haven't read the full PEP, but <a href="https://peps.python.org/pep-0747/#introspecting-type-form-objects">the <code>split_union</code> example here</a> seems to imply that <code>typ</code> internally is of type <code>UnionType</code>, for example â€” not an actual union type).</p>
<p>Again, I'm personally fine with this special-casing, but I thought it would be worth calling out one last time. The alternative would be to make these predicates special forms that could be called via <code>IsFullyStatic[int]</code> or maybe these would be generic classes with a <code>__bool__</code> method that would return <code>Literal[True]</code>/<code>Literal[False]</code> accordingly, such that we could write <code>static_assert(IsFullyStatic[int]())</code>. Or potentially <code>static_assert(IsFullyStatic[int])</code> if we implement it on the meta-class(?).</p>
<p>(the <code>Intersection</code> and <code>Not</code> type forms, and the <code>static_assert</code> function act normal)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 20:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:24 on 2025-01-07 20:48</div>
            <div class="timeline-body"><p>I annotated these using <code>Any</code>, because now with call signature checking, I couldn't call <code>is_fully_static(type[Any])</code> when they were annotated using <code>object</code> because apparently <code>type[Any]</code> (the type, not the expression) is not assignable to <code>object</code>. And using generics is not an option yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 20:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:24 on 2025-01-07 20:52</div>
            <div class="timeline-body"><p>Everything should be assignable to <code>object</code>. If <code>type[Any]</code> is not assignable to <code>object</code>, that's a separate bug that we should fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-07 20:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:24 on 2025-01-07 20:55</div>
            <div class="timeline-body"><p>(Though separately, <code>Any</code> is arguably a better annotation for these parameters anyway, since <code>object</code> implies &quot;it would be valid to pass literally any object to these functions&quot;, and that's not really true â€” in fact, the object passed into several of these has to be a Python object representing a type (a typeform) of some kind)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-07 20:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:24 on 2025-01-07 20:57</div>
            <div class="timeline-body"><p>Our policy at typeshed is to prefer <code>Any</code> for situations like this where the &quot;true type&quot; is inexpressible, anyway</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:24 on 2025-01-07 21:22</div>
            <div class="timeline-body"><p>If you rebase on top of https://github.com/astral-sh/ruff/pull/15332 you should be able to go back to <code>object</code> here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 21:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 21:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:24 on 2025-01-07 21:27</div>
            <div class="timeline-body"><p>Oh, Alex's comments didn't live-update for me. I can see the rationale for preferring <code>Any</code> here, pending <code>TypeForm</code> availability. In that case, feel free to leave it, and not bother rebasing on my PR :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 21:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-07 21:50</div>
            <div class="timeline-body"><p>Your functions aren't the first example of this: the existing <code>typing.cast</code> function (which we haven't yet implemented support for, but will need to) also requires its first argument to be interpreted as a type expression rather than a value expression.</p>
<p>PEP 747 generalizes this; it requires that an expression whose &quot;type context&quot; is a <code>TypeForm</code> type (e.g. the RHS of an annotated assignment where the annotation is a <code>TypeForm</code> type, or an argument matched to a parameter annotated as a <code>TypeForm</code> type) be interpreted as a type expression rather than a value expression. If the expression is a valid type expression, it is assignable to <code>TypeForm</code>; if it is a valid type expression spelling a type assignable to <code>T</code>, then it is assignable to <code>TypeForm[T]</code>.</p>
<p>(The <code>split_union</code> example in the PEP is not a counter-example to this. A <code>TypeForm</code> type is indeed never an &quot;actual union type&quot;; <code>TypeForm[T | S]</code> represents the set of runtime objects that can result from a valid type expression for the type <code>T | S</code>. The type <code>types.UnionType</code> overlaps with <code>TypeForm[T | S]</code>; the type <code>T | S</code> is disjoint from the type <code>TypeForm[T | S]</code>.)</p>
<p>This kind of contextual type evaluation is something we don't support yet, but will need to. It comes up in other cases besides <code>TypeForm</code> as well; Eric Traut has some good examples at https://discuss.python.org/t/pep-747-typeexpr-type-hint-for-a-type-expression/55984/67</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 21:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-07 21:55</div>
            <div class="timeline-body"><p>The call-checking support will require changes to handle contextual type evaluation; we'll need to match arguments to parameters before inferring argument types. I felt that it still made sense to do the simpler implementation now, and adjust it when we add contextual inference support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-07 21:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_vendored/vendor/typeshed/stdlib/knot_extensions.pyi</code>:21 on 2025-01-07 21:59</div>
            <div class="timeline-body"><blockquote>
<p>Your functions aren't the first example of this: the existing <code>typing.cast</code> function (which we haven't yet implemented support for, but will need to) also requires its first argument to be interpreted as a type expression rather than a value expression.</p>
</blockquote>
<p>similar for <code>assert_type</code> as well</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 22:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1795 on 2025-01-07 22:12</div>
            <div class="timeline-body"><p>We currently do not emit a (proper) diagnostic for calls like <code>reveal_type()</code> or <code>static_assert()</code> (this is a pre-existing issue, pre-dating call-signature checking). I'll look into that tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-07 22:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1800 on 2025-01-07 22:16</div>
            <div class="timeline-body"><p>This is not quite consistent with what the single-argument functions do. We probably shouldn't use <code>Type::Unknown</code> for the return type, but rather for the <code>ty_a</code> and <code>ty_b</code>, in case the <code>[â€¦, â€¦]</code> pattern doesn't match. I don't fully understand yet when that happens (i.e.: when would <code>binding.parameter_tys()</code> ever return something that doesn't match the expected signature, or when would <code>.first_parameter()</code> return <code>None</code> for a single-argument function?). Maybe only when there is an inconsistency between stubs and the expected number of arguments here?</p>
<p>I'll look into that tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 22:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1800 on 2025-01-07 22:28</div>
            <div class="timeline-body"><p><code>binding.parameter_tys()</code> is a slice of <code>Type&lt;'db&gt;</code> (not <code>Option&lt;Type&lt;'db&gt;&gt;</code>), of length equal to the number of parameters of the function (regardless of the number of arguments provided in the call). <code>binding.first_parameter()</code> (which should probably be <code>binding.first_parameter_ty()</code> instead, or we shouldn't even have a special-case method at all for the first parameter) will only return <code>None</code> if the function being called doesn't take any parameters at all. If it has a first parameter, but the call didn't supply an argument for it, we'll get <code>Unknown</code>.</p>
<p>Currently <code>parameter_tys</code> always reflects the provided arguments, even if they aren't valid for the annotated parameter type (in which case you'll get an error, but still the actual - invalid - argument type in <code>parameter_tys</code>). It also doesn't reflect defaults; if the argument is not provided, you'll get Unknown, even if the parameter has a default. Neither of these are a design choice that I feel strongly about; I just didn't need anything different, and so I kept it simple. It would be easy to change either of these behaviors in <code>bind_call</code>, if that would make <code>parameter_tys</code> more useful in practice. I didn't get a lot of experience using <code>parameter_tys</code>, since <code>reveal_type</code> was the only use case I had.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:134 on 2025-01-07 23:26</div>
            <div class="timeline-body"><p>The use of &quot;enforce&quot; is a bit confusing to me here. It seems to me that <code>static_assert</code> can be used to <em>check</em> red-knot's understanding of narrowing constraints, but I'm not sure in what sense it &quot;enforces&quot; them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:145 on 2025-01-07 23:27</div>
            <div class="timeline-body"><p>Maybe we don't need to include the <code>utm_source</code> in this link ðŸ˜†</p>
<pre><code class="language-suggestion">&lt;https://docs.python.org/3/library/stdtypes.html#truth-value-testing&gt;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:148 on 2025-01-07 23:29</div>
            <div class="timeline-body"><p>Seems like it would be useful to give a couple explicit examples of statically-known-truthy cases as well (e.g. <code>static_assert(True)</code>, <code>static_assert(5)</code>...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1785 on 2025-01-07 23:37</div>
            <div class="timeline-body"><p>Is this line necessary? Shouldn't the stub return type suffice here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1800 on 2025-01-07 23:39</div>
            <div class="timeline-body"><p>In this case I think the fallback case is just unreachable (unless the stub for <code>is_equivalent_to</code> were changed to not have exactly two parameters).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-07 23:45</div>
            <div class="timeline-body"><p>In order to support <code>typing.cast</code> and <code>typing.assert_type</code>, I think we'll need a finer-grained version of this that allows some &quot;type&quot; and some &quot;value&quot; arguments of the same function. Doesn't have to happen in this PR, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:272 on 2025-01-07 23:48</div>
            <div class="timeline-body"><p>Is there value in separating this case from the one immediately below? I found this surprising when I saw it in the tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:308 on 2025-01-07 23:50</div>
            <div class="timeline-body"><p>Shouldn't this case be unreachable, because <code>truthiness</code> must be either always-false, ambiguous, or always-true, and we won't create a <code>CallOutcome::StaticAssertionError</code> if its always-true? I would be inclined to explicitly mark it as unreachable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/diagnostic.rs</code>:684 on 2025-01-07 23:51</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Makes sure that the argument of `static_assert` is statically known to be true.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:105 on 2025-01-07 23:52</div>
            <div class="timeline-body"><p>The db is already available as <code>context.db()</code>, we shouldn't need it as a separate argument.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:177 on 2025-01-07 23:52</div>
            <div class="timeline-body"><p>Same as above, the <code>InferContext</code> already gives us the db.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2011 on 2025-01-07 23:54</div>
            <div class="timeline-body"><p>Why do we need to add a <code>db</code> argument to a method of <code>TypeInferenceBuilder</code>? It should already be available as <code>self.db()</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2493 on 2025-01-07 23:55</div>
            <div class="timeline-body"><p>As mentioned elsewhere, we'll need per-argument granularity on this soon, but it doesn't have to be in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-07 23:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-07 23:59</div>
            <div class="timeline-body"><p>The integration/flattening looks great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 00:08</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    const fn takes_type_expression_arguments(self) -&gt; bool {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:307 on 2025-01-08 00:09</div>
            <div class="timeline-body"><p>I think rustfmt may have given up on this file at this point because of all the macro usage ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3226 on 2025-01-08 00:14</div>
            <div class="timeline-body"><p>usually I'm all for an exhaustive <code>match</code>, but here I think it's probably fine to simplify a little bit -- since all constraint functions are guaranteed to be wrapped in the first variant, there's probably nothing gained here by explicitly listing all the other variants</p>
<pre><code class="language-suggestion">            _ =&gt; None,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-08 00:15</div>
            <div class="timeline-body"><p>Very nice! A couple of nitpicks on top of Carl's comments. And it still needs an edit to https://github.com/astral-sh/ruff/blob/main/.github/workflows/sync_typeshed.yaml to make sure we don't lose the <code>knot_extensions</code> stub file in the next automated typeshed sync</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 05:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:145 on 2025-01-08 05:23</div>
            <div class="timeline-body"><p>Hahaha</p>
<p>Credit where credit is due!</p>
<p>For reference, I literally asked something like &quot;where is ... specified in the Python documentation&quot;, because I couldn't find it otherwise. And it worked! Didn't notice it was sneaky and added a UTM parameter though ðŸ˜€</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 07:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:148 on 2025-01-08 07:02</div>
            <div class="timeline-body"><p>I think I did that for all variants here except for <code>static_assert(True)</code> because that is already covered above. But we have:</p>
<pre><code class="language-py">static_assert(1)
# â€¦
static_assert((0,))
# â€¦
static_assert(&quot;a&quot;)
# â€¦
static_assert(b&quot;a&quot;)
</code></pre>
<p>But I guess it doesn't hurt to add <code>static_assert(True)</code> here again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 07:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1800 on 2025-01-08 07:04</div>
            <div class="timeline-body"><p>Don't we need to be careful with <code>unreachable!(â€¦)</code> because someone might supply a custom typeshed?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 07:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:134 on 2025-01-08 07:35</div>
            <div class="timeline-body"><p>My idea was the following. I could see how a developer who makes use of a narrowed type in a particular (complicated) branch might want to add a static assertion like this at the top of the branch to get better error messages in case <em>something</em> changes that would result in a non-narrowed type.</p>
<p>This wouldn't necessarily be limited to changes in the type checker, but also to changes in the code. Take this example:</p>
<pre><code class="language-py">def f(x: int):
    if x != 0:
        static_assert(x != 0)

        # make use of the fact that x is statically known to be nonzero.
</code></pre>
<p>If a fellow developer comes along and makes a seemingly &quot;stylistic&quot; change to <code>0 != x</code> (YODA style), that static assertion would fail. And that failure would potentially provide a better feedback to the developer making that change than whatever diagnostic we would emit in the body of that branch due to the <code>int &amp; ~Literal[0]</code> -&gt; <code>int</code> change.</p>
<p>So in this sense, the static assertion helps &quot;enforce&quot; that narrowing constraint. It's not so much used to test a type checkers understanding of narrowing, it's more like a guard that helps to make sure that (seemingly innocuous) changes to the code don't lead to a non-narrowed type in that branch.</p>
<p>That said, I'm not sure if someone would actually do this. And I might have a slightly wrong understanding of the word &quot;enforce&quot;, so I'm happy to change this sentence to whatever we think is more appropriate. Or to remove this entire example.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 07:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:134 on 2025-01-08 07:40</div>
            <div class="timeline-body"><blockquote>
<p>And that failure would potentially provide a better feedback to the developer</p>
</blockquote>
<p>That actually makes me think: if we see <code>static_assert</code> as a useful tool for our users, should we support an optional second argument of type <code>LiteralString</code> for user-defined error messages? Like C++'s <a href="https://en.cppreference.com/w/cpp/language/static_assert"><code>static_assert</code></a>?</p>
<p>Edit: I went ahead and implemented this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 07:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1785 on 2025-01-08 07:42</div>
            <div class="timeline-body"><p>No, it's not. Thanks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:307 on 2025-01-08 07:50</div>
            <div class="timeline-body"><p>Yes :frowning_face:. I formatted it manually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 07:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 08:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 08:55</div>
            <div class="timeline-body"><p>I think this method will break even further when functions accepting <code>TypeForm</code>s are added to the mix:</p>
<pre><code class="language-python"># User-defined; no hardcoding
def f(a: int, b: str, v: TypeForm[T]) -&gt; list[T]: ...
</code></pre>
<p>Granted, <code>TypeForm</code> is not a thing yet, but it likely will, given how the type system has been growing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 09:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1800 on 2025-01-08 09:04</div>
            <div class="timeline-body"><blockquote>
<p>which should probably be <code>binding.first_parameter_ty()</code> instead, or we shouldn't even have a special-case method at all for the first parameter</p>
</blockquote>
<p>I changed <code>first_parameter_ty</code> to <code>one_parameter_ty()</code> (with a change to the logic as well), and added <code>two_parameter_tys()</code>. These are intended as slightly more easy to use companions to <code>parameter_tys()</code> for functions that expect exactly one parameter or exactly two parameters.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 09:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:272 on 2025-01-08 09:11</div>
            <div class="timeline-body"><p>I wanted a slightly easier to understand message for the (presumably most common) case where your assertion condition actually evaluates to <code>False</code>. Like in a comparison that's simply not true.</p>
<p>And I didn't want to re-use this message (&quot;evaluates to <code>False</code>&quot;) for cases like <code>static_assert(&lt;expression of type None&gt;)</code> because it could be confusing, and because I wanted to add more context (show the actual type in the message), which seems not very helpful for cases where the type is <code>Literal[False]</code>.</p>
<p>I can see how that would be slightly confusing if you see those side-by-side in the tests, but do you think that any of these messages is actually confusing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 09:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:308 on 2025-01-08 09:31</div>
            <div class="timeline-body"><p>I added a new <code>StaticAssertionErrorKind</code> enum that describes the various cases. This allows us to remove this case without having to use <code>unreachable!</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 09:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2493 on 2025-01-08 09:33</div>
            <div class="timeline-body"><p>Ok, I'll leave this as a follow-up task.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 10:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 10:45</div>
            <div class="timeline-body"><blockquote>
<p>I think this method will break even further</p>
</blockquote>
<p>I'm not sure that's true? If we see a call like <code>f(1, &quot;a&quot;, int | str)</code>, we will eventually need to check if <code>int | str</code> is a valid type expression. And for this purpose, we <em>may</em> want to call <code>infer_type_expression</code> on that <code>int | str</code> AST node. But <em>inside</em> the function <code>f</code>, the type of <code>v</code> will not be <code>int | str</code> (which is what <code>infer_type_expression</code> returns). It will be a TypeForm object instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 10:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 10:52</div>
            <div class="timeline-body"><p>I think this is not a Python typing question, it's an implementation detail. <code>assert_type(val, typ)</code> is a good example. In order to implement it, it makes sense to call <code>infer_expression</code> on <code>val</code>, and <code>infer_type_expression</code> on <code>typ</code>. But if I understand things correctly, this has nothing to do with whether or not <code>typ</code> is annotated as <code>Any</code> or as <code>TypeForm</code>.</p>
<p>And for your example function <code>f</code>, if we call <code>f(â€¦, â€¦, int | str)</code>, we would never infer <code>v</code> to be of type <code>int | str</code>, no matter how it is annotated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 10:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 10:52</div>
            <div class="timeline-body"><p>https://pyright-play.net/?enableExperimentalFeatures=true&amp;code=MQAgDgngTglg5gCwC4C4RQKZgPZSQWRgGciYA7OfbAEwFcAbDAZW1qgGMMBeAMwEN6RDAChhPKNgC2IJBDDk4AfQwAPJBjKlsmkDEk48IACpyMAMVyTR1DDxA8A2kYC6ACj5pySADQgARmhESFC%2BAG5oJmDmlk7OAJQgALQAfCD0xEixKMIguegYoRgCirJRrqFxonn5SGxkIA7OomKuAIy%2BAER8Hb5eIAA%2BIEFQcUA</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 11:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>.github/workflows/sync_typeshed.yaml</code>:52 on 2025-01-08 11:27</div>
            <div class="timeline-body"><p>This could probably be something like</p>
<pre><code class="language-suggestion">          (
            echo &quot;# Patch applied for red_knot:&quot;
            echo &quot;knot_extensions: 3.0-&quot;
          ) &gt;&gt; ruff/crates/red_knot_vendored/vendor/typeshed/stdlib/VERSIONS
</code></pre>
<p>but I kept it simple for now, as I don't know what's supported in the standard shell</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-01-08 11:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-01-08 11:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-08 11:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-08 11:53</div>
            <div class="timeline-body"><p>Decided to merge this now to unblock work on #15194. Feel free to add post-merge comments and I will address them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_api.md</code>:134 on 2025-01-08 15:17</div>
            <div class="timeline-body"><p>I understand now what you mean by &quot;enforce&quot;, from the developer's perspective; this all seems fine to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1800 on 2025-01-08 15:21</div>
            <div class="timeline-body"><blockquote>
<p>Don't we need to be careful with <code>unreachable!(â€¦)</code> because someone might supply a custom typeshed?</p>
</blockquote>
<p>Ah yes, good point!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 15:29</div>
            <div class="timeline-body"><blockquote>
<p>But if I understand things correctly, this has nothing to do with whether or not <code>typ</code> is annotated as <code>Any</code> or as <code>TypeForm</code>.</p>
</blockquote>
<p>This doesn't quite make sense to me; I'm not sure I understand what you're saying in your comments here.</p>
<p>In the current type system, without <code>TypeForm</code>, certain functions have to be special-cased so that we know (some of) their arguments must be valid type expressions (and we know to infer them as type expressions, so we have the right types for special-casing the behavior of those functions, e.g. their return type, or some special diagnostics they might emit). These include specified functions such as <code>typing.cast</code> and <code>typing.assert_type</code>, as well as red-knot-specific functions introduced in this PR.</p>
<p>In this PR, we only handle the case that all of a function's parameters should be inferred as type expressions. For <code>typing.cast</code> and <code>typing.assert_type</code>, in the short term, we will have to expand this special-casing so we can mark only some parameters as type expressions.</p>
<p>In the longer term, assuming PEP 747 is accepted, <code>TypeForm</code> will generalize this, so we should be able to rely only on the type annotations of the function parameters to decide which arguments should be inferred as type expressions. If the parameter is annotated as a <code>TypeForm</code>, that will be sufficient for us to know that we need to infer any argument for that parameter as a type expression. Once <code>TypeForm</code> exists and is used in stubs, some functions that are currently special-cased will no longer require special-casing at all (e.g. <code>typing.cast</code> can be spelled as <code>def cast[T](typ: TypeForm[T], expr: object) -&gt; T: ...</code> and needs no additional handling), while others (e.g. <code>is_subtype_of</code>) will still require special handling in the type checker to get the correct return type, but will no longer require explicit special-casing to decide which parameters to infer as type expressions.</p>
<p>So I do think this has something to do with whether <code>typ</code> is annotated as <code>Any</code> or <code>TypeForm</code>. I wouldn't phrase it as &quot;<code>TypeForm</code> will break <code>takes_type_expression_arguments</code>&quot;, but rather as &quot;<code>TypeForm</code>, plus contextual type inference of function parameters, will eventually make <code>takes_type_expression_arguments</code> unnecessary.&quot;</p>
<p>Am I missing your point?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 15:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:272 on 2025-01-08 15:32</div>
            <div class="timeline-body"><p>Nope, I don't think either message is confusing on its own. And I see the rationale for splitting them; in particular, that the &quot;actual type&quot; context is very useful for the &quot;is falsy&quot; case, but is redundant/noisy for the &quot;is <code>Literal[False]</code>&quot; case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-08 19:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 19:44</div>
            <div class="timeline-body"><p>Sorry for the confusion I caused here. I think it was mostly just miscommunication (by me), and we probably all agree. To summarize (thank you @carljm for the proper wording):</p>
<ul>
<li>For functions like <code>is_fully_static</code>/<code>cast</code>/<code>assert_type</code> but also <code>f</code> in @InSyncWithFoo's example, we will most definitely want to call <code>infer_type_expression</code> on the (relevant) arguments in order to ensure that they represent valid type expressions. For the example above, if we see <code>f(â€¦, â€¦, int | str)</code>, we will then get the answer <code>int | str</code> (the actual type) from calling <code>infer_type_expression</code> (instead of <code>typing.UnionType</code>, which is what we would get if we call `infer_expression).</li>
<li>For (future) functions annotated with <code>TypeForm</code>, we will then wrap the result of that call (<code>int | str</code>) in <code>TypeForm</code> to get a new type, <code>TypeForm[int | str]</code>, which is what the inferred parameter type of <code>v</code> would ideally be for this call.</li>
<li>As long as we don't have <code>TypeForm</code>, we need to hard-code the knowledge of whether to call <code>infer_expression</code> or <code>infer_type_expression</code> <em>somewhere</em>. Since we don't have <code>TypeForm</code> implemented yet, we currently set the parameter type for special functions like <code>is_fully_static</code>/<code>cast</code>/<code>assert_type</code> to <code>int | str</code> â€” which is wrong! â€” and which was probably at the core of the confusion here. Having this type as a parameter type is <em>useful</em> tough in order to <em>implement</em> these functions in Rust.</li>
<li>Once we have <code>TypeForm</code>, we can make use of it to remove this hard-coded knowledge. Instead of receiving <code>int | str</code> directly in the Rust implementation, we would then receive <code>TypeForm[int | str]</code> and would need to unwrap that inner type first in order to implement those functions.</li>
<li>@carljm pointed out that a possible route for us would be to implement <code>TypeForm</code> &quot;right now&quot;, but this is something that we're going to discuss internally first.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2025-01-08 20:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 20:56</div>
            <div class="timeline-body"><blockquote>
<p>Instead of receiving <code>int | str</code> directly in the Rust implementation, we would then receive <code>TypeForm[int | str]</code> and would need to unwrap that inner type first in order to implement those functions.</p>
</blockquote>
<p>Shouldn't that be <code>types.UnionType &amp; TypeForm[int | str]</code> instead? A similar example:</p>
<pre><code class="language-python">print(type(type[int | str]))        # types.GenericAlias
print(type(type[int] | type[str]))  # types.UnionType

reveal_type(is_equivalent_to(type[int | str], type[int] | type[str]))
# True, `type` is distributive over unions.

# Some function in a runtime type inspection library
def f(v: types.UnionType): ...

f(type[int] | type[str])            # fine
f(type[int | str])                  # not fine
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3257 on 2025-01-08 21:24</div>
            <div class="timeline-body"><blockquote>
<p>Shouldn't that be <code>types.UnionType &amp; TypeForm[int | str]</code> instead</p>
</blockquote>
<p>Sure, good observation, this would also be correct. In principle, inferring intersections could replace contextual type inference entirely, but in practice we won't want to try <code>infer_type_expression</code> blindly on every single expression in case maybe it could be a <code>TypeForm</code> type, so we'll want to use contextual inference simply for performance reasons.</p>
<p>We can make your example work just with contextual type inference, without inferring an intersection; if we see the argument <code>type[int] | type[str]</code> in a <code>types.UnionType</code> context we would infer it as <code>types.UnionType</code>, if we see it in a <code>TypeForm</code> context we infer it as <code>TypeForm[type[int] | type[str]]</code> (or equivalently <code>TypeForm[type[int | str]]</code>). If we are calling a function with an annotated parameter, it really doesn't matter, either way it will pass the assignable test, and the typing of the function's body will depend only on the annotated type anyway.</p>
<p>Inferring the intersection could be useful to get a more precise local inferred type for an annotated assignment, though. That way we could make code like this work:</p>
<pre><code class="language-py">def takes_any_union(u: types.UnionType): ...
def takes_a_typeform(t: TypeForm[int | str]): ...

x: TypeForm = int | str  # we could infer `TypeForm[int | str]`, or `TypeForm[int | str] &amp; types.UnionType` here

takes_a_typeform(x)
takes_any_union(x)  # this call will error unless we infer the intersection

</code></pre>
<p>Note that we can't just say in general that a <code>TypeForm</code> of a union type is always assignable to <code>types.UnionType</code>, because the union <code>TypeForm</code> could have originated from <code>A | B</code> or <code>typing.Union[A, B]</code>, which spell the same type (and thus result in the same <code>TypeForm[A | B]</code> type), but the former would be a <code>types.UnionType</code> and the latter would instead be a <code>typing._UnionGenericAlias</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-08 21:24</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:08:40 UTC
    </footer>
</body>
</html>
