```yaml
number: 2115
title: Implementing TRY400
type: pull_request
state: merged
author: Flowake
labels: []
assignees: []
merged: true
base: main
head: tryceratops-TC400
created_at: 2023-01-23T22:57:33Z
updated_at: 2023-01-26T00:42:19Z
url: https://github.com/astral-sh/ruff/pull/2115
synced_at: 2026-01-12T04:52:00Z
```

# Implementing TRY400

---

_Pull request opened by @Flowake on 2023-01-23 22:57_

Currently implementing TRY400 (#2056)

I cannot find the documentation for the ast parser used by ruff, where could I find it ? That would make my life easier.

---

_Comment by @charliermarsh on 2023-01-24 00:04_

We use the RustPython AST, defined here: https://github.com/RustPython/RustPython/blob/main/compiler/ast/src/ast_gen.rs

It's actually generated by reading from the Python ASDL files, so it's pretty similar to the CPython AST.

---

_Comment by @Flowake on 2023-01-24 22:57_

I have translated the raw python logic from the tryceratops library and I copied other rules to handle the reporting.

I think the violation might be triggered for any method "error" used in the except block. I would need to ensure that the object that the method is called on is a logger, but I'm not sure about how to do that.

---

_Comment by @charliermarsh on 2023-01-25 00:44_

Yeah, we don't have any way to know for sure that the object is a logger. Like the original plugin, this will raise on any `.error(...)` call. The best we can do, probably, is trade false negatives for false positives by flagging specific cases, like `logging.error(...)` or `logger.error(...)` (that is, literally match on the names `logging` and `logger`).

---

_Comment by @charliermarsh on 2023-01-25 00:44_

(Or we just accept this limitation, given that it exists "upstream".)

---

_Comment by @Flowake on 2023-01-25 07:20_

I think sticking to the "upstream" plugin when there are no clear better alternatives for the implementation is preferable.

If you're ok with the code I can make this PR ready for review.

---

_Marked ready for review by @Flowake on 2023-01-25 10:13_

---

_Comment by @Flowake on 2023-01-25 19:24_

I fixed the last issue, it's ready for review !

---

_Comment by @charliermarsh on 2023-01-25 19:37_

Sounds good. I'll give this a look today and merge.

---

_Comment by @Flowake on 2023-01-25 22:56_

I was reading about other rules and their auto fixing part and was wondering what is the approach in this case: we know that the rule will have false negatives, which an autofix would definitely break.

If we want to auto fix this rule, we might actually switch to checking specific cases (like logging and logger) to ensure we only have false positives and then autofix it by changing `.error` to `.exception`. But if there was a custom object called `logger` with an `error` method and no `exception` method, it would also produce broken code.

---

_Comment by @charliermarsh on 2023-01-25 23:00_

I think this one is too uncertain to allow an autofix. The one case we _could_ fix is, if the call is `import logging; logging.error`, then we have the ability to verify that call path and fix it. But any other case is likely too dangerous.

---

_@charliermarsh reviewed on 2023-01-26 00:41_

---

_Review comment by @charliermarsh on `src/rules/tryceratops/mod.rs`:23 on 2023-01-26 00:41_

Quick tip for the future: in order to get the fixture to run on CI etc., we need to add a test case here via this macro.

---

_Review comment by @charliermarsh on `src/rules/tryceratops/rules/error_instead_of_exception.rs`:26 on 2023-01-26 00:42_

I decided to make this a bit stricter. I'm just erring on the side of false negatives these days a little bit, especially for checks like this that lack strong static verifiability. Sorry for the last minute change!

---

_@charliermarsh reviewed on 2023-01-26 00:42_

---

_Merged by @charliermarsh on 2023-01-26 00:42_

---

_Closed by @charliermarsh on 2023-01-26 00:42_

---
