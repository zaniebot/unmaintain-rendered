<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement `blank_line_after_nested_stub_class` preview style - astral-sh/ruff #9155</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement <code>blank_line_after_nested_stub_class</code> preview style</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/9155">#9155</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2023-12-16 01:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>This PR implements the <code>blank_line_after_nested_stub_class</code> preview style in the formatter.</p>
<p>The logic is divided into 3 parts:</p>
<ol>
<li>In between preceding and following nodes at top level and nested suite</li>
<li>When there&#x27;s a trailing comment after the class</li>
<li>When there is no following node from (1) which is the case when it&#x27;s the last or the only node in a suite</li>
</ol>
<p>We handle (3) with <code>FormatLeadingAlternateBranchComments</code>.</p>
Test Plan
<ul>
<li>Add new test cases and update existing snapshots</li>
<li>Checked the <code>typeshed</code> diff</li>
</ul>
<p>fixes: #8891</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-16 01:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-16 01:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-16 01:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/tests/snapshots/format@stub_files__suite.pyi.snap</code>:322 on 2023-12-16 01:05</div>
            <div class="timeline-body"><p>This seems like a bug in Black&#x27;s implementation: <a href="https://github.com/psf/black/issues/4113">psf/black#4113</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-12-16 01:13</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Formatter (stable)
<p>ℹ️ ecosystem check <strong>encountered format errors</strong>. (no format changes; 1 project error)</p>
<a href="https://github.com/openai/openai-cookbook">openai/openai-cookbook</a> (error)
<p>

<pre><code>warning: Detected debug build without --no-cache.
error: Failed to parse examples/dalle/Image_generations_edits_and_variations_with_DALL-E.ipynb:3:7:8: Unexpected token &#x27;prompt&#x27;
</code></pre>
</p>


Formatter (preview)
<p>ℹ️ ecosystem check <strong>detected format changes</strong>. (+5 -0 lines in 5 files in 2 projects; 1 project error; 40 projects unchanged)</p>
<a href="https://github.com/python/typeshed">python/typeshed</a> (+4 -0 lines across 4 files)
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href="https://github.com/python/typeshed/blob/c50a641fc8d37e873b325c234d3e1c2fa68db31d/stdlib/inspect.pyi#L430">stdlib/inspect.pyi~L430</a></p>
<pre><code>         varargs: str | None
         keywords: str | None
         defaults: tuple[Any, ...]
+
     def getargspec(func: object) -&gt; ArgSpec: ...
 
 class FullArgSpec(NamedTuple):
</code></pre>
<p><a href="https://github.com/python/typeshed/blob/c50a641fc8d37e873b325c234d3e1c2fa68db31d/stdlib/sqlite3/dbapi2.pyi#L450">stdlib/sqlite3/dbapi2.pyi~L450</a></p>
<pre><code> 
 @final
 class _Statement: ...
+
 class Warning(Exception): ...
 
 if sys.version_info &gt;= (3, 11):
</code></pre>
<p><a href="https://github.com/python/typeshed/blob/c50a641fc8d37e873b325c234d3e1c2fa68db31d/stubs/gevent/gevent/events.pyi#L97">stubs/gevent/gevent/events.pyi~L97</a></p>
<pre><code> 
 @implementer(IGeventWillPatchEvent)
 class GeventWillPatchEvent(GeventPatchEvent): ...
+
 class IGeventDidPatchEvent(IGeventPatchEvent): ...
 
 @implementer(IGeventWillPatchEvent)
</code></pre>
<p><a href="https://github.com/python/typeshed/blob/c50a641fc8d37e873b325c234d3e1c2fa68db31d/stubs/pyserial/serial/tools/list_ports_windows.pyi#L34">stubs/pyserial/serial/tools/list_ports_windows.pyi~L34</a></p>
<pre><code>         ClassGuid: ctypes._CField[Incomplete, Incomplete, Incomplete]
         DevInst: ctypes._CField[Incomplete, Incomplete, Incomplete]
         Reserved: ctypes._CField[Incomplete, Incomplete, Incomplete]
+
     PSP_DEVINFO_DATA: type[ctypes._Pointer[SP_DEVINFO_DATA]]
     PSP_DEVICE_INTERFACE_DETAIL_DATA = ctypes.c_void_p
     setupapi: ctypes.WinDLL
</code></pre>
</p>

<a href="https://github.com/reflex-dev/reflex">reflex-dev/reflex</a> (+1 -0 lines across 1 file)
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<p><a href="https://github.com/reflex-dev/reflex/blob/3ff88390c2bf63ff61010243b4f8726cf63f2ebc/reflex/config.pyi#L47">reflex/config.pyi~L47</a></p>
<pre><code> class Config(Base):
     class Config:
         validate_assignment: bool
+
     app_name: str
     loglevel: constants.LogLevel
     frontend_port: int
</code></pre>
</p>

<a href="https://github.com/openai/openai-cookbook">openai/openai-cookbook</a> (error)
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<pre><code>warning: Detected debug build without --no-cache.
error: Failed to parse examples/dalle/Image_generations_edits_and_variations_with_DALL-E.ipynb:3:7:8: Unexpected token &#x27;prompt&#x27;
</code></pre>
</p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/konstin">@konstin</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-16 02:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/charliermarsh">@charliermarsh</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-16 02:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:542 on 2023-12-16 02:34</div>
            <div class="timeline-body"><p>Should this also apply if the class is nested in a if/while or any other control flow block?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-12-16 02:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> approved on 2023-12-18 08:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-12-21 23:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-01-10 16:45</div>
            <div class="timeline-body"><p>@dhruvmanila what&#x27;s the status of this PR? Also note that there have been some recent changes in Black. It might be worth double checking Black&#x27;s tests again to ensure we match the formatting precisely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-01-25 11:42</div>
            <div class="timeline-body"><p>Here&#x27;s an update regarding this preview style implementation in Ruff:</p>
<p>tldr; there are bunch of edge cases where it seems to be difficult to add support ...</p>
What&#x27;s working today:
1
<p>Cases when the class definition is followed by another statement at the same indent level. This is to say that in a suite, the preceding and following value is set. Why is this easier? Because <a href="https://github.com/astral-sh/ruff/blob/86a5375e04b296ca3b6e1717ee07009cf5977930/crates/ruff_python_formatter/src/statement/suite.rs#L190">the loop</a> takes care of a lot of conditions.</p>
<p>For example, in the following code snippet there are 2 statements in a suite which is the body of the <code>Top</code> class. Here, the preceding would be <code>Nested1</code> class and following would be the assignment statement. Because we have the context of the siblings, it&#x27;s easier to find out if the class needs an empty line or not.</p>
<pre><code>class Top:
	class Nested1:  # &lt;- statement 1
		pass
	foo = 1  # &lt;- statement 2
</code></pre>
2
<p>Some other cases which works today is where the class is followed by a trailing comment. This is then handled by the class formatting as then it doesn&#x27;t matter if there&#x27;s any other statement following the class or not as we&#x27;ll always need to add an empty line between the class and the comment. For example,</p>
<pre><code>class Top:
	class Nested1:
		pass
	# comment
</code></pre>
<p>This will be handled in <code>empty_lines_before_trailing_comments</code> builder.</p>
Problematic cases
<p>Note that some of the following cases have a workaround in the PR but I&#x27;m not fully convinced with the implementation which is why they&#x27;ve been put in this section.</p>
<p>The main type of case where there are problems are the ones where the class definition is the last statement in the suite. For example,</p>
1
<pre><code>class Top:
	class Nested:
		pass
foo = 1
</code></pre>
<p>Here, <a href="https://github.com/astral-sh/ruff/blob/86a5375e04b296ca3b6e1717ee07009cf5977930/crates/ruff_python_formatter/src/statement/suite.rs#L190">the loop</a> will never be executed because there&#x27;s just 1 statement in the suite. This means that we need to have a special case implementation for the last statement in the suite. This needs to account for a lot of other conditions to make the decision of whether to add an empty line or not:</p>
<p>Is there a class in the parent suite which already added an empty line? If so, then we don&#x27;t need to add another empty line.</p>
<pre><code>class Top:
    class Nested11:
        class Nested12:
            pass
    class Nested21:
        pass
</code></pre>
<p>Here, the <code>Nested11</code> class will add an empty line. Now, the <code>Nested12</code> class should not be adding an empty line otherwise there&#x27;ll be 2 empty lines. <strong>This is solved in this PR</strong> by thinking it in a different way. Instead of the <code>Nested11</code> class being responsible for adding an empty line, we&#x27;ll make <code>Nested12</code> class responsible for it. This is to say that the innermost class should be responsible to add an empty line. Why? Because as a parent it&#x27;s easier to traverse through the children to check this condition:</p>
<pre><code>/// Checks if the last child of the given node is a class definition without a
/// trailing comment.
pub(crate) fn is_last_child_a_class_def(node: AnyNodeRef&lt;&#x27;_&gt;, f: &amp;PyFormatter) -&gt; bool {
    let comments = f.context().comments();
    std::iter::successors(node.last_child_in_body(), AnyNodeRef::last_child_in_body)
        .take_while(|last_child| !comments.has_trailing_own_line(*last_child))
        .any(|last_child| last_child.is_stmt_class_def())
}
</code></pre>
<p>But, this then creates another problem. Take the following code as an example:</p>
<pre><code>if a:
	class Nested:
		pass
else:
	pass
</code></pre>
<p>Here, the problem is that the new logic will add an empty line after the <code>Nested</code> class which will give us:</p>
<pre><code>if a:
	class Nested:
		pass

else:
	pass
</code></pre>
<p>Now, the same logic will try to <em>preserve</em> the empty line by adding the IR element in the same position. But while formatting the <code>else</code> block, the <code>FormatLeadingAlternateBranchComments</code> formatter sees that there&#x27;s an empty line before the <code>else</code> block which it tries to maintain by adding an empty line IR element. Thus, two empty line elements are added which creates an unstable formatting.</p>
2
<p>When a comment is not trailing to the class definition but actually to one of the statements in the parent suite:</p>
<pre><code>if top1:
    class Nested:
        pass
# comment
if top2:
    pass
</code></pre>
3
<p>Similar to the previous case but at end of file:</p>
<pre><code>if top1:
    class Nested:
        pass
# comment
</code></pre>
Number of empty lines
<p>We also need to make sure that running the formatter multiple times doesn&#x27;t keep on adding empty lines (at max it could go to 2). This would happen when the new logic would add an empty line on the first run and then on the second run another logic sees the empty line which it then tries to maintain. This adds multiple empty line IR elements.</p>
Possible solutions
<p>Instead of looking ahead, we&#x27;ll always look behind which is to say that for the current node we need to query the absolute previous node. But we&#x27;ll have to add the logic in multiple places - suite, if, match, try, etc. Here, absolute previous in the literal sense, not just in the same indent level. For example,</p>
<pre><code>class Top:
    class Nested11:
        class Nested12:
            pass
    class Nested21:
        pass
</code></pre>
<p>Here, the previous statement for <code>Nested21</code> would be <code>Nested12</code> and not <code>Nested11</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-29 06:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:542 on 2024-01-29 06:04</div>
            <div class="timeline-body"><p>Yes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:102 on 2024-01-29 07:28</div>
            <div class="timeline-body"><p>This helps when the class is at the boundary location in nested statement:</p>
<pre><code>if foo:
    class Nested:
        pass
else:
    pass
</code></pre>
<p>The <code>FormatLeadingAlternateBranchComments</code> will be called before the <code>else</code> block formatting. Similarly for other blocks like <code>match</code>, <code>case</code>, <code>try .. except ..</code>, etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:546 on 2024-01-29 07:30</div>
            <div class="timeline-body"><p>Logic for when a class is followed by a trailing comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:496 on 2024-01-29 07:36</div>
            <div class="timeline-body"><p>It&#x27;s difficult to merge the <code>is_*_enabled &amp;&amp; *_condition</code> logic with <code>empty_line_condition</code> variable up above like so:</p>
<pre><code>    let empty_line_condition = preceding_comments.has_trailing()
        || following_comments.has_leading()
        || !stub_suite_can_omit_empty_line(preceding, following, f)
        || (is_blank_line_after_nested_stub_class_enabled(f.context())
                    &amp;&amp; blank_line_after_nested_stub_class_condition(
                        preceding.into(),
                        Some(following.into()),
                        f,
                    ))
</code></pre>
<p>The reason being that in the top level condition the boolean check is direct but in other suite kind there&#x27;s an additional check of the number of empty lines. That additional check is to <em>only</em> preserve the empty lines if they&#x27;re present while the preview style adds an empty line conditionally. So, the condition should OR the complete check which was existing earlier to complement it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:511 on 2024-01-29 07:38</div>
            <div class="timeline-body"><p>This is the core condition which checks whether we need to add an empty line between the preceding and following node or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:530 on 2024-01-29 07:39</div>
            <div class="timeline-body"><p>Class with a trailing comment is handled by <code>empty_lines_before_trailing_comments</code> builder.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:536 on 2024-01-29 07:40</div>
            <div class="timeline-body"><p>If the preceding node isn&#x27;t a class, then we check if there&#x27;s a class node as the last child node of the body of nested nodes. This nesting could be arbitrarily deep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-29 07:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-01-29 07:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:511 on 2024-01-29 13:57</div>
            <div class="timeline-body"><p>Nit: The condition is the logic inside of the function, but the function returns a value whether the condition is true.</p>
<p>That&#x27;s why I would rename the function, maybe <code>should_insert_blank_line_after_nested_class_in_stub</code>?</p>
<p>What&#x27;s unclear to me is what makes the check specific to nested classes. Isn&#x27;t it more about whether an empty line should be inserted between any two statements?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:482 on 2024-01-29 14:05</div>
            <div class="timeline-body"><p>Moving the <code>is_blank_line_after_nested_stub_class_enabled</code> into <code>blank_lines_after_nested_stub_class_condition</code> simplifies the calling code a lot</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:514 on 2024-01-29 14:05</div>
            <div class="timeline-body"><p>I prefer passing only what&#x27;s absolutely necessary. Taking a smaller type can also help to avoid borrow checker issue where it is e.g. impossible to hold on to a read-only <code>PyFormatter</code> but keeping hold of an immutable <code>context</code> or <code>comments</code> is possible</p>
<pre><code>    context: &amp;PyFormatContext,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:89 on 2024-01-29 14:14</div>
            <div class="timeline-body"><p>Do we need to check here if we&#x27;re inside a stub file?</p>
<p>Nit: A more expressive name than <code>empty_line_condition</code> would help with readability: <code>requires_blank_line</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:146 on 2024-01-29 14:18</div>
            <div class="timeline-body"><p>Is it possible to move the writting of <code>empty_line</code> out of the branches?</p>
<pre><code>        let empty_line_condition = if is_blank_line_after_nested_stub_class_enabled(f.context()) {
            self.last_node.map_or(false, |preceding| {
                blank_line_after_nested_stub_class_condition(preceding, None, f)
            })
        } else {
            false
        };

        if empty_line_condition {
            write!(f, [empty_line(), leading_comments(self.comments)])
        } else if let Some(first_leading) = self.comments.first() {
            // Leading comments only preserves the lines after the comment but not before.
            // Insert the necessary lines.
            write!(
                f,
                [
                    empty_lines(lines_before(first_leading.start(), f.context().source())),
                    leading_comments(self.comments)
                ]
            )
        } else if let Some(last_preceding) = self.last_node {
            // The leading comments formatting ensures that it preserves the right amount of lines
            // after We need to take care of this ourselves, if there&#x27;s no leading `else` comment.
            // Since the `last_node` could be a compound node, we need to skip _all_ trivia.
            //
            // For example, here, when formatting the `if` statement, the `last_node` (the `while`)
            // would end at the end of `pass`, but we want to skip _all_ comments:
            // ```python
            // if True:
            //     while True:
            //         pass
            //         # comment
            //
            //     # comment
            // else:
            //     ...
            // ```
            //
            // `lines_after_ignoring_trivia` is safe here, as we _know_ that the `else` doesn&#x27;t
            // have any leading comments.
            write!(
                f,
                [empty_lines(lines_after_ignoring_trivia(
                    last_preceding.end(),
                    f.context().source()
                ))]
            )?;
        } else {
            Ok(())
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:546 on 2024-01-29 14:20</div>
            <div class="timeline-body"><p>I think this comment would be helpful in code, maybe along an example?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:496 on 2024-01-29 14:26</div>
            <div class="timeline-body"><p>I think what would help here is to rename <code>empty_line_condition</code> into <code>preserve_empty_line</code> which is different from your check which forces empty lines.</p>
<p>I recommend moving the <code>blank_line_after_nested_stub_class_condition</code> out of the <code>match</code> and next to <code>empty_line_condition</code>, and name the variable <code>require_empty_line</code></p>
<p>I would rename <code>blank_line_after_nested_stub_class_condition</code> to <code>requires_empty_line_between_stub_file_statements</code> (not just preserving, enforcing an empty line).</p>
<p>We can then rewrite the checks in the match branches to</p>
<pre><code>if requires_empty_line || preserve_empty_line {
    empty_line.fmt(f)
}
</code></pre>
<p>which I find easier to understand.</p>
<p>Edit: Maybe better. Could we move the check into <code>stub_suite_can_omit_empty_line</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:528 on 2024-01-29 14:34</div>
            <div class="timeline-body"><p>Nit: A match in a binary expression feels very heavy. Some temporary variables could also help to document the conditions.</p>
<pre><code>            let has_decorators = !class.decorator_list.is_empty();
            let followed_by_class_or_function = match following {
                Some(AnyNodeRef::StmtClassDef(ast::StmtClassDef {
                    body,
                    decorator_list,
                    ..
                })) =&gt; !contains_only_an_ellipsis(body, comments) || !decorator_list.is_empty(),
                Some(AnyNodeRef::StmtFunctionDef(_)) | None =&gt; true,
                _ =&gt; false,
            };

            has_decorators || followed_by_class_or_function
</code></pre>
<p>I think it would be helpful to add some comments here explaining why the conditions are as they are.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-01-29 14:35</div>
            <div class="timeline-body"><p>The code changes overall look good to me. I think we can make some improvements to improve readability and extend documentation a bit.</p>
<p>I&#x27;m very surprised that there are no changed black snapshots. Do you know why that is? Are we sure we match Black&#x27;s formatting?</p>
<p>It would help reviewers if you add an example of the expected formatting (how is it different from today) with a short explanation of the preview style to the PR. I know it&#x27;s in the linked PR, but it requires multiple steps by the reviewer: Open issue, read the summary, go back to the PR, read the summary, and finally read the code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-01-29 14:44</div>
            <div class="timeline-body"><p>#9674 should ensure that black stub files with options run as stub tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-01-29 14:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:89 on 2024-01-29 14:48</div>
            <div class="timeline-body"><p>Can you explain why this special handling is required here but not for other cases for which <code>stub_suite_can_omit_empty_line</code> returns false?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/konstin">@konstin</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-01-29 14:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 11:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:546 on 2024-01-30 11:45</div>
            <div class="timeline-body"><p>I did update the docs for the function :)</p>
<p>https://github.com/astral-sh/ruff/blob/a768fc35ca1f73012ae9d76cba2eedda95c9db1e/crates/ruff_python_formatter/src/comments/format.rs#L534-L546</p>
<p>Is this what you meant?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 12:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:496 on 2024-01-30 12:38</div>
            <div class="timeline-body"><blockquote>
<p>I think what would help here is to rename <code>empty_line_condition</code> into <code>preserve_empty_line</code> which is different from your check which forces empty lines.</p>
</blockquote>
<p>I&#x27;m not sure if this is 100% correct. For top-level, if the condition is true, we always make sure that there is just one empty line. It could be that there isn&#x27;t any empty line in the source code which means we&#x27;re adding an additional empty line. But, for the nested cases, we&#x27;d only preserve any existing empty lines and limit it to 1.</p>
<blockquote>
<p>I recommend moving the <code>blank_line_after_nested_stub_class_condition</code> out of the <code>match</code> and next to <code>empty_line_condition</code>, and name the variable <code>require_empty_line</code></p>
</blockquote>
<p>Thanks, I&#x27;ll update the code accordingly.</p>
<blockquote>
<p>I would rename <code>blank_line_after_nested_stub_class_condition</code> to <code>requires_empty_line_between_stub_file_statements</code> (not just preserving, enforcing an empty line).</p>
</blockquote>
<p>Yeah, I&#x27;m going with <code>is_blank_line_required_after_nested_stub_class</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 12:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:496 on 2024-01-30 12:41</div>
            <div class="timeline-body"><blockquote>
<p>Yeah, I&#x27;m going with <code>is_blank_line_required_after_nested_stub_class</code>.</p>
</blockquote>
<p>Actually, with your other comment, I&#x27;m thinking of <code>should_insert_blank_line_after_class_in_stub_file</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 12:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:511 on 2024-01-30 12:42</div>
            <div class="timeline-body"><p>Good point. It isn&#x27;t specific to nested class. I&#x27;ll update the name.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 12:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:482 on 2024-01-30 12:43</div>
            <div class="timeline-body"><p>Thanks for pointing this out. I&#x27;ve extracted this check into a <code>require_empty_line</code> variable which I think should be similar in terms of simplification.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 14:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:89 on 2024-01-30 14:24</div>
            <div class="timeline-body"><p>This is to handle cases when a class definition is the last statement in a suite. The empty line formatting in suite is a loop which handles only for in between statements i.e., both preceding and following are present. This is required only before an alternate branch because otherwise it&#x27;ll be handled by the top-level suite formatting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 14:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:528 on 2024-01-30 14:24</div>
            <div class="timeline-body"><p>Thanks for the suggestion. I&#x27;ve added some comments with examples.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-01-30 14:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/comments/format.rs</code>:89 on 2024-01-30 14:24</div>
            <div class="timeline-body"><p>Yes, thanks for noticing that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-01-30 17:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/statement/suite.rs</code>:482 on 2024-01-30 17:04</div>
            <div class="timeline-body"><p>Yeah that helps. It might still be worth to move the check into the &quot;condition&quot; function because the check is necessary at all call-sites of that function (and leads to very long conditions)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-01-30 17:05</div>
            <div class="timeline-body"><p>Awesome. Thanks for the added documentation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-01-30 18:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-01-30 18:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-01-30 18:39</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:00:01 UTC
    </footer>
</body>
</html>
