<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Silence errors in unreachable type annotations / class bases - astral-sh/ruff #17342</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Silence errors in unreachable type annotations / class bases</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17342">#17342</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-04-10 19:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-10 19:50</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>For silencing <code>invalid-type-form</code> diagnostics in unreachable code, we use the same approach that we use before and check the reachability that we already record.</p>
<p>For silencing <code>invalid-bases</code>, we simply check if the type of the base is <code>Never</code>. If so, we silence the diagnostic with the argument that the class construction would never happen.</p>
<h2>Test Plan</h2>
<p>Updated Markdown tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-04-10 19:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-10 19:52</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">rich (https://github.com/Textualize/rich)
- error[lint:invalid-base] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:33:26: Invalid class base with type `Never` (all bases must be a class, `Any`, `Unknown` or `Todo`)
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:44:57: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-base] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:57:34: Invalid class base with type `Never` (all bases must be a class, `Any`, `Unknown` or `Todo`)
- error[lint:invalid-base] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:67:27: Invalid class base with type `Never` (all bases must be a class, `Any`, `Unknown` or `Todo`)
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:78:43: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:95:32: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:129:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:132:12: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:170:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:173:12: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:205:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:205:46: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:229:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:230:6: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:253:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:253:42: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:276:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:276:47: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:300:17: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:300:47: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:377:34: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:387:30: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:405:46: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_win32_console.py:444:44: Variable of type `Never` is not allowed in a type expression
- error[lint:invalid-type-form] /tmp/mypy_primer/projects/rich/rich/_windows.py:40:43: Variable of type `Never` is not allowed in a type expression
- Found 791 diagnostics
+ Found 766 diagnostics

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2025-04-10 19:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-04-10 19:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-04-10 19:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @sharkdp on 2025-04-10 19:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-10 20:12</div>
            <div class="timeline-body"><p>I haven't followed all the reachability discussions and I'm sorry if we discussed this before.</p>
<p>Is the explicit reachability check now required for all diagnostics? Or is it only a small subset?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-10 20:18</div>
            <div class="timeline-body"><blockquote>
<p>Is the explicit reachability check now required for all diagnostics? Or is it only a small subset?</p>
</blockquote>
<p>I hope this is the last one :smile:. I could imagine that we might need to add it to a few more isolated diagnostics, but it will not be required to check reachability for all diagnostics. That's a feature! We will still report division-by-zero, if you do <code>1 / 0</code> in an unreachable block.</p>
<p>Whether that approach truly takes us all the way, I don't know. But for now, this is my last PR w.r.t. unreachable code. This solves the last remaining TODOs in that test suite (expect for some TODOs around a new feature that would highlight/report unreachable code).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:603 on 2025-04-10 20:25</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Check if a given AST node is reachable.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:603 on 2025-04-10 20:26</div>
            <div class="timeline-body"><p>Also worth noting here that it doesn't work for arbitrary nodes? The node reachability has to have explicitly been recorded in semantic indexing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-04-10 20:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-04-10 20:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-04-10 20:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-10 20:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-11 06:20</div>
            <div class="timeline-body"><p>I'm not opposed to this approach but I've two thoughts:</p>
<ol>
<li>How would I know if I add a new rule if it needs to check/respect reachability? Should we add some documentation somewhere with some guidance on this?</li>
<li>This is not a <em>now</em> problem but I wonder how this approach will scale if we start adding lint rules.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-11 09:45</div>
            <div class="timeline-body"><p>@MichaReiser Excellent questions.</p>
<blockquote>
<ol>
<li>How would I know if I add a new rule if it needs to check/respect reachability?</li>
</ol>
</blockquote>
<p>I don't know the full answer yet. And I find it hard to formulate a general strategy.</p>
<p>If a rule detects a problem with the code that would also be there if the code was <em>not</em> unreachable, then it should report the problem in all cases (not respect reachabililty). So the following two diagnostics should be emitted in unreachable code:</p>
<pre><code class="language-py">def _():
    return
    x: str = 1  # Object of type `Literal[1]` is not assignable to `str`
    1 / 0  # Cannot divide object of type `Literal[1]` by zero
</code></pre>
<p>The cases where we need to consider reachability are all related to the fact that the rule would otherwise emit a false positive because it depends on <em>loading a symbol</em> from a place in the code that is &quot;on the other side&quot; of the &quot;reachability boundary&quot;. For example:</p>
<pre><code class="language-py">def _():
    class SomeClass: ...
    some_variable = 1

    return

    some_variable  # no unreachable-reference error here, even though `some_variable` is not visible
    x: SomeClass = SomeClass()  # no invalid-type-form error here, even though `SomeClass` is not visible
</code></pre>
<blockquote>
<ol>
<li>Should we add some documentation somewhere with some guidance on this?</li>
</ol>
</blockquote>
<p>Yes, probably. Where would you look for this information / where should I put it?</p>
<blockquote>
<p>This is not a <em>now</em> problem but I wonder how this approach will scale if we start adding lint rules.</p>
</blockquote>
<p>That is a completely reasonable concern. I don't know how this scales. For now, four (out of ~50) rules needed a special &quot;reachability treatment&quot;. Three of these rules (unresolved-reference, unresolved-attribute, unresolved-import) are very obviously related to &quot;looking up symbols&quot;. So I would argue that there is just one case (invalid-type-form) that was kind of unexpected for me. It is related to the fact that we infer a type of <code>Never</code> for symbols that are on the other side of that reachability boundary. <code>Never</code> is a very &quot;permissive&quot; type, and we use it for precisely that reason. It doesn't cause any problems in most of the rules, apparently. But invalid-type-form is special because it affects types in type-expression positions. And we do not allow a type of <code>Never</code> in a type expression context (not to be confused with a type expression that <em>represents</em> <code>Never</code>). Something like</p>
<pre><code class="language-py">from typing import Never

def _(IsThisAValidTypeExpression: Never):
    x: IsThisAValidTypeExpression  # Variable of type `Never` is not allowed in a type expression (lint:invalid-type-form)
</code></pre>
<p>So to summarize, I hope that this approach <em>does</em> scale. But I could also imagine that we find more problems as we go. And it might turn out that we need to silence <em>all</em> diagnostics in unreachable code eventually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-11 11:47</div>
            <div class="timeline-body"><p>Thanks. This explanation was very useful!</p>
<blockquote>
<p>Yes, probably. Where would you look for this information / where should I put it?</p>
</blockquote>
<p>Hmm, that's a good question. Two ideas come to my mind:</p>
<ol>
<li>Into <code>red_knot/docs/diagnostics.md</code>. We could combine it with other guidance around how to write/create diagnostics (@BurntSushi)</li>
<li><code>red_knot_python_semantics::types::diagnostics</code></li>
</ol>
<p>But I don't think there's any very obvious place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-14 10:59</div>
            <div class="timeline-body"><p>After discovering some problems with our current approach which I <a href="https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/unreachable.md#limitations-of-the-current-approach">documented here</a>, I decided to postpone the documentation of any guidelines here, as it seems likely that we need to pivot to a different strategy of silencing diagnostics in unreachable code. For now, I would suggest to simply not care about unreachable code when introducing new diagnostics (unless there are obvious false positives in the ecosystem checks).</p>
<p>I opened a new ticket so we don't forget about this: https://github.com/astral-sh/ty/issues/127</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:57:29 UTC
    </footer>
</body>
</html>
