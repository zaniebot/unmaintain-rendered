<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Eagerly normalize `type[]` types - astral-sh/ruff #15272</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Eagerly normalize <code>type[]</code> types</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15272">#15272</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-01-05 16:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR refactors <code>SubclassOfType</code> so that certain <code>type[]</code> types are eagerly normalized in our model when they are constructed:</p>
<ul>
<li><code>type[object]</code> is eagerly normalized to <code>Type::Instance(&lt;builtins.type&gt;)</code> rather than <code>Type::SubclassOf(&lt;builtins.object&gt;)</code></li>
<li><code>type[&lt;final class&gt;]</code> is eagerly normalized to <code>Type::ClassLiteral(&lt;final class&gt;)</code> rather than <code>Type::SubclassOf(&lt;final class&gt;)</code></li>
</ul>
<p>This already allows us to remove several special cases that we carve out for <code>type[object]</code>, in <code>Type::is_equivalent_to()</code> and <code>Type::is_subtype_of()</code>. The logic applied in these special cases just now falls out naturally from our handling of instance types. The approach will also make it easier to apply knowledge of <code>@final</code> classes to <code>Type::is_equivalent_to()</code>, <code>Type::is_subtype_of()</code> and <code>Type::is_disjoint_from()</code>. Without this refactor, we'd need to carefully remember to check whether the wrapped class was <code>@final</code> in every branch for <code>Type::SubclassOf</code>; with this change, however, it's no longer necessary to do so. Several TODO comments are therefore also removed as part of this PR.</p>
<h2>Details of implementation</h2>
<p>The <code>SubclassOfType</code> struct is moved to a new <code>types</code> submodule, so that it is impossible to construct instances of the struct from other modules without using the &quot;constructor&quot; function that eagerly normalizes types. The &quot;constructor&quot; function is called <code>SubclassOfType::from</code>, and is analogous to our existing methods <code>UnionType::from_elements</code> (which can return any variant of <code>Type</code>, not just <code>Type::Union</code>) and <code>TupleType::from_elements</code> (which can return <code>Type::Never</code> as well as <code>Type::Tuple()</code>). I wasn't really sure what the best name was for the &quot;constructor&quot; function, though -- I initially used <code>SubclassOfType::new()</code>, but Clippy (reasonably) complained that <code>new()</code> methods are meant to return <code>Self</code>. Suggestions are welcome!</p>
<h2>Test Plan</h2>
<ul>
<li>Existing mdtests tweaked</li>
<li>New mdtests added</li>
<li>New unit test added for <code>Type::is_singleton()</code>, ensuring that <code>type[&lt;final class&gt;]</code> is understood to be a singleton type</li>
<li><code>QUICKCHECK_TESTS=200000 cargo test -p red_knot_python_semantic -- --ignored types::property_tests::stable</code> reveals no new property test failures</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-01-05 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-01-05 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2025-01-05 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-01-05 16:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-05 16:47</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @MichaReiser removed by @MichaReiser on 2025-01-05 16:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on 2025-01-05 22:16</div>
            <div class="timeline-body"><p>What does this PR say about the problem discovered in #15271?</p>
<p>Currently <code>report_invalid_assignment()</code> is defined as:</p>
<pre><code class="language-rust">pub(super) fn report_invalid_assignment(..., declared_ty: Type, ...) {
    match declared_ty {
        Type::ClassLiteral(ClassLiteralType { class }) =&gt; {
            context.report_lint(&amp;INVALID_ASSIGNMENT, node, format_args!(
                    &quot;Implicit shadowing of class `{}`; annotate to make it explicit if this is intentional&quot;,
                    class.name(context.db())));
        }
        // ...
    }
}
</code></pre>
<p>...which seems to rely on the fact that a class definition always results in a <code>ClassLiteral</code> type being <code>declared_ty</code>.</p>
<pre><code class="language-py">from types import EllipsisType

class SomeClass: ...
#     ^^^^^^^^^
# `declared_ty`: `ClassLiteral(SomeClass)`

#                                   vvvvvvvvv `inferred_ty`: `InstanceOf(Type)` (irrelevant)
some_variable: type[EllipsisType] = type(...)
#              ^^^^^^^^^^^^^^^^^^
# `declared_ty`: previously `SubclassOf(EllipsisType)`, now `ClassLiteral(EllipsisType)`
</code></pre>
<p>No diagnostics should be emitted here, as <code>some_variable</code> is by no mean a redefinition.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-05 22:59</div>
            <div class="timeline-body"><blockquote>
<p>What does this PR say about the problem discovered in #15271?</p>
</blockquote>
<p>Yeah, I'll investigate that a bit more tomorrow. My suspicion is that it's a pre-existing issue exposed by this PR, rather than a <em>regression</em> caused by this PR, <em>per se</em>. But anyway, it's late here, so a full investigation shall have to wait :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md</code>:165 on 2025-01-05 23:40</div>
            <div class="timeline-body"><p>I think this is probably not acceptable? That is, <code>Literal[X]</code> for classes <code>X</code> is already a notation we are inventing; I don't think we can round-trip explicit user annotations of <code>type[X]</code> as <code>Literal[X]</code> in our type display, even when they are equivalent.</p>
<p>We could always display <code>Literal[X]</code> as <code>type[X]</code> in general. The downside here is that then we are conflating two types that are meaningfully different in how we handle them internally, with identical text representations.</p>
<p>I'm not sure what the alternative is, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:894 on 2025-01-06 00:01</div>
            <div class="timeline-body"><p>I think this is not correct, and it reveals the downside of the approach chosen in this PR.</p>
<p>Delegating subtyping of literal final classes to simply <code>type</code> is too much loss of precision, and it will result in weird/wrong behaviors. For example:</p>
<pre><code class="language-py">from typing import final

class A: pass

@final
class B(A): pass

a: type[A] = B
</code></pre>
<p>With the current code in this PR, this assignment wrongly generates an error,  because our test of whether <code>Literal[B] &lt;: type[A]</code> (which should be) falls back to testing if <code>type &lt;: type[A]</code> (which is not).</p>
<p>With the approach in this PR, I think to preserve the needed precision here, we have to change all the below cases for <code>Type::SubclassOf(X)</code> so they are instead explicitly <code>Type::SubclassOf(X) | Type::ClassLiteral(X)</code>, and remove this generalized fallback entirely.</p>
<p>It is attractive that with this PR we can avoid special cases for <code>Type::SubclassOf</code> with a final class. But on the flip side, it means that we need to write explicit handling for <code>Type::ClassLiteral</code> where otherwise it could have delegated to <code>Type::SubclassOf</code>. (This may still be a good trade-off!)</p>
<p>(Let's add a test for the above example. It could just be a new unit test for <code>is_subtype_of</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:918 on 2025-01-06 00:05</div>
            <div class="timeline-body"><p>Why is this change necessary / an improvement?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-06 00:10</div>
            <div class="timeline-body"><p>Haven't finished reviewing, but have to head out, so submitting what I have so far.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 00:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:918 on 2025-01-06 00:16</div>
            <div class="timeline-body"><p>The existing <code>match</code> branch no longer works with this PR because the inner data wrapped by <code>SubclassOfType</code> is now private, so we can't simply unpack it as part of the <code>match</code> branch. The inner wrapped data must be private if we want to enforce that the eagerly normalising constructor is always used.</p>
<p>But this branch doesn't have to use a nested <code>match</code>; it could also be something like <code>subclass_of_ty.subclass_of().into_class().is_some_and(...)</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md</code>:165 on 2025-01-06 13:51</div>
            <div class="timeline-body"><p>A few points.</p>
<p>Firstly, we're far from unique in inventing our own notation for type display in some cases and using it in the output of <code>reveal_type</code>. E.g. take a look at the mypy output <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=298fa4178255da17b792b3954bf583e4">here</a>. There have been a couple of complaints about some of the stranger symbols in mypy's <code>reveal_type</code> output being confusing, but I don't think it's really been a major issue at all. I can only remember <a href="https://github.com/python/mypy/issues/11519">one issue</a> about it, and it's not highly upvoted.</p>
<p>Secondly, we're also far from unique in eagerly simplifying types that we see in user annotations and using the simplified types in our type display. We already do this elsewhere when we simplify unions (removing duplicate elements and elements that are subtypes of each other); <a href="https://pyright-play.net/?code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAqiApgCYAiSAxjADRQByAhhGQQK4IA2xAUL1S5MAzsKgAxMGAAUMTjwDaqOphQwAugEoAXFAB0B-gA8oAXglTp0gIy0ATJs28QxAG7EmXAPrwExaUZOAkKiUABCTCDSzKykHNzEOrxQKVBGusrJqXC6wjAg-HBm4ZE29ABEwFLlTi7unj4k0nBBgiJiEQBe0kR%2BFNQwSalpGWpZKTlQeQXObh7evv5d0gDe5UblugAsdhVwm1Dl%2BwC%2BjvykxMBQwAGj%2BAA%2BUABGUlxQj8pDqXXzjX4BTiAA">so does pyright, to some extent</a>.</p>
<p>Notwithstanding those two points, I have been thinking for a while that our current display for class-literal and function-literal types is a little confusing for users. It looks <em>too close</em> to something that would be valid in a type annotation in user code, and users will probably think that we're claiming that <code>Literal[SomeClass]</code> is valid in a user type annotation. It'll be confusing for them when we then reject them using <code>Literal[SomeClass]</code> in their own code.</p>
<p>Prior to this PR, I was wondering about <code>Literal[&lt;class 'SomeClass'&gt;]</code> and <code>Literal[&lt;function 'some_function'&gt;]</code> as an alternative display for class-literal and function-literal types. But your comments here make me wonder if we could also consider <code>type[SomeClass(final=True)]</code> or <code>type[SomeClass(@final=True)]</code> for class-literal types</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 13:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 13:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:894 on 2025-01-06 13:54</div>
            <div class="timeline-body"><p>Argh, great catch! Fixing this could indeed be annoying enough that we decide not to pursue the approach here. Let's see.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:894 on 2025-01-06 14:22</div>
            <div class="timeline-body"><p>Actually, fixing this bug only required adding one extra branch to <code>Type::is_subtype_of()</code>. I think that still makes the tradeoff worthwhile.</p>
<p>I added a unit test for the bug in https://github.com/astral-sh/ruff/pull/15272/commits/72f8cece68cbd5d8c3b139a52c89abbb44a9c3b4, and confirmed that it failed on this PR branch prior to https://github.com/astral-sh/ruff/pull/15272/commits/72f8cece68cbd5d8c3b139a52c89abbb44a9c3b4!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-06 14:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-06 18:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/type_of/basic.md</code>:165 on 2025-01-06 18:00</div>
            <div class="timeline-body"><p>Yes, I agree that both displaying our own notation for some types, and simplifying user-provided types, are things we can do. It just feels a bit like crossing another line to <em>combine</em> those two things in such a way that we eagerly replace a spellable user-provided type with a non-spellable type display. But maybe this isn't actually a problem in practice. I'm OK with deferring that question from this PR, and at some point following up more holistically on type display. There are a lot of interesting questions here, including how we balance conciseness/readability vs clarity (to first time readers without needing to refer to docs) in the notations we choose. I won't get too deep into the details here, I'll just say that a) I kind of like the idea of representing <code>ClassLiteral</code> types in some way using <code>type[]</code> notation, since they are similar, and b) I'm not sure we should use the word &quot;final&quot; in that display, because I think it's too confusing in cases where we have a <code>ClassLiteral</code> type but for a non-final class.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-06 18:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:894 on 2025-01-06 18:01</div>
            <div class="timeline-body"><p>Great, will take a look at the rest of the PR now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-06 18:13</div>
            <div class="timeline-body"><blockquote>
<p>a pre-existing issue exposed by this PR</p>
</blockquote>
<p>Yes, it looks that way to me (though I haven't investigated it thoroughly). It looks like we probably need to actually check the reaching definitions, rather than just the declared type, in deciding whether to emit the special class-shadowing diagnostic. (Or we could just abandon that special case and just decide that the regular invalid-assignment diagnostic is adequate.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:920 on 2025-01-06 18:16</div>
            <div class="timeline-body"><p>Is it worth pulling this into an <code>SubclassOfType::is_instance_of</code> method?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1394 on 2025-01-06 18:22</div>
            <div class="timeline-body"><p>I think we might thank ourselves for this in the future?</p>
<pre><code class="language-suggestion">            // We eagerly transform `SubclassOf` to `ClassLiteral` for final types, so `SubclassOf` is never a singleton.
            Type::SubclassOf(..) =&gt; false,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/subclass_of.rs</code>:3 on 2025-01-06 18:26</div>
            <div class="timeline-body"><p>This comment sort of implies a type as being made up of types, rather than objects:</p>
<pre><code class="language-suggestion">/// A type that represents `type[C]`, i.e. the class object `C` and class objects that are subclasses of `C`.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-06 18:28</div>
            <div class="timeline-body"><p>Looks good! I think it makes sense to go with this direction.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-07 11:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:920 on 2025-01-07 11:42</div>
            <div class="timeline-body"><p>I'm reluctant to add a <code>SubclassOfType::is_instance_of</code> method <em>exactly</em>, because I think there's an important-yet-subtle distinction that needs to be made here: the subtype-of relationship is a relationship between <em>types</em> (is this instance type a subtype of the other instance type? is this subclass-of type a subtype of that instance type?) but the subclass-of and instance-of relationships are relationships between <em>runtime objects</em> rather than <em>types</em> (is this class object an instance of that class object? is this instance an instance of that class object? is this class object a subclass of that class object?). So we can ask the question &quot;are all <em>inhabitants of</em> &lt;some <code>SubclassOfType</code>&gt; instances of &lt;class <code>X</code>&gt;?&quot;, but I don't think we should allow ourselves to ask the question &quot;is &lt;some <code>SubclassOfType</code>&gt; an instance of &lt;class <code>X</code>&gt;?&quot;; it blurs the distinction between the concepts in an unfortunate way.</p>
<p>I suppose I already blurred the line recently by adding the <code>KnownInstanceType::is_instance_of()</code> method:</p>
<p>https://github.com/astral-sh/ruff/blob/0dc00e63f444985fc55c327332602c876a2ffd60/crates/red_knot_python_semantic/src/types.rs#L2769-L2771</p>
<p>it felt okay because this type in particular only has exactly one inhabitant at runtime, so in this particular case the distinction between &quot;the type&quot; and &quot;all inhabitants of the type&quot; is really a distinction without a difference. Maybe it was still a mistake, though; maybe we should get rid of that method.</p>
<p>I'd be open to adding APIs such as <code>SubclassOfType::inhabitants_are_instances_of()</code> and <code>InstanceType::inhabitants_are_instances_of()</code>, but the longer names make it slightly more unwieldy. For now I'll leave it, but I'm happy to tackle it in a follow-up if you think it would be worth it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-01-07 12:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-01-07 12:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-07 12:53</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:08:53 UTC
    </footer>
</body>
</html>
