<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Change to BDD representation for constraint sets - astral-sh/ruff #20533</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Change to BDD representation for constraint sets</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20533">#20533</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-09-23 13:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>While working on #20093, I kept running into test failures due to constraint sets not simplifying as much as they could, and therefore not being easily testable against &quot;always true&quot; and &quot;always false&quot;.</p>
<p>This PR updates our constraint set representation to use BDDs. Because BDDs are reduced and ordered, they are canonical — equivalent boolean formulas are represented by the same interned BDD node.</p>
<p>That said, there is a wrinkle, in that the &quot;variables&quot; that we use in these BDDs — the individual constraints like <code>Lower ≤ T ≤ Upper</code> are not always independent of each other.</p>
<p>As an example, given types <code>A ≤ B ≤ C ≤ D</code> and a typevar <code>T</code>, the constraints <code>A ≤ T ≤ C</code> and <code>B ≤ T ≤ D</code> &quot;overlap&quot; — their intersection is non-empty. So we should be able to simplify</p>
<pre><code>(A ≤ T ≤ C) ∧ (B ≤ T ≤ D) == (B ≤ T ≤ C)
</code></pre>
<p>That&#x27;s not a simplification that the BDD structure can perform itself, since those three constraints are modeled as separate BDD variables, and are therefore &quot;opaque&quot; to the BDD algorithms.</p>
<p>That means we need to perform this kind of simplification ourselves. We look at pairs of constraints that appear in a BDD and see if they can be simplified relative to each other, and if so, replace the pair with the simplification. A large part of the toil of getting this PR to work was identifying all of those patterns and getting that substitution logic correct.</p>
<p>With this new representation, all existing tests pass, as well as some new ones that represent test failures that were occuring on #20093.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-23 13:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-23 13:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-23 13:42</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-09-23 13:51</div>
            <div class="timeline-body">



<a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fconsraint-bdd?runnerMode=WallTime">CodSpeed WallTime Performance Report</a>
Merging #20533 will <strong>improve performances by 8.05%</strong>
<p>Comparing <code>dcreager/consraint-bdd</code> (bca166c) with <code>main</code> (e66a872)</p>
Summary
<p><code>⚡ 2</code> improvements<br>
<code>✅ 6</code> untouched</p>
Benchmarks breakdown
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ⚡ | <code>medium[colour-science]</code> | 10.4 s | 9.6 s | +8.05% |
| ⚡ | <code>small[freqtrade]</code> | 8.3 s | 7.8 s | +6.22% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-09-23 13:52</div>
            <div class="timeline-body">



<a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fconsraint-bdd?runnerMode=Instrumentation">CodSpeed Instrumentation Performance Report</a>
Merging #20533 will <strong>improve performances by 4.25%</strong>
<p>Comparing <code>dcreager/consraint-bdd</code> (bca166c) with <code>main</code> (e66a872)</p>
Summary
<p><code>⚡ 1</code> improvement<br>
<code>✅ 12</code> untouched<br>
<code>⏩ 30</code> skipped[^skipped]</p>
Benchmarks breakdown
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ⚡ | <code>hydra-zen</code> | 825.3 ms | 791.7 ms | +4.25% |
[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/dcreager%2Fconsraint-bdd?runnerMode=Instrumentation&amp;sectionId=benchmark-comparison-section-baseline-result-skipped">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-23 13:53</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>scikit-build-core (https://github.com/scikit-build/scikit-build-core)
+ src/scikit_build_core/build/_wheelfile.py:51:22: error[no-matching-overload] No overload of function `field` matches arguments
- Found 52 diagnostics
+ Found 53 diagnostics

</code></pre>

No memory usage changes detected ✅

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/constraints.md</code>:602 on 2025-09-25 15:33</div>
            <div class="timeline-body"><p>These tests all failed to simplify with the old representation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-09-25 16:24</div>
            <div class="timeline-body"><blockquote>
<p>No memory usage changes detected</p>
</blockquote>
<p>This is because #20093 is what introduces the logic to actually create non-trivial constraint sets. That is where we will see the memory increases from using salsa to intern BDD nodes and memoize the BDD operations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-25 16:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-25 16:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-25 16:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-25 16:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;[ty] WIP: Change to BDD representation for constraint sets&quot; to &quot;[ty] Change to BDD representation for constraint sets&quot; by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-25 16:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:264 on 2025-09-25 19:14</div>
            <div class="timeline-body"><p>I&#x27;m not sure I understand why <code>RangeConstraint</code> and <code>ConstrainedTypeVar</code> should be separate structs, given that the only kind of constraint a <code>ConstrainedTypeVar</code> can contain is a <code>RangeConstraint</code>. It seems to result in a lot of awkward entanglement between the types:</p>
<ul>
<li>We have <code>RangeConstraint::new_node</code>, which returns a <code>Node</code> containing a <code>ConstrainedTypeVar</code> containing a <code>RangeConstraint</code> -- why is this method located on <code>RangeConstraint</code>?</li>
<li><code>RangeConstraint::display</code> has to accept an external typevar.</li>
<li>Various methods (e.g. <code>RangeConstraint::intersect</code>) are not sensible unless the constraints are applied to the same typevar, but <code>RangeConstraint</code> can&#x27;t validate this itself.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:562 on 2025-09-25 20:16</div>
            <div class="timeline-body"><pre><code>    /// Returns the `if-then-else` of three BDDs: when `self` evaluates to `true`, it returns what
    /// `then_node` evaluates to; otherwise it returns what `else_node` evaluates to.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:587 on 2025-09-25 20:19</div>
            <div class="timeline-body"><pre><code>    ) -&gt; Self {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:598 on 2025-09-25 20:20</div>
            <div class="timeline-body"><pre><code>    fn restrict_one(self, db: &amp;&#x27;db dyn Db, assignment: ConstraintAssignment&lt;&#x27;db&gt;) -&gt; Self {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1164 on 2025-09-25 20:22</div>
            <div class="timeline-body"><p>Why is this named <code>flipped()</code> instead of <code>negated()</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:795 on 2025-09-25 20:53</div>
            <div class="timeline-body"><p>Couldn&#x27;t this just swap <code>if_true</code> and <code>if_false</code> instead of recursively negating them? Or would that violate some invariant of the BDD?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:631 on 2025-09-25 21:05</div>
            <div class="timeline-body"><p>When would we attempt a simplification that this validation would reject? Are some of the simplifications attempted in <code>InteriorNode::simplify</code> speculative, or possibly invalid? If so, maybe we should mark those more clearly than we do now?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:689 on 2025-09-25 21:05</div>
            <div class="timeline-body"><p>Same question as above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:999 on 2025-09-25 21:09</div>
            <div class="timeline-body"><p>I might be misunderstanding, but it seems like the attempted simplification here doesn&#x27;t match the comment? The simplification I&#x27;d expect to match the comment would be this one:</p>
<pre><code>                // larger ∧ smaller = smaller
                simplified = simplified.substitute_intersection(
                    db,
                    larger_constraint.when_true(),
                    smaller_constraint.when_true(),
                    Node::new_satisfied_constraint(db, smaller_constraint.when_true()),
                );
</code></pre>
<p>It seems like the currently implemented simplification is <code>¬smaller ∧ ¬larger = ¬larger</code>, which is also correct, but not the same thing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1266 on 2025-09-25 21:15</div>
            <div class="timeline-body"><p>Is it not possible to sufficiently simplify the underlying BDD so we don&#x27;t need additional simplification of the <code>SatisfiedConstraints</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-09-25 21:15</div>
            <div class="timeline-body"><p>Nice! It looks like a few tests are failing with the latest commit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1266 on 2025-09-25 21:55</div>
            <div class="timeline-body"><p>No, this is unrelated to the simplifications that we make to the BDD. Those are needed since the BDD variables are not independent of each other.</p>
<p>This issue is true of BDDs in general, even those with nicely independent variables. The problem is that the naive DNF of a BDD includes extra information, because it&#x27;s just walking the BDD node graph. The simplest example is if you create the BDD for <code>x ∨ y</code>:</p>
<pre><code>    x
  ₀/ \₁
  y   1
₀/ \₁
0   1
</code></pre>
<p>and then render that by turning it into DNF, you get <code>x ∨ (¬x ∧ y)</code>. The DNF formula is just a straight rendering of each path that leads to a 1 terminal. But when evaluating that formula, if <code>x=1</code>, we short circuit and don&#x27;t need to evaluate the second clause. Since we can <em>assume</em> that <code>x=0</code> if we get to the point where we need to look at the second clause, we can remove <code>¬x</code> from it. That&#x27;s what this simplification is doing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:631 on 2025-09-25 22:07</div>
            <div class="timeline-body"><p>In a way all of the simplifications are speculative — not because they sometimes don&#x27;t hold, but because we don&#x27;t know in advance whether a particular BDD contains the clause that we&#x27;re trying to simplify. For instance, we might try to substitute <code>x || y</code> with <code>y</code> (because we determined that <code>y</code> fully contains <code>x</code>). If we do that to the function <code>x</code>, without this check, the result we get from the substitution is <code>y</code>. But the result should be <code>x</code>, since <code>x || y</code> doesn&#x27;t appear in the function. In general there isn&#x27;t a way to see if a BDD contains a clause like <code>x || y</code>, since those clauses aren&#x27;t stored directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:795 on 2025-09-25 22:10</div>
            <div class="timeline-body"><p>No, if you have <code>a ∧ b</code> that would produce <code>a ∧ ¬b</code>:</p>
<pre><code>a ∧ b =  a
       ₀/ \₁
       0   b
         ₀/ \₁
         0   1
</code></pre>
<p>Flipping the true/false edges of the root node gives:</p>
<pre><code>         a
       ₀/ \₁
       b   0
     ₀/ \₁
     0   1
</code></pre>
<p>which is <code>¬a ∧ b</code>. Instead we want to walk the entire graph and change each terminal 0 or 1 to its opposite.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1164 on 2025-09-25 22:11</div>
            <div class="timeline-body"><p>Oh yeah good catch! I&#x27;ll rename to be consistent with the other types</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:264 on 2025-09-25 22:13</div>
            <div class="timeline-body"><p>This is a holdover from the previous representation, where there were different kinds of constraint that we built up into a <code>ConstrainedTypeVar</code>. I was mildly leaning towards keeping the diff smaller where possible, but I take your point. I&#x27;ll combine them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-09-25 22:15</div>
            <div class="timeline-body"><blockquote>
<p>It looks like a few tests are failing with the latest commit.</p>
</blockquote>
<p>That patch was me trying to fix things on #20093. I don&#x27;t know that it&#x27;s the right approach so I&#x27;m going to revert it here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-25 22:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1266 on 2025-09-25 22:48</div>
            <div class="timeline-body"><p>I see, makes sense. It still somehow feels like we ought to be able to do this &quot;on the fly&quot; while building the DNF representation, by tracking the information we can assume and not adding clauses that can be assumed? But maybe not, or maybe doing it after-the-fact is just as good in practice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-09-26 00:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:1266 on 2025-09-26 00:51</div>
            <div class="timeline-body"><p>We might be able to, but this code path is only executed as part of displaying constraint sets, which only happens in our test cases, so I didn&#x27;t think it was worth spending too much time optimizing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-09-26 01:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:999 on 2025-09-26 01:20</div>
            <div class="timeline-body"><p>It&#x27;s the comment that&#x27;s wrong (which I just fixed). The <code>larger ∧ smaller = smaller</code> case holds for any two non-disjoint types, not just for strict containment, so it&#x27;s handled in the stanza below.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-26 01:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dcreager">@dcreager</a> on 2025-09-26 01:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-09-26 01:55</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:18:53 UTC
    </footer>
</body>
</html>
