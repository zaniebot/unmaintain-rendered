<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Initial implementation of declaration and definition providers. - astral-sh/ruff #19371</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Initial implementation of declaration and definition providers.</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19371">#19371</a>
        opened by <a href="https://github.com/UnboundVariable">@UnboundVariable</a>
        on 2025-07-15 18:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a></div>
            <div class="timeline-body"><p>This PR implements &quot;go to definition&quot; and &quot;go to declaration&quot; functionality for name nodes only. Future PRs will add support for attributes, module names in import statements, keyword argument names, etc.</p>
<p>This PR:</p>
<ul>
<li>Registers a declaration and definition request handler for the language server.</li>
<li>Splits out the <code>goto_type_definition</code> into its own module. The <code>goto</code> module contains functionality that is common to <code>goto_type_definition</code>, <code>goto_declaration</code> and <code>goto_definition</code>.</li>
<li>Roughs in a new module <code>stub_mapping</code> that is not yet implemented. It will be responsible for mapping a definition in a stub file to its corresponding definition(s) in an implementation (source) file.</li>
<li>Adds a new IDE support function <code>definitions_for_name</code> that collects all of the definitions associated with a name and resolves any imports (recursively) to find the original definitions associated with that name.</li>
<li>Adds a new <code>VisibleAncestorsIter</code> stuct that iterates up the scope hierarchy but skips scopes that are not visible to starting scope.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @UnboundVariable on 2025-07-15 18:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @UnboundVariable on 2025-07-15 18:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @UnboundVariable on 2025-07-15 18:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @UnboundVariable on 2025-07-15 18:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @UnboundVariable on 2025-07-15 18:32</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-15 18:54</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅
No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-07-15 19:42</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_INSTRUMENTATION_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/UnboundVariable%3Agoto_definition?runnerMode=Instrumentation">CodSpeed Instrumentation Performance Report</a></h2>
<h3>Merging #19371 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>UnboundVariable:goto_definition</code> (c258942) with <code>main</code> (cbe94b0)</sub></p>
<h3>Summary</h3>
<p><code>✅ 41</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-15 19:43</div>
            <div class="timeline-body"><blockquote>
<p>Merging #19371 will <strong>degrade performances by 5.26%</strong></p>
</blockquote>
<p>I think that's just a race condition due to https://github.com/astral-sh/ruff/pull/19328 being merged at exactly the wrong time -- if you rebase this PR, it should go away</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">server</span> added by @AlexWaygood on 2025-07-15 19:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-07-15 19:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-15 20:52</div>
            <div class="timeline-body"><p>To potential reviewers... Most of the changes in this PR are straightforward and probably not worth your time reviewing in any great detail. Here are the specific areas where I would most appreciate review and feedback:</p>
<ol>
<li>In <a href="https://github.com/astral-sh/ruff/pull/19371/files#diff-2c8485d2796b0e1e643d3e48cd572c9810dcc7f45bbecae951ca00e5276d7d9d">semantic_index.rs</a>, I added a <code>VisibleAncestorsIter</code> struct to walk up the scope hierarchy but skip the scopes that are not visible to the starting scope. I would have expected to see functionality like this already, but I couldn't find it. Let me know if I should be using something else here.</li>
<li>I added a function <a href="https://github.com/astral-sh/ruff/pull/19371/files#diff-f9eb3d520f255c7ff2246e1250a1ee679eea2e642bef437c28cc36f49e797cee">definitions_for_name</a> in <code>ide_support.rs</code>. Does this look like the right abstraction and separation of concern? I tried a couple of different options, but some of my other attempts required exposing way more public structs and methods from <code>ty_python_semantic</code>  to the <code>ty_ide</code> crate.</li>
<li>I added a new module <a href="https://github.com/astral-sh/ruff/pull/19371/files#diff-940d4c36a4b3d1411e05f62bcbf93457712b47d29e5afc2bcbb751c51286ad1d">resolve_definition</a> that is used by <code>definitions_for_name</code>. It contains code that &quot;resolves&quot; import declarations -- following them recursively to locate the original source declaration. Does this look like the right approach?</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/semantic_index.rs</code>:394 on 2025-07-15 23:08</div>
            <div class="timeline-body"><p>Class scopes are also visible to an annotations scope immediately enclosed by the class scope, e.g. in a case like:</p>
<pre><code class="language-py">class C:
    X = int
    def f[T](self, a: T, b: X) -&gt; T: ...
</code></pre>
<p>We don't already have this iterator because Python's lexical scoping rules (which we currently implement in <code>TypeInferenceBuilder::infer_name_load</code>) are more complex than what's implemented here. Even if we don't consider things like narrowing constraints (which aren't relevant for LSP goto), there are other factors, such as <code>nonlocal</code> and <code>global</code> statements. Once all of that is implemented, I'm not sure if this iterator is a net simplification, or if it just ends up splitting the lexical scoping rules into two different places.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/resolve_definition.rs</code>:60 on 2025-07-15 23:59</div>
            <div class="timeline-body"><p>I think it would be not much more duplicative, and simpler, if we duplicate the <code>let file = ...; let module = ...</code> in the import arms below, and eliminate the redundant early return (which we just end up duplicating in an unreachable arm below.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/resolve_definition.rs</code>:109 on 2025-07-16 00:00</div>
            <div class="timeline-body"><p>If we keep the early return above, I think we should use <code>unreachable!(&quot;would have early returned above&quot;)</code> here rather than duplicating.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/resolve_definition.rs</code>:64 on 2025-07-16 02:27</div>
            <div class="timeline-body"><p>This line seems removable?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:457 on 2025-07-16 02:43</div>
            <div class="timeline-body"><p>This feels like a concern that ought to be encapsulated inside <code>resolve_definition</code>.</p>
<p>Could we eliminate the need for this clause (and get slightly more consistent behavior as well when there are multiple original definitions and some &quot;resolve&quot; and others don't?) by ensuring that <code>resolve_definition</code> always just returns a <code>ResolvedDefinition::Definition</code> of the original definition (instead of an empty vec) in error cases?</p>
<p>Or alternatively, perhaps there should be a <code>fn resolve_definitions</code> in the definition-resolver module that takes an iterator of Definition and returns the resolved definitions, and this logic would then belong there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/goto.rs</code>:209 on 2025-07-16 04:10</div>
            <div class="timeline-body"><p>Why accept the ExprRef here if it's unused?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/stub_mapping.rs</code>:12 on 2025-07-16 04:16</div>
            <div class="timeline-body"><p>Without any implementation, it's difficult to evaluate whether a <code>StubMapper</code> struct makes sense. Will it carry any state (other than a db, which we pass everywhere anyway)? Or will it end up really just being a stateless <code>map_definition</code> function?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/goto.rs</code>:158 on 2025-07-16 04:20</div>
            <div class="timeline-body"><p>It's a bit confusing that several comments here reference &quot;declarations&quot;, when this method is used for both goto-definition and goto-declaration (depending on whether a stub mapper is provided).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_ide/src/goto.rs</code>:147 on 2025-07-16 04:23</div>
            <div class="timeline-body"><p>At the moment in this PR, it looks like the only difference between goto-definition and goto-declaration is whether stubs are mapped to source files. Otherwise, both goto-definition and goto-declaration return all reachable bindings and declarations.</p>
<p>Is this the right behavior? Or should there be a distinction between bindings and declarations?</p>
<p>I guess in the most common cases (functions and classes) it likely won't make a difference. But for e.g. a case like</p>
<pre><code class="language-py">SOME: int
if whatever:
    SOME = 1
else:
    SOME = 2
</code></pre>
<p>I think I would expect goto-declaration to take me only to <code>SOME: int</code>, and goto-definition to take me only to the two assignments with RHS?</p>
<p>Maybe this kind of case isn't common enough for it to matter.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:410 on 2025-07-16 04:31</div>
            <div class="timeline-body"><p>This walk doesn't currently handle <code>nonlocal</code> and <code>global</code> statements, both of which should modify this logic. If a name is declared <code>nonlocal</code> then we shouldn't stop the walk when we discover definitions in that scope, because definitions in the nearest containing (function-like) scope also apply. If we see a <code>global</code> statement, we should consider definitions in that scope, and then jump straight to global scope.</p>
<p>It would be good to add tests for these cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:464 on 2025-07-16 04:54</div>
            <div class="timeline-body"><p>Our type inference has a more precise understanding in many cases of exactly which bindings can actually reach a given use. This is true both in the same scope:</p>
<pre><code class="language-py">def f():
    x = 1
    x&lt;CURSOR&gt;
    x = 2 # should goto-definition from the above line offer this definition as a nav target?
</code></pre>
<p>And in enclosing scopes, in particular where the nested scope is known to be eagerly executed:</p>
<pre><code class="language-py">def f():
    x = 1
    [x&lt;CURSOR&gt; for _ in [1]]
    x = 2  # same question as above
</code></pre>
<p>Is this an intentional choice based on your experience of what behavior users will likely prefer (or what other LSPs do), or is it an expedient choice because that's what was simplest to implement?</p>
<p>If we will eventually want a more precise behavior that eliminates definitions that can't reach the selected use, that implies that we'll end up duplicating much more of the logic found in <code>TypeInferenceBuilder::infer_name_load</code>, and could imply a different implementation direction altogether (where we try to reuse more of the type-inference logic.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/resolve_definition.rs</code>:1 on 2025-07-16 04:58</div>
            <div class="timeline-body"><p>I wonder if this should be a submodule of <code>ide_support.rs</code>, since I think that's the only use case for this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-16 04:59</div>
            <div class="timeline-body"><p>This is great, thank you!</p>
<p>At a high level, my main question mark is the extent to which this adds a new and totally separate reimplementation of logic to model Python semantics which already exists in a different form in our type inference. In this PR, that's mostly <code>definitions_for_name</code>, which sort-of-duplicates <code>TypeInferenceBuilder::infer_name_load</code>. But as we flesh out e.g. attribute access, I suspect there will be even more of this duplication.</p>
<p>On the one hand, this duplication will likely (and already does, in this PR) lead to some subtleties being modeled correctly in one case and not in another case, leading to inconsistencies between the goto feature and type inference.</p>
<p>On the other hand, that may not be a big deal, and this may still be the best tradeoff. The LSP goto features can ignore some complexities (narrowing constraints) entirely, and (at least currently) make some other major simplifications (always considering all reachable bindings and declarations in every considered scope, even if some could not reach the selected name expression). And the clearest implementation alternative (packaging up the full set of discovered Definitions with every Place load in type inference, so that we can reuse the type-inference code) could have significant performance implications for type inference, even when goto features aren't being used.</p>
<p>Regarding your 3 reviewer questions, I think I answered (1) in an inline comment, (2) is discussed both inline (regarding specific limitations of the new function) and above (regarding the higher-level question of whether we re-implement or re-use the type-inference logic), and re (3) I think the new <code>ResolvedDefinition</code> machinery looks reasonable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/goto_declaration.rs</code>:1 on 2025-07-16 08:41</div>
            <div class="timeline-body"><p>Splitting the modules as you suggest makes a lot of sense to me. But I suggest doing it in a separate PR. It makes this PR smaller and also makes it easier to see if there were any changes in those modules (and what's pre-existing code)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/stub_mapping.rs</code>:12 on 2025-07-16 08:43</div>
            <div class="timeline-body"><p>I agree. I don't think having the struct in place provides much value in its current form. It also makes it hard to judge if it should be a method on <code>Definition</code> instead.</p>
<p>I suggest removing it for now and instead add a TODO comment where the mapping must happen.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-16 09:24</div>
            <div class="timeline-body"><p>Thank. I don't have much to add other than I agree with @carljm's summary: It be curious to hear your thoughts on duplicating some of the semantic behavior for the LSP vs trying to enrhich <code>ty_python_semantic</code> itself to avoid the code duplication.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-16 17:03</div>
            <div class="timeline-body"><p>@UnboundVariable and I discussed this today in person and felt that it makes sense to continue with the current approach, even though it involves some of what looks like duplication, because in fact the duplication is &quot;shallower&quot; than it appears; there are a lot of behavior differences between type inference and collecting definitions for goto-definition. (One upcoming example with attributes is that goto-definition actually shouldn't run the descriptor protocol, which is a big part of our type-inference attribute-access code.) Having to integrate all of these differences into the type-inference code as optional flags will increase complexity and slow down implementing the LSP features, as well as making it harder to make future changes to the behavior. In other words, we feel this is a case where it makes sense to accept some duplication in exchange for greater flexibility.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-16 20:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/goto.rs</code>:209 on 2025-07-16 20:46</div>
            <div class="timeline-body"><p>Good catch. That was left over from an earlier iteration of the code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-16 20:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/stub_mapping.rs</code>:12 on 2025-07-16 20:49</div>
            <div class="timeline-body"><p>I'd prefer to leave it in place for now. I told Aria that I'd leave hooks in place for the follow-on work that she's going to do. It's easy to remove if she decides to implement it in some other manner, but I think it's likely that this is the preferred pattern.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @UnboundVariable on 2025-07-16 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @UnboundVariable on 2025-07-16 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-16 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-16 22:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:454 on 2025-07-16 22:47</div>
            <div class="timeline-body"><p>Do we really want to <em>skip</em> current scope here? I realize that there's a broader TODO above about respecting nonlocal/global writes from arbitrary other scopes (which I think is doable with some non-trivial changes to semantic indexing), but it seems like we could easily (and should) include definitions from the same scope in which it is declared <code>nonlocal</code>? (Same question applies re <code>global</code> handling above)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/goto.rs</code>:217 on 2025-07-17 07:23</div>
            <div class="timeline-body"><p>The <code>use</code> here seems unnecessary given that it is used exactly once. We also prefer using global imports in general unless there's a reason not to (e.g. a star import or conflicting trait imports <code>std:fmt::Write</code> and <code>std::io::Write</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:404 on 2025-07-17 07:35</div>
            <div class="timeline-body"><p>This can only fail if <code>name</code> doesn't belong to <code>file</code> or if <code>ast::ExprName</code> is from a previous revision. Id' be inclined to use <code>expression_scope_id</code> directly.</p>
<p>Having to clone <code>ExprName</code> here seems unnecessary. I suggest either implementing <code>HasTrackedScope</code> for <code>ExprName</code> or passing <code>&amp;ExprRef::from(name)</code> here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-17 07:40</div>
            <div class="timeline-body"><p>This is great.</p>
<p>My only concern with duplicating the logic is that it will be very easy to only make the change in one implementation and not in the other. Is there a way that we could run the new logic as part of our mdtests so that at least a test is failing if I only update one implementation but not the other (it would also give us a lot of test coverage to start from and track the remaining TODOs)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-17 21:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:454 on 2025-07-17 21:43</div>
            <div class="timeline-body"><p>With language server functionality like &quot;go to declaration&quot;, it's not clear what behavior is &quot;correct&quot;. It's somewhat subjective, and we will undoubtedly need to iterate on all of the language server features in response to user feedback. As you and I discussed in person, my recommended approach is to use Microsoft's language server (pylance) as a starting point to inform the initial behavior. Pylance has already gone through several years of iteration and user feedback, so it's probably a good starting point for ty.</p>
<p>Another general principle with &quot;go to declaration&quot; and &quot;go to definition&quot; is that it's probably not a good idea to return different results for different usages of a symbol. In other words, if you &quot;go to definition&quot; from any use of a symbol, it should display the same list of definitions.</p>
<p>Based on these principles, the &quot;correct&quot; solution here is to address the TODO that I left in the code. Once we do that, we will want to skip the current scope here. In other words, I wrote the code assuming that we will eventually fix the TODO. If you have strong opinions about how this should work in the interim — or prefer that I prioritize fixing the TODO now, let me know.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_ide/src/goto.rs</code>:217 on 2025-07-17 21:46</div>
            <div class="timeline-body"><p>Thanks, this was left over from a previous iteration of the code. I'll clean it up in my next PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-17 21:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/UnboundVariable">@UnboundVariable</a> reviewed on 2025-07-17 21:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:404 on 2025-07-17 21:50</div>
            <div class="timeline-body"><p>I'll change this in my next PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-18 18:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/ide_support.rs</code>:454 on 2025-07-18 18:26</div>
            <div class="timeline-body"><p>Understood. Not sure how to weight &quot;prefer always returning the same set of definitions&quot; vs &quot;don't fail to return a local definition that is highly likely to be relevant&quot; in the short term, but I agree the right answer is to fix the TODO and consider all definitions. I think the main thing blocking this is to adjust semantic indexing so it does a &quot;breadth-first&quot; rather than &quot;depth-first&quot; walk (defers walking function bodies), so that we can be confident of the target scope for a <code>nonlocal</code> declaration (because we know we've seen all possible bindings in enclosing scopes). But we have plenty to do, so I'm not going to suggest this definitely should be the next priority. It may also make sense for someone more familiar with the existing semantic indexing to tackle that.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:14:17 UTC
    </footer>
</body>
</html>
