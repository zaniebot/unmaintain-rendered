<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Synthetic function-like callables - astral-sh/ruff #18242</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Synthetic function-like callables</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18242">#18242</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-05-21 13:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a></div>
            <div class="timeline-body">

Summary
<p>We create <code>Callable</code> types for synthesized functions like the <code>__init__</code> method of a dataclass. These generated functions are real functions though, with descriptor-like behavior. That is, they can bind <code>self</code> when accessed on an instance. This was modeled incorrectly so far.</p>
Test Plan
<p>Updated tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-05-21 13:57</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>attrs (https://github.com/python-attrs/attrs)
- info[revealed-type] tests/dataclass_transform_example.py:13:13: Revealed type: `(a: str, b: int) -&gt; None`
+ info[revealed-type] tests/dataclass_transform_example.py:13:13: Revealed type: `(self: Define, a: str, b: int) -&gt; None`
- info[revealed-type] tests/dataclass_transform_example.py:21:13: Revealed type: `(with_converter: int = Unknown) -&gt; None`
+ info[revealed-type] tests/dataclass_transform_example.py:21:13: Revealed type: `(self: DefineConverter, with_converter: int = Unknown) -&gt; None`
- warning[possibly-unbound-attribute] tests/test_dunders.py:1008:13: Attribute `__code__` on type `Unknown | (() -&gt; None)` is possibly unbound
- warning[possibly-unbound-attribute] tests/test_dunders.py:1020:13: Attribute `__code__` on type `Unknown | (() -&gt; None)` is possibly unbound
- error[unresolved-attribute] tests/test_dunders.py:1032:13: Type `() -&gt; None` has no attribute `__code__`
- Found 621 diagnostics
+ Found 618 diagnostics

</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7660 on 2025-05-21 14:03</div>
            <div class="timeline-body"><p>Initially, I didn&#x27;t want to add a new parameter here, and simply passed <code>false</code> below everywhere. This led to a very subtle bug that took me a long time to catch, because we use <code>from_overloads</code> to essentially create a new copy of a callable, and the is-function-like behavior was lost in that process. I therefore made it explicit here, but I&#x27;m also fine with trying to walk this back (and create a new function for copying).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-21 14:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types.rs</code>:2751 on 2025-05-21 14:09</div>
            <div class="timeline-body"><p>It is a shortcut to model this in <code>try_call_dunder_get</code>. If we want to be really precise, we should instead create a new method-wrapper type variant for the synthesized <code>__get__</code> method of these synthesized functions, which would be returned from <code>find_name_in_mro</code> when called on function-like <code>Type::Callable</code>s. This would allow us to correctly model the behavior of explicit <code>SomeDataclass.__init__.__get__</code> calls. The occurrence of this seems rather unlikely, so I did not introduce a new type variant just for this. But if we would rather model this completely correctly, I&#x27;m happy to make the necessary changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-21 14:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-21 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6944 on 2025-05-21 14:12</div>
            <div class="timeline-body"><p>It seemed somewhat tempting to return <code>true</code> here :smile: (to make <code>Callable</code> types that are created from functions &quot;function-like&quot;). And maybe that would be more correct in some sense? At the moment, I think it does not make any difference, since <code>FunctionType::into_callable_type</code> is only used in type-property functions that do not seem to invoke the descriptor protocol.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 14:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 14:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 14:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 14:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:2751 on 2025-05-21 14:16</div>
            <div class="timeline-body"><p>Could you add that brief summary as a comment, so we know what to do if it does come up in the future?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-05-21 14:17</div>
            <div class="timeline-body"><blockquote>
<pre><code>- warning[possibly-unbound-attribute] tests/test_dunders.py:1008:13: Attribute `__code__` on type `Unknown | (() -&gt; None)` is possibly unbound
+ warning[possibly-unbound-attribute] tests/test_dunders.py:1008:13: Attribute `__code__` on type `Unknown | ((self: C) -&gt; None)` is possibly unbound
</code></pre>
</blockquote>
<p>hmm, it seems incorrect that we&#x27;re emitting this diagnostic. It definitely exists at runtime:</p>
<pre><code>&gt;&gt;&gt; def f(): ...
... 
&gt;&gt;&gt; f.__code__
&lt;code object f at 0x105d60b90, file &quot;&lt;python-input-0&gt;&quot;, line 1&gt;
&gt;&gt;&gt; class Foo:
...     def f(): ...
...     
&gt;&gt;&gt; Foo().f.__code__
&lt;code object f at 0x105d60c60, file &quot;&lt;python-input-2&gt;&quot;, line 2&gt;
</code></pre>
<p>and it&#x27;s annotated as existing on <code>FunctionType</code> instances in typeshed: https://github.com/astral-sh/ruff/blob/cb9e66927e4658247c1952a67a55a3c3b39523b4/crates/ty_vendored/vendor/typeshed/stdlib/types.pyi#L72-L76</p>
<p>I suppose we need to fallback to <code>Instance(&quot;FunctionType&quot;)</code> for member access on <code>CallableType</code> inhabitants if <code>is_function_like</code> is set to <code>true</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7582 on 2025-05-21 14:18</div>
            <div class="timeline-body"><p>Can you update the comment here to indicate that it creates a function-like callable? (i.e. one that bind self when participating in the descriptor protocol)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6944 on 2025-05-21 14:19</div>
            <div class="timeline-body"><p>If it doesn&#x27;t change any of the current visible behavior I think I would prefer <code>true</code> here, if we&#x27;re using that field to indicate whether the callable binds self when participating in the descriptor protocol.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7660 on 2025-05-21 14:20</div>
            <div class="timeline-body"><p>I think the parameter is fine, at least for now â€” it has the benefit of making us think about whether a callable is function-like each time we create one</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-05-21 14:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-05-21 14:23</div>
            <div class="timeline-body"><p>Are <code>CallableType</code> inhabitants with <code>is_function_like: true</code> modeled as (consistent) subtypes of <code>Instance(&quot;types.FunctionType&quot;)</code>? I think they should be -- could you add a test?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-05-21 14:27</div>
            <div class="timeline-body"><p>I guess I&#x27;m not <em>totally</em> sold that these should be modeled as a special case of <code>CallableType</code> rather than being modeled as a special case of <code>FunctionLiteral</code> (or being their own <code>Type</code> variant entirely) -- the subtyping/assignability and member-access questions seem to me like function-like <code>CallableType</code>s behave pretty differently to non-function-like <code>CallableType</code>s</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-21 14:34</div>
            <div class="timeline-body"><p>I think it would be important to see some new subtyping and assignability tests (and the code to make them pass, which I also don&#x27;t think I&#x27;m seeing here?), which should verify several things:</p>
<ul>
<li>A fully-static callable type that is function-like is a subtype of the same callable type that is not function-like, but not the other way around. (Unless I&#x27;m missing something, it seems like this PR currently doesn&#x27;t consider <code>is_function_like</code> in callable-subtyping at all, which I think would mean it fails to recognize the &quot;not&quot; part of this?)</li>
<li>Same for assignability.</li>
<li>A function literal is a subtype of its own <code>into_callable_type</code> (this could almost be a property test?)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-21 14:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7638 on 2025-05-21 14:35</div>
            <div class="timeline-body"><p>I think we could be a bit more precise in our description here, i.e. a callable type with <code>is_function_like: True</code> is inhabited by callable objects with the given signature that also have a <code>__get__</code> method which acts like <code>FunctionType.__get__</code> (returns a bound method).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 15:26</div>
            <div class="timeline-body"><blockquote>
<pre><code>```diff
+ warning[possibly-unbound-attribute] tests/test_dunders.py:1008:13: Attribute `__code__` on type `Unknown | ((self: C) -&gt; None)` is possibly unbound
</code></pre>
<p>hmm, it seems incorrect that we&#x27;re emitting this diagnostic. It definitely exists at runtime:</p>
</blockquote>
<p>Yes, thanks! At runtime, it also exists for generated methods on dataclasses. This should be fixed now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 15:31</div>
            <div class="timeline-body"><blockquote>
<p>Are <code>CallableType</code> inhabitants with <code>is_function_like: true</code> modeled as (consistent) subtypes of <code>Instance(&quot;types.FunctionType&quot;)</code>? I think they should be -- could you add a test?</p>
</blockquote>
<p>Yes, thanks. Added the test, but haven&#x27;t fixed it yet.</p>
<blockquote>
<p>I guess I&#x27;m not <em>totally</em> sold that these should be modeled as a special case of <code>CallableType</code> rather than being modeled as a special case of <code>FunctionLiteral</code> (or being their own <code>Type</code> variant entirely) -- the subtyping/assignability and member-access questions seem to me like function-like <code>CallableType</code>s behave pretty differently to non-function-like <code>CallableType</code>s</p>
</blockquote>
<p>I originally planned it this way, but somehow accidentally did the &quot;reverse&quot; today and special-cased <code>Type::Callable</code>, and wondered why it was so much easier than I had anticipated :smile:. I will re-evaluate this after quickly trying to implement subtyping with the existing approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 15:35</div>
            <div class="timeline-body"><blockquote>
<p>I think it would be important to see some new subtyping and assignability tests (and the code to make them pass, which I also don&#x27;t think I&#x27;m seeing here?), which should verify several things:</p>
<ul>
<li><p>A fully-static callable type that is function-like is a subtype of the same callable type that is not function-like, but not the other way around. (Unless I&#x27;m missing something, it seems like this PR currently doesn&#x27;t consider <code>is_function_like</code> in callable-subtyping at all, which I think would mean it fails to recognize the &quot;not&quot; part of this?)</p>
</li>
<li><p>Same for assignability.</p>
</li>
</ul>
</blockquote>
<p>So this is interesting. I added the tests, and they.. just pass. It works not because we&#x27;re looking at the <code>is_function_like</code> attribute, but rather because the corresponding synthesized callable has positional-or-keyword parameters with names, whereas the equivalent callable type has positional-only parameters without any name.</p>
<pre><code>type DunderInitType = TypeOf[C.__init__]  # (self: C, x: int) -&gt; None
type EquivalentCallableType = Callable[[C, int], None]  # (C, int, /) -&gt; None
</code></pre>
<p>This is probably not a <em>great</em> way to ensure proper subtyping/assignability properties, so I can look into incorporating <code>is_function_like</code> somehow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-21 15:46</div>
            <div class="timeline-body"><blockquote>
<p>I can look into incorporating <code>is_function_like</code> somehow</p>
</blockquote>
<p>I think the implementation shouldn&#x27;t be too difficult? Just a check in <code>is_assignable_to_impl</code> that the two <code>is_function_like</code>, if they differ, differ only in the right direction.</p>
<p>Writing a failing test may be more of the challenge, but I think if you also define <code>EquivalentCallableType</code> by writing an actual function and then using <code>CallableTypeOf</code> on it, that might work?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-05-21 16:10</div>
            <div class="timeline-body"><blockquote>
<p>somehow accidentally did the &quot;reverse&quot; today and special-cased <code>Type::Callable</code>, and wondered why it was so much easier than I had anticipated</p>
</blockquote>
<p>it being &quot;easier&quot; doesn&#x27;t necessarily reassure me ;) that might just mean that we&#x27;ve accidentally omitted some branches in some places that we would otherwise be forced to add if it was its own variant ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-21 18:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-22 05:43</div>
            <div class="timeline-body"><p>If we do have this as a form of Callable type, it might mean that we could be &quot;smart&quot; about <code>method_attr: Callable[[Self], int] = function_object</code> vs <code>non_method_attr: Callable[[], int] = other_non_function_like_callable_object</code>, where we actually use the type of the RHS as a hint to decide whether we consider the declaration to be of a &quot;method descriptor&quot; or &quot;non method descriptor&quot; callable type. That could let us avoid some unsoundness? See <a href="https://github.com/astral-sh/ruff/pull/18167">astral-sh/ruff#18167</a>#issuecomment-2899969500</p>
<p>On the other hand, it&#x27;s weird to interpret the same annotation differently depending on the RHS. So maybe we shouldn&#x27;t do that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-23 12:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-23 12:34</div>
            <div class="timeline-body"><p>Opening this up for review again. It passes all tests and resolves some ecosystem false positives. I am happy to spend (significantly?) more time on this, trying to rewrite it in terms of a customized <code>FunctionType</code> variant. I agree with @AlexWaygood that this might be less error-prone. But given that we currently only use this for one edge case (<em>explicit</em> calls to a synthetic dunder method on a dataclass, as in <code>MyDataClass.__lt__(â€¦)</code>), I&#x27;m not sure it&#x27;s worth it? The answer might depend on whether or not we foresee using this for purposes of resolving <a href="https://github.com/astral-sh/ty/issues/491">astral-sh/ty#491</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-05-27 19:31</div>
            <div class="timeline-body"><p>I think it&#x27;s fine to go with this for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-28 08:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-28 08:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-05-28 08:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-05-28 09:59</div>
            <div class="timeline-body"><blockquote>
<p>given that we currently only use this for one edge case (<em>explicit</em> calls to a synthetic dunder method on a dataclass, as in <code>MyDataClass.__lt__(â€¦)</code>), I&#x27;m not sure it&#x27;s worth it?</p>
</blockquote>
<p>But I think we should use function-like callables for lambdas too, since they&#x27;re also instances of <code>FunctionType</code> at runtime (they therefore have all those attributes that you can find on instances of <code>types.FunctionType</code>, and can be used as methods just fine if you assign them to symbols in class namespaces()</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:14:49 UTC
    </footer>
</body>
</html>
