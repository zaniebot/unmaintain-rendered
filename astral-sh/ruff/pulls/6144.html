<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skip partial duplicates when applying multi-edit fixes - astral-sh/ruff #6144</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Skip partial duplicates when applying multi-edit fixes</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/6144">#6144</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-07-28 04:18
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-28 04:18</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Right now, if we have two fixes that have an overlapping edit, but not an <em>identical</em> set of edits, they'll conflict, causing us to do another linter traversal. Here, I've enabled the fixer to support partially overlapping edits, which (as an example) let's us greatly reduce the number of iterations required in the test suite.</p>
<p>The most common case here is that in which a bunch of edits need to import some symbol, and then use that symbol, but in different ways. In that case, all edits will have a common fix (to import the symbol), but deviate in some way. With this change, we can do all of those edits in one pass.</p>
<p>Note that the simplest way to enable this was to store sorted edits on <code>Fix</code>. We don't allow modifying the edits on <code>Fix</code> once it's constructed, so this is an easy change, and allows us to avoid a bunch of clones and traversals later on.</p>
<p>Closes #5800.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 04:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:167 on 2023-07-28 04:19</div>
            <div class="timeline-body"><p>I'm disappointed with what's happening here. The ergonomics of it are fine, but it's so inefficient. <code>inorder</code> does a full clone, <code>retain</code> does a full clone, etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 04:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/test.rs</code>:88 on 2023-07-28 04:19</div>
            <div class="timeline-body"><p>Some payoff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/message/diff.rs</code>:45 on 2023-07-28 04:20</div>
            <div class="timeline-body"><p>It does feel good to DRY this up though -- this is now a method on <code>Edits</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 04:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @charliermarsh on 2023-07-28 04:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @charliermarsh on 2023-07-28 04:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2023-07-28 04:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-07-28 04:45</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Ecosystem</h3>
<p>✅ ecosystem check detected no changes.</p>
<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.02      8.6±0.20ms     4.7 MB/sec    1.00      8.4±0.13ms     4.8 MB/sec
formatter/numpy/ctypeslib.py               1.01  1662.2±29.19µs    10.0 MB/sec    1.00  1647.3±22.76µs    10.1 MB/sec
formatter/numpy/globals.py                 1.00    180.0±3.23µs    16.4 MB/sec    1.01    181.1±4.41µs    16.3 MB/sec
formatter/pydantic/types.py                1.00      3.6±0.05ms     7.1 MB/sec    1.00      3.6±0.05ms     7.1 MB/sec
linter/all-rules/large/dataset.py          1.00     11.1±0.08ms     3.7 MB/sec    1.00     11.1±0.08ms     3.7 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      2.8±0.02ms     5.9 MB/sec    1.00      2.8±0.01ms     5.9 MB/sec
linter/all-rules/numpy/globals.py          1.00    383.1±1.62µs     7.7 MB/sec    1.00    383.7±0.58µs     7.7 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.0±0.05ms     5.1 MB/sec    1.02      5.1±0.11ms     5.0 MB/sec
linter/default-rules/large/dataset.py      1.00      6.0±0.02ms     6.8 MB/sec    1.00      6.0±0.04ms     6.8 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1251.9±17.78µs    13.3 MB/sec    1.00  1251.7±18.74µs    13.3 MB/sec
linter/default-rules/numpy/globals.py      1.01    136.6±0.18µs    21.6 MB/sec    1.00    135.5±0.96µs    21.8 MB/sec
linter/default-rules/pydantic/types.py     1.00      2.6±0.03ms     9.7 MB/sec    1.01      2.6±0.06ms     9.6 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.01     10.6±0.19ms     3.8 MB/sec    1.00     10.5±0.13ms     3.9 MB/sec
formatter/numpy/ctypeslib.py               1.00      2.0±0.04ms     8.2 MB/sec    1.00      2.0±0.06ms     8.2 MB/sec
formatter/numpy/globals.py                 1.00    218.4±6.69µs    13.5 MB/sec    1.01    221.3±6.65µs    13.3 MB/sec
formatter/pydantic/types.py                1.01      4.4±0.09ms     5.8 MB/sec    1.00      4.4±0.08ms     5.8 MB/sec
linter/all-rules/large/dataset.py          1.00     14.2±0.24ms     2.9 MB/sec    1.00     14.2±0.15ms     2.9 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.7±0.04ms     4.6 MB/sec    1.00      3.7±0.06ms     4.5 MB/sec
linter/all-rules/numpy/globals.py          1.00    444.7±8.76µs     6.6 MB/sec    1.00   444.3±11.36µs     6.6 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.3±0.13ms     4.0 MB/sec    1.00      6.4±0.12ms     4.0 MB/sec
linter/default-rules/large/dataset.py      1.00      7.8±0.11ms     5.2 MB/sec    1.00      7.8±0.11ms     5.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1564.1±23.52µs    10.6 MB/sec    1.00  1557.2±29.38µs    10.7 MB/sec
linter/default-rules/numpy/globals.py      1.00    170.1±3.28µs    17.3 MB/sec    1.01    171.9±5.03µs    17.2 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.3±0.03ms     7.6 MB/sec    1.01      3.4±0.05ms     7.6 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/autofix/mod.rs</code>:64 on 2023-07-28 05:19</div>
            <div class="timeline-body"><p>Do you think it's feasible to create a <code>Vec&lt;&amp;Edit&gt;</code> which needs to be applied? i.e., filtering out the <code>Edit</code> which has been applied but not in place. This would avoid cloning the <code>Edit</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> approved on 2023-07-28 05:28</div>
            <div class="timeline-body"><p>I like the <code>Edits</code> interface! :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:165 on 2023-07-28 05:38</div>
            <div class="timeline-body"><p>Nit: It should be fine to restrict <code>Edits</code> to <code>&amp;'a [Edit]</code>. It doesn't have to be aware that some usages will use a <code>Cow</code> to avoid clones:</p>
<pre><code class="language-rust">pub struct Edits&lt;'a&gt;(&amp;'a [Edit]);

impl&lt;'a&gt; Edits&lt;'a&gt; {
	pub fn from_slice(edits: &amp;'a [Edit]) -&gt; Self {...}

	pub fn as_slice(&amp;self) -&gt; &amp;[Edit] { self.0 }
}

# usage

let mut plain_edits = Cow::Borrowed(fix.edits().as_slice());

if needs_mutating {
	plain_edits = Cow::Owned(vec![edit]);
}

let edits = Edits::from_slice(&amp;plain_edits);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:129 on 2023-07-28 05:39</div>
            <div class="timeline-body"><p>The methods above (like <code>min_start</code>) should now use <code>self.edits().min_start()</code> to avoid duplication.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:184 on 2023-07-28 05:40</div>
            <div class="timeline-body"><p>Nit: I would call this method <code>to_sorted</code> to clarify that this operation is potentially expensive.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:191 on 2023-07-28 05:51</div>
            <div class="timeline-body"><p>This eagerly clones the edits even if <code>f</code> never returns false.</p>
<p>We can avoid this by iterating manually and only take the slow path that allocates a new <code>Vec</code> if the predicate returns false</p>
<pre><code class="language-rust">let mut edits = self.0.iter().enumerate();
let last_index = loop {
	match edits.next() {
		Some((index, edit)) =&gt; {
			if !f(edit) {
				break index;
			}
		},
		None =&gt; {
			return Cow::Borrowed(self.edits);
		}
}

let mut edits = Vec::from_slice(&amp;self.edits[..last_index]);
edits.extend(self.edits[last_index + 1..].iter().filter(f).cloned()); // TODO requires bounds checks. 
Cow::Owned(edits)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:186 on 2023-07-28 05:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Retains the [`Edit`] elements in the [`Fix`] for which the predicate `f` returns true
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:183 on 2023-07-28 05:54</div>
            <div class="timeline-body"><p>Could you use <code>sort_unstable_by_key</code>? I mean, it doesn't really make a difference because <code>sort_unstable_by_key</code> allocates too, but you would then take benefit of only returning an Iterator</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:180 on 2023-07-28 05:54</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    pub fn inorder(&amp;self) -&gt; impl Iterator&lt;Item = Edit&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:187 on 2023-07-28 05:59</div>
            <div class="timeline-body"><p>I find the <code>retain</code> method somewhat confusing. It isn't explicit that it doesn't necessary mutate the elemnt in place and, instead, creates new elements.</p>
<p>We may even be able to get away by filtering the <code>edits</code> instead of calling <code>retain</code> (iterates over all edits once), <code>min</code> (iterates over all edits once), and <code>inorder</code> (iterates over all edits once).</p>
<ol>
<li>Sort the edits</li>
<li>Getting <code>min</code> is now for free -&gt; It's the start position of the first edit</li>
<li>We can now check adhoc if this specific edit has already been applied, rather than filtering them out previously</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2023-07-28 06:02</div>
            <div class="timeline-body"><p>This is an excellent observation.</p>
<p>I think we can implement this in a way that significantly reduces the time we iterate over edits and removes the in place mutation by</p>
<ol>
<li>Sort the edits of a fix</li>
<li>Skip over all edits of that fix that have already been applied</li>
<li>Take the start position of the first edit, this is the <code>min_start</code> and test if the fix doesn't overlap with another fix</li>
<li>Apply the fix(es)</li>
</ol>
<p>I think this should simplify the implementation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 12:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:183 on 2023-07-28 12:38</div>
            <div class="timeline-body"><p>Are you referring to the methods on <code>itertools</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:129 on 2023-07-28 12:40</div>
            <div class="timeline-body"><p>Ah I actually ended to remove that entirely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 12:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-07-28 12:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:183 on 2023-07-28 12:42</div>
            <div class="timeline-body"><p>Yes, I think that's where they're defined. I should have marked this as a Nit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 12:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:187 on 2023-07-28 12:45</div>
            <div class="timeline-body"><p>I think this is doable... but note that we want the <code>min</code> to be the position of the first non-filtered edit. We may still be able to check it ad hoc though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:183 on 2023-07-28 12:55</div>
            <div class="timeline-body"><p>Just confirming, I had the same instinct but this crate doesn't depend on <code>itertools</code> right now and I thought I'd get more heat for adding the dependency :joy:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 12:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 12:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:191 on 2023-07-28 12:56</div>
            <div class="timeline-body"><p>Part of what I meant when I commented that &quot;I'm disappointed with what's happening here.&quot; :joy:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2023-07-28 18:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-28 18:06</div>
            <div class="timeline-body"><p>This is a bit better could likely be better still.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-28 18:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/autofix/mod.rs</code>:87 on 2023-07-28 18:07</div>
            <div class="timeline-body"><p>This is kind of confusing (definitely easier to read locally than as a diff), but in short: we want to apply these constraints at the fix level, but if all of the fix's edits were already applied, we don't need to enforce them at all. So we do so lazily, only checking if the location is acceptable when we reach the first edit-to-apply.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-28 18:23</div>
            <div class="timeline-body"><p>Okay, the latest version stores sorted edits rather than sorting on the fly. I think this is a lot more efficient as we sort once (and iterate through the edits exactly once) and no longer need to do any clones anywhere. <code>min_start</code> also becomes O(1).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:46 on 2023-07-29 08:06</div>
            <div class="timeline-body"><p>Nit: sorted by [<code>Edit::start</code>] in ascending order</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_diagnostics/src/fix.rs</code>:144 on 2023-07-29 08:07</div>
            <div class="timeline-body"><p>Nit: sorted by [<code>Edit::start</code>] in ascending order</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/autofix/mod.rs</code>:53 on 2023-07-29 08:33</div>
            <div class="timeline-body"><p>Nit: If you want to avoid the labels, but it requires an additional vector:</p>
<pre><code class="language-rust">        let mut edits = fix
            .edits()
            .iter()
            .filter(|edit| !applied.contains(edit))
            .peekable();

        // Lazily enforce any isolation and positional requirements (e.g., avoid applying
        // overlapping fixes, but avoid applying this requirement if all fixes in the edit were
        // already applied).
        if let Some(first) = edits.peek() {
            // If this fix requires isolation, and we've already applied another fix in the
            // same isolation group, skip it.
            if let IsolationLevel::Group(id) = fix.isolation() {
                if !isolated.insert(id) {
                    continue;
                }
            }

            // Best-effort approach: if this fix overlaps with a fix we've already applied,
            // skip it.
            if last_pos.map_or(false, |last_pos| last_pos &gt;= first.start()) {
                continue;
            }
        }

        for edit in edits {
            // Add all contents from `last_pos` to `fix.location`.
            let slice = locator.slice(TextRange::new(last_pos.unwrap_or_default(), edit.start()));
            output.push_str(slice);

            // Add the start source marker for the patch.
            source_map.push_start_marker(edit, output.text_len());

            // Add the patch itself.
            output.push_str(edit.content().unwrap_or_default());

            // Add the end source marker for the added patch.
            source_map.push_end_marker(edit, output.text_len());

            // Track that the edit was applied.
            last_pos = Some(edit.end());
            applied_edits.push(edit);
        }

        applied.extend(applied_edits.drain(..));
        *fixed.entry(rule).or_default() += 1;
    }
</code></pre>
<p>I don't have a preference to be honest. I just thought this is complicated, and then noticed that it is because we read from and write to <code>applied</code> at the same time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-07-29 08:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-07-29 12:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/autofix/mod.rs</code>:53 on 2023-07-29 12:00</div>
            <div class="timeline-body"><p>I think what you have here is a big clarity improvement, worth the allocation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-07-29 12:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-07-29 12:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-07-29 12:11</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 02:59:05 UTC
    </footer>
</body>
</html>
