<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Type narrow in else clause - astral-sh/ruff #13918</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Type narrow in else clause</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13918">#13918</a>
        opened by <a href="https://github.com/TomerBin">@TomerBin</a>
        on 2024-10-24 22:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a></div>
            <div class="timeline-body"><p>Added support for type narrowing in elif and else scopes as part of #13694.</p>
<h2>Summary</h2>
<p>This is ready for review, though still somewhat of a draft. Please let me know if I addressed this correctly or if a completely different solution would be better :)</p>
<h2>Test Plan</h2>
<ul>
<li>mdtest</li>
<li>builder unit test for union negation.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-24 22:40</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>‚úÖ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>‚úÖ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a> reviewed on 2024-10-24 23:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/TomerBin">@TomerBin</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:683 on 2024-10-24 23:13</div>
            <div class="timeline-body"><p>I didn't find any another builder tests that assert the <code>display</code> value of the result type but I actually find it more expressive and readable that way. LMK if I should better stick to the other tests' style.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a> reviewed on 2024-10-24 23:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/TomerBin">@TomerBin</a> on <code>crates/red_knot_python_semantic/src/semantic_index/constraint.rs</code>:16 on 2024-10-24 23:34</div>
            <div class="timeline-body"><p>In this context, &quot;constraint&quot; term is used for both the node that applies the constraint, and for the outcome of the narrowing process.
What do you think about renaming this one into <code>TypeGuard</code> and use <code>constraint</code> name only for the output (map from symbol ids to types)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @TomerBin on 2024-10-24 23:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @TomerBin on 2024-10-24 23:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @TomerBin on 2024-10-24 23:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @TomerBin on 2024-10-24 23:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is.md</code>:60 on 2024-10-24 23:40</div>
            <div class="timeline-body"><p>Shouldn't we be able to narrow this to <code>Literal[True]</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is_not.md</code>:95 on 2024-10-24 23:42</div>
            <div class="timeline-body"><p>Shouldn't we be able to infer <code>Literal[False]</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:683 on 2024-10-24 23:52</div>
            <div class="timeline-body"><p>No, I think this is fine!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:177 on 2024-10-24 23:59</div>
            <div class="timeline-body"><p>I don't think we need to clone here, tests pass with just this:</p>
<pre><code class="language-suggestion">                self = self.add_negative(*elem);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:667 on 2024-10-24 23:59</div>
            <div class="timeline-body"><p>Nice catch!!</p>
<p>I think we might also behave wrongly for de Morgan's other law, adding an intersection on the negative side of an IntersectionBuilder. This should distribute out to a union, (using I think basically the same fold code you removed above). Can you add a test and fix for that as well? (Could be in a separate PR, too.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/constraint.rs</code>:16 on 2024-10-25 00:05</div>
            <div class="timeline-body"><p>Hmm. I'm open to a renaming here to better distinguish these, but not sure I like <code>TypeGuard</code>, I'd rather avoid that term outside of dealing with the actual <code>typing.TypeGuard</code> feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:68 on 2024-10-25 00:11</div>
            <div class="timeline-body"><p>Hmm, I think Salsa does something kind of inefficient when a tracked function has multiple inputs; it internally interns all the arguments. Although it's slightly weird-looking, I think we will get more efficient results here if we break into two separate Salsa tracked functions, <code>all_narrowing_constraints_for_expression</code> and <code>all_negative_narrowing_constraints_for_expression</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:75 on 2024-10-25 00:12</div>
            <div class="timeline-body"><p>Is it worth re-building a <code>Constraint</code> struct here vs just passing in the two elements separately to the builder? It mostly seems like it just results in more verbose usage inside the builder (<code>self.constraint.negative</code> vs <code>self.negative</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:224 on 2024-10-25 00:16</div>
            <div class="timeline-body"><p>We could make the match arms a bit less repetitive/verbose here (though arguably also less explicit?) if we call a function here that returns the negated <code>ast::CmpOp</code> if <code>negative</code> and then match on the resulting <code>CmpOp</code>. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:11 on 2024-10-25 00:23</div>
            <div class="timeline-body"><p>We've previously discussed that we can't actually safely do this narrowing, because <code>x</code> here could be an instance of some subclass of <code>int</code> that overrides <code>__eq__</code> to compare equal to <code>1</code>.</p>
<p>Perhaps experience will tell us that we are being too conservative here, and we should just ignore that possibility; but I'd rather not do that until/unless it's clear that we need to.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:258 on 2024-10-25 00:31</div>
            <div class="timeline-body"><p>As discussed in another comment in the tests, I don't think we can generally narrow on equality checks (or negative inequality checks). But I think we can (and probably will need to) do a more limited form of this, where we check the type of the LHS and if it is a union of single-valued types, we eliminate (by constraining with a negative intersection of) any single-valued types that we know are disjoint with the RHS.</p>
<p>In other words, while we can't infer that <code>x: int; if x == 1:</code> results in <code>Literal[1]</code>, we can infer that <code>x: Literal[1, 2, 3]; if x == 1:</code> results in <code>Literal[1]</code>, and I think we'll need to be able to make the latter inference.</p>
<p>(There may be a more general way to frame this than what I wrote above, need to think about it.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-25 00:32</div>
            <div class="timeline-body"><p>This is really excellent, thank you for doing this!!</p>
<p>Some comments below; maybe don't put too much work into addressing comments until @AlexWaygood and/or @sharkdp have a chance to take a look.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @carljm on 2024-10-25 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-10-25 01:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-25 06:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is.md</code>:60 on 2024-10-25 06:51</div>
            <div class="timeline-body"><p>No, because there are two conditions in the <code>if</code> clause. And only one of them could be <code>False</code>: if <code>y = True</code> and <code>x = False</code>, we also end up in this branch.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is_not.md</code>:95 on 2024-10-25 06:58</div>
            <div class="timeline-body"><p>No. Similar to above: if <code>x = y = False</code>, we also end up in this branch.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-25 06:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-25 07:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is_not.md</code>:1 on 2024-10-25 07:03</div>
            <div class="timeline-body"><p>In this file, can we maybe also add something equivalent to the test &quot;<code>is</code> for other types&quot; test, but for <code>is not</code>:</p>
<pre><code class="language-py">class A: ...

x = A()
y = x if flag else None

if y is not x:
    reveal_type(y)  # revealed: A | None
else:
    reveal_type(y)  # revealed: A
</code></pre>
<p>This wouldn't have been very interesting/useful before. But now with the <code>else</code> branch, it is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-25 07:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/constraint.rs</code>:16 on 2024-10-25 07:27</div>
            <div class="timeline-body"><p>We often called these types <em>Kind</em> in other places.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-25 08:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/isinstance.md</code>:110 on 2024-10-25 08:11</div>
            <div class="timeline-body"><p>Not sure if always desirable, but we could maybe add a <code>TODO</code> here to always remove <code>object</code> from the positive side of an intersection.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a> reviewed on 2024-10-25 15:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/TomerBin">@TomerBin</a> on <code>crates/red_knot_python_semantic/src/semantic_index/constraint.rs</code>:16 on 2024-10-25 15:10</div>
            <div class="timeline-body"><p>What do you think about &quot;Predicate&quot;? I like that it's more easy to understand what &quot;negative&quot; means on a predicate, than on Type or Kind as of the negation of a predicate doesn't always imply the negation of its outcome constraint.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-25 15:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is.md</code>:60 on 2024-10-25 15:36</div>
            <div class="timeline-body"><p>Unresolving this conversation because it might be useful to add a comment here explaining this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-25 15:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is_not.md</code>:95 on 2024-10-25 15:36</div>
            <div class="timeline-body"><p>And here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-25 15:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/constraint.rs</code>:16 on 2024-10-25 15:41</div>
            <div class="timeline-body"><p>I'm happy with &quot;Predicate&quot;!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/narrow.rs</code>:258 on 2024-10-25 17:49</div>
            <div class="timeline-body"><p>This represents a more general category of narrowing cases that we will also run into with, for example, simple <code>if not x:</code> narrowing, where the information gained from the narrowing in that case is &quot;<code>x</code> is falsy&quot; and in this case is &quot;<code>x</code> is equal to 1&quot;, neither of which is a constraint that can correctly be expressed simply a type to intersect <code>x</code> with, given our currently available types. I spent some more time thinking about this, and wrote it up at https://github.com/astral-sh/ruff/issues/13694#issuecomment-2438438759</p>
<p>I'm afraid that's a bit long, but I think the relevant conclusion for this PR is, let's not handle it in this PR :) For this PR, let's just remove the narrowing on <code>==</code> (or negated <code>!=</code>) entirely for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-25 17:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-25 17:50</div>
            <div class="timeline-body"><p>@TomerBin are you ready for another review of this? There are still some previous comments unresolved.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-10-25 18:33</div>
            <div class="timeline-body"><blockquote>
<p>@TomerBin are you ready for another review of this? There are still some previous comments unresolved.</p>
</blockquote>
<p>@carljm Not yet.. I wanted to ask something regarding <strong>eq</strong>. The logic prior to this PR does add single-value types in the rhs as a negative constraint on the symbol, without considering whether the lhs is single-valued.</p>
<pre><code class="language-py">ast::CmpOp::NotEq =&gt; {
                        if rhs_ty.is_single_valued(self.db) {
                            let ty = IntersectionBuilder::new(self.db)
                                .add_negative(rhs_ty)
                                .build();
                            self.constraints.insert(symbol, ty);
                        }
                    }
</code></pre>
<p>In the scope of this PR - do you think this logic should be adopted as well? Or should I just ignore the negation of this predicate at all?</p>
<p>Thanks :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-25 18:46</div>
            <div class="timeline-body"><p>Although it's not safe to apply an intersection with <code>Literal[1]</code> as a result of <code>if x == 1</code>, it is safe to apply an intersection with <code>~Literal[1]</code> as a result of <code>if x != 1</code>. In the former case, we can't say that <code>x</code> must be <code>Literal[1]</code>, it could be some other type that just compares equal to <code>1</code>. But in the latter case, we can definitively say that <code>x</code> cannot be <code>Literal[1]</code>, because we know that every inhabitant of <code>Literal[1]</code> always compares equal to <code>1</code>.</p>
<p>So the current code is correct.</p>
<p>And in this PR, I think it is always the case that if we can infer something from <code>x != y</code>, then we can infer the same thing from the <code>else</code> clause of <code>if x == y</code>.</p>
<p>So yes, I think we should, in this PR, infer that in the <code>else</code> clause of <code>if x == 1</code>, we apply a constraint of <code>~Literal[1]</code> to <code>x</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/TomerBin">@TomerBin</a> reviewed on 2024-10-25 18:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/TomerBin">@TomerBin</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:667 on 2024-10-25 18:47</div>
            <div class="timeline-body"><p>Im not sure how to test that in a unit test. I need to generate an intersection between two types that won't be simplified (so they can't be disjoint). If it was an mdtest I'd do it with class literals, but I'm not sure how to that that in here. Do you have an idea?
Maybe Ill prefer to do it in separate PR if you're happy with that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-25 19:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:667 on 2024-10-25 19:00</div>
            <div class="timeline-body"><p>Yes, separate PR is totally fine! I've created an issue just to make sure we don't lose track of it, in case you don't have time to do it: https://github.com/astral-sh/ruff/issues/13931</p>
<p>I think you can use known types from typeshed to create the intersection? E.g. <code>KnownClass::Str.to_instance()</code> and <code>KnownClass::Int.to_instance()</code> can be intersected without simplifying.</p>
<p>(Technically we probably should consider these disjoint because they are both builtin types with different memory layouts, so you can't subclass both of them at runtime. But we don't represent this yet.)</p>
<p>I think you can also just <code>db.write_file(...)</code> a file with a couple class definitions in it, much like the tests in <code>infer.rs</code>, and then pull out those class types. It's a bit more boilerplate, and there aren't existing tests in here that do it, but it's fine to do it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-10-26 09:02</div>
            <div class="timeline-body"><p>I think that It's ready for another CR :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:6 on 2024-10-26 10:07</div>
            <div class="timeline-body"><p>We should fill in the bodies of helper functions in tests so that they don't start failing in the future when we start checking that functions actually return what they say they return:</p>
<pre><code class="language-suggestion">def int_instance() -&gt; int:
    return 42
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_not_eq.md</code>:81 on 2024-10-26 10:08</div>
            <div class="timeline-body"><pre><code class="language-suggestion">def int_instance() -&gt; int:
    return 42
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/constraint.rs</code>:12 on 2024-10-26 10:12</div>
            <div class="timeline-body"><p>It feels slightly odd to me that a negative boolean value for this field indicates a positive predicate. Could we have the meaning flipped, so that a positive value for the field indicates a positive predicate (and vice versa)?</p>
<pre><code class="language-suggestion">    pub(crate) is_positive: bool,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-26 10:21</div>
            <div class="timeline-body"><p>(Just a few comments from skimming, haven't looked properly yet!)</p>
<p>Looks like some of your tests are failing following https://github.com/astral-sh/ruff/commit/6aaf1d944657a7f37bd99c781c2b1ebdebfdf0e3 being pushed to <code>main</code> ‚Äî you'll need to define the <code>flag</code> variables in your tests in the same way we did in that commit. (You may need to merge in <code>main</code> or rebase to see the same test failures locally)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:30 on 2024-10-26 15:40</div>
            <div class="timeline-body"><p>We'll not do it in this PR, but let's note the TODOs</p>
<pre><code class="language-suggestion">    # TODO should be Literal[1]
    reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:33 on 2024-10-26 15:41</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO should be Literal[2]
    reveal_type(x)  # revealed: Literal[2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:47 on 2024-10-26 15:44</div>
            <div class="timeline-body"><p>I think this comment meant to discuss <code>Literal[3]</code>, not <code>Literal[1]</code>? <code>Literal[1]</code> should be the <em>only</em> possibility here, since we are dealing with literals. We're not doing it in this PR, but we should do narrowing on <code>==</code> enough to eliminate <code>Literal[3]</code> here, since we know it can never be <code>== 1</code>.</p>
<pre><code class="language-suggestion">    # TODO should be `Literal[1]`
    reveal_type(x)  # revealed: Literal[1, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:13 on 2024-10-26 15:46</div>
            <div class="timeline-body"><p>let's clarify this for future readers, that this is <em>not</em> a todo</p>
<pre><code class="language-suggestion">    # cannot narrow; could be a subclass of `int`
    reveal_type(x)  # revealed: int
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:50 on 2024-10-26 15:49</div>
            <div class="timeline-body"><p>But we should, because we're dealing with literal types! Just not in this PR.</p>
<pre><code class="language-suggestion">    # TODO should be Never
    reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_elif_else.md</code>:56 on 2024-10-26 15:49</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO should be Never
    reveal_type(x)  # revealed: Literal[1, 2]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_nested.md</code>:44 on 2024-10-26 15:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        # TODO should be `Literal[2]`
        reveal_type(x)  # revealed: Literal[2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_nested.md</code>:52 on 2024-10-26 15:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO should be Literal[1]
    reveal_type(x)  # revealed: Literal[1, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_nested.md</code>:55 on 2024-10-26 15:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO should be Never
    reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_not_eq.md</code>:16 on 2024-10-26 15:54</div>
            <div class="timeline-body"><p>Again here, we should be able to do this narrowing, in a future PR, because the types <code>None</code> and <code>Literal[1]</code> are both literal types, there can't be unknown subclasses with unknown equality behavior.</p>
<pre><code class="language-suggestion">    # TODO should be None
    reveal_type(x)  # revealed: None | Literal[1]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_not_eq.md</code>:32 on 2024-10-26 15:54</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO should be Literal[False]
    reveal_type(x)  # revealed: bool
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_not_eq.md</code>:65 on 2024-10-26 15:55</div>
            <div class="timeline-body"><p>Again here because these are literal class types that don't admit subclasses, in future we should be able to do this narrowing</p>
<pre><code class="language-suggestion">    # TODO should be Literal[A]
    reveal_type(C)  # revealed: Literal[A, B]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_not_eq.md</code>:81 on 2024-10-26 15:56</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO should be Literal[2]
    reveal_type(x)  # revealed: Literal[1, 2]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:168 on 2024-10-26 15:58</div>
            <div class="timeline-body"><p>I think if we rename <code>Constraint</code> to <code>Predicate</code> we should also rename <code>ScopedConstraintId</code> to <code>ScopedPredicateId</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def/symbol_state.rs</code>:7 on 2024-10-26 15:59</div>
            <div class="timeline-body"><p>seems like there are some missed places where we should rename <code>constraint</code> to <code>predicate</code></p>
<pre><code class="language-suggestion">//! We need to track arbitrary associations between bindings and predicates, not just a single set
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-26 16:03</div>
            <div class="timeline-body"><p>Looks good! 90% of my comments are just that we should have TODOs in tests reflecting the equality narrowing for literal types that we should do in future, as discussed. I'll just apply these suggested changes.</p>
<p>It also looks to me like the constraint -&gt; predicate rename isn't quite fully carried through. If it's OK I might just also push some changes to complete that, and then go ahead and land this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-26 16:08</div>
            <div class="timeline-body"><p>After looking at it more, I think for now I'm just going to revert the Predicate name change in this PR. There's still a ton of things named &quot;constraint&quot; inside the use-def map and semantic index, so the current change just leaves us in an even less consistent naming situation. Fully carrying out the rename in this PR would drown out the substantive changes.</p>
<p>Still open to the renaming if you're interested in pursuing it, but let's consider it as a separate PR. If we do it, it should be thorough -- like a grep for <code>onstraint</code> inside <code>src/semantic_index/</code> should give zero hits, and <code>semantic_index/constraint.rs</code> should be renamed, etc. The name &quot;constraint&quot; would be reserved only for <code>narrow.rs</code>, on the type inference side.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TomerBin">@TomerBin</a> on 2024-10-26 16:17</div>
            <div class="timeline-body"><p>LGTM üëçüëç</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-10-26 16:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-10-26 16:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-26 16:57</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:07:13 UTC
    </footer>
</body>
</html>
