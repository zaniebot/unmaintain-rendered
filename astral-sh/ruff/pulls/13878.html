<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add internal documentation on kinds of types - astral-sh/ruff #13878</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add internal documentation on kinds of types</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13878">#13878</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-10-22 12:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR adds purely internal documentation to assist us, as red-knot developers. By having a common reference with precise definitions for certain terms, there's a reduced risk of misunderstanding.</p>
<h2>Test Plan</h2>
<p><code>pre-commit run -a</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">documentation</span> added by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-10-22 12:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-22 12:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:79 on 2024-10-22 12:24</div>
            <div class="timeline-body"><p>â€¦ and <code>Never</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 12:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:79 on 2024-10-22 12:25</div>
            <div class="timeline-body"><p>ðŸ™ƒ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:109 on 2024-10-22 12:32</div>
            <div class="timeline-body"><p>One thing that could be clarified here: Is <code>Never</code> a single-value type or not? The way I implemented <code>is_single_valued()</code>, <code>Never</code> is excluded. So that definition would have to include something like &quot;A single-value type is a non-empty type for which â€¦&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-22 12:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-22 12:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:151 on 2024-10-22 12:33</div>
            <div class="timeline-body"><p>Sorry for being pedantic: &quot;except for the type itself and the empty type&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 12:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:151 on 2024-10-22 12:34</div>
            <div class="timeline-body"><p>Already fixed this in my latest push, I think :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 12:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:151 on 2024-10-22 12:34</div>
            <div class="timeline-body"><p>Also this is exactly the kind of PR where pedantry is most important haha</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2024-10-22 12:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-22 13:10</div>
            <div class="timeline-body"><p>I wondered whether these docs would be better placed somewhere like https://typing.readthedocs.io/en/latest/. But I'm not sure it would be a great fit for that site, because:</p>
<ul>
<li>Some of the concepts for our internal model of Python's types are not standardised as part of the spec. For example, our concepts of &quot;class-literal&quot; and &quot;function-literal&quot; singleton types are not something that all Python type checkers have</li>
<li>It's not clear that these terms are relevant to either the typing spec or the user-facing documentation parts of https://typing.readthedocs.io/en/latest/</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:53 on 2024-10-22 14:58</div>
            <div class="timeline-body"><p>I get what you're aiming to say here, but I don't think this is true. If we have, for instance, a sealed enum type <code>E</code>, with members <code>E.A</code>, <code>E.B</code>, and <code>E.C</code>, then the type <code>Literal[E.A] | Literal[E.B]</code> is a proper subtype of <code>E</code>, and so is the type <code>Literal[E.B] | Literal[E.C]</code>, but those two proper subtypes are not disjoint.</p>
<p>I'm not sure how to say what you're trying to say here, other than to say that the sealed type consists of the union of the literal types for all its known inhabitants, which kind of feels like just repeating the definition of a sealed type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:65 on 2024-10-22 15:01</div>
            <div class="timeline-body"><p>This is true for <code>bool</code>, because it only has two inhabitants, so we can't construct any non-disjoint union types of its inhabitants.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:82 on 2024-10-22 15:24</div>
            <div class="timeline-body"><p>This is not true, because it fails to consider unions of inhabitants, which are also proper subtypes of <code>Foo</code>. But I think if you just replace &quot;proper subtype&quot; with &quot;inhabitant&quot;, leave out Never, and don't mention disjointness (since individual objects are by definition &quot;disjoint&quot; from each other), you can reach the same conclusion below (regarding how a negated intersection with the overall type is equivalent to a union of literal types for its inhabitants), which is the important part.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:79 on 2024-10-22 15:24</div>
            <div class="timeline-body"><p>Here you mention only <code>X</code> and <code>Y</code>, but below you also mention <code>Z</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:155 on 2024-10-22 15:48</div>
            <div class="timeline-body"><p>I think this wording has a similar problem with arbitrary intersection and union types as the above wording on sealed types.</p>
<p>I think we have to present closed types in a way that's more tied to &quot;instance&quot; types -- as in, it's a type defined as instances of a class, which cannot be subclassed, therefore all inhabitants of the type must be instances of the final class.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 15:50</div>
            <div class="timeline-body"><p>I don't think this paragraph is right. I don't think &quot;has no proper subtypes other than itself and Never&quot; is a workable or useful definition of what it means to be a closed type, and I think both <code>bool</code> and <code>Eggs</code> should be considered closed types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:109 on 2024-10-22 15:52</div>
            <div class="timeline-body"><p>It might be considered implied by &quot;equivalence&quot;, but I think we should be explicit from the beginning that we are talking here about equivalence with respect to Python equality as defined by <code>__eq__</code> and <code>__ne__</code> implementations. &quot;Equivalent with respect to their runtime value&quot; is less clear what exactly we are talking about.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:123 on 2024-10-22 15:55</div>
            <div class="timeline-body"><p>The definition of a single-value type is specific to the Python equality relation, so it seems odd to say &quot;there must exist a ... relation&quot; here.</p>
<p>I would say instead that a single-value type must have a reflexive, symmetric, and transitive definition of Python equality.</p>
<p>But really I kind of think this entire paragraph might not be necessary; I think the literal-type examples you give above are probably sufficient to clarify what a real single-value type looks like. In practice we are never going to try to define any single-value type on a non-builtin class, or any class that might challenge the requirements.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-10-22 15:56</div>
            <div class="timeline-body"><p>Thanks for writing this up! The core ideas look great, I think there are a few issues in some wordings.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:53 on 2024-10-22 16:00</div>
            <div class="timeline-body"><p>Great point, thanks. I think the best solution is just to remove this paragraph.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:109 on 2024-10-22 16:16</div>
            <div class="timeline-body"><p>The introductory paragraph at the top of the document states:</p>
<blockquote>
<p>This document provides definitions for various kinds of types, with examples of Python types that satisfy these definitions.</p>
</blockquote>
<p>I'm <em>trying</em> to present generalised definitions in the first 1-2 sentences of each section, that would apply outside of the specific context of Python, then in later sentences expand on the initial definition and link it back to the concept of Python types. So I would <em>prefer</em> not to mention <code>__eq__</code> or <code>__ne__</code> in the first sentence here, as this is very specific to the way equivalence between arbitrary objects is generally implemented in Python.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:123 on 2024-10-22 16:18</div>
            <div class="timeline-body"><p>Well, you could theorise that there could exist other single-value types in Python other than the ones we know about; they just wouldn't be recognised as such by red-knot.</p>
<blockquote>
<p>In practice we are never going to try to define any single-value type on a non-builtin class</p>
</blockquote>
<p>I don't think this is true. <code>Literal[E.A]</code>, for an enum <code>E</code> with a member <code>A</code>, is a single-value type (as a consequence of being a singleton type).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 16:25</div>
            <div class="timeline-body"><p>What <em>is</em> the term you would use for a type where it is known that no proper subtypes exist other than <code>Never</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:123 on 2024-10-22 16:28</div>
            <div class="timeline-body"><blockquote>
<p><code>Literal[E.A]</code>, for an enum <code>E</code> with a member <code>A</code>, is a single-value type.</p>
</blockquote>
<p>Fair! And if we observe a custom <code>__eq__</code> implementation on an <code>Enum</code> subclass, we probably have to stop treating literal types of those enum members as single-valued types, because we no longer can claim to understand the equality relation for instances of that enum type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:109 on 2024-10-22 16:35</div>
            <div class="timeline-body"><p>I didn't realize you were aiming to initially present a definition of each type abstracted from the Python context. I'm not sure how concretely valuable that is, since this is documentation for red-knot, which is a Python type-checker. And I think it's a bit challenging for &quot;single-valued type&quot; specifically, because what we mean by the term in red-knot <em>is</em> specific to the relation defined by <code>__eq__</code> and <code>__ne__</code>. It's certainly possible, though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:109 on 2024-10-22 16:38</div>
            <div class="timeline-body"><p>I think the core issue here is that the phrase &quot;equivalent with respect to their runtime value&quot; doesn't have any clear meaning in an abstract type system sense. So if you want to present an abstract definition, you'll have to start by saying &quot;Assuming some equivalence relation is defined on type inhabitants...&quot; and go from there.</p>
<p>(You can probably also skip discussion of reflexivity, transitivity, and symmetry, and relegate that to a footnoted link to e.g. https://en.wikipedia.org/wiki/Equivalence_relation, if you are using the term &quot;equivalence relation&quot;, since an equivalence relation is defined to require all of those properties.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:109 on 2024-10-22 16:40</div>
            <div class="timeline-body"><blockquote>
<p>I didn't realize you were aiming to initially present a definition of each type abstracted from the Python context. I'm not sure how concretely valuable that is, since this is documentation for red-knot, which is a Python type-checker.</p>
</blockquote>
<p>It's not documentation for <em>users</em> of red-knot though; it's documentation for red-knot developers to help them (us) think about type-system concepts. I personally find it helpful to consider these concepts in a more abstract way initially, before then linking the concepts back to the specific context of Python :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 16:41</div>
            <div class="timeline-body"><p>I think that would have to be a singleton type. Any type with more than one inhabitant in principle has proper subtypes that are not <code>Never</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 16:43</div>
            <div class="timeline-body"><p><code>Literal[50000000000000000]</code> is not a singleton type (multiple inhabitants exist at runtime), but has no non-<code>Never</code> proper subtypes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:114 on 2024-10-22 16:49</div>
            <div class="timeline-body"><p>I would also suggest avoiding a description like &quot;entirely fungible&quot;, because it is not well-defined. Whether the inhabitants are fungible or not is a matter of perspective and what you're doing with them! If you are doing <code>is</code> comparisons, they are not fungible. It's better if we state things precisely in terms of some equivalence relation: rather than &quot;entirely fungible and equal&quot;, the type inhabitants are &quot;all in the same equivalence class according to some equivalence relation&quot; (the Python equality relation, in our specific case.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:114 on 2024-10-22 16:51</div>
            <div class="timeline-body"><p>Sad -- there are so few situations in which you get to use the word &quot;fungible&quot;; I really thought this was one of them</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:114 on 2024-10-22 16:53</div>
            <div class="timeline-body"><p>(While I concede that you're pedantically correct, I <em>do</em> struggle to see what you might be doing with numbers such that one <code>50000000000000000</code> <code>int</code> object would not be fungible with another <code>50000000000000000</code> <code>int</code> object ðŸ˜„)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:114 on 2024-10-22 16:55</div>
            <div class="timeline-body"><p>Only things you shouldn't be doing with them, for sure! The intent of the language is absolutely that they should be fungible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 16:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 16:57</div>
            <div class="timeline-body"><p>None that we have (or ever would) define or attempt to name, but sure, in principle you can have the singleton type consisting only of the integer object with value <code>50000000000000000</code> that exists at a certain memory address, which is a proper subtype of <code>Literal[50000000000000000]</code> that is not <code>Never</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 16:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 16:59</div>
            <div class="timeline-body"><p>grrr, fine!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 17:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 17:07</div>
            <div class="timeline-body"><p>In some ways I find this a very useful clarification: it's good to remember that the set of Python types recognised by red-knot is a subset of the set of possible types that exist in Python. From this perspective, there really exists an infinite number of possible singleton types in Python.</p>
<p>In other ways, I find this not so useful, because I still feel like we're missing a term to describe types which <em>in red-knot's model</em> can have no possible non-<code>Never</code> proper subtypes <em>that would be understood as such by red-knot</em>. You've successfully convinced me that this is a concept that cannot be expressed in terms of an abstract framework divorced from the concept of Python types and our internal model of Python types. But I still think it's a useful concept nonetheless and something we should have a term for.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 18:23</div>
            <div class="timeline-body"><p>I think I'm not understanding <em>why</em> this is a useful or important concept.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:77 on 2024-10-22 18:26</div>
            <div class="timeline-body"><p>This phrasing feels slightly off to me. It's not about whether red-knot &quot;recognizes them as singleton types&quot; -- it's not as if red-knot recognizes them as some other kind of type instead! It's just that they are types for which red-knot has no internal representation (nor is there any way to spell them in a type expression.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:124 on 2024-10-22 18:27</div>
            <div class="timeline-body"><pre><code class="language-suggestion">for any given sealed type `X` where the only inhabitants of `X` are `A`, `B` and `C`,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 18:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 18:28</div>
            <div class="timeline-body"><p>It is what I was <em>trying</em> to describe... but perhaps you're right, maybe it just isn't actually a useful thing to describe. Not sure...</p>
<p>Anyway, I'm reworking the section titled closed types to more accurately describe the actual type-theory concept described by the term &quot;closed types&quot; :-) will probably finish off that rewrite tomorrow morning and push those changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:153 on 2024-10-22 18:29</div>
            <div class="timeline-body"><p>This seems to leave out the key third requirement: that the inhabitants of the type are all equal to each other according to the <code>__eq__</code> and <code>__ne__</code> implementations of that class. It was stated above in the abstract form, but for clarity it seems worth saying it again in the specific form.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-22 18:36</div>
            <div class="timeline-body"><p>Ok, looking forward to it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 18:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 18:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:124 on 2024-10-22 18:58</div>
            <div class="timeline-body"><p>No, I think that would make the sentence inaccurate. Your phrasing is true for the specific case of enum members, which I use as an example in the sentences following this, but is not true in the abstract, and this sentence describes an abstract relation. Here I theorise a hypothetical sealed type where there are exactly three proper subtypes and describe how such a sealed type might work.</p>
<p>I think it's possibly confusing that I'm using the same letters in my abstract description of the relation as I then use in my enum example immediately below, since the enum example does not in fact correspond exactly to the abstract relation I'm describing here. (The enum type in the example has more than three subtypes.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 19:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:123 on 2024-10-22 19:01</div>
            <div class="timeline-body"><p>It's not clear to me what the importance is here of the description &quot;equivalent to the union of all of its proper subtypes&quot; -- that describes every type! Not every type has a finite and enumerable set of proper subtypes, but <em>every</em> type is equivalent to the union of all its proper subtypes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-22 19:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:124 on 2024-10-22 19:04</div>
            <div class="timeline-body"><p>Ah, I see, makes sense.</p>
<p>I still have the feeling (commented above) that the emphasis here isn't quite on the right characteristics. I'm not sure if there's any value added by discussing or enumerating proper subtypes in this section at all. The important thing is that the type's <em>inhabitants</em> are finite and enumerable, and therefore if by intersection we eliminate some subset of inhabitants, we are able to simplify the representation to a type consisting of the remainder of the inhabitants</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-22 19:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:124 on 2024-10-22 19:09</div>
            <div class="timeline-body"><p>Hmm, I agree that the enumerability of the inhabitants is the more important characteristic, but I find both characteristics to be useful things to bear in mind. Still, I'll take a look tomorrow and see if I can improve the emphasis</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-23 08:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-23 08:12</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p><code>Literal[50000000000000000]</code> is not a singleton type (multiple inhabitants exist at runtime), but has no non-<code>Never</code> proper subtypes</p>
</blockquote>
<p>None that we have (or ever would) define or attempt to name, but sure, in principle you can have the singleton type consisting only of the integer object with value <code>50000000000000000</code> that exists at a certain memory address, which is a proper subtype of <code>Literal[50000000000000000]</code> that is not <code>Never</code>.</p>
</blockquote>
<p>This is purely a discussion about nomenclature, so I'm not sure how useful it is to go deeper, but I'm not sure I completely agree with this <em>&quot;every possible set of runtime values corresponds to *some</em> type, even if we can't name/construct it&quot;* viewpoint. I think the following definition is more useful: A type is a syntactic form that we assign to terms of the programming language. In this definition, it's still true that every type represents a set of possible runtime values. But it's not true that every possible set of runtime values corresponds to a type. <em>Which</em> particular sets of runtime values can be represented as a type depends on the type system and its expressiveness. In C's type system, you can not assign a type to the set <code>{true}</code>. In Python, you can; In Python, you can not assign a type to objects that are used exactly once. In languages with linear types, you can.</p>
<p>In Python's type system, there is no way to construct a type that represents all objects at memory location 0xf7â€¦, and I don't think it's useful to think of types in terms of sets of runtimes values that could <em>potentially</em> be represented by a more expressive type system. I would not claim that C has intersection types, just because I can think of a set of runtime values that would be represented by <code>int8_t &amp; uint8_t = {0, 1, â€¦, 127}</code>. And I would not claim that Python has linear types, just because I can think of the set of runtime objects that are used exactly once.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-23 08:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:13 on 2024-10-23 08:48</div>
            <div class="timeline-body"><p>nit: it might be useful to have some definition of the word &quot;inhabitant&quot; here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-23 09:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-23 09:32</div>
            <div class="timeline-body"><blockquote>
<p>This is purely a discussion about nomenclature</p>
</blockquote>
<p>Hey, the whole PR is about nomenclature ðŸ˜†</p>
<p>One complication here is that red-knot's model of Python's types <em>is</em> more expressive than the model outlined by the typing spec. (In fact, you could argue that all Python type checkers necessarily have a more expressive model than the one outlined in the typing spec -- but I think red-knot goes further than most here.) One obvious example is our concept of function-literal and class-literal types -- you <em>could</em> argue that the concept of class-literal types in particular is strongly implied by much of the rest of the typing spec, but nowhere is it explicitly specified. Similarly, we treat <code>IntersectionType</code>s as first-class types and infer them in many places -- but an <code>Intersection</code> type is still unspecified in the typing spec. (Mypy, for example, <a href="https://github.com/python/mypy/blob/60d1b3776229d3e3c332413ef49ad89be469a5e4/mypy/checker.py#L5416-L5440">does narrowing in many places that clearly <em>implies</em> the existence of an intersection type</a>, but it has no first-class notion of intersection types in its model.)</p>
<p>So I could put forward at least three possible definitions of &quot;type&quot; here:</p>
<ul>
<li>A maximally broad definition: &quot;Any theoretical set of runtime objects constitutes a 'type'&quot;</li>
<li>A maximally narrow definition: &quot;Only a type explicitly specified by the typing spec can be described as a type&quot;</li>
<li>A maximally useful definition: &quot;Any set of runtime objects constitutes a type if it would plausibly be useful to represent it as a type in red-knot in order to accurately and precisely model Python's runtime semantics&quot;</li>
</ul>
<p>I think the maximally useful definition is probably the most, well... useful... but it's also the least precise! It's hard to know which sets of runtime objects we might plausibly find useful to represent as types <em>at some point</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-23 09:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:155 on 2024-10-23 09:44</div>
            <div class="timeline-body"><blockquote>
<p>I think we have to present closed types in a way that's more tied to &quot;instance&quot; types -- as in, it's a type defined as instances of a class, which cannot be subclassed, therefore all inhabitants of the type must be instances of the final class.</p>
</blockquote>
<p>I'm not sure we want the concept of &quot;closed&quot; types to be limited to <em>just</em> <code>@final</code> nominal types, though. I think we would at least want <code>TypedDict</code>s with <code>closed=True</code> to qualify (assuming <a href="https://peps.python.org/pep-0728/">PEP 728</a> is accepted)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-23 14:49</div>
            <div class="timeline-body"><p>Once a type system has full set-theoretic types (arbitrary unions, intersections, and negations), it becomes quite hard to draw a clear line between which possible sets of objects are a type and which are not; many quite complex and precise types can be constructed ad-hoc. Because of this, and because of what Alex says (which sets of objects we choose to represent as a type internally is not set in stone by either the language or the typing spec, but is essentially up to our own judgment of what is useful for representing Python semantics, and may change over time), I think the clearest approach in our terminology is to avoid defining types based on an assumption that no proper subtype of the type could ever exist, despite the type having multiple distinguishable inhabitants.</p>
<p>(But perhaps more important to the original intent of this thread is that I also don't find that definition <em>otherwise</em> useful or correct in this case: I do think that <code>bool</code> and <code>Eggs</code> are closed types.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-23 14:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-23 14:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:182 on 2024-10-23 14:54</div>
            <div class="timeline-body"><blockquote>
<p>I do think that <code>bool</code> and <code>Eggs</code> are closed types</p>
</blockquote>
<p>Yeah, you're right that I was trying to use the word &quot;closed&quot; to describe a different concept to what it means everywhere else in type theory; that was obviously wrong and silly. No disagreements on <em>that</em> point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-24 15:07</div>
            <div class="timeline-body"><p>I updated the PR: I abandoned the attempt to describe a generalised concept of &quot;closed types&quot;; instead, I now just attempt to describe final nominal types (classes explicitly decorated wtih <code>@final</code>, and enum classes).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-10-24 15:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-24 16:00</div>
            <div class="timeline-body"><p>I'm looking forward to read this but don't wait on my review :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:27 on 2024-10-24 16:25</div>
            <div class="timeline-body"><p>Although I think it's fine to include this paragraph, I also wonder if we should link the &quot;core concepts&quot; section of the typing spec more prominently at the top of this doc (rather than just in a footnote), and explicitly call it out as a pre-requisite to this document. Because a) I think all red-knot developers should read and understand the core concepts section of the typing spec anyway, and b) it's not a great use of our time to rewrite definitions here that are already given in the core concepts section, and/or in the glossary, of the typing spec.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:31 on 2024-10-24 16:31</div>
            <div class="timeline-body"><p>While true, this statement feels a bit random here; it's not clear why it matters to mention it here.</p>
<p>As phrased here, it's trivially true given that <code>T &lt;: T</code> for all types <code>T</code>, and <code>T | U == T</code> if <code>U &lt;: T</code>.</p>
<p>It's also true (but somewhat less trivially so) if we're talking about all proper subtypes of <code>T</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:175 on 2024-10-24 16:57</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Many single-value types exist that are not singleton types: examples include
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:219 on 2024-10-24 17:02</div>
            <div class="timeline-body"><p>It may be confusing to readers that technically <code>Literal[Ham.A]</code> still is a single-value type, given this definition of <code>Ham</code>, because all <code>Ham</code> instances compare equal to everything! And this is technically still a valid equivalence relation, in which all inhabitants of <code>Literal[Ham.A]</code> do compare equal.</p>
<p>I think in  <em>practice</em> though, we will not want to give red-knot that level of intelligence about the specific implementation of <code>__eq__</code>; we will rather want to just say that if <code>__eq__</code> is defined, we don't understand the equality relation, and can no longer conclude that <code>Literal[Ham.A]</code> is a single-valued type.</p>
<p>It may be useful to clarify this distinction, or it may be fine to just change this <code>return True</code> to <code>return False</code> and avoid the issue altogether here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:258 on 2024-10-24 17:04</div>
            <div class="timeline-body"><p>Is there a missing code example following this? Or should the colon be a full stop instead?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:235 on 2024-10-24 17:07</div>
            <div class="timeline-body"><p>Nit: are you talking about proper subtypes here? Every final type has one nominal subtype: itself!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:254 on 2024-10-24 17:12</div>
            <div class="timeline-body"><p>I think this section is a bit debatable.</p>
<p>If we are talking about a conceptual <code>Truthy</code> type consisting of &quot;all objects whose <code>__bool__</code> actually returns <code>True</code>&quot;, that might work for this example, but it is probably not a good example to include since it's not clear if we even want to define such a type, given that individual objects can easily change their <code>__bool__</code> behavior over time.</p>
<p>If we are talking about the Protocol type shown here, then given a final type X, <code>X &amp; Truthy</code> will always be either <code>X</code> or <code>Never</code>, it will never be another proper subtype of <code>X</code>, because <code>X.__bool__</code> has a known signature, and that signature is either a subtype of <code>(self) -&gt; Literal[True]</code> or it is not.</p>
<p>A better example of proper subtypes of final types might be a final generic type with a covariant type parameter? In that case <code>X[B] &lt;: X[A]</code> if <code>B &lt;: A</code>, even though <code>X</code> is final.</p>
<p>At a higher level, though, it remains unclear to me why it is important to discuss whether a final type has any proper subtypes here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-24 17:15</div>
            <div class="timeline-body"><p>This looks good! Most of my comments are minor nits.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-24 17:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:258 on 2024-10-24 17:30</div>
            <div class="timeline-body"><p>Oh oops, I added a code example and then deleted it again because it didn't really add anything. I'll get rid of the colon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-24 17:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:235 on 2024-10-24 17:31</div>
            <div class="timeline-body"><p>Argh, yes! And <code>Never</code> is a subtype of everything, again, of course</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-24 17:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:254 on 2024-10-24 17:35</div>
            <div class="timeline-body"><p>I find it pretty useful to remember that runtime subclassing and static subtyping are linked but not the same thing. Just because something is <code>@final</code> does not mean it cannot be subtyped, only that it cannot be subclassed; all types except singleton types can be subtyped.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-24 17:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:27 on 2024-10-24 17:36</div>
            <div class="timeline-body"><p>Yes. Though I'm not sure all this information exists in the typing spec exactly as written. But I was also worried about overlap. I'll take another look.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-24 18:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:27 on 2024-10-24 18:03</div>
            <div class="timeline-body"><p>https://typing.readthedocs.io/en/latest/spec/concepts.html#fully-static-types says</p>
<blockquote>
<p>If an object v is a member of the set of objects denoted by a fully static type T, we can say that v is a â€œmember ofâ€ the type T, or v â€œinhabitsâ€ T.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-28 12:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:235 on 2024-10-28 12:51</div>
            <div class="timeline-body"><blockquote>
<p>And <code>Never</code> is a subtype of everything, again, of course</p>
</blockquote>
<p>...Except <code>Never</code> is not a <em>nominal</em> subtype.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-28 19:11</div>
            <div class="timeline-body"><p>I've once again reworked the final section of this substantially, because I realised my last draft still had some inaccuracies. For example, I wrote that:</p>
<blockquote>
<p>a final type in Python still has subtypes, just no <em>nominal</em> subtypes.</p>
</blockquote>
<p>which is pretty obviously wrong when you think about enums: <code>Literal[E.A]</code> is a nominal type (well, it's certainly not a <em>structural</em> type, anyway), and it's obviously a subtype of the enum <code>E</code>.</p>
<p>My conclusion from all this conversation is that while the concept of final <em>classes</em> might be useful, the concept of final <em>types</em> actually isn't that useful at all (and the name is somewhat misleading in some ways). So I scrapped the section defining a concept of &quot;final <em>types</em>&quot; and replaced it with a section describing &quot;final <em>classes</em>&quot;.</p>
<p>I'd appreciate it if you could give the last section another once-over @carljm!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:33 on 2024-10-28 19:12</div>
            <div class="timeline-body"><p>nit: the use of the qualifier &quot;known&quot; in this sentence invites uncertainty about whether you are saying &quot;there is definitely exactly one inhabitant, and it is known&quot; or &quot;there is exactly one known inhabitant, there may be other unknown ones.&quot;</p>
<p>You could be more explicit that it is the former, but I'm not sure it's worth it, vs just removing the word &quot;known&quot; -- I think it's obvious that if we can be sure there's exactly one inhabitant of type, that means we know what it is :)</p>
<pre><code class="language-suggestion">(and can only ever be) exactly one inhabitant of the type at runtime:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:43 on 2024-10-28 19:13</div>
            <div class="timeline-body"><p>ooh TIL that this is a usable code block language, neat!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:93 on 2024-10-28 19:14</div>
            <div class="timeline-body"><p>There's still a reference to &quot;final type&quot; here, which may no longer make sense given later changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:168 on 2024-10-28 19:17</div>
            <div class="timeline-body"><p>Not important, but may help readers tie together some mentioned concepts.</p>
<pre><code class="language-suggestion">    is reflexive, symmetric, and transitive (satisfying the definition of
    an equivalence relation.)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:175 on 2024-10-28 19:18</div>
            <div class="timeline-body"><p>nit: I think &quot;in terms of identity&quot; is redundant here, especially when you immediately go on to specifically discuss memory addresses</p>
<pre><code class="language-suggestion">However, they are not necessarily the *same* object;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:178 on 2024-10-28 19:19</div>
            <div class="timeline-body"><p>We said above that we can also narrow sealed types by identity, not just singleton types:</p>
<pre><code class="language-suggestion">that the type is a sealed type.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:206 on 2024-10-28 19:22</div>
            <div class="timeline-body"><p><code>Ham</code> is not a singleton type, but <code>Literal[Ham.A]</code> is</p>
<pre><code class="language-suggestion">(but we *can* still narrow the `Literal[Ham.A]` type using identity, as with all singleton types):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:229 on 2024-10-28 19:23</div>
            <div class="timeline-body"><p>nit: this applies to all final classes, whether or not they are made final by the use of <code>@final</code> (and saying &quot;is <code>@final</code>&quot; reads oddly to me, even as a way to say &quot;is decorated with <code>typing.final</code>&quot;)</p>
<pre><code class="language-suggestion">For any two classes `X` and `Y`, if `X` is final and `X` is not a subclass of `Y`,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:241 on 2024-10-28 19:25</div>
            <div class="timeline-body"><p>minor nit, not related to the core point: I think using plurals is generally not great naming practice for either enums or classes generally, suggest <code>Animal</code> instead</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:233 on 2024-10-28 19:26</div>
            <div class="timeline-body"><p>I think &quot;types associated with final classes&quot; is a vague and verbose way to word this; &quot;final class types&quot; I think is a clearer unambiguous reference to the &quot;a type defined as ...&quot; in the previous sentence.</p>
<pre><code class="language-suggestion">However, final class types can still have non-`Never` proper subtypes.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:233 on 2024-10-28 19:29</div>
            <div class="timeline-body"><p>I still feel like this section buries the lede in a major way.</p>
<p>From red-knot's perspective, by far the most important thing about final class types is that we know exactly what methods and attributes they define, with what signatures (including especially dunder methods), and we know there can't be infinite possible subclasses overriding those methods and attributes. But we don't even mention that here, beyond a very vague reference in this phrase to &quot;fewer ways of subtypign&quot;; instead we go on to discuss (at relative length, with an example) the edge case of how some final class types can still have proper subtypes, although it remains unclear in the text why the existence or non-existence of proper subtypes should matter to red-knot or the reader.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:253 on 2024-10-28 19:37</div>
            <div class="timeline-body"><p>I would probably eliminate this entire paragraph. It's confusing, and really not clear what important point it makes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-28 19:39</div>
            <div class="timeline-body"><p>The first several sections of this are really excellent, I have only the most minor of wording nits.</p>
<p>The last section is improved, but I still feel it suffers from a significant &quot;so what?&quot; factor, in that it spends IMO too many words discussing things that I don't think are particularly relevant to red-knot behavior. But this isn't a blocking concern.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-28 19:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/docs/kind_of_types.md</code>:233 on 2024-10-28 19:52</div>
            <div class="timeline-body"><p>I guess I was going out of my way to avoid using the term &quot;final types&quot; here, because I was getting less and less convinced that it was actually a useful term that didn't just invite confusion ðŸ˜„ But you're probably right that my roundabout language here doesn't really add any clarity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/T-256">@T-256</a> on 2025-01-03 15:33</div>
            <div class="timeline-body"><p>Do you still want to land this? We now have <em>mdtests</em> which also have good docs inside themselves.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-03 15:34</div>
            <div class="timeline-body"><blockquote>
<p>Do you still want to land this?</p>
</blockquote>
<p>yes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-07 13:55</div>
            <div class="timeline-body"><p>doesn't seem like I'll get back to this any time soon, and our priority should probably be user-facing docs at this point</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2026-01-07 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2026-01-07 13:55</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:07:10 UTC
    </footer>
</body>
</html>
