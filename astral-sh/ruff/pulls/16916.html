<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] fix eager nested scopes handling - astral-sh/ruff #16916</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] fix eager nested scopes handling</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16916">#16916</a>
        opened by <a href="https://github.com/mtshiba">@mtshiba</a>
        on 2025-03-22 15:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-03-22 15:51</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>From #16861, and the continuation of #16915.</p>
<p>This PR fixes the incorrect behavior of <code>TypeInferenceBuilder::infer_name_load</code> in eager nested scopes.</p>
<p>And this PR closes #16341.</p>
<h2>Test Plan</h2>
<p>New test cases are added in <code>annotations/deferred.md</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-03-22 15:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @mtshiba on 2025-03-22 15:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @mtshiba on 2025-03-22 15:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @mtshiba on 2025-03-22 15:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-22 15:57</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2025-03-22 16:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/deferred.md</code>:71 on 2025-03-23 13:39</div>
            <div class="timeline-body"><p>I think the <code>Bar</code> reference here should be an unresolved-reference error, because the name <code>Bar</code> is defined in a class scope, which is not visible to nested scopes.</p>
<p>You make an explicit exception for this case in <code>infer_name_load</code>, but I don't think we should. It's not really clearly defined by the core runtime what the name resolution semantics should be for annotations when <code>from __future__ import annotations</code> is active (since the actual runtime effect is that the annotations remain strings and are not evaluated at all). But I don't think there is any reason to assume that the usual rules for names in class scopes should not apply. Pyright <a href="https://pyright-play.net/?strict=true&amp;code=GYJw9gtgBA%2BjwFcAuCQFM5QJYQA5hCSgEMA7UsJYpLMUgZwChGBjAG2PvqgDEwwAXIygio7TtwBCxEENHyoAEzTAowABT00bYAEooAWgB8UabOELL6FCFJQtO5uK6niALzmjlqjQ72GTaQ8LKzQbOz9GIA">still applies them</a>. And if you use <code>typing.get_type_hints</code> at runtime to evaluate the stringified annotations, this throws a <code>NameError</code>.</p>
<p>(The <code>Foo</code> reference should not be an error. We should separate this into two different method definitions so it is clear which one errors and which does not.)</p>
<pre><code class="language-suggestion">        def f(self, x: Foo):
            pass
            
        # error: [unresolved-reference]
        def g(self) -&gt; Bar:
            return self
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4099 on 2025-03-23 13:47</div>
            <div class="timeline-body"><p>As discussed in the other comment in the test suite, the exception you make here for <code>self.is_deferred()</code> I think we should not make.</p>
<p>And I think the <code>scope.is_annotation</code> exception needs to be a bit more precise. Annotation scopes can see names defined in their immediately enclosing class scope, but not names defined in more distant enclosing class scopes. For example:</p>
<pre><code class="language-py"> class A:
    a = 1
    class B:
        b = 2
        type S = a  # error!
        type T = b  # no error
</code></pre>
<p>We should add a test showing that the <code>type S = a</code> case is an <code>unresolved-reference</code> error, and adjust the implementation here accordingly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4094 on 2025-03-23 13:50</div>
            <div class="timeline-body"><p>As discussed in other comments, I think only one of these exceptions is valid, and it's not related to lazy evaluation: in general, type parameter scopes can see names defined in their immediately-enclosing class scope.</p>
<pre><code class="language-suggestion">                // There is one exception to this rule: type parameter scopes can see
                // names defined in an immediately-enclosing class scope.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4201 on 2025-03-23 13:57</div>
            <div class="timeline-body"><p>This is implemented as a special-case patch fix for one very specific case (references to classes inside the class definition), when what we need is a more general fix to the semantics implemented for eager nested scopes. Here is one example of a case that we currently handle wrongly, and is not fixed by this patch:</p>
<pre><code class="language-py"># this line should be an unresolved-reference, but we don't error on it:
[x for _ in [1]]
x = 1
</code></pre>
<p>We should add this to the test suite. The fix should be implemented more like I described in my comment on your prior PR: when snapshotting visible bindings for names in eager nested scopes in semantic indexing, we also need to snapshot the fact that there are no visible bindings, and then respect that when we check <code>eager_bindings</code> above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2025-03-23 14:00</div>
            <div class="timeline-body"><p>Thanks for the PR! I think there are some adjustments needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-03-24 12:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4201 on 2025-03-24 12:33</div>
            <div class="timeline-body"><p>Does this mean that we should add undefined symbols to the symbol table of the enclosing scope and register  snapshots of empty bindings in <code>eager_bindings</code>?
Should we also register the builtin symbols as undefined ones?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @sharkdp removed by @sharkdp on 2025-03-24 14:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-24 17:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4201 on 2025-03-24 17:48</div>
            <div class="timeline-body"><p>I don't think we should add the symbol to any outer scope. It may be that we don't actually need any change in semantic index building? We already will store no bindings in <code>eager_bindings</code> if there are no bindings for a name in a scope. It may be that all we need is a bit more sophisticated logic here in <code>infer_name_load</code>, where we need to track as we iterate enclosing scopes if we are still in &quot;eager&quot; context (that is, every scope we've traversed is eager), and if we find no eager binding in a scope while still in eager context, we need to just continue to the next scope rather than falling back to normal non-eager symbol resolution. Once we are out of &quot;eager&quot; context (that is, we have hit a non-eager scope), then eager bindings are no longer relevant and we should check normally for non-eager bindings in each scope. (So I don't think we need any special handling for builtin symbols.)</p>
<p>We should have tests for a case like this, too:</p>
<pre><code class="language-py">x = 1
def f():
    class C:
        y = [x for _ in [1]]
        x = 2
    reveal_type(C.y)  # should reveal [1]
</code></pre>
<p>And the same should be true if <code>x = 1</code> occurs after the definition of <code>f</code> instead of before it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-24 17:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4201 on 2025-03-24 17:49</div>
            <div class="timeline-body"><p>@dcreager would you be able to take a couple minutes to double-check my logic here and make sure I'm suggesting a sensible direction, since you wrote the initial eager-nested-scopes handling?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4201 on 2025-03-26 18:06</div>
            <div class="timeline-body"><p>Yep I think this approach makes sense!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4184 on 2025-03-26 18:10</div>
            <div class="timeline-body"><p>This brings back some logic duplication that we discussed when first adding eager nested scope support (https://github.com/astral-sh/ruff/pull/16079#discussion_r1951742987).  Ideally we could have the return value of <code>SemanticIndex::eager_bindings</code> distinguish between &quot;this enclosing scope is no longer part of an eager context&quot; and &quot;it is but there are no bindings for the symbol&quot;.  Then we'd have a three-armed <code>match</code> statement here (<code>return</code>, <code>continue</code>, and fall through), and we wouldn't have to track <code>in_eager_context</code> both here and in the semantic index builder.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4150 on 2025-03-26 18:11</div>
            <div class="timeline-body"><p>TIL about this exception.  Yuck!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-26 18:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @mtshiba on 2025-03-27 06:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-03-27 06:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:333 on 2025-03-27 18:17</div>
            <div class="timeline-body"><p>Just as a style nit I'm not a huge fan of this &quot;immediately call a lambda&quot; pattern.  I think it's a bit easier to follow with <code>let</code>/<code>else</code>:</p>
<pre><code class="language-suggestion">        let Some(symbol_id) = self.symbol_tables[enclosing_scope].symbol_id_by_name(symbol)
        else {
            return EagerBindingsResult::NotFound;
        };
        let key = EagerBindingsKey {
            enclosing_scope,
            enclosing_symbol: symbol_id,
            nested_scope,
        };
        let Some(id) = self.eager_bindings.get(&amp;key) else {
            return EagerBindingsResult::NotFound;
        };
        match self.use_def_maps[enclosing_scope].eager_bindings(*id) {
            Some(bindings) =&gt; EagerBindingsResult::Found(bindings),
            None =&gt; EagerBindingsResult::NotFound,
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> approved on 2025-03-27 18:19</div>
            <div class="timeline-body"><p>One last style nit, otherwise I think this looks great.  Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-03-28 15:11</div>
            <div class="timeline-body"><p>Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-03-28 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-03-28 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-30 04:29</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:41:05 UTC
    </footer>
</body>
</html>
