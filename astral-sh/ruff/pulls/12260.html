<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Rework module resolver tests - astral-sh/ruff #12260</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Rework module resolver tests</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12260">#12260</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-07-09 18:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-07-09 18:04</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR aims to improve the module-resolver tests in <code>path.rs</code> and <code>resolver.rs</code> in several ways:</p>
<ul>
<li>Reduce boilerplate when setting up the tests</li>
<li>Make the tests more declarative.</li>
<li>Enforce that a mock stdlib directory must include a <code>VERSIONS</code> file</li>
<li>Rather than sharing one large typeshed mock between many tests in <code>path.rs</code>, create a minimal typeshed mock for each test. This makes it clearer what exactly we're testing in each test.</li>
</ul>
<p>Logic to support the building of test cases is extracted into a single submodule. It's now easy to create an isolated, declarative test case where it's obvious exactly which files and directories exist in the mock. For example:</p>
<pre><code class="language-rs">const SRC: &amp;[FileSpec] = &amp;[(&quot;functools.py&quot;, &quot;def update_wrapper(): ...&quot;)];

const TYPESHED: MockedTypeshed = MockedTypeshed {
    stdlib_files: &amp;[(&quot;functools.pyi&quot;, &quot;def update_wrapper(): ...&quot;)],
    versions: &quot;functools: 3.8-&quot;,
};

let TestCase { db, src, .. } = TestCaseBuilder::new()
    .with_src_files(SRC)
    .with_custom_typeshed(TYPESHED)
    .with_target_version(TargetVersion::Py38)
    .build();
</code></pre>
<h2>Test Plan</h2>
<p><code>cargo test -p red_knot_module_resolver</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-07-09 18:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-07-09 18:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-07-09 18:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 18:18</div>
            <div class="timeline-body"><p>This seems a bit arbitrary?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-07-09 18:26</div>
            <div class="timeline-body"><p>Looks nice, I like this a lot!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 19:29</div>
            <div class="timeline-body"><p>Yeah, it <em>is</em> arbitrary. However, we do need <em>something</em> in the <code>VERSIONS</code> file or it will fail to parse:</p>
<p>https://github.com/astral-sh/ruff/blob/88abc6aed801995864bb4f8bcb401d1c2cb48baf/crates/red_knot_module_resolver/src/typeshed/versions.rs#L310-L314</p>
<p>E.g. two tests that don't test anything to do with the stdlib start failing if I make this diff:</p>
<pre><code class="language-diff">diff --git a/crates/red_knot_module_resolver/src/testing.rs b/crates/red_knot_module_resolver/src/testing.rs
index 55f0d9d0a..ce38aca5c 100644
--- a/crates/red_knot_module_resolver/src/testing.rs
+++ b/crates/red_knot_module_resolver/src/testing.rs
@@ -186,7 +186,7 @@ impl TestCaseBuilder&lt;UnspecifiedTypeshed&gt; {
     pub(crate) fn build(self) -&gt; TestCase&lt;()&gt; {
         const DEFAULT_TYPESHED: MockedTypeshed = MockedTypeshed {
             stdlib_files: &amp;[(&quot;functools.pyi&quot;, &quot;def update_wrapper(): ...&quot;)],
-            versions: &quot;functools: 3.8-&quot;,
+            versions: &quot;&quot;,
         };
 
         let TestCase {
</code></pre>
<p>And if the <code>VERSIONS</code> file says a module exists, then we probably should indeed put that module in the mock typeshed...</p>
<p>Maybe I should just put an empty <code>foo.pyi</code> file in the default typeshed mock, and put <code>foo</code> in the <code>VERSIONS</code> file? And add a comment? WDYT?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-09 19:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-09 19:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 19:35</div>
            <div class="timeline-body"><p>My initial feeling is that a VERSIONS file that exists but is empty should not be an error in the parser, it just means there are no stdlib stub files. And that should be the default for tests that don't either provide a mock typeshed or request to use the vendored typeshed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-09 19:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 19:45</div>
            <div class="timeline-body"><p>Yeah, that makes sense. Two counterpoints, however:</p>
<ul>
<li>I think it is useful to validate <em>somewhere</em> that the contents of a custom typeshed directory a user passes to us makes some kind of sense. For example, mypy checks that a small selection of &quot;core&quot; stdlib modules exist in typeshed, and aborts the process immediately if they don't, since it knows no typechecking it does is going to make any kind of sense without them (<code>builtins</code>, <code>typing</code>, <code>collections.abc</code>, <code>types</code>, <code>typing_extensions</code>, I believe). I think it makes sense for us to do similarly at some place in <code>red_knot</code> (but it doesn't necessarily have to be in the <code>VERSIONS</code> parser).</li>
<li>I'm somewhat uneasy about the fact that <code>File::read_to_string()</code> just returns an empty string if a file doesn't exist... in the specific ways we're currently using the <code>ruff_db</code> API to get the <code>VERSIONS</code> file in <code>versions.rs</code>, it should be impossible for us to try parsing an empty string that represents a nonexistent <code>VERSIONS</code> file, but I still sort of worry about it... https://github.com/astral-sh/ruff/blob/88abc6aed801995864bb4f8bcb401d1c2cb48baf/crates/ruff_db/src/files.rs#L181-L190</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-09 20:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 20:12</div>
            <div class="timeline-body"><p>Regarding Files::read_to_string. The fallback path is only taken if the file has been deleted since the last system_path_to_file call. The analysis will most likely be aborted shortly after once the file watcher detects the change and marks the file as deleted (and system_path_to_fike returns None)</p>
<p>Regarding the check. I think that's a useful check for the settings loading code but feels a bit over eager in the parser</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-09 20:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 20:12</div>
            <div class="timeline-body"><p>I guess I am torn here between a) do the simple and obvious thing, and don't unnecessarily prevent users from doing what they want, even if it's odd (for example, an empty typeshed), and b) prevent users from shooting themselves in the foot accidentally.</p>
<p>I think that we should be able to roll with an empty stdlib, even an empty builtins; it'll just result in a lot of Unknown/Unbound in our type inference.</p>
<p>I guess I feel like we should either allow empty VERSIONS, or require an actually-usable stdlib (at least has builtins). Requiring a non-empty-but-can-have-whatever-nonsense-you-want-in-it isn't a middle ground that seems very useful; it just results in pointless workarounds like &quot;let's have a stdlib containing only <code>foo.pyi</code>&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-09 20:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 20:17</div>
            <div class="timeline-body"><p>Alrighty. For now I'll allow an empty <code>VERSIONS</code>, then. We can add more principled validation if/when we feel we need it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-09 20:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 20:23</div>
            <div class="timeline-body"><blockquote>
<p>The analysis will most likely be aborted shortly after once the file watcher detects the change and marks the file as deleted (and system_path_to_fike returns None)</p>
</blockquote>
<p>Right. That still feels like an assumption that I feel like I'd prefer to check explicitly (and panic if it turns out to be incorrect). But not sure; happy to defer to you.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-09 21:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:189 on 2024-07-09 21:04</div>
            <div class="timeline-body"><p>I like to verify that as well. But it should not panic, because that tears down the entire program. Rust analyzer has a few interesting techniques. It keeps the last working workspace tree around for the case that a user messes up the editing of a Cargo.toml. They use the old workspace structure in that case because it's still better than knowing nothing about the program.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:985 on 2024-07-10 06:55</div>
            <div class="timeline-body"><p>Nit: the <code>const</code> probably doesn't give you much here and is a bit more annoying to use because you have to annotate the type. That's why I would have opted to use a regular <code>let</code> here. But it's not worth the time to change it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/testing.rs</code>:136 on 2024-07-10 06:58</div>
            <div class="timeline-body"><p>Nit: I would rename <code>system</code> to <code>fs</code> because it's not the system ;)</p>
<p>You also don't have to call <code>create_directory_all</code>. <code>write_all</code> creates all the necessary intermediate directories for you (it's designed as a testing FS and having to create the directories manually is cumbersome)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-07-10 07:02</div>
            <div class="timeline-body"><p>This is neat!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-10 10:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:985 on 2024-07-10 10:26</div>
            <div class="timeline-body"><p>Yeah, agree that having to explicitly annotate the variables is a bit annoying. That said, I still kinda like using <code>const</code> for this, as it makes it explicit that this is fully static data, which is a nice property for test input.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2024-07-10 10:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-07-10 10:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-10 11:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:985 on 2024-07-10 11:04</div>
            <div class="timeline-body"><p>Maybe, until you hit the point where it can no longer be static :laughing:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-07-10 11:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:47:33 UTC
    </footer>
</body>
</html>
