<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] use Type::Divergent to avoid panic in infinitely-nested-tuple implicit attribute - astral-sh/ruff #20333</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] use Type::Divergent to avoid panic in infinitely-nested-tuple implicit attribute</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20333">#20333</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-09-10 15:00
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2025-09-10 15:00</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Use <code>Type::Divergent</code> to avoid &quot;too many iterations&quot; panic on an infinitely-nested tuple in an implicit instance attribute.</p>
<p>The regression here is from checking all tuple elements to see if they contain a Divergent type. It's 5% on one project, 1% on another, and zero on the rest. I spent some time looking into eliminating this regression by tracking a flag on inference results to note if they could possibly contain any Divergent type, but this doesn't really work -- there are too many different ways a type containing a Divergent type could enter an inference result. Still thinking about whether there are other ways to reduce this. One option is if we see certain kinds of non-atomic types that are commonly expensive to check for Divergent, we could make <code>has_divergent_type</code> a Salsa query on those types.</p>
<h2>Test Plan</h2>
<p>Added mdtest.</p>
<p>Co-authored-by: Alex Waygood <a href="mailto:Alex.Waygood@Gmail.com">Alex.Waygood@Gmail.com</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @carljm on 2025-09-10 15:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-10 15:02</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-09-11 13:14:44.923387518 +0000
+++ new-output.txt	2025-09-11 13:14:47.942419689 +0000
@@ -1,6 +1,6 @@
 WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/a3ffa22/src/function/execute.rs:228:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_type_statement.py`: `PEP695TypeAliasType &lt; 'db &gt;::value_type_(Id(b816)): execute: too many cycle iterations`
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/a3ffa22/src/function/execute.rs:228:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(12a7a)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/3713cd7/src/function/execute.rs:213:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_type_statement.py`: `PEP695TypeAliasType &lt; 'db &gt;::value_type_(Id(b816)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/3713cd7/src/function/execute.rs:213:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(12a7a)): execute: too many cycle iterations`
 _directives_deprecated_library.py:15:31: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `int`
 _directives_deprecated_library.py:30:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `str`
 _directives_deprecated_library.py:36:41: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Self@__add__`
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-10 15:05</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅</p>
<details>
<summary>Memory usage changes were detected when running on open source projects</summary>

<pre><code class="language-diff">flake8 (https://github.com/pycqa/flake8)
-     struct fields = ~4MB
+     struct fields = ~5MB

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-09-10 15:21</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_WALLTIME_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Ftuplerec?runnerMode=WallTime">CodSpeed WallTime Performance Report</a></h2>
<h3>Merging #20333 will <strong>degrade performances by 5.12%</strong></h3>
<p><sub>Comparing <code>cjm/tuplerec</code> (1f8073d) with <code>main</code> (59c8fda)</sub></p>
<h3>Summary</h3>
<p><code>❌ 1</code> regression<br />
<code>✅ 7</code> untouched</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Ftuplerec?runnerMode=WallTime">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ❌ | <code>medium[static-frame]</code> | 7.8 s | 8.2 s | -5.12% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-10 15:26</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Cjm/tuplerec" to "[ty] use Type::Divergent to avoid panic in infinitely-nested-tuple implicit attribute" by @carljm on 2025-09-10 16:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @carljm on 2025-09-10 23:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2025-09-10 23:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @carljm on 2025-09-10 23:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @carljm on 2025-09-10 23:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> approved on 2025-09-11 01:40</div>
            <div class="timeline-body"><p>I like this new <code>Divergent</code> type</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-09-11 10:53</div>
            <div class="timeline-body"><p>All tests seem to pass if I apply this refactor to your branch (which gets rid of quite a few <code>.expect()</code> calls!) -- is there anything conceptually wrong with this?</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/infer.rs b/crates/ty_python_semantic/src/types/infer.rs
index df251700f8..1d53611bf6 100644
--- a/crates/ty_python_semantic/src/types/infer.rs
+++ b/crates/ty_python_semantic/src/types/infer.rs
@@ -387,19 +387,19 @@ impl&lt;'db&gt; InferenceRegion&lt;'db&gt; {
     }
 }
 
-#[derive(Debug, Clone, Copy, Eq, PartialEq, get_size2::GetSize)]
-enum CycleRecovery {
+#[derive(Debug, Clone, Copy, Eq, PartialEq, get_size2::GetSize, salsa::Update)]
+enum CycleRecovery&lt;'db&gt; {
     /// An initial-value for fixpoint iteration; all types are `Type::Never`.
     Initial,
     /// A divergence-fallback value for fixpoint iteration; all types are `Divergent`.
-    Divergent,
+    Divergent(ScopeId&lt;'db&gt;),
 }
 
-impl CycleRecovery {
-    fn merge(self, other: Option&lt;CycleRecovery&gt;) -&gt; CycleRecovery {
+impl&lt;'db&gt; CycleRecovery&lt;'db&gt; {
+    fn merge(self, other: Option&lt;CycleRecovery&lt;'db&gt;&gt;) -&gt; Self {
         if let Some(other) = other {
             match (self, other) {
-                (Self::Divergent, _) | (_, Self::Divergent) =&gt; Self::Divergent,
+                (Self::Divergent(scope), _) | (_, Self::Divergent(scope)) =&gt; Self::Divergent(scope),
                 _ =&gt; Self::Initial,
             }
         } else {
@@ -407,10 +407,10 @@ impl CycleRecovery {
         }
     }
 
-    fn fallback_type&lt;'db&gt;(self, scope_fn: impl FnOnce() -&gt; ScopeId&lt;'db&gt;) -&gt; Type&lt;'db&gt; {
+    fn fallback_type(self) -&gt; Type&lt;'db&gt; {
         match self {
             Self::Initial =&gt; Type::Never,
-            Self::Divergent =&gt; Type::divergent(scope_fn()),
+            Self::Divergent(scope) =&gt; Type::divergent(scope),
         }
     }
 }
@@ -428,13 +428,10 @@ pub(crate) struct ScopeInference&lt;'db&gt; {
 #[derive(Debug, Eq, PartialEq, get_size2::GetSize, salsa::Update, Default)]
 struct ScopeInferenceExtra&lt;'db&gt; {
     /// Is this a cycle-recovery inference result, and if so, what kind?
-    cycle_recovery: Option&lt;CycleRecovery&gt;,
+    cycle_recovery: Option&lt;CycleRecovery&lt;'db&gt;&gt;,
 
     /// The diagnostics for this region.
     diagnostics: TypeCheckDiagnostics,
-
-    /// The scope for which this is an inference result, if we are a divergent cycle recovery.
-    scope: Option&lt;ScopeId&lt;'db&gt;&gt;,
 }
 
 impl&lt;'db&gt; ScopeInference&lt;'db&gt; {
@@ -470,12 +467,9 @@ impl&lt;'db&gt; ScopeInference&lt;'db&gt; {
     }
 
     fn fallback_type(&amp;self) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
-        self.extra.as_ref().and_then(|extra| {
-            extra.cycle_recovery.map(|recovery| {
-                recovery
-                    .fallback_type(|| extra.scope.expect(&quot;Divergent inference should have scope&quot;))
-            })
-        })
+        self.extra
+            .as_ref()
+            .and_then(|extra| extra.cycle_recovery.map(CycleRecovery::fallback_type))
     }
 }
 
@@ -509,7 +503,7 @@ pub(crate) struct DefinitionInference&lt;'db&gt; {
 #[derive(Debug, Eq, PartialEq, get_size2::GetSize, salsa::Update, Default)]
 struct DefinitionInferenceExtra&lt;'db&gt; {
     /// Is this a cycle-recovery inference result, and if so, what kind?
-    cycle_recovery: Option&lt;CycleRecovery&gt;,
+    cycle_recovery: Option&lt;CycleRecovery&lt;'db&gt;&gt;,
 
     /// The definitions that are deferred.
     deferred: Box&lt;[Definition&lt;'db&gt;]&gt;,
@@ -519,9 +513,6 @@ struct DefinitionInferenceExtra&lt;'db&gt; {
 
     /// For function definitions, the undecorated type of the function.
     undecorated_type: Option&lt;Type&lt;'db&gt;&gt;,
-
-    /// The scope this region is part of, if we are a divergent cycle recovery.
-    scope: Option&lt;ScopeId&lt;'db&gt;&gt;,
 }
 
 impl&lt;'db&gt; DefinitionInference&lt;'db&gt; {
@@ -605,12 +596,9 @@ impl&lt;'db&gt; DefinitionInference&lt;'db&gt; {
     }
 
     fn fallback_type(&amp;self) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
-        self.extra.as_ref().and_then(|extra| {
-            extra.cycle_recovery.map(|recovery| {
-                recovery
-                    .fallback_type(|| extra.scope.expect(&quot;Divergent inference should have scope&quot;))
-            })
-        })
+        self.extra
+            .as_ref()
+            .and_then(|extra| extra.cycle_recovery.map(CycleRecovery::fallback_type))
     }
 
     pub(crate) fn undecorated_type(&amp;self) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
@@ -643,13 +631,10 @@ struct ExpressionInferenceExtra&lt;'db&gt; {
     diagnostics: TypeCheckDiagnostics,
 
     /// Is this a cycle recovery inference result, and if so, what kind?
-    cycle_recovery: Option&lt;CycleRecovery&gt;,
+    cycle_recovery: Option&lt;CycleRecovery&lt;'db&gt;&gt;,
 
     /// `true` if all places in this expression are definitely bound
     all_definitely_bound: bool,
-
-    /// The scope this region is part of (if we are a Divergent cycle recovery.)
-    scope: Option&lt;ScopeId&lt;'db&gt;&gt;,
 }
 
 impl&lt;'db&gt; ExpressionInference&lt;'db&gt; {
@@ -672,9 +657,8 @@ impl&lt;'db&gt; ExpressionInference&lt;'db&gt; {
         let _ = scope;
         Self {
             extra: Some(Box::new(ExpressionInferenceExtra {
-                cycle_recovery: Some(CycleRecovery::Divergent),
+                cycle_recovery: Some(CycleRecovery::Divergent(scope)),
                 all_definitely_bound: true,
-                scope: Some(scope),
                 ..ExpressionInferenceExtra::default()
             })),
             expressions: FxHashMap::default(),
@@ -700,12 +684,9 @@ impl&lt;'db&gt; ExpressionInference&lt;'db&gt; {
     }
 
     fn fallback_type(&amp;self) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
-        self.extra.as_ref().and_then(|extra| {
-            extra.cycle_recovery.map(|recovery| {
-                recovery
-                    .fallback_type(|| extra.scope.expect(&quot;Divergent inference should have scope&quot;))
-            })
-        })
+        self.extra
+            .as_ref()
+            .and_then(|extra| extra.cycle_recovery.map(CycleRecovery::fallback_type))
     }
 
     /// Returns true if all places in this expression are definitely bound.
diff --git a/crates/ty_python_semantic/src/types/infer/builder.rs b/crates/ty_python_semantic/src/types/infer/builder.rs
index b1e6fd3b4f..1264aa21fd 100644
--- a/crates/ty_python_semantic/src/types/infer/builder.rs
+++ b/crates/ty_python_semantic/src/types/infer/builder.rs
@@ -252,7 +252,7 @@ pub(super) struct TypeInferenceBuilder&lt;'db, 'ast&gt; {
     undecorated_type: Option&lt;Type&lt;'db&gt;&gt;,
 
     /// Did we merge in a sub-region with a cycle-recovery fallback, and if so, what kind?
-    cycle_recovery: Option&lt;CycleRecovery&gt;,
+    cycle_recovery: Option&lt;CycleRecovery&lt;'db&gt;&gt;,
 
     /// `true` if all places in this expression are definitely bound
     all_definitely_bound: bool,
@@ -293,7 +293,7 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
         }
     }
 
-    fn extend_cycle_recovery(&amp;mut self, other_recovery: Option&lt;CycleRecovery&gt;) {
+    fn extend_cycle_recovery(&amp;mut self, other_recovery: Option&lt;CycleRecovery&lt;'db&gt;&gt;) {
         match &amp;mut self.cycle_recovery {
             Some(recovery) =&gt; *recovery = recovery.merge(other_recovery),
             recovery @ None =&gt; *recovery = other_recovery,
@@ -301,8 +301,7 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
     }
 
     fn fallback_type(&amp;self) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
-        self.cycle_recovery
-            .map(|recovery| recovery.fallback_type(|| self.scope))
+        self.cycle_recovery.map(CycleRecovery::fallback_type)
     }
 
     fn extend_definition(&amp;mut self, inference: &amp;DefinitionInference&lt;'db&gt;) {
@@ -8866,7 +8865,6 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
                     diagnostics,
                     cycle_recovery,
                     all_definitely_bound,
-                    scope: Some(scope),
                 })
             });
 
@@ -8915,7 +8913,6 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
                 deferred: deferred.into_boxed_slice(),
                 diagnostics,
                 undecorated_type,
-                scope: Some(scope),
             })
         });
 
@@ -8981,7 +8978,6 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
             Box::new(ScopeInferenceExtra {
                 cycle_recovery,
                 diagnostics,
-                scope: Some(scope),
             })
         });
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-11 13:06</div>
            <div class="timeline-body"><blockquote>
<p>All tests seem to pass if I apply this refactor to your branch... is there anything conceptually wrong with this?</p>
</blockquote>
<p>There sort of is; I'd actually started the same refactor and then stopped when I reached the &quot;conceptually wrong&quot; thing, which is the implementation of <code>CycleRecovery::merge</code>. When we merge two <code>CycleRecovery::Divergent</code> together, with potentially different scopes, that should never change the scope of whichever one we're mutating. It makes <code>CycleRecovery::merge</code> not a symmetric operation.</p>
<p>That said, I <em>think</em> your implementation actually achieves the necessary invariant in practice, but it's a bit subtle, and due solely to the way the clauses of the match pattern union are ordered, and the fact that <code>TypeInferenceBuilder::extend_cycle_recovery</code> always calls <code>CycleRecovery::merge</code> on <code>self.cycle_recovery</code>, not <code>other.cycle_recovery</code>. So it may still make sense to apply this change, just with a bit more explicit commentary about that being an important invariant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-09-11 13:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-09-11 13:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-09-11 13:51</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:40:53 UTC
    </footer>
</body>
</html>
