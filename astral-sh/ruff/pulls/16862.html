<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Introduce `TypeBound` for property tests - astral-sh/ruff #16862</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Introduce <code>TypeBound</code> for property tests</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16862">#16862</a>
        opened by <a href="https://github.com/cake-monotone">@cake-monotone</a>
        on 2025-03-20 06:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/cake-monotone">@cake-monotone</a> on 2025-03-20 06:57</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This feature was suggested by @AlexWaygood.</p>
<h3>Problem with the Previous Approach</h3>
<p>In property tests with a premise, the test could not perform valid checks until it randomly generated a type that satisfied the premise. This led to unnecessary computational waste.</p>
<p>This was particularly problematic in tests with three arguments, significantly reducing the efficiency of generating valid test cases.</p>
<p>For example:</p>
<pre><code class="language-rust">type_property_test!(
    union_equivalence_not_order_dependent, db,
    forall types s, t, u.
        s.is_fully_static(db) &amp;&amp; t.is_fully_static(db) &amp;&amp; u.is_fully_static(db) =&gt; &lt;property&gt;
);
</code></pre>
<h3>Improvements</h3>
<p>The <code>type_property_test</code> macro now explicitly requires both the identifiers and their corresponding <code>ArbitraryRule</code>.</p>
<pre><code class="language-rust">type_property_test!(
    intersection_equivalence_not_order_dependent, db,
    forall (s: FullyStaticTy, t: FullyStaticTy, u: FullyStaticTy).
        &lt;property&gt;
);
</code></pre>
<p>Now, <code>s</code>, <code>t</code>, and <code>u</code>—which are declared as <code>FullyStaticTy</code>—will only be generated from types that satisfy <code>ty.is_fully_static()</code>.</p>
<p>The rules <code>AnyTy</code>, <code>FullyStaticTy</code>, and <code>SingletonTy</code> each maintain their own random pools for generating <code>Ty</code> instances.
For more details, please refer to the changes in <code>arbitrary.rs</code>.</p>
<h2>Test Plan</h2>
<p>A new <code>ensure_rules</code> module has been added to verify that the types generated under each rule satisfy the expected conditions.</p>
<p>You can run the following command to validate the implementation:</p>
<pre><code class="language-sh">cargo test -p red_knot_python_semantic -- --ignored ensure_rules
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @cake-monotone on 2025-03-20 06:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @cake-monotone on 2025-03-20 06:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @cake-monotone on 2025-03-20 06:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @cake-monotone on 2025-03-20 06:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Introduce `ArbitraryRule` for property tests" to "[red-knot] Introduce `ArbitraryRule` for property tests" by @cake-monotone on 2025-03-20 06:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-20 07:02</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2025-03-20 07:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:266 on 2025-03-20 22:13</div>
            <div class="timeline-body"><p>It looks to me like there are some fully-static types in the above list that are not included here, silently reducing our type coverage for tests using <code>FullyStaticTy</code>. (To pick just one example, <code>BuiltinClassLiteral('str')</code> is both fully-static and a singleton, but is not included either here or below.)</p>
<p>I think this is a significant drawback of this PR. Rather than having a single pool of candidate types, with the actual implemention of <code>is_fully_static</code> and <code>is_singleton</code> deciding which types fall into which categories, we now have to manually categorize the candidate types. And while the new <code>ensure_rules</code> tests help validate that we don't include any type in a category to which it doesn't belong, there's nothing helping us validate that we aren't silently losing coverage by omitting types wrongly.</p>
<p>If we do decide to go ahead with this PR, I would at least prefer if we could not repeat ourselves. That is, have a single list of non-fully-static types, a single list of static types, and a single list of singleton types. <code>FullyStaticTy</code> would combine the latter two lists, <code>AnyTy</code> would combine all three, <code>SingletonTy</code> would use only the latter list.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-20 22:15</div>
            <div class="timeline-body"><p>Thank you for the PR!</p>
<p>I see a significant impact on an individual test using <code>SingletonTy</code> (~75% improvement), a smaller impact on tests using <code>FullyStaticTy</code> (~15% improvement), and a fairly small impact on overall runtime of the stable tests (~4% improvement).</p>
<p>This perf improvement is nice, but perhaps not as large overall as I might have hoped for from this change, I think mostly because most of the tests still use <code>AnyTy</code> anyway.</p>
<p>Personally I am not sure this perf improvement is worth the coverage drawbacks I discuss in my inline comment. Would like to hear other opinions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-21 03:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:266 on 2025-03-21 03:18</div>
            <div class="timeline-body"><p>First of all, I think I should explain that my initial intuition was off. I had assumed that using <code>is_fully_static</code> would make it very unlikely for valid tests—but it turns out that’s not really the case.</p>
<p>From my simulation, the probability that all three variables of <code>AnyTy</code> satisfy the <code>is_fully_static</code> premise is around 65%. That means, out of 100 test runs, about 65 actually test the property, which is higher than I expected.</p>
<p>The key point I was trying to focus on wasn’t performance—it was to remove meaningless tests. If the probability of satisfying a property’s premise approaches zero, the test becomes meaningless. This PR was based on that assumption, so the exact ratio of <code>AnyTy</code> to <code>FullyStaticTy</code> wasn’t my main concern.<br />
But as you've pointed out, <code>FullyStaticTy</code> doesn’t seem to be as effective as I initially thought.</p>
<p>In conclusion, I think it's totally fine to close this PR.</p>
<hr />
<p>Here are a few more stats from the simulation, which might be helpful for future property test reviews:</p>
<ul>
<li>Probability that <code>t.is_singleton()</code> holds: ~9%</li>
<li>Probability that <code>!t.is_fully_static()</code> holds: ~10%</li>
<li>Probability that <code>s.is_equivalent_to(db, t) &amp;&amp; t.is_equivalent_to(db, u)</code> holds: ~0.1%</li>
<li>Probability that <code>s.is_gradual_equivalent_to(db, t)</code> holds: ~1%</li>
</ul>
<p>These probabilities will likely decrease as we add more types to the random pool. But for now, it seems we can compensate by increasing the number of tests. If we move forward with similar PRs in the future, I think we should aim to eliminate premises with very low probability, not fully static.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-21 18:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:266 on 2025-03-21 18:57</div>
            <div class="timeline-body"><p>Aha, I hadn't fully processed the fact that if we have a premise of low probability, that doesn't just impact performance of the test, it also impacts usefulness of the test; a premise of 10% probability means we need 10x the <code>QUICKCHECK_TESTS</code> value to get the same number of actual tests of the implication. I agree this is a stronger motivation for the PR, and could be worth the risk of missing coverage of some type that we fail to include in the right list.</p>
<p>I would consider going ahead with this PR if we implement the above suggestion to avoid repetition in the type lists (so each type is listed exactly once, making it easier to evaluate whether each type is in the right place). We could also consider eliminating <code>FullyStaticTy</code> and just separating <code>SingletonTy</code>, but I kind of think if we go down this route we may as well do it fully.</p>
<p>But I would also like to hear @sharkdp 's opinion, so maybe no need to do any updates here until he is back.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-24 15:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:266 on 2025-03-24 15:10</div>
            <div class="timeline-body"><p>This PR looks great! It's something I've been meaning to implement as well. I kind of liked the generic and simple <code>premise =&gt; property</code> form, but with the syntactic change to the macro, this reads even better, I think.</p>
<blockquote>
<p>with the actual implemention of <code>is_fully_static</code> and <code>is_singleton</code> deciding which types fall into which categories, we now have to manually categorize the candidate types.</p>
</blockquote>
<p>Maybe we can maintain that property? We could have a single pool of types and then categorize them into (static, <code>LazyLock</code>) specialized lists for usage in those dedicated <code>Arbitrary</code> implementations?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:47 on 2025-03-24 15:13</div>
            <div class="timeline-body"><p>I liked the mathematical <code>.</code> here in the syntax, but it's not like it's particularly important, if it's difficult to keep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:44 on 2025-03-24 15:14</div>
            <div class="timeline-body"><pre><code class="language-suggestion">/// - `&lt;property&gt;` is an expression using these identifiers
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:60 on 2025-03-24 15:15</div>
            <div class="timeline-body"><p>Why did this become a problem just now?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:9 on 2025-03-24 15:18</div>
            <div class="timeline-body"><p>Maybe call this <code>BoundedType</code> or similar? It represents an arbitrary type that is bound by a constraint. And <code>ArbitraryRule</code> could be a <code>TypeBound</code>. There might be a small risk for confusion with type variable bounds, but they're quite similar concepts, so it might be fine?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:19 on 2025-03-24 15:20</div>
            <div class="timeline-body"><p>Maybe add a constructor so we can avoid these <code>_marker: …</code> lines?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-24 15:25</div>
            <div class="timeline-body"><p>Thank you for working on this!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-25 04:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:60 on 2025-03-25 04:18</div>
            <div class="timeline-body"><p>It’s because of the macro for <code>$premise</code>.
Since it has been generating <code>!($premise) || ($conclusion)</code>, I think the <code>||</code> operator affects the evaluation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-25 04:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/arbitrary.rs</code>:266 on 2025-03-25 04:31</div>
            <div class="timeline-body"><p>Sounds good! I’ll go ahead with the PR.</p>
<p>As sharkdp suggested, I think keeping a single pool and letting the <code>Arbitrary</code> implementations handle the categorization makes sense — it should make it easier to support more premises in the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-25 04:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests.rs</code>:47 on 2025-03-25 04:32</div>
            <div class="timeline-body"><p>Sure, no problem! I’ll go ahead and change it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-26 05:25</div>
            <div class="timeline-body"><p>The types returned by <code>generate_singular_type </code>are guaranteed to satisfy a predicate (e.g., <code>is_fully_static</code>).
However, the result of <code>generate_type_recursively</code> may not necessarily satisfy it.
One option is to keep generating random types until the condition is met, but I'm not sure if that's a good approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:122 on 2025-03-26 05:27</div>
            <div class="timeline-body"><p>Same issue with <code>generate_type_recursively</code>; the reulst may not satisfy a predicate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-26 05:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @cake-monotone on 2025-03-26 05:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-26 13:03</div>
            <div class="timeline-body"><p>For <code>is_fully_static</code> specifically, that should not be a problem, right? Unions, intersections, and tuples of fully static types are still fully static. And for singleton types, you special-cased <code>generate_type_recursively</code>. So I'm assuming you are worried about future extensions?</p>
<p>Maybe it would make sense to add something like a <code>check_property :: Ty -&gt; bool</code> function to this trait, which we could then use as a post-condition assertion for the return type of <code>generate_type_recursively</code> in <code>BoundedType&lt;Bound&gt;::arbitrary</code> before feeding a type to the actual property test?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-26 13:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-26 13:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:244 on 2025-03-26 13:06</div>
            <div class="timeline-body"><p>This represents an arbitrary gradual type. Should we maybe rename it to <code>GradualType</code>/<code>GradualTy</code> to avoid any confusion with <code>typing.Any</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @AlexWaygood removed by @AlexWaygood on 2025-03-26 13:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-27 07:23</div>
            <div class="timeline-body"><p>You're right — it's not a problem for FullyStaticTy and SingletonTy. The issue came up while I was working on NonFullyStaticTy, where an empty tuple was being generated unexpectedly. I'll apply your suggestion and commit it for now. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-27 07:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Introduce `ArbitraryRule` for property tests" to "[red-knot] Introduce `TypeBound` for property tests" by @cake-monotone on 2025-03-27 07:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @cake-monotone on 2025-03-27 07:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-27 21:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-27 21:54</div>
            <div class="timeline-body"><blockquote>
<p>The issue came up while I was working on NonFullyStaticTy, where an empty tuple was being generated unexpectedly.</p>
</blockquote>
<p>I see. Is this why you implemented it as a re-try mechanism now instead of a hard assertion? I wonder if we could turn this into a hard assertion if we would specialize the tuple generation for this specific type? To avoid having to overload <code>generate_type_recursively</code> completely, we could potentially split it up into four functions (five soon, when we <a href="https://github.com/astral-sh/ruff/pull/17006">add <code>Callable</code>s</a>), and then only specialize the tuple-generation part?</p>
<p>I wonder if we also need to take care of this for shrinking? Could we currently accidentally shrink a non-fully static counterexample type to an empty tuple (which would not fulfill the precondition of the test anymore)? And then erroneously report the empty tuple as a counterexample to a test that requires non-fully static types as inputs?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-28 02:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-28 02:32</div>
            <div class="timeline-body"><blockquote>
<p>I wonder if we could turn this into a hard assertion if we would specialize the tuple generation for this specific type?</p>
</blockquote>
<p>Ah, I see — that does sound like a better approach. I’ll give it a try!</p>
<blockquote>
<p>Could we currently accidentally shrink a non-fully static counterexample type to an empty tuple (which would not fulfill the precondition of the test anymore)?</p>
</blockquote>
<p>While it's pretty clear that this edge case won’t happen at the moment, I think it’s still something that could totally happen down the line, depending on how the type system evolves. So I think it’s worth ensuring we guard against it now.
In conclusion I think just filtering in the Arbitrary shrink, like in this PR, should be sufficient</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-28 03:42</div>
            <div class="timeline-body"><p>Hmm... it's not quite as simple as I thought.</p>
<p>For <code>NonFullyStaticTy</code>, there's another counterexample: <code>Intersection</code>.</p>
<p><code>Ty::Intersection</code> uses <code>IntersectionBuilder</code> to generate a <code>Type</code>, so the result isn't always an actual intersection type. For example:</p>
<ul>
<li>object instance from <code>Ty::Intersection(pos: [], neg: [])</code></li>
<li><code>Type::Never</code> from cases like:</li>
</ul>
<pre><code class="language-rust">Ty::Intersection {
    pos: vec![
        Ty::Tuple(vec![Ty::SubclassOfAny]),
        Ty::Tuple(vec![Ty::Unknown, Ty::Any]),
    ],
    neg: vec![],
}
</code></pre>
<p>...and many more combinations.</p>
<p>So it’s hard to determine whether the result of <code>generate_type_recursively</code> satisfies the precondition, and overloading it probably won’t help here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-28 03:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-28 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-28 15:15</div>
            <div class="timeline-body"><p>To be really honest, I'm starting to think if we should just leave everything as is? This is a significant increase in code complexity and we have identified a few pitfalls that might turn out to cause problems in the future. What is your impression, @cake-monotone?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cake-monotone">@cake-monotone</a> reviewed on 2025-03-29 13:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/cake-monotone">@cake-monotone</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-29 13:27</div>
            <div class="timeline-body"><p>I totally agree — I had the same thought when I realized this structure keeps introducing more complexity.
Maybe the main takeaway from this PR is that we need to be more mindful of the premises when creating or reviewing property tests.</p>
<p>Going back to the original goal; the main purpose of this PR was to improve the valid-testing rate of property test, right? So let's simply double the <code>QUICKCHECK_TEST</code>, since we already got a 75% performance boost from the earlier PR.</p>
<p>Let's close this PR for now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-29 22:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/property_tests/type_bound.rs</code>:117 on 2025-03-29 22:19</div>
            <div class="timeline-body"><p>Ok — Thank you very much for performing this experiment!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-03-29 22:19</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:41:05 UTC
    </footer>
</body>
</html>
