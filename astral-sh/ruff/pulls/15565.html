<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`pyupgrade`] Add rules to use PEP 695 generics in classes and functions (`UP046`, `UP047`) - astral-sh/ruff #15565</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>pyupgrade</code>] Add rules to use PEP 695 generics in classes and functions (<code>UP046</code>, <code>UP047</code>)</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15565">#15565</a>
        opened by <a href="https://github.com/ntBre">@ntBre</a>
        on 2025-01-18 04:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a></div>
            <div class="timeline-body">Summary


<p>This PR extends our <a href="https://peps.python.org/pep-0695">PEP 695</a> handling from the type aliases handled by <code>UP040</code> to generic function and class parameters, as suggested in the latter two examples from #4617:</p>
<pre><code># Input
T = TypeVar(&quot;T&quot;, bound=float)
class A(Generic[T]):
    ...

def f(t: T):
    ...

# Output
class A[T: float]:
    ...

def f[T: float](t: T):
    ...
</code></pre>
<p>I first implemented this as part of <code>UP040</code>, but based on a brief discussion during a very helpful pairing session with @AlexWaygood, I opted to split them into rules separate from <code>UP040</code> and then also separate from each other. From a quick look, and based on <a href="https://github.com/asottile/pyupgrade/issues/836">this issue</a>, I&#x27;m pretty sure neither of these rules is currently in pyupgrade, so I just took the next available codes, <code>UP046</code> and <code>UP047</code>.</p>
<p>The last main TODO, noted in the rule file and in the fixture, is to handle generic method parameters not included in the class itself, <code>S</code> in this case:</p>
<pre><code>T = TypeVar(&quot;T&quot;)
S = TypeVar(&quot;S&quot;)

class Foo(Generic[T]):
    def bar(self, x: T, y: S) -&gt; S: ...
</code></pre>
<p>but Alex mentioned that that might be okay to leave for a follow-up PR.</p>
<p>I also left a TODO about handling multiple subclasses instead of bailing out when more than one is present. I&#x27;m not sure how common that would be, but I can still handle it here, or follow up on that too.</p>
<p>I think this is unrelated to the PR, but when I ran <code>cargo dev generate-all</code>, it removed the rule code <code>PLW0101</code> from <code>ruff.schema.json</code>. It seemed unrelated, so I left that out, but I wanted to mention it just in case.</p>
Test Plan
<p>New test fixture, <code>cargo nextest run</code></p>
<p>Closes #4617, closes #12542</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-18 04:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-18 04:25</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>âœ… ecosystem check detected no linter changes.</p>
Linter (preview)
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-18 04:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-19 13:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-20 00:06</div>
            <div class="timeline-body"><p>I&#x27;m not quite sure what&#x27;s going wrong with <code>mkdocs</code>. I tried pasting in the code it suggested and also adding the rule to <code>KNOWN_FORMATTING_VIOLATIONS</code>, but running <code>python scripts/check_docs_formatted.py</code> locally still reported an issue after each attempt. I&#x27;m planning to try again tomorrow morning, but otherwise this should still be ready for review.</p>
<p>I was also mildly surprised to see no changes in the ecosystem checks. Do those run with Python 3.12?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-01-20 05:39</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;m not quite sure what&#x27;s going wrong with <code>mkdocs</code>. I tried pasting in the code it suggested and also adding the rule to <code>KNOWN_FORMATTING_VIOLATIONS</code>, but running <code>python scripts/check_docs_formatted.py</code> locally still reported an issue after each attempt. I&#x27;m planning to try again tomorrow morning, but otherwise this should still be ready for review.</p>
</blockquote>
<p>I&#x27;m not exactly sure but making the change it suggested seems to work for me ðŸ˜…</p>
<p>The script runs on the generated docs which means that you&#x27;ll have to generate the docs every time you make a change in the Rust code. It&#x27;s always preferable to include the <code>--generate-docs</code> when running this script just to make sure that it&#x27;s running on the latest docs version.</p>
<blockquote>
<p>I was also mildly surprised to see no changes in the ecosystem checks. Do those run with Python 3.12?</p>
</blockquote>
<p>Yes, the ecosystem checks are run on Python 3.12
https://github.com/astral-sh/ruff/blob/c6c434cbc75497dbba65caef892801759aeff6d2/.github/workflows/ci.yaml#L404-L420</p>
<p>https://github.com/astral-sh/ruff/blob/c6c434cbc75497dbba65caef892801759aeff6d2/.github/workflows/ci.yaml#L19-L19</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:17 on 2025-01-20 09:56</div>
            <div class="timeline-body"><p>I would avoid using AST names in user facing documentation because I doubt many users are familiar with their names. Instead, I suggest using the same terminology as PEP 695: Type parameter syntax, generic functions and classes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:1 on 2025-01-20 10:01</div>
            <div class="timeline-body"><p>Did you make any changes to the code in this module or did you copy it over as is?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/snapshots/ruff_linter__rules__pyupgrade__tests__UP046.py.snap</code>:8 on 2025-01-20 10:04</div>
            <div class="timeline-body"><p>Should we change the diagnostic range to only the <code>Generic[T]</code> instead of the entire class header because the name or other base classes aren&#x27;t a problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:9 on 2025-01-20 10:07</div>
            <div class="timeline-body"><p>Can we add an example where the class has multiple base classes (I don&#x27;t know if that&#x27;s valid)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:87 on 2025-01-20 10:11</div>
            <div class="timeline-body"><p>I generally prefer to implement <code>Display</code> over having <code>fmt_</code> methods. It has the advantage that you can call <code>to_string</code> if you want to format it to a <code>String</code> or that it can be formatted without allocating an extra string, by directly writing into the target string (using <code>f</code>)</p>
<pre><code>    impl TypeVar&lt;&#x27;_&gt; {
        fn display&lt;&#x27;a&gt;(&amp;&#x27;a self, source: &amp;&#x27;a str) -&gt; DisplayTypeVar&lt;&#x27;a&gt; {
            DisplayTypeVar { type_var: self, source }
        }
    }

    struct DisplayTypeVar&lt;&#x27;a&gt; {
        type_var: &amp;&#x27;a TypeVar&lt;&#x27;a&gt;,
        source: &amp;&#x27;a str
    }

    impl Display for DisplayTypeVar&lt;&#x27;_&gt; {
        fn fmt(...) {
            match self.type_var {
                ...
            }
        }
    }


    /// Format `self` into `s`, where `source` is the whole file, which will be sliced to recover
    /// the `TypeVarRestriction` values for generic bounds and constraints.
    fn fmt_into(&amp;self, s: &amp;mut String, source: &amp;str) {
        match self.kind {
            TypeVarKind::Var =&gt; {}
            TypeVarKind::Tuple =&gt; s.push(&#x27;*&#x27;),
            TypeVarKind::ParamSpec =&gt; s.push_str(&quot;**&quot;),
        }
        s.push_str(&amp;self.name.id);
        if let Some(restriction) = &amp;self.restriction {
            s.push_str(&quot;: &quot;);
            match restriction {
                TypeVarRestriction::Bound(bound) =&gt; {
                    s.push_str(&amp;source[bound.range()]);
                }
                TypeVarRestriction::Constraint(vec) =&gt; {
                    let len = vec.len();
                    s.push(&#x27;(&#x27;);
                    for (i, v) in vec.iter().enumerate() {
                        s.push_str(&amp;source[v.range()]);
                        if i &lt; len - 1 {
                            s.push_str(&quot;, &quot;);
                        }
                    }
                    s.push(&#x27;)&#x27;);
                }
            }
        }
    }
</code></pre>
<p>and similar, add a <code>DisplayTypeVars</code> wrapper. You could decide to skip the <code>DisplayTypeVar</code> struct and instead make <code>fmt_into</code> a method on <code>DisplayTypeVars</code> with the signature <code>fmt_type_var(f, checker.source)</code>.</p>
<p>Side node: I think <code>fmt_into</code> is sort of confusing because <code>into</code> generally suggests that it consumes <code>self</code> when used as prefix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-01-20 10:14</div>
            <div class="timeline-body"><p>Nice, this overall looks good. I didn&#x27;t review <code>pep695</code> in detail because it isn&#x27;t clear what&#x27;s copied over and what needs reviewing.</p>
<p>The title suggests to me that UP040 now handles generic functions and classes but reading the summary this doesn&#x27;t seem to be true?</p>
<p>What I understand from the summary is that this PR simply introduces a new rule? We should change the title accordingly for a clear changelog entry.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-20 12:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:9 on 2025-01-20 12:21</div>
            <div class="timeline-body"><p>It is valid, but only if <code>Generic</code> is the last base class (see https://docs.astral.sh/ruff/rules/generic-not-last-base-class/#why-is-this-bad)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:33 on 2025-01-20 12:30</div>
            <div class="timeline-body"><p>I find the name <code>TypeVarKind</code> (and especially <code>TypeVarKind::Var</code>!) a little confusing here. Maybe <code>TypeParamKind</code>, and <code>TypeParamKind::TypeVar</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:136 on 2025-01-20 12:31</div>
            <div class="timeline-body"><p>what&#x27;s the reason for altering the order from the original class? It seems to work okay to jumble them up at runtime -- couldn&#x27;t we just keep the order the user has them in?</p>
<pre><code>&gt;&gt;&gt; class Foo[**P, T, **Q, *Ts, S]: ...
...
&gt;&gt;&gt;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:33 on 2025-01-20 12:35</div>
            <div class="timeline-body"><p>Hmm, I&#x27;m not sure I understand what you&#x27;re trying to say here. If a function uses PEP-695 type parameters, those parameters are in scope for the whole of the function&#x27;s body:</p>
<pre><code>&gt;&gt;&gt; def f[T]():
...     print(T.__name__)
...     print(type(T))
...     
&gt;&gt;&gt; f()
T
&lt;class &#x27;typing.TypeVar&#x27;&gt;
</code></pre>
<p>And with respect to <code>isinstance()</code>, that never worked with old-style <code>TypeVar</code>s either!</p>
<pre><code>&gt;&gt;&gt; from typing import TypeVar
&gt;&gt;&gt; T = TypeVar(&quot;T&quot;)
&gt;&gt;&gt; def f(x: T, y: object) -&gt; T:
...     if isinstance(y, T):
...         print(&#x27;hooray!&#x27;)
...     return x
...     
&gt;&gt;&gt; f(42, 42)
Traceback (most recent call last):
  File &quot;&lt;python-input-11&gt;&quot;, line 1, in &lt;module&gt;
    f(42, 42)
    ~^^^^^^^^
  File &quot;&lt;python-input-10&gt;&quot;, line 2, in f
    if isinstance(y, T):
       ~~~~~~~~~~^^^^^^
TypeError: isinstance() arg 2 must be a type, a tuple of types, or a union
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:37 on 2025-01-20 12:35</div>
            <div class="timeline-body"><pre><code>/// from typing import TypeVar
/// T = TypeVar(&quot;T&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-20 12:36</div>
            <div class="timeline-body"><p>I wonder if these should even be the same rule...? Generic functions and generic classes feel quite distinct.</p>
<p>I don&#x27;t know how methods play into this, though -- we&#x27;ve obviously left them unimplemented for now, but we might want to try fixing them as a followup extension. We might have to fix methods in the same pass as the class definition...? Not sure...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:84 on 2025-01-20 12:37</div>
            <div class="timeline-body"><pre><code>    // PEP-695 syntax is only available on Python 3.12+
    if checker.settings.target_version &lt; PythonVersion::Py312 {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:96 on 2025-01-20 12:39</div>
            <div class="timeline-body"><p>ooh, maybe we should add another rule for this, if we don&#x27;t detect it already with something? We could open an issue for it</p>
<pre><code>&gt;&gt;&gt; from typing import TypeVar
&gt;&gt;&gt; T = TypeVar(&quot;T&quot;)
&gt;&gt;&gt; class Foo[S](Generic[T]): ...
... 
Traceback (most recent call last):
  File &quot;&lt;python-input-13&gt;&quot;, line 1, in &lt;module&gt;
    class Foo[S](Generic[T]): ...
  File &quot;&lt;python-input-13&gt;&quot;, line 1, in &lt;generic parameters of Foo&gt;
    class Foo[S](Generic[T]): ...
  File &quot;/Users/alexw/.pyenv/versions/3.13.1/lib/python3.13/typing.py&quot;, line 1279, in _generic_init_subclass
    raise TypeError(
        &quot;Cannot inherit from Generic[...] multiple times.&quot;)
TypeError: Cannot inherit from Generic[...] multiple times.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:106 on 2025-01-20 12:40</div>
            <div class="timeline-body"><p>I support this -- it&#x27;s good to cut scope for the first version of the rule. Could you possibly add a note to the rule&#x27;s documentation explaining this limitation for now, though?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:170 on 2025-01-20 12:42</div>
            <div class="timeline-body"><p>Could you add a note to the rule&#x27;s documentation saying that methods are currently not supported?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:128 on 2025-01-20 12:46</div>
            <div class="timeline-body"><p>While this is indeed an error, is it something we should be fixing? It would be just as much an error in the user&#x27;s original class:</p>
<pre><code>&gt;&gt;&gt; class Foo[T, T]: ...
  File &quot;&lt;python-input-14&gt;&quot;, line 1
    class Foo[T, T]: ...
                 ^
SyntaxError: duplicate type parameter &#x27;T&#x27;
&gt;&gt;&gt; from typing import Generic, TypeVar
&gt;&gt;&gt; T = TypeVar(&quot;T&quot;)
&gt;&gt;&gt; class Bar(Generic[T, T]): ...
... 
Traceback (most recent call last):
  File &quot;&lt;python-input-16&gt;&quot;, line 1, in &lt;module&gt;
    class Bar(Generic[T, T]): ...
              ~~~~~~~^^^^^^
  File &quot;/Users/alexw/.pyenv/versions/3.13.1/lib/python3.13/typing.py&quot;, line 432, in inner
    return func(*args, **kwds)
  File &quot;/Users/alexw/.pyenv/versions/3.13.1/lib/python3.13/typing.py&quot;, line 1235, in _generic_class_getitem
    raise TypeError(
        f&quot;Parameters to {cls.__name__}[...] must all be unique&quot;)
TypeError: Parameters to Generic[...] must all be unique
</code></pre>
<p>I think instead of filtering out duplicates, we should just bail and not emit a diagnostic if we&#x27;ve found duplicate TypeVars. It will fail at runtime and we can&#x27;t say for sure what the user wanted to happen.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-20 12:47</div>
            <div class="timeline-body"><p>Thanks, this is great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-20 12:49</div>
            <div class="timeline-body"><blockquote>
<p>I was also mildly surprised to see no changes in the ecosystem checks. Do those run with Python 3.12?</p>
</blockquote>
<p>I think we run them with Python 3.12 in CI, but when the ecosystem check is running on a project that has <code>requires-python = &quot;&gt;= 3.9&quot;</code> in its <code>pyproject.toml</code> file, it will assume that that project cannot use Python 3.12 syntax. I think few projects have <code>requires-python = &quot;&gt;= 3.12&quot;</code> at this stage, unfortunately, as it&#x27;s still a fairly new Python version</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:128 on 2025-01-20 13:07</div>
            <div class="timeline-body"><p>Ah that makes sense. I copied this from the <code>non_pep695_type_alias</code> rule, but it looks like that was to handle cases like this that we don&#x27;t have to worry about.
https://github.com/astral-sh/ruff/blob/d70d959612d6869c6754717e2333317c06020884/crates/ruff_linter/resources/test/fixtures/pyupgrade/UP040.py#L50-L53</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 13:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 13:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:33 on 2025-01-20 13:21</div>
            <div class="timeline-body"><p>Oh thanks for the clarification! I copied this from UP040 too and thought it applied here. It must be type-alias-specific again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 13:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:136 on 2025-01-20 13:26</div>
            <div class="timeline-body"><p>I was just trying to match the nice lists from the PEP and <code>typing</code> docs :laughing: I agree that keeping the original order makes more sense.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 13:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:37 on 2025-01-20 13:37</div>
            <div class="timeline-body"><p>Thanks! I combined this with the mkdocs fix</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:33 on 2025-01-20 13:41</div>
            <div class="timeline-body"><p>Sounds good, I also changed the <code>Tuple</code> variant to <code>TypeVarTuple</code> to match its PEP/<code>typing</code> name too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 13:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 13:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:9 on 2025-01-20 13:54</div>
            <div class="timeline-body"><p>I added a test case showing that multiple base classes are not modified currently and also updated the docs to mention this, as Alex suggested below. I&#x27;m happy to work on the implementation here if you prefer, but I was planning to handle this in a follow up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-20 14:04</div>
            <div class="timeline-body"><p>Yeah, I was kind of wondering that myself, especially as I was splitting UP040 and this one. The rule function bodies are just different enough that I don&#x27;t see an easy way of sharing much more code. Should I separate them?</p>
<p>I agree, not sure about methods either. Maybe they fit with functions if we can just subtract the enclosing class&#x27;s type parameters from the function code (now I&#x27;m realizing we might have a problem with nesting in general?). But I could see it going with the class code, the function code, or being a third rule even.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 14:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 14:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:17 on 2025-01-20 14:07</div>
            <div class="timeline-body"><p>Sounds good, happy to switch. I used these because they&#x27;re mentioned in the PEP and in the <code>typing</code> documentation for the code we&#x27;re replacing, and UP040 similarly mentions <code>TypeAlias</code> and <code>TypeAliasType</code>, but more natural language makes sense to me too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 14:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:1 on 2025-01-20 14:16</div>
            <div class="timeline-body"><p>I modified <code>expr_name_to_type_var</code> to include the <code>TypeVar.kind</code> field, factored out <code>TypeParam::from</code> from its call site in <code>use_pep695_type_alias.rs</code> and added the <code>match kind</code>, and added the <code>fmt_*</code> functions. The <code>Visitor</code> code is untouched, and so is the <code>TypeVarRestriction</code> struct.</p>
<p>Sorry for the confusing mix of changes. I modified it all in-place and then tried splitting it out to separate the rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-20 14:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-20 14:18</div>
            <div class="timeline-body"><p>Ah, nesting is a very good point! I think it&#x27;s fine to not offer a fix for generic functions or classes nested inside other generic functions or classes (they&#x27;re rare, and complicated to get right!). You can check whether a class or function is nested inside any class or function scopes by using this method on the semantic model to iterate up through all parent statements and checking if any are a <code>StmtClassDef</code> or a <code>StmtFunctionDef</code>: https://github.com/astral-sh/ruff/blob/73798327c62257c79effedb2f038a5649911e6b7/crates/ruff_python_semantic/src/model.rs#L1243-L1250</p>
<p>We should definitely add tests for nested functions and classes as well!</p>
<p>For methods -- after thinking about it more, I think we might be okay? Whether or not there&#x27;s also a fix for the class statement being applied by a different rule simultaneously, I think the same fix needs to be applied for the method definition:</p>
<pre><code>  T = TypeVar(&quot;T&quot;)
  S = TypeVar(&quot;S&quot;)

  class Foo(Generic[T]):
-     def bar(self, x: T, y: S) -&gt; S: ...
+     def bar[S](self, x: T, y: S) -&gt; S: ...
</code></pre>
<p>or, if the class has also been fixed...</p>
<pre><code>  S = TypeVar(&quot;S&quot;)

  class Foo[T]:
-     def bar(self, x: T, y: S) -&gt; S: ...
+     def bar[S](self, x: T, y: S) -&gt; S: ...
</code></pre>
<p>So I think it <em>should</em> be okay for methods to be their own rule -- which, I think, means that it would be good for free functions and classes to be separate rules too!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 15:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/snapshots/ruff_linter__rules__pyupgrade__tests__UP046.py.snap</code>:8 on 2025-01-20 15:29</div>
            <div class="timeline-body"><p>Good call. I thought this looked nice for the examples, but I think your suggestion makes more sense for longer, more realistic class names! And it will be even more important when we handle multiple base classes.</p>
<p>I wanted to make a similar change for functions, but I think it will require tracking the <code>range</code> of the parameter in <code>TypeVar</code> and possibly even emitting separate diagnostics for each affected parameter. I could cheat a little for classes because I only handle a single base class for now.</p>
<p>I&#x27;m picturing a function like this with non-contiguous, unique type parameters as a problematic case:</p>
<pre><code>def h(p: T, another_param, and_another: U): ...
      ^^^^                 ^^^^^^^^^^^^^^
</code></pre>
<p>I think that&#x27;s the ideal kind of diagnostic, but I think it requires separate diagnostics and fixes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 15:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:84 on 2025-01-20 15:31</div>
            <div class="timeline-body"><p>Added this to both checks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 15:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:96 on 2025-01-20 15:36</div>
            <div class="timeline-body"><p>Issue created! #15620</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-20 15:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/snapshots/ruff_linter__rules__pyupgrade__tests__UP046.py.snap</code>:8 on 2025-01-20 15:43</div>
            <div class="timeline-body"><p>Hmm yeah that&#x27;s an interesting case (CC @BurntSushi: While not directly related to diagnostics, it is an interesting problem how we may want multiple diagnostic ranges but a single fix).</p>
<p>Aren&#x27;t we tracking the ranges for the fix (by only underlining the type?). although that still doesn&#x27;t scale to multiple parameters unless we extend the range.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:17 on 2025-01-20 15:46</div>
            <div class="timeline-body"><p>Oops, you&#x27;re exactly right. These aren&#x27;t even the PEP/<code>typing</code> names. Those are <code>TypeVar</code> and <code>TypeVarTuple</code> not <code>TypeParam</code>. I changed this to</p>
<pre><code>/// ## What it does
///
/// Checks for use of standalone type variables and parameter specifications in generic functions
/// and classes.
</code></pre>
<p>in any case. I also updated both UP046 and the original UP040 docs to use <code>TypeVar</code> instead of <code>TypeParam</code> in the later variance discussion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 15:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 17:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:87 on 2025-01-20 17:14</div>
            <div class="timeline-body"><p>Ah great suggestion. I reached for <code>Display</code> initially but backed up when I realized I needed the <code>source</code> string. The intermediate struct is a good trick to keep in mind, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:6 on 2025-01-20 17:20</div>
            <div class="timeline-body"><p>We have a test that uses a bound TypeVar here -- could you also add a test that uses a constrained TypeVar?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:28 on 2025-01-20 17:21</div>
            <div class="timeline-body"><p>nit: with the latest version of the PR, I think this enum no longer needs the <code>Ord</code> and <code>PartialOrd</code> implementations (and to me there&#x27;s no &quot;obvious&quot; order they should always go in, so I&#x27;d prefer to remove them)</p>
<pre><code>#[derive(Copy, Clone, Debug, Eq, PartialEq)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 17:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/snapshots/ruff_linter__rules__pyupgrade__tests__UP046.py.snap</code>:8 on 2025-01-20 17:25</div>
            <div class="timeline-body"><p>Yes, in the generic class case, I&#x27;m using the assumption of a single base class to underline the type. This is the <code>range</code> used later for the diagnostic:
https://github.com/astral-sh/ruff/blob/55be0d8563c2dbcf4126238f6414efc998dc76e1/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs#L109-L116</p>
<p>Once we add a loop to support multiple base classes, like multiple function parameters, I think we&#x27;d need to capture each <code>range</code> from the parameters as we loop.
https://github.com/astral-sh/ruff/blob/55be0d8563c2dbcf4126238f6414efc998dc76e1/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs#L209-L221</p>
<p>But I could be misunderstanding or missing an easier way to do it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_alias.rs</code>:31 on 2025-01-20 17:25</div>
            <div class="timeline-body"><p>This issue predates your PR, but the wording here doesn&#x27;t really make sense to me; I&#x27;d change it to</p>
<pre><code>/// `covariant` and `contravariant` keywords used by `TypeVar` variables. As
/// such, rewriting a type alias using a PEP-695 `type` statement may change
/// the variance of the alias&#x27;s type parameters.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_alias.rs</code>:36 on 2025-01-20 17:36</div>
            <div class="timeline-body"><p>Blegh, the wording is again pretty bad here :/ Your docs for your new rule are much better!</p>
<p>The wording here confuses two issues:</p>
<ol>
<li>Replacing an assignment with a type statement</li>
<li>Replacing implicit variance over a globally defined <code>TypeVar</code> with an explicit type parameter</li>
</ol>
<p>For generic old-style type aliases that use type arguments, this whole paragraph actually doesn&#x27;t apply at all, since you can&#x27;t use <code>isinstance()</code> with them even if they use the old syntax:</p>
<pre><code>&gt;&gt;&gt; from typing import TypeVar, TypeAlias
&gt;&gt;&gt; T = TypeVar(&quot;T&quot;)
&gt;&gt;&gt; X: TypeAlias = list[T]
&gt;&gt;&gt; isinstance([], X)
Traceback (most recent call last):
  File &quot;&lt;python-input-4&gt;&quot;, line 1, in &lt;module&gt;
    isinstance([], X)
    ~~~~~~~~~~^^^^^^^
TypeError: isinstance() argument 2 cannot be a parameterized generic
</code></pre>
<p>You can only use <code>isinstance()</code> on old-style type aliases if they are <em>not</em> generic:</p>
<pre><code>&gt;&gt;&gt; from typing import TypeAlias
&gt;&gt;&gt; X: TypeAlias = int
&gt;&gt;&gt; isinstance(42, X)
True
</code></pre>
<p>I&#x27;d probably go with something like for the docs here</p>
<pre><code>/// Unlike type aliases that use simple assignments, definitions created using
/// [PEP 695] `type` statements cannot be used as drop-in replacements at
/// runtime for the value on the right-hand side of the statement. This means
/// that while for some simple old-style type aliases you can use them as the
/// second argument to an `isinstance()` call (for example), doing the same
/// with a [PEP 695] `type` statement will always raise `TypeError` at
/// runtime.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:28 on 2025-01-20 17:38</div>
            <div class="timeline-body"><pre><code>/// an inline type parameter may change its variance.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:32 on 2025-01-20 17:40</div>
            <div class="timeline-body"><pre><code>/// The rule currently skips generic classes with multiple base classes, and skips
/// generic methods in generic or non-generic classes.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:48 on 2025-01-20 17:41</div>
            <div class="timeline-body"><p>Maybe it&#x27;s worth making the example slightly more realistic by using the type parameter in the class body?</p>
<pre><code>/// class GenericClass(Generic[T]):
///     var: T
/// ```
///
/// Use instead:
///
/// ```python
/// class GenericClass[T]:
///     var: T
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:77 on 2025-01-20 17:43</div>
            <div class="timeline-body"><p>Another reason why it might be good for these to be implemented as separate rules: the rules table in the docs <a href="https://docs.astral.sh/ruff/rules/">here</a> is generated by this method; it will use the contents of the first <code>format!()</code> call in this method for this rule&#x27;s &quot;message&quot; column. Only displaying the first <code>format!()</code> call and not the second would give a slightly misleading impression of what the rule does, in this case!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:148 on 2025-01-20 17:46</div>
            <div class="timeline-body"><p>nit: to me it makes sense to check the typevars are not empty before filtering out duplicates</p>
<pre><code>    if vars.is_empty() {
        return;
    }

    let type_vars: Vec&lt;&amp;str&gt; = vars
        .iter()
        .unique_by(|tvar| &amp;tvar.name.id)
        .collect();

    // non-unique type variables are runtime errors, so just bail out here
    if type_vars.len() &lt; nvars.len() {
        return;
    }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-20 17:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 17:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695.rs</code>:28 on 2025-01-20 17:57</div>
            <div class="timeline-body"><p>Good call, I mean to make a comment about the ordering, but you&#x27;ve saved me from that too!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-20 18:00</div>
            <div class="timeline-body"><p>Oh, could you also possibly add a mention of https://docs.astral.sh/ruff/rules/unused-private-type-var/ to the docs for this rule? The two rules work very well when they&#x27;re enabled together, as the fixes for this rule might result in lots of type variables becoming unused. This is how you can reference another rule in the docs for a rule: https://github.com/astral-sh/ruff/blob/4cfa3555199f9377b29c490cbb703beb6b1eb3b4/crates/ruff_linter/src/rules/flake8_type_checking/rules/type_alias_quotes.rs#L116-L119</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 18:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:148 on 2025-01-20 18:12</div>
            <div class="timeline-body"><p>This section was bothering me too. I factored it out into a <code>check_type_vars</code> function to share it between the class and function rules and applied your suggestion here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-20 18:43</div>
            <div class="timeline-body"><p>Since we don&#x27;t have a useful ecosystem report on this PR (due to so few projects setting <code>requires-python</code> to Python 3.12 or newer), I tried modifying typeshed&#x27;s pyproject.toml file to say that typeshed only supported Python 3.12+, and I then ran Ruff using this branch (with only UP046 selected) on my local clone of typeshed. Here&#x27;s a PR to my typeshed fork with the results: <a href="https://github.com/AlexWaygood/typeshed/pull/34">AlexWaygood/typeshed#34</a>.</p>
<p>Summary of the findings:</p>
<ol>
<li><p>No syntax errors or comments dropped as far as I can see -- it mostly looks fantastic!</p>
</li>
<li><p>However, mypy crashes. Given that pyright is basically fine with all the changes here, this is almost certainly a bug in mypy, and probably a typeshed-specific one (typeshed provides the stubs for some very core parts of the standard library, which mypy often makes assumptions about; it&#x27;s quite easy to provoke a mypy crash by changing random parts of typeshed). Given that it&#x27;s quite unlikely that this will affect non-typeshed users, I think this probably doesn&#x27;t matter for us.</p>
</li>
<li><p>Pyright <em>nearly</em> passes, but there&#x27;s a few errors about missing type arguments for <code>slice</code>. And this highlights an important point that we both missed! <code>slice</code> is defined <a href="https://github.com/python/typeshed/blob/57d7c4334b64856fda6f6e8f992b101ddafe2f57/stdlib/builtins.pyi#L943">here</a> in typeshed, and we can see it&#x27;s generic over three type parameters. The type parameters are defined <a href="https://github.com/python/typeshed/blob/57d7c4334b64856fda6f6e8f992b101ddafe2f57/stdlib/builtins.pyi#L98-L100">here</a> -- and they all have <code>default</code> keyword arguments used in their definitions! This is <a href="https://peps.python.org/pep-0696/">PEP 696</a>, which was introduced in Python 3.13. An old-style TypeVar that uses the <code>default</code> keyword cannot be rewritten with type parameters on Python 3.12, but if we&#x27;re on Python 3.13+, we can rewrite it like this:</p>
<pre><code>  from typing_extensions import Any, TypeVar, Generic

  T = TypeVar(&quot;T&quot;, default=Any, bound=str)

- class slice(Generic[T]):
+ class slice[T: str = Any]:
      start: T
</code></pre>
</li>
<li><p>It&#x27;s a bit annoying that the rule will rewrite something like this:</p>
<pre><code>_T = TypeVar(&quot;_T&quot;)

def f(x: _T) -&gt; _T: ...
</code></pre>
<p>to</p>
<pre><code>def f[_T](x: _T) -&gt; _T: ...
</code></pre>
<p>when what I&#x27;d really <em>like</em> is</p>
<pre><code>def f[T](x: T) -&gt; T: ...
</code></pre>
<p>The leading underscore is just unnecessary visual noise when it becomes a type parameter,
since type parameters can&#x27;t anyway be accessed from outside the function scope; they&#x27;re private by default. I don&#x27;t think we should try to rename any type variables as part of this PR, but we might consider thinking about this as part of a followup.</p>
</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-20 18:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:6 on 2025-01-20 18:43</div>
            <div class="timeline-body"><p>Good catch, I added one for classes and one for functions!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-20 18:59</div>
            <div class="timeline-body"><p>Wow great catch on the <code>default</code> argument. Should we just bail out for now if we see a <code>default</code> argument? Eventually I guess we&#x27;ll need a bit more bookkeeping around the <code>checker.settings.target_version</code>.</p>
<p>Otherwise I think the remaining TODOs are</p>
<ul>
<li>[x] add tests for nested functions and classes (and bail out of nested scopes)</li>
<li>[x] split into two rules</li>
</ul>
<p>Hopefully I&#x27;ve addressed everything else, but please let me know if I missed something!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-20 19:01</div>
            <div class="timeline-body"><blockquote>
<p>Should we just bail out for now if we see a <code>default</code> argument?</p>
</blockquote>
<p>Yup, fine to bail out on seeing a <code>default</code> argument for this PR! (Though we should make a note about that in the docs for the rule, or we&#x27;ll get bug reports about it if we land this and then never get to the followup implementing support for <code>TypeVar</code>s that have the <code>default</code> argument</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;[`pyupgrade`] Expand UP040 to handle generic functions and classes (`UP040`, `UP046`)&quot; to &quot;[`pyupgrade`] Add rules to use PEP 695 generics in classes and functions (`UP046`, `UP047`)&quot; by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-20 21:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-20 21:46</div>
            <div class="timeline-body"><p>Okay, I think I covered all of the suggestions! For follow ups I have</p>
<ul>
<li>[ ] Rename private type variables in generics (don&#x27;t make inline generics like <code>[_T]</code>)</li>
<li>[ ] Allow multiple base classes for generic classes</li>
<li>[ ] Handle generic methods</li>
<li>[ ] Handle <code>default</code> kwargs for Python &gt;= 3.13</li>
</ul>
<p>Plus the separate, related rule for mixed old- and new-style generics in #15620. Should I open issues for each of these, or just track them here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-21 07:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-21 07:50</div>
            <div class="timeline-body"><p>Sorry for being late to the party but can you elaborate a bit on the reason why we chose to split the rule? The reason for the split aren&#x27;t clear to me as a user. What&#x27;s so different between classes and functions that I&#x27;d only want this rule enabled for one or the other? I don&#x27;t think it should matter how much code the implementations can share -- that would be an us problem and we shouldn&#x27;t forward it to the users by &quot;overwhelming&quot; them with more rules&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-01-21 07:53</div>
            <div class="timeline-body"><p>I&#x27;d suggest creating a new issue. They all seem like extensions and can be implemented after this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:291 on 2025-01-21 13:38</div>
            <div class="timeline-body"><p>we can avoid allocating a <code>Vec</code> here (which might be expensive) and also simplify a little:</p>
<pre><code>    // If any type varaibles were not unique, just bail out here
    // this is a runtime error and we can&#x27;t predict what the user wanted
    (vars.iter().unique_by(|tvar| &amp;tvar.name.id).count() == vars.len()).then_some(vars)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_class.rs</code>:25 on 2025-01-21 13:38</div>
            <div class="timeline-body"><pre><code>/// `contravariant` keywords used by `TypeVar` variables. As such, replacing a `TypeVar` variable
/// with an inline type parameter may change its variance.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-21 13:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-21 13:39</div>
            <div class="timeline-body"><p>Another reason Alex mentioned <a href="https://github.com/astral-sh/ruff/pull/15565#discussion_r1922718333">down below</a> was that the rules table in the docs uses the first <code>format!</code> call from <code>Violation::message</code>, so splitting them will give two more specialized descriptions in that table. Otherwise, we discussed that it&#x27;s generally nice to lean toward more fine-grained rule selection, but I see what you mean about overwhelming users with rules. I also think you&#x27;re right that users will probably want both of these together, but @AlexWaygood may have a different intuition here. I&#x27;m happy to go either way.</p>
<p>I think this is a side note related to rule categorization, but my ideal picture is something like a PEP 695 parent category that would activate all three of these (UP040, UP046, and UP047). That&#x27;s why I put them all in UP040 initially, but the naming of UP040 (<a href="https://docs.astral.sh/ruff/rules/non-pep695-type-alias/#non-pep695-type-alias-up040">non-pep695-type-alias</a>) was a bit too specific to include the others.</p>
<p>If we do leave them split, you&#x27;ve reminded me that I should add a <code>See also</code> section to both of them pointing to the other at least.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_class.rs</code>:28 on 2025-01-21 13:39</div>
            <div class="timeline-body"><p>I think the note about generic methods is irrelevant here now that it&#x27;s been split up into two rules</p>
<pre><code>/// The rule currently skips generic classes with multiple base classes. It also skips
/// generic classes nested inside of other
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_class.rs</code>:53 on 2025-01-21 13:40</div>
            <div class="timeline-body"><pre><code>/// This rule replaces standalone type variables in classes but doesn&#x27;t remove
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_function.rs</code>:25 on 2025-01-21 13:41</div>
            <div class="timeline-body"><pre><code>/// `contravariant` keywords used by `TypeVar` variables. As such, replacing a `TypeVar` variable
/// with an inline type parameter may change its variance.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_function.rs</code>:47 on 2025-01-21 13:42</div>
            <div class="timeline-body"><pre><code>/// def generic_function(var: T) -&gt; T:
///     return var
/// ```
///
/// Use instead:
///
/// ```python
/// def generic_function[T](var: T) -&gt; T:
///     return var
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_function.rs</code>:52 on 2025-01-21 13:42</div>
            <div class="timeline-body"><pre><code>/// This rule replaces standalone type variables in function signatures but doesn&#x27;t remove
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_function.rs</code>:55 on 2025-01-21 13:43</div>
            <div class="timeline-body"><pre><code>/// [`unused-private-type-var`](unused-private-type-var.md) for a rule to clean up unused
/// private type variables.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_class.rs</code>:56 on 2025-01-21 13:43</div>
            <div class="timeline-body"><pre><code>/// [`unused-private-type-var`](unused-private-type-var.md) for a rule to clean up unused
/// private type variables.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 13:44</div>
            <div class="timeline-body"><p>This looks very close!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-21 13:45</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;d suggest creating a new issue. They all seem like extensions and can be implemented after this PR.</p>
</blockquote>
<p>Agree -- I think a single new issue that tracks all these followups as sub-items would be perfect</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-21 13:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:291 on 2025-01-21 13:50</div>
            <div class="timeline-body"><p>Oh nice! I always forget about the methods on <code>bool</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-21 14:04</div>
            <div class="timeline-body"><p>Thanks for all of the documentation fixes and the <code>then_some</code> improvement! It looks like there&#x27;s a tiny typo that I&#x27;m fixing locally. Otherwise, do we want to <a href="https://github.com/astral-sh/ruff/pull/15565#discussion_r1923216394">revisit</a> splitting the rule? If not, I just want to extend the <code>See also</code> sections to point to each other. I opened the other issue for follow ups too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-21 14:06</div>
            <div class="timeline-body"><p>I saw the format issue. While not ideal, I don&#x27;t think it&#x27;s reason enough to split a rule because I consider having to configure two rules more inconvenient than a slightly confusing message in the rules table (which we can fix when we refactor Ruff&#x27;s rule infrastructure to Red Knot&#x27;s)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-21 14:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 14:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-21 14:11</div>
            <div class="timeline-body"><p>Personally I think that these are doing distinct enough things that they deserve to be separate rules -- the documentation examples for them are completely different, for example. I do see Micha&#x27;s point that there&#x27;s maybe not really a reason for why somebody might want to enable one but leave the other disabled -- but in general, I feel like we see a lot of requests for fine-grained configuration on the issue tracker, but not much demand for coarser configuration. I think there are many confusing things about Ruff&#x27;s configuration setup, but I don&#x27;t think the sheer number of rules is one of them... but I know that this is somewhere where Micha and I disagree :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-21 14:18</div>
            <div class="timeline-body"><p>I updated the <a href="https://github.com/AlexWaygood/typeshed/pull/34">PR against my typeshed fork</a> to run the autofixes from the latest version of this PR. The pyright CI there is flagging a couple of other issues:</p>
<ol>
<li><p><code>/home/runner/work/typeshed/typeshed/stdlib/builtins.pyi:1547:32 - error: Type parameter &quot;SupportsRichComparisonT&quot; is not included in the type parameter list for &quot;max&quot; (reportGeneralTypeIssues)</code>.</p>
<p>This is because <code>SupportsRichComparisonT</code> is defined in another module, so we can&#x27;t see that it&#x27;s a type variable. This actually means that the autofix breaks the function definition, because the function now mixes old-style type variable declarations with new-style type parameters in its annotations, and pyright correctly rejects this. I don&#x27;t think there&#x27;s a good solution here other than to make sure that the fix is marked unsafe, and to document that this is a known limitation of the rule.</p>
</li>
<li><p>In a similar vein, it looks like we don&#x27;t currently recognise <code>typing.AnyStr</code> as being a type variable. This is the same issue as issue (1), but it&#x27;s a very commonly used type variable (and a public member of the standard-library <code>typing</code> module), so I think it&#x27;s worth us adding some special-casing for it so that it&#x27;s recognised as a type variable.</p>
</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_class.rs</code>:156 on 2025-01-21 14:22</div>
            <div class="timeline-body"><p>the fixes to these rules should be marked as unsafe rather than safe:</p>
<ul>
<li>The issue pointed out in the <code>Known issues</code> section regarding the switch from explicit variance to inferred variance means that they could change the semantics of the code&#x27;s annotations</li>
<li>the issue I pointed out just now regarding type variables from other modules means that the fixes could in some cases outright break the code&#x27;s annotations</li>
</ul>
<pre><code>        .with_fix(Fix::unsafe_edit(Edit::replacement(
            type_params.to_string(),
            name.end(),
            arguments.end(),
        ))),
</code></pre>
<p>We also need to add a <code>## Fix safety</code> section to the rules&#x27; docs explaining why the fixes are marked as unsafe</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_function.rs</code>:158 on 2025-01-21 14:23</div>
            <div class="timeline-body"><pre><code>        .with_fix(Fix::unsafe_edit(Edit::insertion(
            type_params.to_string(),
            name.end(),
        ))),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 14:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 14:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_generic_class.rs</code>:156 on 2025-01-21 14:26</div>
            <div class="timeline-body"><p>(if you grep for <code>## Fix safety</code>, you can find lots of other rules that have similar sections in their docs, that you can use as examples!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-01-21 14:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_parameter.rs</code>:59 on 2025-01-21 14:55</div>
            <div class="timeline-body"><blockquote>
<p>but I don&#x27;t think the sheer number of rules is one of them</p>
</blockquote>
<p>I don&#x27;t think this is necessarily true, given that users ask for presets, better categorization etc. Users struggle with configuring Ruff and the sheer amount of rules is one big factor causing it. Just speaking for myself, finding if a rule already exists is no easy task (you can try pasting it in the playground but good luck if the rule requires configuration). You have to scroll through a sheer endless list of rules. And I think it&#x27;s a problem we don&#x27;t understand well yet because users simply tend to not enable rules because they&#x27;re overwhelmed (or enable all of them) -- giving them a worse experience overall. That&#x27;s why I keep pushing back on defaulting to more granular rules. There&#x27;s a non zero cost.</p>
<p>Looking at the two rules and reading the documentation I think either works. I&#x27;ve a slight preference to just have one, but considering that we split them out from UP40, maybe it&#x27;s makes sense to have them separate. I&#x27;d probably go with separate rules just to avoid extra work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-21 20:19</div>
            <div class="timeline-body"><p>Thanks again for the thorough review and for your <code>typeshed</code> tests! I think I have now</p>
<ul>
<li>handled imported type variables (by giving only a diagnostic in classes and by giving an unsafe fix (that excludes them) in functions)</li>
<li>updated the <code>Known issues</code> and <code>Fix safety</code> sections of both rules</li>
<li>added a special case for <code>AnyStr</code></li>
</ul>
<p>The <code>AnyStr</code> case felt a little awkward, so hopefully it&#x27;s at least close to what you had in mind.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:52 on 2025-01-21 21:30</div>
            <div class="timeline-body"><p>micro-nit: it&#x27;s nice to keep fixtures looking like &quot;realistic&quot; Python code where possible (this looks a bit strange to me, as there&#x27;s generally no reason to use a <code>TypeVar</code> in a function&#x27;s annotations like this unless either two parameters are annotated with the <code>TypeVar</code> or the return annotation uses the <code>TypeVar</code>):</p>
<pre><code>    def generic_method(var: T) -&gt; T:
        return var
</code></pre>
<p>this applies to a few other functions and classes in your fixtures, but I won&#x27;t comment on all of them ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:28 on 2025-01-21 21:33</div>
            <div class="timeline-body"><p>should <code>SupportsRichComparisonT</code> be imported from another module at the top of this file?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:111 on 2025-01-21 21:57</div>
            <div class="timeline-body"><p>hrm... I&#x27;m not a huge fan of the way that the special handling for <code>AnyStr</code> is kind-of implicit here. It also seems a shame that we&#x27;re now cloning all <code>TypeVarRestriction::Constraint</code> <code>Expr</code>s just to handle the <code>AnyStr</code> special case.</p>
<p>I think we can solve this by:</p>
<ol>
<li>Adding a dedicated variant for <code>TypeVarRestriction</code>, and</li>
<li>Only storing an <code>&amp;&#x27;a str</code> for the <code>name</code> field on <code>TypeVar</code>, rather than a whole <code>ast::name::Name</code>.</li>
</ol>
<p>Something like this? I think this patch also has the advantage that we&#x27;d recognise a fully qualified use of <code>AnyStr</code> as an attribute expression, e.g. <code>import typing; x: typing.AnyStr</code>:</p>

Suggested patch

<pre><code>diff --git a/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs b/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs
index 3de4228bc..de9a6407a 100644
--- a/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs
+++ b/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs
@@ -28,7 +28,10 @@ enum TypeVarRestriction&lt;&#x27;a&gt; {
     /// A type variable with a bound, e.g., `TypeVar(&quot;T&quot;, bound=int)`.
     Bound(&amp;&#x27;a Expr),
     /// A type variable with constraints, e.g., `TypeVar(&quot;T&quot;, int, str)`.
-    Constraint(Vec&lt;Expr&gt;),
+    Constraint(Vec&lt;&amp;&#x27;a Expr&gt;),
+    /// `AnyStr` is a special case: the only public `TypeVar` defined in the standard library,
+    /// and thus the only one that we recognise when imported from another module.
+    AnyStr,
 }
 
 #[derive(Copy, Clone, Debug, Eq, PartialEq)]
@@ -40,7 +43,7 @@ enum TypeParamKind {
 
 #[derive(Debug)]
 struct TypeVar&lt;&#x27;a&gt; {
-    name: &amp;&#x27;a ExprName,
+    name: &amp;&#x27;a str,
     restriction: Option&lt;TypeVarRestriction&lt;&#x27;a&gt;&gt;,
     kind: TypeParamKind,
     default: Option&lt;&amp;&#x27;a Expr&gt;,
@@ -92,23 +95,19 @@ impl Display for DisplayTypeVar&lt;&#x27;_&gt; {
             TypeParamKind::TypeVarTuple =&gt; f.write_str(&quot;*&quot;)?,
             TypeParamKind::ParamSpec =&gt; f.write_str(&quot;**&quot;)?,
         }
-        f.write_str(&amp;self.type_var.name.id)?;
+        f.write_str(self.type_var.name)?;
         if let Some(restriction) = &amp;self.type_var.restriction {
             f.write_str(&quot;: &quot;)?;
             match restriction {
                 TypeVarRestriction::Bound(bound) =&gt; {
                     f.write_str(&amp;self.source[bound.range()])?;
                 }
+                TypeVarRestriction::AnyStr =&gt; f.write_str(&quot;(bytes, str)&quot;)?,
                 TypeVarRestriction::Constraint(vec) =&gt; {
                     let len = vec.len();
                     f.write_str(&quot;(&quot;)?;
                     for (i, v) in vec.iter().enumerate() {
-                        // typing.AnyStr special case doesn&#x27;t have a real range
-                        if let Expr::Name(name) = v {
-                            f.write_str(name.id.as_ref())?;
-                        } else {
-                            f.write_str(&amp;self.source[v.range()])?;
-                        }
+                        f.write_str(&amp;self.source[v.range()])?;
                         if i &lt; len - 1 {
                             f.write_str(&quot;, &quot;)?;
                         }
@@ -135,7 +134,7 @@ impl&lt;&#x27;a&gt; From&lt;&amp;&#x27;a TypeVar&lt;&#x27;a&gt;&gt; for TypeParam {
             TypeParamKind::TypeVar =&gt; {
                 TypeParam::TypeVar(TypeParamTypeVar {
                     range: TextRange::default(),
-                    name: Identifier::new(name.id.clone(), TextRange::default()),
+                    name: Identifier::new(*name, TextRange::default()),
                     bound: match restriction {
                         Some(TypeVarRestriction::Bound(bound)) =&gt; Some(Box::new((*bound).clone())),
                         Some(TypeVarRestriction::Constraint(constraints)) =&gt; {
@@ -146,6 +145,25 @@ impl&lt;&#x27;a&gt; From&lt;&amp;&#x27;a TypeVar&lt;&#x27;a&gt;&gt; for TypeParam {
                                 parenthesized: true,
                             })))
                         }
+                        Some(TypeVarRestriction::AnyStr) =&gt; {
+                            Some(Box::new(Expr::Tuple(ast::ExprTuple {
+                                range: TextRange::default(),
+                                elts: vec![
+                                    Expr::Name(ExprName {
+                                        range: TextRange::default(),
+                                        id: Name::from(&quot;str&quot;),
+                                        ctx: ast::ExprContext::Load,
+                                    }),
+                                    Expr::Name(ExprName {
+                                        range: TextRange::default(),
+                                        id: Name::from(&quot;bytes&quot;),
+                                        ctx: ast::ExprContext::Load,
+                                    }),
+                                ],
+                                ctx: ast::ExprContext::Load,
+                                parenthesized: true,
+                            })))
+                        }
                         None =&gt; None,
                     },
                     // We don&#x27;t handle defaults here yet. Should perhaps be a different rule since
@@ -155,12 +173,12 @@ impl&lt;&#x27;a&gt; From&lt;&amp;&#x27;a TypeVar&lt;&#x27;a&gt;&gt; for TypeParam {
             }
             TypeParamKind::TypeVarTuple =&gt; TypeParam::TypeVarTuple(TypeParamTypeVarTuple {
                 range: TextRange::default(),
-                name: Identifier::new(name.id.clone(), TextRange::default()),
+                name: Identifier::new(*name, TextRange::default()),
                 default: None,
             }),
             TypeParamKind::ParamSpec =&gt; TypeParam::ParamSpec(TypeParamParamSpec {
                 range: TextRange::default(),
-                name: Identifier::new(name.id.clone(), TextRange::default()),
+                name: Identifier::new(*name, TextRange::default()),
                 default: None,
             }),
         }
@@ -178,36 +196,27 @@ struct TypeVarReferenceVisitor&lt;&#x27;a&gt; {
 /// Recursively collects the names of type variable references present in an expression.
 impl&lt;&#x27;a&gt; Visitor&lt;&#x27;a&gt; for TypeVarReferenceVisitor&lt;&#x27;a&gt; {
     fn visit_expr(&amp;mut self, expr: &amp;&#x27;a Expr) {
+        // special case for typing.AnyStr, which is a commonly-imported type variable in the
+        // standard library with the definition:
+        //
+        // ```python
+        // AnyStr = TypeVar(&#x27;AnyStr&#x27;, bytes, str)
+        // ```
+        //
+        // As of 01/2025, this line hasn&#x27;t been modified in 8 years, so hopefully there won&#x27;t be
+        // much to keep updated here. See
+        // https://github.com/python/cpython/blob/383af395af828f40d9543ee0a8fdc5cc011d43db/Lib/typing.py#L2806
+        if self.semantic.match_typing_expr(expr, &quot;AnyStr&quot;) {
+            self.vars.push(TypeVar {
+                name: &quot;AnyStr&quot;,
+                restriction: Some(TypeVarRestriction::AnyStr),
+                kind: TypeParamKind::TypeVar,
+                default: None,
+            });
+            return;
+        }
+
         match expr {
-            // special case for typing.AnyStr, which is a commonly-imported type variable in the
-            // standard library with the definition:
-            //
-            // ```python
-            // AnyStr = TypeVar(&#x27;AnyStr&#x27;, bytes, str)
-            // ```
-            //
-            // As of 01/2025, this line hasn&#x27;t been modified in 8 years, so hopefully there won&#x27;t be
-            // much to keep updated here. See
-            // https://github.com/python/cpython/blob/383af395af828f40d9543ee0a8fdc5cc011d43db/Lib/typing.py#L2806
-            e @ Expr::Name(name) if self.semantic.match_typing_expr(e, &quot;AnyStr&quot;) =&gt; {
-                self.vars.push(TypeVar {
-                    name,
-                    restriction: Some(TypeVarRestriction::Constraint(vec![
-                        Expr::Name(ExprName {
-                            range: TextRange::default(),
-                            id: Name::from(&quot;bytes&quot;),
-                            ctx: ruff_python_ast::ExprContext::Load,
-                        }),
-                        Expr::Name(ExprName {
-                            range: TextRange::default(),
-                            id: Name::from(&quot;str&quot;),
-                            ctx: ruff_python_ast::ExprContext::Load,
-                        }),
-                    ])),
-                    kind: TypeParamKind::TypeVar,
-                    default: None,
-                });
-            }
             Expr::Name(name) if name.ctx.is_load() =&gt; {
                 if let Some(var) = expr_name_to_type_var(self.semantic, name) {
                     self.vars.push(var);
@@ -243,7 +252,7 @@ fn expr_name_to_type_var&lt;&#x27;a&gt;(
         }) =&gt; {
             if semantic.match_typing_expr(subscript_value, &quot;TypeVar&quot;) {
                 return Some(TypeVar {
-                    name,
+                    name: &amp;name.id,
                     restriction: None,
                     kind: TypeParamKind::TypeVar,
                     default: None,
@@ -288,14 +297,14 @@ fn expr_name_to_type_var&lt;&#x27;a&gt;(
                     Some(TypeVarRestriction::Bound(&amp;bound.value))
                 } else if arguments.args.len() &gt; 1 {
                     Some(TypeVarRestriction::Constraint(
-                        arguments.args.iter().skip(1).cloned().collect(),
+                        arguments.args.iter().skip(1).collect(),
                     ))
                 } else {
                     None
                 };
 
                 return Some(TypeVar {
-                    name,
+                    name: &amp;name.id,
                     restriction,
                     kind,
                     default,
@@ -327,7 +336,7 @@ fn check_type_vars(vars: Vec&lt;TypeVar&lt;&#x27;_&gt;&gt;) -&gt; Option&lt;Vec&lt;TypeVar&lt;&#x27;_&gt;&gt;&gt; {
     // found on the type parameters
     (vars
         .iter()
-        .unique_by(|tvar| &amp;tvar.name.id)
+        .unique_by(|tvar| tvar.name)
         .filter(|tvar| tvar.default.is_none())
         .count()
         == vars.len())
diff --git a/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_alias.rs b/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_alias.rs
index c2340c609..1fb63f8be 100644
--- a/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_alias.rs
+++ b/crates/ruff_linter/src/rules/pyupgrade/rules/pep695/use_pep695_type_alias.rs
@@ -133,7 +133,7 @@ pub(crate) fn non_pep695_type_alias_type(checker: &amp;mut Checker, stmt: &amp;StmtAssig
         .map(|expr| {
             expr.as_name_expr().map(|name| {
                 expr_name_to_type_var(checker.semantic(), name).unwrap_or(TypeVar {
-                    name,
+                    name: &amp;name.id,
                     restriction: None,
                     kind: TypeParamKind::TypeVar,
                     default: None,
@@ -199,7 +199,7 @@ pub(crate) fn non_pep695_type_alias(checker: &amp;mut Checker, stmt: &amp;StmtAnnAssign)
     // Type variables must be unique; filter while preserving order.
     let vars = vars
         .into_iter()
-        .unique_by(|TypeVar { name, .. }| name.id.as_str())
+        .unique_by(|tvar| tvar.name)
         .collect::&lt;Vec&lt;_&gt;&gt;();
 
     checker.diagnostics.push(create_diagnostic(
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 21:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 22:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:173 on 2025-01-21 22:01</div>
            <div class="timeline-body"><p>Should we also add a test for UP040 with a type alias that uses a <code>TypeVar</code> with a default (since that rule now shares the logic from this module)?</p>
<p>We might want to see if we can convert the fix there to also use simple string interpolation rather than the <code>ExprGenerator</code>... I feel like it makes sense for all three rules to use basically the same infrastructure. But not for this PR! Just another possible followup for you ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 22:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:206 on 2025-01-21 22:08</div>
            <div class="timeline-body"><p>I think we have to make sure here that <code>str</code> and <code>bytes</code> haven&#x27;t been overridden in an enclosing scope before we add a type parameter that uses <code>(str, bytes)</code> as constraints. E.g. <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=100810bb27581625b327bce54ec1b63b">https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=100810bb27581625b327bce54ec1b63b</a>. If <code>str</code> and/or <code>bytes</code> have been overridden with symbols in an enclosing scope, we can&#x27;t offer a fix to replace <code>AnyStr</code> with an inline type parameter. I think you can check for this using the <code>SemanticModel::is_available()</code> method. https://github.com/astral-sh/ruff/blob/ef85c682bdd76ed63457bdfbec72e09424ac20ab/crates/ruff_python_semantic/src/model.rs#L327-L331</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 22:10</div>
            <div class="timeline-body"><p>The docs look fantastic now! Thanks again for your patience!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 10:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:206 on 2025-01-22 10:17</div>
            <div class="timeline-body"><p>To be clear: I&#x27;d <em>only</em> do this for <code>AnyStr</code>, at least for the first version of this rule. I think theoretically it could apply to the bounds or constraints for any <code>TypeVar</code>, but:</p>
<ol>
<li>It&#x27;s much more likely to be an issue for a TypeVar coming from another module like <code>AnyStr</code></li>
<li>I think it&#x27;ll just be much more complicated to account for name shadowing with arbitrary non-<code>AnyStr</code> TypeVars, and it&#x27;s probably not essential since the fix is already marked as unsafe.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-22 11:10</div>
            <div class="timeline-body"><p>I did some more testing using the PR to my typeshed fork. I have good news and bad news!</p>
<p>The good news is that the pyright report on the typeshed PR is now basically clean -- all remaining errors are due to TypeVars coming from other modules, but we&#x27;ve flagged that in the rule&#x27;s documentation. Also, these just aren&#x27;t that common, so there aren&#x27;t very many errors relating to even that.</p>
<p>The bad news is that I managed to minimize the mypy crash, and it doesn&#x27;t actually look like something that would only affect typeshed: <a href="https://github.com/python/mypy/issues/18507">python/mypy#18507</a>. I think it could potentially affect any stub authors. Pytype is also crashing on the PR to my typeshed fork, so we should perhaps add a note to this rule&#x27;s documentation saying that not all type checkers fully support PEP 695 yet, so users may need to be careful before applying the rule&#x27;s autofixes to their codebase.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 13:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:52 on 2025-01-22 13:46</div>
            <div class="timeline-body"><p>Ah sorry for making you repeat yourself. I know you mentioned it for the docs, but I thought I could get away with it for the tests! I&#x27;ll keep this in mind now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 13:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:28 on 2025-01-22 13:54</div>
            <div class="timeline-body"><p>I didn&#x27;t know where it&#x27;s actually from (maybe <code>_typeshed</code> from a github search?), but I imported it from <code>somewhere</code> at the top to make it more clear that we&#x27;re testing an unknown type variable,  not just a missing import. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 13:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046.py</code>:28 on 2025-01-22 13:56</div>
            <div class="timeline-body"><p>yup, it&#x27;s defined in <code>_typeshed</code> here: https://github.com/python/typeshed/blob/ce521e8c76eec84828b30353b163fcff8e054bbd/stdlib/_typeshed/<strong>init</strong>.pyi#L104 (it doesn&#x27;t actually exist at runtime!). But importing it from <code>somewhere</code> is fine for these fixtures; the only important thing is that it needs to come from another module ðŸ‘</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:111 on 2025-01-22 13:57</div>
            <div class="timeline-body"><p>Agreed, I didn&#x27;t like it either. Thanks for the patch!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 13:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 14:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:206 on 2025-01-22 14:01</div>
            <div class="timeline-body"><p>Oh, actually, <code>SemanticModel::has_builtin_binding</code> might be better for this use case that <code>SemanticModel::is_available</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/13e7afca42e1ab4e698412df903e3dd172909caa/crates/ruff_python_semantic/src/model.rs#L268-L277</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:173 on 2025-01-22 14:22</div>
            <div class="timeline-body"><p>Added some tests and three lines to bail out if we see <code>default</code>, and I added the string suggestion to the follow up issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:1 on 2025-01-22 14:24</div>
            <div class="timeline-body"><p>And UP047!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 14:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:206 on 2025-01-22 14:41</div>
            <div class="timeline-body"><p>Great catch! I also added a test for this. Is there a way to reset the builtin status of <code>str</code>, for example? I tried this initially to check both <code>str</code> and <code>bytes</code> and that everything was reset, but I think any assignment to a builtin might just mean it&#x27;s not built in anymore? And we can&#x27;t nest within a class or function to get a new scope since we skip nesting too! I&#x27;m happy enough with the current test, which is just the first case here, but I wanted to check.</p>
<pre><code>str = &quot;string&quot;
class BadStr(Generic[AnyStr]):
    var: AnyStr

str = __builtins__.str

bytes = b&quot;bytes&quot;
class BadBytes(Generic[AnyStr]):
    var: AnyStr

bytes = __builtins__.bytes

class OkayAgain(Generic[AnyStr]):
    var: AnyStr
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 14:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 14:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:206 on 2025-01-22 14:49</div>
            <div class="timeline-body"><blockquote>
<p>Is there a way to reset the builtin status of <code>str</code>, for example?</p>
</blockquote>
<p>Ooh good point. Usually I&#x27;d usually put everything inside a function but here that obviously doesn&#x27;t work, for the reasons you pointed out! Maybe you could put the test in a different fixture file entirely (with a docstring at the top of the fixture file saying why it&#x27;s separated from most of the rest of the fixtures for these rules)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:206 on 2025-01-22 14:58</div>
            <div class="timeline-body"><p>Ah okay, I just put it at the bottom, but a separate file probably makes more sense!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 14:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046_0.py</code>:29 on 2025-01-22 15:06</div>
            <div class="timeline-body"><pre><code># or constraints on the TypeVar imported from another module
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046_0.py</code>:41 on 2025-01-22 15:08</div>
            <div class="timeline-body"><p>for a <code>TypeVarTuple</code>, this would either be</p>
<pre><code>class MultipleGenerics(Generic[S, T, *Ts, P]):
</code></pre>
<p>or, if the code was originally written to support Python &lt;3.11</p>
<pre><code>class MultipleGenerics(Generic[S, T, Unpack[Ts], P]):
</code></pre>
<p>with <code>Unpack</code> imported from <code>typing</code> or <code>typing_extensions</code>. Proper handling of <code>Unpack</code> is yet another thing you could possibly handle in a followup PR ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:3 on 2025-01-22 15:12</div>
            <div class="timeline-body"><p>Hmm... I suppose these new rules don&#x27;t really fit with our <a href="https://github.com/astral-sh/ruff/blob/main/CONTRIBUTING.md#rule-naming-convention">naming convention</a>. On the other hand, they do match the name of UP040, which is a very similar pre-existing rule. Not sure whether we should use our &quot;general convention&quot; or the &quot;local convention&quot; set by UP040... @MichaReiser, do you have any preference?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:172 on 2025-01-22 15:17</div>
            <div class="timeline-body"><p>(I&#x27;m not sure it should be a different <em>rule</em> but let&#x27;s discuss that on <a href="https://github.com/astral-sh/ruff/issues/15642">astral-sh/ruff#15642</a> ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:254 on 2025-01-22 15:25</div>
            <div class="timeline-body"><p>I know this is just copied over from where it was before -- but we can simplify this quite a bit with some <code>?</code>s:</p>
<pre><code>    let StmtAssign { value, .. } = semantic
        .lookup_symbol(name.id.as_str())
        .and_then(|binding_id| semantic.binding(binding_id).source)
        .map(|node_id| semantic.statement(node_id))?
        .as_assign_stmt()?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-22 15:26</div>
            <div class="timeline-body"><p>Brilliant work. This looks ready to land now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 15:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:3 on 2025-01-22 15:30</div>
            <div class="timeline-body"><p>I think the rule names are actually okay, but the modules don&#x27;t match the rule names :sweat_smile: I think that should be an easy and non-user-facing change if we wanted to rename all three?</p>
<p>https://github.com/astral-sh/ruff/blob/9fadf46933bb5cc7f6eafbcd22418dfdd8021e3a/crates/ruff_linter/src/codes.rs#L537</p>
<p>https://github.com/astral-sh/ruff/blob/9fadf46933bb5cc7f6eafbcd22418dfdd8021e3a/crates/ruff_linter/src/codes.rs#L543-L544</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 15:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:3 on 2025-01-22 15:31</div>
            <div class="timeline-body"><p>Ohh perfect. Yes, let&#x27;s just rename the files to match the rules that are in them, then ðŸ˜„</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 15:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:172 on 2025-01-22 15:32</div>
            <div class="timeline-body"><p>I&#x27;ll blame Zanie for that one since it was already there! But sounds good to discuss in any case :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/pyupgrade/UP046_0.py</code>:41 on 2025-01-22 15:39</div>
            <div class="timeline-body"><p>Ah, I thought I caught all of these this time. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 15:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:2 on 2025-01-22 15:58</div>
            <div class="timeline-body"><pre><code>//! Shared code for [`non_pep695_type_alias`] (UP040),
//! [`non_pep695_generic_class`] (UP046), and [`non_pep695_generic_function`]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-22 15:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 16:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:2 on 2025-01-22 16:04</div>
            <div class="timeline-body"><p>Ahh, the one place my LSP couldn&#x27;t rename for me. I did a quick grep this time, and there&#x27;s also a pyflakes test called <code>use_pep695_type_aliass</code> (double <code>s</code> included). Should I rename that as well?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-22 16:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:2 on 2025-01-22 16:12</div>
            <div class="timeline-body"><p>Hmm, it looks like that pyflakes test was only <em>renamed</em> in <a href="https://github.com/astral-sh/ruff/pull/6289">astral-sh/ruff#6289</a>/files... and I&#x27;m not sure why, because it doesn&#x27;t seem relevant to that PR (the type aliases in that test don&#x27;t use PEP 695, and there are no changes to any pyflakes-related code in that PR other than the test being renamed). It looks like it <em>might</em> have been renamed by mistake?</p>
<p>@zanieb, I know it was a while ago, but I don&#x27;t suppose you have any context on why that test was renamed in that PR, do you? :-)</p>
<p>I don&#x27;t think the naming of that separate pyflakes test needs to hold up this PR being merged, though ðŸ˜„</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-01-22 16:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/pep695/mod.rs</code>:2 on 2025-01-22 16:16</div>
            <div class="timeline-body"><p>Sounds good! I&#x27;ll push this fix and then move towards merging.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-22 16:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/ntBre">@ntBre</a> on 2025-01-22 16:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-22 16:35</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:10:32 UTC
    </footer>
</body>
</html>
