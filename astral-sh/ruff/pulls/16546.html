<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Break up call binding into two phases - astral-sh/ruff #16546</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Break up call binding into two phases</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16546">#16546</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-03-07 01:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>This breaks up call binding into two phases:</p>
<ul>
<li><p><strong><em>Matching parameters</em></strong> just looks at the names and kinds (positional/keyword) of each formal and actual parameters, and matches them up.  Most of the current call binding errors happen during this phase.</p>
</li>
<li><p>Once we have matched up formal and actual parameters, we can <strong><em>infer types</em></strong> of each actual parameter, and <strong><em>check</em></strong> that each one is assignable to the corresponding formal parameter type.</p>
</li>
</ul>
<p>As part of this, we add information to each formal parameter about whether it is a type form or not. Once <a href="https://peps.python.org/pep-0747/">PEP 747</a> is finalized, we can hook that up to this internal type form representation. This replaces the <code>ParameterExpectations</code> type, which did the same thing in a more ad hoc way.</p>
<p>While we&#x27;re here, we add a new fluent API for building <code>Parameter</code>s, which makes our signature constructors a bit nicer to read.  We also eliminate a TODO where we were consuming types from the argument list instead of the bound parameter list when evaluating our special-case known functions.</p>
<p>Closes astral-sh/ruff#15460</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-03-07 07:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2445 on 2025-03-18 18:45</div>
            <div class="timeline-body"><p>These <code>type_form</code> calls are the magic lines that replace <code>ParameterExpectations</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2690 on 2025-03-18 18:47</div>
            <div class="timeline-body"><p>This special-case return type logic moves over to a private method on <code>Bindings</code>, which we guarantee is always called after checking argument types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-18 18:49</div>
            <div class="timeline-body">

<code>mypy_primer</code> results
<p>No ecosystem changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-18 18:55</div>
            <div class="timeline-body"><p>This representation lets us handle different union elements/overloads that have different bound <code>self</code> parameters without having to make clones of all of the other arguments. That&#x27;s not just an optimization, it also ensures that there&#x27;s only a single slice of non-bound arguments that we perform type inference on. (That type inference now happens after we&#x27;ve matched up arguments and parameters — which is when we prepend bound <code>self</code> parameters)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-18 18:57</div>
            <div class="timeline-body"><p>We either need these cells, or the <code>Rc</code> slice up above needs to be an <code>Rc&lt;RefCell&lt;[_]&gt;&gt;</code>, so that the type inference code can update these fields with the inferred types after we&#x27;ve already matched parameters.  Since these types are both <code>Copy</code> this seemed the cleanest.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:177 on 2025-03-18 18:58</div>
            <div class="timeline-body"><p>I&#x27;m not sure if it&#x27;s really needed, but using bitflags here instead of an enum or bool means that we support an argument that might be used as a type form for one union element/overload, and a value for another.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:33 on 2025-03-18 18:58</div>
            <div class="timeline-body"><p><code>Bindings</code> now takes ownership of both the signatures and (a clone of the) arguments of its call site, since that information needs to carry over from <code>match_parameters</code> to <code>check_types</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:217 on 2025-03-18 19:00</div>
            <div class="timeline-body"><p>We&#x27;re using <code>parameter_types</code> everywhere now, which lets close off a TODO and remove <code>CallArguments::{first,second,third}_argument</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-18 19:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-18 20:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-18 20:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-18 20:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-18 20:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-03-18 21:26</div>
            <div class="timeline-body"><p>Is this PR WIP or ready for review?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;[red-knot] WIP: Break up call binding into two phases&quot; to &quot;[red-knot] Break up call binding into two phases&quot; by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-18 21:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-18 21:35</div>
            <div class="timeline-body"><blockquote>
<p>Is this PR WIP or ready for review?</p>
</blockquote>
<p>Doh! I remembered to update everything except for the title :joy:   It&#x27;s ready for review</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:70 on 2025-03-18 23:12</div>
            <div class="timeline-body"><p>Another possible naming approach that would avoid the clippy warning, and maybe be more explicit:</p>
<pre><code>    /// The inferred type of this argument as a value expression. Will be `Type::Unknown` if we
    /// haven&#x27;t inferred a type for this argument yet.
    value_type: Cell&lt;Type&lt;&#x27;db&gt;&gt;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 00:29</div>
            <div class="timeline-body"><p>If I understand correctly, storing two separate types here allows us to share a single set of arguments, even if we use those arguments to call e.g. a union of callables, in which the same argument might need to be inferred as a value expression for one of the callables and a type form for the other.</p>
<p>(Does our type inference approach actually support that case in this PR? Either way, should we add a test for that case?)</p>
<p>My concern here is that while this works for &quot;type expression vs value expression&quot;, it doesn&#x27;t scale to generalized &quot;type context.&quot; (See <a href="https://github.com/astral-sh/ruff/issues/16838">astral-sh/ruff#16838</a> for a writeup on what I mean by &quot;type context&quot; here.) Assuming we will need generalized type context, we will I think eventually either need to clone arguments, or we&#x27;ll need a more generalized representation here that can store any number of types for a given argument, keyed by the context type perhaps?</p>
<p>But as long as we are aware of this, and have a rough idea how we&#x27;d approach it (and maybe mention it in a TODO comment, or in a comment over on <a href="https://github.com/astral-sh/ruff/issues/16838">astral-sh/ruff#16838</a> ?), it could still be OK to go with this version for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-19 00:30</div>
            <div class="timeline-body"><p>Haven&#x27;t finished my review yet, but leaving a few initial comments since I need to head out for a bit now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:70 on 2025-03-19 00:40</div>
            <div class="timeline-body"><p>What were your considerations in using Unknown to represent &quot;no type inferred yet&quot; vs using an <code>Option&lt;Type&gt;</code> here? Given that <code>Unknown</code> is also a valid inferred type for an argument, the latter seems semantically clearer about whether we&#x27;ve inferred a type for this argument yet. But maybe in practice we don&#x27;t need that clarity?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-19 00:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-19 07:12</div>
            <div class="timeline-body"><p>I think it&#x27;s worth making this a comment on <code>arguments</code>. The reason of <code>Rc</code> is definetely not &quot;appearant&quot; (and one of our first uses in Red Knot?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:20 on 2025-03-19 07:13</div>
            <div class="timeline-body"><p>Nit: Would <code>Default::default()</code> work?</p>
<pre><code>            arguments: Default::default(),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:32 on 2025-03-19 07:16</div>
            <div class="timeline-body"><p>Can we add a <code>## Panics</code> section to the documentation that explains that this method can only be called for <code>self</code> when <code>bound_self</code> is <code>None</code>.</p>
<p>The alternative would be to make this method return an <code>Option</code> or a <code>Result</code> and use explicit <code>unwrap</code> calls. But that might be somewhat annoying if there are too many call sites.</p>
<p>After reviewing the entire PR: It seems that this variant bubbles all the way up to <code>Type::try_*</code> methods. I think we should document this invariant on all methods where it is necessary or enforce it by changing the signature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-19 07:25</div>
            <div class="timeline-body"><p>I don&#x27;t think I fully understand</p>
<blockquote>
<p>That&#x27;s not just an optimization, it also ensures that there&#x27;s only a single slice of non-bound arguments that we perform type inference on.</p>
</blockquote>
<p>Or, I&#x27;m not sure I fully understand its implication.</p>
<blockquote>
<p>Once we have matched up formal and actual parameters, we can infer types of each actual parameter, and check that each one is assignable to the corresponding formal parameter type.</p>
</blockquote>
<p>What I understand from your sentence in the PR summary is that we only perform type inference once we matched all parameters? Does this happen exactly once or is it possible that this operation is performed more than once (e.g. once for every matching signature?)</p>
<p>I&#x27;m asking because I&#x27;m a bit concerned about the <code>Cell</code> use in <code>Argument</code> because we then loose the static assertion that type inference can happen exactly once (you could hold on to multiple <code>Arguments</code> that all point to the same shared slice but then infer the type with differently matched parameters). Would it be possible to use <code>Rc::get_mut</code> (or <code>try_mut</code>) instead of using interior mutability to enforce that all other references to the <code>Argument</code> slice got dropped or are they still alive at that point? If they&#x27;re still alive, isn&#x27;t the state of their <code>Argument</code>s now misleading because the types are inferred for another matched binding?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:8 on 2025-03-19 07:27</div>
            <div class="timeline-body"><p>I think it would be good to document that <code>CallArguments</code> should be light to clone because the operation is performent frequently during call binding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:159 on 2025-03-19 07:30</div>
            <div class="timeline-body"><p>Nit: Should we rename this to <code>evalute_known_cases</code> to reuse our existing terminology around known classes, functions?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:493 on 2025-03-19 07:32</div>
            <div class="timeline-body"><p>It seems that this path might now panic if <code>arguments</code> already has <code>self</code> bound.</p>
<p>We should at least document this constraint on <code>match_parameters</code> but it makes me think if we should change the signature to return a <code>Result</code> or <code>Option</code> here to have the caller <em>guarantee</em> that <code>arguments</code> isn&#x27;t bound yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:471 on 2025-03-19 07:33</div>
            <div class="timeline-body"><p>Nit: Is it still necessary that all these types are <code>Clone</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:642 on 2025-03-19 07:35</div>
            <div class="timeline-body"><p>I&#x27;d prefer an <code>Option&lt;usize&gt;</code> over the maigc use of <code>usize::MAX</code> or to introduce a newtype wrapper that behaves as <code>Option&lt;usize&gt;</code> but does the <code>magic</code> encoding internally (e.g. by using an <code>Option&lt;NonZeroUsize&gt;</code> internally and that maps the indices by 1 offset).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:15 on 2025-03-19 07:37</div>
            <div class="timeline-body"><p>Do we need the precision of both lifetimes or could we use one unified <code>&#x27;a</code> lifetime for both <code>call</code> and <code>db</code>?</p>
<p>It seems to me that <code>call</code> will always be the shorter lifetime of the two.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-19 07:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-19 13:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-19 13:32</div>
            <div class="timeline-body"><blockquote>
<p>What I understand from your sentence in the PR summary is that we only perform type inference once we matched all parameters?</p>
</blockquote>
<p>Yes that&#x27;s right</p>
<blockquote>
<p>Does this happen exactly once or is it possible that this operation is performed more than once (e.g. once for every matching signature?)</p>
</blockquote>
<p>This is related to @carljm comment <a href="https://github.com/astral-sh/ruff/pull/16546">astral-sh/ruff#16546</a>#discussion_r2002195997</p>
<p>As of right now, we peform type inference on each argument at most once. We do not infer a different type for an argument for each matching signature. As we move towards supporting generics, we will have to do more work per argument for each matching signature. But I am purposefully trying to keep this PR simpler by not bringing that into play yet.</p>
<blockquote>
<p>I&#x27;m asking because I&#x27;m a bit concerned about the <code>Cell</code> use in <code>Argument</code> because we then loose the static assertion that type inference can happen exactly once (you could hold on to multiple <code>Arguments</code> that all point to the same shared slice but then infer the type with differently matched parameters).</p>
</blockquote>
<p>Before we had that as a static guarantee because <code>Argument</code> had no mutuator methods — you had to provide the inferred type when you created it. If I understand your concern, it&#x27;s less about using <code>Cell</code> in particular and more about having a mutator method at all, is that right? Would you have the same worry if it was a more normal <code>&amp;mut self</code> mutator method? Because there would still be no static guarantee that you didn&#x27;t call it twice.</p>
<p>I could pull the argument types out into a separate Rust type, which you would create after <code>match_parameters</code> and then pass in to <code>check_types</code>. But I think then we&#x27;d lose the static guarantee that the <code>ArgumentTypes</code> that you pass in in step two was created for the <code>CallArguments</code> that you pass in in step one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-19 13:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 13:41</div>
            <div class="timeline-body"><blockquote>
<p>(Does our type inference approach actually support that case in this PR? Either way, should we add a test for that case?)</p>
</blockquote>
<p>In theory yes <a href="https://github.com/astral-sh/ruff/pull/16546">astral-sh/ruff#16546</a>#discussion_r2001792198, but that&#x27;s a good suggestion to add a test for it</p>
<blockquote>
<p>have a rough idea how we&#x27;d approach it</p>
</blockquote>
<p>For that I assumed that we would eventually move the inferred argument types down into <code>Binding</code>, so that we could store separate inferred types for each signature.  I wanted to avoid that in this PR, since I didn&#x27;t want to repeat the inference step for each matched signature.  (<code>infer_expression</code> and <code>infer_type_expression</code> don&#x27;t seem to be salsa queries, and so we wouldn&#x27;t get memoization of those for free, unless I&#x27;m misunderstanding something)</p>
<p>My suggestion for @MichaReiser&#x27;s comment <a href="https://github.com/astral-sh/ruff/pull/16546">astral-sh/ruff#16546</a>#discussion_r2003341589 might work for this too — go ahead and create <code>ArgumentTypes</code>, with a single inferred type for each argument, and put it in <code>Bindings</code> since we currently only do inference once per call.  (Actually put it there twice: once for holding value types, and one for type form types.)</p>
<p>Or, just eat the cost of doing inference once per signature now, since we know we&#x27;ll need to at some point anyway?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-19 13:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 13:45</div>
            <div class="timeline-body"><blockquote>
<p>Assuming we will need generalized type context, we will I think eventually either need to clone arguments</p>
</blockquote>
<p>Put differently, with type contexts, we will definitely need to perform inference multiple times on each argument.  One thing I noticed fixing some tests on this PR is that we currently have to make sure to infer a type for each argument, even if the argument was not successfully matched to a parameter.  That is, we actually can&#x27;t infer argument types <em>at most</em> once, it has to be <em>exactly</em> once.  This is because the argument expression might contain standalone expressions, and we have tests that verify that we end up inferring and storing a type for each of those.  If we don&#x27;t make sure to visit non-matched arguments, we can miss some of those.</p>
<p>Will that be an issue inferring arguments multiple times? Will the standalone expression machinery handle that correctly? (Will it be possible to infer different types for standalone expressions inside of an argument that ends up with different inferred types for different signatures? Or will we just collapse those down into a union?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-19 13:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-19 13:56</div>
            <div class="timeline-body"><blockquote>
<p>If I understand your concern, it&#x27;s less about using Cell in particular and more about having a mutator method at all, is that right?</p>
</blockquote>
<p>My main concern is how we avoid that we don&#x27;t accidentally end up mutating the same underlying <code>Argument</code> that is shared by using <code>Rc&lt;[Argument]&gt;</code>. The benefit I see of using <code>Rc::get_mut</code> and panicking if it is shared is that we would detect that mistake (at least at runtime).</p>
<p>I don&#x27;t think that using <code>&amp;mut</code> helps here because my concern is about having two <code>CallArguments</code> that both share the same <code>arguments</code>. Requiring a <code>&amp;mut CallArguments</code> doesn&#x27;t prevent mutating <code>a</code> when <code>b</code> points to the same arguments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-19 14:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-19 14:08</div>
            <div class="timeline-body"><p>I don&#x27;t think we can use <code>Rc::get_mut</code> because with how it&#x27;s formulated right now, we <em>need</em> that sharing. Each signature might have to bind a different <code>self</code>/<code>cls</code> argument to the front of the argument list, but we also only want to perform type inference once on the (non-bound) arguments that are the same for each signature. The bindings themselves have to store the arguments so that they can be type-checked in the later call, and the outer code in <code>infer.rs</code> also needs to store the arguments so that it can do the actual type inference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-19 14:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:12 on 2025-03-19 14:43</div>
            <div class="timeline-body"><blockquote>
<p>how we avoid that we don&#x27;t accidentally end up mutating the same underlying <code>Argument</code> that is shared by using <code>Rc&lt;[Argument]&gt;</code></p>
</blockquote>
<p>My understanding is that the whole point of this structure is that we <em>do</em> want to mutate the same underlying shared <code>Argument</code>; it gives us a place to store the inferred type for that argument, to avoid inferring it multiple times.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-19 15:01</div>
            <div class="timeline-body"><p>I&#x27;m reworking this with a different way of representing arguments and types per @MichaReiser and @carljm&#x27;s comments.  Putting this back to draft while I do that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-19 15:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-19 15:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 15:07</div>
            <div class="timeline-body"><p>This all makes sense. I&#x27;m fine in general with keeping this PR simpler by not expanding scope to cover the future need for type context, I would just suggest recording our best understanding of how the current approach is limited and what we may need to do instead in future, either in a TODO comment or in a new issue. (It could even just be as a comment over on #16838.)</p>
<blockquote>
<p>One thing I noticed fixing some tests on this PR is that we currently have to make sure to infer a type for each argument, even if the argument was not successfully matched to a parameter. That is, we actually can&#x27;t infer argument types <em>at most</em> once, it has to be <em>exactly</em> once. This is because the argument expression might contain standalone expressions, and we have tests that verify that we end up inferring and storing a type for each of those. If we don&#x27;t make sure to visit non-matched arguments, we can miss some of those.</p>
</blockquote>
<p>Yes, this requirement originates with our desire to have some type for every expression, both for IDE uses and for typed-linter use cases. It isn&#x27;t actually limited to just standalone expressions, it&#x27;s a requirement currently that <em>every</em> expression have a type.</p>
<blockquote>
<p>Will that be an issue inferring arguments multiple times? Will the standalone expression machinery handle that correctly? (Will it be possible to infer different types for standalone expressions inside of an argument that ends up with different inferred types for different signatures? Or will we just collapse those down into a union?)</p>
</blockquote>
<p>The purpose of standalone expressions is that inferring a type for them does go through a query (<code>infer_expression_types</code>). I think for expressions (like call arguments) that may need to be inferred multiple times with different type contexts, we will need to make them standalone expressions, and we will need to add the type context as an argument to <code>infer_expression_types</code>, so we automatically get Salsa caching keyed on the expression+context pair.</p>
<p>And then, yes, we will need to decide how to ultimately provide a single type for that expression to, say, IDE hover, or a typed linter rule. Not sure I have a better idea for that than the union? It should be relatively rare in practice that we call a union of callables where different elements of the union have different type contexts for the same argument.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-19 17:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 17:57</div>
            <div class="timeline-body"><blockquote>
<p>It isn&#x27;t actually limited to just standalone expressions, it&#x27;s a requirement currently that <em>every</em> expression have a type.</p>
</blockquote>
<p>Ah right, thank you for calling that out!</p>
<blockquote>
<p>And then, yes, we will need to decide how to ultimately provide a single type for that expression to, say, IDE hover, or a typed linter rule. Not sure I have a better idea for that than the union? It should be relatively rare in practice that we call a union of callables where different elements of the union have different type contexts for the same argument.</p>
</blockquote>
<p>My more pressing (and mundane) concern was that <code>store_expression_type</code> currently panics if you try to store a type for an expression more than once. I wasn&#x27;t certain if that&#x27;s just there to help catch unexpected bugs, or if it&#x27;s protecting something more fundamental that would be hard to reconcile with inferring expressions multiple times in different contexts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-19 19:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 19:00</div>
            <div class="timeline-body"><blockquote>
<p>My more pressing (and mundane) concern was that <code>store_expression_type</code> currently panics if you try to store a type for an expression more than once. I wasn&#x27;t certain if that&#x27;s just there to help catch unexpected bugs, or if it&#x27;s protecting something more fundamental that would be hard to reconcile with inferring expressions multiple times in different contexts.</p>
</blockquote>
<p>It&#x27;s aiming to catch bugs where we accidentally do unnecessary repeat work, or accidentally include an expression in multiple different inference regions. I&#x27;ve been aware that this will eventually need modification to handle speculative inference or inference with differing type contexts, but haven&#x27;t yet worked out a detailed plan for it. Ideally we would keep some protection against accidental duplication by using explicit API for cases where we really do want to infer the same expression tree multiple times. (One possibility implied above is that we only do this for standalone expressions, and so we have special cases around merging the result of <code>infer_expression_types</code> back into the enclosing region that account for the fact that we might need to integrate multiple inferences.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-19 20:12</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
Formatter (stable)
<p>✅ ecosystem check detected no format changes.</p>
Formatter (preview)
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:70 on 2025-03-19 20:25</div>
            <div class="timeline-body"><p>This is moot now that I&#x27;m doing value form XOR type form</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:70 on 2025-03-19 20:26</div>
            <div class="timeline-body"><p>This is moot with the new represenation, where you have to provide a callback to infer each argument type when constructing a <code>CallArgumentTypes</code>.  You now either (a) have all argument types uninferred, in which case you have a <code>CallArguments</code>, or (b) have inferred all argument types, in which case you have a <code>CallArgumentTypes</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:74 on 2025-03-19 20:29</div>
            <div class="timeline-body"><blockquote>
<p>My more pressing (and mundane) concern was that <code>store_expression_type</code> currently panics if you try to store a type for an expression more than once.</p>
</blockquote>
<p>In working on a test case, I realized that this is an issue already, even without inferring argument types separately for each signature — if you were to use an argument as both a value and a type, we would infer its expression twice, and end up trying to store a type for that expression twice.</p>
<p>So for now I&#x27;ve changed this PR to say that an argument must be used <strong>either</strong> as a value or as a type form for all of the signatures in any particular call site.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:20 on 2025-03-19 20:29</div>
            <div class="timeline-body"><p>Done (now with <code>VecDeque</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:32 on 2025-03-19 20:30</div>
            <div class="timeline-body"><p>This no longer panics with the new representation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:8 on 2025-03-19 20:30</div>
            <div class="timeline-body"><p>We don&#x27;t clone this anymore, we use the <code>push_self</code>/<code>pop_self</code> methods to modify a single one in place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:159 on 2025-03-19 20:31</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:493 on 2025-03-19 20:32</div>
            <div class="timeline-body"><p>This can no longer panic, and we no longer clone.  Instead we <code>push_front</code> onto the <code>VecDeque</code> and <code>pop_front</code> before returning</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:471 on 2025-03-19 20:33</div>
            <div class="timeline-body"><p>Nope! Removed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:642 on 2025-03-19 20:34</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:15 on 2025-03-19 20:34</div>
            <div class="timeline-body"><p>The extra lifetime went away with the new representation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1704 on 2025-03-19 20:39</div>
            <div class="timeline-body"><p>There are a lot of cases like this where we make a call &quot;internally&quot;.  Here we&#x27;re not really <em>inferring</em> the types of the arguments; they&#x27;re provided directly.  This is also handled nicely with the new representation: you construct <code>CallArgumentTypes</code>, since you have argument types ready to specify.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-19 20:44</div>
            <div class="timeline-body"><p>Okay, I&#x27;ve pushed up a new representation that I think is nicer, and addresses most of the concerns.</p>
<p>In summary:</p>
<p><code>CallArguments</code> goes back to being a simple list of <code>Argument</code>s, which look exactly like they did before. This does not store argument types.</p>
<p>Once you are ready to perform type inference on an argument list, you transform the <code>CallArguments</code> into a <code>CallArgumentTypes</code>. You provide a callback to infer each argument type. That makes it impossible to have incomplete partially inferred state.</p>
<p>This also makes it clearer which information each phase requires, since <code>match_parameters</code> takes in a <code>CallArguments</code>, and <code>check_types</code> takes in a <code>CallArgumentTypes</code>.</p>
<p>We don&#x27;t store <code>CallArguments</code> in any of the bindings types anymore, which means we don&#x27;t need to make them cheap to clone, and we don&#x27;t need any interior mutability tricks to let the type inference code update shared state.</p>
<p>To handle bound <code>self</code>/<code>cls</code> parameters, we now use <code>VecDeque</code> instead of <code>Vec</code> for both <code>CallArguments</code> and <code>CallArgumentTypes</code>.  That lets us cheaply push the bound parameter onto the front of the argument list when needed, and pop it back off when we&#x27;re done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-19 20:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:19 on 2025-03-20 07:27</div>
            <div class="timeline-body"><p>Do we need an assertion that the front attribute is <code>Synthetic</code> to avoid cases where someone calls <code>pop_self</code> without having called <code>push_self</code> before?</p>
<p>Or should we use an <code>Option</code> for the <code>self</code> argument (I don&#x27;t know if that&#x27;s the approach that you had initially), as it seems that we never need to return a slice (which wouldn&#x27;t work with <code>VecDeque</code> anyway) and we only ever need to mutate the first element.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:60 on 2025-03-20 07:28</div>
            <div class="timeline-body"><pre><code>        let arguments = CallArguments::default();
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-03-20 07:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:704 on 2025-03-20 10:13</div>
            <div class="timeline-body"><p>Does the field documentation need to be updated to reflect that change of using <code>None</code> instead of <code>usize::MAX</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-03-20 10:23</div>
            <div class="timeline-body"><p>I haven&#x27;t done a thorough review, I&#x27;m mainly looking at the PR to keep up with the changes happening on main. I think the changes looks good, will defer it to Carl/Micha for the final review.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:704 on 2025-03-20 13:26</div>
            <div class="timeline-body"><p>It sure does! Thanks, good catch</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/arguments.rs</code>:19 on 2025-03-20 13:27</div>
            <div class="timeline-body"><p>I changed this to a <code>with_self</code> method that does the pushing/popping in the right pattern, instead of adding assertions or more complex types to ensure the caller does the right thing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-20 13:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:43 on 2025-03-21 00:22</div>
            <div class="timeline-body"><p>This TODO may not be accurate, given our conversation today? Totally up to you how you want to handle this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-03-21 00:25</div>
            <div class="timeline-body"><p>Love this. Love the Parameter fluent builder, love the new type-safe distinction between <code>CallArguments</code> and <code>CallArgumentTypes</code>. Fantastic!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-21 13:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/call/bind.rs</code>:43 on 2025-03-21 13:19</div>
            <div class="timeline-body"><p>Removed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-21 13:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-21 13:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-21 13:38</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:12:05 UTC
    </footer>
</body>
</html>
