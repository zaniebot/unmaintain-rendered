<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`pyupgrade`] Prevent infinite loop with `I002` (`UP010`, `UP035`) - astral-sh/ruff #19413</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>pyupgrade</code>] Prevent infinite loop with <code>I002</code> (<code>UP010</code>, <code>UP035</code>)</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19413">#19413</a>
        opened by <a href="https://github.com/danparizher">@danparizher</a>
        on 2025-07-17 21:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/danparizher">@danparizher</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Fixes #18729 and fixes #16802</p>
<h2>Test Plan</h2>
<p>Manually verified via CLI that Ruff no longer enters an infinite loop by running:</p>
<pre><code class="language-sh">echo 1 | ruff --isolated check - --select I002,UP010 --fix
</code></pre>
<p>with <code>required-imports = [&quot;from __future__ import generator_stop&quot;]</code> set in the config, confirming ‚ÄúAll checks passed!‚Äù and no snapshots were generated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-17 21:18</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ntBre by @ntBre on 2025-07-24 13:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @ntBre on 2025-07-25 22:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_future_import.rs</code>:129 on 2025-07-28 18:44</div>
            <div class="timeline-body"><p>This looks like a nice potential helper function. Refactoring it like that would both allow us to reuse some code here with an early return and share this with UP035, which I think could use the same fix (https://github.com/astral-sh/ruff/issues/16802). I'd suggest something like:</p>
<pre><code class="language-rust">fn helper_function(/* ... */) -&gt; bool {
  let name_import = match stmt {
              ruff_python_ast::Stmt::ImportFrom(ruff_python_ast::StmtImportFrom {
                  module,
                  level,
                  ..
              }) =&gt; {
                  NameImport::ImportFrom(MemberNameImport {
                      module: module.as_ref().map(std::string::ToString::to_string),
                      name: ruff_python_semantic::Alias {
                          name: alias.name.to_string(),
                          as_name: None,
                      },
                      level: *level,
                  })
              }
              ruff_python_ast::Stmt::Import(_) =&gt; {
                  NameImport::Import(ModuleNameImport {
                      name: ruff_python_semantic::Alias {
                          name: alias.name.to_string(),
                          as_name: None,
                      },
                  })

              }
              _ =&gt; return false,
          };
                  checker
                      .settings()
                      .isort
                      .required_imports
                      .contains(&amp;name_import)
}
</code></pre>
<p>modulo the horrific formatting from me editing this on GitHub and with a real function name and arguments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-07-28 18:46</div>
            <div class="timeline-body"><p>Thanks! I had one suggestion to refactor the fix here, and we should also add a test. Since the fix is on the UP010 side, I think it would make sense to add a unit test in the <code>pyupgrade</code> module too. You should be able to select both rules and use the normal snapshot infrastructure otherwise.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danparizher">@danparizher</a> on 2025-07-28 23:39</div>
            <div class="timeline-body"><p>Thanks, I extracted that as a function and also added a check into <code>crates\ruff_linter\src\rules\pyupgrade\rules\deprecated_import.rs</code>. Let me know if that's correct. For adding tests for the whole <code>pyupgrade</code> module, what would that look like? Would appreciate recommendations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/unnecessary_future_import.rs</code>:88 on 2025-07-29 17:56</div>
            <div class="timeline-body"><p>I think we could pass a <code>StmtRef</code> here and avoid the clone in UP035.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-07-29 18:18</div>
            <div class="timeline-body"><p>I found one new suggestion for the implementation, but this looks good otherwise.</p>
<p>For the test, I wrote up this patch:</p>
<details><summary>Patch</summary>

<pre><code class="language-diff">diff --git a/crates/ruff_linter/src/rules/pyupgrade/mod.rs b/crates/ruff_linter/src/rules/pyupgrade/mod.rs
index 3f64cb323f..919958e48e 100644
--- a/crates/ruff_linter/src/rules/pyupgrade/mod.rs
+++ b/crates/ruff_linter/src/rules/pyupgrade/mod.rs
@@ -7,16 +7,18 @@ pub(crate) mod types;
 
 #[cfg(test)]
 mod tests {
+    use std::collections::BTreeSet;
     use std::path::Path;
 
     use anyhow::Result;
     use ruff_python_ast::PythonVersion;
+    use ruff_python_semantic::{MemberNameImport, NameImport};
     use test_case::test_case;
 
     use crate::registry::Rule;
-    use crate::rules::pyupgrade;
+    use crate::rules::{isort, pyupgrade};
     use crate::settings::types::PreviewMode;
-    use crate::test::test_path;
+    use crate::test::{test_path, test_snippet};
     use crate::{assert_diagnostics, settings};
 
     #[test_case(Rule::ConvertNamedTupleFunctionalToClass, Path::new(&quot;UP014.py&quot;))]
@@ -294,4 +296,44 @@ mod tests {
         assert_diagnostics!(diagnostics);
         Ok(())
     }
+
+    #[test]
+    fn i002_conflict() {
+        let diagnostics = test_snippet(
+            &quot;1&quot;,
+            &amp;settings::LinterSettings {
+                isort: isort::settings::Settings {
+                    required_imports: BTreeSet::from_iter([
+                        // https://github.com/astral-sh/ruff/issues/18729
+                        NameImport::ImportFrom(MemberNameImport::member(
+                            &quot;__future__&quot;.to_string(),
+                            &quot;generator_stop&quot;.to_string(),
+                        )),
+                        // https://github.com/astral-sh/ruff/issues/16802
+                        NameImport::ImportFrom(MemberNameImport::member(
+                            &quot;collections&quot;.to_string(),
+                            &quot;Sequence&quot;.to_string(),
+                        )),
+                    ]),
+                    ..Default::default()
+                },
+                ..settings::LinterSettings::for_rules([
+                    Rule::MissingRequiredImport,
+                    Rule::UnnecessaryFutureImport,
+                    Rule::DeprecatedImport,
+                ])
+            },
+        );
+        assert_diagnostics!(diagnostics, @r&quot;
+        &lt;filename&gt;:1:1: I002 [*] Missing required import: `from __future__ import generator_stop`
+        ‚Ñπ Safe fix
+          1 |+from __future__ import generator_stop
+        1 2 | 1
+
+        &lt;filename&gt;:1:1: I002 [*] Missing required import: `from collections import Sequence`
+        ‚Ñπ Safe fix
+          1 |+from collections import Sequence
+        1 2 | 1
+        &quot;);
+    }
 }
diff --git a/crates/ruff_linter/src/test.rs b/crates/ruff_linter/src/test.rs
index cf63762b8a..02eca4ca05 100644
--- a/crates/ruff_linter/src/test.rs
+++ b/crates/ruff_linter/src/test.rs
@@ -380,7 +380,7 @@ macro_rules! assert_diagnostics {
     }};
     ($value:expr, @$snapshot:literal) =&gt; {{
         insta::with_settings!({ omit_expression =&gt; true }, {
-            insta::assert_snapshot!($crate::test::print_messages(&amp;$value), $snapshot);
+            insta::assert_snapshot!($crate::test::print_messages(&amp;$value), @$snapshot);
         });
     }};
     ($name:expr, $value:expr) =&gt; {{
</code></pre>
</details>

<p>I guess nobody had ever tried to use the inline snapshot version of <code>assert_diagnostics!</code> because the <code>@</code> wasn't being passed along.</p>
<p>This test fails on <code>main</code> with the expected failure to converge, but with your fixes it yields the expected snapshot. We fix the I002 issues and don't raise UP010 or UP035. Nice work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ntBre by @danparizher on 2025-07-30 15:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Prevent infinite fix loop between I002 and UP010 when required import is also unnecessary" to "[`pyupgrade`] Prevent infinite loop with I002 (`UP010`, `UP035`)" by @ntBre on 2025-07-30 20:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[`pyupgrade`] Prevent infinite loop with I002 (`UP010`, `UP035`)" to "[`pyupgrade`] Prevent infinite loop with `I002` (`UP010`, `UP035`)" by @ntBre on 2025-07-30 20:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-07-30 21:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_import.rs</code>:723 on 2025-07-30 21:02</div>
            <div class="timeline-body"><p>I'm not totally sure, but this feels like it could be overly restrictive. This should be equivalent to:</p>
<pre><code class="language-rust">    if import_from_stmt.names.iter().any(|alias| {
        is_import_required_by_isort(checker, StmtRef::ImportFrom(import_from_stmt), alias)
    }) {
        return;
    }
</code></pre>
<p>and I'm wondering if <code>all</code> might be the better condition than <code>any</code>. In terms of a test case, I tried this:</p>
<pre><code class="language-rust">    #[test]
    fn i002_conflict() {
        let diagnostics = test_snippet(
            &quot;from pipes import quote, Template&quot;,
            &amp;settings::LinterSettings {
                isort: isort::settings::Settings {
                    required_imports: BTreeSet::from_iter([
                        // https://github.com/astral-sh/ruff/issues/18729
                        NameImport::ImportFrom(MemberNameImport::member(
                            &quot;__future__&quot;.to_string(),
                            &quot;generator_stop&quot;.to_string(),
                        )),
                        // https://github.com/astral-sh/ruff/issues/16802
                        NameImport::ImportFrom(MemberNameImport::member(
                            &quot;collections&quot;.to_string(),
                            &quot;Sequence&quot;.to_string(),
                        )),
                        // Only bail out if _all_ the names in UP035 are required. `pipes.Template`
                        // isn't flagged by UP035, so requiring it shouldn't prevent `pipes.quote`
                        // from getting a diagnostic.
                        NameImport::ImportFrom(MemberNameImport::member(
                            &quot;pipes&quot;.to_string(),
                            &quot;Template&quot;.to_string(),
                        )),
                    ]),
                    ..Default::default()
                },
                ..settings::LinterSettings::for_rules([
                    Rule::MissingRequiredImport,
                    Rule::UnnecessaryFutureImport,
                    Rule::DeprecatedImport,
                ])
            },
        );
        assert_diagnostics!(diagnostics, @r&quot;
        &lt;filename&gt;:1:1: UP035 [*] Import from `shlex` instead: `quote`
          |
        1 | from pipes import quote, Template
          | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ UP035
          |
          = help: Import from `shlex`

        ‚Ñπ Safe fix
        1   |-from pipes import quote, Template
          1 |+from pipes import Template
          2 |+from shlex import quote

        &lt;filename&gt;:1:1: I002 [*] Missing required import: `from __future__ import generator_stop`
        ‚Ñπ Safe fix
          1 |+from __future__ import generator_stop
        1 2 | from pipes import quote, Template

        &lt;filename&gt;:1:1: I002 [*] Missing required import: `from collections import Sequence`
        ‚Ñπ Safe fix
          1 |+from collections import Sequence
        1 2 | from pipes import quote, Template
        &quot;);
    }
</code></pre>
<p>after switching to <code>all</code>. I think it makes sense to flag <code>quote</code> even if <code>Template</code> is required. What do  you think?</p>
<p>I think that's consistent with the <code>continue</code> instead of <code>return</code> in UP010.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-07-30 21:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_import.rs</code>:723 on 2025-07-30 21:04</div>
            <div class="timeline-body"><p>Actually, this may just not be the right place to inject the check. Somewhere in here we should actually inspect the <code>alias</code> being replaced. That might be the more natural place to check <code>is_import_required_by_isort</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/danparizher">@danparizher</a> reviewed on 2025-07-31 00:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/danparizher">@danparizher</a> on <code>crates/ruff_linter/src/rules/pyupgrade/rules/deprecated_import.rs</code>:723 on 2025-07-31 00:01</div>
            <div class="timeline-body"><p>I think the <code>continue</code> approach makes the most sense. I envision collecting skipped aliases and filtering them out during processing. Feel free to iterate on the commit how you see fit. üôÇ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-07-31 18:43</div>
            <div class="timeline-body"><p>I pushed a few changes:</p>
<ul>
<li>Stored the required imports on <code>ImportReplacer</code> instead of a <code>HashSet</code> so we can avoid allocating that up front</li>
<li>Pushed to <code>unmatched_names</code> instead of continuing in <code>partition_imports</code> (this was causing the <code>from pipes import Template</code> import to be dropped when removing the <code>quote</code> import)</li>
<li>Combined <code>i002_conflict</code> and <code>up035_partial_required_import</code>, that's what I had in mind initially. I don't think we need both tests separately</li>
<li>Tried to simplify <code>is_import_required_by_isort</code> a bit</li>
</ul>
<p>I'm not sure if the simplification actually paid off. It seems nice not to allocate strings for the <code>NameImport</code>s, but now we have to call <code>qualified_name</code> repeatedly in the <code>any</code> check. Your version wasn't showing any performance regression, so if this regresses performance at all, I'll just put it back.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @ntBre on 2025-07-31 19:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ntBre on 2025-07-31 19:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-31 20:44</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:14:21 UTC
    </footer>
</body>
</html>
