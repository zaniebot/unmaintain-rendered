<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Decompose `bool` to `Literal[True, False]` in unions and intersections - astral-sh/ruff #15738</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Decompose <code>bool</code> to <code>Literal[True, False]</code> in unions and intersections</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15738">#15738</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-01-25 13:10
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Our union builder currently has a problem due to a bad interaction of several features we've implemented:</p>
<ul>
<li>The union builder understands that <code>bool â‰¡ Literal[True, False]</code> (and therefore that for any <code>T</code>, <code>bool | T â‰¡ Literal[True, False] | T</code>; therefore, whenever it sees <code>Literal[True, False]</code> in a union, it eagerly simplifies this union to the simpler type <code>bool</code>.</li>
<li>The union builder also understands that adding <code>U</code> to the union <code>S | T</code> is a no-op if <code>U</code> is a subtype of either <code>S</code> or <code>T</code></li>
<li>The union builder understands that <code>Literal[True]</code> is a subtype of <code>AlwaysTruthy</code> and <code>~AlwaysFalsy</code></li>
<li>The union builder understands that <code>Literal[Falsy]</code> is a subtype of <code>AlwaysFalsy</code> and <code>~AlwaysTruthy</code></li>
<li>The union builder understands that <code>bool</code> is neither a subtype of <code>AlwaysTruthy</code> nor a subtype of <code>AlwaysFalsy</code></li>
</ul>
<p>Putting all these features together means that the union builder can produce different unions depending on the order in which elements are inserted into the union. Consider a union consisting of <code>Literal[True]</code>, <code>Literal[False]</code> and <code>AlwaysTruthy</code>. If they're inserted in that order, then the unions is built like this:</p>
<pre><code>(1) `Literal[True]`
(2) add `Literal[False]` to the union:
    -&gt; `Literal[True] | Literal[False]`
    -&gt; eagerly simplified to `bool`
(3) add `AlwaysTruthy` to the union:
    -&gt; `bool | AlwaysTruthy`

Final union: `bool | AlwaysTruthy`
</code></pre>
<p>But if they're inserted in a slightly different order, a different union is constructed entirely, which red-knot is not capable of understanding to be equivalent to the one above:</p>
<pre><code>(1) `Literal[False]
(2) add `AlwaysTruthy` to the union
    -&gt; `Literal[False] | AlwaysTruthy`
(3) add `Literal[True]` to the union
    -&gt; still `Literal[False] | AlwaysTruthy`
       (new addition is ignored since it is a subtype
       of pre-existing element `AlwaysTruthy)

Final union: `Literal[False] | AlwaysTruthy`
</code></pre>
<p>There are the following set of equivalent type pairs that can currently be constructed under our current model but are not understood to be equivalent by red-knot:</p>
<ul>
<li><code>AlwaysTruthy | bool â‰¡ AlwaysTruthy | Literal[False]</code></li>
<li><code>AlwaysFalsy | bool â‰¡ AlwaysFalsy | Literal[True]</code></li>
<li><code>~AlwaysTruthy | bool â‰¡ ~AlwaysTruthy | Literal[True]</code></li>
<li><code>~AlwaysFalsy | bool â‰¡ ~AlwaysFalsy | Literal[False]</code></li>
</ul>
<p>This PR refactors the union builder to ensure that unions are <em>never</em> constructed that contain <code>bool</code> as an element; instead, <code>bool</code> is always decomposed to <code>Literal[True, False]</code>. The same is done for our intersection builder. Doing this makes it much easier to ensure that unions such as the ones above always have the same set of elements no matter which order they are inserted into the union; a lot of complexity is removed from <code>builder.rs</code> in this PR. However, it has the (significant) drawback that in various type-relational methods such as <code>Type::is_equivalent_to()</code>, <code>Type::is_subtype_of()</code> and <code>Type::is_assignable_to()</code>, we have to remember to normalize <code>bool</code> into <code>Literal[True, False]</code> before comparing the type with any other type, since the other type might be a union, and we must ensure that <code>Literal[True, False]</code> is understood to be equivalent to <code>bool</code>.</p>
<p>Since it would be confusing for users if <code>bool</code> was displayed as <code>Literal[True, False]</code>, some logic is added to <code>Type::display</code> so that <code>Literal[True, False]</code> is replaced with <code>bool</code> in unions before unions are printed to the terminal in diagnostics.</p>
<p>This PR fixes https://github.com/astral-sh/ty/issues/216, and allows us to promote two flaky property tests to stable. However, it currently shows up as having a 1% performance regression on both red-knot benchmarks on codspeed: https://codspeed.io/astral-sh/ruff/branches/alex%2Ftruthy-unions-5.</p>
<h2>What about literal strings?</h2>
<p>As well as the above invariants for unions containing <code>AlwaysTruthy/AlwaysFalsy</code> and <code>bool</code>, there are also equivalences for <code>LiteralString</code> that we do not yet understand. The fact that we do not understand these is at least partly responsible for the flakiness of several other property tests that are not marked as stable:</p>
<ul>
<li><code>AlwaysTruthy | LiteralString â‰¡ AlwaysTruthy | Literal[&quot;&quot;]</code></li>
<li><code>AlwaysFalsy | LiteralString â‰¡ AlwaysFalsy | LiteralString &amp; ~Literal[&quot;&quot;]</code></li>
<li><code>~AlwaysTruthy | LiteralString â‰¡ ~AlwaysTruthy | Literal[&quot;&quot;]</code></li>
<li><code>~AlwaysFalsy | LiteralString â‰¡ ~AlwaysFalsy | LiteralString &amp; ~Literal[&quot;&quot;]</code></li>
</ul>
<p>I'm not sure if this problem is solvable in the same way without adding a new <code>Type::TruthyLiteralString</code> variant. Anyway, this PR does not attempt to solve this problem. Instead, some failing tests are added with a TODO.</p>
<h2>Test Plan</h2>
<ul>
<li>New mdtests added that fail on <code>main</code></li>
<li><code>QUICKCHECK_TESTS=1000000 cargo test --release -p red_knot_python_semantic -- --ignored types::property_tests::stable</code></li>
<li><code>QUICKCHECK_TESTS=5000000 cargo test --release -p red_knot_python_semantic -- --ignored types::property_tests::stable::union_equivalence_not_order_dependent</code></li>
<li><code>QUICKCHECK_TESTS=3000000 cargo test --release -p red_knot_python_semantic -- --ignored types::property_tests::stable::intersection_equivalence_not_order_dependent</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-01-25 13:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-25 13:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:4674 on 2025-01-25 13:13</div>
            <div class="timeline-body"><p>hmm, this doesn't yet handle unions inside tuples inside tuples...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-25 16:00</div>
            <div class="timeline-body"><p>There's actually two distinct changes here; I'll split this PR into two</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2025-01-25 17:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-01-25 17:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2025-01-25 17:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-01-25 17:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-25 17:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/exception/control_flow.md</code>:458 on 2025-01-25 17:23</div>
            <div class="timeline-body"><p>The order here changes because I'm using <code>swap_remove</code> in <code>Type::display</code> to ensure that <code>Literal[True, False]</code> is displayed as <code>bool</code> to users. But maybe it's okay to use <code>remove()</code> in <code>Type::display()</code> rather than <code>swap_remove</code>? <code>remove()</code> is <code>O(n)</code> rather than <code>O(1)</code>, but displaying a type shouldn't really be performance-sensitive: it's usually only done as part of printing a diagnostic to the terminal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-25 17:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/comparison/tuples.md</code>:76 on 2025-01-25 17:25</div>
            <div class="timeline-body"><p>I changed this because it doesn't look like we've implemented comparisons between unions inside tuples yet, and <code>bool</code> is now internally represented as a union, which meant that many <code>reveal_type</code> assertions in this test became TODOs rather than <code>bool</code>s. Testing whether we knew how to compare a <code>bool</code> with a <code>bool</code> didn't seem to me to be the point of the test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:995 on 2025-01-25 17:26</div>
            <div class="timeline-body"><p>I had a stack overflow for a looong time here before I realised I had to change this... was tearing my hair out ðŸ™ƒ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-25 17:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-26 10:18</div>
            <div class="timeline-body"><blockquote>
<p>it has the (significant) drawback that in various type-relational methods such as <code>Type::is_equivalent_to()</code>, <code>Type::is_subtype_of()</code> and <code>Type::is_assignable_to()</code>, we have to remember to normalize <code>bool</code> into <code>Literal[True, False]</code> before comparing the type with any other type, since the other type might be a union, and we must ensure that <code>Literal[True, False]</code> is understood to be equivalent to <code>bool</code>.</p>
</blockquote>
<p>One solution to this might be to add a <code>NormalizedType</code> newtype, which you <em>have</em> to convert a <code>Type</code> into before you can use any of these methods. Then we wouldn't have to remember to normalize types inside these methods (or inside the union and intersection builders!) -- we would know that the type was already normalized due to a <code>NormalizedType</code> instance being passed rather than a <code>Type</code>.</p>
<pre><code class="language-rs">#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct NormalizedType&lt;'db&gt;(Type&lt;'db&gt;);

impl&lt;'db&gt; NormalizedType&lt;'db&gt; {
    /// Return true if this type is a [subtype of] type `target`.
    pub(crate) fn is_subtype_of(self, db: &amp;'db dyn Db, target: Self) -&gt; bool {}

    /// Return true if this type is [assignable to] type `target`.
    pub(crate) fn is_assignable_to(self, db: &amp;'db dyn Db, target: Self) -&gt; bool {}

    /// Return true if this type is [equivalent to] type `other`.
    pub(crate) fn is_equivalent_to(self, db: &amp;'db dyn Db, other: Self) -&gt; bool {}

    /// Returns true if this type and `other` are gradual equivalent.
    pub(crate) fn is_gradual_equivalent_to(self, db: &amp;'db dyn Db, other: Self) -&gt; bool {}

    /// Return true if this type and `other` have no common elements.
    pub(crate) fn is_disjoint_from(self, db: &amp;'db dyn Db, other: Self) -&gt; bool {}
}

impl&lt;'db&gt; Deref for NormalizedType&lt;'db&gt; {
    type Target = Type&lt;'db&gt;;

    fn deref(&amp;self) -&gt; &amp;Self::Target {
        &amp;self.0
    }
}

impl&lt;'db&gt; From&lt;NormalizedType&lt;'db&gt;&gt; for Type&lt;'db&gt; {
    fn from(value: NormalizedType&lt;'db&gt;) -&gt; Self {
        value.0
    }
}
</code></pre>
<p>This is quite attractive in some ways. It would be a very big change to make, though, and it would make our API more awkward to use in several places. I'm not sure it would be worth it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-27 08:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:995 on 2025-01-27 08:07</div>
            <div class="timeline-body"><p>Can you say more why this is necessary? And maybe add a comment (unless I'm missing something obvious)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-27 11:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:995 on 2025-01-27 11:02</div>
            <div class="timeline-body"><p>The first step in <code>Type::is_subtype_of()</code> is now (with this PR) to normalize <code>bool</code> to <code>Literal[True] | Literal[False]</code> for both <code>self</code> and <code>target</code>. So if <code>self</code> is <code>bool</code>, <code>self.is_subtype_of(target)</code> delegates to whether <code>Literal[True] | Literal[False]</code> is a subtype of <code>target</code>.  That takes us to the <code>Type::Union</code> branch: a union type is a subtype of <code>target</code> iff all its members are a subtype of <code>target</code>. So then we try the first member of the union <code>Literal[True] | Literal[False]</code>, and ask the question: &quot;Is <code>Literal[True]</code> a subtype of <code>target</code>? If <code>target</code> is not equivalent to <code>Literal[True]</code>, that takes us to this branch, and this branch says &quot;<code>Literal[True]</code> is a subtype of <code>target</code> iff <code>bool</code> is a subtype of <code>target</code>&quot;. So then we ask the question &quot;Is <code>bool</code> a subtype of <code>target</code>?&quot;, which is the very first question we started off with. And <code>bool</code> is normalized to <code>Literal[True] | Literal[False]</code>... the cycle repeats indefinitely, resulting in infinite recursion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-27 11:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:995 on 2025-01-27 11:21</div>
            <div class="timeline-body"><p>Thanks!</p>
<p>I still don't understand why it's correct though? There are types which are supertypes of <code>bool</code>, but not of <code>int</code>. <code>bool | None</code> or <code>~Literal[2]</code>, for example. So why is it correct to replace the <code>bool &lt;: target</code> check with a <code>int &lt;: target</code> check? Because all special cases have been handled above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-27 11:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:995 on 2025-01-27 11:54</div>
            <div class="timeline-body"><blockquote>
<p>I still don't understand why it's correct though?</p>
</blockquote>
<p>It might not be -- I <em>have</em> been known to make mistakes ðŸ˜œ</p>
<blockquote>
<p>There are types which are supertypes of <code>bool</code>, but not of <code>int</code>. <code>bool | None</code> or <code>~Literal[2]</code>, for example. So why is it correct to replace the <code>bool &lt;: target</code> check with a <code>int &lt;: target</code> check? Because all special cases have been handled above?</p>
</blockquote>
<p>Yeah, I <em>think</em> our set-theoretic types such as unions and intersections should be handled in the branches above? I just added more test cases demonstrating this.</p>
<p>(I <em>will</em> add a comment to the code reflecting this conversation, but first I'm experimenting with alternative ways of structuring the code that might make this clearer in the first place!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-27 18:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:995 on 2025-01-27 18:25</div>
            <div class="timeline-body"><p>(https://github.com/astral-sh/ruff/pull/15773 is the &quot;alternative way of structuring the code&quot;, for anybody else reading this thread)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-28 00:48</div>
            <div class="timeline-body"><p>I think I suggested normalizing <code>bool</code> to <code>Literal[True, False]</code>, and I appreciate you exploring what that would look like! But having seen what it would look like, it doesn't feel to me like the right direction.</p>
<p>The cases where this simplification applies are very narrow: unions of <code>bool</code> (or an enum, in future -- I'm going to call these sealed types) with a larger type that only partially overlaps with <code>bool</code> (or the enum). Since <code>bool</code> and enums are both very narrow types, with a small/fixed set of singleton inhabitants, there are very few larger types that will partially overlap. Some types (<code>int</code> or <code>object</code>) will fully overlap (they are super-types), but I think in fact <code>AlwaysTruthy</code> and <code>AlwaysFalsy</code> are the only partially overlapping types?</p>
<p>So while decomposing is attractive in its conceptual simplicity (and in its code simplicity!), it means lots of operations on bools in unions become more expensive, because we have to check against two types instead of one (and this will be even worse with enums, possibly making the approach not even workable for them at all.) And then in the effort to limit some of that inefficiency (by decomposing only in unions/intersections), we lose a fair bit of the conceptual and code simplicity. So we are kind of letting the tail wag the dog, by paying extra perf cost for all uses of <code>bool</code> intersections, in order to support the less-common case where <code>Always{Truthy,Falsy}</code> is also in that union.</p>
<p>I think we do want to normalize these cases (by which I mean, where a sealed type partially overlaps with another type in a union) such that we decompose the sealed type and eliminate the overlap (that is, <code>AlwaysFalse | Literal[True]</code> instead of <code>AlwaysFalse | bool</code>). This seems better than trying to encode the equivalence in <code>is_equivalent_to</code>.</p>
<p>But given that the cases where this applies are so narrow, and we already compare every new union element to every existing union element, I think we can do this as (yet another) special case in <code>UnionBuilder</code>, and that will perform better than always decomposing.</p>
<p>The rule would be that whenever we see <code>bool</code> in a union with a type that it is not disjoint from but also not a subtype of (I phrase it in this general way so that we also handle intersections containing <code>Always{Truthy,False}</code> being in a union with <code>bool</code>), we replace <code>bool</code> in that union with its literal inhabitant that is disjoint from the other type.</p>
<p>WDYT?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-01-28 11:19</div>
            <div class="timeline-body"><blockquote>
<p>WDYT?</p>
</blockquote>
<p>I think this could work! I tried something like what you outline above initially, and struggled to get it to work, but I think at that stage I still didn't understand the full extent of the problem here. Revisiting it might yield different results now that I am Older and Wiser.</p>
<blockquote>
<p>I think we do want to normalize these cases (by which I mean, where a sealed type partially overlaps with another type in a union) such that we decompose the sealed type and eliminate the overlap (that is, <code>AlwaysFalse | Literal[True]</code> instead of <code>AlwaysFalse | bool</code>). This seems better than trying to encode the equivalence in <code>is_equivalent_to</code>.</p>
</blockquote>
<p>I agree that we need some kind of normalization here rather than attempting some ugly (and expensive) special casing in <code>is_equivalent_to</code>. And intuitively, normalizing the union elements so that they do not overlap feels like the better way to go. But in practice, I wonder if normalizing to <code>AlwaysFalsy | bool</code> might actually be better. If we normalize to <code>AlwaysFalsy | Literal[True]</code>, we won't naturally understand <code>bool</code> as being a subtype of this type; we'd still have to decompose <code>bool</code> to <code>Literal[True, False]</code> in <code>is_subtype_of</code> and <code>is_assignable_to</code>. If we normalize to <code>AlwaysFalsy | bool</code>, however, I think it's possible that no special handling will be necessary in those methods.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-28 14:39</div>
            <div class="timeline-body"><p>I think there might be a more general problem here where we should understand the equivalence <code>P | Q = (P &amp; ~Q) | Q</code> and <code>P | Q = P | (Q &amp; ~P)</code>. We currently don't.</p>
<p>I understand that there is a desire to always find a canonical representation, but I'm afraid this might be too much to ask for in a set-theoretic type system? Enforcing non-overlapping union elements can be achieved, but there are many ways to do that â€” the two variants <code>(P &amp; ~Q) | Q</code> and <code>P | (Q &amp; ~P)</code> are just two extreme cases where the entire overlap is either moved to the right or to the left. And if more than two types are involved, there's a combinatorial explosion of possibilities.</p>
<p>It is obviously desirable to have a &quot;simple&quot; and unique representation when we present types to users, at least in common cases. But as a general property, I'm not sure if that is achievable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-01-28 16:20</div>
            <div class="timeline-body"><blockquote>
<p>I understand that there is a desire to always find a canonical representation,</p>
</blockquote>
<p>We've had some PRs that move us in this direction, but I think this is the key question we need to answer â€” do we want <code>Type</code> to have a normal form?  (presumably DNF given its current shape)</p>
<blockquote>
<p>And if more than two types are involved, there's a combinatorial explosion of possibilities.</p>
<p>It is obviously desirable to have a &quot;simple&quot; and unique representation when we present types to users, at least in common cases. But as a general property, I'm not sure if that is achievable.</p>
</blockquote>
<p>...because if so, you would typically avoid that combinatorial explosion by ensuring that the primitives in the normal form are all disjoint.</p>
<p>In this case, it's <code>AlwaysTruthy</code> / <code>AlwaysFalsy</code> which most obviously violates that disjointness.  So they could not be primitives (i.e. variants in the <code>Type</code> enum), and would either be a property that types can have (implemented as an <code>is_always_truthy</code> method), or syntactic sugar for some type that is in normal form.  (e.g. an <code>always_falsy</code> constructor that would desugar into something like <code>Union[False, 0, &quot;&quot;, some protocol involving __bool__, ...]</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-28 16:53</div>
            <div class="timeline-body"><blockquote>
<p>...because if so, you would typically avoid that combinatorial explosion by ensuring that the primitives in the normal form are all disjoint.</p>
<p>In this case, it's <code>AlwaysTruthy</code> / <code>AlwaysFalsy</code> which most obviously violates that disjointness. So they could not be primitives (i.e. variants in the <code>Type</code> enum), and would either be a property that types can have (implemented as an <code>is_always_truthy</code> method), or syntactic sugar for some type that is in normal form. (e.g. an <code>always_falsy</code> constructor that would desugar into something like <code>Union[False, 0, &quot;&quot;, some protocol involving __bool__, ...]</code>)</p>
</blockquote>
<p>I was mostly thinking about non-primitives, such as unrelated classes</p>
<pre><code class="language-py">class C1: ...
class C2: ...
...
class Cn: ...
</code></pre>
<p>How would you bring the union <code>C1 | C2 | â€¦ | Cn</code> into some canonical form (that avoids overlaps)? We could try something like <code>C1 | C2 &amp; ~C1 | C3 &amp; ~C1 &amp; ~C2 | â€¦</code>, but that depends on insertion order and doesn't look like it would be very useful to work with(?). A symmetric version would probably involve having O(nÂ²) entries (<code>C1 &amp; ~C2 &amp; â€¦ &amp; ~Cn | ~C1 &amp; C2 &amp; ~C3 &amp; â€¦ &amp; ~Cn | â€¦ | ~C1 &amp; â€¦ &amp; ~Cn-1 &amp; Cn)</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-01-28 17:17</div>
            <div class="timeline-body"><p>Yes, (one) problem with trying to avoid all overlaps is that a typical nominal instance type (perhaps the most common type) is not disjoint from another unrelated one, thanks to subclassing and multiple inheritance. So avoiding all overlaps in unions seems impractical.</p>
<p>I agree that I'm not sure it's feasible in general to have a single normalized representation of every type. (It is important that we maintain DNF in the sense that we always normalize to a union of intersections, never a more complex tree of unions and intersections. But that doesn't necessarily imply a fully normalized form in terms of the possible combinations of elements.)</p>
<p>My suggestion above was much more narrow and targeted: that we'd avoid overlaps <em>with sealed types</em> and prefer decomposing the sealed type instead. I think this is more tractable. But Alex makes a good point that this might be the wrong direction; perhaps we should prefer the overlap and use the full sealed type whenever it is correct to do so.</p>
<blockquote>
<p>I think there might be a more general problem here where we should understand the equivalence <code>P | Q = (P &amp; ~Q) | Q</code> and <code>P | Q = P | (Q &amp; ~P)</code>. We currently don't.</p>
</blockquote>
<p>To me this looks like a case where we'd ideally prefer to achieve this understanding via an eager simplification of <code>(P &amp; ~Q) | Q</code> to <code>P | Q</code> (which again means we are preferring the overlap, not preferring to avoid the overlap.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-02-01 01:03</div>
            <div class="timeline-body"><p>I just realized from looking at the <a href="https://github.com/python/typing/pull/1839">overloads spec PR</a> that the pattern you started introducing in this PR as <code>with_normalized_bools</code> is something we will eventually need for overload matching, under the general rubric of &quot;type expansion&quot;. (See the very end of <code>overloads.rst</code> in that PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-04-28 07:09</div>
            <div class="timeline-body"><p>Just checking in. Is this something that we still plan on merging/changing in the future?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-28 07:11</div>
            <div class="timeline-body"><blockquote>
<p>Just checking in. Is this something that we still plan on merging/changing in the future?</p>
</blockquote>
<p>I've deprioritised this issue for now as it's not urgent, but it's still something we'll need to fix at some point, and I still think something like this could be a viable fix. I'd rather not close this just yet.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:09:29 UTC
    </footer>
</body>
</html>
