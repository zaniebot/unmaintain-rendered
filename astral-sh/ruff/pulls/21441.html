<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>new module for parsing ranged suppressions - astral-sh/ruff #21441</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>new module for parsing ranged suppressions</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21441">#21441</a>
        opened by <a href="https://github.com/amyreese">@amyreese</a>
        on 2025-11-14 00:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This adds a new <code>suppression</code> module to the <code>ruff_linter</code> crate, similar to the suppression
module for ty, to parse comments for ruff suppression directives, such as <code># ruff: disable[CODE]</code>.</p>
<p>This is just the piece for parsing and storing an IMR of the comments themselves. Next step
is to interpret parsed comments and map them to ranges, codes, etc that can be referenced
later when determining which diagnostics should be kept/filtered/whatever.</p>
<h2>Test Plan</h2>
<ul>
<li>A bunch of new snapshot tests</li>
<li>Added to the beginning of <code>check_path</code> so that the parsing runs on all checked files
for performance regression testing.</li>
</ul>
<p>Issue #3711</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ntBre by @amyreese on 2025-11-14 00:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @amyreese on 2025-11-14 00:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-14 01:06</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>âœ… ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>âœ… ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-14 07:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:55 on 2025-11-14 07:53</div>
            <div class="timeline-body"><p>I assume this is something that gets clearer once we have more code but it's not clear to me how a <code>Suppression</code> can have multiple comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-14 07:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:14 on 2025-11-14 07:54</div>
            <div class="timeline-body"><p>I'm leaning towards skipping <code>ignore</code> for now, given that we don't have consensus on a design yet</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-14 19:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:55 on 2025-11-14 19:06</div>
            <div class="timeline-body"><p>The idea is a <code>Suppression</code> object would cover a range of the document, but for cases like <code># ruff: disable</code> you would also need a matching <code># ruff: enable</code> to define the range of the suppression, leading to multiple comments for a single suppression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-14 19:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:14 on 2025-11-14 19:08</div>
            <div class="timeline-body"><p>Sure, was not planning on supporting it in the first implementation, but wanted to keep it in mind for designing how the system/structures should work. Equally applies to <code>noqa</code> suppressions I guess.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-14 19:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:55 on 2025-11-14 19:10</div>
            <div class="timeline-body"><p>The next step of the implementation would be looking through the list of discovered comments and start matching disable/enable comments and build a single <code>Suppression</code> object with the appropriate range, and containing references to both comments so that the future &quot;unused suppression&quot; diagnostic could easily find both comments to suggest removing them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amyreese">@amyreese</a> on 2025-11-19 01:46</div>
            <div class="timeline-body"><p>Updated with logic to match disable/enable suppression comments and transform them into ranged suppression objects. Currently just looks for matching indentation and codes, to get a simplified implementation that works, since looking at tokens is complicated by where dedent tokens appear relative to own-line comments at the end of blocks (<a href="https://play.ruff.rs/3f5950bf-c969-4519-a207-1304b22d1c78">playground example</a>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-19 07:28</div>
            <div class="timeline-body"><blockquote>
<p>Updated with logic to match disable/enable suppression comments and transform them into ranged suppression objects. Currently just looks for matching indentation and codes, to get a simplified implementation that works, since looking at tokens is complicated by where dedent tokens appear relative to own-line comments at the end of blocks (<a href="https://play.ruff.rs/3f5950bf-c969-4519-a207-1304b22d1c78">playground example</a>).</p>
</blockquote>
<p>Yeah, I think we have to &quot;ignore&quot; <code>Dedent</code>s if all that comes between the comment token and the <code>Dedent</code> token are trivia tokens (newline, comment,)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amyreese">@amyreese</a> on 2025-11-19 16:49</div>
            <div class="timeline-body"><blockquote>
<p>Yeah, I think we have to &quot;ignore&quot; <code>Dedent</code>s if all that comes between the comment token and the <code>Dedent</code> token are trivia tokens (newline, comment,)</p>
</blockquote>
<p>Plus we still need to do indentation checking to make a reasonable guess as to which scope the comment should be associated:</p>
<pre><code class="language-py">def foo():
    if True:
        pass
        # here?
    # here?
# or here?
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-21 07:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:153 on 2025-11-21 07:24</div>
            <div class="timeline-body"><p>Could we use the <code>indent_level</code> here rather than match on the exact indent (in which case a simple <code>usize</code> counter could replace our current stack?</p>
<p>Python also supports mixed space-tab indents and I never remember the exact details, but using levels over the indent-string ensures that you delegate all this to the lexer/parser.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-21 07:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:150 on 2025-11-21 07:25</div>
            <div class="timeline-body"><p>Mathing on <code>token</code> here seems weird as it isn't an enum? I think what you want to do here is to match on <code>token.kind()</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-21 16:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:150 on 2025-11-21 16:53</div>
            <div class="timeline-body"><p>Yes</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-21 16:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:153 on 2025-11-21 16:53</div>
            <div class="timeline-body"><p>I think the problem is that if you only have an &quot;indent level&quot;, then you can't easily match a comment to an indentation level, because indentation levels in Python can be arbitrary. This comes back to needing to determine which level a comment belongs to when it appears before a Dedent token, and I'm not aware of a way to do that other than comparing full indentation strings.  If there are helpers in ruff that can infer an indentation level to a comment, I would love to know.</p>
<blockquote>
<p>Python also supports mixed space-tab indents and I never remember the exact details</p>
</blockquote>
<p>FWIW, Python does not allow mixing spaces and tabs within an indented block of code. Eg, this will produce either an <code>IndentationError</code> or a <code>TabError</code> at runtime, depending on how many spaces are used:</p>
<pre><code>def foo():
&lt;tab&gt;pass
&lt;spaces&gt;pass
</code></pre>
<p>With modern editors and formatters, I would be surprised if mixed indents were still a problem, at least for someone at the point of using Ruff to check their code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-21 17:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:153 on 2025-11-21 17:09</div>
            <div class="timeline-body"><p>Oh, so this is for comments at the end of a block like this:</p>
<pre><code class="language-py">def test():
	# ruff: disable[code]
	if True:
		pass
	# ruff: enable[code] - re-enables the outer and not the inner matching ignore
</code></pre>
<p>vs</p>
<pre><code class="language-py">
def test():
	if True:
		# ruff: disable[code]
		pass
		# ruff: enable[code] - re-enables the inner matching ignore
</code></pre>
<p>Agree, using string comparison for those is probably fine and also what we do in the formatter https://github.com/astral-sh/ruff/blob/f69f278bf12d67e17bd46b51ffcc87fb21babd3e/crates/ruff_python_formatter/src/comments/placement.rs#L603</p>
<p>Python does allow mixed space and tabs indent (they can even be different between statements in a block, for as long as the visual indent is the same regardless of the tab size)
https://play.ruff.rs/7a681eaf-592d-45c7-8272-1eca15252a51</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-21 17:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:153 on 2025-11-21 17:17</div>
            <div class="timeline-body"><blockquote>
<p>Python does allow mixed space and tabs indent (they can even be different between statements in a block, for as long as the visual indent is the same regardless of the tab size)</p>
</blockquote>
<p>gross ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @amyreese on 2025-11-25 01:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-11-25 01:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch restored on 2025-11-25 01:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @amyreese on 2025-11-25 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @amyreese on 2025-11-25 02:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[ruff] new module for parsing suppression comments" to "[ruff] new module for parsing ranged suppressions" by @amyreese on 2025-11-25 02:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @MichaReiser on 2025-11-25 08:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/linter.rs</code>:144 on 2025-11-25 08:22</div>
            <div class="timeline-body"><p>I think we should remove this before landing as it isn't used yet (but it's great to have in place up right to landing to get the benchmark resutls)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:42 on 2025-11-25 08:31</div>
            <div class="timeline-body"><p>Allocating a <code>Vec</code> just for comparing the code and copying over the string slices is unnecessarily expensive.</p>
<p>You can do something like this</p>
<pre><code class="language-suggestion">    fn codes_as_str&lt;'src&gt;(&amp;self, source: &amp;'src str) -&gt; impl Iterator&lt;Item = &amp;'src str&gt; {
        self.codes.iter().map(|range| source.slice(range))
    }
</code></pre>
<p>And then compare the codes using <code>comment.codes_as_str().eq(other.codes_as_str())</code></p>
<p>However, this will require that the codes are in the exact same order. Is this the semantics we want?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:46 on 2025-11-25 08:34</div>
            <div class="timeline-body"><p>Can you make an example for why it's necessary to match <code>disable</code> comments to <code>enable</code> comments. I assumed that matching <code>enable</code> to <code>disable</code> comments should be sufficient because we always start with &quot;enabled-by-default&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:67 on 2025-11-25 08:35</div>
            <div class="timeline-body"><pre><code class="language-suggestion">#[expect(unused)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-11-25 08:41</div>
            <div class="timeline-body"><p><code>SmallVec</code> stack-allocates up to <code>N</code> items before heap allocating a regular <code>Vec</code>. This has the advantage that it reduces the pressure on heap size. However, it can have the downside that the containing type (<code>Suppression</code>) becomes larger because the <code>SmallVec</code> requires at least <code>N * SuppressionComment</code> bytes to store the inline elements.</p>
<p>The main downside of small vec is that it wastes memory when the stored elements is less than <code>N</code>. It also makes copying <code>Suppression</code> more expensive because it requires writing more bytes (e.g. when adding a <code>Suppression</code> to a <code>Vec</code>)</p>
<p>Given that <code>SuppressionComment</code> is a fairly chunky type (72 bytes) (rust-analyzer shows you the size on hover) and the most common case is probably to suppress exactly one code, I suggest reducing <code>N</code> to 1</p>
<pre><code class="language-suggestion">    comments: SmallVec&lt;[SuppressionComment; 1]&gt;,
</code></pre>
<p>After reading the entire PR, I think this shouldn't be a <code>SmallVec</code> in the first place. Instead, I think we should use two fields:</p>
<pre><code class="language-rust">enable_comment: Option&lt;SuppressionComment&gt;,
disable_comment: Option&lt;SuppressionComment&gt;
</code></pre>
<p>This is more explicit expresses the structure found in code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:58 on 2025-11-25 08:41</div>
            <div class="timeline-body"><p>Nit: Consider using <code>CompactStr</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:67 on 2025-11-25 08:43</div>
            <div class="timeline-body"><p>I suggest implementing <code>Copy</code> for <code>InvalidSuppressionKind</code>. It improves the ergonomics of this type as Rust now allows you to make copys of the type without an explicit <code>.clone</code> call. <code>Copy</code> is recommended for small types (a no-brainer for anything <code>&lt;= usize</code>; I sometimes go as high as <code>2 usize</code>) and where identity doesn't matter</p>
<pre><code class="language-suggestion">#[derive(Copy, Clone, Debug)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:175 on 2025-11-25 08:51</div>
            <div class="timeline-body"><p>Nit: I prefer to have the external visible API come before the implementation details. In this case, move <code>load_from_tokens</code> above <code>match_comments</code>. It has the advantage that, when reading the code, I can start getting an overview before I have to read the gnarly implementation details.</p>
<p>I know that this might take some time getting used to coming from Python where you have to forward-declare functions and classes before you can use it. We don't need to do that in Rust, allowing us to lay out the code for better readability than the runtime requires.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:125 on 2025-11-25 08:57</div>
            <div class="timeline-body"><p>It's preferred to use <code>&amp;str</code> over <code>&amp;String</code> because you can pass a <code>String</code> reference and a static string (like <code>&quot;abc&quot;</code>) to a function taking a <code>&amp;str</code>, but you can only pass a <code>String</code> reference to a function taking a <code>&amp;String</code> argument.</p>
<pre><code class="language-suggestion">    fn match_comments(&amp;mut self, current_indent: &amp;str) {
</code></pre>
<p>Overall, writing <code>&amp;String</code> or <code>&amp;Vec&lt;T&gt;</code> tends to be a code smell and you should use <code>&amp;str</code> or <code>&amp;[T]</code> instead</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:178 on 2025-11-25 08:58</div>
            <div class="timeline-body"><p>We can avoid copying the idents to <code>String</code> by storing <code>&amp;str</code></p>
<pre><code class="language-suggestion">        let default_indent = &quot;&quot;;
        let mut current_indent = default_indent;
        let mut indents: Vec&lt;&amp;str&gt; = vec![];
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:186 on 2025-11-25 09:00</div>
            <div class="timeline-body"><p>Now that we use <code>&amp;str</code>, which is <code>Copy</code>, we can write this as</p>
<pre><code class="language-suggestion">										current_indent = self.source.slice(token);
                    indents.push(current_indent);
</code></pre>
<p>Although I'd suggest removing <code>current_indent</code> altogether and instead use <code>indents.last().copied().unwrap_or_default()</code> to get the current indent. It avoids tracking the same state twice</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:268 on 2025-11-25 09:06</div>
            <div class="timeline-body"><p>You can avoid the cloning here by changing the signature of <code>load_from_tokens</code> to take a <code>mut self</code> (so that it takes an owned value, meaning, the caller won't be allowed to use <code>self</code> anymore after).</p>
<pre><code class="language-rust">load_from_tokens(mut self, tokens: &amp;Tokens)
</code></pre>
<pre><code class="language-suggestion">        Suppressions {
            valid: self.valid,
            invalid: self.invalid,
            errors: self.errors,
        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:343 on 2025-11-25 09:08</div>
            <div class="timeline-body"><p>I was a bit confused by this line. I think what you have here works because we don't need to support <code># ruff:disable[RUF100] reason # fmt: off</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:331 on 2025-11-25 09:10</div>
            <div class="timeline-body"><p>You can use <code>indentation</code> here</p>
<p>https://github.com/astral-sh/ruff/blob/ef8f399a65d4a6355a0140adf7ff4462e549d2ae/crates/ruff_python_ast/src/whitespace.rs#L9-L14</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:23 on 2025-11-25 09:17</div>
            <div class="timeline-body"><p>I'm inclined to remove <code>indent</code> from <code>SuppressionComment</code> as it is only information necessary for matching comments. I don't think we'll need it afterwards.</p>
<p>It would also allow moving the indent handling out of the <code>SuppressionParser</code>, keeping the parser scope narrow to just parsing out the comment (and it's the builders responsiblity to do all the indent stuff).</p>
<p>The way I would approach this is by adding a <code>PendingSuppressionComment</code> struct like this</p>
<pre><code class="language-rust">struct PendingSuppressionComment&lt;'src&gt; {
	indent: &amp;'src str,
	comment: SuppressionComment
}
</code></pre>
<p>It also has the advantage that we don't need to copy the indent to a <code>String</code>, instead we can just store the <code>str</code> slice (requires changing <code>pending</code> to <code>Vec&lt;PendingSuppressionComment&lt;'a&gt;&gt;</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:131 on 2025-11-25 09:33</div>
            <div class="timeline-body"><p>I wonder if <code>load_from_tokens</code> should store a <code>Vec&lt;(&amp;str, Vec&lt;SuppressionComment&gt;)</code> where the first item is the indent at a given level, and the second item is the suppression comments at that level.</p>
<p>I think this method would greatly simplify because you could just iterate over the comments at the given level instead of having to match them by indent again.</p>
<p>The downside is that we allocate a few extra <code>Vec</code>'s, one for each level with a suppression comment. I think that's fine.</p>
<p>Making this change should also remove the need for <code>PendingSuppressionComment</code> because we no longer need to store the <code>indent</code> anywhere (I think)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:159 on 2025-11-25 09:41</div>
            <div class="timeline-body"><p>I don't think it's a big deal, but it's a bit unfortunate that we need to clone both comments here. Do we need all information from <code>SuppressionComment</code> or could we copy a subset of the information to `Suppression? (If not, as I said, I think this is completely fine)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:992 on 2025-11-25 09:44</div>
            <div class="timeline-body"><p>I find the snapshot tests here fairly hard to read due to all the byte offsets. You could consider adding a helper similar to what I added in ty that pretty prints suppression comments:</p>
<p>https://github.com/astral-sh/ruff/blob/ef8f399a65d4a6355a0140adf7ff4462e549d2ae/crates/ty_python_semantic/src/suppression.rs#L1087-L1159</p>
<p>Another alternative is to render the suppressions using our diagnostic system, similar to what we do for ty's ide tests</p>
<p>https://github.com/astral-sh/ruff/blob/ef8f399a65d4a6355a0140adf7ff4462e549d2ae/crates/ty_ide/src/lib.rs#L392-L398</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:991 on 2025-11-25 10:03</div>
            <div class="timeline-body"><p>I think it would be great to have a few more tests here:</p>
<ul>
<li>What if we have to succinct <code>ruff: enable</code></li>
<li>What about multiple <code>ruff: disable</code> and only one <code>ruff: enable</code></li>
<li>What if the <code>ruff: disable</code> and <code>ruff: enable</code> match but the codes are in a different order?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-25 10:15</div>
            <div class="timeline-body"><p>This, overall looks great. I've a few inline comment for how I would restructure the code to make it more performant or more idiomatic Rust.</p>
<p>My main concern is that I see a <a href="https://codspeed.io/astral-sh/ruff/branches/suppression-parsing?utm_source=github&amp;utm_medium=check&amp;utm_content=details">3% performance regression</a> on the linter benchmarks. I think we should try the following:</p>
<ol>
<li>Can we reduce the regression by integrating the extraction into <a href="https://github.com/astral-sh/ruff/blob/b6bd32d9dc086e81b766019b5b99e8c343de7220/crates/ruff_python_index/src/indexer.rs#L32"><code>Indexer::from_tokens</code></a> by having a <code>visit_token</code> method?</li>
<li>Instead of iterating over <code>Tokens</code>, iterate over <code>CommentRanges</code>, and start iterating over tokens only the comment is a <code>ruff: enable</code> / <code>ruff: disable</code> comment. A somewhat naive implementation below</li>
</ol>
<pre><code class="language-rust">let mut indents: Vec&lt;&amp;str&gt; = vec![];
        let mut errors = Vec::new();

        let mut suppressions = comments
            .iter()
            .copied()
            .filter_map(|comment_range| {
                let mut parser = SuppressionParser::new(self.source, comment_range);
                match parser.parse_comment() {
                    Ok(comment) =&gt; Some(comment),
                    Err(ParseError {
                        kind: ParseErrorKind::NotASuppression,
                        ..
                    }) =&gt; None,
                    Err(error) =&gt; {
                        errors.push(error);
                        None
                    }
                }
            })
            .peekable();

        'comments: while let Some(suppression) = suppressions.peek() {
            let last_indent = tokens
                .before(suppression.range.start())
                .iter()
                .rfind(|token| token.kind() == TokenKind::Indent)
                .map(|token| self.source.slice(token))
                .unwrap_or_default();

            indents.push(last_indent);

            let tokens = tokens.after(suppression.range.start());

            // Iterate through tokens, tracking indentation, filtering trailing comments, and then
            // looking for matching comments from the previous block when reaching a dedent token.
            for (token_index, token) in tokens.iter().enumerate() {
                let current_indent = indents.last().copied().unwrap_or_default();
                match token.kind() {
                    TokenKind::Indent =&gt; {
                        indents.push(self.source.slice(token));
                    }
                    TokenKind::Dedent =&gt; {
                        self.match_comments(current_indent);

                        indents.pop();

                        if indents.is_empty() { // OR if self.pending is empty?
                            continue 'comments;
                        }
                    }
                    TokenKind::Comment =&gt; {
                        let Some(suppression) =
                            suppressions.next_if(|suppression| suppression.range == token.range())
                        else {
                            continue;
                        };

                        let Some(indent) =
                            indentation_at_offset(suppression.range.start(), self.source)
                        else {
                            // trailing suppressions are not supported
                            self.invalid.push(InvalidSuppression {
                                kind: InvalidSuppressionKind::Trailing,
                                comment: suppression,
                            });
                            continue;
                        };

                        // comment matches current block's indentation, or precedes an indent/dedent token
                        if indent == current_indent
                            || tokens[token_index..]
                                .iter()
                                .find(|t| !t.kind().is_trivia())
                                .is_some_and(|t| {
                                    t.kind() == TokenKind::Dedent || t.kind() == TokenKind::Indent
                                })
                        {
                            self.pending.push(PendingComment {
                                comment: suppression,
                                indent,
                            });
                        } else {
                            // weirdly indented? Â¯\_(ãƒ„)_/Â¯
                            self.invalid.push(InvalidSuppression {
                                kind: InvalidSuppressionKind::Indentation,
                                comment: suppression,
                            });
                        }
                    }
                    _ =&gt; {}
                }
            }

            self.match_comments(&quot;&quot;);
        }

        Suppressions {
            valid: self.valid,
            invalid: self.invalid,
            errors,
        }
</code></pre>
<p>I've a slight preference towards the second approach as it tries to avoid unnecessary work, but I'd also be fine going with the first approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 16:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:175 on 2025-11-25 16:42</div>
            <div class="timeline-body"><blockquote>
<p>I know that this might take some time getting used to coming from Python where you have to forward-declare functions and classes before you can use it. We don't need to do that in Rust, allowing us to lay out the code for better readability than the runtime requires.</p>
</blockquote>
<p>That's not really true for Python.Â You can reference and call other functions even if they're defined later in the file, as long as at import-time you don't try to actually execute it before the runtime has gotten to the definition.</p>
<p>Eg, this will work just fine:</p>
<pre><code class="language-py">def foo():
	bar()

def bar():
	...

foo()
</code></pre>
<p>It's more a style choice I picked up â€”Â for a different kind of readability â€” where it's easier to consume and understand a module in it's entirety if you can read it from top-to-bottom, starting with the building blocks. It helps prevent the need for jumping around in the file to understand what functions/classes are doing, because you would have read their definitions or at least their docstrings already. And if you're more interested in what the &quot;public&quot; API is rather than understanding the implementation, that would generally be covered by either a docstring at the top of the file, or documentation built from the source code's docstrings.</p>
<p>That said, I will try to follow Ruff's/Rust's style.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-25 17:27</div>
            <div class="timeline-body"><p>As discussed in our 1:1</p>
<ul>
<li>I think we should move the performance optimization out of this PR. We can simply remove the call to extract the comments in this PR and address the performance concerns in a follow-up PR.</li>
<li>Let's add more integration tests in https://github.com/astral-sh/ruff/pull/21623 rather than trying to improve the integration testing framework here (and extending coverage)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 17:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:46 on 2025-11-25 17:36</div>
            <div class="timeline-body"><p>I wrote it both ways here because I waffled a bit on where/how to do the matching, and in which direction the search for a match would be done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 17:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:42 on 2025-11-25 17:55</div>
            <div class="timeline-body"><blockquote>
<p>However, this will require that the codes are in the exact same order. Is this the semantics we want?</p>
</blockquote>
<p>I considered using an unordered set, or just sorting the codes found, but wasn't sure what the performance semantics of that would be when trying to match comments together, especially if there was a big file with a bunch of disable/enable comments.</p>
<p>From the UX perspective, I feel like &quot;must be same order&quot; is easy to explain, and also helps enforce the idea that you can't &quot;mix and match&quot; codes from various disable/enable comments.</p>
<p>Eg, I don't think we want to support (or make users <em>think</em> we support) this:</p>
<pre><code># ruff: disable[foo]
...
# ruff: disable[bar]
...
# ruff: enable[foo,bar]
</code></pre>
<p>Keeping the semantics rigid around order within matched comments seems beneficial, but I'm not opposed to allowing arbitrary orders as long as the set contents match.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-25 17:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:42 on 2025-11-25 17:59</div>
            <div class="timeline-body"><p>I'm fine keeping it as is for now and change the behavior based on user feedback.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 18:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-11-25 18:10</div>
            <div class="timeline-body"><p>The main reason I chose a vec rather than explicit fields was as consideration for  any logic around needing the comment ranges (like reporting unused suppressions/codes) could simply loop over any associated comments without having to know what kind the suppression is, or without needing to repeat logic within <code>if let Some(comment) = suppression.&lt;kind&gt;_comment</code> blocks. And in a hypothetical future where we added alternative suppression directives (eg, <code>#ruff:ignore</code>) or where we unified <code>#noqa</code> into this framework to deduplicate suppression handling logic, we wouldn't need to add new fields or further duplicate that logic.  But also maybe there's some rust tricks that make this nicer and I don't know what I'm talking about. ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-25 18:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-11-25 18:24</div>
            <div class="timeline-body"><p>I'm fine leaving this as is in that case but a few thougths:</p>
<blockquote>
<p>The main reason I chose a vec rather than explicit fields was as consideration for any logic around needing the comment ranges (like reporting unused suppressions/codes) could simply loop over any associated comments without having to know what kind the suppression is, or without needing to repeat logic within if let Some(comment) = suppression.<kind>_comment blocks</p>
</blockquote>
<p><code>Suppression</code> could have a <code>comments()</code> method that returns an <code>Iterator</code> over al its comments for the cases where we really just want to iterate over them. I suspect that we still need special casing depending on the kind of comment when generating fixes.</p>
<blockquote>
<p>or where we unified #noqa into this framework to deduplicate suppression handling logic, we wouldn't need to add new fields or further duplicate that logic.</p>
</blockquote>
<p>I wouldn't worry too much about that. This seems far out and there are a few options as well, E.g. we could have an <code>enum</code> depending on the comment kind that stores one or two comments (I don't think there's any case where we want to store 3?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 19:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:23 on 2025-11-25 19:32</div>
            <div class="timeline-body"><p>I'm definitely not used to thinking in terms of composing types like this. That will take more practice to reach for it more regularly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 19:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:992 on 2025-11-25 19:47</div>
            <div class="timeline-body"><p>I tried doing this earlier on and got so lost in rust compiler errors that I decided to defer it for later once I actually had the logic working ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 20:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-11-25 20:29</div>
            <div class="timeline-body"><blockquote>
<p>Given that SuppressionComment is a fairly chunky type (72 bytes) (rust-analyzer shows you the size on hover) and the most common case is probably to suppress exactly one code, I suggest reducing N to 1</p>
</blockquote>
<p>Also I think you misunderstand the current use here. In the expected case, this vec would contain a reference to both the disable and enable <code>SuppressionComment</code> objects. Unmatched disable/enable would end up in the <code>invalid</code> pile rather than getting a <code>Suppression</code> object created.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-11-25 20:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:159 on 2025-11-25 20:50</div>
            <div class="timeline-body"><p>Other than the indents â€” which I will move out somewhere else â€” the rest of the data in the comment object was intended for use by diagnostics like unused suppressions/codes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-25 22:46</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-25 22:49</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">beartype (https://github.com/beartype/beartype)
- beartype/claw/_package/clawpkgtrie.py:66:29: warning[unsupported-base] Unsupported class base with type `&lt;class 'dict[str, PackagesTrieBlacklist]'&gt; | &lt;class 'dict[str, Divergent]'&gt;`
- beartype/claw/_package/clawpkgtrie.py:247:29: warning[unsupported-base] Unsupported class base with type `&lt;class 'dict[str, PackagesTrieWhitelist]'&gt; | &lt;class 'dict[str, Divergent]'&gt;`
- Found 498 diagnostics
+ Found 496 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
+ src/scikit_build_core/_logging.py:153:13: warning[unsupported-base] Unsupported class base with type `&lt;class 'Mapping[str, Style]'&gt; | &lt;class 'Mapping[str, Divergent]'&gt;`
- src/scikit_build_core/build/_pathutil.py:25:38: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `str | PathLike[str]`, found `DirEntry[Path]`
- src/scikit_build_core/build/_pathutil.py:27:24: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `str | PathLike[str]`, found `DirEntry[Path]`
- src/scikit_build_core/build/wheel.py:98:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 44 diagnostics
+ Found 42 diagnostics

pydantic (https://github.com/pydantic/pydantic)
- pydantic/fields.py:943:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:943:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:983:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:983:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:1026:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:1026:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:1066:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:1066:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:1109:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:1109:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:1148:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:1148:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:1188:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
+ pydantic/fields.py:1188:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
- pydantic/fields.py:1567:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, Divergent], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`
+ pydantic/fields.py:1567:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`


</code></pre>
</details>

<p>No memory usage changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[ruff] new module for parsing ranged suppressions" to "new module for parsing ranged suppressions" by @MichaReiser on 2025-11-26 07:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-26 07:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-11-26 07:04</div>
            <div class="timeline-body"><blockquote>
<p>Unmatched disable/enable would end up in the invalid pile rather than getting a Suppression object created.</p>
</blockquote>
<p>I thought we decided to allow implicit <em>enables</em> at the end of the block.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-12-01 17:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-12-01 17:36</div>
            <div class="timeline-body"><p>Looking back at the notion doc, the summary says we decided on requiring a matching enable comment, I believe coming back to the idea of wanting to make sure that refactors didn't accidentally remove a <code>#ruff:enable</code> line and unknowingly suppress more lines than originally intended.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @amyreese on 2025-12-02 00:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amyreese">@amyreese</a> on 2025-12-02 00:08</div>
            <div class="timeline-body"><p>Updated with most of the suggestions, including use of <code>&amp;str</code>, better testing snapshots, etc. Performance work to bridge comment ranges and tokens was left for a future PR. I think this should be ready to land assuming I haven't introduced other nits.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-02 08:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:77 on 2025-12-02 08:18</div>
            <div class="timeline-body"><p>I'm leaning towards making this a lint rule, which we can enable by default, but giving users a way to opt out if they want to.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:12 on 2025-12-02 08:20</div>
            <div class="timeline-body"><p>Use <code>expect</code> over <code>allow</code>. This way, rustc will remind you to remove the unused warning once the struct is used</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:177 on 2025-12-02 08:22</div>
            <div class="timeline-body"><p>Nit</p>
<pre><code class="language-suggestion">                                        matches!(t.kind(), TokenKind::Dedent | TokenKind::Indent)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/suppression.rs</code>:131 on 2025-12-02 08:23</div>
            <div class="timeline-body"><p>I still think that this might be a nice simplification but up to you</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-12-02 08:25</div>
            <div class="timeline-body"><p>Thanks, this looks good.</p>
<p>I suggest keeping <code>disable</code> comments without an explicit comment as valid suppressions and instead creating a new ruff dedicated lint rule that warns about this. This way, it gives users a way to opt-out from this behavior.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/amyreese">@amyreese</a> on <code>crates/ruff_linter/src/suppression.rs</code>:12 on 2025-12-02 16:05</div>
            <div class="timeline-body"><p>I tried doing that, but then I get <code>unfulfilled</code> issues because they are used by tests. ðŸ™ƒ  Is there a correct way to account for that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/amyreese">@amyreese</a> reviewed on 2025-12-02 16:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @amyreese on 2025-12-02 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @amyreese on 2025-12-02 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-12-02 23:40</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:17:15 UTC
    </footer>
</body>
</html>
