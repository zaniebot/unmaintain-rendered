<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`pyflakes`/`pylint`] Skip `__class__` checks in method definitions (… - astral-sh/ruff #19783</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>pyflakes</code>/<code>pylint</code>] Skip <code>__class__</code> checks in method definitions (…</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19783">#19783</a>
        opened by <a href="https://github.com/mikeleppane">@mikeleppane</a>
        on 2025-08-06 12:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mikeleppane">@mikeleppane</a></div>
            <div class="timeline-body">Summary
Problem
<p>Rules <a href="https://docs.astral.sh/ruff/rules/unused-variable/">F841</a> (<code>unused-variable</code>) and <a href="https://docs.astral.sh/ruff/rules/nonlocal-without-binding/">PLE0117</a> (<code>nonlocal-without-binding</code>) incorrectly flagged usage within method definitions, causing false positives.
Root Cause: Both rules failed to recognize that it is a special variable automatically available in Python method definitions. In methods, it is implicitly bound by the Python runtime, making assignments to it legitimate and declarations valid. <code>__class__``__class__``nonlocal __class__</code></p>
Solution
<ul>
<li>Added special handling for when detected within method definitions: <code>__class__</code></li>
<li><strong>F841</strong>: Skip unused variable warnings for assignments in methods <code>__class__</code></li>
<li><strong>PLE0117</strong>: Allow statements in methods without requiring explicit outer bindings <code>nonlocal __class__</code></li>
</ul>
<pre><code>class C:
    def set_class(self, cls):
        __class__ = cls  # No longer warns about unused variable
        
    def get_class(self):
        nonlocal __class__  # No longer warns about missing binding
        return __class__
</code></pre>
Test Plan
<pre><code>cargo test
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-06 13:02</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-06 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/pyflakes/rules/unused_variable.rs</code>:289 on 2025-08-06 15:25</div>
            <div class="timeline-body"><p>We might be able to use something like this here for traversing the parent scopes:</p>
<p>https://github.com/astral-sh/ruff/blob/4d57fcd5a488e628aa26aaacd0a61728609ff310/crates/ruff_linter/src/checkers/ast/mod.rs#L702-L708</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-08-06 15:41</div>
            <div class="timeline-body"><p>Thanks for working on this!</p>
<p>This looks like it fixes the issue for these two rules. Did you look into my suggestion about synthesizing a <code>__class__</code> binding for class scopes (<a href="https://github.com/astral-sh/ruff/issues/18442">astral-sh/ruff#18442</a>#issuecomment-2935976782)? I&#x27;m still not sure if that&#x27;s a good idea or not, but it could be nice to resolve this more generally instead of adding special cases to individual rules as needed, and that seemed like one approach.</p>
<p>In grepping around, it looks like we might already have handling for this, if we can call this enclosing <code>resolve_load</code> function:</p>
<p>https://github.com/astral-sh/ruff/blob/4d57fcd5a488e628aa26aaacd0a61728609ff310/crates/ruff_python_semantic/src/model.rs#L412-L422</p>
<p>If neither of these solutions looks fruitful, I&#x27;m happy with what you have here too :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mikeleppane">@mikeleppane</a> on 2025-08-07 13:57</div>
            <div class="timeline-body"><p>@ntBre thanks for the good comments! What would you think about this approach, in which we add a method to the semantic model that would expose implicit global functionality? Something like this:</p>
<pre><code>impl&lt;&#x27;a&gt; SemanticModel&lt;&#x27;a&gt; {
    /// Check if a name would resolve as an implicit global from a given scope
    /// without actually creating references or modifying state.
    pub fn would_resolve_as_implicit_global(&amp;self, name: &amp;str, scope_id: ScopeId) -&gt; bool {
        let scope = &amp;self.scopes[scope_id];
        
        match name {
            &quot;__class__&quot; =&gt; {
                if !scope.kind.is_function() {
                    return false;
                }
                
                let mut seen_function = false;
                for ancestor_scope_id in self.ancestor_scopes(scope_id) {
                    let ancestor_scope = &amp;self.scopes[ancestor_scope_id];
                    if ancestor_scope.kind.is_class() &amp;&amp; seen_function {
                        return true;
                    }
                    seen_function |= ancestor_scope.kind.is_function();
                }
                false
            }
            &quot;__module__&quot; | &quot;__qualname__&quot; =&gt; {
                scope.kind.is_class()
            }
            _ =&gt; false,
        }
    }
}

// RULE

pub(crate) fn unused_variable(checker: &amp;Checker, name: &amp;str, binding: &amp;Binding) {
    if binding.is_unpacked_assignment() {
        return;
    }

    if checker
        .semantic()
        .would_resolve_as_implicit_global(name, binding.scope)
    {
        return;
    }

    /*// Skip __class__ in method definitions - it&#x27;s automatically bound by Python
    if name == &quot;__class__&quot; &amp;&amp; is_binding_in_method_definition(checker, binding) {
        return;
    }*/

    let mut diagnostic = checker.report_diagnostic(
        UnusedVariable {
            name: name.to_string(),
        },
        binding.range(),
    );
    if let Some(fix) = remove_unused_variable(binding, checker) {
        diagnostic.set_fix(fix);
    }
}


</code></pre>
<p>With this, the implementation of both rules becomes trivial, and we have something more general. I think now it solves this beautifully.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dscorbett">@dscorbett</a> on 2025-08-07 17:51</div>
            <div class="timeline-body"><p>I haven’t reviewed the code but I have three responses to the opening comment.</p>
<pre><code>    def set_class(self, cls):
        __class__ = cls  # No longer warns about unused variable
</code></pre>
<p>There actually should be an F841 warning because <code>__class__</code> is a local variable here, not a nonlocal variable, and is therefore unused.</p>
<pre><code>    def get_class(self):
        nonlocal __class__  # No longer warns about missing binding
        return __class__
</code></pre>
<p>There should be a warning because the <code>nonlocal</code> statement is redundant, though I agree it is out of scope for PLE0117. This could be a new rule analogous to <a href="https://docs.astral.sh/ruff/rules/global-variable-not-assigned/"><code>global-variable-not-assigned</code> (PLW0602)</a>.</p>
<p>Finally, the original issue used F841 and PLE0117 as examples. The fix should probably be at a more fundamental level in the code about bindings and scopes, affecting all rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-13 18:12</div>
            <div class="timeline-body"><p>Thanks @dscorbett, it sounds like the fix here is not quite right.</p>
<p>@mikeleppane I&#x27;m not sure adding this method to the semantic model would be very helpful, at least as used in this snippet. We&#x27;d still have to be careful to call it in each affected rule, so it&#x27;s not much of a step up from the type of special-casing in this PR. That&#x27;s why I&#x27;m still intrigued by the synthetic binding approach. It would be a small special case when creating new scopes, and then all of our other infrastructure should continue working as usual. That may still not work, though, because <code>__class__</code> isn&#x27;t bound in the class scope, but it&#x27;s also not exactly bound in the method scope because you can&#x27;t usually do something like this:</p>
<pre><code>&gt;&gt;&gt; class C:
...     def f():
...         x = 1
...         nonlocal x
...         return x
...
  File &quot;&lt;python-input-5&gt;&quot;, line 4
    nonlocal x
    ^^^^^^^^^^
SyntaxError: name &#x27;x&#x27; is assigned to before nonlocal declaration
</code></pre>
<p>which seems analogous to the <code>nonlocal</code> case for <code>__class__</code> if you synthesize it as a binding in the method.</p>
<p>I think I&#x27;ve talked myself out of the synthetic binding, so maybe a new semantic model method <em>is</em> called for, but ideally we&#x27;d call it within existing semantic model methods so that every rule benefits from it automatically. It may also be worth checking how ty handles this. I didn&#x27;t turn up anything obviously helpful in a very quick grep, but I suspect that they may have an answer somewhere.</p>
<p>We <em>could</em> push a synthetic scope between the class and the method, which seems closest to how this is implemented in CPython, but then we have to skip that scope kind everywhere else, which doesn&#x27;t seem worth it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-26 13:50</div>
            <div class="timeline-body"><p>Thanks again for your work here! I think we can close this now in favor of <a href="https://github.com/astral-sh/ruff/pull/20048">astral-sh/ruff#20048</a>. I pulled in your tests over there and added you as a co-author :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/ntBre">@ntBre</a> on 2025-08-26 13:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:17:26 UTC
    </footer>
</body>
</html>
