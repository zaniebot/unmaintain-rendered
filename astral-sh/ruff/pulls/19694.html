<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Do not treat tuple types as ever being single-valued - astral-sh/ruff #19694</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Do not treat tuple types as ever being single-valued</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19694">#19694</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-08-01 17:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body">Summary
<p>This PR updates our handling of tuples so that we no longer consider tuple types as ever being &quot;single-valued&quot; types. As a reminder, a type is only single-valued if all possible inhabitants of the type compare equal. For example, <code>Literal[42]</code> is a single-valued type (even though it is not a singleton type), because the definition of the type is such that the only possible inhabitants of the type are instances of <em>exactly</em> <code>int</code> (cannot be an <code>int</code> subclass!) that compare equal to the runtime value <code>42</code>.</p>
<p>On <code>main</code> we consider a tuple type as being single-valued if it is a fixed-length tuple and all its element types are single-valued types. This makes sense if you assume that inhabitants of <code>tuple[int, str]</code> must be instances of <em>exactly</em> <code>tuple</code>. But that&#x27;s not what we assume, and it&#x27;s not what we should assume: all other type checkers consider tuple subclasses as being subtypes of the tuple type defined by their tuple superclass. It would be a huge compatibility break with the ecosystem if we tried to assume otherwise:</p>
<pre><code>from ty_extensions import static_assert, is_subtype_of

class Foo(tuple[int, str]): ...

static_assert(is_subtype_of(Foo, tuple[int, str]))  # passes
</code></pre>
<p>It&#x27;s easy to create a subclass of <code>tuple[int, str]</code> that is Liskov-compliant but not single-valued, which therefore means that <code>tuple[int, str]</code> cannot be single-valued, as it is a supertype of its subclass, so can only be single-valued if all its subtypes are single-valued:</p>
<pre><code>from ty_extensions import is_single_valued, static_assert

class EmptyTupleSubclass(tuple[()]):
    def __eq__(self, other: object) -&gt; bool:
        return isinstance(other, EmptyTupleSubclass) and len(other) == 0

static_assert(not is_single_valued(tuple[()]))
static_assert(not is_single_valued(EmptyTupleSubclass))

class SingleElementTupleSubclass(tuple[int]):
    def __eq__(self, other: object) -&gt; bool:
        return (
            isinstance(other, SingleElementTupleSubclass)
            and len(other) == 1
            and isinstance(other[0], int)
        )

static_assert(not is_single_valued(tuple[int]))
static_assert(not is_single_valued(SingleElementTupleSubclass))

class TwoElementTupleSubclass(tuple[str, bytes]):
    def __eq__(self, other: object) -&gt; bool:
        return (
            isinstance(other, TwoElementTupleSubclass)
            and len(other) == 2
            and isinstance(other[0], str)
            and isinstance(other[1], bytes)
        )

static_assert(not is_single_valued(tuple[str, bytes]))
static_assert(not is_single_valued(TwoElementTupleSubclass))
</code></pre>
<p>This might seem needlessly nitpicky and academic -- who creates tuple subclasses in the real world? But the answer to that question is &quot;Quite a few people, actually!&quot;, since all <code>NamedTuple</code> classes are tuple subclasses, and <code>NamedTuple</code>s are a very popular feature.</p>
Test Plan
<p>Updated and extended mdtests</p>
Ecosystem analysis
<p>There is a single new diagnostic being emitted on <code>zope.interface</code> <a href="https://github.com/zopefoundation/zope.interface/blob/f418c310af667c619314cdc635aeaca2b1c7a4c3/src/zope/interface/ro.py#L483-L497">here</a>. This is because they&#x27;re using <code>()</code> as a sentinel value, and then trying to narrow that type out of a union of types by using <code>== ()</code>. But we no longer see that as a valid way of narrowing a type, because we infer the type of <code>()</code> as <code>tuple[()]</code>, and we must account for the possibility of <code>tuple[()]</code> subclasses that define custom equality methods.</p>
<p>This does feel a <em>bit</em> unfortunate, because while tuple subclasses are common and defining custom <code>__eq__</code> methods on them seems pretty plausible, defining a custom <code>__eq__</code> method on a subclass of <code>tuple[()]</code> specifically seems somewhat implausible. However, it&#x27;s only a single new diagnostic, and I think that&#x27;s worth it to make our behaviour sound and consistent.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 17:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-01 17:18</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree//conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-01 17:20</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>zope.interface (https://github.com/zopefoundation/zope.interface)
+ src/zope/interface/ro.py:492:13: warning[possibly-unbound-implicit-call] Method `__setitem__` of type `Unknown | tuple[()] | WeakKeyDictionary[Unknown, Unknown]` is possibly unbound
- Found 338 diagnostics
+ Found 339 diagnostics

scikit-learn (https://github.com/scikit-learn/scikit-learn)
- sklearn/externals/array_api_extra/_lib/_funcs.py:512:28: error[invalid-argument-type] Argument to function `min` is incorrect: Expected `Iterable[Unknown]`, found `(tuple[int, ...] &amp; ~tuple[()]) | int`
+ sklearn/externals/array_api_extra/_lib/_funcs.py:512:28: error[invalid-argument-type] Argument to function `min` is incorrect: Expected `Iterable[Unknown]`, found `tuple[int, ...] | int`
- sklearn/externals/array_api_extra/_lib/_funcs.py:512:49: error[invalid-argument-type] Argument to function `max` is incorrect: Expected `Iterable[Unknown]`, found `(tuple[int, ...] &amp; ~tuple[()]) | int`
+ sklearn/externals/array_api_extra/_lib/_funcs.py:512:49: error[invalid-argument-type] Argument to function `max` is incorrect: Expected `Iterable[Unknown]`, found `tuple[int, ...] | int`

scipy (https://github.com/scipy/scipy)
- scipy/_lib/array_api_extra/src/array_api_extra/_lib/_funcs.py:568:28: error[invalid-argument-type] Argument to function `min` is incorrect: Expected `Iterable[Unknown]`, found `(tuple[int, ...] &amp; ~tuple[()]) | int`
+ scipy/_lib/array_api_extra/src/array_api_extra/_lib/_funcs.py:568:28: error[invalid-argument-type] Argument to function `min` is incorrect: Expected `Iterable[Unknown]`, found `tuple[int, ...] | int`
- scipy/_lib/array_api_extra/src/array_api_extra/_lib/_funcs.py:568:49: error[invalid-argument-type] Argument to function `max` is incorrect: Expected `Iterable[Unknown]`, found `(tuple[int, ...] &amp; ~tuple[()]) | int`
+ scipy/_lib/array_api_extra/src/array_api_extra/_lib/_funcs.py:568:49: error[invalid-argument-type] Argument to function `max` is incorrect: Expected `Iterable[Unknown]`, found `tuple[int, ...] | int`

</code></pre>

No memory usage changes detected âœ…

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 18:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 18:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 18:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 18:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-08-01 20:15</div>
            <div class="timeline-body"><blockquote>
<p>This does feel a <em>bit</em> unfortunate, because while tuple subclasses are common and defining custom <code>__eq__</code> methods on them seems pretty plausible</p>
</blockquote>
<p>One thing that gives me pause with this larger effort is that for some methods, we seem to be saying that the signature is all we need to consider when determine Liskov compliance; and for others, we&#x27;re saying that the <em>behavior</em> of the method needs to be consistent in subclasses. For instance, we&#x27;re outlawing overriding <code>__getitem__</code> and <code>__iter__</code> in a tuple subclass, because we want to ensure that we can unpack tuples:</p>
<pre><code>def _(t: tuple[int, str]):
    i, s = t
</code></pre>
<p>and if we only paid attention to the signature of <code>tuple.__iter__</code> (or <code>tuple.__len__</code> + <code>tuple.__getitem__</code>), then we couldn&#x27;t do this soundly.</p>
<p>I agree with that decision! And it seems clear that for the methods that we decide must be <em>behaviorally</em> Liskov-compatible, not just <em>type-signature</em> Liskov-compatible, we have to outlaw overriding, since we don&#x27;t have a way to express, let alone check, those behavioral requirements.</p>
<p>But why does that argument not also apply here to <code>__eq__</code>? Especially since you could argue that <code>__eq__</code> should always be consistent with <code>__iter__</code>:</p>
<pre><code>t1 == t2 â‡” list(iter(t1)) == list(iter(t2))
</code></pre>
<p>Individually I&#x27;m fine with all of these decisions, but I&#x27;m wondering if there&#x27;s a more rigorous first principle that we can refer to when making them. Right now it seems like we&#x27;re just deciding on a case-by-case basis.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 20:52</div>
            <div class="timeline-body"><p>To an extent I <em>am</em> being a bit ad-hoc about this, yes. But my guiding principle has been that tuples should behave like normal instance types (because they&#x27;re really much more similar to instance types than literal types in what they represent!) except when the benefits to user-facing behaviour are significant and clear. For unpacking of tuples, <code>__getitem__</code> inference of tuples, and truthiness of tuples, I feel like the bar is clearly met in all cases. For something like this, however, I&#x27;m not sure the same thing applies.</p>
<p>However... I&#x27;ve just realised that I think we will need to forbid overriding <code>__eq__</code> anyway on a tuple subclass. Our precise inference for comparisons between tuple types is essential to our understanding of <code>sys.version_info</code> tests (among other things); we can&#x27;t get rid of that. And in order for that to be sound, we will need to forbid overriding all comparison methods on tuple subclasses. Once we do that, treating tuples as single-valued is sound -- so this PR is invalid.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-01 20:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-04 11:52</div>
            <div class="timeline-body"><p>After a weekend mulling this over, I&#x27;ve changed my mind about this again ðŸ˜„</p>
<p>Given that we&#x27;ll have to forbid overriding <code>__eq__</code> anyway to make our precise comparison inference for tuples sound, it&#x27;s true that treating tuples as single-valued types might be sound. Just because it&#x27;s sound doesn&#x27;t make it well-motivated or consistent, however. I really do think we should be treating tuple types similarly to instance types as our default behaviour, unless there&#x27;s a well-motivated reason for us to apply special casing for tuple types in some specific instance. In this case, I don&#x27;t see any particular reason why it&#x27;s more beneficial to users to treat tuple types as single-valued, when there are many other &quot;fundamental&quot; instance types such as <code>int</code> and <code>str</code> that we do not treat as single-valued. If there were a significant ecosystem report on this PR, then I think that would be a reason to keep the special casing, but as it is I don&#x27;t think it&#x27;s worth the added complexity to our model and the inconsistency with other instance types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-04 11:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-05 03:03</div>
            <div class="timeline-body"><p>Hmm, I liked the rationale for closing this PR a bit better than the rationale for re-opening it :) The comparison to <code>int</code> or <code>str</code> doesn&#x27;t make much sense -- those types are fundamentally not single-valued, even if you didn&#x27;t consider subclasses or custom <code>__eq__</code> at all. Tuples <em>are</em> special, because they are immutable product types, which is why we can safely consider them single-valued if they consist of single-valued types. And we have to forbid custom <code>__eq__</code> on tuple subclasses anyway, so this is sound! And there is at least one clear real-world case for it. I don&#x27;t think we can dismiss &quot;just one ecosystem hit&quot; as &quot;no use case&quot;. Mypy-primer is a small sample of real-world code, and one mypy-primer hit (that isn&#x27;t in wrongly-typed or clearly bad-practice code) is a clear indicator of a real use case.</p>
<p>The general principle of making tuples &quot;less special&quot; (when they are inevitably quite special anyway) doesn&#x27;t seem to me like a sufficiently strong argument to outweigh the above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-05 11:17</div>
            <div class="timeline-body"><p>Alrighty, thanks both -- sounds like the consensus is against me here!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-05 11:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-08-05 14:31</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:17:16 UTC
    </footer>
</body>
</html>
