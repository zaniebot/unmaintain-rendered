<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Create a specialization from a constraint set - astral-sh/ruff #21414</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Create a specialization from a constraint set</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21414">#21414</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-11-12 21:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>This patch lets us create specializations from a constraint set. The constraint encodes the restrictions on which types each typevar can specialize to. Given a generic context and a constraint set, we iterate through all of the generic context's typevars. For each typevar, we abstract the constraint set so that it only mentions the typevar in question (propagating derived facts if needed). We then find the &quot;best representative type&quot; for the typevar given the abstracted constraint set.</p>
<p>When considering the BDD structure of the abstracted constraint set, each path from the BDD root to the <code>true</code> terminal represents one way that the constraint set can be satisfied. (This is also one of the clauses in the DNF representation of the constraint set's boolean formula.) Each of those paths is the conjunction of the individual constraints of each internal node that we traverse as we walk that path, giving a single lower/upper bound for the path. We use the upper bound as the &quot;best&quot; (i.e. &quot;closest to <code>object</code>&quot;) type for that path.</p>
<p>If there are multiple paths in the BDD, they technically represent independent possible specializations. If there's a single specialization that satisfies all of them, we will return that as the specialization. If not, then the constraint set is ambiguous. (This happens most often with constrained typevars.) We could in the future turn <em>each</em> of the paths into separate specializations, but it's not clear what we would do with that, so instead we just report the ambiguity as a specialization failure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @dcreager on 2025-11-12 21:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @dcreager on 2025-11-12 21:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-12 21:08</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-12 21:09</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/build/wheel.py:98:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 44 diagnostics
+ Found 43 diagnostics


</code></pre>
</details>

<p>No memory usage changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dcreager on 2025-11-18 01:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-11-18 01:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-11-18 01:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dcreager on 2025-11-18 01:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dcreager on 2025-11-18 01:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @ibraheemdev by @MichaReiser on 2025-11-18 17:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-18 20:54</div>
            <div class="timeline-body"><p>Doesn't this result violate &quot;must specialize to one of those specific types&quot;?</p>
<p>I feel like we discussed this case earlier and looked at what other type checkers do. I think they rather infer <code>Unknown</code> if they have no basis for picking one of the constrained types? At least that's what pyright seems to do: https://pyright-play.net/?pyrightVersion=1.1.405&amp;pythonVersion=3.12&amp;reportUnreachable=true&amp;code=CYUwZgBGDaAqBcEAUBLAdgFwDQQM4YCcBKAXSQA9FYIAfCAOQHs0QiIBaAPggQCgIBEFJHJDcENIwwNmIeP0GKCIDAFcCaCOQUCCAQxS4QPAJ4AHEAFECBRgSQAiAIIBjNXoA2HkzJZiIAO62aADmDkS8vMoAbiCeAPoY5iBIYEhMLEQRvEA</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:160 on 2025-11-18 20:57</div>
            <div class="timeline-body"><p>Yes, but shouldn't we still solve to the gradual type that is one of the constraints? E.g. see https://pyright-play.net/?pyrightVersion=1.1.405&amp;pythonVersion=3.12&amp;reportUnreachable=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoCCKcAUCQCYCmwUwA2gCoBcUAFKjADSHECUAuqwAeLBlF5QAtAD4ozElEVQQlGAFcQKKELIqAbpQCGAGwD68BJVbBWAImBgwt3rzJA</p>
<p>E.g. in every solution in the first section below that is not <code>Base</code>, I would expect to solve to <code>Any</code>, rather than any of the materializations of it. I suspect this will cause false positives and violate the gradual guarantee otherwise?</p>
<p>It seems like the current approach takes as a requirement that we always solve to a fully static type, but I'm not sure that is what we should do, in the case of constrained type variables.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:304 on 2025-11-18 21:02</div>
            <div class="timeline-body"><p>ðŸŽ‰</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-11-18 21:12</div>
            <div class="timeline-body"><p>This is lovely!</p>
<p>My only questions fall into the category of &quot;constrained typevars are weird&quot; and can be punted to later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-11-18 22:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-18 22:33</div>
            <div class="timeline-body"><p>Ah yes, come to think of it, this is where we talked way back about how we might get more than one possible specialization. That seems like the better way to model this â€” multiple satisfiable paths in the BDD leads to an ambiguous result (and we can give you all of them if you want them), not to the union of those results.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-11-18 22:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-18 22:37</div>
            <div class="timeline-body"><p>Well I would distinguish between constrained typevars and others here. For bounded or unbounded typevars, I like the union type resulting from multiple ORed constraints! I don't think that should go to Unknown. But I do think that if we can't pick one of the constrained types for a constrained typevar, that should go to Unknown.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-11-19 13:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-19 13:55</div>
            <div class="timeline-body"><p>I think the unbounded example was incorrect, though. The constraint set is <code>T â‰¤ int âˆ¨ T â‰¤ str</code>, but <code>int | str</code> is not a subtype of <code>int</code> nor of <code>str</code>, so <code>T = int | str</code> is not a valid specialization. With the change that I'm introducing to handle constrained typevars, I now get <code>T = Never</code> as the specialization, which I think is the only correct one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-11-19 13:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-19 13:57</div>
            <div class="timeline-body"><p>(This is the unbounded example:)</p>
<p>https://github.com/astral-sh/ruff/blob/4327616df4480d11b2a2373cbd3968a4c304dc5c/crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md?plain=1#L44-L45</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-11-19 15:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:160 on 2025-11-19 15:32</div>
            <div class="timeline-body"><blockquote>
<p>It seems like the current approach takes as a requirement that we always solve to a fully static type, but I'm not sure that is what we should do, in the case of constrained type variables.</p>
</blockquote>
<p>Hmm, that is a good point. I would like to put in TODOs and handle that as follow-on work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-11-19 16:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-19 16:38</div>
            <div class="timeline-body"><blockquote>
<p>I think the unbounded example was incorrect, though. The constraint set is <code>T â‰¤ int âˆ¨ T â‰¤ str</code>, but <code>int | str</code> is not a subtype of <code>int</code> nor of <code>str</code>, so <code>T = int | str</code> is not a valid specialization.</p>
</blockquote>
<p>Oh yes, of course this is right.</p>
<blockquote>
<p>With the change that I'm introducing to handle constrained typevars, I now get <code>T = Never</code> as the specialization, which I think is the only correct one.</p>
</blockquote>
<p>Hmm, well it's clearly not the only correct solution, and definitely not the &quot;closest to <code>object</code> one&quot;? Aren't <code>T = int</code> and <code>T = str</code> both valid solutions for the constraint set <code>T â‰¤ int âˆ¨ T â‰¤ str</code>? (It's an OR, not an AND.) <code>Never</code> is a valid solution but doesn't seem like a useful one.</p>
<p>But now I see why it might make sense to specialize to <code>Unknown</code> in this case, too. We have two equally-good specialization options and no reason to pick one over the other, and either one we pick could lead to false positives.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-11-19 17:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-19 17:00</div>
            <div class="timeline-body"><blockquote>
<p>But now I see why it might make sense to specialize to <code>Unknown</code> in this case, too. We have two equally-good specialization options and no reason to pick one over the other, and either one we pick could lead to false positives.</p>
</blockquote>
<p>This maybe brings up a different question, which is the difference between a <em>useful</em> solution and a <em>valid</em> one. As I've written it, we do return a specialization for the unbounded example Â­â€” <code>T = Never</code>. (It's the only <em>single</em> specialization that satisfies all branches of the constraint set union.) That's different than the constrained typevar case, where we return <code>None</code>. So we wouldn't fall back on <code>T = Unknown</code> for the unbounded case.</p>
<p>This has come up in some of the other PRs, as well. Is <code>T = Never</code> ever a specialization we'd want to return? I've been arguing that if you don't want that as a specialization, you should be adding <code>T â‰  Never</code> as an additional constraint in your constraint set, and that the constraint set algorithms shouldn't pre-suppose that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-11-19 19:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/generics/specialize_constrained.md</code>:132 on 2025-11-19 19:00</div>
            <div class="timeline-body"><p>I'm honestly not sure on these questions without tying it back to real Python examples. It's not clear to me in what real-world scenarios we'd end up with a constraint set like <code>T â‰¤ int âˆ¨ T â‰¤ str</code>. So maybe it's better to leave this for a future PR with ecosystem results to look at.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-11-19 19:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-11-19 19:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-11-19 19:20</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:17:11 UTC
    </footer>
</body>
</html>
