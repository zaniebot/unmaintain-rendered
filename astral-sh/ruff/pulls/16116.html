<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Move `reveal_type`, `assert_type` handling out of `CallOutcome` - astral-sh/ruff #16116</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Move <code>reveal_type</code>, <code>assert_type</code> handling out of <code>CallOutcome</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16116">#16116</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2025-02-12 12:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 12:37</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Let's measure the temperture on how people feel about this ;)</p>
<p>Something I noticed about <code>CallOutcome</code> or more generally about <code>Type::call</code> is that we have to differentiate between three use cases:</p>
<ol>
<li>We want to type check a call expression</li>
<li>We want to type check a possibly implicit call (e.g. <code>a += 1</code> where this calls <code>__add__</code>)</li>
<li>We are only interested in what the function would return if called</li>
</ol>
<p>This PR moves the code only relevant to 1 out of <code>CallOutcome</code> and into <code>infer_call_expression</code> instead.
It simplifies the <code>CallOutcome</code> struct overall and I, as a reader, find it easier to reason about which logic
applies where.</p>
<h2>Test Plan</h2>
<p><code>cargo test</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2025-02-12 12:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-02-12 12:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/call.rs</code>:242 on 2025-02-12 12:40</div>
            <div class="timeline-body"><p>I don't know how relevant this is and if it's worth supporting. I think the following would require the union handling:</p>
<pre><code class="language-py">if coinflip():
	a = reveal_type
else:
	a = something_else

a(a) 
</code></pre>
<p>We, obviously could still support this by moving the union case handling into <code>infer_call_expression</code> too, but I honestly don't think it's worth the complexity (and there's no test)</p>
<p>Also note that we didn't support this for static assertions... so it was sort of inconsistent already</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @MichaReiser on 2025-02-12 12:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @MichaReiser on 2025-02-12 12:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @MichaReiser on 2025-02-12 12:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @MichaReiser on 2025-02-12 12:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 12:46</div>
            <div class="timeline-body"><p>I don't plan on merging this immediately even if people think this is a good idea. I mainly want to get feedback on the direction and if, deemed acceptable, continue in the direction of reducing <code>Type::call</code> to only handle the 3rd case and see how that goes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 12:49</div>
            <div class="timeline-body"><p>To extend a bit on 3. I think it's useful if <code>Type::call</code> returns a struct that holds enough information to create a diagnostic from it. But I think we should remove all methods that take an <code>InferContext</code> from <code>CallOutcome</code> and move them somewhere into <code>infer_</code></p>
<p>The reason I'm leaning in this direction is that I currently find it hard to decide which of the <code>CallOutcome</code> methods I have to use and why.</p>
<p>Will this work, I don't know.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3273 on 2025-02-12 13:07</div>
            <div class="timeline-body"><p>you could possibly do one more early return here:</p>
<pre><code class="language-suggestion">        };
        
        let Some(known_function) = function_type.known(self.db()) else {
            return;
        }

        match known_function {
            KnownFunction::RevealType =&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-02-12 13:08</div>
            <div class="timeline-body"><p>This is an excellent simplification. Thank you.</p>
<blockquote>
<pre><code class="language-py">if coinflip():
    a = reveal_type
else:
    a = something_else

a(a)
</code></pre>
</blockquote>
<p>Yeah, I don't think we need to support this. Neither mypy or pyright does, and it doesn't seem worth the extra complexity. There's no plausible use-case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-12 15:13</div>
            <div class="timeline-body"><p>I'm looking into moving out <code>len</code> next. It's an interesting challenge on how to do that without duplicating all code</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3346 on 2025-02-12 15:19</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                if truthiness.is_always_true() {
                    return call;
                }

                if let Some(message) = message.into_string_literal().map(|s| &amp;**s.value(self.db()))
                {
                    self.context.report_lint(
                        &amp;STATIC_ASSERT_ERROR,
                        call_expression.into(),
                        format_args!(&quot;Static assertion error: {message}&quot;),
                    );
                } else if parameter_ty == Type::BooleanLiteral(false) {
                    self.context.report_lint(
                        &amp;STATIC_ASSERT_ERROR,
                        call_expression.into(),
                        format_args!(&quot;Static assertion error: argument evaluates to `False`&quot;),
                    );
                } else if truthiness.is_always_false() {
                    self.context.report_lint(
                        &amp;STATIC_ASSERT_ERROR,
                        call_expression.into(),
                        format_args!(
                            &quot;Static assertion error: argument of type `{parameter_ty}` is statically known to be falsy&quot;,
                            parameter_ty=parameter_ty.display(self.db())
                        ),
                    );
                } else {
                    self.context.report_lint(
                        &amp;STATIC_ASSERT_ERROR,
                        call_expression.into(),
                        format_args!(
                            &quot;Static assertion error: argument of type `{parameter_ty}` has an ambiguous static truthiness&quot;,
                            parameter_ty=parameter_ty.display(self.db())
                        ),
                    );
                }
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-02-12 15:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3255 on 2025-02-12 18:43</div>
            <div class="timeline-body"><p>The name <code>check_call</code> doesn't seem right here, as most of the important &quot;call checking&quot; happens outside this method, this method just handles special cases for a few particular known callables. I'm not sure what better name to suggest, which I think raises some question about whether this change adds clarity to the structure of the code. The right name also depends partly on what all we intend to ultimately try to move out here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-02-12 19:07</div>
            <div class="timeline-body"><p>I'm OK with this change as a standalone change (because it pulls some complexity out of <code>CallOutcome</code> and <code>Type::call</code>, in exchange for losing some precision that doesn't matter at all), but I don't see it as clarifying a broader direction for how we handle call checking or outcomes of type operations, which seems like maybe the opposite of your intent with the PR :)</p>
<p>Strictly speaking, this is a semantic regression, because it means we no longer &quot;recognize&quot; <code>reveal_type</code> and friends wherever we might happen to call them, but only if they are directly called, not as part of a union, and not in an implicit call. I don't think this matters at all in practice (there is no reasonable use case either for <code>reveal_type</code> to be in a union, or for something like <code>__bool__ = reveal_type</code> that would result in an implicit call to it), but it makes me question whether this generalizes at all beyond a few &quot;special&quot; functions where we are OK with being more limited.</p>
<p>I think this semantic &quot;regression&quot; corresponds to the lack of clarity for me about how the code structure is supposed to correlate to the Python semantics, and therefore also what we should name the new method. Before it was IMO more clear: <code>Type::call</code> and its return value should encapsulate all of the results, both in terms of needed diagnostics and in terms of return type, of calling any Python object. If we are going to split that up in some way, I don't yet understand the semantics of the intended split.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-12 19:14</div>
            <div class="timeline-body"><blockquote>
<p>I'm OK with this change as a standalone change (because it pulls some complexity out of <code>CallOutcome</code> and <code>Type::call</code>, in exchange for losing some precision that doesn't matter at all), but I don't see it as clarifying a broader direction for how we handle call checking or outcomes of type operations</p>
</blockquote>
<p>That's actually why I kinda like the PR. Figuring out a Big Picture for how to solve the overall problem is Hard. Breaking out somewhat isolated simplifications like this where they make sense makes it easier to analyse the rest of the problem and think about it in isolation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-02-13 09:07</div>
            <div class="timeline-body"><blockquote>
<p>I'm OK with this change as a standalone change (because it pulls some complexity out of CallOutcome and Type::call, in exchange for losing some precision that doesn't matter at all), but I don't see it as clarifying a broader direction for how we handle call checking or outcomes of type operations, which seems like maybe the opposite of your intent with the PR :)</p>
</blockquote>
<p>I'm also not sure where this goes long term but the second half of your comment already gives me some signal. So I still think this was useful :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2025-02-14 14:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:57:53 UTC
    </footer>
</body>
</html>
