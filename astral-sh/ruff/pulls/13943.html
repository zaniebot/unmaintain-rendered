<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Infer `tuple` types from annotations - astral-sh/ruff #13943</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Infer <code>tuple</code> types from annotations</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13943">#13943</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-10-27 21:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-27 21:56</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR adds support for heterogenous <code>tuple</code> annotations to red-knot.</p>
<p>I initially thought that this might be useful for <code>sys.version_info</code> support... now that I look again, I'm not sure that it <em>is</em> actually useful for that. Anyway, still a useful feature, and one we'd have had to implement anyway!</p>
<p>The PR does the following:</p>
<ul>
<li>Extends <code>infer_type_expression</code> so that it understands tuple annotations</li>
<li>Changes <code>infer_type_expression</code> so that <code>ExprStarred</code> nodes in type annotations are inferred as <code>Todo</code> rather than <code>Unknown</code> (they're valid in PEP-646 tuple annotations)</li>
<li>Extends <code>Type::is_subtype_of</code> to understand when one heterogenous tuple type can be understood to be a subtype of another (without this change, the PR would have introduced new false-positive errors to some existing mdtests).</li>
</ul>
<h2>Test Plan</h2>
<ul>
<li>mdtests added to <code>assignment/annotations.md</code></li>
<li><code>is_subtype_of</code> unit tests have been added to <code>types.rs</code></li>
<li>I verified that the PR produces no new false positives in the red-knot benchmarks.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-10-27 21:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-10-27 21:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-10-27 21:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-27 22:50</div>
            <div class="timeline-body"><p>No idea what's up with those CI errors; they don't really seem to be anything to do with this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-28 07:21</div>
            <div class="timeline-body"><blockquote>
<p>No idea what's up with those CI errors; they don't really seem to be anything to do with this PR</p>
</blockquote>
<p>This should be fixed now. Cargo insta made the <code>--unreferenced-snapshots</code> detection more correct and that caught a few unreferenced snapshot in our repository. @dhruvmanila deleted them on main, so you should be good to go</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:478 on 2024-10-28 07:28</div>
            <div class="timeline-body"><p>Nit: Not sure if Rustc can deduplicate the <code>self_tuple.elements(db).len()</code> (inlined <code>len</code>) and the <code>self_tuple(db)</code> because of the dyn <code>Db</code>.</p>
<pre><code class="language-suggestion">								let self_elements = self_tuple.elements(db);
								let target_elements = target_tuple.elements(db);
								
                self_elements.len(db) == target_elements.len(db)
                    &amp;&amp; self_elements
                        .iter()
                        .zip(target_elements)
                        .all(|(self_element, target_element)| {
                            self_element.is_subtype_of(db, *target_element)
                        })
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3510 on 2024-10-28 07:29</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                            let mut elements = Vec::with_capacity(tuple.elements.len());
</code></pre>
<p>or use collect?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3514 on 2024-10-28 07:32</div>
            <div class="timeline-body"><p>I thought we only use <code>Todo</code> if the inference itself is directly the consequence of something we aren't handling but not when we continue deriving other types from it... which seems to be the case here?</p>
<p>I think I would prefer a type <code>(str, Todo, int)</code> over just <code>Todo</code> because this gives me less information where the <code>Todo</code> is coming from and makes it harder to track down</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-28 07:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-28 07:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3514 on 2024-10-28 07:45</div>
            <div class="timeline-body"><p>The issue here is that certain parameters can change the meaning of the entire tuple. If we only inferred Todo for a subelement of a tuple here, we'd interpret the annotation <code>tuple[str, ...]</code> as <code>tuple[str, Todo]</code> which means &quot;a tuple of length two where the first element is a <code>str</code> and the second element is todo&quot;. But that's flat-out wrong — <code>tuple[str, ...]</code> actually means &quot;a tuple of arbitrary length, in which all elements in the tuple are instances of <code>str</code>&quot; — the <code>...</code> changes the meaning of the entire tuple (it becomes a homogenous tuple rather than a heterogeneous tuple, and we <a href="https://github.com/astral-sh/ruff/issues/13855">don't support homogenous tuples yet</a>).</p>
<p>Hmmm... But maybe I can limit the situations where we return Todo for the entire tuple to certain special elements that we know change the meaning of the entire tuple... And just infer Todo for subelements rather than the whole tuple otherwise.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-28 10:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3514 on 2024-10-28 10:34</div>
            <div class="timeline-body"><p>I made this change. It didn't really make <em>much</em> impact, because even <code>Unpack[tuple[int, ...]]</code> as a subelement can change the meaning of the entire tuple, so we still need to infer <code>Todo</code> for the entire tuple if an <code>Expr::Subscript</code> is found in the tuple that we infer to be <code>Todo</code>. But, there are now a few more tuples where we only infer <code>Todo</code> for a subelement rather than the whole tuple. And, I made the comments more expansive to explain why we need to do it this way :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-28 10:46</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md</code>:63 on 2024-10-28 21:32</div>
            <div class="timeline-body"><p>nit: when I saw this header, I expected to find &quot;incorrect tuple annotations&quot;, as in invalid tuple annotation forms. What I found instead I would describe as &quot;invalid tuple assignments&quot;</p>
<pre><code class="language-suggestion">## Incorrect tuple assignments are complained about
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics.md</code>:21 on 2024-10-28 21:33</div>
            <div class="timeline-body"><p>If we're editing this message anyway, let's use language from the Python typing spec instead of Hindley-Milner language</p>
<pre><code class="language-suggestion"># TODO should emit a diagnostic here (str is not assignable to int)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:472 on 2024-10-28 21:37</div>
            <div class="timeline-body"><p>This raises interesting questions about how we handle union-of-tuples vs tuple-of-unions, as in, the equivalence of <code>tuple[int, str | int]</code> to <code>tuple[int, str] | tuple[int, int]</code>. I'm not sure how important it is that we understand this (I don't think existing type checkers do, but it would be cool if we did.)</p>
<p>We could try to normalize this one way or another in type construction, at the cost of less fidelity to original annotation forms. Or we could try to handle it here, at potentially a high complexity cost. Or we could decide not to handle it at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3766 on 2024-10-28 21:40</div>
            <div class="timeline-body"><p>A sizable percentage of this entire function ends up being Todo-handling. All else equal, I'd rather not write tons of extra code for accurate handling of Todos, since medium-term they should disappear. But on the other hand, I think this still falls on the &quot;probably worth it for debugging value&quot; side of the line.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-28 21:41</div>
            <div class="timeline-body"><p>Looks great, thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-28 22:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:472 on 2024-10-28 22:57</div>
            <div class="timeline-body"><p>(To be clear, I don't think we need to do any of this in this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-29 10:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:472 on 2024-10-29 10:22</div>
            <div class="timeline-body"><p>Yeah, this is an interesting question... I'd be curious to see examples of exactly which things we <em>should</em> infer (and <em>would</em> infer if we understood this expansion), but don't currently</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2024-10-29 10:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-10-29 10:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-29 10:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-29 11:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:472 on 2024-10-29 11:45</div>
            <div class="timeline-body"><p>I think it's less about inference and more about simple assignability. If a function parameter is annotated as the one type and you pass it an argument that ends up getting inferred as the other, that call should be accepted but existing type checkers won't accept it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:472 on 2024-10-29 11:46</div>
            <div class="timeline-body"><p>Ah, makes sense</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-29 11:46</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:57:29 UTC
    </footer>
</body>
</html>
