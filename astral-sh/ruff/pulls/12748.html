<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add scope and definitions for comprehensions - astral-sh/ruff #12748</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add scope and definitions for comprehensions</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12748">#12748</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2024-08-08 10:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>This PR adds scope and definition for comprehension nodes. This includes the following nodes:</p>
<ul>
<li>List comprehension</li>
<li>Dictionary comprehension</li>
<li>Set comprehension</li>
<li>Generator expression</li>
</ul>
Scope
<p>Each expression here adds it&#x27;s own scope with one caveat - the <code>iter</code> expression of the first generator is part of the parent scope. For example, in the following code snippet the <code>iter1</code> variable is evaluated in the outer scope.</p>
<pre><code>[x for x in iter1]
</code></pre>
<blockquote>
<p>The iterable expression in the leftmost for clause is evaluated directly in the enclosing scope and then passed as an argument to the implicitly nested scope.</p>
<p>Reference: https://docs.python.org/3/reference/expressions.html#displays-for-lists-sets-and-dictionaries</p>
</blockquote>
<p>There&#x27;s another special case for assignment expressions:</p>
<blockquote>
<p>There is one special case: an assignment expression occurring in a list, set or dict comprehension or in a generator expression (below collectively referred to as “comprehensions”) binds the target in the containing scope, honoring a nonlocal or global declaration for the target in that scope, if one exists.</p>
<p>Reference: https://peps.python.org/pep-0572/#scope-of-the-target</p>
</blockquote>
<p>For example, in the following code snippet, the variables <code>a</code> and <code>b</code> are available after the comprehension while <code>x</code> isn&#x27;t:</p>
<pre><code>[a := 1 for x in range(2) if (b := 2)]
</code></pre>
Definition
<p>Each comprehension node adds a single definition, the &quot;target&quot; variable (<code>[_ for target in iter]</code>). This has been accounted for and a new variant has been added to <code>DefinitionKind</code>.</p>
Type Inference
<p>Currently, type inference is limited to a single scope. It doesn&#x27;t <em>enter</em> in another scope to infer the types of the remaining expressions of a node. To accommodate this, the type inference for a <strong>scope</strong> requires new methods which <em>doesn&#x27;t</em> infer the type of the <code>iter</code> expression of the leftmost outer generator (that&#x27;s defined in the enclosing scope).</p>
<p>The type inference for the scope region is split into two parts:</p>
<ul>
<li><code>infer_generator_expression</code> (similarly for comprehensions) infers the type of the <code>iter</code> expression of the leftmost outer generator</li>
<li><code>infer_generator_expression_scope</code> (similarly for comprehension) infers the type of the remaining expressions except for the one mentioned in the previous point</li>
</ul>
<p>The type inference for the <strong>definition</strong> also needs to account for this special case of leftmost generator. This is done by defining a <code>first</code> boolean parameter which indicates whether this comprehension definition occurs first in the enclosing expression.</p>
Test Plan
<p>New test cases were added to validate multiple scenarios. Refer to the documentation for each test case which explains what is being tested.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-08 10:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-08-09 10:01</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 10:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 10:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 10:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 10:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 15:03</div>
            <div class="timeline-body"><p>(I&#x27;m planning to look at the diagnostics difference in the benchmark today)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:533 on 2024-08-09 15:57</div>
            <div class="timeline-body"><pre><code>    /// Test case to validate that the generator scope is correctly identified and that the target
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:661 on 2024-08-09 16:08</div>
            <div class="timeline-body"><p>I think the cleaner way to handle assignment expressions inside a comprehension will be to still record the name and the definition inside the comprehension scope, but mark the name as nonlocal (as if there were implicitly a <code>nonlocal a</code> statement in that scope.) I think this is also necessary for correctness in cases where the assigned name is also used within the comprehension.</p>
<p>This will really just become a <code>TODO</code> as currently we don&#x27;t yet have handling in general for the <code>nonlocal</code> statement or nonlocal name references.</p>
<p>So for now I would probably just remove this test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:28 on 2024-08-09 16:10</div>
            <div class="timeline-body"><p>I would merge this with the existing <code>use crate::semantic_index::definition::{...}</code> statement above.</p>
<p>Perhaps we should generally use <code>super::</code> for imports from <code>crate::semantic_index</code> instead (I wouldn&#x27;t mind that change) but within a given file I&#x27;d rather stay consistent one way or another and keep the imports together.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:189 on 2024-08-09 16:11</div>
            <div class="timeline-body"><p>As mentioned in the other comment, I think we should remove this logic.</p>
<p>We could add a TODO for handling assignment expressions inside comprehensions as nonlocal names. Maybe somewhere down with the comprehension-visit methods?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:177 on 2024-08-09 16:12</div>
            <div class="timeline-body"><p>Hmm, why is this annotation now required?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-09 17:19</div>
            <div class="timeline-body"><p>I added the filename/line/column information to diagnostics (still a string), and all checks out.</p>
<p>The following two diagnostics are removed (valid):</p>
<pre>
<a href="https://github.com/python/cpython/blob/591f6754b56cb7f6c31fce8c22528bdf0a99556c/Lib/tomllib/_parser.py#L22">tomllib/_parser.py:22:28: Name &#x27;i&#x27; used when not defined.</a>
<a href="https://github.com/python/cpython/blob/591f6754b56cb7f6c31fce8c22528bdf0a99556c/Lib/tomllib/_parser.py#L330">tomllib/_parser.py:330:46: Name &#x27;i&#x27; used when not defined.</a>
</pre>

<p>And, the following got added:</p>
<pre>
<a href="https://github.com/python/cpython/blob/591f6754b56cb7f6c31fce8c22528bdf0a99556c/Lib/tomllib/_parser.py#L330">tomllib/_parser.py:330:41: Name &#x27;key&#x27; used when not defined.</a>
</pre>

<p>The one that got added is because type inference is done at the scope level, so the <code>key</code> variable is not defined in the generator scope but in the enclosing scope.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:187 on 2024-08-09 17:40</div>
            <div class="timeline-body"><p>As elsewhere, <code>Comprehension</code> not <code>Generator</code>.</p>
<p>I&#x27;m torn about whether we should have a separate scope kind here or just use <code>ScopeKind::Function</code>. But I think this will be useful when we do need to implement the special case about assignment expressions in comprehensions; otherwise we&#x27;d just need to keep separate state on the semantic index builder that the current scope is a comprehension.</p>
<p>But we should add this scope kind to <code>ScopeId::is_function_like</code> above, since otherwise comprehension scopes just behave like function scopes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:691 on 2024-08-09 17:45</div>
            <div class="timeline-body"><p>Throughout this PR, we should use &quot;Comprehension&quot; instead of &quot;Generator&quot; as the general term covering list/dict/set/generator comprehensions.</p>
<p>A generator in Python is a specific kind of iterator object, which also has <code>send()</code> and <code>throw()</code> methods, which is created either using a generator expression / generator comprehension, or by defining a function that uses the <code>yield</code> keyword.</p>
<p>List/dict/set comprehensions are not generators. Generator expressions can also be referred to as &quot;generator comprehensions&quot;; a generator expression / generator comprehension is the expression syntax for defining a generator (as opposed to the function-that-yields syntax.)</p>
<p>The use of the term &quot;generator&quot; in the Python AST (and our AST) for &quot;the things inside a comprehension that iterate and generate values&quot; is perhaps a bit unfortunate, because it&#x27;s overloading the term to describe something different than what &quot;generator&quot; usually means in Python.</p>
<p>The upshot of all this:</p>
<ul>
<li>it&#x27;s fine to keep <code>visit_generator</code> etc in the builder as-is; this is just using the term as it&#x27;s already used in the AST, to describe this particular piece of syntax inside a comprehension.</li>
<li>everywhere else (definitions, symbol table, etc) we should use <code>Comprehension</code>, not <code>Generator</code>, as the general term encompassing list/dict/set/generator comprehensions.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:47 on 2024-08-09 17:55</div>
            <div class="timeline-body"><p><code>Comprehension</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:111 on 2024-08-09 17:55</div>
            <div class="timeline-body"><p><code>ComprehensionDefinitionNodeRef</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:184 on 2024-08-09 17:55</div>
            <div class="timeline-body"><p><code>Comprehension</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:133 on 2024-08-09 17:56</div>
            <div class="timeline-body"><p>Technically it would be better to use <code>GeneratorExpression</code> or <code>GeneratorComprehension</code> here, not just <code>Generator</code>, since this doesn&#x27;t include &quot;function that yields&quot; syntax.</p>
<p>It&#x27;s kind of a toss-up which one to use; they are more commonly called &quot;generator expressions&quot;, but &quot;generator comprehension&quot; highlights the parallel to other kinds of comprehensions better. I&#x27;m fine with whichever you prefer; if you don&#x27;t care I guess I&#x27;d go with <code>GeneratorComprehension</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:317 on 2024-08-09 17:58</div>
            <div class="timeline-body"><p><code>GeneratorExpression</code> or <code>GeneratorComprehension</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:418 on 2024-08-09 17:59</div>
            <div class="timeline-body"><p><code>GeneratorExpression</code> or <code>GeneratorComprehension</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:432 on 2024-08-09 17:59</div>
            <div class="timeline-body"><p><code>GeneratorExpression</code> or <code>GeneratorComprehension</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:264 on 2024-08-09 18:02</div>
            <div class="timeline-body"><p>I prefer these method names without the word &quot;in&quot;, e.g. <code>infer_list_comprehension_expression_scope</code>. Using &quot;in&quot; almost seems to communicate the opposite of what we want. What distinguishes these methods is that they infer the comprehension scope, not the comprehension in its containing scope.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1080 on 2024-08-09 18:03</div>
            <div class="timeline-body"><pre><code>            unreachable!(&quot;Comprehension must contain at least one generator&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1189 on 2024-08-09 18:04</div>
            <div class="timeline-body"><pre><code>            unreachable!(&quot;Comprehension must contain at least one generator&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1095 on 2024-08-09 18:07</div>
            <div class="timeline-body"><p>We could update this to return <code>typing.Generator</code>, and similarly below for <code>builtins.dict</code>, <code>builtins.list</code>, <code>builtins.set</code>. It should be a fairly simple change to resolve the type from typeshed.</p>
<p>But I don&#x27;t feel strongly about whether we do that in this PR or not, since we&#x27;d still have a TODO to make it generic and properly infer the contained type, once we have generic types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1197 on 2024-08-09 18:13</div>
            <div class="timeline-body"><p>This method should look up the definition and use <code>infer_definition_types</code> query here (thus ending up in <code>infer_comprehension_definition</code> to actually do the work), otherwise we&#x27;ll end up repeating inference of the same comprehension, once in the scope-level query and once in the definition-level query. You can use the existing helper <code>infer_definition</code> to do this; see e.g. <code>infer_function_definition_statement</code> for an existing case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1218 on 2024-08-09 18:16</div>
            <div class="timeline-body"><p>Might be good to add a TODO here just to remind us that actually the <code>target</code> type should (later, not in this PR) be inferred by getting the item type of the (iterable) type of <code>iter</code>, not by an <code>infer_expression</code> call.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-08-09 18:17</div>
            <div class="timeline-body"><p>This is great, thanks for figuring out so much just by reading the code, which isn&#x27;t always as documented as it should be!</p>
<p>A few changes I think we should make (mostly to naming, a couple functional things), but the basic structure is exactly right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-09 18:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:691 on 2024-08-09 18:20</div>
            <div class="timeline-body"><blockquote>
<p>The use of the term &quot;generator&quot; in the Python AST (and our AST)</p>
</blockquote>
<p>We differ from CPython&#x27;s AST in quite a few ways at this point; we could easily rename this field to something less confusing (but obviously not in this PR)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-09 18:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1095 on 2024-08-09 18:22</div>
            <div class="timeline-body"><blockquote>
<p>We could update this to return <code>typing.Generator</code>, and similarly below for <code>builtins.dict</code>, <code>builtins.list</code>, <code>builtins.set</code>. It should be a fairly simple change to resolve the type from typeshed.</p>
</blockquote>
<p>Generators are actually somewhat interesting because do you infer the abstract type (<code>typing.Generator</code>) or the concrete type (<code>types.GeneratorType</code>)? I think mypy does the former and it causes issues... can&#x27;t remember what pyright does...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-09 18:28</div>
            <div class="timeline-body"><blockquote>
<p>The one that got added is because type inference is done at the scope level, so the <code>key</code> variable is not defined in the generator scope but in the enclosing scope.</p>
</blockquote>
<p>Yes, this is just part of our larger TODO item to support nonlocal name references; currently we support local and global, but not nonlocal yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-09 18:30</div>
            <div class="timeline-body"><blockquote>
<p>I added the filename/line/column information to diagnostics (still a string), and all checks out.</p>
</blockquote>
<p>Want to push this as a PR? I think it&#x27;s generally useful. The specific current diagnostics won&#x27;t survive Micha&#x27;s planned work for next week, but the code to include this information in diagnostics could survive the transition.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-08-09 18:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1095 on 2024-08-09 18:33</div>
            <div class="timeline-body"><p>Oh, yeah... I think probably the concrete type (<code>types.GeneratorType</code>) is better, since in this case we know for sure it is the built-in Generator type, not something else that just implements the interface.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 06:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:661 on 2024-08-12 06:28</div>
            <div class="timeline-body"><p>Yeah, I think that makes sense specifically for &quot;necessary for correctness in cases where the assigned name is also used within the comprehension.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 06:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:28 on 2024-08-12 06:31</div>
            <div class="timeline-body"><p>Yeah, I generally prefer to use <code>crate::</code> for imports from the current crate and using <code>super::</code> only when it&#x27;s from the parent directory and not exposed to the crate. That said, I didn&#x27;t really add this import, it was <code>rust-analyzer</code> that did it when I accepted the completion ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 06:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:177 on 2024-08-12 06:32</div>
            <div class="timeline-body"><p>It&#x27;s not really required to compile the code but rust-analyzer wasn&#x27;t able to infer the type of <code>definition_node</code> variable in this context (not sure why).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 06:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:691 on 2024-08-12 06:37</div>
            <div class="timeline-body"><p>Thanks for the explanation between the two. This really helps in clarifying where to use one and the other. I think what you say makes sense and I&#x27;ll update the wording to use &quot;comprehension&quot; in most places.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 06:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:133 on 2024-08-12 06:41</div>
            <div class="timeline-body"><p>I don&#x27;t mind using <code>GeneratorComprehension</code> although I couldn&#x27;t find any reference to &quot;generator comprehension&quot; in the Python documentation. I don&#x27;t really mind the inconsistency as it clearly highlights the syntax that this variant represents. I&#x27;m leaning towards <code>GeneratorExpression</code> for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 06:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:187 on 2024-08-12 06:51</div>
            <div class="timeline-body"><blockquote>
<p>But we should add this scope kind to <code>ScopeId::is_function_like</code> above, since otherwise comprehension scopes just behave like function scopes.</p>
</blockquote>
<p>Isn&#x27;t that changed with <a href="https://peps.python.org/pep-0709/">PEP 709 - Inlined comprehensions</a> in Python 3.12?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-12 07:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:187 on 2024-08-12 07:24</div>
            <div class="timeline-body"><blockquote>
<p>Isn&#x27;t that changed with <a href="https://peps.python.org/pep-0709/">PEP 709 - Inlined comprehensions</a> in Python 3.12?</p>
</blockquote>
<p>The internal implementation in CPython no longer uses a function object for these scopes, following the changes Carl made to implement PEP 709. But the user-facing behaviour is the same in 99% of situations; semantically, they still behave like function scopes in almost every way</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-08-12 07:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:187 on 2024-08-12 07:32</div>
            <div class="timeline-body"><p>I see, that makes sense. Thanks for clarifying.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-12 11:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-08-12 16:10</div>
            <div class="timeline-body"><a href="https://codspeed.io/astral-sh/ruff/branches/dhruv/comprehension-red-knot">CodSpeed Performance Report</a>
Merging #12748 will <strong>not alter performance</strong>
<p>Comparing <code>dhruv/comprehension-red-knot</code> (e904b8d) with <code>main</code> (fb9f0c4)</p>
Summary
<p><code>✅ 32</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-12 16:14</div>
            <div class="timeline-body"><p>(Updated the number of expected diagnostics for the Red Knot benchmark per the analysis in <a href="https://github.com/astral-sh/ruff/pull/12748">astral-sh/ruff#12748</a>#issuecomment-2278398925)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:536 on 2024-08-12 16:56</div>
            <div class="timeline-body"><p>Nit: for clarity, we should use &quot;comprehension&quot; rather than &quot;generator&quot; in the name of this test, its doc comment, and in variable names throughout the test.</p>
<p>Same in some other tests below.</p>
<pre><code>    /// Test case to validate that the comprehension scope is correctly identified and that the target
    /// variable is defined only in the comprehension scope and not in the outer scope.
    #[test]
    fn comprehension_scope() {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:563 on 2024-08-12 16:57</div>
            <div class="timeline-body"><pre><code>        let [(comprehension_scope_id, comprehension_scope)] = index
            .child_scopes(FileScopeId::global())
            .collect::&lt;Vec&lt;_&gt;&gt;()[..]
        else {
            panic!(&quot;expected one child scope&quot;)
        };

        assert_eq!(comprehension_scope.kind(), ScopeKind::Comprehension);
        assert_eq!(
            comprehension_scope_id.to_scope_id(&amp;db, file).name(&amp;db),
            &quot;&lt;listcomp&gt;&quot;
        );

        let comprehension_symbol_table = index.symbol_table(comprehension_scope_id);

        assert_eq!(names(&amp;comprehension_symbol_table), vec![&quot;x&quot;]);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:567 on 2024-08-12 16:57</div>
            <div class="timeline-body"><pre><code>    /// Test case to validate that the `x` variable used in the comprehension is referencing the `x`
    /// variable defined by the inner generator (`for x in iter2`) and not the outer one.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:607 on 2024-08-12 16:59</div>
            <div class="timeline-body"><pre><code>        let [(comprehension_scope_id, _)] = index
            .child_scopes(FileScopeId::global())
            .collect::&lt;Vec&lt;_&gt;&gt;()[..]
        else {
            panic!(&quot;expected one child scope&quot;)
        };

        let use_def = index.use_def_map(comprehension_scope_id);

        let module = parsed_module(&amp;db, file).syntax();
        let element = module.body[0]
            .as_expr_stmt()
            .unwrap()
            .value
            .as_list_comp_expr()
            .unwrap()
            .elt
            .as_name_expr()
            .unwrap();
        let element_use_id = element.scoped_use_id(&amp;db, comprehension_scope_id.to_scope_id(&amp;db, file));

        let [definition] = use_def.use_definitions(element_use_id) else {
            panic!(&quot;expected one definition&quot;)
        };
        let DefinitionKind::Comprehension(comprehension) = definition.node(&amp;db) else {
            panic!(&quot;expected comprehension definition&quot;)
        };
        let ast::Comprehension { target, .. } = comprehension.node();
        let name = target.as_name_expr().unwrap().id().as_str();

        assert_eq!(name, &quot;x&quot;);
        assert_eq!(target.range(), TextRange::new(23.into(), 24.into()));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:567 on 2024-08-12 17:00</div>
            <div class="timeline-body"><p>This test name is correct, given the current terminology used in the AST; it is testing multiple &quot;generators&quot; in a comprehension. But there are some uses of &quot;generator&quot; in variable names within the test that are not accurate; using &quot;generator&quot; where we mean &quot;comprehension.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:614 on 2024-08-12 18:56</div>
            <div class="timeline-body"><pre><code>    /// Test case to validate that the nested comprehension creates a new scope which is a child of the
    /// outer comprehension scope and the variables are correctly defined in the respective scopes.
    #[test]
    fn nested_generators() {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:567 on 2024-08-12 18:57</div>
            <div class="timeline-body"><p>Oh and this is a very minor nit, but I think in these test case doc comments you could eliminate the entire phrase &quot;Test case to validate that&quot; without losing anything.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:657 on 2024-08-12 19:09</div>
            <div class="timeline-body"><pre><code>        let [(comprehension_scope_id, comprehension_scope)] = index
            .child_scopes(FileScopeId::global())
            .collect::&lt;Vec&lt;_&gt;&gt;()[..]
        else {
            panic!(&quot;expected one child scope&quot;)
        };

        assert_eq!(comprehension_scope.kind(), ScopeKind::Comprehension);
        assert_eq!(
            comprehension_scope_id.to_scope_id(&amp;db, file).name(&amp;db),
            &quot;&lt;listcomp&gt;&quot;
        );

        let comprehension_symbol_table = index.symbol_table(comprehension_scope_id);

        assert_eq!(names(&amp;comprehension_symbol_table), vec![&quot;y&quot;, &quot;iter2&quot;]);

        let [(inner_comprehension_scope_id, inner_comprehension_scope)] =
            index.child_scopes(comprehension_scope_id).collect::&lt;Vec&lt;_&gt;&gt;()[..]
        else {
            panic!(&quot;expected one inner comprehension scope&quot;)
        };

        assert_eq!(inner_comprehension_scope.kind(), ScopeKind::Comprehension);
        assert_eq!(
            inner_comprehension_scope_id.to_scope_id(&amp;db, file).name(&amp;db),
            &quot;&lt;setcomp&gt;&quot;
        );

        let inner_comprehension_symbol_table = index.symbol_table(inner_comprehension_scope_id);

        assert_eq!(names(&amp;inner_comprehension_symbol_table), vec![&quot;x&quot;]);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:262 on 2024-08-12 19:11</div>
            <div class="timeline-body"><pre><code>    /// Visit a list of [`Comprehension`] nodes, assumed to be the &quot;generators&quot; that compose a
    /// comprehension (that is, the `for x in y` and `for y in z` parts of `x for x in y for y in z`.)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-08-12 19:14</div>
            <div class="timeline-body"><p>Looks great! Just a few naming things left to clean up, mostly in the tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-13 01:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-08-13 01:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-13 01:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:05:49 UTC
    </footer>
</body>
</html>
