<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement Pylint's `cyclic-import` rule (`PLR0401`) - astral-sh/ruff #3880</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement Pylint's <code>cyclic-import</code> rule (<code>PLR0401</code>)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/3880">#3880</a>
        opened by <a href="https://github.com/chanman3388">@chanman3388</a>
        on 2023-04-05 00:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a></div>
            <div class="timeline-body"><p>Implement https://pylint.pycqa.org/en/v2.13.9/messages/refactor/cyclic-import.html
Issue #970</p>
<p>The principle here is we utilise the <code>ImportMap</code> to traverse the modules which may or may not import each other. When a module has all its imported modules checked, it is counted as 'fully visited'.
When considering a traversed path, each module imported along the way is kept in a stack, a cycle is detected when the module we're currently inspecting is already contained within this stack. The appropriate part of the stack is copied into a new <code>Vec</code> and pushed onto a <code>Vec</code> which contains all the cycles currently detected from the current module.</p>
<p>By the nature of the implementation, cycles of other modules traversed are detected, but these won't be reported immediately, instead stored in a <code>HashMap</code>. When the cyclic import rule is called, a check of whether we have already the cycles for this module is done to avoid duplicate work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-05 00:26</div>
            <div class="timeline-body"><p>Consider this file tree</p>
<pre><code>grand
├── __init__.py
├── a.py (from .parent.child import a; from .parent import a; from grand.parent.child import b)
└── parent
    ├── __init__.py
    ├── a.py (from .child import a, b; from .. import a)
    └── child
        ├── __init__.py
        ├── a.py (from .. import a; from ... import a)
        ├── b.py (from . import a)
        └── c.py --empty--
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-05 00:29</div>
            <div class="timeline-body"><p>Pylint outputs:</p>
<pre><code>************* Module grand.parent.child.b
grand/parent/child/b.py:2:0: W0611: Unused import a (unused-import)
grand/parent/child/b.py:1:0: R0401: Cyclic import (grand.parent.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/child/b.py:1:0: R0401: Cyclic import (grand.a -&gt; grand.parent.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/child/b.py:1:0: R0401: Cyclic import (grand.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/child/b.py:1:0: R0401: Cyclic import (grand.a -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/child/b.py:1:0: R0401: Cyclic import (grand.a -&gt; grand.parent.a) (cyclic-import)
grand/parent/child/b.py:1:0: R0401: Cyclic import (grand.parent.a -&gt; grand.parent.child.a) (cyclic-import)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-05 00:31</div>
            <div class="timeline-body"><p>Ruff outputs</p>
<pre><code>grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.child.a -&gt; grand.parent.a) (cyclic-import)
grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.child.a) (cyclic-import)
grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.a -&gt; grand.parent.child.a) (cyclic-import)
grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a -&gt; grand.parent.a) (cyclic-import)
grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.a) (cyclic-import)
grand/a.py:3:21: PLR0401 Cyclic import (grand.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a -&gt; grand.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.parent.child.a -&gt; grand.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.parent.child.b -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/a.py:2:23: PLR0401 Cyclic import (grand.parent.a -&gt; grand.a -&gt; grand.parent.child.a) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.parent.a) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.parent.a -&gt; grand.a -&gt; grand.parent.child.b) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.a) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.a -&gt; grand.parent.child.b) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.a -&gt; grand.parent.a) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.parent.a -&gt; grand.parent.child.b) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.a -&gt; grand.parent.a -&gt; grand.parent.child.b) (cyclic-import)
grand/parent/child/a.py:3:17: PLR0401 Cyclic import (grand.parent.child.a -&gt; grand.parent.a -&gt; grand.a) (cyclic-import)
grand/parent/child/b.py:2:15: PLR0401 Cyclic import (grand.parent.child.b -&gt; grand.parent.child.a -&gt; grand.a -&gt; grand.parent.a) (cyclic-import)
grand/parent/child/b.py:2:15: PLR0401 Cyclic import (grand.parent.child.b -&gt; grand.parent.child.a -&gt; grand.parent.a -&gt; grand.a) (cyclic-import)
grand/parent/child/b.py:2:15: PLR0401 Cyclic import (grand.parent.child.b -&gt; grand.parent.child.a -&gt; grand.a) (cyclic-import)
grand/parent/child/b.py:2:15: PLR0401 Cyclic import (grand.parent.child.b -&gt; grand.parent.child.a -&gt; grand.parent.a) (cyclic-import)
</code></pre>
<p>That is to say, that for each module, each cycle it is involved in will generate a message.
The example test data, I hope, is more complicated that one would ever come across in practice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @chanman3388 on 2023-04-05 00:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-05 00:46</div>
            <div class="timeline-body"><p>@charliermarsh I was going to add some more unittests, namely to test more complicated cycles and to test <code>pylint/rules/cyclic_import.rs#cyclic_import</code>, would we want to consider adding the functionality to add folders as fixtures parallel to this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-04-05 01:16</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Ecosystem</h3>
<p>✅ ecosystem check detected no changes.</p>
<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.00     15.0±0.09ms     2.7 MB/sec    1.01     15.1±0.10ms     2.7 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.6±0.00ms     4.6 MB/sec    1.01      3.7±0.01ms     4.5 MB/sec
linter/all-rules/numpy/globals.py          1.00    374.8±1.82µs     7.9 MB/sec    1.02    381.1±0.82µs     7.7 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.3±0.01ms     4.1 MB/sec    1.01      6.3±0.01ms     4.0 MB/sec
linter/default-rules/large/dataset.py      1.00      7.4±0.02ms     5.5 MB/sec    1.02      7.6±0.01ms     5.4 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1595.2±5.17µs    10.4 MB/sec    1.01   1616.4±2.33µs    10.3 MB/sec
linter/default-rules/numpy/globals.py      1.00    173.8±1.68µs    17.0 MB/sec    1.03    179.3±0.99µs    16.5 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.4±0.01ms     7.6 MB/sec    1.01      3.4±0.01ms     7.5 MB/sec
parser/large/dataset.py                    1.01      5.8±0.00ms     7.0 MB/sec    1.00      5.7±0.01ms     7.1 MB/sec
parser/numpy/ctypeslib.py                  1.00   1134.2±1.60µs    14.7 MB/sec    1.00   1130.9±2.51µs    14.7 MB/sec
parser/numpy/globals.py                    1.02    117.0±0.78µs    25.2 MB/sec    1.00    115.1±0.23µs    25.6 MB/sec
parser/pydantic/types.py                   1.00      2.5±0.00ms    10.3 MB/sec    1.00      2.5±0.00ms    10.3 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.03     17.3±0.15ms     2.3 MB/sec    1.00     16.8±0.12ms     2.4 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.03      4.4±0.03ms     3.8 MB/sec    1.00      4.3±0.03ms     3.9 MB/sec
linter/all-rules/numpy/globals.py          1.05    448.4±5.08µs     6.6 MB/sec    1.00    428.5±6.04µs     6.9 MB/sec
linter/all-rules/pydantic/types.py         1.02      7.3±0.05ms     3.5 MB/sec    1.00      7.1±0.04ms     3.6 MB/sec
linter/default-rules/large/dataset.py      1.01      8.6±0.07ms     4.8 MB/sec    1.00      8.5±0.04ms     4.8 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.01  1807.1±11.71µs     9.2 MB/sec    1.00  1781.5±15.05µs     9.3 MB/sec
linter/default-rules/numpy/globals.py      1.03    199.2±1.59µs    14.8 MB/sec    1.00    194.0±7.75µs    15.2 MB/sec
linter/default-rules/pydantic/types.py     1.01      3.9±0.02ms     6.6 MB/sec    1.00      3.8±0.07ms     6.7 MB/sec
parser/large/dataset.py                    1.00      6.7±0.03ms     6.1 MB/sec    1.10      7.4±0.03ms     5.5 MB/sec
parser/numpy/ctypeslib.py                  1.00   1249.3±7.96µs    13.3 MB/sec    1.10   1373.9±8.45µs    12.1 MB/sec
parser/numpy/globals.py                    1.00    129.7±0.84µs    22.8 MB/sec    1.08    140.0±0.82µs    21.1 MB/sec
parser/pydantic/types.py                   1.00      2.8±0.02ms     9.1 MB/sec    1.10      3.1±0.01ms     8.3 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andersk">@andersk</a> on 2023-04-05 01:38</div>
            <div class="timeline-body"><p>Simple test that crashes this:</p>
<pre><code class="language-console">$ echo 'import a' &gt; a.py

$ RUST_BACKTRACE=1 cargo run --bin=ruff -- -n --select=PLR0401 a.py
warning: /home/anders/rust/ruff/crates/ruff_diagnostics/Cargo.toml: `default-features` is ignored for serde, since `default-features` was not specified for `workspace.dependencies.serde`, this could become a hard error in the future
warning: /home/anders/rust/ruff/crates/ruff_text_size/Cargo.toml: `default-features` is ignored for serde, since `default-features` was not specified for `workspace.dependencies.serde`, this could become a hard error in the future
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
warning: the following packages contain code that will be rejected by a future version of Rust: lalrpop v0.19.8, nom v5.1.2
note: to see what the problems were, use the option `--future-incompat-report`, or run `cargo report future-incompatibilities --id 1`
     Running `/home/anders/.cache/cargo-target/debug/ruff -n --select=PLR0401 a.py`

error: `ruff` crashed. This indicates a bug in `ruff`. If you could open an issue at:

https://github.com/charliermarsh/ruff/issues/new?title=%5BPanic%5D

quoting the executed command, along with the relevant file contents and `pyproject.toml` settings, we'd be very appreciative!

thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', crates/ruff/src/rules/pylint/rules/cyclic_import.rs:87:46
stack backtrace:
   0: rust_begin_unwind
             at /rustc/2036fdd24f77d607dcfaa24c48fbe85d3f785823/library/std/src/panicking.rs:577:5
   1: core::panicking::panic_fmt
             at /rustc/2036fdd24f77d607dcfaa24c48fbe85d3f785823/library/core/src/panicking.rs:67:14
   2: core::panicking::panic
             at /rustc/2036fdd24f77d607dcfaa24c48fbe85d3f785823/library/core/src/panicking.rs:117:5
   3: core::option::Option&lt;T&gt;::unwrap
             at /rustc/2036fdd24f77d607dcfaa24c48fbe85d3f785823/library/core/src/option.rs:952:21
   4: ruff::rules::pylint::rules::cyclic_import::cyclic_import
             at ./crates/ruff/src/rules/pylint/rules/cyclic_import.rs:87:38
   5: ruff_cli::commands::run::run
             at ./crates/ruff_cli/src/commands/run.rs:167:17
   6: ruff_cli::check
             at ./crates/ruff_cli/src/lib.rs:250:13
   7: ruff_cli::run
             at ./crates/ruff_cli/src/lib.rs:89:40
   8: ruff::main
             at ./crates/ruff_cli/src/bin/ruff.rs:45:11
   9: core::ops::function::FnOnce::call_once
             at /rustc/2036fdd24f77d607dcfaa24c48fbe85d3f785823/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andersk">@andersk</a> on 2023-04-21 21:13</div>
            <div class="timeline-body"><p>Still easy to crash:</p>
<pre><code class="language-console">$ touch __init__.py

$ echo 'from . import a' &gt; a.py

$ RUST_BACKTRACE=1 cargo run --bin=ruff -- -n --select=PLR0401 a.py
warning: /home/anders/rust/ruff/crates/ruff_text_size/Cargo.toml: `default-features` is ignored for serde, since `default-features` was not specified for `workspace.dependencies.serde`, this could become a hard error in the future
warning: /home/anders/rust/ruff/crates/ruff_diagnostics/Cargo.toml: `default-features` is ignored for serde, since `default-features` was not specified for `workspace.dependencies.serde`, this could become a hard error in the future
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
warning: the following packages contain code that will be rejected by a future version of Rust: lalrpop v0.19.8, nom v5.1.2
note: to see what the problems were, use the option `--future-incompat-report`, or run `cargo report future-incompatibilities --id 1`
     Running `/home/anders/.cache/cargo-target/debug/ruff -n --select=PLR0401 a.py`

error: `ruff` crashed. This indicates a bug in `ruff`. If you could open an issue at:

https://github.com/charliermarsh/ruff/issues/new?title=%5BPanic%5D

quoting the executed command, along with the relevant file contents and `pyproject.toml` settings, we'd be very appreciative!

thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', crates/ruff/src/rules/pylint/rules/cyclic_import.rs:149:75
stack backtrace:
   0: rust_begin_unwind
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/std/src/panicking.rs:577:5
   1: core::panicking::panic_fmt
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/panicking.rs:67:14
   2: core::panicking::panic
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/panicking.rs:117:5
   3: core::option::Option&lt;T&gt;::unwrap
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/option.rs:952:21
   4: ruff::rules::pylint::rules::cyclic_import::cyclic_import::{{closure}}
             at ./crates/ruff/src/rules/pylint/rules/cyclic_import.rs:149:58
   5: &lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::find
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/slice/iter/macros.rs:249:24
   6: ruff::rules::pylint::rules::cyclic_import::cyclic_import
             at ./crates/ruff/src/rules/pylint/rules/cyclic_import.rs:147:29
   7: ruff_cli::commands::run::run
             at ./crates/ruff_cli/src/commands/run.rs:169:17
   8: ruff_cli::check
             at ./crates/ruff_cli/src/lib.rs:250:13
   9: ruff_cli::run
             at ./crates/ruff_cli/src/lib.rs:89:40
  10: ruff::main
             at ./crates/ruff_cli/src/bin/ruff.rs:45:11
  11: core::ops::function::FnOnce::call_once
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-21 21:47</div>
            <div class="timeline-body"><blockquote>
<p>Still easy to crash:</p>
<pre><code>$ touch __init__.py

$ echo 'from . import a' &gt; a.py

$ RUST_BACKTRACE=1 cargo run --bin=ruff -- -n --select=PLR0401 a.py
warning: /home/anders/rust/ruff/crates/ruff_text_size/Cargo.toml: `default-features` is ignored for serde, since `default-features` was not specified for `workspace.dependencies.serde`, this could become a hard error in the future
warning: /home/anders/rust/ruff/crates/ruff_diagnostics/Cargo.toml: `default-features` is ignored for serde, since `default-features` was not specified for `workspace.dependencies.serde`, this could become a hard error in the future
    Finished dev [unoptimized + debuginfo] target(s) in 0.19s
warning: the following packages contain code that will be rejected by a future version of Rust: lalrpop v0.19.8, nom v5.1.2
note: to see what the problems were, use the option `--future-incompat-report`, or run `cargo report future-incompatibilities --id 1`
     Running `/home/anders/.cache/cargo-target/debug/ruff -n --select=PLR0401 a.py`

error: `ruff` crashed. This indicates a bug in `ruff`. If you could open an issue at:

https://github.com/charliermarsh/ruff/issues/new?title=%5BPanic%5D

quoting the executed command, along with the relevant file contents and `pyproject.toml` settings, we'd be very appreciative!

thread 'main' panicked at 'called `Option::unwrap()` on a `None` value', crates/ruff/src/rules/pylint/rules/cyclic_import.rs:149:75
stack backtrace:
   0: rust_begin_unwind
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/std/src/panicking.rs:577:5
   1: core::panicking::panic_fmt
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/panicking.rs:67:14
   2: core::panicking::panic
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/panicking.rs:117:5
   3: core::option::Option&lt;T&gt;::unwrap
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/option.rs:952:21
   4: ruff::rules::pylint::rules::cyclic_import::cyclic_import::{{closure}}
             at ./crates/ruff/src/rules/pylint/rules/cyclic_import.rs:149:58
   5: &lt;core::slice::iter::Iter&lt;T&gt; as core::iter::traits::iterator::Iterator&gt;::find
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/slice/iter/macros.rs:249:24
   6: ruff::rules::pylint::rules::cyclic_import::cyclic_import
             at ./crates/ruff/src/rules/pylint/rules/cyclic_import.rs:147:29
   7: ruff_cli::commands::run::run
             at ./crates/ruff_cli/src/commands/run.rs:169:17
   8: ruff_cli::check
             at ./crates/ruff_cli/src/lib.rs:250:13
   9: ruff_cli::run
             at ./crates/ruff_cli/src/lib.rs:89:40
  10: ruff::main
             at ./crates/ruff_cli/src/bin/ruff.rs:45:11
  11: core::ops::function::FnOnce::call_once
             at /rustc/28a29282f6dde2e4aba6e1e4cfea5c9430a00217/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
</code></pre>
</blockquote>
<p>Yeah I figured this might still be the case, I'll sort it out later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @chanman3388 on 2023-04-22 02:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-23 03:57</div>
            <div class="timeline-body"><p>Using <code>strings</code> in hash sets is expensive because hasing requires iterating over the whole string (and it may be necessary to do so more than once if the hash map needs to grow). Could we instead have a single map that stores a <code>name</code> to <code>id</code> mapping, where <code>id</code> is a zero type wrapper around e.g. a <code>u32</code> type? It would allow us to only hash the string once rather than once per map.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:52 on 2023-04-23 03:58</div>
            <div class="timeline-body"><p>What's the reason for using <code>Arc</code> vs eg. <code>Box</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:64 on 2023-04-23 03:59</div>
            <div class="timeline-body"><p>Nit: It could be useful to put all these related data structures into a single struct that you can than pass around (and can expose semantically meaningful methods)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:102 on 2023-04-23 04:00</div>
            <div class="timeline-body"><p>Can we document why calling <code>unwrap</code> is safe or avoid calling <code>unwrap</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_cli/src/commands/run.rs</code>:165 on 2023-04-23 04:04</div>
            <div class="timeline-body"><p>Nit: I first assumed that this is the body of the <code>for</code> loop because of how it is nested. It could make sense to assign the result of this expression to a variable and then use it in the for loop</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/imports.rs</code>:124 on 2023-04-23 04:06</div>
            <div class="timeline-body"><p>It's unclear to me why it's necessary to implement <code>AsRef&lt;ModuleImport</code>. Could you give me an example of how it is used?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_cli/src/commands/run.rs</code>:177 on 2023-04-23 04:09</div>
            <div class="timeline-body"><p>Can you test if ruff correctly renders the diagnostic using <code>--show-source</code>. You may need to set the source code if this is not the case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:155 on 2023-04-23 04:10</div>
            <div class="timeline-body"><p>Can we document (here and in other places where we call <code>unwrap</code>) why calling <code>unwrap</code> is safe or, even better, restructure the code so that calling <code>unwrap</code> is unnecessary?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-04-23 04:12</div>
            <div class="timeline-body"><p>Impressive.</p>
<p>Can we add some integration tests that test the generated diagnostics?</p>
<p>How does that work in ruff-lsp when the user has unsaved changes in multiple files?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 04:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-23 04:55</div>
            <div class="timeline-body"><p>This is a good idea, I'll look into it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 05:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:52 on 2023-04-23 05:01</div>
            <div class="timeline-body"><p>I'm still reasonably new to this so do correct me if I'm wrong. The way I've done it I believe that we should have the same <code>str</code> potentially owned by multiple owners, though this might also not always be the case and I may indeed have a different <code>Arc&lt;str&gt;</code> which does contain the same value as another. For a <code>Box&lt;T&gt;</code> only one thing can own <code>T</code>. Cloning a <code>Box&lt;T&gt;</code> requires cloning the contents of the <code>Box</code> which isn't what I want.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 05:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:102 on 2023-04-23 05:03</div>
            <div class="timeline-body"><p>Sure, I'll need to double check, but I think that at this point, because this function was called to do the exact same thing one the same arguments when creating the <code>ImportMap</code>, then it must be safe here. I will need to check that is unequivocally true.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:155 on 2023-04-23 05:05</div>
            <div class="timeline-body"><p>Sure, I think here though I should just be able to use <code>the_rest[0]</code>, would that be more idiomatic?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 05:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 05:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff_python_ast/src/imports.rs</code>:124 on 2023-04-23 05:11</div>
            <div class="timeline-body"><pre><code>                   `imports.module_to_imports[module_name][0].as_ref().into(),`</code></pre>
<p>Line 125 of <code>cylic_import.rs</code>
Could I have avoided it?
<code>imports.module_to_imports[module_name]</code> yields a <code>ModuleImport</code>, I made <code>impl From&lt;&amp;ModuleImport&gt; for Range</code> only so I need a reference to a <code>ModuleImport</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-23 05:13</div>
            <div class="timeline-body"><blockquote>
<p>Impressive.</p>
<p>Can we add some integration tests that test the generated diagnostics?</p>
<p>How does that work in ruff-lsp when the user has unsaved changes in multiple files?</p>
</blockquote>
<p>If I understand you correctly, I <em>think</em> at the moment we can't do the former as the integration tests only work on individual files, whereas to check I get the correct cycles I need to lint a package.</p>
<p>Short answer for the latter is, I don't know, I'll find that out.</p>
<p>Thanks for the thorough review!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/andersk">@andersk</a> reviewed on 2023-04-23 06:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/andersk">@andersk</a> on <code>crates/ruff_python_ast/src/imports.rs</code>:124 on 2023-04-23 06:09</div>
            <div class="timeline-body"><p>You can write <code>(&amp;imports.module_to_imports[module_name][0]).into()</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 14:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff_python_ast/src/imports.rs</code>:124 on 2023-04-23 14:02</div>
            <div class="timeline-body"><p>@andersk, thanks! I thought I tried this, but I must've been mistaken. Thanks for the review/bug finding btw.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-04-23 16:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:52 on 2023-04-23 16:22</div>
            <div class="timeline-body"><p>That's a good point! Using refcounting here does make sense to avoid allocating the same module name many times. Would it be possible to use an <code>Rc</code> instead of <code>Arc</code> or is this data structure shared across thread boundaries?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 16:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff_cli/src/commands/run.rs</code>:177 on 2023-04-23 16:52</div>
            <div class="timeline-body"><p>The answer is that it doesn't render it correctly so I'll need to sort this out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 17:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff_cli/src/commands/run.rs</code>:177 on 2023-04-23 17:18</div>
            <div class="timeline-body"><p>I've got this working, but I'm not sure I've done this in the expected fashion. If I want to use <code>ruff::linter::diagnostics_to_messages</code> I have to re-tokenize the source file which seems inefficient. I would need to do that to populate the <code>noqa</code> flags correctly, should I do that? For now I haven't as it <em>appears</em> simpler no to.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 17:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff_cli/src/commands/run.rs</code>:165 on 2023-04-23 17:53</div>
            <div class="timeline-body"><p>Hm, I had to format it that way due to <code>cargo fmt</code> I think, the variables that are to be used in the actual for loop are in the line where the for loop starts?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-23 20:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:52 on 2023-04-23 20:29</div>
            <div class="timeline-body"><p>So the <code>ImportMap</code> is created in a way that is 'threaded' due to using <code>par_iter</code> which is where the first use of <code>Arc&lt;str&gt;</code> comes in. With the changes for referring to module names by id instead, because I create a name to id and id to name mapping...these just clone the <code>Arc</code> so unless I deliberately construct new <code>Rc</code>s from these <code>Arc</code>s I don't <em>think</em> I can just use an <code>Rc</code> even after this point. So I don't think I can trivially use <code>Rc</code> in favour of <code>Arc</code>.
It's awkward, because I don't think we actually share these across thread boundaries, but the compiler doesn't like it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-24 00:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-24 00:11</div>
            <div class="timeline-body"><p>Ok, I've done this, but I think it's a bit ugly imho, at least I think it's kinda ugly.
At least on the noddy example I provided above, it doesn't appear to provide any gains, but it is a small example.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-24 00:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:102 on 2023-04-24 00:12</div>
            <div class="timeline-body"><p>I don't <em>believe</em> it's unsafe to call <code>unwrap</code> here, however to be certain, I've avoided it now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-24 00:37</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>Impressive.
Can we add some integration tests that test the generated diagnostics?
How does that work in ruff-lsp when the user has unsaved changes in multiple files?</p>
</blockquote>
<p>If I understand you correctly, I <em>think</em> at the moment we can't do the former as the integration tests only work on individual files, whereas to check I get the correct cycles I need to lint a package.</p>
<p>Short answer for the latter is, I don't know, I'll find that out.</p>
<p>Thanks for the thorough review!</p>
</blockquote>
<p>So at the moment at least I don't know how to test ruff-lsp with my own version of ruff. Is there someone that could help with that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-04-26 00:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-26 00:56</div>
            <div class="timeline-body"><blockquote>
<p>At least on the noddy example I provided above,</p>
</blockquote>
<p>What example is this?</p>
<p>You would probably want to hide this behind a custom data structure that takes care of performing the <code>str -&gt; id</code> lookups. So that it appears to users the same as when they to the <code>HashMap.get(str)</code> lookup directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-26 15:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-26 15:11</div>
            <div class="timeline-body"><blockquote>
<p>Consider this file tree</p>
<pre><code>grand
├── __init__.py
├── a.py (from .parent.child import a; from .parent import a; from grand.parent.child import b)
└── parent
    ├── __init__.py
    ├── a.py (from .child import a, b; from .. import a)
    └── child
        ├── __init__.py
        ├── a.py (from .. import a; from ... import a)
        ├── b.py (from . import a)
        └── c.py --empty--
</code></pre>
</blockquote>
<p>This one.
Ok, I'll give <code>.get</code> implementation a go.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-04-26 16:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_cli/src/commands/run.rs</code>:177 on 2023-04-26 16:02</div>
            <div class="timeline-body"><p>I plan to have a closer look and provide you with an answer by Friday or early next week (I'm travelling today/tomorrow)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-26 21:26</div>
            <div class="timeline-body"><p>So I decided to do some noddy 'benchmarking'. I cloned the cpython repo, checked out the tag v.3.11.3 and ran ruff on it with --select=E,F,PLR0401 on it with varying commits from this branch using <code>cargo build --release</code>, by my estimation this is about 1M lines of python. I have an AMD 5900X. Off the current tip (<a href="https://github.com/charliermarsh/ruff/pull/3880/commits/f819262695a0cf10c8ab5feb9fd6b5cb1d6dc6cd">f819262</a>), it takes about 15-17s. Without performing a <code>name</code> to <code>id</code> mapping, that is to say leaving all the module names as <code>Arc&lt;str&gt;</code>, <a href="https://github.com/charliermarsh/ruff/pull/3880/commits/c878a78960cf42b6ae3d1f00b39e75bd07f1e835">c878a78</a>, it seems to reasonably consistently take 15s.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-26 21:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chanman3388">@chanman3388</a> on <code>crates/ruff/src/rules/pylint/rules/cyclic_import.rs</code>:54 on 2023-04-29 21:17</div>
            <div class="timeline-body"><p>Wrt ruff-lsp...I <em>believe</em> I'm using my own build of ruff with vscode...but I don't think it picks up on the cyclic imports. Does it just lint individual files at a time?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chanman3388">@chanman3388</a> reviewed on 2023-04-29 21:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-30 21:25</div>
            <div class="timeline-body"><p>I've got another branch that uses <code>par_iter</code> instead and places <code>CyclicImportHelper</code> in an <code>Arc&lt;RwLock&lt;T&gt;</code>. At least from my benchmarking it's ever-so-slightly faster.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-04-30 21:37</div>
            <div class="timeline-body"><blockquote>
<p>I've got another branch that uses <code>par_iter</code> instead and places <code>CyclicImportHelper</code> in an <code>Arc&lt;RwLock&lt;T&gt;</code>. At least from my benchmarking it's ever-so-slightly faster.</p>
</blockquote>
<p>Scratch that, seems I was trying something else.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-01 15:21</div>
            <div class="timeline-body"><p>This is a very impressive PR for an extremely valuable lint rule. Thanks for keeping working on it and rebasing it.</p>
<p>I have taken a closer look today and what it would mean. I have a few technical concerns for which I don't have any immediate answers right now and I recommend solving before merging. We can make some other improvements to the data structures to improve performance and reduce memory consumption.</p>
<h2>Open Questions</h2>
<h3>LSP and unsaved changes</h3>
<p>I haven't verified this but I fear that ruff will start reporting false positives (or negatives) if users have multiple open unsaved documents in their editor. Ruff's LSP passes the content of the active file in the editor per stdin instead of reading it from disk because there are likely unsaved changes.</p>
<p>The problem is, users can have multiple open documents with unsaved changes. We would need to pass all of them via stdin to ensure ruff operates on the latest content rather than on the stale content on disk. A scenario where I could see this be especially problematic is if the user has a cyclic import, makes changes two both files that fix the issue, but ruff continues to report it because it uses stale content from disk.</p>
<p>Properly supporting this use case most likely require significant changes to the LSP. We may want to decide that we're okay with this limitation. I rather prefer not to disable the rule in editors only because one of ruffs value propositions is that it works the same in editors and the CLI.</p>
<h3>Caching</h3>
<p>Ruff caches all diagnostics per file to avoid repeating the same analysis for unchanged files. I don't know how to cache the project-wide analysis yet and/or how cache invalidation should work. But I think that's something that we potentially can defer to later.</p>
<p>Related to this: We need to have the source code to emit diagnostics. It's unclear to me how to best retrieve the source code. We may need to first refactor our code to extract the logic that reads the source for a file.</p>
<h2>Architecture</h2>
<p>I would like to build an architecture that supports other use-cases like checking if a module only imports valid symbols from a module. Ideally, most of the computation happens per-file to use the CPUs' multi-core architecture best.</p>
<p>The way I think about this, and it is to a large extent implemented this way in this PR, is that we need to extract additional metadata in the per-file lint phase, cache it, aggregate that information, and then run additional checks on the aggregated data.</p>
<h3>Lint Phase</h3>
<p>Extract the name of the imported modules (and future, exported symbols). We can do this by computing a set of all imports in the lint phase where <code>ModuleImport</code> is defined as</p>
<pre><code class="language-rust">struct ModuleImports {
	imports: FxHashSet&lt;ModuleImport&gt;
}

struct ModuleImport {
	/// The range of the import statement, used for diagnostics
	range: TextRange,
	/// Or can we use a `TextRange` slicing into the source to avoid allocations?
	name: String,
}
</code></pre>
<p>We need to persist the <code>ModuleImports</code> when writing to the cache in the <code>cache.rs</code> and restore them when reading from the cache. This is similar to what you have today. My main recommendation is to keep this as slim as possible to make it cheap to cache.</p>
<h3>Orchestration (CLI)</h3>
<p>Build up an aggregated view. Ideally, as little as possible of that code lives in the CLI. The CLI should only be calling into the corresponding code living in ruff. For example, we could create a <code>Modules</code> or <code>Project</code> struct in ruff that aggregates the data:</p>
<pre><code class="language-rust">struct Modules {
	index: hashbrowns::HashMap&lt;ModuleId, ()&gt; // Use the raw_entry_mut method to manually compute the hash key to avoid storing the name multiple time. https://docs.rs/hashbrown/latest/hashbrown/struct.HashMap.html#method.raw_entry
	modules: Vec&lt;Module&gt; // the index defines the `ModuleId`. Use `self.modules.len()` to compute the next id.
}

impl Modules {
  pub fn add_module(name: String, imports: ModuleImports) {...}
}

#[derive(Copy, Clone, Eq, PartialEq, Hash, Debug)]
struct ModuleId(u32);

struct Module {
	name: String,
	imports: Vec&lt;ResolvedImport&gt;,
	source: String, // (or lazy load?)
}

struct ResolvedImport {
	id: ModuleId,
	range: TextRange
}
</code></pre>
<p>We can avoid the need for locking on <code>Modules</code> by only using it from a single thread. Ideally, we could start building it while the analysis of other modules is still running rather than having to wait until all analysis ended (use a separate thread with a Channel?)</p>
<h3>Project-wide analysis</h3>
<p>Create a new <code>lint_project(modules: &amp;Modules)</code> or similar method in ruff that does the cross-file linting.</p>
<p>What's unclear is how to retrieve the source text for cached files without loading every single file.</p>
<h2>Next Steps</h2>
<p>I think we should try to answer if we want to solve the LSP and caching issues today and we can then decide what other technical improvements we want to make (again, your PR is already super close and some of my suggestions may not work, you will know better). @charliermarsh what's your take on the LSP and caching problematic?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-05-01 23:37</div>
            <div class="timeline-body"><p>With regards to say, checking that we import valid symbols, I think in the per-file lint phase, we could construct an <code>ExportMap</code> of sorts. I suppose the main issue is that such a map is going to require more memory, but it would allow for checking if a member in a module does exist, at least for Ruff, it would be nice to have if we could at least do this on first-party packages.
I've not checked the memory usage, the version of perf I had to compile to work with WSL2 doesn't support memory events. I did play around with some other implementations of cyclic import detection, and it does seem that if you don't store the cycles and only consider cycles applicable to the current module that it is slightly faster than the approach in this PR as you can do it in a parallel fashion.  Would this be of interest? It feels inefficient, but it is faster, and it would allow for the running of other rules much like we do now, but using the <code>ImportMap</code> and the <code>ExportMap</code> concept that I mentioned.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chanman3388">@chanman3388</a> on 2023-05-04 22:26</div>
            <div class="timeline-body"><p>The <a href="https://github.com/chanman3388/ruff/pull/4">PR</a> with checking only the cycles relevant to the module being checked, if it is of any interest.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-10-20 18:04</div>
            <div class="timeline-body"><p>I'm going to close this for now in the interest of bookkeeping active PRs. I'm bummed that we haven't been able to merge it (and sorry for all the work you put in, only to lead to this disappointing outcome), but it starts to move us into multi-file analysis and so we need to solve some other problems before we'd be comfortable shipping it (namely, around caching and LSP support, as Micha described above in more detail). When the time comes, we can always reopen.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-10-20 18:04</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:56:58 UTC
    </footer>
</body>
</html>
