<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] detect unreachable attribute assignments - astral-sh/ruff #16852</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] detect unreachable attribute assignments</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16852">#16852</a>
        opened by <a href="https://github.com/mtshiba">@mtshiba</a>
        on 2025-03-19 17:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR closes astral-sh/ruff#15967.</p>
<p>Attribute assignments that are statically known to be unreachable are excluded from consideration for implicit instance attribute type inference. If none of the assignments are found to be reachable, an <code>unresolved-attribute</code> error is reported.</p>
<h2>Test Plan</h2>
<p><a href="https://github.com/astral-sh/ruff/blob/main/crates/red_knot_python_semantic/resources/mdtest/attributes.md#attributes-defined-in-statically-known-to-be-false-branches">A test case</a> marked as TODO now work as intended, and new test cases have been added.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-03-19 17:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @mtshiba on 2025-03-19 17:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @mtshiba on 2025-03-19 17:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @mtshiba on 2025-03-19 17:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-19 17:28</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-03-19 17:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-20 08:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:149 on 2025-03-20 08:23</div>
            <div class="timeline-body"><p>I'm trying to understand the need for this new field. It seems that we need the symbol for every <code>AttributeAssignment</code>. Would it be possible to store the symbol as part of the <code>attribute_assignments</code> state instead. Or are there any downsides to it that I'm overlooking?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-21 00:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:149 on 2025-03-21 00:05</div>
            <div class="timeline-body"><p>I think it goes deeper than this. If we see an attribute assignment like <code>self.x = &quot;foo&quot;</code> in <code>__init__</code> method, the only symbol in the scope of <code>__init__</code> that is involved here is <code>self</code>. What we are newly tracking in this PR is the &quot;symbol namespace&quot; of &quot;names assigned to <code>self</code> in methods&quot;. So it's not just tracking some existing symbol ID, we are creating a whole new symbol table for this new namespace, that before was not tracked at all. And we also add support to the use-def map so that we can track conditional visibility of these names as well.</p>
<p>It's a clever and interesting approach, which makes good use of the existing symbol-table and control-flow infrastructure we have. It's also interesting because it could likely generalize well to future attribute-type-narrowing support.</p>
<p>Off the top of my head, I also wonder whether we need both the <code>attribute_assignments</code> map and the new <code>instance_attribute_tables</code>. It seems like the latter should be able to replace the former entirely, as we can just query the symbol table and the use-def map to get all assigned names?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-21 00:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:149 on 2025-03-21 00:06</div>
            <div class="timeline-body"><p>Would definitely be interested in @sharkdp's thoughts on this PR, as the author of the <code>instance_attributes</code> work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-03-21 00:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:149 on 2025-03-21 00:27</div>
            <div class="timeline-body"><p>My main &quot;a priori&quot; concern with this PR would have been the cost of adding <code>instance_attribute_tables</code> to every scope, even though we only use it in some scopes. But codspeed says no regression; I guess the cost of an empty symbol table and empty extra set of symbol states in the use-def map is not that high?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-03-21 03:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:149 on 2025-03-21 03:09</div>
            <div class="timeline-body"><p>Yes, I thought that a new field were needed to track the visibility of instance attributes, but we can actually divert some existing structure. That is, we can add an empty definition to <code>UseDefMapBuilder::all_definitions</code> to make it publish a <code>ScopedDefinitionID</code>, which will correspond to the instance attribute assignment.
Since <code>self.x = 1</code> and <code>x = 1</code> are different things, we need to have them as different symbol states from <code>symbol_states/public_symbols</code>, and in addition, the (reachable) instance attributes must remain visible after the method is returned since they are accessible from the outside.</p>
<p>As you say, the essence of this PR is the addition of states to manage instance attributes.
It was not needed in this PR, but if we want to do more analysis for instance attributes in the future, we may need to add a new variant representing attribute assignment to <code>DefinitionKind</code> and make a <code>Definition</code> instead of adding an empty definition to <code>all_definitions</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-24 16:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:416 on 2025-03-24 16:02</div>
            <div class="timeline-body"><p>This is an improvement that we should probably add a test for?</p>
<pre><code class="language-py">class C:
    def __init__(self):
        self.x = 1
        self.x = &quot;a&quot;

reveal_type(C().x)
</code></pre>
<p>Previously, we would infer <code>Unknown | Literal[1, 2]</code> in that case, and now we infer the more correct <code>Unknown | Literal[2]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:515 on 2025-03-24 16:15</div>
            <div class="timeline-body"><p>The changes in this PR would probably also allow us to add a more fine-granular possibly-unbound handling for instance attributes. In a case like this …</p>
<pre><code class="language-py">class C:
    def f(self, cond: bool):
        if cond:
            self.x = 1

C().x
</code></pre>
<p>… we could use the full return type of <code>is_attribute_assignment_visible</code> to see that <code>x</code> is not definitely bound.</p>
<p>Boundness of implicit instance instance attributes is treated a bit inconsistently at the moment. We treat them as always possibly-unbound in some situations (e.g. in the descriptor protocol implementation), since we don't (attempt to) understand if that method <code>f</code> has been called or not.</p>
<p>But on the other hand, we do not emit a possibly-unbound-attribute diagnostic in a case like above, because <code>f</code> <em>could</em> have been called. So we don't set an explicit <code>Boundness::PossiblyUnboud</code> state for implicit instance attributes, as that would lead to many false positive diagnostics.</p>
<p>I'm not sure if there is much value in adding a more sophisticated understanding, but it seems reasonable to emit a possibly-unbound-attribute diagnostic in the example above. Because even if <code>f</code> is called, <code>x</code> is still possibly-unbound.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-24 16:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-03-24 16:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:149 on 2025-03-24 16:21</div>
            <div class="timeline-body"><blockquote>
<p>Would definitely be interested in @sharkdp's thoughts on this PR, as the author of the instance_attributes work.</p>
</blockquote>
<p>I also think this looks great, especially because it doesn't just solve the unreachable-attribute assignment case, but also allows us to distinguish between those two cases:</p>
<pre><code class="language-py">self.x = 1
self.x = 2
</code></pre>
<p>and</p>
<pre><code class="language-py">if cond:
    self.x = 1
else:
    self.x = 2
</code></pre>
<blockquote>
<p>Off the top of my head, I also wonder whether we need both the <code>attribute_assignments</code> map and the new <code>instance_attribute_tables</code>. It seems like the latter should be able to replace the former entirely, as we can just query the symbol table and the use-def map to get all assigned names?</p>
</blockquote>
<p>I agree. I would be great if we could attempt to make that change in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-03-27 04:18</div>
            <div class="timeline-body"><p>While trying to solve the issue, I noticed that the following code does not pass:</p>
<pre><code class="language-python">class C:
    def __init__(self):
        def closure():
            self.a: str = 1
        closure()
        [... for self.b in range(1)]
        class D:
            self.c = 1

# should be OK
C().a
C().b
C().c
</code></pre>
<p>It appears that the <code>SemanticIndexBuilder::register_attribute_assignment</code> does not take inner scopes into account.
I'm trying to fix this, but this may be an issue that should be resolved in another PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @AlexWaygood removed by @AlexWaygood on 2025-03-27 21:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @mtshiba on 2025-03-30 19:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-03-30 19:26</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_INSTRUMENTATION_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Aunreachable-attribute-assignments">CodSpeed Performance Report</a></h2>
<h3>Merging astral-sh/ruff#16852 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>mtshiba:unreachable-attribute-assignments</code> (e52f9d6) with <code>main</code> (3aa3ee8)</sub></p>
<h3>Summary</h3>
<p><code>✅ 32</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-03-30 19:30</div>
            <div class="timeline-body"><p>The commit I just made completely removes <code>SemanticIndex::attribute_assignments/AttributeAssignment</code>.
Attribute assignments are now stored in <code>SemanticIndex::all_definitions</code>.</p>
<p>I noticed that we can also track attribute assignments in comprehension/named/augmented assignments as well, so I will be working on that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:195 on 2025-03-31 07:42</div>
            <div class="timeline-body"><p>The main motivation for using an <code>Arc</code> for the <code>SymbolTable</code> was so that we could return them from a salsa query that is specific per scope (instead of the entire <code>semantic_index</code>). However, it looks like no such query exists any more, so we should remove the <code>Arc</code> wrapper</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:39 on 2025-03-31 07:46</div>
            <div class="timeline-body"><p>What's the reason for moving this function out of <code>Class</code>? It makes the diff harder to review</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:38 on 2025-03-31 07:50</div>
            <div class="timeline-body"><p>Have you investigated where the performance regression is coming from?</p>
<p>I suspect that it is because this function is now a salsa query and its arguments are somewhat expensive (requires hashing and allocating a name). Gating the <code>attribute_assignments</code> and <code>is_attribute_assignment_visible</code> methods behind a query is important because they access <code>semantic_index</code> or <code>node</code>. However, it makes me wonder if we could change the methods so that they wouldn't have to depend on the entire <code>semantic_index</code> or access specific nodes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:42 on 2025-03-31 07:50</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    name: Name, // tracked functions do not accept a borrowed `str` with an implicit lifetime
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-03-31 07:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-03-31 17:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:38 on 2025-03-31 17:18</div>
            <div class="timeline-body"><p>Thanks. Initially I thought the performance regression was caused by removing <code>salsa::tracked</code> of <code>attribute_assignments</code>, but changing the field types of <code>{Assignment, ForStmt, WithItem}DefinitionKind</code> may be the true cause (there seems to be a regression with type inference on these).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 07:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:515 on 2025-04-01 07:44</div>
            <div class="timeline-body"><p>It looks like this leads to many new diagnostics in the ecosystem checks. Did you have a chance to investigate this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-04-01 17:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:515 on 2025-04-01 17:25</div>
            <div class="timeline-body"><p>I found that the following code would result in a <code>possibly-unbound-attribute</code> warning.</p>
<ul>
<li>case 1: may loop forever in <code>__init__</code></li>
</ul>
<pre><code class="language-python">from typing import Iterable

class Foo:
    def __init__(self, iterable: Iterable[int], cond: bool) -&gt; None:
        self.x = 1

        # These loops may never stop
        for _ in iterable:
            pass
        while cond:
            pass

foo = Foo([], False)
# error: [possibly-unbound-attribute]
foo.x
</code></pre>
<ul>
<li>case 2: may throw an error in <code>__init__</code></li>
</ul>
<pre><code class="language-python">class Foo:
    def __init__(self, b: bytes, cond: bool) -&gt; None:
        try:
            s = b.decode()
        except UnicodeDecodeError:
            raise ValueError(&quot;Invalid UTF-8 sequence&quot;)
        if cond:
            raise ValueError(&quot;Something went wrong&quot;)

        self.s = s

foo = Foo(b&quot;abc&quot;)
# error: [possibly-unbound-attribute]
foo.s
</code></pre>
<p>These are false positive warnings; when creating a <code>SemanticIndex</code>, it would be necessary to treat the recording of visibility for attribute assignments differently than for name assignments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:341 on 2025-04-02 23:52</div>
            <div class="timeline-body"><p>If we keep the possibly-unbound-attribute diagnostic, I think it makes just as much sense for this attribute to be marked as possibly-unbound as it does in the <code>if flag:</code> case with <code>c_instance.possibly_undeclared_unbound</code> above. The iterable here might be empty. (We could add a comment here explaining that &quot;iterable might be empty&quot; is the reason the attribute might not be defined.)</p>
<p>That is,  I think either this case and the above <code>if flag:</code> case should both emit a diagnostic, or neither of them should.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:345 on 2025-04-02 23:53</div>
            <div class="timeline-body"><p>Same as above: <em>if</em> we are emitting <code>possibly-unbound-attribute</code> for cases where the only attribute definition we see is conditional, then we <em>should</em> emit it here IMO; <code>for</code> is just as conditional as <code>if</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:432 on 2025-04-02 23:53</div>
            <div class="timeline-body"><p>If we keep this behavior, then the text above on lines 415-416 would need to be updated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:115 on 2025-04-03 00:00</div>
            <div class="timeline-body"><p>This logic is already implemented as <code>ChildrenIter</code>, should we just use that instead of <code>DescendantsIter</code>?</p>
<p>(There's no efficiency improvement, the implementation of <code>ChildrenIter</code> is effectively the same, it just avoids re-implementing the logic.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index.rs</code>:102 on 2025-04-03 00:03</div>
            <div class="timeline-body"><p>We should probably mention in the doc comment for this function that calling it adopts a direct dependency on the AST of the file containing <code>class_body_scope</code>, since we access the semantic index for that file.</p>
<pre><code class="language-suggestion">///
/// Only call this when doing type inference on the same file as `class_body_scope`, otherwise it
/// introduces a direct dependency on that file's AST.
pub(crate) fn attribute_assignments&lt;'db, 's&gt;(
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:1917 on 2025-04-03 00:20</div>
            <div class="timeline-body"><p>In this PR, <code>TargetKind</code> still has only two variants, <code>Name</code> and <code>Sequence</code>, but now we end up using <code>Name</code> also when the target is an attribute. This should be fixed in some way, since it's misleading.</p>
<p>It seems maybe we don't ever need to distinguish between name target and attribute target using the <code>TargetKind</code>? In which case we could rename the <code>Name</code> variant to <code>NameOrAttribute</code>. Or we could add a third variant, <code>Attribute</code>, and make sure we pass <code>Attribute</code> variant here. The latter seems nicer in that we preserve more information, but if we don't need that information maybe it's not worth it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:288 on 2025-04-03 00:23</div>
            <div class="timeline-body"><p>Does this PR introduce <code>None</code> entries elsewhere in the array? If not, we can revert this change?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:325 on 2025-04-03 00:34</div>
            <div class="timeline-body"><p>nit: we could just call this <code>instance_attributes</code>.</p>
<p>We don't call <code>public_symbols</code> <code>public_symbol_states</code>, even though it is also an indexvec of <code>SymbolState</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:362 on 2025-04-03 00:41</div>
            <div class="timeline-body"><p>Just for naming consistency I suppose we could call this <code>instance_attribute_bindings</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:417 on 2025-04-03 00:44</div>
            <div class="timeline-body"><p>Do we have any tests for an attribute assignment inside a definitely-not-existing method? I.e. do any tests fail if we remove this <code>is_method_visible</code> check?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-03 00:46</div>
            <div class="timeline-body"><p>Haven't finished my review but I have to head out, so submitting the comments I have so far. Thanks for your work on this!</p>
<p>Given the false positives observed, I'm not sure we should keep the possibly-unbound-attribute checks, but I'm still thinking about whether there is a satisfactory way to address the false positive cases. It may have some overlap with https://github.com/astral-sh/ruff/issues/15777</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-04-03 06:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/red_knot_python_semantic/src/semantic_index/use_def.rs</code>:417 on 2025-04-03 06:05</div>
            <div class="timeline-body"><p>I added a test to check the visibility of an attribute defined in a definitely-non-existing-method.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-04-04 06:38</div>
            <div class="timeline-body"><p>Support for attribute assignments in comprehension/aug-assign/~~named-expression~~ is incomplete, but considering that it is still not implemented in the main branch and that it was not originally planned in this PR, this may be work that should be done in another PR.</p>
<p>I believe that the implementation of the feature originally planned in this PR is almost complete and ready for final review.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-04-04 06:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @mtshiba on 2025-04-04 06:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @mtshiba on 2025-04-04 06:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @BurntSushi by @mtshiba on 2025-04-11 16:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:882 on 2025-04-12 02:26</div>
            <div class="timeline-body"><p>Can't we just get this once at the top of the function? It won't ever change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-04-12 02:38</div>
            <div class="timeline-body"><p>This looks pretty good to me! It turns <code>ClassLiteralType::implicit_instance_attribute</code> into even more of a monster method, but I think I'm ok with that for now: it has a clear responsibility, and the logic in it is well encapsulated; if we need to break it up for better reuse in future, we can do that.</p>
<p>@sharkdp if you have a chance, I'd like to make sure this looks good to you as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:598 on 2025-04-14 06:49</div>
            <div class="timeline-body"><p>This seems to be a small extension of the existing &quot;Possibly unbound&quot; test case below. Maybe we can move it down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/class.rs</code>:928 on 2025-04-14 07:11</div>
            <div class="timeline-body"><p>Elegant!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-04-14 07:13</div>
            <div class="timeline-body"><p>This looks great — thank you very much. I have just one minor comment, which I can also resolve myself before merging this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-04-14 07:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-04-14 07:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-14 12:57</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:10:52 UTC
    </footer>
</body>
</html>
