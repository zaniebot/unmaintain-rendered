<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[internal] `ComparableExpr` (f)strings and bytes made invariant under concatenation - astral-sh/ruff #13301</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[internal] <code>ComparableExpr</code> (f)strings and bytes made invariant under concatenation</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13301">#13301</a>
        opened by <a href="https://github.com/dylwil3">@dylwil3</a>
        on 2024-09-10 04:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dylwil3">@dylwil3</a> on 2024-09-10 04:54</div>
            <div class="timeline-body"><h1>Summary</h1>
<p>This PR modifies the construction of <code>ComparableExpr</code> objects from <code>Expr</code> objects in order to ensure that the following equalities hold at the level of comparable AST nodes:</p>
<pre><code class="language-python">&quot;a&quot; &quot;b&quot; == &quot;ab&quot;
b&quot;a&quot; b&quot;b&quot; == b&quot;ab&quot;
&quot;text&quot; f&quot;{foo} more&quot; &quot;text&quot; f&quot;{bar}&quot; == f&quot;text{foo} moretext{bar}&quot;
</code></pre>
<ul>
<li>[x] <code>ExprStringLiteral</code></li>
<li>[x] <code>ExprBytesLiteral</code></li>
<li>[x] <code>ExprFString</code></li>
</ul>
<p>Closes #13291</p>
<details>
    <summary>Details</summary>

<ul>
<li><code>ExprStringLiteral</code>: The comparable variant simply stores the concatenated string value using the <code>to_str</code> method</li>
<li><code>ExprBytesLiteral</code>: The comparable variant stores a <code>Cow&lt;'ast, [u8]&gt;</code> which is owned for concatenated bytes expressions and borrowed otherwise.</li>
<li><code>ExprFString</code>: The comparable variant stores the vector of <code>FStringElement</code>'s obtained by joining together contiguous sequences of <code>StringLiteral</code> and <code>FString</code> elements. So, for example</li>
</ul>
<pre><code class="language-python">&quot;text&quot; f&quot;{foo} more&quot; &quot;text&quot; f&quot;{bar}&quot;
</code></pre>
<p>would be interpreted as the vector with components<code>&quot;text&quot;</code>, <code>f&quot;{foo}&quot;</code>, <code>&quot; moretext&quot;</code>, and <code>f&quot;{bar}&quot;</code>.</p>
</details>

<h1>Test Plan</h1>
<ul>
<li>[x] Unit tests with hand-crafted AST nodes</li>
<li>[x] Integration tests with parsed source code</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[internal] `ComparableExpr` (f)strings and bytes made invariant under concatenation" to "[internal] [WIP] `ComparableExpr` (f)strings and bytes made invariant under concatenation" by @dylwil3 on 2024-09-10 04:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-11 04:12</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[internal] [WIP] `ComparableExpr` (f)strings and bytes made invariant under concatenation" to "[internal] `ComparableExpr` (f)strings and bytes made invariant under concatenation" by @dylwil3 on 2024-09-24 16:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dylwil3 on 2024-09-24 17:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @zanieb on 2024-09-24 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @zanieb on 2024-09-24 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @MichaReiser by @zanieb on 2024-09-24 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @zanieb on 2024-09-24 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:695 on 2024-09-25 07:44</div>
            <div class="timeline-body"><p>Nit: We can simplify this a bit</p>
<pre><code class="language-suggestion">                ast::FStringPart::Literal(string_literal) =&gt; {
                    literal_accumulator = Some(match literal_accumulator.take() {
                        None =&gt; Cow::Borrowed(string_literal),
                        Some(existing_literal) =&gt; {
                            let mut s = existing_literal.into_owned();
                            s.push_str(string_literal);
                            s.into()
                        }
                    });
                },
                ast::FStringPart::FString(fstring) =&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:662 on 2024-09-25 07:49</div>
            <div class="timeline-body"><p>Nit: This can be simplified to</p>
<pre><code class="language-suggestion">                        Some(existing_literal) =&gt; existing_literal.to_mut().push_str(&amp;literal.value),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:602 on 2024-09-25 08:05</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    elements: Box&lt;[ComparableFStringElement&lt;'a&gt;]&gt;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:637 on 2024-09-25 08:19</div>
            <div class="timeline-body"><p>Nit: there's some repetitive code in this implementation that we can avoid by introducing a <code>Collector</code> new-type wrapper that provides the necessary utility methods:</p>
<pre><code class="language-rust">                #[derive(Default)]
        struct Collector&lt;'a&gt; {
            elements: Vec&lt;ComparableFStringElement&lt;'a&gt;&gt;,
        }

        impl&lt;'a&gt; Collector&lt;'a&gt; {
            fn push_literal(&amp;mut self, literal: &amp;'a str) {
                if let Some(ComparableFStringElement::Literal(existing_literal)) =
                    self.elements.last_mut()
                {
                    existing_literal.to_mut().push_str(literal);
                } else {
                    self.elements
                        .push(ComparableFStringElement::Literal(literal.into()));
                }
            }

            fn push_expression(&amp;mut self, expression: &amp;'a ast::FStringExpressionElement) {
                self.elements.push(expression.into());
            }
        }

        let mut collector = Collector::default();

        for part in value {
            match part {
                ast::FStringPart::Literal(string_literal) =&gt; {
                    collector.push_literal(&amp;*string_literal.value);
                }
                ast::FStringPart::FString(fstring) =&gt; {
                    // Note: we do _not_ clear the literal buffer here
                    // since we may encounter literals amongst the
                    // f-string elements.
                    for element in &amp;fstring.elements {
                        match element {
                            ast::FStringElement::Literal(literal) =&gt; {
                                collector.push_literal(&amp;*literal.value);
                            }
                            ast::FStringElement::Expression(expression) =&gt; {
                                collector.push_expression(expression)
                            }
                        }
                    }
                }
            }
        }

        Self {
            elements: collector.elements.into_boxed_slice(),
        }

</code></pre>
<p>This does require splitting the <code>From</code> implementation for <code>FStringElement</code></p>
<pre><code class="language-rust">impl&lt;'a&gt; From&lt;&amp;'a ast::FStringElement&gt; for ComparableFStringElement&lt;'a&gt; {
    fn from(fstring_element: &amp;'a ast::FStringElement) -&gt; Self {
        match fstring_element {
            ast::FStringElement::Literal(ast::FStringLiteralElement { value, .. }) =&gt; {
                Self::Literal(value.as_ref().into())
            }
            ast::FStringElement::Expression(formatted_value) =&gt; formatted_value.into(),
        }
    }
}

impl&lt;'a&gt; From&lt;&amp;'a ast::FStringExpressionElement&gt; for ComparableFStringElement&lt;'a&gt; {
    fn from(fstring_expression_element: &amp;'a ast::FStringExpressionElement) -&gt; Self {
        let ast::FStringExpressionElement {
            expression,
            debug_text,
            conversion,
            format_spec,
            range: _,
        } = fstring_expression_element;

        Self::FStringExpressionElement(FStringExpressionElement {
            expression: (expression).into(),
            debug_text: debug_text.as_ref(),
            conversion: *conversion,
            format_spec: format_spec
                .as_ref()
                .map(|spec| spec.elements.iter().map(Into::into).collect()),
        })
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:629 on 2024-09-25 08:22</div>
            <div class="timeline-body"><p>The word <code>stack</code> here is a bit confusing because the implementation doesn't make use of a stack. It uses a single &quot;slot&quot; storing the last string literal.</p>
<p>I think I'm good with the above comment because the most important informatin that I wasn't aware of is that adjacent string literals need to be concatenated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:1710 on 2024-09-25 08:28</div>
            <div class="timeline-body"><p>Thanks for taking the time to write all those tests.</p>
<p>I don't have a great suggestion but I wonder if we should make them integration tests instead, because they're very verbose and are difficult to read. E.g. there's so much boilerplate that I find it difficult to pick up the important bits. I also assume that they were very annoying to write. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2024-09-25 08:28</div>
            <div class="timeline-body"><p>This is great and nice work on f-strings. I've a few suggestions on how we can reduce the code for the f-string transformation and I think it would be great if we can reduce the test-boilerplate to improve readability.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2024-09-25 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:1710 on 2024-09-25 14:28</div>
            <div class="timeline-body"><p>The integration tests have the same content so I elected to remove these verbose unit tests entirely. They were helpful for development (and for my own understanding of the internals of f-string nodes), but keeping them around is probably more trouble than they're worth!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2024-09-25 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:629 on 2024-09-25 14:28</div>
            <div class="timeline-body"><p>Reworded a bit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2024-09-25 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:637 on 2024-09-25 14:28</div>
            <div class="timeline-body"><p>Very elegant! Done!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:602 on 2024-09-25 14:28</div>
            <div class="timeline-body"><p>Done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2024-09-25 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2024-09-25 14:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:662 on 2024-09-25 14:29</div>
            <div class="timeline-body"><p>Done (but now inside <code>Collector</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dylwil3">@dylwil3</a> reviewed on 2024-09-25 14:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dylwil3">@dylwil3</a> on <code>crates/ruff_python_ast/src/comparable.rs</code>:695 on 2024-09-25 14:29</div>
            <div class="timeline-body"><p>Done, but superseded by <code>Collector</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-09-25 14:58</div>
            <div class="timeline-body"><p>This is great! Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-09-25 14:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-09-25 14:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-25 15:07</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:00:06 UTC
    </footer>
</body>
</html>
