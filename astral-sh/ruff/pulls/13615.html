<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] more ergonomic and efficient handling of known builtin classes - astral-sh/ruff #13615</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] more ergonomic and efficient handling of known builtin classes</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13615">#13615</a>
        opened by <a href="https://github.com/Slyces">@Slyces</a>
        on 2024-10-03 17:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a></div>
            <div class="timeline-body">

Summary
<p>This PR introduces a new enumeration <code>BuiltinType</code> that serves 2 purposes:</p>
<ul>
<li>df16f218aaa40f319fc6dd3eaddefdc7c3b5bfb0: give a common syntax for the convenience shortcuts to get a builtin instance<ul>
<li>For that purpose, the enum doesn&#x27;t need to be exhaustive - just to have the types we often need</li>
</ul>
</li>
<li>c98ce748f74841eabe73eb1f4dbc77f83454e5f0: save if a class is a builtin on creation, to save time on call when we need to check for custom behaviour (<code>str(...)</code>, <code>bool(...)</code>, ...)</li>
</ul>
<p>I think for the first purpose that&#x27;s mainly a syntax preference, you should be able to tell fairly fast if you prefer it that way.
For the second, that&#x27;s mainly an optimisation that we might need once we handle more specific behaviour for <code>builtin</code> used as callable - this could clearly wait until we implement more of those.</p>
Test Plan
<p>No tests were added, but the existing test suite is enough to check if this introduced a regression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/Slyces">@Slyces</a> on 2024-10-03 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/Slyces">@Slyces</a> on 2024-10-03 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/Slyces">@Slyces</a> on 2024-10-03 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-03 17:55</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>âœ… ecosystem check detected no linter changes.</p>
Linter (preview)
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-04 04:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:912 on 2024-10-04 04:04</div>
            <div class="timeline-body"><p>What&#x27;s the reason for introducing and using <code>BuiltinType::iter</code> here instead of a match. I think I&#x27;d prefer to avoid adding a dependency for this use case as it feels a bit overkill :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-04 08:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:912 on 2024-10-04 08:11</div>
            <div class="timeline-body"><p>I guess the reason was to make it easier to add more members as needed - but that&#x27;s probably not worth a dependency!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:829 on 2024-10-04 17:25</div>
            <div class="timeline-body"><pre><code>/// Feel free to expand this enum if you ever find yourself using the same builtin type in multiple
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:862 on 2024-10-04 17:26</div>
            <div class="timeline-body"><p>maybe</p>
<pre><code>        self.to_class(db).to_instance(db)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:419 on 2024-10-04 17:31</div>
            <div class="timeline-body"><p>Can we add a method on <code>ClassType</code> to make this less verbose? I would probably even call it <code>is_builtin</code>:</p>
<pre><code>                if class.is_builtin(db, BuiltinType::Int) =&gt;
</code></pre>
<p>And then rename the <code>is_builtin</code> field to just <code>builtin</code>; <code>is_</code> prefix suggests a boolean, not an optional enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1283 on 2024-10-04 17:46</div>
            <div class="timeline-body"><p>As mentioned above, I&#x27;d name this just <code>builtin</code> -- <code>is_</code> prefix suggests a boolean.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 17:54</div>
            <div class="timeline-body"><p>Naming nit: let&#x27;s rename this to <code>BuiltinClass</code>. This actually only handles classes, not all kinds of types (functions are types too).</p>
<p>Speaking of which, I kinda want to unify this PR and <code>FunctionKind</code>, in terms of both naming and API. The one trick there is that we want to represent known functions that aren&#x27;t actually builtins (e.g. <code>reveal_type</code>). The same may be true in future for other stdlib classes!</p>
<p>So maybe ultimately what we&#x27;ll actually want is <code>KnownClass</code> and <code>KnownFunction</code> enums, and a <code>known</code> field (which is an <code>Option&lt;KnownClass&gt;</code> or <code>Option&lt;KnownFunction&gt;</code> - I like this Option approach better than <code>FunctionKind::Ordinary</code>), and <code>is_known</code> method, on both <code>ClassType</code> and <code>FunctionType</code>. But this would require generalizing what you have in this PR to not assume builtins module, and instead classify the known functions/classes by module as well. I would be happy with doing all of this now, in this PR, or waiting on it if you prefer to land a simpler version of this PR for now.</p>
<p>cc @AlexWaygood in case you hate my naming/API preferences :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-04 17:57</div>
            <div class="timeline-body"><p>This looks great as a general direction! A few nits and thoughts on naming/API.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/carljm">@carljm</a> on 2024-10-04 18:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Feat/builtins enum&quot; to &quot;[red-knot] more ergonomic and efficient handling of known builtin classes&quot; by <a href="https://github.com/carljm">@carljm</a> on 2024-10-04 18:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-04 18:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1288 on 2024-10-04 18:06</div>
            <div class="timeline-body"><p>I don&#x27;t like the name of this method currently because it implies that if it returns <code>None</code> the class is not a builtin. But that&#x27;s not necessarily true, since our list of known builtins isn&#x27;t exhaustive. I&#x27;d prefer <code>maybe_known_builtin</code>. Or just <code>maybe_known</code> if we go with the broader refactor/rename to handle any known class, even if it&#x27;s not a builtin.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-04 18:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 18:10</div>
            <div class="timeline-body"><p>Hmm, I considered the pros and cons of <code>Option&lt;KnownFunction&gt;</code> vs having <code>FunctionKind::Ordinary</code> while working on my previous PR. I ended up going with <code>FunctionKind::Ordinary</code> because I have a general preference having a flat list of possible states rather than representing possible states using an enum of enums. It makes it easier to count exactly how many possible states there are, and giving the default state a name (<code>Ordinary</code>) rather than using <code>None</code> makes it abundantly clear to new readers of the code what the default state represents. It&#x27;s also more ergonomic to pattern-match on a flat list rather than a nested enum.</p>
<p>I don&#x27;t feel <em>too</em> strongly, but a flat enum would be my preference :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-04 18:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 18:16</div>
            <div class="timeline-body"><p>I think clearer naming is the primary reason I prefer <code>Option&lt;KnownFunction&gt;</code>. I don&#x27;t like the name <code>FunctionKind</code> because it is so unnecessarily generic -- it doesn&#x27;t clarify anything at all about what characteristic(s) of the function we are actually talking about. What happens when we later need to categorize functions according to some totally different cross-cutting categorization?</p>
<p>It seems clearer to me to have <code>known = Some(KnownFunction)</code> mean it&#x27;s a known function (and then the enum specifies which one), and <code>known = None</code> to mean &quot;not a known function.&quot; I suppose we could still use the <code>KnownFunction</code> name and have <code>KnownFunction::NotKnown</code> or <code>KnownFunction::None</code> -- it just seems weird to me to have a variant of <code>KnownFunction</code> that means... not a known function.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-04 18:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 18:22</div>
            <div class="timeline-body"><p>Yes, you&#x27;re definitely right that <code>FunctionKind</code> is not a great name. And I think you&#x27;re right that renaming it to <code>KnownFunction</code> addresses some of the concern I had that it wouldn&#x27;t be obvious what the default state signified. When it&#x27;s called <code>KnownFunction</code>, it&#x27;s pretty obvious that <code>None</code> indicates that it&#x27;s not a known function!</p>
<p>I&#x27;m still not a massive fan of nested enums, but I guess in this case it&#x27;s <em>okay</em>. Feel free to proceed :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-04 19:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 19:32</div>
            <div class="timeline-body"><p>Would you like me to address this naming change in this PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-04 19:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1288 on 2024-10-04 19:33</div>
            <div class="timeline-body"><p>Completely agree. I think I like this <code>known</code> prefix - what would you think of also adding it to the type we store internally?
I&#x27;m overall afraid that a new reader would come - see a builtin field - and trust that it covers all existing builtins</p>
<p>Edit: realised an above comment goes that way</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-04 19:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 19:38</div>
            <div class="timeline-body"><p>Yes, if you&#x27;re up for it I think it would be ideal to go ahead and make the switch to both <code>KnownClass</code> and <code>KnownFunction</code> enums in this PR, with <code>ClassType</code> having a field <code>known: Option&lt;KnownClass&gt;</code> and a method <code>is_known</code>, and similar for <code>FunctionType</code>. Where <code>KnownFunction</code> would replace the current <code>FunctionKind</code> enum, and the new <code>FunctionType::known</code> field would replace the current <code>FunctionType::kind</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-04 19:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1288 on 2024-10-04 19:39</div>
            <div class="timeline-body"><p>Agreed; I think this is a good enough reason to go ahead and fully make the change to &quot;Known&quot; terminology in this PR, as described in the other comment thread.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-04 22:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:832 on 2024-10-04 22:06</div>
            <div class="timeline-body"><p>The newest commit implements a first attempt at this. I did three things:</p>
<ul>
<li>Apply naming convention for <code>KnownFunction</code></li>
<li>Apply naming convention for <code>KnownClass</code></li>
<li>Try to extend the structure in <code>KnownClass</code> to easily support non-builtins</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:419 on 2024-10-05 05:20</div>
            <div class="timeline-body"><p>Is there a reason you went for <code>is_known_class</code> rather than <code>is_known</code> for this method? It&#x27;s ok either way, just feels like an unnecessary level of repetition of the word &quot;class&quot; when we have <code>class.is_known_class(db, KnownClass::...)</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-05 05:21</div>
            <div class="timeline-body"><p>One question about method naming, otherwise this looks excellent, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 07:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:419 on 2024-10-05 07:18</div>
            <div class="timeline-body"><p>No reason, is known is good!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 07:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:419 on 2024-10-05 07:40</div>
            <div class="timeline-body"><p>@carljm should be fixed!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 10:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:365 on 2024-10-05 10:20</div>
            <div class="timeline-body"><p>Ah. @carljm, I think this might actually reveal a bug in <code>main</code>. The union of <code>Literal[True] | Literal[False]</code> should surely simplify to <code>Instance(&quot;bool&quot;)</code> rather than <code>Class(&quot;bool&quot;)</code>. If an object has type <code>Literal[True]</code>, it indicates that it the object is an instance of <code>bool</code>, not that it is the <code>bool</code> class itself.</p>
<p>The fact that the new idiom in this PR makes this bug more obvious is definitely a point in favour of us landing it @Slyces!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 10:24</div>
            <div class="timeline-body"><p>Nit: I&#x27;d probably add the other &quot;fundamental&quot; types in this list (<code>types.ModuleType</code>, <code>types.FunctionType</code>, <code>_typeshed.NoneType</code> and <code>builtins.type</code>) to the <code>KnownClass</code> enum as well, and take <code>typing.Any</code> out of the enum for now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:902 on 2024-10-05 10:40</div>
            <div class="timeline-body"><p>this feels a bit repetitive, and it also feels like we&#x27;re doing some work that isn&#x27;t always necessary depending on what <code>self</code> is. Maybe something like this?</p>
<pre><code>        let is_stdlib_module = module.search_path().is_standard_library();
        let module_name = module.name().as_str();
        match self {
            Self::Any =&gt; is_stdlib_module &amp;&amp; matches!(module_name, &quot;typing&quot; | &quot;typing_extensions&quot;)
            _ =&gt; is_stdlib_module &amp;&amp; module_name == &quot;builtins&quot;,
        }
</code></pre>
<p>I&#x27;d actually also prefer it if we tediously enumerated all the builtin classes rather than using <code>_</code> as a fallback branch. If we do it that way then the compiler will warn us when we add a new non-builtins variant but forget to update this method, which would lead to incorrect results.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:890 on 2024-10-05 10:43</div>
            <div class="timeline-body"><p>I wish Rust had some way of enforcing that the r.h.s. of a match statement is meant to be exhaustive :/ I guess that&#x27;s what you were going for with your initial <code>EnumIter</code> solution from <code>strum</code>. But I agree with Dhruv that it&#x27;s probably not really worth an extra dependency.</p>
<p>If this enum continues to grow and this becomes a maintenance problem, I guess we could consider writing a macro to generate this method, which would allow us to ensure that the r.h.s. of the <code>match</code> is exhaustive. But that comes with its own tradeoffs, of course.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 10:43</div>
            <div class="timeline-body"><p>Seems fine to me other than a couple of nits!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 13:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:902 on 2024-10-05 13:07</div>
            <div class="timeline-body"><p>Actually we could also early return if we are not in stdlib as all cases in the close future would be in stdlib</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 13:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:365 on 2024-10-05 13:40</div>
            <div class="timeline-body"><p>Great catch, definitely didn&#x27;t see it myself!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 13:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:365 on 2024-10-05 13:43</div>
            <div class="timeline-body"><p>(It doesn&#x27;t need to be fixed in this PR, since I guess it&#x27;ll require other changes elsewhere that your PR currently doesn&#x27;t touch! Though it might actually be a pretty small change â€” if so, it&#x27;s probably okay to fix it here if you feel like it ðŸ˜†)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 15:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 15:55</div>
            <div class="timeline-body"><p>Why is it <code>_typeshed.NoneType</code>? In my repl I see the <code>type(None)</code> from builtins?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-05 15:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 15:58</div>
            <div class="timeline-body"><p>The type of <code>None</code> (<code>NoneType</code>) is not exposed in the stdlib at all in some versions of Python, and is never exposed in builtins. The <code>None</code> singleton object is in builtins, but typeshed needs a place to give the definition of the <em>type</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 16:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:890 on 2024-10-05 16:02</div>
            <div class="timeline-body"><p>I agree, and indeed this is where my mind went first when I introduced <code>strum</code>: make sure that extending the enum is as painless as possible. I&#x27;m dropping a <code>// Note</code> in there for future reference. Also found a stackoverflow exploring exactly this limitation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 16:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 16:03</div>
            <div class="timeline-body"><p>Would you have a reference or strategy (maybe to drop in the comment of the enum) to find out where a given common symbol is defined?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 16:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 16:03</div>
            <div class="timeline-body"><p>The <a href="https://github.com/python/typeshed/tree/main/stdlib/_typeshed"><code>_typeshed</code> module</a> is a fictitious module that typeshed pretends is part of the standard library. Because typeshed pretends it&#x27;s part of the stdlib, and we treat typeshed&#x27;s stubs as the sole source of truth for the stdlib, we think it&#x27;s part of the stdlib too!</p>
<p>The purpose of the <code>_typeshed</code> module is twofold:</p>
<ul>
<li>to define various convenient aliases and protocols that don&#x27;t exist at runtime but which are used extensively in typeshed&#x27;s stubs for the stdlib. These need to be defined in a stdlib module, because typeshed&#x27;s stubs for the stdlib can&#x27;t depend on any non-stdlib stubs.</li>
<li>to define certain compatibility workarounds for type checkers (that&#x27;s us!) to use. <code>_typeshed.NoneType</code> <a href="https://github.com/python/typeshed/blob/fc611d94c8edf225df33c8ccf66a62e6f4894679/stdlib/_typeshed/__init__.pyi#L304-L311">is an example of this</a>. At runtime, the type of <code>None</code> is <code>types.NoneType</code>, but <code>types.NoneType</code> was <a href="https://docs.python.org/3/library/types.html#types.NoneType">only added in 3.10</a>. We can&#x27;t use that as the type of <code>None</code>, as we still support Python 3.8 and 3.9, and all other type checkers also have this problem -- so typeshed defines <code>_typeshed.NoneType</code> as a little compatibility hack for us.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 16:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:365 on 2024-10-05 16:06</div>
            <div class="timeline-body"><p>Might prefer a separate PR if that&#x27;s ok!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 16:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:365 on 2024-10-05 16:08</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/issues/13642</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 16:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 16:13</div>
            <div class="timeline-body"><p>So, small question on the topic. I see that we have methods to lookup <code>typing_extensions</code>, but nothing from <code>typing</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 16:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 16:13</div>
            <div class="timeline-body"><blockquote>
<p>Would you have a reference or strategy (maybe to drop in the comment of the enum) to find out where a given common symbol is defined?</p>
</blockquote>
<p>I guess I&#x27;d probably <code>cd</code> into this directory and grep for the type&#x27;s name? https://github.com/astral-sh/ruff/tree/main/crates/red_knot_vendored/vendor/typeshed/stdlib</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 16:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 16:20</div>
            <div class="timeline-body"><blockquote>
<p>So, small question on the topic. I see that we have methods to lookup <code>typing_extensions</code>, but nothing from <code>typing</code></p>
</blockquote>
<p>Yeah, that&#x27;s for a very similar reason! There&#x27;s some symbols that only exist in <code>typing</code> on some versions of Python, but exist in <code>typing_extensions</code> on all versions of Python. That means that it&#x27;s usually better for a type checker to look things up in <code>typing_extensions</code> rather than <code>typing</code>, since <code>typing_extensions</code> re-exports all symbols from <code>typing</code>, and typeshed <a href="https://github.com/python/typeshed/blob/main/stdlib/typing_extensions.pyi">pretends <code>typing_extensions</code> is part of the stdlib</a>. (I <em>promise</em> typeshed doesn&#x27;t do this for <em>loads</em> of modules... only <code>_typeshed</code> and <code>typing_extensions</code>!!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/Slyces">@Slyces</a> on 2024-10-05 16:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a> reviewed on 2024-10-05 16:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Slyces">@Slyces</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:890 on 2024-10-05 16:31</div>
            <div class="timeline-body"><p>If that would be more manageable, one option we would have for the maintainability of mapping str to KnownClass would be to only add a dependency for tests, which would be used to ensure we didn&#x27;t miss a case.
Don&#x27;t know if that&#x27;s more acceptable, but it would ensure that we never miss a case without adding dependencies to the production code</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:754 on 2024-10-05 16:34</div>
            <div class="timeline-body"><pre><code>            Type::Function(_) =&gt; KnownClass::FunctionType.to_class(db),
            Type::Module(_) =&gt; KnownClass::ModuleType.to_class(db),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:758 on 2024-10-05 16:35</div>
            <div class="timeline-body"><pre><code>            Type::None =&gt; KnownClass::NoneType.to_class(db),
            // TODO not accurate if there&#x27;s a custom metaclass...
            Type::Class(_) =&gt; KnownClass::Type.to_class(db),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:843 on 2024-10-05 16:37</div>
            <div class="timeline-body"><p>nit</p>
<pre><code>    NoneType, // Part of `types` for Python &gt;= 3.10
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 16:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-10-05 16:47</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-05 16:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:890 on 2024-10-05 16:50</div>
            <div class="timeline-body"><p>Let&#x27;s land the PR for now. Maybe we can create an issue to discuss this further and see what the other red-knot maintainers think :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-05 17:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-05 17:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-05 17:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-07 08:40</div>
            <div class="timeline-body"><p>I like this a lot. This is excellent API design :)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:07:12 UTC
    </footer>
</body>
</html>
