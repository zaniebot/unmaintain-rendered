<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Lint registry and rule selection - astral-sh/ruff #14874</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Lint registry and rule selection</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14874">#14874</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2024-12-09 14:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This is the third and last PR in this stack that adds support for toggling lints at a per-rule level.</p>
<p>This PR introduces a new <code>LintRegistry</code>, a central index of known lints. The registry is required because we want to support lint rules from many different crates but need a way to look them up by name, e.g., when resolving a lint from a name in the configuration or analyzing a suppression comment.</p>
<p>Adding a lint now requires two steps:</p>
<ol>
<li>Declare the lint with <code>declare_lint</code></li>
<li>Register the lint in the registry inside the <code>register_lints</code> function.</li>
</ol>
<p>I considered some more involved macros to avoid changes in two places. Still, I ultimately decided against it because a) it's just two places and b) I'd expect that registering a type checker lint will differ from registering a lint that runs as a rule in the linter. I worry that any more opinionated design could limit our options when working on the linter, so I kept it simple.</p>
<p>The second part of this PR is the <code>RuleSelection</code>. It stores which lints are enabled and what severity they should use for created diagnostics. For now, the <code>RuleSelection</code> always gets initialized with all known lints and it uses their default level.</p>
<h2>Linter crates</h2>
<p>Each crate that defines lints should export a <code>register_lints</code> function that accepts a <code>&amp;mut LintRegistryBuilder</code> to register all its known lints in the registry. This should make registering all known lints in a top-level crate easy: Just call <code>register_lints</code> of every crate that defines lint rules.</p>
<p>I considered defining a <code>LintCollection</code> trait and even some fancy macros to accomplish the same but decided to go for this very simplistic approach for now. We can add more abstraction once needed.</p>
<h2>Lint rules</h2>
<p>This is a bit hand-wavy. I don't have a good sense for how our linter infrastructure will look like, but I expect we'll need a way to register the rules that should run as part of the red knot linter. One way is to keep doing what Ruff does by having one massive <code>checker</code> and each lint rule adds a call to itself in the relevant AST visitor methods. An alternative is that we have a <code>LintRule</code> trait that provides common hooks and implementations will be called at the &quot;right time&quot;. Such a design would need a way to register all known lint implementations, possibly with the lint. This is where we'd probably want a dedicated <code>register_rule</code> method. A third option is that lint rules are handled separately from the <code>LintRegistry</code> and are specific to the linter crate.</p>
<p>The current design should be flexible enough to support the three options.</p>
<h2>Documentation generation</h2>
<p>The documentation for all known lints can be generated by creating a factory, registering all lints by calling the <code>register_lints</code> methods, and then querying the registry for the metadata.</p>
<h2>Deserialization and Schema generation</h2>
<p>I haven't fully decided what the best approach is when it comes to deserializing lint rule names:</p>
<ul>
<li>Reject invalid names in the deserializer. This gives us error messages with line and column numbers (by serde)</li>
<li>Don't validate lint rule names during deserialization; defer the validation until the configuration is resolved. This gives us more control over handling the error, e.g. emit a warning diagnostic instead of aborting when a rule isn't known.</li>
</ul>
<p>One technical challenge for both deserialization and schema generation is that the <code>Deserialize</code> and <code>JSONSchema</code> traits do not allow passing the <code>LintRegistry</code>, which is required to look up the lints by name. I suggest that we either rely on the salsa db being set for the current thread (<code>salsa::Attach</code>) or build our own thread-local storage for the <code>LintRegistry</code>. It's the caller's responsibility to make the lint registry available before calling <code>Deserialize</code> or <code>JSONSchema</code>.</p>
<h2>CLI support</h2>
<p>I prefer deferring adding support for enabling and disabling lints from the CLI for now because I think it will be easier
to add once I've figured out how to handle configurations.</p>
<h2>Bitset optimization</h2>
<p>Ruff tracks the enabled rules using a cheap copyable <code>Bitset</code> instead of a hash map. This helped improve performance by a few percent (see https://github.com/astral-sh/ruff/pull/3606). However, this approach is no longer possible because lints have no &quot;cheap&quot; way to compute their index inside the registry (other than using a hash map).</p>
<p>We could consider doing something similar to Salsa where each <code>LintMetadata</code> stores a <code>LazyLintIndex</code>.</p>
<pre><code>pub struct LazyLintIndex {
	cached: OnceLock&lt;(Nonce, LintIndex)&gt;
}

impl LazyLintIndex {
	pub fn get(registry: &amp;LintRegistry, lint: &amp;'static LintMetadata) {
	
	let (nonce, index) = self.cached.get_or_init(|| registry.lint_index(lint));

	if registry.nonce() == nonce {
		index
	} else {
		registry.lint_index(lint)
	}
}
</code></pre>
<p>Each registry keeps a map from <code>LintId</code> to <code>LintIndex</code> where <code>LintIndex</code> is in the range of <code>0...registry.len()</code>. The <code>LazyLintIndex</code> is based on the assumption that every program has exactly <strong>one</strong> registry. This assumption allows to cache the <code>LintIndex</code> directly on the <code>LintMetadata</code>. The implementation falls back to the &quot;slow&quot; path if there is more than one registry at runtime.</p>
<p>I was very close to implementing this optimization because it's kind of fun to implement. I ultimately decided against it because it adds complexity and I don't think it's worth doing in Red Knot today:</p>
<ul>
<li>Red Knot only queries the rule selection when deciding whether or not to emit a diagnostic. It is rarely used to detect if a certain code block should run. This is different from Ruff where the rule selection is queried many times for every single AST node to determine which rules <em>should</em> run.</li>
<li>I'm not sure if a 2-3% performance improvement is worth the complexity</li>
</ul>
<p>I suggest revisiting this decision when working on the linter where a fast path for deciding if a rule is enabled might be more important (but that depends on how lint rules are implemented)</p>
<h2>Test Plan</h2>
<p>I removed a lint from the default rule registry, and the MD tests started failing because the diagnostics were no longer emitted.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2024-12-09 14:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-09 14:46</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @MichaReiser on 2024-12-09 15:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @MichaReiser on 2024-12-09 15:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @MichaReiser on 2024-12-09 15:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @MichaReiser on 2024-12-09 15:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-12-10 01:23</div>
            <div class="timeline-body"><p>Looks good!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-12-11 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-12-11 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-12-11 12:25</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:08:22 UTC
    </footer>
</body>
</html>
