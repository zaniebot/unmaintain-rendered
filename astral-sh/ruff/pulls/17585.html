<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add `FunctionType::to_overloaded` - astral-sh/ruff #17585</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add <code>FunctionType::to_overloaded</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17585">#17585</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2025-04-23 16:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-04-23 16:09</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR adds a new method <code>FunctionType::to_overloaded</code> which converts a <code>FunctionType</code> into an <code>OverloadedFunction</code> which contains all the <code>@overload</code>-ed <code>FunctionType</code> and the implementation <code>FunctionType</code> if it exists.</p>
<p>There's a big caveat here (it's the way overloads work) which is that this method can only &quot;see&quot; all the overloads that comes <em>before</em> itself. Consider the following example:</p>
<pre><code class="language-py">from typing import overload

@overload
def foo() -&gt; None: ...
@overload
def foo(x: int) -&gt; int: ...
def foo(x: int | None) -&gt; int | None:
	return x
</code></pre>
<p>Here, when the <code>to_overloaded</code> method is invoked on the</p>
<ol>
<li>first <code>foo</code> definition, it would only contain a single overload which is itself and no implementation.</li>
<li>second <code>foo</code> definition, it would contain both overloads and still no implementation</li>
<li>third <code>foo</code> definition, it would contain both overloads and the implementation which is itself</li>
</ol>
<h3>Usages</h3>
<p>This method will be used in the logic for checking invalid overload usages. It can also be used for #17541.</p>
<h2>Test Plan</h2>
<p>Make sure that existing tests pass.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @dhruvmanila on 2025-04-23 16:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @dhruvmanila on 2025-04-23 16:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-23 16:14</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dhruvmanila on 2025-04-23 17:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dhruvmanila on 2025-04-23 17:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dhruvmanila on 2025-04-23 17:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dhruvmanila on 2025-04-23 17:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @dhruvmanila on 2025-04-23 17:32</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-23 19:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6099 on 2025-04-23 19:56</div>
            <div class="timeline-body"><p>Is this needed because salsa woudd otherwise incorrectly pick up the inner function and make it a method?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6099 on 2025-04-23 20:01</div>
            <div class="timeline-body"><p>Interesting. So having the <code>#[salsa::tracked]</code> on the impl block causes problems with having a non-query method with a nested query inside it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 20:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6099 on 2025-04-23 20:01</div>
            <div class="timeline-body"><p>I'm not sure by &quot;make it a method&quot; but I think it would make it a query because the previous <code>impl</code> block is marked with <code>#[salsa::tracked]</code> and it seems wasteful to only cache the <code>.as_ref</code> call because the inner function is already tracked.</p>
<p>I could possibly avoid marking the inner function as salsa tracked and merge this into the above <code>impl</code> block.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-04-23 20:02</div>
            <div class="timeline-body"><p>This looks great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-23 20:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:08</div>
            <div class="timeline-body"><p>Does that mean that we call <code>to_overloaded</code> 4 times if a function has 3 overloads (and one impl). 4 times because:</p>
<ol>
<li><code>to_overloaded</code> on the implementation</li>
<li>which calls into <code>to_overloaded</code> on the last overload</li>
<li>which, in turn, calls into `to_overloaded on the second overload</li>
<li>which, in turn, calls into <code>to_overloaded</code> on the first overload</li>
</ol>
<p>Or is it at most two <code>to_overloaded</code> calls, one for the impl (root) which then calls into the <code>to_overloaded</code> for the first overload?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-23 20:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6099 on 2025-04-23 20:11</div>
            <div class="timeline-body"><blockquote>
<p>I'm not sure by &quot;make it a method&quot; but I think it would make it a query because the previous impl block is marked with #[salsa::tracked] and it seems wasteful to only cache the .as_ref call because the inner function is already tracked.</p>
</blockquote>
<p>The <code>#[salsa::tracked]</code> on the impl block doesn't make all functions in that block query. Only functions that itself are also marked with <code>#[salsa::tracked]</code> will become queries. That's why I think it should be fine to merge the impl blocks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 20:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:14</div>
            <div class="timeline-body"><p>Yes, the former is correct. It will call 4 times.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 20:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:16</div>
            <div class="timeline-body"><p>This kind of gives me a thought as to whether this is being wasting resources in terms of memory because we don't really need to cache the calls on the function that isn't the implementation or the last overload (if implementation doesn't exists).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-23 20:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:19</div>
            <div class="timeline-body"><p>Only caching the last result would be great. Not only reduces it overall memory consumption. It also removes the need to clone the <code>overloads</code> vec multiple times only to add one extra element.</p>
<p>Would it be possible to rewrite this logic as a loop where we store the current function type that we look up instead of a recursive function call?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 20:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6099 on 2025-04-23 20:20</div>
            <div class="timeline-body"><p>I think I misunderstood what <code>#[salsa::tracked]</code> does on an impl block. I think I can just merge the two impl blocks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 20:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6099 on 2025-04-23 20:20</div>
            <div class="timeline-body"><p>Yeah, I'm not sure why I thought of that. I just realized after sending this message. Thanks. I'll change it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6157 on 2025-04-23 20:20</div>
            <div class="timeline-body"><p>It would be great to document the limitations that the method only returns overloads defined <em>before</em> <code>self</code> as this may not be immediately obvious from the implementation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-23 20:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-23 20:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:31</div>
            <div class="timeline-body"><p>It should be possible to do this iteratively instead of recursively. It will be less efficient (will repeat work) if we did end up calling it on intermediate overloads too, but it should be somewhat more efficient if we only end up calling it on the last overload. Which I think should usually be the case?</p>
<p>The memory used here is tiny, and there's no cold regression shown; I doubt that overloads will ever be a significant part of our overall performance profile (cold check time or memory). There is a 1% incremental regression, probably due to the new memoized query results; an iterative approach might be able to bring that down if it reduces the number of memos?</p>
<p>I don't think we should spend more than an hour or two right now on reworking this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-23 20:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:33</div>
            <div class="timeline-body"><blockquote>
<p>t should be possible to do this iteratively instead of recursively. It will be less efficient (will repeat work) if we did end up calling it on intermediate overloads too, but it should be somewhat more efficient if we only end up calling it on the last overload. Which I think should usually be the case?</p>
</blockquote>
<p>Could we remove the query all-together, considering that they're rare and because <code>to_overloaded</code> is only called from <code>signature</code> which itself is cached?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 20:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 20:36</div>
            <div class="timeline-body"><p>Yeah, I don't think we would face any regression if we don't cache the <code>to_overloaded</code> right now as most of the usages of overloads would come from <code>signature</code> which is cached.</p>
<p>Currently, there isn't any usages of <code>to_overloaded</code> but that will happen when I add the checks for valid overloads in a follow-up PR. I think I'd prefer to see if removing the cache would cause any regression after that and not now. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-23 21:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 21:09</div>
            <div class="timeline-body"><p>There will likely be another upcoming use for dataclass transforms that wouldn't be from within signature? But would also be within a different query.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 21:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6165 on 2025-04-23 21:19</div>
            <div class="timeline-body"><p>Yeah, for now I'll just follow-up with an iterative approach instead. I'll merge this PR after expanding the documentation for <code>to_overloaded</code> method.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2025-04-23 21:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:6157 on 2025-04-23 21:19</div>
            <div class="timeline-body"><p>Added a note in <a href="https://github.com/astral-sh/ruff/pull/17585/commits/734a708fb407b4a1c90c1e2c4e8becea97cedd5d"><code>734a708</code> (#17585)</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-04-23 21:26</div>
            <div class="timeline-body"><p>Merging this PR, I'll follow-up with an iterative approach (instead of the current recursive approach) to collect the overloads. Later, once we have a couple of usages of <code>to_overloaded</code> we can check if not caching the method regresses or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dhruvmanila on 2025-04-23 21:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2025-04-23 21:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-23 21:27</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:33:29 UTC
    </footer>
</body>
</html>
