<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Attribute access on intersection types - astral-sh/ruff #16665</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Attribute access on intersection types</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/16665">#16665</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-03-12 09:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-03-12 09:29</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Implements attribute access on intersection types, which didn't previously work. For example:</p>
<pre><code class="language-py">from typing import Any

class P: ...
class Q: ...

class A:
    x: P = P()

class B:
    x: Any = Q()

def _(obj: A):
    if isinstance(obj, B):
        reveal_type(obj.x)  # revealed: P &amp; Any
</code></pre>
<p>Refers to <a href="https://github.com/astral-sh/ruff/pull/16416#discussion_r1985040363">this comment</a>.</p>
<h2>Test Plan</h2>
<p>New Markdown tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-03-12 09:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-03-12 09:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-03-12 09:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-03-12 09:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-12 09:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:1061 on 2025-03-12 09:34</div>
            <div class="timeline-body"><p>I wonder if we should allow <code>type[Intersection[A, B]]</code> in type expressions, as a shorthand for <code>Intersection[type[A], type[B]]</code>. We already allow (and it's mandated by the spec) <code>type[A | B]</code> and <code>type[Union[A, B]]</code> as shorthands for <code>type[A] | type[B]</code>.</p>
<p>Obviously doesn't need to be done in this PR, though</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-12 09:35</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">arrow (https://github.com/arrow-py/arrow)
- warning: lint:possibly-unbound-attribute
-    --&gt; /tmp/mypy_primer/projects/arrow/arrow/factory.py:237:47
-     |
- 235 |             # (Arrow) -&gt; from the object's datetime @ tzinfo
- 236 |             elif isinstance(arg, Arrow):
- 237 |                 return self.type.fromdatetime(arg.datetime, tzinfo=tz)
-     |                                               ------------ Attribute `datetime` on type `@Todo &amp; Arrow &amp; ~Decimal | float &amp; Arrow` is possibly unbound
- 238 |
- 239 |             # (datetime) -&gt; from datetime @ tzinfo
-     |
- 
- 
- error: lint:unresolved-attribute
-     |
-     |
- 
- error: lint:unresolved-attribute
-    --&gt; /tmp/mypy_primer/projects/arrow/arrow/arrow.py:166:17
-     |
- 164 |             and hasattr(tzinfo, &quot;localize&quot;)
- 165 |             and hasattr(tzinfo, &quot;zone&quot;)
- 166 |             and tzinfo.zone
-     |                 ^^^^^^^^^^^ Type `@Todo &amp; tzinfo` has no attribute `zone`
- 167 |         ):
- 168 |             tzinfo = parser.TzinfoParser.parse(tzinfo.zone)
-     |
-    --&gt; /tmp/mypy_primer/projects/arrow/arrow/arrow.py:168:48
- 166 |             and tzinfo.zone
- 167 |         ):
- 168 |             tzinfo = parser.TzinfoParser.parse(tzinfo.zone)
-     |                                                ^^^^^^^^^^^ Type `@Todo &amp; tzinfo` has no attribute `zone`
- 169 |         elif isinstance(tzinfo, str):
- 170 |             tzinfo = parser.TzinfoParser.parse(tzinfo)
- Found 80 diagnostics
+ Found 77 diagnostics

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:1080 on 2025-03-12 10:37</div>
            <div class="timeline-body"><p>Again, not something for this PR necessarily. But I think that this implies that we should infer the following case like so:</p>
<pre><code class="language-py">@final
class A: ...
class B: ...
class C:
    x: A
class D:
    x: B

def f(y: C):
    if isinstance(y, D):
        reveal_type(y)  # revealed: Never
</code></pre>
<p>Because we know that all instances of <code>C</code> have an <code>x</code> attribute, but the inferred type of the <code>x</code> attribute on the <code>y</code> variable would be <code>A &amp; B</code>, which simplifies  to <code>Never</code>, since <code>A</code> is <code>@final</code>. An inferred attribute type of <code>Never</code> for the <code>x</code> attribute is the same thing as saying that <code>y</code> cannot have an attribute <code>x</code> in this branch,  but we already established that <code>y</code> <em>must</em> have an <code>x</code> attribute, since <code>y</code> is an instance of <code>C</code>. The only way to solve this contradiction is to say that this branch is in fact unreachable: <code>C &amp; D</code> must simplify to <code>Never</code> due to the fact that <code>A &amp; B</code> simplifies to <code>Never</code>.</p>
<p>This is perhaps quite a long-winded proof for something that is self-evident...! I think mypy and pyright might also infer unreachable code in cases like this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-12 10:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:1080 on 2025-03-12 11:49</div>
            <div class="timeline-body"><p>We already (with this PR) correctly infer the type of <code>y.x</code> as <code>Never</code> in your example.</p>
<p>I think it is also correct to go from that to inferring <code>C &amp; D</code> itself as <code>Never</code>, but this could be quite expensive to implement (since it would require checking every attribute of any pair of types that end up in an intersection together), and it's not clear to me how necessary/valuable it will be in practice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-03-12 11:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-03-12 12:00</div>
            <div class="timeline-body"><p>(mypy-primer changes look correct)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-03-12 12:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-03-12 12:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-03-12 12:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/attributes.md</code>:1080 on 2025-03-12 12:25</div>
            <div class="timeline-body"><blockquote>
<p>We already (with this PR) correctly infer the type of <code>y.x</code> as <code>Never</code> in your example.</p>
</blockquote>
<p>I know; it was the further inference that I was attempting to discuss.</p>
<p>Anyway, I agree that we can defer this for now and see how expensive and/or useful it is later!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-03-12 12:25</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:49:32 UTC
    </footer>
</body>
</html>
