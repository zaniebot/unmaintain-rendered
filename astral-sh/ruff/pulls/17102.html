<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add `Type::TypeVar` variant - astral-sh/ruff #17102</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add <code>Type::TypeVar</code> variant</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17102">#17102</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-03-31 21:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dcreager">@dcreager</a> on 2025-03-31 21:50</div>
            <div class="timeline-body"><p>This adds a new <code>Type</code> variant for holding an instance of a typevar inside of a generic function or class.  We don't handle specializing the typevars yet, but this should implement most of the typing rules for inside the generic function/class, where we don't know yet which specific type the typevar will be specialized to.</p>
<p>This PR does <em>not</em> yet handle the constraint that multiple occurrences of the typevar must be specialized to the <em>same</em> time.  (There is an existing test case for this in <code>generics/functions.md</code> which is still marked as TODO.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @dcreager on 2025-03-31 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-03-31 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-03-31 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dcreager on 2025-03-31 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:555 on 2025-03-31 21:51</div>
            <div class="timeline-body"><p>I have implemented all of these <code>Type</code> functions with the interpretation that a typevar is not fully static, since it can be specialized to a dynamic type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-03-31 21:52</div>
            <div class="timeline-body"><p>Open question</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1507 on 2025-03-31 21:52</div>
            <div class="timeline-body"><p>ditto open question</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-03-31 21:53</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2028 on 2025-03-31 21:53</div>
            <div class="timeline-body"><p>Switching to using <code>UnionType</code> instead of <code>TupleType</code> to hold typevar constraints lets me use these helper methods where we need to treat the constraints the same as an actual union.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3282 on 2025-03-31 21:54</div>
            <div class="timeline-body"><p>One way to handle this would be to have a new <code>FinalInstance</code> type variant, which is an instance of a particular type but not any of its subclasses.  I'm pretty sure that's what pyright is doing with its <code>type*</code> notation, which is what it infers typevar constraint elements as.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-03-31 21:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 06:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-04-01 06:47</div>
            <div class="timeline-body"><blockquote>
<p>Should a bounded typevar be considered a singleton if its bound is?</p>
</blockquote>
<p>I don't think so? Even without gradual types, you could always assign <code>Never</code>, which is also not a singleton.</p>
<p>For <em>constrained</em> typevars, we might be able to return <code>true</code> in some cases (if all possible options are singleton types)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 06:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1507 on 2025-04-01 06:51</div>
            <div class="timeline-body"><p>Same here, returning <code>false</code> seems correct for bounded typevars, since <code>Never</code> is always a possibility and it's not single-valued.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 07:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:77 on 2025-04-01 07:00</div>
            <div class="timeline-body"><blockquote>
<p>Unless the bound is final, in which case the final class is also assignable to the typevar</p>
</blockquote>
<p>Is this true? <code>Never</code> is always a subtype of the bound (and therefore a valid specialization?), but a final bound is not assignable to <code>Never</code> (unless it would also be <code>Never</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 07:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:95 on 2025-04-01 07:08</div>
            <div class="timeline-body"><p>See above: I'm not sure if this should really be assignable. <code>FinalClass</code> can have no subclasses, but it does have subtypes. So <code>T</code> could be <code>Never</code>, and  <code>FinalClass</code> is not assignable to <code>T</code>.</p>
<p>Unrelated hint: I usually encode the assertion that I <em>want</em> to hold true and silence the static-assertion error using <code># error</code>. This way, the TODO can be resolved by removing the error assertion instead of having to invert the Boolean condition. It's really just a stylistic preference, but I think it makes the tests a bit easier to read if you can just ignore the comments and see the actual assertions in code:</p>
<pre><code class="language-suggestion">    # TODO: This should hold true
    # error: [static-assert-error]
    static_assert(is_assignable_to(FinalClass, T))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:317 on 2025-04-01 07:15</div>
            <div class="timeline-body"><p>Maybe add some documentation here, or is the documentation on <code>TypeVarInstance</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-04-01 07:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 07:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:95 on 2025-04-01 07:20</div>
            <div class="timeline-body"><p>Maybe it could be argued for this particular function that if <code>T</code> is <code>Never</code>, the function could never be called (as there is no value which could be passed in as argument). And in this sense, <code>FinalClass</code> could be considered assignable to <code>T</code>, since the body would not be executed if <code>T</code> would be <code>Never</code>.</p>
<p>But then I could change the example slightly to</p>
<pre><code class="language-py">def bounded_final[T: FinalClass](t: list[T]) -&gt; T:
    # same body
</code></pre>
<p>and this function <em>can</em> be called with an empty list of type <code>list[Never]</code>. And therefore I would conclude that <code>FinalClass</code> should not be assignable to <code>T</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-01 07:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:251 on 2025-04-01 07:37</div>
            <div class="timeline-body"><p>Would it make sense to add a test like the following? I could imagine that code like this gets written if a generic function needs special handling for a particular special case?</p>
<pre><code class="language-py">class P: ...
class Q: ...

def constrained[T: (P, Q)](t: T) -&gt; None:
    if isinstance(t, P):
        p: P = t  # this works already on your branch
    else:
        q: Q = t  # this yields an error, but should be fine(?)
</code></pre>
<p>Alternatively, we could also use <code>reveal_type(t)</code> in those branches and assert on the narrowed types of <code>t</code>. We currently reveal <code>T &amp; P</code> and <code>T &amp; ~P</code>, which might be simplified to <code>P</code> and <code>Q</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:77 on 2025-04-01 13:28</div>
            <div class="timeline-body"><p>That's a great catch, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:95 on 2025-04-01 13:29</div>
            <div class="timeline-body"><blockquote>
<p>Unrelated hint: I usually encode the assertion that I <em>want</em> to hold true and silence the static-assertion error using <code># error</code>.</p>
</blockquote>
<p>I like that, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:251 on 2025-04-01 13:30</div>
            <div class="timeline-body"><p>Yes, good idea.  I hadn't touched the narrowing code, but should.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:317 on 2025-04-01 13:32</div>
            <div class="timeline-body"><p>Done.  (There is documentation down at <code>TypeVarInstance</code> describing the fields of the struct, but I added some here too describing the intent of this type variant)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-04-01 13:41</div>
            <div class="timeline-body"><blockquote>
<p>For <em>constrained</em> typevars, we might be able to return <code>true</code> in some cases (if all possible options are singleton types)?</p>
</blockquote>
<p>Yeah I wasn't sure how &quot;viral&quot; to make the constraints in this case. You can still specialize the typevar as <code>Any</code>, which is not in general a singleton. But do we want to carry through the knowledge that that <code>Any</code> can really only be materialized to one of the constraint types?</p>
<p>And if we do, do we want to that here too?:</p>
<pre><code class="language-py">def f[T: (int, str)](t: T):
    reveal_type(t.__class__) # revealed: Literal[int | str]
    a: Any = t
    reveal_type(a.__class__) # revealed: Any or Literal[int | str]?
</code></pre>
<p>(Though I could see the argument that the explicit <code>Any</code> annotation is a request to ignore the constraints for some reason?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-01 13:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-01 13:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:835 on 2025-04-01 13:46</div>
            <div class="timeline-body"><p>@sharkdp I think your comment about <code>Never</code> applies here, too:</p>
<pre><code class="language-py">@final
class F: ...

def f[T: F, U: F](t: list[T], u: list[U]) -&gt; None: ...
</code></pre>
<p>since <code>f[F, Never]</code> and <code>f[Never, F]</code> are valid specializations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:95 on 2025-04-01 14:28</div>
            <div class="timeline-body"><blockquote>
<p>But then I could change the example slightly to</p>
</blockquote>
<p>I updated all of the functions to use <code>list[?]</code> for consistency</p>
<blockquote>
<p>Unrelated hint: I usually encode the assertion that I <em>want</em> to hold true and silence the static-assertion error using <code># error</code>.</p>
</blockquote>
<p>With the changes to how we're handling final bounds/constraints, it turns out there aren't any more TODOs.  But I will keep this in mind for the future!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1435 on 2025-04-01 14:30</div>
            <div class="timeline-body"><p>I've implemented the interpretation that a constrained typevar is singleton/single-valued if all of the constraint types are.  I think that is not really the same as my &quot;assign to an explicitly <code>Any</code>-annotated variable&quot; case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-01 14:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-01 15:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:251 on 2025-04-01 15:01</div>
            <div class="timeline-body"><p>Looking at this more, I think this is because of how I've implemented <code>is_subtype_of</code> for typevars. Since they can be specialized to <code>Any</code>, I'm treating them as not fully static, so they don't participate in subtyping at all. If we loosened that a bit for constrained types, I think the existing intersection builder logic would simplify these as you suggest.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:555 on 2025-04-01 17:51</div>
            <div class="timeline-body"><p>We are actually going to do a simple syntactic check to determine if a typevar is fully static. The typevar is not fully static iff it has a not-fully-static bound or constraint. This lines up nicely with the definition in the <a href="https://typing.python.org/en/latest/spec/concepts.html#fully-static-and-gradual-types">typing spec</a>:</p>
<blockquote>
<p>We will refer to types that do not contain a gradual form as a sub-part as fully static types.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:251 on 2025-04-01 17:54</div>
            <div class="timeline-body"><p>And <a href="https://github.com/astral-sh/ruff/pull/17102#discussion_r2023399009">treating a typevar as fully static</a> if its constraints are fully static should then address this case, since typevars would then (often) participate in subtyping.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-01 17:54</div>
            <div class="timeline-body"><p>Summarizing a discussion from Discord:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-04-01 18:00</div>
            <div class="timeline-body"><p>(Currently planning to hold off on reviewing this until that fully-static change mentioned above is made, but please ping if there's anything it would be useful to get additional eyes on sooner.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-01 19:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:251 on 2025-04-01 19:45</div>
            <div class="timeline-body"><p>Implementing the full static / subtyping change helped with this, but I did also have to add special logic to the intersection builder for simplifying intersections with a constrained typevar.  We now desugar the typevar into a union of its constraints before simplifying.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-04-01 20:15</div>
            <div class="timeline-body"><blockquote>
<p>(Currently planning to hold off on reviewing this until that fully-static change mentioned above is made, but please ping if there's anything it would be useful to get additional eyes on sooner.)</p>
</blockquote>
<p>Fully-static change is up, merge conflicts resolved. Should be good for another round of review!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/type_ordering.rs</code>:125 on 2025-04-01 20:36</div>
            <div class="timeline-body"><p>I think you need to also make sure that two different TypeVars always have a consistent ordering here:</p>
<pre><code class="language-suggestion">        (Type::TypeVar(left), Type::TypeVar(right)) =&gt; left.cmp(right),
        (Type::TypeVar(_), _) =&gt; Ordering::Less,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-04-01 20:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/functions.md</code>:110 on 2025-04-01 20:41</div>
            <div class="timeline-body"><p>I would have naively expected this PR to resolve this TODO. I guess it doesn't because the PR currently just infers Unknown for all binary ops on typevars</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:97 on 2025-04-01 20:52</div>
            <div class="timeline-body"><p>What are the <code>t</code> and <code>u</code> parameters here for? Just to avoid (possible future?) diagnostics about unused/unbindable typevars? If that's the reason, any particular reason for them to be <code>list[T]</code> and <code>list[U]</code> rather than just <code>T</code> and <code>U</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:59 on 2025-04-01 20:56</div>
            <div class="timeline-body"><p>excluding <code>object</code>?</p>
<p>Could also make some kind of note about &quot;unbounded&quot; being equivalent to &quot;bounded by <code>object</code>&quot;, but maybe not necessary.</p>
<pre><code class="language-suggestion">other type (including other typevars), besides `object`, since we can make no assumption about what type it will be
specialized to.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:73 on 2025-04-01 21:03</div>
            <div class="timeline-body"><p>It's interesting to me that without <code>knot_extensions</code>, we would have probably written this test more in a &quot;real code example&quot; style, e.g. by actually trying to assign something typed as T to something typed as U and asserting the invalid-assignment error, etc.</p>
<p>Subtype tests are harder to write like that, you'd have to do something like create a union and see how it does or doesn't simplify.</p>
<p>I think this explicit unit-testy style is probably clearer and better? It just looks less like a real Python code example.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:138 on 2025-04-01 21:06</div>
            <div class="timeline-body"><p>Considering how much discussion it took for me at least to arrive at a clear understanding here, maybe it's worth its own commentary paragraph? Just something about how a typevar with a non-fully-static bound is a non-fully-static type and thus can't participate in subtyping, because it is bounded by an unknown type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:140 on 2025-04-01 21:09</div>
            <div class="timeline-body"><p>A more interesting test here would be whether <code>T</code> is assignable to some other random type that isn't <code>Any</code>, right? Like I would think <code>T</code> should be assignable to e.g. <code>int</code>, because the upper bound of <code>T</code> could materialize to <code>int</code>. (But not the other way around, <code>int</code> shouldn't be assignable to <code>T</code>, because regardless of what the upper bound materializes to, <code>T</code> could still specialize to a smaller type, even <code>Never</code>, and unlike materialization, specialization is not &quot;forgiving&quot;.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:141 on 2025-04-01 21:16</div>
            <div class="timeline-body"><p>But <code>int &amp; str</code> should be assignable to <code>T</code>, no?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:156 on 2025-04-01 21:17</div>
            <div class="timeline-body"><p>Similarly to above, I think here we are missing the most interesting tests, where we substitute some other concrete type instead of using <code>Any</code> and test how that affects type relations with a constraint of <code>Any</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:260 on 2025-04-01 21:27</div>
            <div class="timeline-body"><p>Might also be worth testing that <code>T | object</code> also simplifies to <code>int</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:279 on 2025-04-01 21:30</div>
            <div class="timeline-body"><p>Again <code>T | object</code> (where its a supertype of both constraints, but not identical to either of them) seems maybe worth explicitly testing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:354 on 2025-04-01 21:34</div>
            <div class="timeline-body"><p>I don't think this is right, as discussed above. I think this should still be <code>T &amp; Any</code>. (That is, it shouldn't simplify).</p>
<p>The unsoundness gets &quot;lost&quot; due to the use of <code>Any</code>, whose forgiving nature makes it unsound anyway, but if we imagine intersecting with a fourth unrelated type <code>D</code> here instead, we'd get <code>int &amp; D | str &amp; D | bool &amp; D</code>. By the nature of intersection <code>T &amp; D</code> must be a subtype of both <code>T</code> and <code>D</code>, so if we simplify <code>T &amp; D</code> to <code>int &amp; D | str &amp; D | bool &amp; D</code>, that implies this union must be a subtype of <code>T</code>. But it is not! <code>T</code> is not the union of its constraints, it is one (and only one) of them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:337 on 2025-04-01 21:44</div>
            <div class="timeline-body"><p>Not sure about the accuracy of the <code>TODO</code> here. With a constrained typevar like <code>[T: (A, B)]</code>, the typevar <code>T</code> must specialize to either the type <code>A</code> or the type <code>B</code>, not some hypothetical subtype <code>C</code> that is a subclass of <code>A</code>. But instances of <code>C</code> still inhabit the type <code>A</code>, and thus still inhabit the type <code>T</code> if it is specialized to <code>A</code>. The &quot;invariance&quot; of constraints only impacts the precision of the possible specializations, it doesn't change the meaning of the constraint types. So I don't think we need an &quot;instances of only this class&quot; type in order to properly represent a constrained typevar as a union.</p>
<p>That said, I'm also not convinced it's correct here to treat the typevar as the union of its constraints. If we imagine a typevar <code>[T: (A, B, C)]</code> and then we intersect that typevar with <code>A | B</code>, according to this handling we would get <code>(A | B | C) &amp; (A | B)</code>, which simplifies to <code>A | B</code>.  But that implies that <code>A | B &lt;: T</code>, which is not right! <code>T</code> is <em>one of</em> <code>A</code> or <code>B</code> or <code>C</code>, not the union of all three; <code>A | B</code> should not be assignable to <code>T</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:358 on 2025-04-01 21:49</div>
            <div class="timeline-body"><p>For the same reasons as above, I don't think this is correct either, and we should do less simplification here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:512 on 2025-04-01 21:52</div>
            <div class="timeline-body"><p>My objections above to treating a constrained typevar as the union of its constraints only apply when the result of simplification is still a union of some of the constraints. I think the below test is correct, because in every case we can simplify down to a single constraint, so we don't run into the problem of wrongly claiming that a union of (some of) the constraints is a subtype of the constrained typevar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:307 on 2025-04-01 21:56</div>
            <div class="timeline-body"><p>orthogonal nit!</p>
<pre><code class="language-suggestion">    // TODO protocols, overloads, generics
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:628 on 2025-04-01 22:16</div>
            <div class="timeline-body"><p>Do we need to normalize ordering of the constraints of a typevar?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:666 on 2025-04-01 22:18</div>
            <div class="timeline-body"><p>Is there a reason to handle this as a separate prior <code>if</code> statement, rather than an arm in the <code>match</code> below? It doesn't seem particularly different to many other existing match arms that also delegate to recursive calls.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:665 on 2025-04-01 22:34</div>
            <div class="timeline-body"><p>I agree that this is true, both for the stated reason, and for the slightly different reason discussed above in comments on the tests (that a union type is a super-type of every sub-union composed of subsets of its elements, and this is not true for a constrained typevar).</p>
<p>What's less clear to me is why this is a TODO comment. What specific behavior(s) would we need to change in order to consider this TODO comment addressed?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:918 on 2025-04-01 22:36</div>
            <div class="timeline-body"><p>Same questions as above, both about the TODO comment and the use of a separate <code>if</code> rather than a match arm.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1541 on 2025-04-01 22:43</div>
            <div class="timeline-body"><p>This comment seems both out-of-place and obsolete to the current PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1977 on 2025-04-01 22:50</div>
            <div class="timeline-body"><p>I understand the convenience of using a union type here, because of the nice handy methods it has. I'm a little nervous about introducing non-canonicalized <code>UnionType</code> into the world, and breaking invariants that we otherwise assume to be true of all <code>UnionType</code>. I'm also a bit nervous about representing constraints as a union making it a little too easy to think that a constrained typevar is a union.</p>
<p>It will probably be fine :) I guess if we find it isn't, the fix might be to have a &quot;vector of types&quot; type with some of these useful convenience methods, and then both UnionType and constrained typevars could hold one of those?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4403 on 2025-04-01 22:52</div>
            <div class="timeline-body"><p>Shouldn't the correct handling here be to treat the typevar as if it were <code>object</code> / it's upper bound / the union of its constraints? Specifically that might result in some diagnostics we want.</p>
<p>(Fine to consider that out-of-scope for this PR, but I think we should have a TODO for it.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4549 on 2025-04-01 22:53</div>
            <div class="timeline-body"><p>Similarly, TODO here for treating the typevar as object/bound/union-of-constraints for purposes of checking the binary operation?</p>
<p>(I think this is why the one TODO in the tests that I commented on isn't fixed by this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:317 on 2025-04-01 23:09</div>
            <div class="timeline-body"><p>I'd kind of assumed that we would need to store some reference to the binding scope of the typevar here, in addition to the information stored in <code>TypeVarInstance</code>, like maybe in order to disambiguate between usages of the same legacy TypeVar. But maybe we don't actually need that? You can't reuse the same legacy TypeVar in nested scopes anyway; the method here isn't a generic function with its own typevar scope, it's just referencing the class typevar:</p>
<pre><code class="language-py">from typing import TypeVar, Generic

T = TypeVar(&quot;T&quot;)

class C(Generic[T]):
    def __init__(self, x: T) -&gt; None:
        self.x = x

    def foo(self, x: T) -&gt; T:
        return x
</code></pre>
<p>And pyright errors if a nested class tries to reuse the same typevar used by the outer class. Which makes sense; uses of the typevar would otherwise be ambiguous. So maybe we don't need any internal disambiguation?</p>
<p>Pyright displays type vars like <code>T@C</code> instead of just <code>T</code>, where <code>C</code> is the name of the class in which the typevar is bound. But maybe we don't need that either? The name of the typevar always seemed sufficiently clear to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3282 on 2025-04-01 23:22</div>
            <div class="timeline-body"><p>Similar to another comment above, I'm not convinced by this TODO comment. Even though the <em>type</em> that specializes a constrained typevar must be one of the constraint types, the inhabitants of those constraint types still include instances of subclasses, as always for an instance type. A typevar <code>[T: (A, B)]</code>, if specialized by <code>A</code>, is still inhabited by instances of subclasses of <code>A</code>. Which means that the meta-type of that type var should be inhabited by the meta-type of subclasses of <code>A</code> as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3766 on 2025-04-01 23:24</div>
            <div class="timeline-body"><p>The TODO comment I do feel we might need here is that I don't think having this return a union type is really correct. I think it should rather be a synthetic typevar constrained to the meta-types of each constraint.</p>
<p>I'm not sure how much this matters in practice, so totally fine with it being a TODO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:194 on 2025-04-01 23:28</div>
            <div class="timeline-body"><p>As discussed in comments on the tests, I'm not convinced that this gloss of a constrained typevar to a union of its constraints is something that we should be doing here. Or at least -- I think we need to limit it to the case where we are immediately able to eliminate all but one of the union elements, so the result is no longer a union. If that's tricky, I also think it's OK to leave the entire ability to narrow a constrained typevar as a follow-up item instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-04-01 23:29</div>
            <div class="timeline-body"><p>This is fantastic! Great work. Sorry for all the comments ðŸ˜† I think almost all of them are fine to address just with TODO comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:97 on 2025-04-02 13:06</div>
            <div class="timeline-body"><blockquote>
<p>What are the <code>t</code> and <code>u</code> parameters here for? Just to avoid (possible future?) diagnostics about unused/unbindable typevars?</p>
</blockquote>
<p>That's right</p>
<blockquote>
<p>If that's the reason, any particular reason for them to be <code>list[T]</code> and <code>list[U]</code> rather than just <code>T</code> and <code>U</code>?</p>
</blockquote>
<p>David <a href="https://github.com/astral-sh/ruff/pull/17102#discussion_r2022981985">suggested this</a> as a way of making sure the function is still callable even when the typevar is specialized to <code>Never</code>, since <code>list[Never]</code> can be instantiated. That might not really be a concern for the type checker, though?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:73 on 2025-04-02 13:08</div>
            <div class="timeline-body"><p>tbh I was mostly just mimicking the pattern in <code>type_properties/is_subtype_of.md</code> and friends</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:59 on 2025-04-02 13:15</div>
            <div class="timeline-body"><p>Done (went with a slightly different wording)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:138 on 2025-04-02 13:24</div>
            <div class="timeline-body"><p>Done. Also added a new section above explaining and testing our interpretation of when typevars are fully static</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:140 on 2025-04-02 13:25</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:260 on 2025-04-02 14:03</div>
            <div class="timeline-body"><p>I think <code>T | object</code> would simplify to <code>object</code>, regardless of whether <code>T</code> is bounded or constrained.  And <code>T &amp; object</code> would simplify to <code>T</code>, not to <code>int</code>, since <code>T</code> might be specialized to something smaller than <code>int</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:156 on 2025-04-02 14:06</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-02 14:10</div>
            <div class="timeline-body"><p>Addressed some of the easier comments. Still thinking about how best to handle the &quot;it's not really a union&quot; bits...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-02 15:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:97 on 2025-04-02 15:23</div>
            <div class="timeline-body"><p>I suppose if you have a variable typed as <code>Never</code> you should be able to pass it as argument to a function parameter typed as <code>Never</code>?</p>
<p>Anyway, not important, using lists is totally fine, I was just curious. This rationale is good enough for me :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-02 15:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:260 on 2025-04-02 15:24</div>
            <div class="timeline-body"><p>Right, of course, not sure what I was thinking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3766 on 2025-04-02 15:29</div>
            <div class="timeline-body"><p>After further discussion this morning, I think this is one of those cases where returning the union is not wrong, just imprecise, and probably fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-02 15:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:97 on 2025-04-02 19:11</div>
            <div class="timeline-body"><blockquote>
<p>I suppose if you have a variable typed as <code>Never</code> you should be able to pass it as argument to a function parameter typed as <code>Never</code>?</p>
</blockquote>
<p>I think you'd get an <code>[unresolved-reference]</code> error at the call site, since there's no way you could create a binding for that variable.  Hmm, unless you assigned it the result of calling a function that returns <code>Never</code>?</p>
<p>Anyway, I digress... :sweat_smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:141 on 2025-04-02 19:17</div>
            <div class="timeline-body"><p>It is! I had to reorder some of the subtype/assignable clauses to make this pass. The correct order is:</p>
<ul>
<li>union</li>
<li>one-of / typevar</li>
<li>intersection</li>
</ul>
<p>which aligns with what the extended DNF representation for types would be if/when we introduce <code>OneOf</code> as a new connective.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:279 on 2025-04-02 19:54</div>
            <div class="timeline-body"><p>Done (also made some better-named types for these bounds and constraints)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:337 on 2025-04-02 23:39</div>
            <div class="timeline-body"><p>I've implemented the intersection builder hack we discussed in Discord, and reworded this section to describe how a hypothetical <code>OneOf</code> connector would interact with intersections.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:354 on 2025-04-02 23:39</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:358 on 2025-04-02 23:39</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:512 on 2025-04-02 23:42</div>
            <div class="timeline-body"><p>I added an extra test here for a three-way <code>isinstance</code> narrowing, to test that the simplification still gets applied even if it takes a couple of narrowing steps to get there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:317 on 2025-04-02 23:44</div>
            <div class="timeline-body"><blockquote>
<p>So maybe we don't need any internal disambiguation?</p>
</blockquote>
<p>I think we will be saved by the fact that <a href="https://typing.python.org/en/latest/spec/generics.html#scoping-rules-for-type-variables">it's an error</a> to have nested generic scopes that reuse typevar names. So for checking typevars, I think the name will actually be enough to disambiguate on its own.</p>
<p>(This PR is also not currently doing anything to verify that multiple occurrences of the same typevar in the same generic scope resolve to the same value. I think that will require type contexts.)</p>
<p>I do intend to add the <code>@suffix</code> notation, but wanted to tackle that separately.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:628 on 2025-04-02 23:49</div>
            <div class="timeline-body"><p>Ah yes, I was thinking to keep them as-is to keep them in source order â€” but that's only important for the typevars in the generic clause, not for the constraints of any of those typevars.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:666 on 2025-04-03 00:05</div>
            <div class="timeline-body"><p>The ordering here is weird â€” constrained typevars on the LHS need to be handled first, since <em>all</em> of the constraints must be assignable to the RHS. But unbounded typevars need to fall through to the main <code>match</code> statement so that we e.g. test is against any of elements of a union on the RHS.  I honestly don't love the brittleness of the checks.</p>
<p>I was able to fold this in with an <code>if</code> guard on the typevar LHS match arm, though that requires calling the <code>bound_or_constraints</code> salsa query twice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:918 on 2025-04-03 00:05</div>
            <div class="timeline-body"><p>Ditto, done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1541 on 2025-04-03 00:05</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3282 on 2025-04-03 00:06</div>
            <div class="timeline-body"><p>Good point! Removed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:3766 on 2025-04-03 00:08</div>
            <div class="timeline-body"><p>Reworded to mention our possible future <code>OneOf</code> connector as a more precise option</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:194 on 2025-04-03 00:09</div>
            <div class="timeline-body"><p>Replaced this with the new hack that we discussed in Discord</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1977 on 2025-04-03 00:12</div>
            <div class="timeline-body"><p>I added another TODO here to consider a future <code>OneOfType</code> connective. That would be a good opportunity to extract the &quot;vector of types&quot; as you suggest.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4403 on 2025-04-03 01:04</div>
            <div class="timeline-body"><p>Added a TODO</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4549 on 2025-04-03 01:04</div>
            <div class="timeline-body"><p>Added a TODO</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-03 01:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-03 14:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:141 on 2025-04-03 14:10</div>
            <div class="timeline-body"><p>Per another comment, this description of the &quot;correct order&quot; is not accurate anymore. It's more subtle â€” LHS constrained typevars have to be handled first, then the order described above</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/functions.md</code>:110 on 2025-04-03 14:19</div>
            <div class="timeline-body"><p>Fixed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4403 on 2025-04-03 14:19</div>
            <div class="timeline-body"><p>Scratch that, the fix was easier than I expected.  Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4549 on 2025-04-03 14:20</div>
            <div class="timeline-body"><p>Ditto, fixed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-03 14:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:110 on 2025-04-03 16:17</div>
            <div class="timeline-body"><p>Relative to the prose above, the tests that are conspicuous by absence here are e.g. <code>static_assert(not is_subtype_of(T, Super))</code> and <code>static_assert(not is_subtype_of(Super, T))</code> -- that is, that the typevar is neither a subtype nor a supertype of some arbitrary non-object type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:183 on 2025-04-03 16:22</div>
            <div class="timeline-body"><pre><code class="language-suggestion">intersection of all of its constraints is a subtype of the typevar. (Though that intersection is
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:184 on 2025-04-03 16:23</div>
            <div class="timeline-body"><p>Not sure about this parenthetical comment about &quot;likely to be Never in practice.&quot; How likely is that really? Arguably the most common type is a regular non-final instance type (i.e. the type <code>A</code> with <code>class A: ...</code>), and two such types are not disjoint, so their intersection is not <code>Never</code>. E.g. in the example below, <code>Intersection[Base, Unrelated]</code> is not <code>Never</code>.</p>
<p>Unless I'm missing something, I'd probably remove this parenthetical?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:293 on 2025-04-03 16:40</div>
            <div class="timeline-body"><p>Would this test be more relevant if the bound were in fact a singleton type? Otherwise it seems a bit trivial that the typevar wouldn't be a singleton.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:451 on 2025-04-03 16:45</div>
            <div class="timeline-body"><pre><code class="language-suggestion">Nevertheless, describing constrained typevars this way helps explain how we simplify intersections
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:495 on 2025-04-03 16:47</div>
            <div class="timeline-body"><p>I guess following the precedent above, we could also mention what this would be with <code>OneOf</code>?</p>
<pre><code class="language-suggestion">        # With OneOf this would be OneOf[int, bool]
        reveal_type(x)  # revealed: T &amp; ~str
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:542 on 2025-04-03 16:50</div>
            <div class="timeline-body"><p>Shouldn't this be <code>R &amp; ~Q &amp; ~P</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:649 on 2025-04-03 16:52</div>
            <div class="timeline-body"><p>For the UpperBound case, don't we need to normalize the upper-bound type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:717 on 2025-04-03 16:56</div>
            <div class="timeline-body"><p>Isn't &quot;everything is a subtype of <code>object</code>&quot; handled above, not below? Or am I misunderstanding here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-04-03 17:05</div>
            <div class="timeline-body"><p>Awesome work. Ship it!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:110 on 2025-04-03 17:55</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:184 on 2025-04-03 17:57</div>
            <div class="timeline-body"><p>To confirm my understanding, <code>Base</code> and <code>Unrelated</code> are not disjoint because someone could declare a new class that is a subclass of both?  That's a helpful clarification, it explains why I was not getting the expected test failures when I changed <code>None</code> (an actually disjoint type) to <code>Unrelated</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:293 on 2025-04-03 17:58</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:542 on 2025-04-03 18:01</div>
            <div class="timeline-body"><p>Nope.  In the first <code>elif</code>, we get <code>(T &amp; Q) &amp; ~P</code>, which simplifies to <code>Q &amp; ~P</code> because <code>T &amp; Q</code> triggers the &quot;typevar with exactly one positive constraint check&quot;.</p>
<p>In the <code>else</code>, we get <code>T &amp; ~P &amp; ~Q</code>, which triggers the &quot;typevar with all but one negative constraint&quot;, which simplifies to the remaining constraint, <code>R</code>.  The negatives are removed as part of that simplification.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:649 on 2025-04-03 18:02</div>
            <div class="timeline-body"><p>Good catch, done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:717 on 2025-04-03 18:03</div>
            <div class="timeline-body"><p>You're right! Forget to edit the comment when I moved the match arms around</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-03 18:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-03 18:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:183 on 2025-04-03 18:08</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-04-03 18:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-04-03 18:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-03 18:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-03 22:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:184 on 2025-04-03 22:46</div>
            <div class="timeline-body"><blockquote>
<p>To confirm my understanding, <code>Base</code> and <code>Unrelated</code> are not disjoint because someone could declare a new class that is a subclass of both?</p>
</blockquote>
<p>Yep, that's right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-03 23:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/generics/pep695.md</code>:542 on 2025-04-03 23:17</div>
            <div class="timeline-body"><p>Right, but (as we briefly discussed in 1:1) the negative constraints should still remain, because <code>P</code>, <code>Q</code>, and <code>R</code> are not disjoint (due to multiple inheritance as discussed above), and their non-empty intersection should still be excluded. See https://github.com/astral-sh/ruff/pull/17189</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:41:05 UTC
    </footer>
</body>
</html>
