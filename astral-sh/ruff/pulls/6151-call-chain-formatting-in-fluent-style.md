```yaml
number: 6151
title: Call chain formatting in fluent style
type: pull_request
state: merged
author: konstin
labels: []
assignees: []
merged: true
base: main
head: fluent_style
created_at: 2023-07-28T13:19:20Z
updated_at: 2023-08-08T12:36:56Z
url: https://github.com/astral-sh/ruff/pull/6151
synced_at: 2026-01-12T02:52:03Z
```

# Call chain formatting in fluent style

---

_Pull request opened by @konstin on 2023-07-28 13:19_

Implement fluent style/call chains. See the `call_chains.py` formatting for examples.

This isn't fully like black because in `raise A from B` they allow `A` breaking can influence the formatting of `B` even if it is already multiline.

Similarity index:

| project      | main  | PR    |
|--------------|-------|-------|
| build        | ???   | 0.753 |
| django       | 0.991 | 0.998 |
| transformers | 0.993 | 0.994 |
| typeshed     | 0.723 | 0.723 |
| warehouse    | 0.978 | 0.994 |
| zulip        | 0.992 | 0.994 |

Call chain formatting is affected by https://github.com/astral-sh/ruff/issues/627, but i'm cutting scope here.

Closes #5343

**Test Plan**:
 * Added a dedicated call chains test file
 * The ecosystem checks found some bugs
 * I manually check django and zulip formatting


---

_Comment by @konstin on 2023-07-28 13:19_

Current dependencies on/for this PR:
* main
  * **PR #6151** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/6151" target="_blank"><img src="https://static.graphite.dev/graphite-32x32.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ

This comment was auto-generated by [Graphite](https://app.graphite.dev/github/pr/astral-sh/ruff/6151?utm_source=stack-comment).

---

_Comment by @github-actions[bot] on 2023-07-28 13:51_

## PR Check Results
### Benchmark
#### Linux
```
group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      9.3Â±0.02ms     4.4 MB/sec    1.11     10.3Â±0.09ms     3.9 MB/sec
formatter/numpy/ctypeslib.py               1.00   1885.3Â±8.59Âµs     8.8 MB/sec    1.06      2.0Â±0.01ms     8.3 MB/sec
formatter/numpy/globals.py                 1.02   231.6Â±14.37Âµs    12.7 MB/sec    1.00    226.2Â±7.00Âµs    13.0 MB/sec
formatter/pydantic/types.py                1.00      4.0Â±0.03ms     6.3 MB/sec    1.06      4.3Â±0.04ms     6.0 MB/sec
linter/all-rules/large/dataset.py          1.00     13.1Â±0.10ms     3.1 MB/sec    1.02     13.3Â±0.14ms     3.1 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.3Â±0.02ms     5.0 MB/sec    1.01      3.4Â±0.01ms     5.0 MB/sec
linter/all-rules/numpy/globals.py          1.00    458.6Â±0.76Âµs     6.4 MB/sec    1.00    457.8Â±1.70Âµs     6.4 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.0Â±0.05ms     4.3 MB/sec    1.01      6.0Â±0.02ms     4.2 MB/sec
linter/default-rules/large/dataset.py      1.00      6.5Â±0.24ms     6.3 MB/sec    1.05      6.8Â±0.04ms     6.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1356.7Â±7.79Âµs    12.3 MB/sec    1.05   1428.3Â±6.01Âµs    11.7 MB/sec
linter/default-rules/numpy/globals.py      1.01    159.5Â±7.98Âµs    18.5 MB/sec    1.00    157.3Â±0.61Âµs    18.8 MB/sec
linter/default-rules/pydantic/types.py     1.00      2.8Â±0.02ms     9.0 MB/sec    1.05      3.0Â±0.03ms     8.5 MB/sec
```

#### Windows
```
group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00     10.4Â±0.13ms     3.9 MB/sec    1.06     11.1Â±0.11ms     3.7 MB/sec
formatter/numpy/ctypeslib.py               1.00  1974.8Â±38.30Âµs     8.4 MB/sec    1.04      2.0Â±0.04ms     8.1 MB/sec
formatter/numpy/globals.py                 1.00   222.4Â±10.07Âµs    13.3 MB/sec    1.02    225.9Â±8.00Âµs    13.1 MB/sec
formatter/pydantic/types.py                1.00      4.3Â±0.07ms     5.9 MB/sec    1.03      4.5Â±0.06ms     5.7 MB/sec
linter/all-rules/large/dataset.py          1.00     14.7Â±0.16ms     2.8 MB/sec    1.01     14.8Â±0.16ms     2.8 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.8Â±0.06ms     4.4 MB/sec    1.03      3.9Â±0.06ms     4.3 MB/sec
linter/all-rules/numpy/globals.py          1.00    452.9Â±8.58Âµs     6.5 MB/sec    1.02    462.0Â±6.85Âµs     6.4 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.7Â±0.09ms     3.8 MB/sec    1.01      6.8Â±0.10ms     3.8 MB/sec
linter/default-rules/large/dataset.py      1.00      7.3Â±0.11ms     5.6 MB/sec    1.08      7.9Â±0.15ms     5.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1470.6Â±26.20Âµs    11.3 MB/sec    1.07  1568.9Â±21.62Âµs    10.6 MB/sec
linter/default-rules/numpy/globals.py      1.00    165.7Â±3.23Âµs    17.8 MB/sec    1.08    178.2Â±5.09Âµs    16.6 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.2Â±0.08ms     7.9 MB/sec    1.07      3.4Â±0.08ms     7.4 MB/sec
```
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

---

_Renamed from "Fluent style" to "Call chain formatting in fluent style" by @konstin on 2023-07-30 12:51_

---

_Marked ready for review by @konstin on 2023-07-31 07:33_

---

_Converted to draft by @konstin on 2023-07-31 07:53_

---

_Comment by @konstin on 2023-07-31 07:54_

Blocked on unstable formatting of
```python
y = (
    x.a()  #
    .b()
)

y = x.a().b()  #

y = (
    x.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa()  #
    .b()
)

y = x.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa().b()  #
```

---

_Marked ready for review by @konstin on 2023-08-02 12:43_

---

_Review requested from @MichaReiser by @konstin on 2023-08-02 12:43_

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/parentheses.rs`:77 on 2023-08-03 08:54_

`FluentStyle` doesn't fit well into the `Parentheses` concept, which is intended to be generally applicable to all expressions. 

---

_@MichaReiser reviewed on 2023-08-03 09:00_

Woah, nice improvement on the compatibility! 

The fluent style formatting now requires to route through the fluent style in many positions (which I like more than setting in on context). 

Have you considered to, instead "unroll" the call chain in the `CallExpression` formatting? Meaning, we would have a single formatting that owns the whole call chain formatting without calling into format attribute and format subscript (maybe parts of it). I'm asking because I find it difficult to "unroll" the recursion in my head and wonder if it would be easier if the whole call chain formatting would be in its own file.

---

_Comment by @konstin on 2023-08-03 12:14_

Good point, i made fluent style a bool that gets passed through the call chain formatting. It's still recursive but i think that's better than unrolling

---

_Comment by @konstin on 2023-08-03 13:01_

This took some rotations but now it's just a `is_fluent_style_call_chain` function we call when formatting an expression. There is still a case we miss (`not a().b().c()`), but i'm happy how it looks now.

---

_Comment by @MichaReiser on 2023-08-03 13:04_

> Good point, i made fluent style a bool that gets passed through the call chain formatting. It's still recursive but i think that's better than unrolling

Could you explain your reasoning of why?

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:201 on 2023-08-03 13:21_

As far as I know, `maybe_parenthesize` is only used on statement level

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/expr_attribute.rs`:16 on 2023-08-03 13:22_

Can we use a `MemberLayout` type instead with `Default` and `Fluent` variants? It's otherwise difficult to understand what `with_options(true)` means. 

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:71 on 2023-08-03 13:25_

Is this still necessary here? It seems that `Call`, `Attribute` and `Subscript` now by-pass the `Expr` formatting.

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:188 on 2023-08-03 13:29_

Would it be possible to remove the code from here if:

* Replace the `boolean` option with an enum that has three variants:
  * `Fluent`
  * `NonFluent`: Left side of a call chain, but we don't use the fluent style
  * `Root`: The root of a fluent chain (default)
* `CallExpression` tests if it is inside of a fluent chain if the variant is `Root`. (or any node that can be the end of a call chain). If so, use `Fluent`, otherwise` NonFluent`
* `Subscript`, `Call`, or `Attribute` wrap their content in a `group` if the layout is `Fluent`. 
* Change `can_omit_parentheses` to return `false` for call chains.


---

_Comment by @konstin on 2023-08-03 13:29_

> > Good point, i made fluent style a bool that gets passed through the call chain formatting. It's still recursive but i think that's better than unrolling
> 
> Could you explain your reasoning of why?

I think consistency, mainly: Every other expression is formatted from outermost to innermost, so this is no difference. The main thing we do differently is to put a newline between the closing parentheses and the dot.

---

_@MichaReiser reviewed on 2023-08-03 13:30_

---

_@konstin reviewed on 2023-08-03 19:13_

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/expression/mod.rs`:201 on 2023-08-03 19:13_

it's unreachable with the check now

---

_@konstin reviewed on 2023-08-03 19:13_

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/expression/expr_attribute.rs`:16 on 2023-08-03 19:13_

good idea

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/expression/mod.rs`:71 on 2023-08-03 20:08_

I spent way to much time trying to come up with something better, but i'm afraid the answer is yes. I think the node level is the biggest problem here because e.g. just inlining helpers doesn't seem to work.

---

_@konstin reviewed on 2023-08-03 20:08_

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/expression/mod.rs`:188 on 2023-08-03 20:25_

I don't think i really follow; Call chains can appear about everywhere except on statement level. For the MaybeParenthesize it's special because we need to switch parentheses mode, call chain formatting always has parentheses when breaking.

> Change can_omit_parentheses to return false for call chains.

This is already the case.

Unfortunately I don't understand why exactly the current solution works but the alternatives i tried don't, the interaction of node level, context, parentheses, MaybeParenthesize and FormatExpr or not is still opaque to me.

---

_@konstin reviewed on 2023-08-03 20:25_

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:553 on 2023-08-04 06:44_

`is_expression_parenthesized` returns false positives if it is the first argument in a call expression. I guess this is safe because the expression never has `attributes_after_parentheses` that is larger than 1.

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:183 on 2023-08-04 06:47_

Can we inline the `can_omit_optional_parentheses` call again to avoid calling it for `OptionalParentheses::Always` and `Never`?

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:77 on 2023-08-04 07:04_

I played around with your PR locally, and moving the call chain formatting out of the `Expr` seems possible. It has the added benefit that we avoid adding unnecessary groups around `Subsccript` and `Attribute` accessors

```patch
Subject: [PATCH] Move Fluent style out of `Expr` formatting
---
Index: crates/ruff_python_formatter/src/expression/expr_subscript.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_subscript.rs b/crates/ruff_python_formatter/src/expression/expr_subscript.rs
--- a/crates/ruff_python_formatter/src/expression/expr_subscript.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/expr_subscript.rs	(date 1691133618832)
@@ -34,6 +34,17 @@
             ctx: _,
         } = item;
 
+        let call_chain_layout = match self.call_chain_layout {
+            CallChainLayout::Default => {
+                if f.context().node_level().is_parenthesized() {
+                    CallChainLayout::from_expression(AnyNodeRef::from(item), f.context().source())
+                } else {
+                    CallChainLayout::NonFluent
+                }
+            }
+            layout @ (CallChainLayout::Fluent | CallChainLayout::NonFluent) => layout,
+        };
+
         let comments = f.context().comments().clone();
         let dangling_comments = comments.dangling_comments(item.as_any_node_ref());
         debug_assert!(
@@ -42,9 +53,9 @@
         );
 
         let format_value = format_with(|f| match value.as_ref() {
-            Expr::Attribute(expr) => expr.format().with_options(self.call_chain_layout).fmt(f),
-            Expr::Call(expr) => expr.format().with_options(self.call_chain_layout).fmt(f),
-            Expr::Subscript(expr) => expr.format().with_options(self.call_chain_layout).fmt(f),
+            Expr::Attribute(expr) => expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Call(expr) => expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Subscript(expr) => expr.format().with_options(call_chain_layout).fmt(f),
             _ => value.format().fmt(f),
         });
 
@@ -91,10 +102,16 @@
     fn needs_parentheses(
         &self,
         _parent: AnyNodeRef,
-        _context: &PyFormatContext,
+        context: &PyFormatContext,
     ) -> OptionalParentheses {
         {
-            OptionalParentheses::Never
+            if CallChainLayout::from_expression(self.into(), context.source())
+                == CallChainLayout::Fluent
+            {
+                OptionalParentheses::Multiline
+            } else {
+                self.value.needs_parentheses(self.into(), context)
+            }
         }
     }
 }
Index: crates/ruff_python_formatter/src/expression/expr_call.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_call.rs b/crates/ruff_python_formatter/src/expression/expr_call.rs
--- a/crates/ruff_python_formatter/src/expression/expr_call.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/expr_call.rs	(date 1691134353539)
@@ -1,6 +1,7 @@
 use crate::expression::CallChainLayout;
 use ruff_formatter::{write, FormatRuleWithOptions};
 use ruff_python_ast::node::AnyNodeRef;
+use ruff_python_ast::Expr::Call;
 use ruff_python_ast::{Expr, ExprCall};
 
 use crate::expression::parentheses::{NeedsParentheses, OptionalParentheses};
@@ -29,14 +30,41 @@
             arguments,
         } = item;
 
-        match func.as_ref() {
-            Expr::Attribute(expr) => expr.format().with_options(self.call_chain_layout).fmt(f)?,
-            Expr::Call(expr) => expr.format().with_options(self.call_chain_layout).fmt(f)?,
-            Expr::Subscript(expr) => expr.format().with_options(self.call_chain_layout).fmt(f)?,
-            _ => func.format().fmt(f)?,
-        }
+        let call_chain_layout = match self.call_chain_layout {
+            CallChainLayout::Default => {
+                if f.context().node_level().is_parenthesized() {
+                    CallChainLayout::from_expression(AnyNodeRef::from(item), f.context().source())
+                } else {
+                    CallChainLayout::NonFluent
+                }
+            }
+            layout @ (CallChainLayout::Fluent | CallChainLayout::NonFluent) => layout,
+        };
+
+        let fmt_inner = format_with(|f| {
+            match func.as_ref() {
+                Expr::Attribute(expr) => expr.format().with_options(call_chain_layout).fmt(f)?,
+                Expr::Call(expr) => expr.format().with_options(call_chain_layout).fmt(f)?,
+                Expr::Subscript(expr) => expr.format().with_options(call_chain_layout).fmt(f)?,
+                _ => func.format().fmt(f)?,
+            }
 
-        write!(f, [arguments.format()])
+            arguments.format().fmt(f)
+        });
+
+        // Allow to indent the parentheses while
+        // ```python
+        // g1 = (
+        //     queryset.distinct().order_by(field.name).values_list(field_name_flat_long_long=True)
+        // )
+        // ```
+        if call_chain_layout == CallChainLayout::Fluent
+            && self.call_chain_layout == CallChainLayout::Default
+        {
+            group(&fmt_inner).fmt(f)
+        } else {
+            fmt_inner.fmt(f)
+        }
     }
 }
 
@@ -46,6 +74,12 @@
         _parent: AnyNodeRef,
         context: &PyFormatContext,
     ) -> OptionalParentheses {
-        self.func.needs_parentheses(self.into(), context)
+        if CallChainLayout::from_expression(self.into(), context.source())
+            == CallChainLayout::Fluent
+        {
+            OptionalParentheses::Multiline
+        } else {
+            self.func.needs_parentheses(self.into(), context)
+        }
     }
 }
Index: crates/ruff_python_formatter/src/expression/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/mod.rs b/crates/ruff_python_formatter/src/expression/mod.rs
--- a/crates/ruff_python_formatter/src/expression/mod.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/mod.rs	(date 1691134350626)
@@ -65,17 +65,6 @@
     fn fmt(&self, expression: &Expr, f: &mut PyFormatter) -> FormatResult<()> {
         let parentheses = self.parentheses;
 
-        // All expressions that can have parentheses can be in fluent style. We need to exclude top
-        // expressions since they don't get parenthesized
-        let call_chain_layout = if matches!(
-            f.context().node_level(),
-            NodeLevel::CompoundStatement | NodeLevel::TopLevel
-        ) {
-            CallChainLayout::Default
-        } else {
-            CallChainLayout::from_expression(expression, f.context().source())
-        };
-
         let format_expr = format_with(|f| match expression {
             Expr::BoolOp(expr) => expr.format().with_options(Some(parentheses)).fmt(f),
             Expr::NamedExpr(expr) => expr.format().fmt(f),
@@ -93,12 +82,12 @@
             Expr::Yield(expr) => expr.format().fmt(f),
             Expr::YieldFrom(expr) => expr.format().fmt(f),
             Expr::Compare(expr) => expr.format().with_options(Some(parentheses)).fmt(f),
-            Expr::Call(expr) => expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Call(expr) => expr.format().fmt(f),
             Expr::FormattedValue(expr) => expr.format().fmt(f),
             Expr::JoinedStr(expr) => expr.format().fmt(f),
             Expr::Constant(expr) => expr.format().fmt(f),
-            Expr::Attribute(expr) => expr.format().with_options(call_chain_layout).fmt(f),
-            Expr::Subscript(expr) => expr.format().with_options(call_chain_layout).fmt(f),
+            Expr::Attribute(expr) => expr.format().fmt(f),
+            Expr::Subscript(expr) => expr.format().fmt(f),
             Expr::Starred(expr) => expr.format().fmt(f),
             Expr::Name(expr) => expr.format().fmt(f),
             Expr::List(expr) => expr.format().fmt(f),
@@ -128,17 +117,7 @@
 
             let mut f = WithNodeLevel::new(level, f);
 
-            // Allow to indent the parentheses while
-            // ```python
-            // g1 = (
-            //     queryset.distinct().order_by(field.name).values_list(field_name_flat_long_long=True)
-            // )
-            // ```
-            if call_chain_layout == CallChainLayout::Fluent {
-                write!(f, [group(&format_expr)])
-            } else {
-                write!(f, [format_expr])
-            }
+            write!(f, [format_expr])
         }
     }
 }
@@ -175,35 +154,6 @@
             parenthesize,
         } = self;
 
-        // Fluent style means that when we break we always add parentheses, so we don't need the
-        // checks below for existing parentheses, comments or `needs_parentheses`
-        if CallChainLayout::from_expression(expression, f.context().source())
-            == CallChainLayout::Fluent
-        {
-            match expression {
-                Expr::Attribute(expr) => {
-                    return parenthesize_if_expands(&group(
-                        &expr.format().with_options(CallChainLayout::Fluent),
-                    ))
-                    .fmt(f)
-                }
-                Expr::Call(expr) => {
-                    return parenthesize_if_expands(&group(
-                        &expr.format().with_options(CallChainLayout::Fluent),
-                    ))
-                    .fmt(f)
-                }
-                Expr::Subscript(expr) => {
-                    return parenthesize_if_expands(&group(
-                        &expr.format().with_options(CallChainLayout::Fluent),
-                    ))
-                    .fmt(f)
-                }
-                // `call_chain_layout` checks we're in one of the above
-                _ => unreachable!(),
-            };
-        }
-
         let comments = f.context().comments();
         let preserve_parentheses = parenthesize.is_optional()
             && is_expression_parenthesized((*expression).into(), f.context().source());
@@ -527,30 +477,36 @@
 /// ```
 #[derive(Copy, Clone, Debug, Default, PartialEq, Eq)]
 pub enum CallChainLayout {
+    /// The root of a call chain
     #[default]
     Default,
+
+    /// A nested call chain element that uses fluent style.
     Fluent,
+
+    /// A nested call chain element not using fluent style.
+    NonFluent,
 }
 
 impl CallChainLayout {
-    pub(crate) fn from_expression(mut expr: &Expr, source: &str) -> Self {
+    pub(crate) fn from_expression(mut expr: AnyNodeRef, source: &str) -> Self {
         let mut attributes_after_parentheses = 0;
         loop {
             match expr {
-                Expr::Attribute(ast::ExprAttribute { value, .. }) => {
+                AnyNodeRef::ExprAttribute(ast::ExprAttribute { value, .. }) => {
                     // `f().x` | `data[:100].T`
                     if matches!(value.as_ref(), Expr::Call(_) | Expr::Subscript(_)) {
                         attributes_after_parentheses += 1;
                     }
-                    expr = value;
+                    expr = AnyNodeRef::from(value.as_ref());
                 }
-                Expr::Call(ast::ExprCall { func: inner, .. })
-                | Expr::Subscript(ast::ExprSubscript { value: inner, .. }) => {
-                    expr = inner;
+                AnyNodeRef::ExprCall(ast::ExprCall { func: inner, .. })
+                | AnyNodeRef::ExprSubscript(ast::ExprSubscript { value: inner, .. }) => {
+                    expr = AnyNodeRef::from(inner.as_ref());
                 }
                 _ => {
                     // We to format the following in fluent style: `f2 = (a).w().t(1,)`
-                    if is_expression_parenthesized(AnyNodeRef::from(expr), source) {
+                    if is_expression_parenthesized(expr, source) {
                         attributes_after_parentheses += 1;
                     }
                     break;
@@ -558,7 +514,7 @@
             }
         }
         if attributes_after_parentheses < 2 {
-            CallChainLayout::Default
+            CallChainLayout::NonFluent
         } else {
             CallChainLayout::Fluent
         }
Index: crates/ruff_python_formatter/src/expression/expr_attribute.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_attribute.rs b/crates/ruff_python_formatter/src/expression/expr_attribute.rs
--- a/crates/ruff_python_formatter/src/expression/expr_attribute.rs	(revision 54b78ac7bdf0728ea0f0d91a426e460046d827e6)
+++ b/crates/ruff_python_formatter/src/expression/expr_attribute.rs	(date 1691133618832)
@@ -31,6 +31,17 @@
             ctx: _,
         } = item;
 
+        let call_chain_layout = match self.call_chain_layout {
+            CallChainLayout::Default => {
+                if f.context().node_level().is_parenthesized() {
+                    CallChainLayout::from_expression(AnyNodeRef::from(item), f.context().source())
+                } else {
+                    CallChainLayout::NonFluent
+                }
+            }
+            layout @ (CallChainLayout::Fluent | CallChainLayout::NonFluent) => layout,
+        };
+
         let needs_parentheses = matches!(
             value.as_ref(),
             Expr::Constant(ExprConstant {
@@ -51,18 +62,18 @@
         } else {
             match value.as_ref() {
                 Expr::Attribute(expr) => {
-                    expr.format().with_options(self.call_chain_layout).fmt(f)?;
+                    expr.format().with_options(call_chain_layout).fmt(f)?;
                 }
                 Expr::Call(expr) => {
-                    expr.format().with_options(self.call_chain_layout).fmt(f)?;
-                    if self.call_chain_layout == CallChainLayout::Fluent {
+                    expr.format().with_options(call_chain_layout).fmt(f)?;
+                    if call_chain_layout == CallChainLayout::Fluent {
                         // Format the dot on its own line
                         soft_line_break().fmt(f)?;
                     }
                 }
                 Expr::Subscript(expr) => {
-                    expr.format().with_options(self.call_chain_layout).fmt(f)?;
-                    if self.call_chain_layout == CallChainLayout::Fluent {
+                    expr.format().with_options(call_chain_layout).fmt(f)?;
+                    if call_chain_layout == CallChainLayout::Fluent {
                         // Format the dot on its own line
                         soft_line_break().fmt(f)?;
                     }
@@ -75,7 +86,7 @@
             hard_line_break().fmt(f)?;
         }
 
-        if self.call_chain_layout == CallChainLayout::Fluent {
+        if call_chain_layout == CallChainLayout::Fluent {
             // Fluent style has line breaks before the dot
             // ```python
             // blogs3 = (
@@ -139,7 +150,11 @@
         context: &PyFormatContext,
     ) -> OptionalParentheses {
         // Checks if there are any own line comments in an attribute chain (a.b.c).
-        if context
+        if CallChainLayout::from_expression(self.into(), context.source())
+            == CallChainLayout::Fluent
+        {
+            OptionalParentheses::Multiline
+        } else if context
             .comments()
             .dangling_comments(self)
             .iter()

```

There's room to remove some of the duplication in `Subscript`, `Attribute`, and the call formatting. I also haven't tested if there are no regressions on the django projects. 

I would prefer this solution because it avoids by-passing `NeedsParentheses`, `can_omit_parentheses`, and the changes are local to the affected expression types. But interested to hear your opinion. It may be worth to schedule some sync time to avoid further forth and back.

---

_@MichaReiser reviewed on 2023-08-04 07:36_

---

_@konstin reviewed on 2023-08-04 11:46_

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/expression/mod.rs`:77 on 2023-08-04 11:46_

Should have checked first, there's a case of unstable formatting now:
```python
class s():s=((()).r(Q(e="efinitive Guide to Django: Web Development Done Right")())).order_by()
```

---

_Merged by @konstin on 2023-08-04 13:58_

---

_Closed by @konstin on 2023-08-04 13:58_

---

_Branch deleted on 2023-08-04 13:58_

---

_Comment by @konstin on 2023-08-04 13:59_

oh i didn't turn of automerge; it should be fine anyway, i'll do a follow-up PR if anything comes up

---

_Comment by @MichaReiser on 2023-08-04 15:41_

> oh i didn't turn of automerge; it should be fine anyway, i'll do a follow-up PR if anything comes up

This looks good to me. 

Does this implementation handle the case you shared with me earlier correctly where it must preserve parentheses around members of the call chain?

```python
a = (
    b().c(
        "asdfasfaefinitive Guidddddde to Django: Web Developfdddddddment Done Rdddight"
    )
).d()
a = (
    b()
    .c("asdfasfaefinitive Guidddddde to Django: Web Developfdddddddment Done Rdddight")
    .d()
)
```

---

_@MichaReiser reviewed on 2023-08-04 15:42_

---

_Review comment by @MichaReiser on `crates/ruff_python_formatter/src/expression/mod.rs`:183 on 2023-08-04 15:42_

@konstin can we revert this change?

---

_Comment by @konstin on 2023-08-07 09:12_

yep it does, it's 

https://github.com/astral-sh/ruff/pull/6151/files#diff-dce5f767478405fd26c9245cf2e2bfb3358c6f61f5463570955ab0a2bc8a23abR117

and 

https://github.com/astral-sh/ruff/pull/6151/files#diff-9e872df95d51e4a0160715ef3cda0d7aaa8244e20f1bd7c7b0886a648358dfbeR280-R282

---

_@konstin reviewed on 2023-08-08 12:36_

---

_Review comment by @konstin on `crates/ruff_python_formatter/src/expression/mod.rs`:183 on 2023-08-08 12:36_

already done

---
