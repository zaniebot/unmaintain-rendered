<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turn define_rule_mapping! into a procedural macro - astral-sh/ruff #1885</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Turn define_rule_mapping! into a procedural macro</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/1885">#1885</a>
        opened by <a href="https://github.com/not-my-profile">@not-my-profile</a>
        on 2023-01-15 05:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/not-my-profile">@not-my-profile</a></div>
            <div class="timeline-body"><p>define_rule_mapping! was previously implemented as a declarative macro, which was however was partially relying on an origin_by_code! proc macro because declarative macros cannot match on substrings of identifiers.</p>
<p>Currently all define_rule_mapping! lines look like the following:</p>
<pre><code>TID251 =&gt; violations::BannedApi,
TID252 =&gt; violations::BannedRelativeImport,</code></pre>
<p>We want to break up violations.rs, moving the violation definitions to the respective rule modules. To do this we want to change the previous lines to:</p>
<pre><code>TID251 =&gt; rules::flake8_tidy_imports::banned_api::BannedApi,
TID252 =&gt; rules::flake8_tidy_imports::relative_imports::RelativeImport,</code></pre>
<p>This however doesn't work because the define_rule_mapping! macro is currently defined as:</p>
<pre><code>($($code:ident =&gt; $mod:ident::$name:ident,)+) =&gt; { ... }</code></pre>
<p>That is it only supported $module::$name but not longer paths with multiple modules. While we could define <code>=&gt; $path:path</code><a href="https://doc.rust-lang.org/reference/macros-by-example.html#metavariables">1</a> then we could no longer access the last path segment, which we need because we use it for the DiagnosticKind variant names. And <code>$path:path::$last:ident</code> doesn't work either because it would be ambiguous (Rust wouldn't know where the path ends ... so path fragments have to be followed by some punctuation/keyword that may not be part of paths).</p>
<p>So we just convert the declarative macro into a procedural macro in order to support paths of arbitrary length.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/not-my-profile">@not-my-profile</a> on 2023-01-15 05:16</div>
            <div class="timeline-body"><p>I have found that GitHub apparently mangles commit messages when merging by squashing:
See 7b1ce72f862f0967df1924c583288ccc8b7cb81c which does not have the second block indented vs my original commit, which correctly indented it 5569f668fe3183f6f48c2c7f3722dee74a0c4737.</p>
<p>So if you don't mind, I'd prefer it if you simply merged all of my PRs via rebasing (so even PRs that only contain a single commit) ... I don't want GitHub messing up my commit messages.</p>
<p>(And also because I sometimes force push commit message fixes which don't make it into the PR description.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-01-15 06:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-01-15 06:54</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:55:33 UTC
    </footer>
</body>
</html>
