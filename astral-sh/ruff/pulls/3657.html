<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enable autofix for annotations within 'simple' string literals - astral-sh/ruff #3657</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Enable autofix for annotations within 'simple' string literals</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/3657">#3657</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-03-21 20:40
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><h2>Summary,</h2>
<p>Today, we avoid applying any autofixes for code within deferred string type annotations. For example:</p>
<pre><code class="language-py"># Ruff will flag this, and convert it to `list[int]`.
x: List[int] = []

# Ruff will flag this, but won't attempt to fix it.
x: &quot;List[int]&quot; = []
</code></pre>
<p>This PR enables autofix for code within deferred string type annotations <em>in certain cases</em>. Namely, we allow these snippets to be fixed if and only if the annotation is &quot;simple&quot;, defined here as not containing any implicit concatenations or escaped characters. For example, we don't even try to fix this:</p>
<pre><code class="language-py">x: &quot;Li&quot; &quot;st[int]&quot; = []
</code></pre>
<p>...which is valid, but unusual.</p>
<p>Another way to think of this definition is: can we accurately predict the source code location for expressions within the string? If a string is &quot;simple&quot;, then we can do a &quot;located parse&quot; starting at the beginning of the content, and all the parsed locations will be correct within the indexing scheme of the parent.</p>
<p>Note that if an annotation is &quot;complex&quot;, we fallback to our existing behavior, whereby we modify the location of every located expression within the parsed annotation with the location of the <em>string itself</em>. So, e.g., the <code>int</code> in <code>&quot;Li&quot; &quot;st[int]&quot;</code> is given the location of the entire string annotation.</p>
<p>Closes #3656.</p>
<p>Closes #3508.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2023-03-21 20:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @konstin by @charliermarsh on 2023-03-21 20:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-03-21 21:05</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Ecosystem</h3>
<p>✅ ecosystem check detected no changes.</p>
<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.00     14.2±0.02ms     2.9 MB/sec    1.01     14.2±0.06ms     2.9 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.8±0.01ms     4.4 MB/sec    1.00      3.8±0.01ms     4.4 MB/sec
linter/all-rules/numpy/globals.py          1.00    435.4±1.91µs     6.8 MB/sec    1.00    435.4±1.55µs     6.8 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.3±0.01ms     4.1 MB/sec    1.00      6.3±0.01ms     4.0 MB/sec
linter/default-rules/large/dataset.py      1.00      7.8±0.01ms     5.2 MB/sec    1.00      7.8±0.01ms     5.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.02   1711.8±3.84µs     9.7 MB/sec    1.00   1685.3±2.00µs     9.9 MB/sec
linter/default-rules/numpy/globals.py      1.00    173.1±0.70µs    17.0 MB/sec    1.01    175.5±2.11µs    16.8 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.6±0.01ms     7.0 MB/sec    1.01      3.7±0.01ms     7.0 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.01     15.1±0.10ms     2.7 MB/sec    1.00     14.9±0.07ms     2.7 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.01      4.1±0.01ms     4.0 MB/sec    1.00      4.1±0.02ms     4.1 MB/sec
linter/all-rules/numpy/globals.py          1.01    453.3±3.41µs     6.5 MB/sec    1.00    450.0±4.85µs     6.6 MB/sec
linter/all-rules/pydantic/types.py         1.00      6.7±0.02ms     3.8 MB/sec    1.00      6.7±0.04ms     3.8 MB/sec
linter/default-rules/large/dataset.py      1.01      8.2±0.02ms     4.9 MB/sec    1.00      8.1±0.02ms     5.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.02   1765.7±7.78µs     9.4 MB/sec    1.00   1736.8±5.83µs     9.6 MB/sec
linter/default-rules/numpy/globals.py      1.00    181.4±0.99µs    16.3 MB/sec    1.00    180.7±2.60µs    16.3 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.8±0.01ms     6.7 MB/sec    1.00      3.8±0.07ms     6.7 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:4549 on 2023-03-22 08:05</div>
            <div class="timeline-body"><p>Nit: We can try to use <code>drain</code> to avoid the need for reversing and manually call pop</p>
<pre><code class="language-rust">let mut string_type_definitions = self.deferred.string_type_definitions.drain(..).rev();
for ((range, value, (in_annotation, in_type_checking_block), deferral)) = string_type_definitions {
	...
}
</code></pre>
<p>If the borrow checker gets mad because of multiple mutable borrows of <code>self</code>, then try this:</p>
<pre><code class="language-rust">let mut string_type_definitions = std::mem::take(&amp;mut self.deferred.string_type_definitions);
for ((range, ..)) = string_type_definitions.drain(..).rev() {
  ..
}

// Restore vector, to re-use the heap allocations
self.deferred.string_type_definitions = string_type_definitions; 
</code></pre>
<p>Both these approaches assume that the loop's body does not read from or write to `self.deferred.string_type_definitions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/scope.rs</code>:2 on 2023-03-22 08:06</div>
            <div class="timeline-body"><p>Revert?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-03-22 08:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff_python_ast/src/typing.rs</code>:76 on 2023-03-22 09:53</div>
            <div class="timeline-body"><p>isn't that a case for <code>derive(PartialEq, Eq)]</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-03-22 09:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> approved on 2023-03-22 09:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-03-22 16:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:4549 on 2023-03-22 16:09</div>
            <div class="timeline-body"><p>I think we actually <em>do</em> want to write to <code>self.deferred.string_type_definitions</code>, but we probably <em>don't</em> do it currently (https://github.com/charliermarsh/ruff/issues/3655).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_ast/src/typing.rs</code>:76 on 2023-03-22 16:30</div>
            <div class="timeline-body"><p>This macro gives us something slightly different -- we can do <code>annotation.is_simple()</code>, similar to what we get with <code>Result</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-03-22 16:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-03-22 16:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-03-22 16:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-03-22 16:45</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 16:56:45 UTC
    </footer>
</body>
</html>
