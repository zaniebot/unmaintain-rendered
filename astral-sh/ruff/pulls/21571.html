<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Don't suggest things that aren't subclasses of `BaseException` after `raise` - astral-sh/ruff #21571</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Don&#x27;t suggest things that aren&#x27;t subclasses of <code>BaseException</code> after <code>raise</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21571">#21571</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2025-11-21 19:36
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>This only applies to items that have a type associated with them. That
is, things that are already in scope. For items that don&#x27;t have a type
associated with them (i.e., suggestions from auto-import), we still
suggest them since we can&#x27;t know if they&#x27;re appropriate or not. It&#x27;s not
quite clear on how best to improve here for the auto-import case. (Short
of, say, asking for the type of each such symbol. But the performance
implications of that aren&#x27;t known yet.)</p>
<p>Note that because of auto-import, we were still suggesting
<code>NotImplemented</code> even though astral-sh/ty#1262 specifically cites it as
the motivating example that we <em>shouldn&#x27;t</em> suggest. This was occuring
because auto-import was including symbols from the <code>builtins</code> module,
even though those are actually already in scope. So this PR also gets
rid of those suggestions from auto-import.</p>
<p>Overall, this means that, at least, <code>raise NotImpl</code> won&#x27;t suggest
<code>NotImplemented</code>.</p>
<p>Fixes astral-sh/ty#1262</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;ag/filter non exceptions after raise&quot; to &quot;[ty] Don&#x27;t suggest things that aren&#x27;t subclasses of `BaseException` after `raise`&quot; by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/dcreager">@dcreager</a> removed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/carljm">@carljm</a> removed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/sharkdp">@sharkdp</a> removed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">server</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-21 19:37</div>
            <div class="timeline-body"><p>Demo:</p>
<p>https://github.com/user-attachments/assets/94fd6788-c6d2-4bc3-9f5b-b3ed210268ee</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-21 19:39</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-11-21 19:41</div>
            <div class="timeline-body">

<code>mypy_primer</code> results
<p>No ecosystem changes detected âœ…</p>
<p>No memory usage changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Gankra">@Gankra</a> on <code>crates/ty_ide/src/completion.rs</code>:1417 on 2025-11-21 20:21</div>
            <div class="timeline-body"><p>Wow I need to review more of your PRs, y&#x27;all are wildin&#x27; in here. I assume you can&#x27;t more-normally walk up the AST because autocomplete has to operate in malformed ASTs more?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Gankra">@Gankra</a> approved on 2025-11-21 20:23</div>
            <div class="timeline-body"><p>On paper it makes sense?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-21 21:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:1417 on 2025-11-21 21:40</div>
            <div class="timeline-body"><p>I think it&#x27;s more that I&#x27;ve been operating under the presumption that &quot;if we can do things directly from the tokens, then that&#x27;s probably better.&quot; In part to avoid the problem you bring up (although I&#x27;ve found our AST to be pretty good at dealing with malformed input) but also because it&#x27;s very cheap to just look at a few tokens. It&#x27;s possible that doing an AST traversal is also cheap enough. I honestly don&#x27;t have a great sense of it yet, but for completions we do a lot of &quot;check if we&#x27;re in context foo, or bar, or baz, or quux...&quot; so the faster each of those checks are (which I assume will continue to grow over time), the better. Although I did just remove a bunch of those checks for imports and consolidated it into one single check.</p>
<p>TL;DR - We could probably look at the AST for cases like this, but I&#x27;m starting simple.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-22 14:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/completion.rs</code>:1417 on 2025-11-22 14:05</div>
            <div class="timeline-body"><p>Walking tokens is certainly faster, but walking the AST also isn&#x27;t crazy expensive (all Ruff lint rules just do that). That&#x27;s why I&#x27;d pick whatever is easier.</p>
<p>The bigger challenge with our AST is that you can&#x27;t walk upwards (or sideways). At least not without building another intermediate representation that stores upward pointers for each AST node</p>
<p>One downside of using tokens is that there are cases where the parsed AST and token stream can disagree. E.g. the parser sometimes synthesizes name expressions if a required expression is missing (<code>e.g. a.</code> should synthesize a name expression for the attribute). However, we don&#x27;t synthesize a name token in that case).</p>
<p>However, our lexing is, to some extent, parser-directed during error recovery. For example, a &quot;normal&quot; lexer would parse the whitespace before <code>pass</code> as such whitespace because there&#x27;s an unclosed <code>(</code>. This is not the case for our token stream because the parser will inform the lexer that it will start error recovery after <code>(</code> because <code>pass</code> isn&#x27;t a valid argument name and that the lexer should try to lex the current token, assuming it&#x27;s in a statement context, in which case the whitespace is lexed as an indent.</p>
<pre><code>def test(
	pass
</code></pre>
<p>https://play.ruff.rs/f1d64305-c9ff-47cc-8edf-3a7216871932</p>
<p>However, there are a few cases where the parsed AST and the token stream can disagree, e.g. the token stream doesn&#x27;t contain a newline before <code>pass</code> even though this is parsed as <code>def test():\npass</code></p>
<pre><code>def test(pass
</code></pre>
<p>https://play.ruff.rs/d9e759b6-d676-4871-b421-abbd58514fc9</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_ide/src/completion.rs</code>:1383 on 2025-11-22 14:08</div>
            <div class="timeline-body"><pre><code>    // But we may not always want to treat it specially. So we&#x27;re
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_ide/src/completion.rs</code>:415 on 2025-11-22 14:11</div>
            <div class="timeline-body"><p>I suppose you can also raise instances of exceptions. So if a user has something like</p>
<pre><code>exception_to_raise = NotImplementedError(&quot;foooooooooooooooooooooooooooo&quot;)
raise exception_to&lt;CURSOR&gt;
</code></pre>
<p>we should probably suggest <code>exception_to_raise</code> there. That implies that this should be</p>
<pre><code>    if is_raising_exception(tokens) {
        let raisable_type = UnionType::from_elements(
            db,
            [KnownClass::BaseException.to_subclass_of(db), KnownClass::BaseException.to_instance(db)]
        );
        completions.retain(|c| {
            let Some(ty) = c.ty else { return true };
            ty.is_assignable_to(db, raisable_type)
        });
    }
</code></pre>
<p>basically, the same as this bit in the type-inference builder:</p>
<p>https://github.com/astral-sh/ruff/blob/3410041b4ca8226641b72e2f947ebd612dd2ea28/crates/ty_python_semantic/src/types/infer/builder.rs#L6003-L6025</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-11-22 14:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_ide/src/completion.rs</code>:1427 on 2025-11-22 14:22</div>
            <div class="timeline-body"><p>I think you want to, at least, skip all trivia tokens and parentheses (<code>(</code>, <code>)</code>)) to properly support</p>
<pre><code>raise (
	a  # comment
	.Error
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-11-22 14:25</div>
            <div class="timeline-body"><p>Thank you! This looks fantastic.</p>
<p>Though... the more I think about this, the more edge cases I think of. What if a user has something like this?</p>
<pre><code>import jsonschema.exceptions

if condition:
    raise jsons&lt;CURSOR&gt;
</code></pre>
<p>The user wants to type <code>raise jsonschema.exceptions.SchemaError</code>, but we refuse to suggest <code>jsonschema</code> here, and even after they&#x27;ve typed <code>jsonschema.&lt;CURSOR&gt;</code>, we refuse to suggest <code>jsonschema.exceptions</code>, since <code>jsonschema</code> and <code>jsonschema.exceptions</code> both have module-literal types, and module-literal types aren&#x27;t assignable to <code>type[BaseException] | BaseException</code>.</p>
<p>I can think of three ways round this:</p>
<ol>
<li>Make things more complicated: say that we&#x27;ll also include module-literal types after <code>raise</code> keywords</li>
<li>Make things simpler: rather than trying to do a full analysis of which types make sense after a <code>raise</code> keyword in the autocompletion engine, just special-case a few symbols (like <code>NotImplemented</code>) that we <em>know</em> don&#x27;t make sense after a <code>raise</code> keyword, and make sure that they&#x27;re removed.</li>
<li>Somewhere in the middle? Rather than <em>removing</em> types that aren&#x27;t assignable to <code>type[BaseException] | BaseException</code> from the list of suggestions, just make sure that they&#x27;re all ranked below symbols that <em>are</em> assignable to <code>type[BaseException] | BaseException</code>. And maybe <em>also</em> special-case <code>NotImplemented</code> so that it&#x27;s removed entirely?</li>
</ol>
<p>I think I&#x27;m leaning towards (3). (1) just feels like it has too many edge cases attached to it, because there are lots of ways of creating nested namespaces in Python (not just modules and submodules!). Something like this is unusual in Python, but I can imagine it would be pretty surprising if a user tried it and then found they didn&#x27;t have the autocompletions they expected (they want to type <code>raise Namespace.Exception1</code>):</p>
<pre><code>class Namespace:
    class Exception1(ValueError): ...
    class Exception2(TypeError): ...
    class Exception3(RuntimeError): ...

raise Name&lt;CURSOR&gt;
</code></pre>
<p>(3) also seems like it&#x27;ll have a lot less complexity associated with it than (1)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-22 15:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:1417 on 2025-11-22 15:29</div>
            <div class="timeline-body"><p>Thanks for that explanation! I didn&#x27;t know some of that. I think sticking with tokens for now is fine. We can always switch to AST in response to user feedback.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-22 15:31</div>
            <div class="timeline-body"><p>@AlexWaygood Great points. I like (3) too. I think that also fits better with symbols from auto-import not having a type associated with it. So it recasts the problem more as a ranking problem than a &quot;don&#x27;t show symbols&quot; problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-24 16:47</div>
            <div class="timeline-body"><p>@AlexWaygood OK, this should be updated now to do your (3) idea. Review is appreciated, particularly on how I did the check for <code>NotImplemented</code>. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 16:57</div>
            <div class="timeline-body"><p>I think here you can simplify this a bit -- the big reason that folks mix up <code>NotImplemented</code> and <code>NotImplementedError</code> all the time is that they not only have very similar names, they&#x27;re also both builtins. <code>type(NotImplemented)</code> doesn&#x27;t really have the same issue, because it&#x27;s not exposed as a builtin (you have to import the <code>NotImplementedType</code> class from the <code>types</code> module)</p>
<pre><code>        // As a special case, and because it&#x27;s a common footgun, we
        // specifically disallow `NotImplemented` in this context.
        // `NotImplementedError` should be used instead. So if we can
        // definitively detect `NotImplemented`, then we can safely
        // omit it from suggestions.
        completions.retain(|item| {
            let Some(ty) = item.ty else { return true };
            !ty.is_notimplemented(db)
        });
</code></pre>
<p>this will of course require making yet <em>another</em> <code>ty_python_semantic</code> API <code>pub</code> rather than <code>pub(crate)</code> ðŸ˜†</p>
<p>https://github.com/astral-sh/ruff/blob/a57e29131125bf05db7379e90c7616eec32624fe/crates/ty_python_semantic/src/types.rs#L895-L897</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-11-24 17:02</div>
            <div class="timeline-body"><p>This is awesome!! It makes me ridiculously happy that <code>NotImplemented</code> is no longer suggested after <code>raise</code>, and that all the exceptions are suggested first here:</p>
<p><img alt="image" src="https://github.com/user-attachments/assets/9acc4412-22cb-4692-b679-a3c8d7f63234"></p>
<p>ðŸ˜ƒ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-24 17:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:15</div>
            <div class="timeline-body"><p>Yeah I guess I was thinking about</p>
<pre><code>class Tricksy(NotImplementedType): pass
</code></pre>
<p>But I guess it&#x27;s probably not worth that and better to focus on the specific footgun?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-24 17:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:17</div>
            <div class="timeline-body"><p>My approach also covered</p>
<pre><code>tricksy = NotImplemented
raise tricksy
</code></pre>
<p>But probably also not worth handling that?</p>
<p>Especially since both of my examples will get down-ranked anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-11-24 17:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:18</div>
            <div class="timeline-body"><p>yeah, I think I&#x27;d just focus on the known footgun -- apart from anything else, <code>NotImplementedType</code> cannot be subclassed, so the user will get an error about <code>Tricksy</code> at runtime and ty will also complain about the invalid class definition: https://play.ty.dev/03244fb4-7141-43e4-baf8-240d405ac1d3</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-11-24 17:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:20</div>
            <div class="timeline-body"><blockquote>
<p>My approach also covered</p>
<pre><code>tricksy = NotImplemented
raise tricksy
</code></pre>
</blockquote>
<p>that&#x27;s also covered by my suggested approach! <code>tricksy</code> has the same type as the <code>NotImplemented</code> singleton here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-24 17:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:26</div>
            <div class="timeline-body"><p>Interesting. For whatever reason, the type that completions sees for <code>tricksy</code> is <code>Never</code>:</p>
<pre><code>[crates/ty_ide/src/completion.rs:413:17] item = Completion {
    name: Name(&quot;tricksy&quot;),
    insert: None,
    ty: Some(
        Never,
    ),
    kind: None,
    module_name: None,
    import: None,
    builtin: false,
    is_type_check_only: false,
    is_definitively_raisable: true,
    documentation: None,
}
</code></pre>
<p>Example:</p>
<p>https://github.com/user-attachments/assets/fc93503a-6b8f-496c-98e5-8ee557004c8e</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-24 17:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:27</div>
            <div class="timeline-body"><p>I think it has something to do with it being used in a <code>raise</code> context?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-11-24 17:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:28</div>
            <div class="timeline-body"><p>(This is for my own edification at this point. I updated the PR to use your approach. :))</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-11-24 17:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_ide/src/completion.rs</code>:414 on 2025-11-24 17:32</div>
            <div class="timeline-body"><blockquote>
<p>Interesting. For whatever reason, the type that completions sees for <code>tricksy</code> is <code>Never</code>:</p>
</blockquote>
<p>hmm... that seems incorrect; there must be a bug somewhere. (Where it is I don&#x27;t know -- probably in <code>ty_python_semantic</code> rather than <code>ty_ide</code>, though it might well be in <code>ide_support.rs</code> rather than one of the &quot;core type-inference&quot; parts of that crate.)</p>
<blockquote>
<p>I think it has something to do with it being used in a <code>raise</code> context?</p>
</blockquote>
<p>yes, that seems likely</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-24 17:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2025-11-24 17:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-11-24 17:55</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:20:56 UTC
    </footer>
</body>
</html>
