<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add Rule to check for singular `yield` in `@contextlib.{async}contextmanager` decorated functions (RUF062) - astral-sh/ruff #17281</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add Rule to check for singular <code>yield</code> in <code>@contextlib.{async}contextmanager</code> decorated functions (RUF062)</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17281">#17281</a>
        opened by <a href="https://github.com/maxmynter">@maxmynter</a>
        on 2025-04-07 16:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a></div>
            <div class="timeline-body">

<p>Closes #16949</p>
Summary
<p>Add a rule that checks that only a single <code>yield</code> statement is in <code>@contextlib.contextmanager</code> or <code>@contextlib.asynccontextmanager</code> decorated functions.</p>
<p>Later <code>yield</code> statements are executed in the cleanup stage of the contextmanager and result in a <code>RuntimeError</code>.</p>
<p>See <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager">docs</a></p>
Notes
<ul>
<li>I reused the <code>function_def_visit_preorder_except_body</code> from the <code>unused_async.rs</code> rule and moved it to <code>helpers.rs</code> alongside <code>class_def_visit_preorder_except_body</code>. While I don&#x27;t use the latter, I moved both to maintain code locality.</li>
</ul>


Test Plan
<p>Added a testing fixture and <code>cargo insta</code> snapshot.</p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-07 16:50</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>âœ… ecosystem check detected no linter changes.</p>
Linter (preview)
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-07 17:15</div>
            <div class="timeline-body"><p>I&#x27;ve looked through these ecosystem changes.
They all come from branches in the control flow like this one:</p>
<pre><code>@contextmanager
def context():
   print(&quot;setup&quot;)
   if condition:
       print(&quot;condition&quot;)
       yield
   else:
       print(&quot;not condition&quot;)
       yield
    print(&quot;teardown&quot;)
</code></pre>
<p>The current implementation does not check for this; it should. I&#x27;m working on it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-07 17:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-09 22:04</div>
            <div class="timeline-body"><p>Still work in progress. Currently handling of <code>try-except-else</code> blocks is wrong and I also want to extend the test for deeper nested cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-10 16:00</div>
            <div class="timeline-body"><p>RUF060 traverses source-ordered AST nodes while maintaining a stack tracking yield counts across execution paths:</p>
<ul>
<li>Overrides visit_stmt to handle optional control flow blocks (if/elif/else, try/except/else/finally, for/while/else)</li>
<li>For branching structures: takes maximum yield count across exclusive branches to proceed</li>
<li>For try/except/else/finally the except(s)/else are mutually exclusive</li>
<li>For loops: flags any yield in loop body as problematic (likely multiple yields, we only know at runtime iirc), optional else clause</li>
<li>Match/Case does not need special handling since &gt;= one case block are mandatory</li>
</ul>
<p>Using two testing fixtures; one for failing and one for passing cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-10 16:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-14 13:11</div>
            <div class="timeline-body"><p>Can we run the ecosystem tests again?</p>
<p>I try running them locally but get the same issues as #10436 (<code>error: invalid value &#x27;RUF9&#x27; for &#x27;--ignore &lt;RULE_CODE&gt;&#x27;</code> in all repo&#x27;s). It doesn&#x27;t seem related to my changes and I also get the failure on the commit that passed in CI.
If you have any pointers how to fix that, I would greatly appreciate.</p>
<p>Otherwise this is ready for review.</p>
<p>cc: @ntBre (since you reacted to my previous comment above).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-14 15:15</div>
            <div class="timeline-body"><p>The <code>RUF9</code> rules are only available in test builds, so you have to build in the test or maybe dev profile. I&#x27;ve run into this a bit myself and don&#x27;t remember exactly the command I ran to avoid it :sweat_smile:</p>
<p>The ecosystem checks should rerun automatically and update the comment. Are you seeing stale results? You could try pushing an empty commit to retrigger it, but CI might also check if relevant files changed, I&#x27;d have to double check.</p>
<p>I&#x27;ll try to give this a review in the next day or two!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/ntBre">@ntBre</a> by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-14 15:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-14 19:39</div>
            <div class="timeline-body"><p>I think you&#x27;ve picked a really tough rule to implement because it requires such a careful analysis of control flow. I added a minimized version of the first ecosystem hit as a test case:</p>
<pre><code>@contextlib.contextmanager
def foo():
    if False:
        yield 1
        return
    yield 2
</code></pre>
<p>and it is a real false positive.</p>
<p>I think this rule&#x27;s implementation might be simplified by the control flow graph work being tracked in #17065, so I&#x27;d probably recommend holding off on this for now.</p>
<p>Thanks for your work here and apologies for not noticing this or commenting on the issue earlier!</p>
<p>For now, the main other thing you could do is just go through the ecosystem results and see if there are any other interesting test cases. The two I randomly picked also had this early return form, so they may make up a majority of false positives.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-16 08:57</div>
            <div class="timeline-body"><p>I went through the ecosystem changes. Most are the return case you describe. Sometimes a little more complex:</p>
<pre><code>try:
    yield
finally:
    return
</code></pre>
<p>So an implementation that tracks returns over control flow branches would also need to consider cases like this one where the return does not follow in the same block.</p>
<p>There are <a href="https://github.com/ibis-project/ibis/blob/21e47ac0b39dc07122b67a95f0e92abd162a746f/ibis/backends/athena/__init__.py#L286">two</a> <a href="https://github.com/zulip/zulip/blob/440864e7c92511f1181899133d5cc87b4988dfdc/zerver/lib/context_managers.py#L36">other</a> <code>try</code>-<code>except</code> blocks like this:</p>
<pre><code>try:
    yield 1
except:
    yield 2
</code></pre>
<p>which in principle is a true positive. If the <code>try</code> fails after the <code>yield</code>, there would be a second one in the <code>except</code> block.</p>
<p>However, I think it&#x27;s a reasonable assumption that in the context of an <code>@contextmanager</code> the error prone code is prior to the <code>yield</code>.
Then we can assume that the control flow either passes the <code>yield</code>s in <code>try</code>-<code>else</code>-<code>finally</code> or <code>try</code>-<code>except</code>-<code>finally</code>.</p>
<hr>
<p>As for the ecosystem changes. No they are not stale for me. I think i got sidetracked by this <code>RUF9</code> error and not being able to execute locally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-16 13:08</div>
            <div class="timeline-body"><p>Thanks again for working on this! I just want to make sure you saw this part of my comment above since I saw some new commits:</p>
<blockquote>
<p>I think this rule&#x27;s implementation might be simplified by the control flow graph work being tracked in <a href="https://github.com/astral-sh/ruff/issues/17065">astral-sh/ruff#17065</a>, so <strong>I&#x27;d probably recommend holding off on this for now</strong>.</p>
</blockquote>
<p>You&#x27;re certainly welcome to keep working on it, but I think it will be easier to implement and to review once we have more general control-flow graph support.</p>
<p>cc @dylwil3 to make sure I&#x27;m not totally off-base with what the CFG work will give us</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-04-16 13:20</div>
            <div class="timeline-body"><p>Yep that&#x27;s the hope! However the initial version will probably have simplified handling for <code>try</code> statements (since those are quite the quagmire); I also haven&#x27;t actually thought much about <code>yield</code> statements so it&#x27;s possible I haven&#x27;t modeled them correctly ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-04-16 13:35</div>
            <div class="timeline-body"><p>Thanks Dylan!</p>
<p>I&#x27;d still lean towards waiting on the separate CFG work, and then the rule will grow capabilities as the CFG infrastructure improves, but I&#x27;m open to other thoughts too. The extra unit tests from the ecosystem check will still be very helpful for knowing where we stand throughout the process.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-16 14:15</div>
            <div class="timeline-body"><p>Thanks @ntBre, I saw your note but i&#x27;ve learned quite a bit in implementing this. That&#x27;s why I went with <a href="https://astral-sh.notion.site/Astral-s-Values-0ed6a642bcc84e91af6836b2373572f5">bias toward action</a> knowing I&#x27;m happier with a working implementation that&#x27;s idle for roadmap reasons, than to abandon this half finished.
I also think it would be cool to have a substantial rule contributed to ruff  ðŸ¤© (i made <code>RUF102</code> last week, but it&#x27;s rather simple).</p>
<p>In the latest commit&#x27;s i&#x27;ve changed to the assumption that any failures in a <code>try</code> block happen before a <code>yield</code>.
This is also my recommentation. I think it&#x27;s a sensible hypothesis in the context of <code>@contextmanager</code> and otherwise we would either just accumulate over branches (with many false positives) or have special cases for pre/post <code>yield</code> errors which let&#x27;s complexity of the implementation explode.</p>
<p>It seems that this adresses the ecosystem change issues.</p>
<p>So if you are up for it I would love to try to get this over the finish line. Of course, I understand if you have too much on your plate or just want to wait. That&#x27;s a risk I took willingly.</p>
<p>In that case, @dylwil3, What is the timeline for #17065?
I&#x27;m full time on OSS contributions for another three weeks and if it&#x27;s done in time, I would love another jab at this one using the CFG. Also let me know if I can help with this or in any other capacity!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-04-16 16:06</div>
            <div class="timeline-body"><p>The goal is to have the stacked PRs ready to review by Monday - but it&#x27;s hard to predict with confidence the timeline after that since it depends on the results of code review. Optimistically, a reasonable implementation will be merged in by the following Monday which you can then play with here.</p>
<blockquote>
<p>Also let me know if I can help with this or in any other capacity!</p>
</blockquote>
<p>Absolutely! At the moment there&#x27;s a few parts of the design that I&#x27;d like to stabilize, but then I&#x27;d be happy to help divvy up the work - thanks for offering!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-16 21:21</div>
            <div class="timeline-body"><p>Awesome! Looking forward!</p>
<p>I&#x27;ll mark this as draft until then and this probably doesn&#x27;t need a review before the CFG is ready (unless of course someone is bored; in that case i&#x27;d appreciate any pointers to improve my Rust).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-04-16 21:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-05-10 04:29</div>
            <div class="timeline-body"><p>Note: The merge conflicts are with #16480 which by now has been merged as <code>RUF060</code>.
A renaming here should do. I&#x27;m Happy to take care once we decide to move forward here</p>
<p>I would love to get this one over the finish line sometime and given extensive test cases and the ecosystem checks, I&#x27;m also pretty confident. The actual implementation is only 350ish lines. Does it still make sense to wait on the CFG work, @ntBre?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dylwil3">@dylwil3</a> on 2025-05-11 16:22</div>
            <div class="timeline-body"><p>@maxmynter as these things go sometimes, CFG work has been slowed in favor of some higher priority tasks. My apologies! I&#x27;m personally okay with moving forward with the rule as it currently exists as long as we feel confident about getting no/rare false positives (this is preferred even if it means having more false negatives).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by <a href="https://github.com/ntBre">@ntBre</a> on 2025-05-12 12:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-05-12 12:58</div>
            <div class="timeline-body"><p>Sure, I can try to review it at some point if you fix the conflicts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-05-12 18:39</div>
            <div class="timeline-body"><p>Just as a note on the rule code, you may want to jump to RUF062. <a href="https://github.com/astral-sh/ruff/pull/17368">astral-sh/ruff#17368</a> is currently using RUF061 too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-05-13 03:58</div>
            <div class="timeline-body"><p>Awesome, I will tidy up here over the next few days and reopen and request a review once I&#x27;m there.</p>
<p>@dylwil3 I hope I didn&#x27;t come off as pushy and if so, apologies. I guess, I&#x27;m just excited about this contribution and definitely understand that you all have other priorities as weil!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-05-13 22:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/ntBre">@ntBre</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-26 09:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dylwil3">@dylwil3</a> by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-26 09:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-06 13:04</div>
            <div class="timeline-body"><p>I did a quick merge with some changes I made recently, hope you don&#x27;t mind. I&#x27;m preparing to review this today!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:93 on 2025-06-06 13:29</div>
            <div class="timeline-body"><p>Is this the same as case 3 above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:138 on 2025-06-06 13:32</div>
            <div class="timeline-body"><p>It looks like this one might be missing an <code>else</code> based on the name and comment</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:154 on 2025-06-06 13:33</div>
            <div class="timeline-body"><p>Ah maybe the body of this one is swapped with <code>while_loop_with_else</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:184 on 2025-06-06 13:46</div>
            <div class="timeline-body"><p>This part kind of confuses me. We&#x27;re not inspecting the actual body of <code>is_true</code> right? It&#x27;s just a placeholder for a boolean function? I might just delete the inner function here if that&#x27;s the case, it&#x27;s fine for it to be undefined.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062_1.py</code>:46 on 2025-06-06 13:51</div>
            <div class="timeline-body"><p>The one case where this might be valid is if the <code>yield</code> is followed by an unconditional <code>break</code> or <code>return</code>. Does the rule handle that case? <code>return</code> seemed well handled in the valid cases, but I don&#x27;t remember seeing <code>break</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:319 on 2025-06-06 13:58</div>
            <div class="timeline-body"><p>So are these cases <em>not</em> valid anymore? I came back up here to ask after reading the invalid cases below, which look very similar. And now I&#x27;m seeing the <code># RUF060</code> comments here which indicate to me that these cause errors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/mod.rs</code>:103 on 2025-06-06 14:00</div>
            <div class="timeline-body"><p>nit: if the second test file is _1 I&#x27;d usually make the first one _0.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/helpers.rs</code>:214 on 2025-06-06 14:07</div>
            <div class="timeline-body"><p>very minor nit: I was curious to see what <code>visit_preorder</code> looked like, but I think it doesn&#x27;t exist anymore. I know you just carried this comment over from the other file, but if you&#x27;re curious, it would be interesting to me to know what <code>visit_preorder</code> is called now (and if we could possibly use it now).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:37 on 2025-06-06 14:19</div>
            <div class="timeline-body"><p>Is it worth tracking an enum or bool saying whether the context manager was async? I think this message will be slightly incorrect for <code>asynccontextmanager</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:54 on 2025-06-06 14:29</div>
            <div class="timeline-body"><p>Is this condition ever transiently <code>true</code> while traversing and then reset back to <code>false</code>? I&#x27;m wondering because an alternative approach here would be to store a <code>&amp;Checker</code> in the <code>YieldPathTracker</code> and call <code>report_diagnostic</code> as soon as we see an extra yield. I think this would have two main benefits:</p>
<ol>
<li>We can emit multiple diagnostics if there are more than two <code>yield</code>s</li>
<li>We can capture a more helpful diagnostic range from the problematic <code>yield</code> statement</li>
</ol>
<p>And a third point closely related to these is that we&#x27;re currently refactoring our diagnostic infrastructure in a way that should allow us to attach multiple spans/pieces of info to a diagnostic soon. We could potentially emit a multi-part diagnostic here with pieces like:</p>
<ul>
<li>This <code>yield</code> in</li>
<li>This context manager is an error because of</li>
<li>This earlier <code>yield</code> in the same path</li>
</ul>
<p>each with their own range/code snippet, which would be pretty cool. We can&#x27;t do that now, but I feel like the <code>&amp;Checker</code> approach would make that change easy in the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:72 on 2025-06-06 15:38</div>
            <div class="timeline-body"><p>nit: it seems like this is a visitor, so I&#x27;d probably name it <code>YieldPathVisitor</code>.</p>
<p>I also think this type could use some docs explaining the meaning of the stacks and how they are modified while traversing the AST. I&#x27;m writing this before reading much of the code below, but I&#x27;m also wondering if these stacks are manipulated independently or if it might make more sense to have a single stack of something like <code>Scope</code>s, where each scope has its own <code>yields</code> and <code>returns</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:80 on 2025-06-06 15:40</div>
            <div class="timeline-body"><p>Do we need to <code>pop</code> here or  could you just inspect the value with <code>last</code>? That doesn&#x27;t seem quite right for the <code>None</code> case where you push 0, but that&#x27;s also slightly surprising to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-06 15:51</div>
            <div class="timeline-body"><p>Thanks. I haven&#x27;t really wrapped my head fully around the stack stuff, but I have a few suggestions that might make things more clear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 07:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:93 on 2025-06-12 07:52</div>
            <div class="timeline-body"><p>Yes, thanks for catching this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 07:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:184 on 2025-06-12 07:56</div>
            <div class="timeline-body"><p>Agree. Back when I was writing these, I wasn&#x27;t too deep in Ruff&#x27;s testing setup and got intimidated when the linting of the fixture began screaming at me! Removed these</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 07:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062_1.py</code>:46 on 2025-06-12 07:59</div>
            <div class="timeline-body"><p>It&#x27;s not yet. I will add handling and tests for <code>break</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/resources/test/fixtures/ruff/RUF062.py</code>:319 on 2025-06-12 08:12</div>
            <div class="timeline-body"><p>The heuristic of this rule assumes that an error in a <code>try/except</code> occurs before the yield statement. Thus it&#x27;s assumes the data flow and thus yield accumulation to either follow <code>try-&gt;else-&gt;finally</code> or <code>except-&gt;finally</code>.</p>
<p>Therefore this is valid but those two aren&#x27;t:</p>
<pre><code># (15) Invalid: Unguarded yield in finally
@contextlib.contextmanager
def yield_in_finally():
    try:
        yield
    except:
        pass
    else:
        return
    finally:
        yield

# (16) Invalid: No returning except accumulates yields
@contextlib.contextmanager
def yield_in_no_return_except():
    try:
        pass
    except:
        yield
    else:
        yield
        return
    yield
</code></pre>
<p>I agree about the comments though. They are stale. An earlier version of the rule was also accumulating <code>yields</code> in the full <code>try-&gt;except-&gt;else-&gt;finally</code> path. But this had changes in the ecosystem tests for cases like these:</p>
<pre><code>try:
     some_flaky_setup()
     yield &quot;success&quot;
except CommonFlakinessError:
    yield &quot;alternative&quot;
</code></pre>
<p>Therefore I moved this from invalid to valid cases. The same is true for the 3 succeeding test cases. I removed all the stale <code>#RUF060</code> comments there too.</p>
<p>I think in the context of a contextmanager it makes sense, that the error prone code preceds the <code>yield</code> and we only count <code>yield</code>s in the abovementioned path.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 08:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-06-12 08:53</div>
            <div class="timeline-body"><p>Test todos:</p>
<ul>
<li>[x] Review Comments on tests</li>
<li>[x] Rename fixture <code>RUF062.py</code> -&gt; <code>RUF062_0.py</code></li>
<li>[x] Update Snapshots</li>
</ul>
<p>Rule Logic Todos</p>
<ul>
<li>[x] Add tests for break</li>
<li>[ ] Implement handling for <code>break</code></li>
<li>[x] Accumulate violating expressions for individual diagnostic</li>
<li>[x] Refactor <code>.pop()</code> use</li>
<li>[x] Rename <code>YieldPathTracker</code></li>
<li>[x] Move stacks into <code>struct Scope</code></li>
<li>[x] Fixup <code>merge_continuing_branch</code> borrowing workaround (line 108)</li>
</ul>
Questions
Ok to only report along max yield path?
<p>Currently, we accumulate <code>yields</code> greedily. Therefore we can only report diagnostics for yields along this path. Eg. here</p>
<pre><code># (12) Invalid: Multiple yields in complex try/except/else/finally
@contextlib.contextmanager
def complex_try_except_else_finally(condition):
    try:
        if condition:
            yield &quot;in try if&quot;
        else:
            yield &quot;in try else&quot;
    except ValueError:
        yield &quot;in ValueError&quot;  # Unreported RUF062; only report on max yield path
    except TypeError:
        yield &quot;in TypeError&quot;  # Unreported RUF062; only report on max yield path
    else:
        yield &quot;in else&quot;  # RUF062
    finally:
        yield &quot;in finally&quot;  # RUF062
</code></pre>
<p>we only report along the try-else-finally pathway. Is that fine or should we accumulate all?
Computationally this may become more complex though as we multiply the number of scopes at every branch instead of only taking the maximum path.</p>
<p>In the above example we would need to track along the <code>try -&gt; ValueError -&gt; finally</code>, <code>try -&gt; TypeError -&gt; finally</code>, and <code>try -&gt; else -&gt; finally</code> pathways. Without it, not all offending violations are marked. However, fixing iteratively will eventually adress all violations.</p>
Don&#x27;t report on yield followed by break in loop?
<p>Implementing this is quite involved because we would need to recursively check the body of the loop and the contained expressions while keeping track of their order. This breaks the symmetry on yield check. Thus,  we  would need to check for being nested in a loop everywhere and . if we are, check for a succeeding <code>break</code>. This also needs us to track the order in which we encounter the <code>yield</code> / <code>break</code>s.</p>
<p>Given we found no loops in the ecosystem checks (and <code>yield</code> out of a loop in a <code>contextmanager</code> decorated function is unorthodox, they are only allowed to yield once), I would suggest one of the following:</p>
<ul>
<li>Keep the heuristic and report yields in loops, users can <code># noqa</code> if they need to,</li>
<li>Drop the heuristic and ignore the fact that loops are repeatedly executed. We would just check the enclosed control flow like we do with e.g. <code>if</code>/<code>else</code> bodies.</li>
</ul>
<p>I would lean toward two because false positives are annoying. But i&#x27;m hesitant for the complexity added by adressing yield given that we did not see it occur anywhere.</p>
<p>If we really want to include the loop check, I would like that in a separate PR because this one is big already.</p>
<p>Let me know what you think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Add Rule to check for singular `yield` in `@contextlib.{async}contextmanager` decorated functions (RUF060)&quot; to &quot;Add Rule to check for singular `yield` in `@contextlib.{async}contextmanager` decorated functions (RUF062)&quot; by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-06-12 08:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 09:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/helpers.rs</code>:214 on 2025-06-12 09:09</div>
            <div class="timeline-body"><p>It was changed here</p>
<pre><code>commit 050f33277163db62449d11e9cc84137be26661d4 refs/remotes/upstream/dhruv/callable-disjoint
Author: Micha Reiser &lt;micha@reiser.io&gt;
Date:   Fri Mar 28 20:40:26 2025 +0100

    Rename `visit_preorder` to `visit_source_order` (#17046)

    ## Summary

    We renamed the `PreorderVisitor` to `SourceOrderVisitor` a long time ago
    but it seems that we missed to rename the `visit_preorder` functions to
    `visit_source_order`.
    This PR renames `visit_preorder` to `visit_source_order`
</code></pre>
<p>with this being the (generated) code:
https://github.com/astral-sh/ruff/blob/e6fe2af292e7be87c2917863464a5455c5b22c38/crates/ruff_python_ast/src/generated.rs#L7288-L7321</p>
<p>I updated the name in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/42828fb5ff48b1014ed27fef06442aab046c151b">42828fb</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 10:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:37 on 2025-06-12 10:18</div>
            <div class="timeline-body"><p>Adressed in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/7ae6e798247d070f8513878e84fb51c35b2467f8">7ae6e79</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 10:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:54 on 2025-06-12 10:22</div>
            <div class="timeline-body"><p>No. This is never transiently true, so this is a great idea!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-12 15:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:54 on 2025-06-12 15:24</div>
            <div class="timeline-body"><p>Adressed in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/5451c18fb937365b9295ecc522042bf2109b0b4c">5451c18</a></p>
<p>We need a HashMap to track offending expressions as every expression can be part of multiple paths which may or may not be violating the rule. Thus they may be added repeatedly.</p>
<p>I now use the expressions to add the diagnostic at the specific <code>yield</code> instead of the full function.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-13 14:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:72 on 2025-06-13 14:03</div>
            <div class="timeline-body"><p>Good idea -- makes for a natural abstraction and the code easier to understand!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-06-13 14:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:80 on 2025-06-13 14:30</div>
            <div class="timeline-body"><p><code>last</code> would have been enough but it&#x27;s irrelevant now with the refactor.</p>
<p>I agree the debug assert and pushing is awkward. I added it to avoid a runtime <code>panic!</code> but if we attempt to pop from an empty stack, there is always a logical error. With an extensive test suite I think <code>.expect()</code> is nicer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/ntBre">@ntBre</a> by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-06-13 17:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-07-10 13:15</div>
            <div class="timeline-body"><p>(I&#x27;m finally taking a look at this today, thanks again for your work here!)</p>
<p>To your questions, I think it <em>would</em> be nice to report all of the violations, if it&#x27;s not too much more programming work. I think we generally like to avoid situations where fixing one issue &quot;creates&quot; a second one that we didn&#x27;t report initially. I don&#x27;t think this is a blocker, though.</p>
<p>And I think I agree with you about not worrying about <code>break</code>. I had just reviewed a rule where <code>break</code> and <code>return</code> were also being used and the test cases here brought it to mind, but that would seem like a strange pattern in a context manager, as you said.</p>
<p>I&#x27;ll take another look at the rest of the code now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-07-10 13:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/helpers.rs</code>:214 on 2025-07-10 13:17</div>
            <div class="timeline-body"><p>Looks like everything is updated except the comment ðŸ˜† Thanks for finding the commit!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:14 on 2025-07-10 13:22</div>
            <div class="timeline-body"><p>Should we mention <code>asynccontextmanager</code> here?</p>
<pre><code>/// Checks that a function decorated with `contextlib.contextmanager` or 
/// `contextlib.asynccontextmanager` yields at most once.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:21 on 2025-07-10 13:23</div>
            <div class="timeline-body"><p>Hmm, we usually have a <code>use instead:</code> part of the example, but I guess it&#x27;s not really clear what the user meant. I guess we could just drop the second yield? Maybe this is fine as-is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:80 on 2025-07-10 13:26</div>
            <div class="timeline-body"><p>Oh, when I saw <code>String</code> in the <code>Violation</code> struct, I assumed you were slicing out the actual contents from the file. For this case, we could just use a <code>&amp;&#x27;static str</code> and avoid allocating. (Or you could try the slicing approach, so if a user imports the decorator directly the error message would reflect that)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:64 on 2025-07-10 13:56</div>
            <div class="timeline-body"><p>I tried this patch locally to embed the <code>Checker</code> in the visitor to emit the errors as we encounter them. I&#x27;m not sure it&#x27;s really much better because we do still need a hash set to avoid duplicate diagnostics. Just an idea if it appeals to you. Possibly it would help with emitting all diagnostics in a branch?</p>
Patch

<pre><code>diff --git a/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs b/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs
index fc2dfe6667..ae44981249 100644
--- a/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs
+++ b/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs
@@ -4,7 +4,7 @@ use ruff_python_ast::AnyNodeRef;
 use ruff_python_ast::helpers::map_callable;
 use ruff_python_ast::{self as ast, visitor::source_order};
 use ruff_text_size::{Ranged, TextRange};
-use rustc_hash::FxHashMap;
+use rustc_hash::FxHashSet;
 
 use crate::checkers::ast::Checker;
 use crate::rules::ruff::rules::helpers::function_def_visit_sourceorder_except_body;
@@ -54,14 +54,8 @@ impl Violation for MultipleYieldsInContextManager {
 /// RUF062
 pub(crate) fn multiple_yields_in_contextmanager(checker: &amp;Checker, function_def: &amp;StmtFunctionDef) {
     if let Some(context_manager_name) = get_contextmanager_decorator(function_def, checker) {
-        let mut path_tracker = YieldPathVisitor::new();
+        let mut path_tracker = YieldPathVisitor::new(checker, context_manager_name);
         source_order::walk_body(&amp;mut path_tracker, &amp;function_def.body);
-        for expr in path_tracker.into_violations() {
-            checker.report_diagnostic(
-                MultipleYieldsInContextManager::new(context_manager_name.clone()),
-                expr.range(),
-            );
-        }
     }
 }
 
@@ -93,16 +87,20 @@ fn get_contextmanager_decorator(
 // Within a scope we evaluate all control flow paths and propagate the yields along the
 // maximum path to the outer scope.
 // Return exits the contextmanager decorated function and we stop accumulating yields along that path.
-struct YieldPathVisitor&lt;&#x27;a&gt; {
+struct YieldPathVisitor&lt;&#x27;a, &#x27;b&gt; {
     scopes: Vec&lt;Scope&lt;&#x27;a&gt;&gt;,
-    violations: FxHashMap&lt;TextRange, &amp;&#x27;a Expr&gt;,
+    checker: &amp;&#x27;a Checker&lt;&#x27;b&gt;,
+    name: String,
+    seen: FxHashSet&lt;TextRange&gt;,
 }
 
-impl&lt;&#x27;a&gt; YieldPathVisitor&lt;&#x27;a&gt; {
-    fn new() -&gt; Self {
+impl&lt;&#x27;a, &#x27;b&gt; YieldPathVisitor&lt;&#x27;a, &#x27;b&gt; {
+    fn new(checker: &amp;&#x27;a Checker&lt;&#x27;b&gt;, name: String) -&gt; Self {
         Self {
             scopes: vec![Scope::new()],
-            violations: FxHashMap::default(),
+            checker,
+            name,
+            seen: FxHashSet::default(),
         }
     }
 
@@ -146,7 +144,7 @@ impl&lt;&#x27;a&gt; YieldPathVisitor&lt;&#x27;a&gt; {
     fn report_multiple_yield_violations(&amp;mut self, yields: &amp;[&amp;&#x27;a Expr]) {
         // Only report the second to last violations
         for &amp;yield_expr in yields.iter().skip(1) {
-            self.violations.insert(yield_expr.range(), yield_expr);
+            self.report_single_yield_violation(yield_expr);
         }
     }
 
@@ -159,11 +157,13 @@ impl&lt;&#x27;a&gt; YieldPathVisitor&lt;&#x27;a&gt; {
     }
 
     fn report_single_yield_violation(&amp;mut self, yield_expr: &amp;&#x27;a Expr) {
-        self.violations.insert(yield_expr.range(), yield_expr);
-    }
-
-    fn into_violations(self) -&gt; impl Iterator&lt;Item = &amp;&#x27;a Expr&gt; {
-        self.violations.into_values()
+        let range = yield_expr.range();
+        if self.seen.insert(range) {
+            self.checker.report_diagnostic(
+                MultipleYieldsInContextManager::new(self.name.clone()),
+                range,
+            );
+        }
     }
 
     // For exclusive branches (if/elif/else, match cases, ...) - propagate the maximum
@@ -226,7 +226,7 @@ impl&lt;&#x27;a&gt; Scope&lt;&#x27;a&gt; {
     }
 }
 
-impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldPathVisitor&lt;&#x27;a&gt; {
+impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldPathVisitor&lt;&#x27;a, &#x27;_&gt; {
     fn enter_node(&amp;mut self, node: AnyNodeRef&lt;&#x27;a&gt;) -&gt; source_order::TraversalSignal {
         match node {
             AnyNodeRef::StmtFor(_)
@@ -405,7 +405,7 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldPathVisitor&lt;&#x27;a&gt; {
                 if let Some(scope) = self.scopes.last_mut() {
                     scope.add_yield(expr);
                     if scope.does_yield_more_than_once() {
-                        self.violations.insert(expr.range(), expr);
+                        self.report_single_yield_violation(expr);
                     }
                 }
             }
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:112 on 2025-07-10 14:09</div>
            <div class="timeline-body"><p>This check pops up in a lot of places, which doesn&#x27;t feel quite right to me. I think a nicer API, if it&#x27;s possible, would be to have <code>add_yield</code> perform this check. That way you don&#x27;t have to worry about this in so many places, you just call <code>add_yield</code> whenever you encounter one, and a diagnostic is emitted if appropriate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-07-10 14:17</div>
            <div class="timeline-body"><p>I think the tests look good, but I&#x27;m hoping we can still simplify the code a bit more.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-07-14 15:39</div>
            <div class="timeline-body"><p>Thanks @ntBre for your review. I&#x27;m somewhat occupied the next two weeks but will continue here afterwards!</p>
<p>Edit (Aug 11th): Will get back to this -- sorry, lots of life stuff right now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:14 on 2025-08-21 11:44</div>
            <div class="timeline-body"><p>Adressed in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/7781d140633b62716cd06cc5795e1287b74bd7c1">7781d14</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-21 11:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-21 11:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:21 on 2025-08-21 11:45</div>
            <div class="timeline-body"><p>I made it more explicit in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/7781d140633b62716cd06cc5795e1287b74bd7c1">7781d14</a>.</p>
<p>I feel it may be a bit redundant, but since it doesn&#x27;t add a lot of text, I feel its better to be really explicit and have the working example, too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-21 11:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:80 on 2025-08-21 11:55</div>
            <div class="timeline-body"><p>Adressed in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/e95fd25ab6b558f1112d8968e4db05e7faad95ff">e95fd25</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-21 15:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:64 on 2025-08-21 15:46</div>
            <div class="timeline-body"><p>Thanks for your suggestion. I&#x27;ve incorporated parts of it in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/395e8ad8139113570a893447761eb31d042d0d14">395e8ad</a> but tried to keep the concerns of the visitor and caller separate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-21 15:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:112 on 2025-08-21 15:51</div>
            <div class="timeline-body"><p>Adressed in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/395e8ad8139113570a893447761eb31d042d0d14">395e8ad</a> and <a href="https://github.com/astral-sh/ruff/pull/17281/commits/21a92aacda77d096e8cd928e38d11abf8eb695a7">21a92aa</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-08-21 19:02</div>
            <div class="timeline-body"><p>Finally got around to do some more work here! Thanks (again) for your review @ntBre.</p>
<p>I&#x27;ve</p>
<ul>
<li>Resolved merge conflicts. Just renaming of methods.</li>
<li>Broken up the Try-except-else-finally logic into smaller functions to make it easier to reason about</li>
<li>use a collection-emission pattern for the yield counting.</li>
<li>Improved naming quite a bit</li>
<li>Added a couple more brief comments</li>
<li>Removed a couple unnecessary allocations</li>
<li>Extracted a couple code duplications</li>
</ul>
<p>Let me know what you think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/ntBre">@ntBre</a> by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-08-21 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:184 on 2025-08-26 19:50</div>
            <div class="timeline-body"><p>I deleted the implementation of this method, and all of the tests still pass. Is it possible that this is unnecessary, or just none of the tests exercise it? Intuitively, it seems to me if we&#x27;re leaving the scope, we don&#x27;t really need to clear it out, but I might not be following the flow here correctly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:111 on 2025-08-26 20:06</div>
            <div class="timeline-body"><p>I&#x27;m not really buying the separation of concerns thing here. To me, the whole concern is to emit diagnostics, so I think it makes sense to have the checker here and emit diagnostics as we find them. I tried this again locally, and it&#x27;s both less code and avoids allocating an intermediate <code>Vec</code> if we just embed the <code>Checker</code>, which I think makes it a clear win.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-08-26 21:31</div>
            <div class="timeline-body"><p>Thanks for following up on this and continuing to handle my pedantic feedback :)</p>
<p>All of my minor concerns are resolved, but I&#x27;m still thinking the implementation is more complicated than it needs to be. This is kind of a generalization of my comment below, but I just started deleting chunks of code and all of our tests still pass. Here&#x27;s the patch I was working on locally:</p>
Patch

<pre><code>diff --git a/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs b/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs
index 305b21d3ed..fc73075430 100644
--- a/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs
+++ b/crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs
@@ -66,18 +66,8 @@ impl Violation for MultipleYieldsInContextManager {
 /// RUF062
 pub(crate) fn multiple_yields_in_contextmanager(checker: &amp;Checker, function_def: &amp;StmtFunctionDef) {
     if let Some(context_manager_name) = get_contextmanager_decorator(function_def, checker) {
-        let mut violations = Vec::new();
-        {
-            let mut yield_tracker = YieldTracker::new(&amp;mut violations);
-            source_order::walk_body(&amp;mut yield_tracker, &amp;function_def.body);
-        }
-
-        for range in violations {
-            checker.report_diagnostic(
-                MultipleYieldsInContextManager::new(context_manager_name),
-                range,
-            );
-        }
+        let mut yield_tracker = YieldTracker::new(checker, context_manager_name);
+        source_order::walk_body(&amp;mut yield_tracker, &amp;function_def.body);
     }
 }
 
@@ -107,16 +97,18 @@ fn get_contextmanager_decorator(
 // Within a scope we evaluate all control flow paths and propagate the yields along the
 // maximum path to the outer scope.
 // Return exits the contextmanager decorated function and we stop accumulating yields along that path.
-struct YieldTracker&lt;&#x27;a&gt; {
-    violations: &amp;&#x27;a mut Vec&lt;TextRange&gt;,
+struct YieldTracker&lt;&#x27;a, &#x27;b&gt; {
+    checker: &amp;&#x27;a Checker&lt;&#x27;b&gt;,
+    name: &amp;&#x27;static str,
     scopes: Vec&lt;YieldScope&lt;&#x27;a&gt;&gt;,
     reported_ranges: FxHashSet&lt;TextRange&gt;,
 }
 
-impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
-    fn new(violations: &amp;&#x27;a mut Vec&lt;TextRange&gt;) -&gt; Self {
+impl&lt;&#x27;a, &#x27;b&gt; YieldTracker&lt;&#x27;a, &#x27;b&gt; {
+    fn new(checker: &amp;&#x27;a Checker&lt;&#x27;b&gt;, name: &amp;&#x27;static str) -&gt; Self {
         Self {
-            violations,
+            checker,
+            name,
             scopes: vec![YieldScope::new()],
             reported_ranges: FxHashSet::default(),
         }
@@ -124,51 +116,36 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
 
     fn add_yield(&amp;mut self, expr: &amp;&#x27;a Expr) {
         if let Some(scope) = self.scopes.last_mut() {
-            scope.add_yield(expr);
+            scope.yield_expressions.push(expr);
             if scope.yields_excessively() {
                 self.emit_violation(expr);
             }
         }
     }
 
-    fn emit_violation(&amp;mut self, expr: &amp;&#x27;a Expr) {
+    fn emit_violation(&amp;mut self, expr: &amp;Expr) {
         let range = expr.range();
         if self.reported_ranges.insert(range) {
-            self.violations.push(range);
+            self.checker
+                .report_diagnostic(MultipleYieldsInContextManager::new(self.name), range);
         }
     }
 
-    fn emit_multiple_violations(&amp;mut self, yields: &amp;[&amp;&#x27;a Expr]) {
+    fn emit_multiple_violations&lt;&#x27;e&gt;(&amp;mut self, yields: impl IntoIterator&lt;Item = &amp;&#x27;e &amp;&#x27;e Expr&gt;) {
         // The first yield conforms to the protocol
-        for &amp;yield_expr in yields.iter().skip(1) {
+        for yield_expr in yields.into_iter().skip(1) {
             self.emit_violation(yield_expr);
         }
     }
 
-    fn report_excess(&amp;mut self, yields: &amp;[&amp;&#x27;a Expr]) {
-        if yields.len() &gt; 1 {
-            self.emit_multiple_violations(yields);
-        }
-    }
-
     fn propagate_yields(&amp;mut self, yields: &amp;[&amp;&#x27;a Expr]) {
-        self.report_excess(yields);
-        let scope = self
-            .scopes
-            .last_mut()
-            .expect(&quot;Missing current scope for yield propagation&quot;);
         for &amp;yield_expr in yields {
-            scope.add_yield(yield_expr);
-        }
-        let yields_excessive = scope.yields_excessively();
-        let yield_exprs_clone = scope.yield_expressions.clone();
-        if yields_excessive {
-            self.emit_multiple_violations(&amp;yield_exprs_clone);
+            self.add_yield(yield_expr);
         }
     }
 
-    fn push_scope(&amp;mut self, scope: YieldScope&lt;&#x27;a&gt;) {
-        self.scopes.push(scope);
+    fn push_scope(&amp;mut self) {
+        self.scopes.push(YieldScope::new());
     }
 
     fn pop_scope(&amp;mut self) -&gt; Option&lt;(Vec&lt;&amp;&#x27;a Expr&gt;, bool)&gt; {
@@ -177,18 +154,11 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
             .map(|scope| (scope.yield_expressions, scope.does_return))
     }
 
-    fn clear_scope_yields(&amp;mut self) {
-        self.scopes
-            .last_mut()
-            .expect(&quot;Missing current scope for clearing yields&quot;)
-            .clear();
-    }
-
-    fn max_yields(branches: &amp;[Vec&lt;&amp;&#x27;a Expr&gt;]) -&gt; Vec&lt;&amp;&#x27;a Expr&gt; {
+    fn max_yields&lt;&#x27;v&gt;(branches: &amp;&#x27;v [Vec&lt;&amp;&#x27;a Expr&gt;]) -&gt; &amp;&#x27;v [&amp;&#x27;a Expr] {
         branches
             .iter()
             .max_by_key(|branch| branch.len())
-            .cloned()
+            .map(Vec::as_slice)
             .unwrap_or_default()
     }
 
@@ -200,7 +170,7 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
 
     fn handle_loop(&amp;mut self, body: &amp;&#x27;a [ast::Stmt], orelse: &amp;&#x27;a [ast::Stmt]) {
         self.visit_body(body);
-        self.push_scope(YieldScope::new());
+        self.push_scope();
         self.visit_body(orelse);
     }
 
@@ -220,7 +190,7 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
             let (except_yields, except_returns) = self
                 .pop_scope()
                 .expect(&quot;Missing except handler scope in try-statement&quot;);
-            self.report_excess(&amp;except_yields);
+            self.emit_multiple_violations(&amp;except_yields);
 
             if except_returns {
                 returning_except_branches.push(except_yields);
@@ -233,10 +203,6 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
             .pop_scope()
             .expect(&quot;Missing try block scope in try-statement&quot;);
 
-        self.report_excess(&amp;try_yields);
-        self.report_excess(&amp;else_yields);
-        self.report_excess(&amp;finally_yields);
-
         let path = TryExceptPath {
             try_yields,
             try_returns,
@@ -248,27 +214,14 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
         };
 
         if finally_returns {
-            self.handle_terminating_paths(&amp;path);
         } else {
             self.handle_continuing_paths(&amp;path);
         }
     }
 
-    // Finally returns - execution stops, report worst-case path
-    fn handle_terminating_paths(&amp;mut self, path: &amp;TryExceptPath&lt;&#x27;a&gt;) {
-        let except_yields = Self::get_max_except_path(path);
-        let base_path = Self::build_pre_finally_path(path, &amp;except_yields);
-        let max_path = Self::append_finally(&amp;base_path, &amp;path.finally_yields);
-
-        self.report_excess(&amp;max_path);
-        self.clear_scope_yields();
-    }
-
     // Finally doesn&#x27;t return - execution continues, handle all paths
     fn handle_continuing_paths(&amp;mut self, path: &amp;TryExceptPath&lt;&#x27;a&gt;) {
-        let (exception_return, exception_no_return) = Self::build_except_paths(path);
-
-        self.report_excess(&amp;exception_return);
+        let (_exception_return, exception_no_return) = Self::build_except_paths(path);
 
         let normal_path = Self::build_try_else_path(path);
 
@@ -276,60 +229,23 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
     }
 
     fn handle_exclusive_branches(&amp;mut self, branch_count: usize) {
-        let mut returning_branches = Vec::new();
         let mut continuing_branches = Vec::new();
 
         for _ in 0..branch_count {
             let (branch_yields, branch_returns) = self
                 .pop_scope()
                 .expect(&quot;Missing branch scope in if/match statement&quot;);
-            self.report_excess(&amp;branch_yields);
 
-            if branch_returns {
-                returning_branches.push(branch_yields);
-            } else {
+            if !branch_returns {
                 continuing_branches.push(branch_yields);
             }
         }
 
-        let max_returning = Self::max_yields(&amp;returning_branches);
         let max_continuing = Self::max_yields(&amp;continuing_branches);
 
-        self.report_excess(&amp;max_returning);
         self.propagate_yields(&amp;max_continuing);
     }
 
-    // Path building methods
-    // Find except handler with most yields
-    fn get_max_except_path(path: &amp;TryExceptPath&lt;&#x27;a&gt;) -&gt; Vec&lt;&amp;&#x27;a Expr&gt; {
-        let max_returning_except = Self::max_yields(&amp;path.returning_except_branches);
-        let max_continuing_except = Self::max_yields(&amp;path.continuing_except_branches);
-
-        if max_returning_except.len() &gt; max_continuing_except.len() {
-            max_returning_except
-        } else {
-            max_continuing_except
-        }
-    }
-
-    // Build path before finally: try + (else or except)
-    fn build_pre_finally_path(
-        path: &amp;TryExceptPath&lt;&#x27;a&gt;,
-        max_except_yields: &amp;[&amp;&#x27;a Expr],
-    ) -&gt; Vec&lt;&amp;&#x27;a Expr&gt; {
-        let mut common_path = path.try_yields.clone();
-
-        if !path.try_returns {
-            common_path.extend(if path.else_yields.len() &gt; max_except_yields.len() {
-                &amp;path.else_yields
-            } else {
-                max_except_yields
-            });
-        }
-
-        common_path
-    }
-
     // Build exception paths with finally appended
     fn build_except_paths(path: &amp;TryExceptPath&lt;&#x27;a&gt;) -&gt; (Vec&lt;&amp;&#x27;a Expr&gt;, Vec&lt;&amp;&#x27;a Expr&gt;) {
         let max_returning_except = Self::max_yields(&amp;path.returning_except_branches);
@@ -357,17 +273,15 @@ impl&lt;&#x27;a&gt; YieldTracker&lt;&#x27;a&gt; {
         exception_no_return: &amp;[&amp;&#x27;a Expr],
     ) {
         if path.try_returns {
-            let try_path = Self::append_finally(&amp;path.try_yields, &amp;path.finally_yields);
-            self.report_excess(&amp;try_path);
             self.propagate_yields(exception_no_return);
         } else if path.else_returns {
-            self.report_excess(normal_path);
+            self.emit_multiple_violations(normal_path);
             self.propagate_yields(exception_no_return);
         } else {
             let max_yield_path = if normal_path.len() &gt; exception_no_return.len() {
-                normal_path.to_vec()
+                normal_path
             } else {
-                exception_no_return.to_vec()
+                exception_no_return
             };
             self.propagate_yields(&amp;max_yield_path);
         }
@@ -397,24 +311,12 @@ impl&lt;&#x27;a&gt; YieldScope&lt;&#x27;a&gt; {
         }
     }
 
-    fn clear(&amp;mut self) {
-        self.yield_expressions.clear();
-    }
-
     fn yields_excessively(&amp;self) -&gt; bool {
         self.yield_expressions.len() &gt; 1
     }
-
-    fn add_yield(&amp;mut self, expr: &amp;&#x27;a Expr) {
-        self.yield_expressions.push(expr);
-    }
-
-    fn set_does_return(&amp;mut self, value: bool) {
-        self.does_return = value;
-    }
 }
 
-impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
+impl&lt;&#x27;a, &#x27;b&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a, &#x27;b&gt; {
     fn enter_node(&amp;mut self, node: AnyNodeRef&lt;&#x27;a&gt;) -&gt; source_order::TraversalSignal {
         match node {
             AnyNodeRef::StmtFor(_)
@@ -426,7 +328,7 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
                 // Track for primary control flow structures
                 // Optional branches like else/finally clauses are handled in leave_node
                 // Except is handled in leave node to maintain logical locality
-                self.push_scope(YieldScope::new());
+                self.push_scope();
             }
             _ =&gt; {}
         }
@@ -447,8 +349,7 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
                 self.handle_exclusive_branches(branch_count);
             }
             AnyNodeRef::StmtFor(_) | AnyNodeRef::StmtWhile(_) =&gt; {
-                let (else_yields, else_returns) =
-                    self.pop_scope().expect(&quot;Missing loop else scope&quot;);
+                let (else_yields, _) = self.pop_scope().expect(&quot;Missing loop else scope&quot;);
                 let (body_yields, _body_returns) =
                     self.pop_scope().expect(&quot;Missing loop body scope&quot;);
 
@@ -460,10 +361,6 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
                     }
                 }
                 self.propagate_yields(&amp;else_yields);
-                if else_returns {
-                    // If else returns, don&#x27;t propagate yield count
-                    self.clear_scope_yields();
-                }
             }
             _ =&gt; {}
         }
@@ -482,7 +379,7 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
         match stmt {
             ast::Stmt::Return(_) =&gt; {
                 if let Some(scope) = self.scopes.last_mut() {
-                    scope.set_does_return(true);
+                    scope.does_return = true;
                 }
             }
             ast::Stmt::FunctionDef(nested) =&gt; {
@@ -513,7 +410,7 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
                 if self.enter_node(node).is_traverse() {
                     self.visit_body(body);
                     for clause in elif_else_clauses {
-                        self.push_scope(YieldScope::new());
+                        self.push_scope();
                         self.visit_elif_else_clause(clause);
                     }
                     self.leave_node(node);
@@ -532,13 +429,13 @@ impl&lt;&#x27;a&gt; source_order::SourceOrderVisitor&lt;&#x27;a&gt; for YieldTracker&lt;&#x27;a&gt; {
                 if self.enter_node(node).is_traverse() {
                     self.visit_body(body);
                     for handler in handlers {
-                        self.push_scope(YieldScope::new());
+                        self.push_scope();
                         self.visit_except_handler(handler);
                     }
 
-                    self.push_scope(YieldScope::new());
+                    self.push_scope();
                     self.visit_body(orelse);
-                    self.push_scope(YieldScope::new());
+                    self.push_scope();
                     self.visit_body(finalbody);
                     self.leave_node(node);
                 }
</code></pre>


<p>My main thinking boils down to this: we&#x27;re already using the <code>Scope</code> pushing and popping to manage scopes, and we&#x27;re calling <code>add_yield</code> every time we encounter a <code>yield</code> expression, so it seems to me that we shouldn&#x27;t have to do any post-processing on the nodes, we just push a <code>yield</code> every time we encounter it and emit a diagnostic if we&#x27;ve already seen too many in this <code>Scope</code>. You can see this in my <code>add_yield</code> implementation in the patch, which I think you already had mostly the same version of, I just tried to use it a bit more aggressively, I think:</p>
<pre><code>    fn add_yield(&amp;mut self, expr: &amp;&#x27;a Expr) {
        if let Some(scope) = self.scopes.last_mut() {
            scope.yield_expressions.push(expr);
            if scope.yields_excessively() {
                self.emit_violation(expr);
            }
        }
    }
</code></pre>
<p>If we call this every time we encounter a <code>yield</code> expression, and we&#x27;ve set up our <code>Scope</code> stack correctly, won&#x27;t we automatically emit a violation in each of the correct places?</p>
<p>I could be wrong and just confused about all of the various <code>emit_*</code> and <code>handle_*</code> and <code>propagate</code> functions, but intuitively this is what I was expecting.</p>
<p>In any case, the code I deleted is not being tested, so we may need more extensive test coverage to make sure it&#x27;s actually needed.</p>
<p>I&#x27;m sorry to keep dragging this out, I was hoping to approve and merge this today. I&#x27;m happy to keep playing with the code until I convince myself it&#x27;s correct if I&#x27;m off base here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-28 12:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:184 on 2025-08-28 12:48</div>
            <div class="timeline-body"><p>There are some edge cases where we may need the scope clearing. For example</p>
<pre><code>@contextmanager
def test():
    for item in something():
        if condition(item):
            break
    else:
        yield 
        return
    yield
</code></pre>
<p>If we <code>break</code> then the <code>else</code> doesn&#x27;t execute and we need to clear the <code>yield</code> from the else branch to not further accumulate them. Otherwise we would get a false positive on the next one.</p>
<p>We did say earlier that we don&#x27;t want logic handling yields in loop bodies and heuristically assume them to happen multiple times. But I would argue that this here is a different case.</p>
<p>Applications for this pattern could be if we <a href="https://book.pythontips.com/en/latest/for_-_else.html#else-clause">search</a> for a specific item in <code>something()</code>.</p>
<p>We should definitely add a test case for this.</p>
<p>Note: we can get rid of the scope clearing after the <code>finally</code> block because that always executes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-08-28 12:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_linter/src/rules/ruff/rules/multiple_yields_contextmanager.rs</code>:184 on 2025-08-28 12:56</div>
            <div class="timeline-body"><p>Test added in <a href="https://github.com/astral-sh/ruff/pull/17281/commits/e0ba97b9f26f7f44573361e10a4c137e746502ef">e0ba97b</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-09-05 21:58</div>
            <div class="timeline-body"><p>Thank you, @ntBre , for being pedantic. I&#x27;m learning a lot here. Plus, in this case it wasn&#x27;t, I found edge cases this didn&#x27;t handle before. And it should definitely not be possible to delete core logic without tests breaking.</p>
<p>So what changed?</p>
<ul>
<li><strong>Removed Tracker / Reporter Seperation</strong>: Embedded <code>Checker</code> directly and removed intermediate <code>violations</code> storing</li>
<li><strong>Simplified scope management</strong>: Switched from tracking expression references to simple yield counts</li>
<li><strong>Reworked visitor logic</strong>: Now only relies on <code>visit_stmt</code> and <code>visit_expr</code>, removed complex path-building methods and ~170 lines while keeping parity in logic</li>
<li><strong>Added 18 more test cases</strong> including the loop-else-break scenario</li>
<li><strong>Fixed false positives</strong>: Now correctly ignores <code>yield</code>s in <code>lambda</code> and generators</li>
</ul>
<p>I think the complexity around <code>try-except</code> is warranted. Mainly due to the fact that <code>finally</code> executes even when previous <code>try</code> or <code>except</code> branches <code>return</code>. We need to keep track of this state to know if we should continue to accumulate <code>yields</code> after the finally or if the branch is guarded by a <code>return</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/ntBre">@ntBre</a> by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-09-05 21:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-10-19 18:55</div>
            <div class="timeline-body"><p>Ping @ntBre (No rush, just that this doesn&#x27;t get lost :) )</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:13:06 UTC
    </footer>
</body>
</html>
