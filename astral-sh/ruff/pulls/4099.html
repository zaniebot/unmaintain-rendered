<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Preserve whitespace around `ListComp` brackets in `C419` - astral-sh/ruff #4099</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Preserve whitespace around <code>ListComp</code> brackets in <code>C419</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/4099">#4099</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2023-04-25 19:18
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>While converting from a list comprehension to a generator expression, the square brackets are not preserved as that are only present on a list comprehension.</p>
<p>We&#x27;ll convert the brackets into a paren node and add it at the <em>end</em> and <em>start</em> of the left and right parens respectively.</p>
<p>fixes: #4094</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-04-25 19:26</div>
            <div class="timeline-body"><p>Hmm, wait this doesn&#x27;t look correct (missing the initial insta snapshot).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-04-25 19:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-04-25 19:36</div>
            <div class="timeline-body">PR Check Results
Ecosystem
<p>✅ ecosystem check detected no changes.</p>
Benchmark
Linux
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.00     14.1±0.05ms     2.9 MB/sec    1.00     14.1±0.07ms     2.9 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.4±0.01ms     4.9 MB/sec    1.00      3.4±0.01ms     4.9 MB/sec
linter/all-rules/numpy/globals.py          1.01    424.1±1.35µs     7.0 MB/sec    1.00    418.5±0.72µs     7.1 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.9±0.01ms     4.3 MB/sec    1.00      5.9±0.02ms     4.3 MB/sec
linter/default-rules/large/dataset.py      1.00      6.9±0.01ms     5.9 MB/sec    1.01      7.0±0.02ms     5.8 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.01  1502.7±21.51µs    11.1 MB/sec    1.00   1495.0±2.96µs    11.1 MB/sec
linter/default-rules/numpy/globals.py      1.00    167.1±0.23µs    17.7 MB/sec    1.01    168.3±0.32µs    17.5 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.1±0.00ms     8.2 MB/sec    1.00      3.1±0.01ms     8.2 MB/sec
parser/large/dataset.py                    1.00      5.4±0.00ms     7.5 MB/sec    1.00      5.4±0.00ms     7.5 MB/sec
parser/numpy/ctypeslib.py                  1.00   1056.0±0.63µs    15.8 MB/sec    1.00   1053.2±0.68µs    15.8 MB/sec
parser/numpy/globals.py                    1.01    107.1±0.65µs    27.6 MB/sec    1.00    106.4±0.34µs    27.7 MB/sec
parser/pydantic/types.py                   1.00      2.3±0.00ms    11.1 MB/sec    1.00      2.3±0.00ms    11.1 MB/sec
</code></pre>
Windows
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.01     18.0±0.32ms     2.3 MB/sec    1.00     17.8±0.42ms     2.3 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.4±0.10ms     3.8 MB/sec    1.00      4.4±0.14ms     3.8 MB/sec
linter/all-rules/numpy/globals.py          1.00   515.3±10.52µs     5.7 MB/sec    1.00   513.9±18.19µs     5.7 MB/sec
linter/all-rules/pydantic/types.py         1.00      7.5±0.16ms     3.4 MB/sec    1.01      7.5±0.20ms     3.4 MB/sec
linter/default-rules/large/dataset.py      1.03      9.1±0.33ms     4.5 MB/sec    1.00      8.8±0.21ms     4.6 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.03  1902.9±66.09µs     8.8 MB/sec    1.00  1856.2±51.47µs     9.0 MB/sec
linter/default-rules/numpy/globals.py      1.03   213.9±10.18µs    13.8 MB/sec    1.00   208.5±11.68µs    14.2 MB/sec
linter/default-rules/pydantic/types.py     1.00      4.0±0.11ms     6.4 MB/sec    1.00      4.0±0.12ms     6.4 MB/sec
parser/large/dataset.py                    1.00      6.8±0.10ms     6.0 MB/sec    1.01      6.8±0.12ms     5.9 MB/sec
parser/numpy/ctypeslib.py                  1.00  1309.1±44.54µs    12.7 MB/sec    1.01  1326.0±85.49µs    12.6 MB/sec
parser/numpy/globals.py                    1.03    137.6±8.45µs    21.4 MB/sec    1.00    134.2±4.65µs    22.0 MB/sec
parser/pydantic/types.py                   1.00      2.9±0.08ms     8.7 MB/sec    1.01      3.0±0.10ms     8.6 MB/sec
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-04-26 14:30</div>
            <div class="timeline-body"><p><em><strong>Context:</strong></em></p>
<blockquote>
<p>Ok, so it seems like we&#x27;re not copying over the <code>lbracket</code> and <code>rbracket</code> fields from the <code>ListComp</code> node. Now, this is a challenge as we need to convert it into a <code>GeneratorExp</code> which only has the <code>lpar</code> and <code>rpar</code> fields. We&#x27;ll need to pick the required parts from the Bracket nodes into the Parenthesis nodes.</p>
</blockquote>
<p>This seems a bit difficult but here are some of my ideas:</p>
<ol>
<li><p>Convert the <code>lbracket</code> and <code>rbracket</code> nodes into <code>LeftParen</code> and <code>RightParen</code>, then append and prepend it respectively to the generator&#x27;s <code>lpar</code> and <code>rpar</code> vectors. This means that there will an <a href="https://beta.ruff.rs/docs/rules/#pyupgrade-up">extraneous parenthesis</a> added. <strong>(Currently implemented)</strong></p>
<pre><code>any(
    [
    	i for i in range(10)  # comment
    ]
)

# Above will be converted to
any(
    (  # &lt;-- these are the extra parenthesis
    	i for i in range(10)  # comment
    )
)
</code></pre>
</li>
<li><p>Copy the <code>rbracket</code> into the <code>whitespace_after_arg</code> as that&#x27;s where it belongs and then append <em>only</em> the comment part from the <code>Comma</code> node as it is currently done so. If comma is not present, then the same comment belongs to <code>whitespace_after_arg</code> which means that the comment from <code>rbracket</code> will be prepended to it instead. This will be a special case as it&#x27;ll handle only this specific issue and ignore the comment from <code>lbracket</code>, if any.</p>
<pre><code>any(
    [
    	i for i in range(10)  # rbracket comment
    ]  # whitespace_after_arg comment (comma is absent)
)

# Above should be converted to
any(
    	i for i in range(10)  # rbracket comment # whitespace_after_arg comment (comma is absent)
)
</code></pre>
</li>
</ol>
<p>/cc @charliermarsh @MichaReiser your input would be appreciated :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-04-29 03:28</div>
            <div class="timeline-body"><p>I&#x27;ve read this a few times and keep finding myself undecided. I think adding extra parentheses is undesirable, so I&#x27;m leaning towards Option 2. What I don&#x27;t fully understand is the role on the comma in that logic -- how does it differ when the comment is present vs. absent?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-04-30 11:20</div>
            <div class="timeline-body"><blockquote>
<p>What I don&#x27;t fully understand is the role on the comma in that logic -- how does it differ when the comment is present vs. absent?</p>
</blockquote>
<p>Ok, so the <code>Arg</code> node contains the <code>comma</code> field which is optional and then there&#x27;s <code>whitespace_after_arg</code> as well. If the argument is not followed by the comma then the comment will be in <code>whitespace_after_arg</code> node otherwise it&#x27;ll be in the <code>comma</code> node.</p>
<p>https://github.com/Instagram/LibCST/blob/889ce56b0fcb9724ef980c7f2305d04f6bb7cd34/native/libcst/src/nodes/expression.rs#L321-L332</p>
<pre><code>all(
    [x.id for x in bar],  # comment
)

# vs

all(
	[x.id for x in bar]
)
</code></pre>
<p>The issue we&#x27;re facing is that the comment is in the <code>rbracket</code> node of <code>ListComp</code> node which, along with <code>lbracket</code> is being ignored (no brackets in generator expressions).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-01 09:44</div>
            <div class="timeline-body"><p>I&#x27;m unfamiliar with LibCST, and I&#x27;ve failed to find a clear definition of how libCST decides to attach trivia (to which node/property). So what I&#x27;m saying here may not make sense in the context of LibCST.</p>
<p>I prefer your second option, and you&#x27;re algorithm for copying the trivia makes sense to me. Do we need some logic for copying any trivia attached to the opening bracket too? What if it is a standalone comprehension or will this never trigger C419?</p>
<pre><code>[
		i for i in range(10)  # comment
]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-05-01 12:04</div>
            <div class="timeline-body"><blockquote>
<p>Do we need some logic for copying any trivia attached to the opening bracket too?</p>
</blockquote>
<p>I believe we should but I don&#x27;t see any use case for having a comment on the opening bracket (correct me if I&#x27;m wrong):</p>
<pre><code>any(
	[  # where would this comment be used?
		i.id for i in range(5)
	]
)

# If so, that should be converted to
any(
	i.id for i in range(5)  # where would this comment be used?
)
</code></pre>
<p>In case we want to support it, I believe it should be <em>added</em> or <em>appended</em> to the generator expression node as shown above.</p>
<p>And, in the worst case, if there are comments in all three places:</p>
<pre><code>any(
	[  # rbracket comment
		i.id for i in range(5)  # comprehension comment
	]  # lbracket comment
)

any(
	i.id for i in range(5)  # comprehension comment  # lbracket comment  # rbracket comment
)
</code></pre>
<p>One more thing to note is that <code>black</code> formats the way shown below. Note that there&#x27;s no comment at the opening bracket, if there was, then <code>black</code> wouldn&#x27;t format it.</p>
<pre><code>any(
    [
        i.id for i in range(5)  # comprehension comment
    ]  # lbracket comment
)

any([i.id for i in range(5)])  # comprehension comment  # lbracket comment
</code></pre>
<blockquote>
<p>What if it is a standalone comprehension or will this never trigger C419?</p>
</blockquote>
<p>This won&#x27;t be triggered for standalone comprehensions. The rule is only for <code>any</code> and <code>all</code> function calls with one argument.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-01 12:16</div>
            <div class="timeline-body"><blockquote>
<p>In case we want to support it, I believe it should be added or appended to the generator expression node as shown above.</p>
</blockquote>
<p>My take is that ruff should never remove any comments and we can either not provide a fix in that case or implement the proper placement.</p>
<blockquote>
<pre><code>any(
  [  # rbracket comment
      i.id for i in range(5)  # comprehension comment
  ]  # lbracket comment
)

any(
  i.id for i in range(5)  # comprehension comment  # lbracket comment  # rbracket comment
)
</code></pre>
</blockquote>
<p>I would prefer writing the <code>rbracket_comment</code> before the <code>lbracket_comment</code> to ensure comments maintain the same sequence as they had in the source document. This is important because the comment explanations may depend on their ordering. Or is that what you&#x27;re suggesting but you mixed up <code>rbracket</code> and <code>lbracket</code> in the source example?</p>
<p>What do you think of attaching the <code># bracket comment</code> to the whole comprehension expression?</p>
<pre><code># rbracket comment
i.id for i in range(5)  # comprehension comment
</code></pre>
<p>Are there any more edge cases, for example, when <code>[</code> or <code>]</code> has any leading comments:</p>
<pre><code>&gt; any(
&gt; 	# lbracket leading
&gt; 	[  # lbracket trailing
&gt; 		i.id for i in range(5)  # comprehension comment
&gt; 	# rbracket_leading
&gt; 	]  # rbracket trailing
&gt; )
</code></pre>
<p>Or is this not an issue because of how libCST represents comments?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-05-01 13:54</div>
            <div class="timeline-body"><p>Um wait, I think I switched the <code>lbracket</code> and <code>rbracket</code> notations in the code. Another mistake I made was that the &quot;comprehension comment&quot; belongs to <code>rbracket</code> node while the &quot;lbracket comment&quot; (which should be &quot;rbracket comment&quot;) belongs to <code>rpar</code> node (which is copied correctly).</p>
<p>So, <code>lbracket</code> contains the comment occurring <em>after</em> the token while <code>rbracket</code> contains the comment occurring <em>before</em> the token and it&#x27;s the same for parenthesis.</p>
<hr>
<blockquote>
<p>My take is that ruff should never remove any comments and we can either not provide a fix in that case or implement the proper placement.</p>
</blockquote>
<p>I agree on that. The problem is stemming from the fact that we&#x27;re <em>removing</em> the tokens (left and right brackets) which means that whatever trivia belonged to that token is being removed as well.</p>
<blockquote>
<p>I would prefer writing the <code>rbracket_comment</code> before the <code>lbracket_comment</code> to ensure comments maintain the same sequence as they had in the source document. This is important because the comment explanations may depend on their ordering. Or is that what you&#x27;re suggesting but you mixed up <code>rbracket</code> and <code>lbracket</code> in the source example?</p>
</blockquote>
<p>My first thought was that order wouldn&#x27;t matter as both would belong to the same line but I can understand your point of view.</p>
<blockquote>
<p>What do you think of attaching the <code># bracket comment</code> to the whole comprehension expression?</p>
</blockquote>
<p>Oh wait! This suggestion led me to another idea (thanks!): So, there&#x27;s another node in <code>libCST</code> which is <a href="https://github.com/Instagram/LibCST/blob/889ce56b0fcb9724ef980c7f2305d04f6bb7cd34/native/libcst/src/nodes/whitespace.rs#L84-L91"><code>EmptyNode</code></a> and this can be used to have a line with <em>only</em> a comment in it along with the correct indentation. I haven&#x27;t looked as to how to implement it, but this is what would happen:</p>
<pre><code>any(
    [  # lbracket comment
        i.bit_count() for i in range(5)  # rbracket comment
    ]  # rpar comment
)


any(
    # lbracket comment
        i.bit_count() for i in range(5)  # rbracket comment  # rpar comment
)
</code></pre>
<ol>
<li>The &quot;lbracket comment&quot; will be an <code>EmptyNode</code> which will be added to <code>whitespace_before_args</code>.</li>
<li>The &quot;rbracket comment&quot; will be added to <code>whitespace_after_args</code></li>
<li>Similarly, the &quot;rpar comment&quot; will be either be added or appended to <code>whitespace_after_args</code> depending on (2). Or do we want to keep this in it&#x27;s own line?</li>
</ol>
<p>What do you think?</p>
<blockquote>
<p>Or is this not an issue because of how libCST represents comments?</p>
</blockquote>
<p>This won&#x27;t be an issue as those belong with the parenthesis which are copied correctly over to the generator expression <strong>(line 1162, 1163)</strong>:</p>
<p>https://github.com/charliermarsh/ruff/blob/814731364afa995ae4a65da5e0dd85791a64b4c2/crates/ruff/src/rules/flake8_comprehensions/fixes.rs#L1159-L1164</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-02 01:05</div>
            <div class="timeline-body"><blockquote>
<p>My take is that ruff should never remove any comments and we can either not provide a fix in that case or implement the proper placement.</p>
</blockquote>
<p>Unfortunately we do remove comments in some situations. Ruff&#x27;s comment-handling for autofixes is &quot;best effort&quot; right now. In some cases, with complex expressions, we <em>do</em> skip the autofix entirely if comments are present, but it&#x27;s done on a case-by-case basis.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-02 07:28</div>
            <div class="timeline-body"><p>@dhruvmanila I&#x27;m really impressed by how carefully and thoughtfully you exercise the comment placement! It&#x27;s a joy to read your explanations.</p>
<blockquote>
<p>What do you think?</p>
</blockquote>
<p>I love it. That would match my expectations. I also thought about whether we want to keep the <code>#rpar comment</code> on its own line if the source contains a newline between the comprehension&#x27;s end and the <code>]</code> but I don&#x27;t think that&#x27;s necessary because the newline is only present because of the <code>(...)</code> wrapping of the comprehension.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-05-02 16:02</div>
            <div class="timeline-body"><blockquote>
<p>@dhruvmanila I&#x27;m really impressed by how carefully and thoughtfully you exercise the comment placement! It&#x27;s a joy to read your explanations.</p>
</blockquote>
<p>Thanks a lot for those kind words! I really appreciate it and also inspired by your detailed explanations :)</p>
<blockquote>
<p>I love it. That would match my expectations. I also thought about whether we want to keep the <code>#rpar comment</code> on its own line if the source contains a newline between the comprehension&#x27;s end and the <code>]</code> but I don&#x27;t think that&#x27;s necessary because the newline is only present because of the <code>(...)</code> wrapping of the comprehension.</p>
</blockquote>
<p>Got it. I&#x27;ll try to finish this by tonight.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-05-06 10:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/flake8_comprehensions/fixes.rs</code>:1168 on 2023-05-08 12:06</div>
            <div class="timeline-body"><p>I love these comments! Thank you so much for taking the time to write them. It makes reviewing (and reading the code in the future) so much easier.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-05-08 12:08</div>
            <div class="timeline-body"><p>Excellent</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-08 18:58</div>
            <div class="timeline-body"><p>Doesn&#x27;t need to block the merge here, but do we need to apply similar treatment to any of the other comprehension-transform rules?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-05-08 23:28</div>
            <div class="timeline-body"><blockquote>
<p>Doesn&#x27;t need to block the merge here, but do we need to apply similar treatment to any of the other comprehension-transform rules?</p>
</blockquote>
<p>I had the same thought, let me check. In general wherever the parenthesis or brackets are being dropped, that&#x27;s where this problem will occur.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-05-08 23:45</div>
            <div class="timeline-body"><p>I&#x27;ve provided a few examples but there will be a few more. As mentioned that whenever the parenthesis or brackets are being dropped, that&#x27;s where this will happen. It seems to be happening in most of comprehension fixes.</p>
<p>I believe we should have a generalized way of resolving this.</p>
<hr>
C404
<pre><code>dict(
    # first comment
    [
        # second comment
        (i, i)
        for i in range(3)
    ]
)

{
    # first comment
    i: i
        for i in range(3)
}
</code></pre>
C405
<pre><code>set(
    # some comment
    (1, 2)
)

{1, 2}
</code></pre>
C406
<pre><code>dict(
    # first comment
    [
        # second comment
        (1, 2)
    ]
)

{
    # first comment
    1: 2
}
</code></pre>
C409
<pre><code>tuple(
    # some comment
    [1, 2, 3, 4]
)

(1, 2, 3, 4)
</code></pre>
C410
<pre><code>list(
    # some comment
    [1, 2, 3, 4]
)

[1, 2, 3, 4]
</code></pre>
C411
<pre><code>list(
    # comment
    [i * i for i in x]
)

[i * i for i in x]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-09 06:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-05-09 06:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-05-13 16:39</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:53:23 UTC
    </footer>
</body>
</html>
