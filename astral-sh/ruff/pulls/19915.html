<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Represent `NamedTuple` as an opaque special form, not a class - astral-sh/ruff #19915</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Represent <code>NamedTuple</code> as an opaque special form, not a class</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19915">#19915</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-08-14 13:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body">Summary
<p>At runtime, <code>NamedTuple</code> is a function:</p>
<ul>
<li>It has attributes that are present on functions (but not on classes), such as <code>__kwdefaults__</code></li>
<li>It does not have attributes that are present on classes (but not on functions), such as <code>__mro__</code></li>
<li>It cannot appear in the MRO of any class</li>
<li>It is impossible to create an &quot;instance of <code>NamedTuple</code>&quot;</li>
<li>&quot;Inheriting from <code>NamedTuple</code>&quot; is actually just syntactic sugar for creating a tuple subclass that has a number of additional properties and methods monkey-patched onto it.</li>
</ul>
<p>Ty understands the last of these points: given the class definition <code>Point</code> here, we accurately infer that <code>Point</code> directly inherits from <code>tuple[int, int]</code> and does not have <code>NamedTuple</code> in its MRO:</p>
<pre><code>from typing import NamedTuple

class Point(NamedTuple):
    x: int
    y: int
</code></pre>
<p>However, it currently believes that <code>NamedTuple</code> is a class at runtime, due to the definition that typeshed gives in <code>typing.pyi</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/dc2e8ab3776a7f7ec9ec26be61939f73567a2c13/crates/ty_vendored/vendor/typeshed/stdlib/typing.pyi#L1734-L1775</p>
<p>I&#x27;ve <a href="https://discuss.python.org/t/removing-type-checker-internals-from-typeshed/87960/4">argued</a> elsewhere that the current typeshed definition for <code>NamedTuple</code> makes little sense and that it would be simpler for typeshed to describe <code>NamedTuple</code> as what it actually is at runtime: a function! Unfortunately, however, it&#x27;s hard to change the definition in typeshed at this point, as other type checkers rely on it being this way.</p>
<p>This PR therefore adds some special casing to our type inference logic so that if we see that a class definition is a class with the name <code>&quot;NamedTuple&quot;</code> and it comes from the module <code>typing</code> or the module <code>typing_extensions</code>, we override our usual type inference logic and infer <code>Type::SpecialForm(SpecialFormType::NamedTuple)</code> for the class instead of a <code>Type::ClassLiteral()</code> type. This allows us to add a bespoke error message if users try to use the function in a type expression (currently this does not work -- because we accurately do not infer any class as being a &quot;subclass of <code>NamedTuple</code>&quot; -- but we also do not emit a diagnostic for it, <a href="https://github.com/astral-sh/ty/issues/545#issuecomment-3186756638">causing confusion</a>). Attribute access on the new <code>SpecialFormType</code> variant falls back to attribute access on instances of <code>types.FunctionType</code>, meanwhile, staying true to the actual semantics that <code>typing.NamedTuple</code> has at runtime.</p>
Test Plan
<p>Mdtests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 13:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-14 13:46</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a>

Changes were detected when running ty on typing conformance tests

<pre><code>--- old-output.txt	2025-08-15 10:59:09.219027094 +0000
+++ new-output.txt	2025-08-15 10:59:09.287027633 +0000
@@ -1,5 +1,5 @@
 WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/918d35d/src/function/execute.rs:215:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(445b)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/918d35d/src/function/execute.rs:215:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(6244)): execute: too many cycle iterations`
 _directives_deprecated_library.py:15:31: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `int`
 _directives_deprecated_library.py:30:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `str`
 _directives_deprecated_library.py:36:41: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Self@__add__`
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-14 13:48</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>static-frame (https://github.com/static-frame/static-frame)
+ static_frame/core/quilt.py:866:46: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
+ static_frame/test/unit/test_quilt.py:2106:66: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 1777 diagnostics
+ Found 1779 diagnostics

</code></pre>

No memory usage changes detected ‚úÖ

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 16:53</div>
            <div class="timeline-body"><p>I think you are technically correct here, but I&#x27;m a bit worried about being strict about this, because apparently both <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=d87a730220ffcefe63d4cb81203fb70a">mypy</a> and <a href="https://pyright-play.net/?strict=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoByAhhAKYAmAKgK4IA2pANFEQM6ul4D68CpAsACghAYzptWUAIIAKYmSq0GASgBcQqJqgoSpVVFYwQQoeVLAowANqV98ijXqkAujIAe%2BysqgBaAHxQthpaIKQw1CAoUG4mgkREUAC8sjpkiQBEAFJgABYo6cpCoEmWMvGFgkA">pyright</a> allow it. (By which I mean, using <code>NamedTuple</code> as a type annotation and allowing instances of classes created with <code>NamedTuple</code> to be assignable to it.) If people are used to this working, is it a battle we want to fight?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:08</div>
            <div class="timeline-body"><p>Well, here are some options I can think of:</p>
<ol>
<li><p>Do nothing; leave things as they are on <code>main</code>. The current situation on <code>main</code> is that we think <code>NamedTuple</code> is a class (and therefore it&#x27;s valid in type expressions), but we essentially see it as an &quot;uninhabited type&quot;. No instance of a <code>NamedTuple</code> type is currently considered an instance of <code>NamedTuple</code> by ty, because we accurately emulate the behaviour of <code>NamedTuple.__mro_entries__</code> where it&#x27;s swapped out with <code>tuple</code> in a class&#x27;s MRO.</p>
<p>I don&#x27;t think just leaving things as they are is a realistic option TBH; users are <a href="https://github.com/astral-sh/ty/issues/545#issuecomment-3186756638">already complaining</a> that they find it confusing.</p>
</li>
<li><p>Pretend that <code>NamedTuple</code> classes actually do have <code>NamedTuple</code> in their MROs? That... might be possible? I&#x27;d really rather not, though: <code>NamedTuple</code> in typeshed inherits from <code>tuple[Any, ...]</code>, so I think this is going to really complicate inferring the correct tuple spec of <code>NamedTuple</code> classes.</p>
</li>
<li><p>Attempt to emulate the runtime semantics as accurately as possible: that&#x27;s what this PR tries to do; but, as you say, it&#x27;s another incompatibility with existing type checkers.</p>
</li>
<li><p>Allow <code>NamedTuple</code> in type expressions, <em>but</em> instead of treating it as a nominal class (what typeshed says) or a function (what it actually is at runtime), treat it as some kind of synthesized protocol that has a <code>_make</code> method and a <code>_replace</code> method (etc.), such that all <code>NamedTuple</code> classes are considered subtypes of it even though <code>NamedTuple</code> doesn&#x27;t actually exist in their MROs</p>
</li>
</ol>
<p>I could try (4)? It might be interesting. It does feel like something of an elaborate hack in the name of compatibility, but maybe that&#x27;s worth it.</p>
<p>FWIW, the long-term plan at typeshed is to replace the current <code>NamedTuple</code> class definition with a <code>NamedTuple</code> function definition, as outlined in https://discuss.python.org/t/removing-type-checker-internals-from-typeshed/87960. But if I&#x27;m being honest about it, it&#x27;s probably more of a &quot;wish&quot; than a plan; I&#x27;ve yet to see any evidence that the mypy maintainers are interested in adjusting their internals to account for that change, and it would obviously be a backwards compatibility break for them too since users have (apparently!) gotten used to using <code>NamedTuple</code> in type annotations. So I don&#x27;t know when that typeshed change would actually happen; probably not any time soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 19:17</div>
            <div class="timeline-body"><p>Yes, I agree that (1) is not a good option.</p>
<p>I wonder what other type checkers are doing here? I suspect it&#x27;s not (4) -- it&#x27;s probably some version of (2)?</p>
<p>I feel like there&#x27;s another possibility here, where we get effectively the same semantics as (2) or (4), but just via a new Type variant instead (created by use of <code>NamedTuple</code> in a type expression, representing &quot;super-type of all classes created via <code>NamedTuple</code>&quot;), which is special-cased (since I think we can rather easily internally mark classes created via NamedTuple), rather than via a Protocol, and without actually messing with the MRO of NamedTuples.</p>
<p>(I think the additional semantics of (4) where you could make your own subtype of <code>NamedTuple</code> by just providing the right methods, is probably undesirable if we have a choice, though it may not matter in practice.)</p>
<p>Ultimately I think we do need to support this in some form. That is, I don&#x27;t think (3) alone is a workable option either, although I do think some of this PR could still make sense, just so we understand the value-type of <code>NamedTuple</code>, its attributes etc, more accurately.</p>
<p>I&#x27;m pretty sure I recall that mypy used to not support <code>NamedTuple</code> as an annotation, for all the sensible reasons discussed here, and eventually changed that approach based on user feedback. To me that&#x27;s pretty strong signal that we don&#x27;t want to break compatibility here without a really good reason.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:27</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;m pretty sure I recall that mypy used to not support <code>NamedTuple</code> as an annotation, for all the sensible reasons discussed here, and eventually changed that approach based on user feedback. To me that&#x27;s pretty strong signal that we don&#x27;t want to break compatibility here without a really good reason.</p>
</blockquote>
<p>Hmm, really? That happened before I &quot;entered the scene&quot;, if so üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 19:36</div>
            <div class="timeline-body"><p>It happened in late 2021, in <a href="https://github.com/python/mypy/pull/11162">python/mypy#11162</a>, but it doesn&#x27;t look like there was a lot of user feedback there, just one user report that Nikita agreed with, and convinced Jelle and Jukka to merge it :) I do feel like I remember an earlier issue about it with more discussion, but not finding that at the moment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 19:38</div>
            <div class="timeline-body"><blockquote>
<p>(I think the additional semantics of (4) where you could make your own subtype of <code>NamedTuple</code> by just providing the right methods, is probably undesirable if we have a choice, though it may not matter in practice.)</p>
</blockquote>
<p>This is arguable, I guess -- if the main purpose of such an annotation is that it lets you write code that generically introspects NamedTuples, then a Protocol (that can also be satisfied by a manually constructed class) seems like a pretty sensible implementation?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:48</div>
            <div class="timeline-body"><p>Looks like some previous discussion was at <a href="https://github.com/python/typing/issues/431">python/typing#431</a> prior to that mypy PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:55</div>
            <div class="timeline-body"><p>Here&#x27;s the section in <a href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#named-tuples">the mypy docs</a> describing this feature...</p>
<blockquote>
<p>You can use the raw NamedTuple ‚Äúpseudo-class‚Äù in type annotations if any NamedTuple object is valid.</p>
<p>For example, it can be useful for deserialization:</p>
<pre><code>def deserialize_named_tuple(arg: NamedTuple) -&gt; Dict[str, Any]:
    return arg._asdict()

Point = namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])
Person = NamedTuple(&#x27;Person&#x27;, [(&#x27;name&#x27;, str), (&#x27;age&#x27;, int)])

deserialize_named_tuple(Point(x=1, y=2))  # ok
deserialize_named_tuple(Person(name=&#x27;Nikita&#x27;, age=18))  # ok

# Error: Argument 1 to &quot;deserialize_named_tuple&quot; has incompatible type
# &quot;Tuple[int, int]&quot;; expected &quot;NamedTuple&quot;
deserialize_named_tuple((1, 2))
</code></pre>
<p>Note that this behavior is highly experimental, non-standard, and may not be supported by other type checkers and IDEs.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 20:14</div>
            <div class="timeline-body"><p>Found the thread I was thinking of: <a href="https://github.com/python/mypy/issues/3915">python/mypy#3915</a></p>
<p>Complete with comments from both you and I üòÜ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 21:41</div>
            <div class="timeline-body"><p>Here&#x27;s my best attempt at a protocol that all <code>NamedTuple</code> types would be assignable to -- we could stick something like this in <code>ty_extensions</code> and say that <code>NamedTuple</code> in a type expression should be understood as referring to this type:</p>
<pre><code>import sys
from typing import Reversible, Iterable, Collection, SupportsIndex, Protocol, overload, ClassVar, Any, Self

class NamedTuplesque(Reversible[object], Collection[object], Protocol):
    # from typing.NamedTuple stub
    _field_defaults: ClassVar[dict[str, Any]]
    _fields: ClassVar[tuple[str, ...]]
    @classmethod
    def _make(self: Self, iterable: Iterable[Any]) -&gt; Self: ...
    def _asdict(self, /) -&gt; dict[str, Any]: ...
    def _replace(self: Self, /, **kwargs) -&gt; Self: ...
    if sys.version_info &gt;= (3, 13):
        def __replace__(self: Self, **kwargs) -&gt; Self: ...
    
    # from Sequence stub
    @overload
    def __getitem__(self, index: int, /) -&gt; object: ...
    @overload
    def __getitem__(self, index: slice, /) -&gt; tuple[object, ...]: ...
    def index(self, value, start: int = 0, stop: int = ..., /) -&gt; int: ...
    def count(self, value, /) -&gt; int: ...
    
    # from tuple stub
    def __add__(self, value: tuple[Any, ...], /) -&gt; tuple[object, ...]: ...
    def __mul__(self, value: SupportsIndex, /) -&gt; tuple[object, ...]: ...
    def __rmul__(self, value: SupportsIndex, /) -&gt; tuple[object, ...]: ...
    def __hash__(self, /) -&gt; int: ...
</code></pre>
<p>We seem to do pretty well at recognising that <code>NamedTuple</code> types are assignable to this protocol (at least with our current, basic protocol implementation): https://play.ty.dev/5435f316-bd88-4dfb-b5d0-9e8ece0c3a6c.</p>
<p>But the stub there is complicated enough that it honestly might be less of a maintenance burden to just add a new <code>Type</code> variant, like you suggest...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 00:00</div>
            <div class="timeline-body"><p>I guess there&#x27;s some redundancy with <code>NamedTupleFallback</code> here? At the very least this protocol and <code>NamedTupleFallback</code> should stay consistent with each other.</p>
<p>It seems like if we use a dedicated <code>Type</code> variant, we still have to maintain the equivalent of this protocol as special-cased synthesized attributes on the <code>Type</code> variant, right? So not sure there&#x27;s much of an advantage either way in terms of maintainability.</p>
<p>Seems like you did the hardest part already by writing the protocol; sticking it in <code>ty_extensions</code> and inferring it in <code>in_type_expression</code> seems pretty simple! I&#x27;d say let&#x27;s just do that. Ideally in the future we could get it into typeshed; that&#x27;s really where it belongs.</p>
<p>Nit: we could name it <code>NamedTupleLike</code> to parallel the existing <code>DataclassLike</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 09:55</div>
            <div class="timeline-body"><blockquote>
<p>I guess there&#x27;s some redundancy with <code>NamedTupleFallback</code> here? At the very least this protocol and <code>NamedTupleFallback</code> should stay consistent with each other.</p>
</blockquote>
<p>Yes -- possibly <code>NamedTupleFallback</code> in typeshed should actually just be this protocol? Not sure how motivated I feel to try to push that change through, though üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 09:57</div>
            <div class="timeline-body"><blockquote>
<p>Seems like you did the hardest part already by writing the protocol; sticking it in <code>ty_extensions</code> and inferring it in <code>in_type_expression</code> seems pretty simple! I&#x27;d say let&#x27;s just do that. Ideally in the future we could get it into typeshed; that&#x27;s really where it belongs.</p>
</blockquote>
<p>I still feel like the &quot;right&quot; thing to do is to ban it in type expressions entirely, especially since the mypy docs explicitly call out that their feature is</p>
<blockquote>
<p>highly experimental, non-standard, and may not be supported by other type checkers and IDEs.</p>
</blockquote>
<p>But the discussions you&#x27;ve linked to are pretty persuasive that users &quot;expect&quot; it to work in type expressions like a protocol type, and compatibility with other type checkers is obviously valuable. So I&#x27;ll make the change üôÉ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 10:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-15 10:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:249 on 2025-08-15 10:45</div>
            <div class="timeline-body"><p>this is kinda weird but it&#x27;s the logical conclusion of this strategy üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 10:50</div>
            <div class="timeline-body"><p>The primer report is now much less dramatic for the revised version of the PR. We now just have two diagnostics going away in static-frame because we now have a better understanding of the code patterns they&#x27;re using that are supposed to work with any <code>NamedTuple</code> type.</p>
<p>The initial attempt to use a protocol type resulted in one new diagnostic being added in django-stubs, because we did not see <code>NamedTupleLike</code> as a subtype of <code>tuple[Any, ...]</code> -- that&#x27;s impossible if we use a protocol here, since the only fully static nominal type a protocol can ever be a subtype of is <code>object</code>:</p>
<blockquote>
<pre><code>django-stubs (https://github.com/typeddjango/django-stubs)
+ django-stubs/db/models/query.pyi:40:31: error[invalid-argument-type] Argument to class `ValuesListIterable` is incorrect: Expected `tuple[Any, ...]`, found `NamedTupleLike`
- Found 442 diagnostics
+ Found 443 diagnostics
</code></pre>
</blockquote>
<p>I&#x27;ve since removed that diagnostic by making the protocol in <code>ty_extensions</code> more minimal, and saying that <code>NamedTuple</code> does not actually mean <code>NamedTupleLike</code> when it occurs in a type expression -- it <em>actually</em> means <code>tuple[object, ...] &amp; NamedTupleLike</code>. This seems to solve all problems...!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jelle-openai">@jelle-openai</a> on 2025-08-15 16:57</div>
            <div class="timeline-body"><blockquote>
<p>convinced Jelle and Jukka to merge</p>
</blockquote>
<p>For the record I&#x27;m still not convinced this was a good idea. <a href="https://github.com/python/mypy/pull/11162">python/mypy#11162</a>#discussion_r713485175</p>
<p>But it seems the approach you came up with in this PR is reasonable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 17:05</div>
            <div class="timeline-body"><blockquote>
<p>For the record I&#x27;m still not convinced this was a good idea. <a href="https://github.com/python/mypy/pull/11162#discussion_r713485175">python/mypy#11162 (comment)</a></p>
</blockquote>
<p>If you&#x27;d pushed back harder back then, we wouldn&#x27;t be in this situation now üòÜ</p>
<p>Seriously though, this feature doesn&#x27;t bother me much. I feel like &quot;having a protocol for NamedTuple-created classes&quot; makes sense and has good use cases, and having that protocol maintained in a shared place rather than by every individual user also makes sense to me. So really the only &quot;questionable&quot; thing here is having the special form <code>typing.NamedTuple</code> mean that protocol in a type expression. I grant that&#x27;s a bit weird, and the principled thing would be just to name the protocol directly. But special forms mean all kinds of weird things in type expressions; this one seems pretty intuitive and harmless to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-08-15 17:14</div>
            <div class="timeline-body"><p>Looks good to me, thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 17:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 17:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-08-15 17:20</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:17:43 UTC
    </footer>
</body>
</html>
