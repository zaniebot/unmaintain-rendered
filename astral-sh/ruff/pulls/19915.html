<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Represent `NamedTuple` as an opaque special form, not a class - astral-sh/ruff #19915</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Represent <code>NamedTuple</code> as an opaque special form, not a class</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19915">#19915</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-08-14 13:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>At runtime, <code>NamedTuple</code> is a function:</p>
<ul>
<li>It has attributes that are present on functions (but not on classes), such as <code>__kwdefaults__</code></li>
<li>It does not have attributes that are present on classes (but not on functions), such as <code>__mro__</code></li>
<li>It cannot appear in the MRO of any class</li>
<li>It is impossible to create an &quot;instance of <code>NamedTuple</code>&quot;</li>
<li>&quot;Inheriting from <code>NamedTuple</code>&quot; is actually just syntactic sugar for creating a tuple subclass that has a number of additional properties and methods monkey-patched onto it.</li>
</ul>
<p>Ty understands the last of these points: given the class definition <code>Point</code> here, we accurately infer that <code>Point</code> directly inherits from <code>tuple[int, int]</code> and does not have <code>NamedTuple</code> in its MRO:</p>
<pre><code class="language-py">from typing import NamedTuple

class Point(NamedTuple):
    x: int
    y: int
</code></pre>
<p>However, it currently believes that <code>NamedTuple</code> is a class at runtime, due to the definition that typeshed gives in <code>typing.pyi</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/dc2e8ab3776a7f7ec9ec26be61939f73567a2c13/crates/ty_vendored/vendor/typeshed/stdlib/typing.pyi#L1734-L1775</p>
<p>I've <a href="https://discuss.python.org/t/removing-type-checker-internals-from-typeshed/87960/4">argued</a> elsewhere that the current typeshed definition for <code>NamedTuple</code> makes little sense and that it would be simpler for typeshed to describe <code>NamedTuple</code> as what it actually is at runtime: a function! Unfortunately, however, it's hard to change the definition in typeshed at this point, as other type checkers rely on it being this way.</p>
<p>This PR therefore adds some special casing to our type inference logic so that if we see that a class definition is a class with the name <code>&quot;NamedTuple&quot;</code> and it comes from the module <code>typing</code> or the module <code>typing_extensions</code>, we override our usual type inference logic and infer <code>Type::SpecialForm(SpecialFormType::NamedTuple)</code> for the class instead of a <code>Type::ClassLiteral()</code> type. This allows us to add a bespoke error message if users try to use the function in a type expression (currently this does not work -- because we accurately do not infer any class as being a &quot;subclass of <code>NamedTuple</code>&quot; -- but we also do not emit a diagnostic for it, <a href="https://github.com/astral-sh/ty/issues/545#issuecomment-3186756638">causing confusion</a>). Attribute access on the new <code>SpecialFormType</code> variant falls back to attribute access on instances of <code>types.FunctionType</code>, meanwhile, staying true to the actual semantics that <code>typing.NamedTuple</code> has at runtime.</p>
<h2>Test Plan</h2>
<p>Mdtests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-08-14 13:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-14 13:46</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-08-15 10:59:09.219027094 +0000
+++ new-output.txt	2025-08-15 10:59:09.287027633 +0000
@@ -1,5 +1,5 @@
 WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/918d35d/src/function/execute.rs:215:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(445b)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/918d35d/src/function/execute.rs:215:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(6244)): execute: too many cycle iterations`
 _directives_deprecated_library.py:15:31: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `int`
 _directives_deprecated_library.py:30:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `str`
 _directives_deprecated_library.py:36:41: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Self@__add__`
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-14 13:48</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">static-frame (https://github.com/static-frame/static-frame)
+ static_frame/core/quilt.py:866:46: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
+ static_frame/test/unit/test_quilt.py:2106:66: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 1777 diagnostics
+ Found 1779 diagnostics

</code></pre>
</details>
No memory usage changes detected ‚úÖ

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2025-08-14 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 16:53</div>
            <div class="timeline-body"><p>I think you are technically correct here, but I'm a bit worried about being strict about this, because apparently both <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=d87a730220ffcefe63d4cb81203fb70a">mypy</a> and <a href="https://pyright-play.net/?strict=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoByAhhAKYAmAKgK4IA2pANFEQM6ul4D68CpAsACghAYzptWUAIIAKYmSq0GASgBcQqJqgoSpVVFYwQQoeVLAowANqV98ijXqkAujIAe%2BysqgBaAHxQthpaIKQw1CAoUG4mgkREUAC8sjpkiQBEAFJgABYo6cpCoEmWMvGFgkA">pyright</a> allow it. (By which I mean, using <code>NamedTuple</code> as a type annotation and allowing instances of classes created with <code>NamedTuple</code> to be assignable to it.) If people are used to this working, is it a battle we want to fight?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:08</div>
            <div class="timeline-body"><p>Well, here are some options I can think of:</p>
<ol>
<li><p>Do nothing; leave things as they are on <code>main</code>. The current situation on <code>main</code> is that we think <code>NamedTuple</code> is a class (and therefore it's valid in type expressions), but we essentially see it as an &quot;uninhabited type&quot;. No instance of a <code>NamedTuple</code> type is currently considered an instance of <code>NamedTuple</code> by ty, because we accurately emulate the behaviour of <code>NamedTuple.__mro_entries__</code> where it's swapped out with <code>tuple</code> in a class's MRO.</p>
<p>I don't think just leaving things as they are is a realistic option TBH; users are <a href="https://github.com/astral-sh/ty/issues/545#issuecomment-3186756638">already complaining</a> that they find it confusing.</p>
</li>
<li><p>Pretend that <code>NamedTuple</code> classes actually do have <code>NamedTuple</code> in their MROs? That... might be possible? I'd really rather not, though: <code>NamedTuple</code> in typeshed inherits from <code>tuple[Any, ...]</code>, so I think this is going to really complicate inferring the correct tuple spec of <code>NamedTuple</code> classes.</p>
</li>
<li><p>Attempt to emulate the runtime semantics as accurately as possible: that's what this PR tries to do; but, as you say, it's another incompatibility with existing type checkers.</p>
</li>
<li><p>Allow <code>NamedTuple</code> in type expressions, <em>but</em> instead of treating it as a nominal class (what typeshed says) or a function (what it actually is at runtime), treat it as some kind of synthesized protocol that has a <code>_make</code> method and a <code>_replace</code> method (etc.), such that all <code>NamedTuple</code> classes are considered subtypes of it even though <code>NamedTuple</code> doesn't actually exist in their MROs</p>
</li>
</ol>
<p>I could try (4)? It might be interesting. It does feel like something of an elaborate hack in the name of compatibility, but maybe that's worth it.</p>
<p>FWIW, the long-term plan at typeshed is to replace the current <code>NamedTuple</code> class definition with a <code>NamedTuple</code> function definition, as outlined in https://discuss.python.org/t/removing-type-checker-internals-from-typeshed/87960. But if I'm being honest about it, it's probably more of a &quot;wish&quot; than a plan; I've yet to see any evidence that the mypy maintainers are interested in adjusting their internals to account for that change, and it would obviously be a backwards compatibility break for them too since users have (apparently!) gotten used to using <code>NamedTuple</code> in type annotations. So I don't know when that typeshed change would actually happen; probably not any time soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 19:17</div>
            <div class="timeline-body"><p>Yes, I agree that (1) is not a good option.</p>
<p>I wonder what other type checkers are doing here? I suspect it's not (4) -- it's probably some version of (2)?</p>
<p>I feel like there's another possibility here, where we get effectively the same semantics as (2) or (4), but just via a new Type variant instead (created by use of <code>NamedTuple</code> in a type expression, representing &quot;super-type of all classes created via <code>NamedTuple</code>&quot;), which is special-cased (since I think we can rather easily internally mark classes created via NamedTuple), rather than via a Protocol, and without actually messing with the MRO of NamedTuples.</p>
<p>(I think the additional semantics of (4) where you could make your own subtype of <code>NamedTuple</code> by just providing the right methods, is probably undesirable if we have a choice, though it may not matter in practice.)</p>
<p>Ultimately I think we do need to support this in some form. That is, I don't think (3) alone is a workable option either, although I do think some of this PR could still make sense, just so we understand the value-type of <code>NamedTuple</code>, its attributes etc, more accurately.</p>
<p>I'm pretty sure I recall that mypy used to not support <code>NamedTuple</code> as an annotation, for all the sensible reasons discussed here, and eventually changed that approach based on user feedback. To me that's pretty strong signal that we don't want to break compatibility here without a really good reason.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:27</div>
            <div class="timeline-body"><blockquote>
<p>I'm pretty sure I recall that mypy used to not support <code>NamedTuple</code> as an annotation, for all the sensible reasons discussed here, and eventually changed that approach based on user feedback. To me that's pretty strong signal that we don't want to break compatibility here without a really good reason.</p>
</blockquote>
<p>Hmm, really? That happened before I &quot;entered the scene&quot;, if so üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 19:36</div>
            <div class="timeline-body"><p>It happened in late 2021, in https://github.com/python/mypy/pull/11162, but it doesn't look like there was a lot of user feedback there, just one user report that Nikita agreed with, and convinced Jelle and Jukka to merge it :) I do feel like I remember an earlier issue about it with more discussion, but not finding that at the moment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 19:38</div>
            <div class="timeline-body"><blockquote>
<p>(I think the additional semantics of (4) where you could make your own subtype of <code>NamedTuple</code> by just providing the right methods, is probably undesirable if we have a choice, though it may not matter in practice.)</p>
</blockquote>
<p>This is arguable, I guess -- if the main purpose of such an annotation is that it lets you write code that generically introspects NamedTuples, then a Protocol (that can also be satisfied by a manually constructed class) seems like a pretty sensible implementation?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:48</div>
            <div class="timeline-body"><p>Looks like some previous discussion was at https://github.com/python/typing/issues/431 prior to that mypy PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 19:55</div>
            <div class="timeline-body"><p>Here's the section in <a href="https://mypy.readthedocs.io/en/stable/kinds_of_types.html#named-tuples">the mypy docs</a> describing this feature...</p>
<blockquote>
<p>You can use the raw NamedTuple ‚Äúpseudo-class‚Äù in type annotations if any NamedTuple object is valid.</p>
<p>For example, it can be useful for deserialization:</p>
<pre><code class="language-py">def deserialize_named_tuple(arg: NamedTuple) -&gt; Dict[str, Any]:
    return arg._asdict()

Point = namedtuple('Point', ['x', 'y'])
Person = NamedTuple('Person', [('name', str), ('age', int)])

deserialize_named_tuple(Point(x=1, y=2))  # ok
deserialize_named_tuple(Person(name='Nikita', age=18))  # ok

# Error: Argument 1 to &quot;deserialize_named_tuple&quot; has incompatible type
# &quot;Tuple[int, int]&quot;; expected &quot;NamedTuple&quot;
deserialize_named_tuple((1, 2))
</code></pre>
<p>Note that this behavior is highly experimental, non-standard, and may not be supported by other type checkers and IDEs.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-14 20:14</div>
            <div class="timeline-body"><p>Found the thread I was thinking of: https://github.com/python/mypy/issues/3915</p>
<p>Complete with comments from both you and I üòÜ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-14 21:41</div>
            <div class="timeline-body"><p>Here's my best attempt at a protocol that all <code>NamedTuple</code> types would be assignable to -- we could stick something like this in <code>ty_extensions</code> and say that <code>NamedTuple</code> in a type expression should be understood as referring to this type:</p>
<pre><code class="language-py">import sys
from typing import Reversible, Iterable, Collection, SupportsIndex, Protocol, overload, ClassVar, Any, Self

class NamedTuplesque(Reversible[object], Collection[object], Protocol):
    # from typing.NamedTuple stub
    _field_defaults: ClassVar[dict[str, Any]]
    _fields: ClassVar[tuple[str, ...]]
    @classmethod
    def _make(self: Self, iterable: Iterable[Any]) -&gt; Self: ...
    def _asdict(self, /) -&gt; dict[str, Any]: ...
    def _replace(self: Self, /, **kwargs) -&gt; Self: ...
    if sys.version_info &gt;= (3, 13):
        def __replace__(self: Self, **kwargs) -&gt; Self: ...
    
    # from Sequence stub
    @overload
    def __getitem__(self, index: int, /) -&gt; object: ...
    @overload
    def __getitem__(self, index: slice, /) -&gt; tuple[object, ...]: ...
    def index(self, value, start: int = 0, stop: int = ..., /) -&gt; int: ...
    def count(self, value, /) -&gt; int: ...
    
    # from tuple stub
    def __add__(self, value: tuple[Any, ...], /) -&gt; tuple[object, ...]: ...
    def __mul__(self, value: SupportsIndex, /) -&gt; tuple[object, ...]: ...
    def __rmul__(self, value: SupportsIndex, /) -&gt; tuple[object, ...]: ...
    def __hash__(self, /) -&gt; int: ...
</code></pre>
<p>We seem to do pretty well at recognising that <code>NamedTuple</code> types are assignable to this protocol (at least with our current, basic protocol implementation): https://play.ty.dev/5435f316-bd88-4dfb-b5d0-9e8ece0c3a6c.</p>
<p>But the stub there is complicated enough that it honestly might be less of a maintenance burden to just add a new <code>Type</code> variant, like you suggest...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 00:00</div>
            <div class="timeline-body"><p>I guess there's some redundancy with <code>NamedTupleFallback</code> here? At the very least this protocol and <code>NamedTupleFallback</code> should stay consistent with each other.</p>
<p>It seems like if we use a dedicated <code>Type</code> variant, we still have to maintain the equivalent of this protocol as special-cased synthesized attributes on the <code>Type</code> variant, right? So not sure there's much of an advantage either way in terms of maintainability.</p>
<p>Seems like you did the hardest part already by writing the protocol; sticking it in <code>ty_extensions</code> and inferring it in <code>in_type_expression</code> seems pretty simple! I'd say let's just do that. Ideally in the future we could get it into typeshed; that's really where it belongs.</p>
<p>Nit: we could name it <code>NamedTupleLike</code> to parallel the existing <code>DataclassLike</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 09:55</div>
            <div class="timeline-body"><blockquote>
<p>I guess there's some redundancy with <code>NamedTupleFallback</code> here? At the very least this protocol and <code>NamedTupleFallback</code> should stay consistent with each other.</p>
</blockquote>
<p>Yes -- possibly <code>NamedTupleFallback</code> in typeshed should actually just be this protocol? Not sure how motivated I feel to try to push that change through, though üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 09:57</div>
            <div class="timeline-body"><blockquote>
<p>Seems like you did the hardest part already by writing the protocol; sticking it in <code>ty_extensions</code> and inferring it in <code>in_type_expression</code> seems pretty simple! I'd say let's just do that. Ideally in the future we could get it into typeshed; that's really where it belongs.</p>
</blockquote>
<p>I still feel like the &quot;right&quot; thing to do is to ban it in type expressions entirely, especially since the mypy docs explicitly call out that their feature is</p>
<blockquote>
<p>highly experimental, non-standard, and may not be supported by other type checkers and IDEs.</p>
</blockquote>
<p>But the discussions you've linked to are pretty persuasive that users &quot;expect&quot; it to work in type expressions like a protocol type, and compatibility with other type checkers is obviously valuable. So I'll make the change üôÉ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2025-08-15 10:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-08-15 10:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:249 on 2025-08-15 10:45</div>
            <div class="timeline-body"><p>this is kinda weird but it's the logical conclusion of this strategy üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-15 10:50</div>
            <div class="timeline-body"><p>The primer report is now much less dramatic for the revised version of the PR. We now just have two diagnostics going away in static-frame because we now have a better understanding of the code patterns they're using that are supposed to work with any <code>NamedTuple</code> type.</p>
<p>The initial attempt to use a protocol type resulted in one new diagnostic being added in django-stubs, because we did not see <code>NamedTupleLike</code> as a subtype of <code>tuple[Any, ...]</code> -- that's impossible if we use a protocol here, since the only fully static nominal type a protocol can ever be a subtype of is <code>object</code>:</p>
<blockquote>
<pre><code class="language-diff">django-stubs (https://github.com/typeddjango/django-stubs)
+ django-stubs/db/models/query.pyi:40:31: error[invalid-argument-type] Argument to class `ValuesListIterable` is incorrect: Expected `tuple[Any, ...]`, found `NamedTupleLike`
- Found 442 diagnostics
+ Found 443 diagnostics
</code></pre>
</blockquote>
<p>I've since removed that diagnostic by making the protocol in <code>ty_extensions</code> more minimal, and saying that <code>NamedTuple</code> does not actually mean <code>NamedTupleLike</code> when it occurs in a type expression -- it <em>actually</em> means <code>tuple[object, ...] &amp; NamedTupleLike</code>. This seems to solve all problems...!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jelle-openai">@jelle-openai</a> on 2025-08-15 16:57</div>
            <div class="timeline-body"><blockquote>
<p>convinced Jelle and Jukka to merge</p>
</blockquote>
<p>For the record I'm still not convinced this was a good idea. https://github.com/python/mypy/pull/11162#discussion_r713485175</p>
<p>But it seems the approach you came up with in this PR is reasonable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 17:05</div>
            <div class="timeline-body"><blockquote>
<p>For the record I'm still not convinced this was a good idea. <a href="https://github.com/python/mypy/pull/11162#discussion_r713485175">python/mypy#11162 (comment)</a></p>
</blockquote>
<p>If you'd pushed back harder back then, we wouldn't be in this situation now üòÜ</p>
<p>Seriously though, this feature doesn't bother me much. I feel like &quot;having a protocol for NamedTuple-created classes&quot; makes sense and has good use cases, and having that protocol maintained in a shared place rather than by every individual user also makes sense to me. So really the only &quot;questionable&quot; thing here is having the special form <code>typing.NamedTuple</code> mean that protocol in a type expression. I grant that's a bit weird, and the principled thing would be just to name the protocol directly. But special forms mean all kinds of weird things in type expressions; this one seems pretty intuitive and harmless to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-08-15 17:14</div>
            <div class="timeline-body"><p>Looks good to me, thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-08-15 17:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-08-15 17:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-08-15 17:20</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:15:04 UTC
    </footer>
</body>
</html>
