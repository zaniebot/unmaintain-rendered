<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Markdown test runner - astral-sh/ruff #15632</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Markdown test runner</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15632">#15632</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-01-21 09:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-21 09:33</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>As more and more tests move to Markdown, running the mdtest suite becomes one of the most common tasks for developers working on Red Knot. There are a few pain points when doing so, however:</p>
<ul>
<li>The <code>build.rs</code> script enforces recompilation (~five seconds) whenever something changes in the <code>resource/mdtest</code> folder. This is strictly necessary, because whenever files are added or removed, the test harness needs to be updated. But this is very rarely the case! The most common scenario is that a Markdown file has <em>changed</em>, and in this case, no recompilation is necessary. It is currently not possible to distinguish these two cases using <code>cargo::rerun-if-changed</code>. One can work around this by running the test executable manually, but it requires finding the path to the correct <code>mdtest-&lt;random-hash&gt;</code> executable.</li>
<li>All Markdown tests are run by default. This is needed whenever Rust code changes, but while working on the tests themselves, it is often much more convenient to only run the tests for a single file. This can be done by using a <code>mdtest__path_to_file</code> filter, but this needs to be manually spelled out or copied from the test output.</li>
<li><code>cargo</code>s test output for a failing Markdown test is often unnecessarily verbose. Unless there is an <em>actual</em> panic somewhere in the code, mdtests usually fail with the explicit <a href="https://github.com/astral-sh/ruff/blob/c616650dfa514c58ac86c5c60648d4d2dcf17d6d/crates/red_knot_test/src/lib.rs#L96"><em>&quot;Some tests failed&quot;</em> panic</a> in the mdtest suite. But in those cases, we are not interested in the pointer to the source of this panic, but only in the mdtest suite output.</li>
</ul>
<p>This PR adds a Markdown test runner tool that attempts to make the developer experience better.</p>
<p>Once it is started using</p>
<pre><code class="language-bash">uv run crates/red_knot_python_semantic/mdtest.py
</code></pre>
<p>it will first recompile the tests once (if cargo requires it), find the path to the <code>mdtest</code> executable, and then enter into a mode where it watches for changes in the <code>red_knot_python_semantic</code> crate. Whenever â€¦</p>
<ul>
<li>â€¦ a Markdown file changes, it will rerun the mdtest for this specific file automatically (no recompilation!).</li>
<li>â€¦ a Markdown file is added, it will recompile the tests and then run the mdtest for the new file</li>
<li>â€¦ Rust code is changed, it will recompile the tests and run all of them</li>
</ul>
<p>The tool also trims down <code>cargo test</code> output and only shows the actual mdtest errors.</p>
<p>The tool will certainly require a few more iterations before it becomes mature, but I'm curious to hear if there is any interest for something like this.</p>
<h2>Preview</h2>
<p><img src="https://github.com/user-attachments/assets/ebdb20a0-c12d-4657-94b1-ac0f38d79fe9" alt="mdtest" /></p>
<h2>Test Plan</h2>
<ul>
<li>Tested the new runner under various scenarios.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">testing</span> added by @sharkdp on 2025-01-21 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-01-21 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-01-21 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-01-21 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-01-21 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-21 09:40</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:145 on 2025-01-21 10:04</div>
            <div class="timeline-body"><p>Curious Python typing scenario. The <code>Never</code>/<code>NoReturn</code> here is technically correct, I believe, but apparently not possible for type-checkers to infer. <code>watch</code> returns an infinite generator, but even if the return type of <code>watch</code> would be <code>Generator[â€¦, â€¦, Never]</code>, that doesn't seem to help. Both mypy and pyright have problems with this:</p>
<pre><code class="language-py">from typing import Never, Generator

def generator() -&gt; Generator[int, None, Never]:
    while True:
        yield 1

def f() -&gt; Never:
    for _ in generator():
        pass
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-21 10:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:1 on 2025-01-21 11:04</div>
            <div class="timeline-body"><p>Should we document this script in https://github.com/astral-sh/ruff/blob/main/crates/red_knot_test/README.md?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:5 on 2025-01-21 11:07</div>
            <div class="timeline-body"><p>I nearly suggested that we use <code>termcolor</code> instead of <code>rich</code>, since it's a much smaller library to have as a dependency, but I suppose your use of <code>console.status</code> is good enough reason to stick with <code>rich</code> ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:8 on 2025-01-21 11:10</div>
            <div class="timeline-body"><p>Should we add a <code>tool.uv.exclude-newer</code> value in this inline config, to ensure new versions of these dependencies don't unexpectedly break the script? I doubt that they will -- <code>rich</code> and <code>watchfiles</code> are both very widely used and fairly dependable... but there's still a chance that one of them might do a breaking major release at some point?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:23 on 2025-01-21 11:11</div>
            <div class="timeline-body"><p>minor: you could annotate these with <code>Final</code>:</p>
<pre><code class="language-suggestion">from typing import Final, Literal, Never

from rich.console import Console
from watchfiles import Change, watch

CRATE_NAME: Final = &quot;red_knot_python_semantic&quot;
CRATE_ROOT: Final = Path(__file__).resolve().parent
MDTEST_DIR: Final = CRATE_ROOT / &quot;resources&quot; / &quot;mdtest&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:52 on 2025-01-21 11:17</div>
            <div class="timeline-body"><p>nit: I generally prefer to make most <code>bool</code> flags keyword-only; it makes callsites more readable</p>
<pre><code class="language-suggestion">        self, status_message: str, *, message_on_success: bool = True
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:180 on 2025-01-21 11:23</div>
            <div class="timeline-body"><p>is this an exhaustive match? Could we be explicit by adding a fallback branch with either <code>pass</code> (if it's not exhaustive) or an assertion that it's unreachable (if it's exhaustive)? We can use <code>typing.assert_never()</code> if this match is meant to be exhaustive (though pyright <a href="https://github.com/microsoft/pyright/issues/7559#issuecomment-2108198425">has some issues</a> with the function)</p>
<pre><code class="language-suggestion">                match change:
                    case Change.added:
                        # When saving a file, some editors (looking at you, Vim) might first
                        # save the file with a temporary name (e.g. `file.md~`) and then rename
                        # it to the final name. This creates a `deleted` and `added` change.
                        # We treat those files as `changed` here.
                        if (Change.deleted, path_str) in changes:
                            changed_md_files.add(relative_path)
                        else:
                            new_md_files.add(relative_path)
                    case Change.modified:
                        changed_md_files.add(relative_path)
                    case _:
                        pass
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:97 on 2025-01-21 11:26</div>
            <div class="timeline-body"><p>I'm generally not a <em>massive</em> fan of instance attributes that aren't initialized in <code>__init__</code>, because they can lead to <code>AttributeError</code>s at unexpected moments. I'd prefer to either add an assertion that the attribute has been initialized here (the suggestion below), or (better) have the attribute declared as <code>Path | None</code> in the class body, initialize it to <code>None</code> in <code>__init__</code>, and add an assertion in this method that <code>self.mdtest_executable is not None</code> before using it.</p>
<p>I'd also make <code>capture_output</code> keyword-only</p>
<pre><code class="language-suggestion">    def _run_mdtest(
        self, arguments: list[str] | None = None, *, capture_output: bool = False
    ) -&gt; subprocess.CompletedProcess:
        arguments = arguments or []
        assert hasattr(self, &quot;mdtest_executable&quot;), &quot;Must call `self._recompile_tests()` before calling `self._run_mdtest()`&quot;
        return subprocess.run(
            [self.mdtest_executable, *arguments],
            cwd=CRATE_ROOT,
            env=dict(os.environ, CLICOLOR_FORCE=&quot;1&quot;),
            capture_output=capture_output,
            text=True,
            check=False,
        )
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-21 11:27</div>
            <div class="timeline-body"><p>This is fantastic!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-21 11:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:5 on 2025-01-21 11:33</div>
            <div class="timeline-body"><p>Right... I have never used <code>rich</code> before and it seems a bit bloated, but on the other hand, <code>uv</code> is fast :smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-21 11:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:8 on 2025-01-21 11:40</div>
            <div class="timeline-body"><p>We could also use the brand new locking for scripts: https://docs.astral.sh/uv/guides/scripts/#locking-dependencies.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:32 on 2025-01-21 11:57</div>
            <div class="timeline-body"><p>minor: you could consider using a dataclass for the <code>MDTestRunner</code>. It doesn't help with our <code>__init__</code> method much, but it would autogenerate a reasonable <code>__repr__</code> method for the class</p>
<pre><code class="language-suggestion">from dataclasses import dataclass
from pathlib import Path
from typing import Final, Literal, Never, assert_never

from rich.console import Console
from watchfiles import Change, watch

CRATE_NAME: Final = &quot;red_knot_python_semantic&quot;
CRATE_ROOT: Final = Path(__file__).resolve().parent
MDTEST_DIR: Final = CRATE_ROOT / &quot;resources&quot; / &quot;mdtest&quot;


@dataclass
class MDTestRunner:
    mdtest_executable: Path | None = None
    console: Console

    def __init__(self) -&gt; None:
        self.console = Console()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:34 on 2025-01-21 11:59</div>
            <div class="timeline-body"><p>this parameter seems to always be passed using keyword arguments, which I think is more readable; you could possibly enforce it in the signature</p>
<pre><code class="language-suggestion">    def _run_cargo_test(self, *, message_format: Literal[&quot;human&quot;, &quot;json&quot;]) -&gt; str:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 11:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-21 12:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:32 on 2025-01-21 12:11</div>
            <div class="timeline-body"><p>Hm :smile:. I love dataclasses, but this class feels very much <em>not</em> like a data class. It has a custom <code>__init__</code>, I don't want/need auto-generated comparison methods, and I probably don't want to debug this class by inspecting it's <code>repr</code> (I previously had a logging output that showed the <code>mdtest_executable</code> path, but removed that because it didn't add any value). Change my mind.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 12:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:32 on 2025-01-21 12:14</div>
            <div class="timeline-body"><p>Aha! I see you're one of the dataclass &quot;purists&quot; ;)</p>
<p>I think there's two perspectives on <code>@dataclass</code>: you either think that it's a convenient code generator for a class, or you think that it should only be used for simple classes that wrap data, similar to Rust structs. I generally think of them the first way, but the name of the module obviously favours the second interpretation ;)</p>
<p>I also agree that the gains here are very minimal, so I'm happy to leave it as-is!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-21 12:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-21 12:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/mdtest.py</code>:145 on 2025-01-21 12:15</div>
            <div class="timeline-body"><p>I'm sure there was a discussion at some point about how best to annotate infinitely looping generator functions in such a way that type checkers would understand that they never return. I can't find it now, though :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-01-21 12:22</div>
            <div class="timeline-body"><p>This is amazing!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-21 13:05</div>
            <div class="timeline-body"><p>Thank you for the reviews! I'm going to merge this, so that everyone interested can easily test it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-01-21 13:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-01-21 13:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-21 13:06</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:57:51 UTC
    </footer>
</body>
</html>
