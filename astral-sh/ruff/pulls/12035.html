<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider 2-character EOL before line continuation - astral-sh/ruff #12035</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Consider 2-character EOL before line continuation</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12035">#12035</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2024-06-26 03:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-06-26 03:17</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR fixes a bug introduced in https://github.com/astral-sh/ruff/pull/12008 which didn't consider the two character newline after the line continuation character.</p>
<p>For example, consider the following code highlighted with whitespaces:</p>
<pre><code class="language-py">call(foo # comment \\r\n
\r\n
def bar():\r\n
....pass\r\n
</code></pre>
<p>The lexer is at <code>def</code> when it's running the re-lexing logic and trying to move back to a newline character. It encounters <code>\n</code> and it's being escaped (incorrect) but <code>\r</code> is being escaped, so it moves the lexer to <code>\n</code> character. This creates an overlap in token ranges which causes the panic.</p>
<pre><code>Name 0..4
Lpar 4..5
Name 5..8
Comment 9..20
NonLogicalNewline 20..22 &lt;-- overlap between
Newline 21..22           &lt;-- these two tokens
NonLogicalNewline 22..23
Def 23..26
...
</code></pre>
<p>fixes: #12028</p>
<h2>Test Plan</h2>
<p>Add a test case with line continuation and windows style newline character.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @dhruvmanila on 2024-06-26 03:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">parser</span> added by @dhruvmanila on 2024-06-26 03:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dhruvmanila on 2024-06-26 03:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-06-26 03:36</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-26 04:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1408 on 2024-06-26 04:42</div>
            <div class="timeline-body"><p>The main change is to split the match with <code>\r</code> and <code>\n</code> into it's own branch and then a common check for line continuation character.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1408 on 2024-06-26 06:35</div>
            <div class="timeline-body"><p>I think we can simplify this logic a bit. It doesn't seem to matter how many new line characters there are, we just want to skip all of them</p>
<pre><code class="language-rust">if matches!(c, '\n' | '\r') {
	while Some(newline) = reverse_chars.next_if(|c| matches!(c, '\n' | '\r')) {
		current_position -= newline.text_len();
	}

 // after any new line, handle line continuation
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-06-26 06:39</div>
            <div class="timeline-body"><p>Looks good to me. But I agree with you that this is all backwards lexing again. Could we use the previous token kind (e.g. by storing it on the lexer) and test if it is a <code>NonLogicalNewline</code> to avoid all the complexity of guessing if something's a newline or not?</p>
<p>Or is this not sufficient if there are multiple newlines (in which case storing just one previous token isn't enough?)</p>
<p>I guess there's also:</p>
<pre><code class="language-python">[a, 
	# comment
	# more comment

def foo
</code></pre>
<p>where there's more in between <code>def</code> and <code>,</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-06-26 07:23</div>
            <div class="timeline-body"><blockquote>
<p>Looks good to me. But I agree with you that this is all backwards lexing again. Could we use the previous token kind (e.g. by storing it on the lexer) and test if it is a <code>NonLogicalNewline</code> to avoid all the complexity of guessing if something's a newline or not?</p>
<p>Or is this not sufficient if there are multiple newlines (in which case storing just one previous token isn't enough?)</p>
<p>I guess there's also:</p>
<pre><code class="language-python">[a, 
  # comment
  # more comment

def foo
</code></pre>
<p>where there's more in between <code>def</code> and <code>,</code></p>
</blockquote>
<p>Yeah, that's correct. There can be multiple trivia tokens in between which makes it hard to just look at the last token.</p>
<p>Although we could split the logic and move &quot;finding the non-logical newline&quot; part to the <code>TokenSource</code> who has access to all the tokens and then it'll ask the lexer to move back to the provided location. I'm not sure if this is a good way to model this behavior.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-26 08:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1408 on 2024-06-26 08:30</div>
            <div class="timeline-body"><p>I don't think this will work because we want the position of the last unescaped newline character. We would still need to keep track of that position, so we might as well be explicit about this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dhruvmanila on 2024-06-26 08:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2024-06-26 08:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-06-26 08:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:56:33 UTC
    </footer>
</body>
</html>
