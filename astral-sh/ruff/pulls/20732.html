<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Add support for functional `TypedDict` syntax - astral-sh/ruff #20732</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Add support for functional <code>TypedDict</code> syntax</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20732">#20732</a>
        opened by <a href="https://github.com/ibraheemdev">@ibraheemdev</a>
        on 2025-10-07 03:57
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-10-07 03:57</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Adds support for the functional <code>TypedDict</code> syntax, e.g.</p>
<pre><code class="language-py">Person = TypedDict(&quot;Person&quot;, { &quot;name&quot;: str })

person: Person = { &quot;name&quot;: &quot;...&quot; }
</code></pre>
<p>Part of https://github.com/astral-sh/ty/issues/154.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @ibraheemdev on 2025-10-07 03:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @ibraheemdev on 2025-10-07 03:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @ibraheemdev on 2025-10-07 03:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @ibraheemdev on 2025-10-07 03:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @ibraheemdev on 2025-10-07 03:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-07 03:59</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-10-08 00:11:18.065496583 +0000
+++ new-output.txt	2025-10-08 00:11:21.376504168 +0000
@@ -1,6 +1,7 @@
 WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
 fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_type_statement.py`: `PEP695TypeAliasType &lt; 'db &gt;::value_type_(Id(cc17)): execute: too many cycle iterations`
-fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(16432)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/typeddicts_required.py`: `infer_definition_types(Id(13458)): execute: too many cycle iterations`
+fatal[panic] Panicked at /home/runner/.cargo/git/checkouts/salsa-e6f3bb7c2a062968/29ab321/src/function/execute.rs:217:25 when checking `/home/runner/work/ruff/ruff/typing/conformance/tests/aliases_typealiastype.py`: `infer_definition_types(Id(16c32)): execute: too many cycle iterations`
 _directives_deprecated_library.py:15:31: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `int`
 _directives_deprecated_library.py:30:26: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `str`
 _directives_deprecated_library.py:36:41: error[invalid-return-type] Function always implicitly returns `None`, which is not assignable to return type `Self@__add__`
@@ -839,9 +840,11 @@
 tuples_type_form.py:15:1: error[invalid-assignment] Object of type `tuple[Literal[1], Literal[&quot;&quot;]]` is not assignable to `tuple[int, int]`
 tuples_type_form.py:25:1: error[invalid-assignment] Object of type `tuple[Literal[1]]` is not assignable to `tuple[()]`
 tuples_type_form.py:36:1: error[invalid-assignment] Object of type `tuple[Literal[1], Literal[2], Literal[3], Literal[&quot;&quot;]]` is not assignable to `tuple[int, ...]`
+typeddicts_alt_syntax.py:23:44: error[invalid-argument-type] Argument is incorrect: Expected `_TypedDictSchema`, found `dict[Unknown | str, Unknown | &lt;class 'str'&gt;]`
 typeddicts_operations.py:37:20: error[missing-typed-dict-key] Missing required key 'name' in TypedDict `Movie` constructor
 typeddicts_operations.py:62:1: error[unresolved-attribute] Type `MovieOptional` has no attribute `clear`
 typeddicts_readonly.py:24:4: error[invalid-assignment] Cannot assign to key &quot;members&quot; on TypedDict `Band`: key is marked read-only
+typeddicts_readonly.py:36:4: error[invalid-assignment] Cannot assign to key &quot;members&quot; on TypedDict `Band2`: key is marked read-only
 typeddicts_readonly.py:50:4: error[invalid-assignment] Cannot assign to key &quot;title&quot; on TypedDict `Movie1`: key is marked read-only
 typeddicts_readonly.py:51:4: error[invalid-assignment] Cannot assign to key &quot;year&quot; on TypedDict `Movie1`: key is marked read-only
 typeddicts_readonly.py:60:4: error[invalid-assignment] Cannot assign to key &quot;title&quot; on TypedDict `Movie2`: key is marked read-only
@@ -849,12 +852,11 @@
 typeddicts_readonly_inheritance.py:36:4: error[invalid-assignment] Cannot assign to key &quot;name&quot; on TypedDict `Album2`: key is marked read-only
 typeddicts_readonly_inheritance.py:65:19: error[missing-typed-dict-key] Missing required key 'name' in TypedDict `RequiredName` constructor
 typeddicts_type_consistency.py:69:21: error[invalid-key] Invalid key access on TypedDict `A3`: Unknown key &quot;y&quot;
-typeddicts_type_consistency.py:101:1: error[invalid-assignment] Object of type `Unknown | None` is not assignable to `str`
 typeddicts_type_consistency.py:126:56: error[invalid-argument-type] Invalid argument to key &quot;inner_key&quot; with declared type `str` on TypedDict `Inner1`: value of type `Literal[1]`
 typeddicts_usage.py:23:7: error[invalid-key] Invalid key access on TypedDict `Movie`: Unknown key &quot;director&quot;
 typeddicts_usage.py:24:17: error[invalid-assignment] Invalid assignment to key &quot;year&quot; with declared type `int` on TypedDict `Movie`: value of type `Literal[&quot;1982&quot;]`
 typeddicts_usage.py:28:17: error[missing-typed-dict-key] Missing required key 'name' in TypedDict `Movie` constructor
 typeddicts_usage.py:28:18: error[invalid-key] Invalid key access on TypedDict `Movie`: Unknown key &quot;title&quot;
 typeddicts_usage.py:40:24: error[invalid-type-form] The special form `typing.TypedDict` is not allowed in type expressions. Did you mean to use a concrete TypedDict or `collections.abc.Mapping[str, object]` instead?
-Found 857 diagnostics
+Found 859 diagnostics
 WARN A fatal error occurred while checking some files. Not all project files were analyzed. See the diagnostics list above for details.
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 04:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5616 on 2025-10-07 04:09</div>
            <div class="timeline-body"><p>Should we be erroring here? pyright doesn't seem to support string constants as <code>TypedDict</code> keys, but we currently ignore non-literal keys when type-checking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/resources/mdtest/annotations/unsupported_special_types.md</code>:16 on 2025-10-07 11:58</div>
            <div class="timeline-body"><p>We could also update the text above and remove <code>TypedDict</code>s from that enumeration.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4767 on 2025-10-07 12:05</div>
            <div class="timeline-body"><p>This is necessary because we now infer the dict literal that is being passed to the <code>typing.TypedDict</code> constructor as a special form type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4862 on 2025-10-07 12:09</div>
            <div class="timeline-body"><p>Using <code>**kwargs: Any</code> here implies that we won't get completions for parameters for these constructor calls. This also doesn't seem to work for class-based <code>TypedDict</code>s at the moment, so it's certainly something that we can implement later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types.rs</code>:9239 on 2025-10-07 12:57</div>
            <div class="timeline-body"><p>This seems helpful. I was thinking about giving it another name (e.g. <code>disambiguate</code>), or just providing <code>fn as_bool(self) -&gt; Option&lt;bool&gt;</code>, which would turn the callsite into <code>a.to_bool().unwrap_or(b)</code>, but I think I like your version best.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:54 on 2025-10-07 13:05</div>
            <div class="timeline-body"><p>I think we (I) used the term &quot;class-based <code>TypedDict</code>&quot; before, so maybe</p>
<pre><code class="language-suggestion">    ClassBased(ClassType&lt;'db&gt;),
</code></pre>
<p>but I don't feel strongly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:68 on 2025-10-07 13:07</div>
            <div class="timeline-body"><p>Maybe</p>
<pre><code class="language-suggestion">    /// `typing.TypedDict` constructor (functional form for creating `TypedDict`s).
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:65 on 2025-10-07 13:10</div>
            <div class="timeline-body"><p>Is &quot;incomplete&quot; the same as &quot;nameless&quot;?</p>
<pre><code class="language-suggestion">    /// Returns an incomplete (nameless) `TypedDictType` from its items.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:94 on 2025-10-07 13:16</div>
            <div class="timeline-body"><p>Hm, I'm wondering why this doesn't cause problems for dunder-calls on synthesized <code>TypedDict</code>s?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5606 on 2025-10-07 13:35</div>
            <div class="timeline-body"><p>It confused me a bit that this <code>infer_typed_dict_expression</code> function is now used for two rather distinct tasks:</p>
<ul>
<li>Inferring an incomplete synthesized <code>TypedDict</code> <em>schema</em> from a dict like <code>{&quot;name&quot;: str, &quot;age&quot;: int}</code> that is being passed to <code>typing.TypedDict</code></li>
<li>Inferring a <code>TypedDict</code> <em>inhabitant</em> type for a dict like <code>{&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25}</code> in the context of a <code>TypedDict</code> annotation.</li>
</ul>
<p>Maybe those could be two separate functions? The only thing they share seems to be the <code>ast::ExprDict</code> unpacking above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 13:36</div>
            <div class="timeline-body"><p><code>Type::TypedDict</code> refers to an <em>inhabitant</em> of a <code>TypedDict</code> type (not to its specification), so it feels strange/wrong to me to return this variant here, even if this type is not externally observable, since it will be passed to the constructor immediately. Introducing a completely new type variant to hold on to those nameless schemas seems like overkill, but maybe we could use a new <code>KnownInstanceType</code> variant?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5616 on 2025-10-07 13:44</div>
            <div class="timeline-body"><p>From https://typing.python.org/en/latest/spec/typeddict.html#use-of-final-values-and-literal-types:</p>
<blockquote>
<p>Type checkers are only expected to support actual string literals, not final names or literal types, for specifying keys in a TypedDict type definition</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5681 on 2025-10-07 13:49</div>
            <div class="timeline-body"><p>There's probably a reason we can't use <code>infer_annotation_expression</code> here (which would already handle <code>Required</code>, etc.)? I'm not sure I understand it, though. Are we forced to infer this as a normal expression?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-10-07 13:50</div>
            <div class="timeline-body"><p>This is fantastic â€” thank you very much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 14:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5616 on 2025-10-07 14:45</div>
            <div class="timeline-body"><p>&quot;Only expected to support&quot; is not the same as &quot;must emit an error for anything else&quot;, though...</p>
<p>In general, we defer a lot of operations to type-check time that other type checkers attempt to do during (their equivalent of) semantic indexing. That puts limitations on other type checkers that we don't necessarily have for things like this, which is why language like this appears in the spec about what type checkers are &quot;expected&quot; to support</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5616 on 2025-10-07 17:27</div>
            <div class="timeline-body"><p>I changed the code to ignore these for now. I think eventually it makes sense to at least warn if we don't support them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4767 on 2025-10-07 17:28</div>
            <div class="timeline-body"><p>Yes, if it was inferred as a dictionary literal we would not have access to its items. <code>TypedDict</code> works here as a type annotation because it is not otherwise allowed in type-form expressions. I added a comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4862 on 2025-10-07 17:28</div>
            <div class="timeline-body"><p>Added a TODO comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:54 on 2025-10-07 17:29</div>
            <div class="timeline-body"><p>I copied the <code>FromClass</code> and <code>Synthesized</code> naming from the <code>Protocol</code> enum, but also don't feel strongly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:94 on 2025-10-07 17:32</div>
            <div class="timeline-body"><p><code>KnownInstanceType::TypedDictType</code> is special-cased in <code>Type::bindings</code>, but I think it would otherwise go through <code>instance_fallback</code> to an instance of <code>KnownClass::TypedDictFallback</code>, not <code>meta_type</code> to its class literal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 17:34</div>
            <div class="timeline-body"><p>I tried that at first, the problem is that we check this type against the type annotation of <code>SpecialFormType::TypedDict</code>, which <code>KnownInstanceType::TypedDictType</code> is not currently assignable to (falling back to an instance of <code>TypedDictFallback</code>). Maybe it's worth changing that, because it is quite counterintuitive?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 17:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5681 on 2025-10-07 17:38</div>
            <div class="timeline-body"><p>This code is copied from <code>infer_annotation_expression</code>, but restricted to <code>Required</code>, <code>NotRequired</code>, and <code>ReadOnly</code> qualifiers. <code>infer_annotation_expression</code> has handling for other expressions and qualifiers as well, which I'm not sure we want to allow here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-07 17:46</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-10-07 17:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 17:49</div>
            <div class="timeline-body"><p>Hmm... it seems to me that it's rather the annotation which is wrong? <code>typing.TypedDict</code> is <a href="https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions">not actually allowed</a> in type annotations. And if it were, I would rather expect it to be accepting inhabitants of <code>TypedDict</code>s, instead of dict literals that describe the schema of a <code>TypedDict</code>?</p>
<p>If I understand correctly, you want to specify <em>some</em> type in the annotation in order to later recognize it in the type context when you infer the type for the schema dict literal. Could we make up a new type for just for this purpose? Some new <code>SpecialForm</code> variant maybe? You would then be free to design assignability rules. Maybe @AlexWaygood has some ideas...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5681 on 2025-10-07 17:56</div>
            <div class="timeline-body"><p>I see. Class-based <code>TypedDict</code>s would have the same limitation. We probably don't show an error if you use something like <code>name: Final[str]</code> at the moment.</p>
<p>Given that we don't emit errors for this case here either, I'm inclined to say I'd rather use <code>infer_annotation_expression</code> and maybe later pass down a &quot;context&quot; enum or a bitset parameter that would describe what kind of qualifiers are legal in the annotation that is currently being inferred?</p>
<p>I'll leave it up to you, though, if you want to change it or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-10-07 17:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:06</div>
            <div class="timeline-body"><p>Hmm, I haven't read through this whole PR yet so I'm not sure what the correct doc-comment here should be, but I don't think this can be an accurate description of what <code>TypedDictType</code> represents... <code>TypedDict</code> is a function at runtime, so it is impossible to create an &quot;instance of <code>TypedDict</code>&quot;. Calling <code>TypedDict</code> &quot;as a function&quot; at runtime creates a new class in exactly the same way as inheriting from <code>TypedDict</code> at runtime:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; import typing
&gt;&gt;&gt; type(typing.TypedDict)
&lt;class 'function'&gt;
&gt;&gt;&gt; X = typing.TypedDict(&quot;X&quot;, {})
&gt;&gt;&gt; X
&lt;class '__main__.X'&gt;
&gt;&gt;&gt; type(X)
&lt;class 'typing._TypedDictMeta'&gt;
&gt;&gt;&gt; class Y(typing.TypedDict): ...
... 
&gt;&gt;&gt; Y
&lt;class '__main__.Y'&gt;
&gt;&gt;&gt; type(Y)
&lt;class 'typing._TypedDictMeta'&gt;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 18:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 18:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 18:09</div>
            <div class="timeline-body"><p>@carljm suggesting using <code>typing.TypedDict</code> here <em>because</em> it isn't allowed in type-form expressions, so it will not conflict with real type annotations. We are also inferring the dictionary literal as if it is a <code>TypedDict</code> instance, so if we implemented the assignability rules for <code>typing.TypedDict</code>, this should work fine.</p>
<p>That said, you're right that this is somewhat of a hack, and we could instead use a special type for the annotation (and even a special type for the inferred dictionary literal, but that might be overkill).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 18:20</div>
            <div class="timeline-body"><blockquote>
<p>@carljm suggesting using <code>typing.TypedDict</code> here <em>because</em> it isn't allowed in type-form expressions</p>
</blockquote>
<p>I see. I was definitely quite confused by this hack in the beginning, but if there are no observable side-effects, I'm also fine with documenting it, and keeping it as is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-10-07 18:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 18:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:24</div>
            <div class="timeline-body"><p>It seems incorrect to me that we infer different types for <code>X</code> and <code>Y</code> (and different types for <code>X.__class__</code> and <code>Y.__class__</code>) here on your PR branch. They're both class objects in exactly the same way at runtime:</p>
<pre><code class="language-py">from typing import TypedDict, reveal_type

X = TypedDict(&quot;X&quot;, {})

reveal_type(X)  # revealed: typing.TypedDict
reveal_type(X.__class__)  # revealed: TypedDictFallback

class Y(TypedDict): ...

reveal_type(Y)  # revealed: &lt;class 'Y'&gt;
reveal_type(Y.__class__)  # revealed: type
</code></pre>
<p>We previously experimented with making the <code>Type::ClassLiteral()</code> variant internally wrap an enum, so that we could express the fact that not all class-literal objects at runtime are created via class statements. https://github.com/astral-sh/ruff/pull/19998 turned out not to be the correct approach for <code>NewType</code>s (calls to <code>NewType</code> don't actually create classes!), but I think it could be the right approach here, and for the functional <code>enum.Enum</code> syntax, and for <code>collections.namedtuple()</code> calls, and for the functional <code>typing.NamedTuple</code> syntax, and for three-argument calls to <code>type()</code>, since those all <em>do</em> actually create classes at runtime.</p>
<p>Having said all that, this would all complicate your approach (possibly by quite a lot), so I'm okay if you don't want to try making <code>Type::ClassLiteral</code> an enum. I only mention it because I think we'll have the same issue of &quot;class objects created via function calls&quot; for all these other things we'll need to support in the long term, too. So it may be worth digging in and trying to pull off that refactor at <em>some</em> point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-10-07 18:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 18:33</div>
            <div class="timeline-body"><p>It's definitely really cool that we can use bidirectional inference here to control how type inference of a specific sub-expression of a call-expression works. I have no concrete things in mind, but I could certainly imagine that we could use this for other things as well (instead of detecting the right callable type, the precise parameter, etc.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 18:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:36</div>
            <div class="timeline-body"><p>Hmm, I see. Maybe I misread <a href="https://github.com/astral-sh/ruff/pull/20523#issuecomment-3330619430">this comment</a>, which I thought meant that we <em>don't</em> need to support definitionless classes for functional <code>TypedDict</code>s.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 18:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 18:40</div>
            <div class="timeline-body"><p>I also find this all a <em>little</em> confusing in places, I'm afraid ðŸ˜¬</p>
<p>I actually feel more strongly about not returning a <code>Type::TypedDict</code> variant for the dictionary literal, though. I'm okay with (ab)using <code>SpecialForm::TypedDictType</code> for the type annotation if we document the hack properly, but I think I'd much prefer returning a <code>KnownInstanceType::TypedDictSchema</code> (feel free to bikeshed the name) for the dictionary literal that describes the schema. The dictionary literal <em>describes</em> a <code>TypedDict</code>'s shape rather than <em>inhabiting</em> a <code>TypedDict</code> -- reusing the <code>Type::TypedDict</code> variant for this purpose feels conceptually wrong, and error-prone</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:43</div>
            <div class="timeline-body"><p>Sorry, I think that was just my oversight in that comment, not thinking about the fact that functional TypedDict does actually create a class at runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-10-07 18:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:44</div>
            <div class="timeline-body"><p>I can't speak for Carl, but I think possibly what he was saying there was that it turned out that <code>NewType</code> calls don't actually create new class objects afterall, so actually <code>NewType</code> <em>is</em> different from functional <code>NamedTuple</code>/<code>enum</code>/<code>TypedDict</code>/classes created using three-argument <code>type()</code>. Meaning that in fact, https://github.com/astral-sh/ruff/pull/20126 doesn't help us here, because unlike #19998, it doesn't propose turning <code>ClassLiteral</code> into an enum</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 18:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 18:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:46</div>
            <div class="timeline-body"><p>oops, I posted my reply before I saw Carl's!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-07 18:53</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">isort (https://github.com/pycqa/isort)
- isort/output.py:535:25: error[invalid-argument-type] Argument to function `import_statement` is incorrect: Expected `Sequence[str]`, found `@Todo | None | list[Unknown]`
+ isort/output.py:535:25: error[invalid-argument-type] Argument to function `import_statement` is incorrect: Expected `Sequence[str]`, found `Any | None | list[Unknown]`
- isort/output.py:545:25: error[invalid-argument-type] Argument to function `import_statement` is incorrect: Expected `Sequence[str]`, found `@Todo | None | list[Unknown]`
+ isort/output.py:545:25: error[invalid-argument-type] Argument to function `import_statement` is incorrect: Expected `Sequence[str]`, found `Any | None | list[Unknown]`
- isort/output.py:553:29: error[invalid-argument-type] Argument to function `import_statement` is incorrect: Expected `Sequence[str]`, found `@Todo | None | list[Unknown]`
+ isort/output.py:553:29: error[invalid-argument-type] Argument to function `import_statement` is incorrect: Expected `Sequence[str]`, found `Any | None | list[Unknown]`

graphql-core (https://github.com/graphql-python/graphql-core)
- tests/utilities/test_build_client_schema.py:682:42: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 424 diagnostics
+ Found 423 diagnostics

dragonchain (https://github.com/dragonchain/dragonchain)
+ dragonchain/transaction_processor/level_4_actions_utest.py:73:73: error[invalid-argument-type] Invalid argument to key &quot;dc_id&quot; with declared type `str` on TypedDict `L1Headers`: value of type `Literal[123]`
+ dragonchain/transaction_processor/level_4_actions_utest.py:73:90: error[invalid-argument-type] Invalid argument to key &quot;block_id&quot; with declared type `str` on TypedDict `L1Headers`: value of type `Literal[124]`
- Found 315 diagnostics
+ Found 317 diagnostics

mypy (https://github.com/python/mypy)
+ mypy/typeshed/stdlib/logging/config.pyi:45:38: error[unsupported-operator] Operator `|` is unsupported between objects of type `typing.TypedDict` and `&lt;class 'dict[str, Any]'&gt;`
- Found 1834 diagnostics
+ Found 1835 diagnostics

artigraph (https://github.com/artigraph/artigraph)
+ src/arti/types/python.py:258:13: error[invalid-argument-type] Argument is incorrect: Expected `_TypedDictSchema`, found `dict[@Todo, @Todo]`
- Found 146 diagnostics
+ Found 147 diagnostics

operator (https://github.com/canonical/operator)
+ ops/model.py:85:51: error[invalid-type-form] Variable of type `Literal[&quot;_SettableStatusName | _ReadOnlyStatusName&quot;]` is not allowed in a type expression
- ops/pebble.py:637:58: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- ops/pebble.py:727:58: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- ops/pebble.py:796:58: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
+ ops/pebble.py:2110:23: error[invalid-argument-type] Invalid argument to key &quot;access&quot; with declared type `Literal[&quot;untrusted&quot;, &quot;metrics&quot;, &quot;read&quot;, &quot;admin&quot;]` on TypedDict `IdentityDict`: value of type `str`
- Found 100 diagnostics
+ Found 99 diagnostics

meson (https://github.com/mesonbuild/meson)
+ mesonbuild/cargo/manifest.py:268:28: error[invalid-key] Invalid key access on TypedDict `Package`: Unknown key &quot;package&quot;
+ mesonbuild/cargo/manifest.py:347:17: error[invalid-key] Invalid key access on TypedDict `BuildTarget`: Unknown key &quot;path&quot; - did you mean &quot;name&quot;?
+ mesonbuild/cargo/manifest.py:362:17: error[invalid-key] Invalid key access on TypedDict `BuildTarget`: Unknown key &quot;path&quot; - did you mean &quot;name&quot;?
+ mesonbuild/cargo/manifest.py:376:17: error[invalid-key] Invalid key access on TypedDict `BuildTarget`: Unknown key &quot;path&quot; - did you mean &quot;name&quot;?
+ mesonbuild/cargo/manifest.py:390:17: error[invalid-key] Invalid key access on TypedDict `BuildTarget`: Unknown key &quot;path&quot; - did you mean &quot;name&quot;?
- Found 889 diagnostics
+ Found 894 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
+ src/prefect/cli/deployment.py:392:48: error[invalid-assignment] Invalid assignment to key &quot;anchor_date&quot; with declared type `str` on TypedDict `IntervalScheduleOptions`: value of type `datetime`
+ src/prefect/cli/root.py:121:48: error[invalid-key] Invalid key access on TypedDict `VersionInfo`: Unknown key &quot;full-revisionid&quot;
+ src/prefect/utilities/dockerutils.py:67:46: error[invalid-key] Invalid key access on TypedDict `VersionInfo`: Unknown key &quot;full-revisionid&quot;
- Found 3198 diagnostics
+ Found 3201 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
+ src/scikit_build_core/build/_wheelfile.py:51:22: error[no-matching-overload] No overload of function `field` matches arguments
- Found 52 diagnostics
+ Found 53 diagnostics

static-frame (https://github.com/static-frame/static-frame)
+ static_frame/test/unit/test_type_clinic.py:197:39: error[invalid-argument-type] Argument is incorrect: Expected `_TypedDictSchema`, found `dict[str, &lt;class 'int'&gt; | &lt;class 'float'&gt; | &lt;class 'str'&gt;]`
+ static_frame/test/unit/test_type_clinic.py:198:39: error[invalid-argument-type] Argument is incorrect: Expected `_TypedDictSchema`, found `dict[str, &lt;class 'int'&gt; | &lt;class 'float'&gt; | &lt;class 'bool'&gt;]`
- Found 1888 diagnostics
+ Found 1890 diagnostics

</code></pre>
</details>
No memory usage changes detected âœ…

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 18:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:54</div>
            <div class="timeline-body"><p>I see, that makes a lot of sense. I would prefer to get this PR merged even if it is slightly incorrect (assuming it doesn't generate a lot of ecosystem false positives), but I'm happy to continue this work to support the <code>ClassLiteral</code> refactor. It probably makes sense to do that with functional <code>TypedDict</code>s first, rather than implement a new feature along with the refactor.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-07 18:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6871 on 2025-10-07 18:56</div>
            <div class="timeline-body"><p>That SGTM, breaking it up into chunks will make it easier to review too!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 19:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:108 on 2025-10-07 19:40</div>
            <div class="timeline-body"><p>I'm not sure how we should display <code>TypedDictSchema</code> in diagnostics, given that it is an internal type. Ideally we would have a special diagnostic for this specific case, but I believe the <code>TypedDictSchema</code> type might still show up in the IDE in other cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-07 19:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5649 on 2025-10-07 19:42</div>
            <div class="timeline-body"><p>I refactored this to use a new <code>SpecialForm::TypedDictSchema</code> and <code>KnownInstanceType::TypedDictSchema</code> type. Hopefully that makes it clearer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @ibraheemdev on 2025-10-07 20:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-07 20:23</div>
            <div class="timeline-body"><!-- generated-comment ty ecosystem-analyzer -->

<h2><code>ecosystem-analyzer</code> results</h2>
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>invalid-argument-type</code> | 6 | 0 | 3 |
| <code>invalid-key</code> | 7 | 0 | 0 |
| <code>unused-ignore-comment</code> | 0 | 4 | 0 |
| <code>invalid-assignment</code> | 1 | 0 | 0 |
| <code>invalid-type-form</code> | 1 | 0 | 0 |
| <code>unsupported-operator</code> | 1 | 0 | 0 |
| <strong>Total</strong> | <strong>16</strong> | <strong>4</strong> | <strong>3</strong> |</p>
<p><strong><a href="https://ibraheem-typed-dict-construc.ecosystem-663.pages.dev/diff">Full report with detailed diff</a></strong> (<a href="https://ibraheem-typed-dict-construc.ecosystem-663.pages.dev/timing">timing results</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-10-07 20:47</div>
            <div class="timeline-body"><p>The main limitation of this PR based on the ecosystem report looks to be inheriting from a <code>TypedDict</code> created with the functional syntax:</p>
<pre><code>error: [invalid-base] Invalid class base with type `typing.TypedDict` 
</code></pre>
<p>The errors are a bit unfortunate, but I'm not sure there's an easy way to avoid these false positives before the <code>ClassLiteral</code> refactor.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @ibraheemdev on 2025-10-07 20:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @ibraheemdev on 2025-10-07 20:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-07 20:50</div>
            <div class="timeline-body"><blockquote>
<p>The main limitation of this PR based on the ecosystem report looks to be inheriting from a <code>TypedDict</code> created with the functional syntax:</p>
<pre><code>error: [invalid-base] Invalid class base with type `typing.TypedDict` 
</code></pre>
<p>The errors are a bit unfortunate, but I'm not sure there's an easy way to avoid these false positives before the <code>ClassLiteral</code> refactor.</p>
</blockquote>
<p>Could you add a branch to <code>ClassBase::try_from_type</code> similar to this one, to silence the false positives?</p>
<p>https://github.com/astral-sh/ruff/blob/7a347c43705125eadf3c4d4bad045f59d0f205c3/crates/ty_python_semantic/src/types/class_base.rs#L260-L264</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/call/bind.rs</code>:1146 on 2025-10-07 21:20</div>
            <div class="timeline-body"><p>I personally would not call the result of a <code>TypedDict(&quot;X&quot;, {&quot;foo&quot;: int})</code> call a &quot;synthesized&quot; <code>TypedDict</code>. I don't think we've laid down a definition anywhere, but to me a &quot;synthesized&quot; type is one that we &quot;spin out of thin air&quot; during type checking, that doesn't actually correspond to a definition anywhere in the user's source code. But functional <code>TypedDict</code>s <em>do</em> have definitions in source code -- it's just that the definitions are formed of assignments to function calls rather than class statements</p>
<p>Maybe rename the struct from <code>SynthesizedTypedDictType</code> to <code>FunctionalTypedDictType</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6547 on 2025-10-07 21:22</div>
            <div class="timeline-body"><p>Could we not add a <code>TypeDefinition::Assignment</code> variant to the <code>TypeDefinition</code> enum, and return that variant from this arm? That doesn't necessarily need to be done in this PR, but maybe we should add a TODO here and/or a followup issue about it? It would be nice for go-to-declaration to work with functional <code>TypedDict</code>s</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6896 on 2025-10-07 21:22</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// A single class object created using the `typing.TypedDict` functional syntax
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-10-07 21:24</div>
            <div class="timeline-body"><p>Thanks for taking on board the feedback -- this looks great!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-07 21:31</div>
            <div class="timeline-body"><blockquote>
<pre><code class="language-diff">+ static_frame/test/unit/test_type_clinic.py:197:39: error[invalid-argument-type] Argument is incorrect: Expected `_TypedDictSchema`, found `dict[str, &lt;class 'int'&gt; | &lt;class 'float'&gt; | &lt;class 'str'&gt;]`
</code></pre>
</blockquote>
<p>It would be nice if we could special-case this kind of diagnostic to say something like &quot;Expected a dictionary literal with string-literal keys and types as values&quot;, rather than exposing the internal <code>_TypedDictSchema</code> type here. But we can defer that; this seems fine for an initial implementation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @ibraheemdev on 2025-10-07 21:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @ibraheemdev on 2025-10-07 21:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-08 00:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6547 on 2025-10-08 00:28</div>
            <div class="timeline-body"><p>Opened https://github.com/astral-sh/ty/issues/1322.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-10-08 00:29</div>
            <div class="timeline-body"><p>It looks like there's a panic with recursive <code>TypeDict</code> definitions in the typing conformance suite:</p>
<pre><code class="language-py">RecursiveMovie = TypedDict(
    &quot;RecursiveMovie&quot;, {&quot;title&quot;: Required[str], &quot;predecessor&quot;: NotRequired[&quot;RecursiveMovie&quot;]}
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-08 00:43</div>
            <div class="timeline-body"><blockquote>
<p>It looks like there's a panic with recursive <code>TypeDict</code> definitions in the typing conformance suite</p>
</blockquote>
<p>Shoot, I should have thought of this in advance. I think it means that we will have to make inference of the actual dict spec lazy, similar to how it is for class typed-dicts by default (since all our understanding of class bodies is lazy).</p>
<p>It may be that the best way to do this is similar to what I've done for TypeVar definitions in https://github.com/astral-sh/ruff/pull/20598, where we more fully special-case the entire assignment statement. This would probably eliminate the need for some of the machinery added in this PR around integrating with the full call-binding machinery.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @ibraheemdev on 2025-10-08 21:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ibraheemdev on 2025-12-10 20:49</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 16:42:34 UTC
    </footer>
</body>
</html>
