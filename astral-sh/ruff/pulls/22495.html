<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Generalize union-type subtyping fast path - astral-sh/ruff #22495</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Generalize union-type subtyping fast path</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22495">#22495</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2026-01-10 15:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Currently we have a branch near the top of <code>Type::has_relation_to_impl</code> that returns <code>ConstraintSet::from(true)</code> if the l.h.s. is a typevar <code>T</code> and the right-hand side is a union <code>U</code> where <code>T</code> is one of the elements of <code>U</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/337e3ebd27407f50b96dd686631c4ac4697fa973/crates/ty_python_semantic/src/types/relation.rs#L463-L475</p>
<p>But this branch isn't only correct for type variables! In general, it is true for <em>any</em> type <code>T</code> that it will be assignable to, redundant with, and -- in some cases -- a subtype of a union <code>U</code> if <code>T</code> is contained within the elements of <code>U</code>. The branch is only <em>necessary</em> for type variables, because for non-type-variables we apply a more generalized handling lower down here:</p>
<p>https://github.com/astral-sh/ruff/blob/337e3ebd27407f50b96dd686631c4ac4697fa973/crates/ty_python_semantic/src/types/relation.rs#L730-L739</p>
<p>But the generalized handling for <code>T &lt;: U</code> can be very slow in certain pathological cases (<em>cough</em> pydantic) where a union type contains very complicated types early on in its list of elements. For example, consider the following scenario: we want to check whether <code>C</code> is a subtype of <code>U</code>, and <code>U</code> is a union with the following elements list:</p>
<pre><code>-----------
A | B | C |
-----------
</code></pre>
<p>Unfortunately, <code>A</code> and <code>B</code> are both complex recursive structural types (<em>cough</em> pydantic's huge <code>TypedDict</code>s), and checking whether <code>C</code> is a subtype of <code>A</code> or <code>B</code> is a question that takes us a long time to answer. But with our current generalized handling for determining whether <code>C &lt;: U</code> for a union type <code>U</code>, we <em>must</em> answer these questions before we even ask the question &quot;Is <code>C</code> a subtype of <code>C</code>?&quot;, for which the answer is trivial.</p>
<p>By extending the trivial <code>if union.elements(db).contains(self)</code> check early on in <code>Type::has_relation_to()</code> to <em>all</em> types (not just type variables), we can achieve a significant speedup over what we have on the <code>main</code> branch. Now, in the above example, we quickly iterate over the elements of <code>U</code> once, discover that <code>C</code> is trivially contained in <code>U</code>'s elements, and return <code>true</code> for the overall subtyping check without ever having to ask whether <code>C</code> is a subtype of <code>A</code> or <code>B</code>.</p>
<p>Essentially this means that for <em>any</em> type <code>T</code>, if we want to check whether <code>T</code> is a subtype of a union <code>U</code> we <em>may</em> iterate over the elements of the union twice: once for this fast path to check whether the union trivially contains <code>T</code> in its elements, and (if it is not trivially contained) once again to do the full (slow) <code>has_relation_to_impl</code> check for each element in the union.</p>
<p>It's perhaps surprising that iterating over the union elements twice would be consistently faster than iterating over the union elements once. However, the Codspeed results on this PR have very consistently shown some impressive speedups and no performance regressions.</p>
<h2>Behaviour change</h2>
<p>As well as achieving a big speedup, this PR also (to my surprise) improves our type-variable solving for <code>Callable</code> types. I've added a regression test for this to the PR:</p>
<pre><code class="language-py">from typing import Callable

class Box[T]:
    def get(self) -&gt; T:
        raise NotImplementedError

def my_iter[T](f: Callable[[], T | None]) -&gt; Box[T]:
    return Box()

def get_int() -&gt; int | None: ...

reveal_type(my_iter(get_int))  # `main`: Box[int | None]`; PR: Box[int]
</code></pre>
<p>I've stared at it for a while, but I don't <em>fully</em> understand why this PR fixes the bug. It makes me a bit nervous, because I worry that the bug is still there <em>somewhere</em> else in our code, and that this PR merely papers over the bug somehow. But @carljm encouraged me to open this up for review, so that's what I'm doing! I'm curious if the reason for the behaviour change is obvious to somebody else.</p>
<p>This behaviour change has a significant, positive impact on the ecosystem, because of typeshed's third overload for <code>builtins.iter()</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/337e3ebd27407f50b96dd686631c4ac4697fa973/crates/ty_vendored/vendor/typeshed/stdlib/builtins.pyi#L3746-L3761</p>
<h2>Reduction in nondeterminism??</h2>
<p>I <em>may</em> be imagining it -- and it's very hard to tell -- but I think this PR <em>may</em> reduce our level of nondeterminism? There are still some flakes in the mypy_primer report, but I <em>think</em> the level of flakes on this PR has been consistently lower than I've seen on other ty PRs recently. Since we know that the number of flakes significantly increased after https://github.com/astral-sh/ruff/pull/21551, and we know that this PR impacts our behaviour when solving type variables in <code>Callable</code> types, I wonder if this <em>might</em> also accidentally be improving the situation there somewhat?</p>
<p>It's again a bit of a mystery to me why this would be the case, however. It's also hard to confirm, since there is definitely still some flakiness in the ecosystem report (and there was <em>some</em> flakiness in the report prior to #21551, too!).</p>
<h2>Reflexivity of subtyping for type variables</h2>
<p>An implementation detail of this PR is that we currently return <code>false</code> from the <code>Type::subtyping_is_always_reflexive()</code> method on <code>main</code> if a type is a <code>Type::TypeVar</code> variant, but this PR changes that so we return <code>true</code> for <code>Type::TypeVar</code> variants.</p>
<p>The rationale for the current return-type of <code>false</code> is stated in this comment here:</p>
<p>https://github.com/astral-sh/ruff/blob/337e3ebd27407f50b96dd686631c4ac4697fa973/crates/ty_python_semantic/src/types/relation.rs#L491-L501</p>
<p>But the <code>subtyping_is_always_reflexive</code> method only has a single callsite on <code>main</code>, and that is here:</p>
<p>https://github.com/astral-sh/ruff/blob/337e3ebd27407f50b96dd686631c4ac4697fa973/crates/ty_python_semantic/src/types/relation.rs#L327-L334</p>
<p>and we also implement on <code>main</code> that <code>T</code> is always a subtype of <code>T | None</code> if <code>T</code> is a type variable, which I think is also only safe if we are able to assume that subtyping is always reflexive for <code>Type::TypeVar</code> variants. It therefore seems like we <em>de-facto</em> treat <code>Type::TypeVar</code> variants in exactly the same way as all <code>Type</code> variants for which we return <code>true</code> from <code>Type::subtyping_is_always_reflexive()</code>, and that therefore life becomes much simpler if we simply return <code>true</code> from that method for <code>Type::TypeVar()</code> types.</p>
<p>I'm curious if I'm missing something here?</p>
<h2>Open questions</h2>
<p>It's <em>possible</em> that there are pathologically large unions where iterating over the union twice would mean that this new implementation of subtyping against union types is actually slower. Should we skip the fast path for non-type-variable types if the length of the union is above a certain arbitrary threshhold? Or is that something we should just leave for now, until we have hard evidence that this is a real problem?</p>
<p>I initially played around with using an <code>FxOrderSet</code> for <code>UnionType::elements()</code>, in https://github.com/astral-sh/ruff/pull/22458. That would make the <code>.contains()</code> fast path <code>O(1)</code> rather than <code>O(n)</code>, which would alleviate the concern about pathologically large unions. But (to my surprise) the Codspeed reports appear to show that this PR is ~as fast as #22458, and #22458 has a memory-usage regression which this PR does not. So for now, I am proposing adding the fast path while still keeping <code>UnionType::elements</code> as a boxed slice.</p>
<h2>Test Plan</h2>
<ul>
<li>Existing tests</li>
<li>One new mdtest for the improvement to typevar solving for <code>Callable</code> types</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @AlexWaygood on 2026-01-10 15:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2026-01-10 15:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @AlexWaygood on 2026-01-10 15:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2026-01-10 15:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-10 15:32</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2><a href="https://github.com/python/typing/blob/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance/">Typing conformance results</a></h2>
<p>No changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-10 15:33</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">spack (https://github.com/spack/spack)
- lib/spack/spack/spec_parser.py:472:16: error[invalid-return-type] Return type does not match returned value: expected `list[Spec]`, found `list[Spec | None]`
- Found 4345 diagnostics
+ Found 4344 diagnostics

beartype (https://github.com/beartype/beartype)
- beartype/_check/code/codemain.py:1199:54: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 496 diagnostics
+ Found 495 diagnostics

pytest (https://github.com/pytest-dev/pytest)
- src/_pytest/config/__init__.py:1717:26: error[invalid-argument-type] Argument to function `assert_never` is incorrect: Expected `Never`, found `Unknown &amp; ~Literal[&quot;ini&quot;] &amp; ~Literal[&quot;toml&quot;]`
- Found 414 diagnostics
+ Found 413 diagnostics

sockeye (https://github.com/awslabs/sockeye)
+ sockeye/inference.py:410:32: error[invalid-argument-type] Argument is incorrect: Expected `RestrictLexicon | None`, found `object`
- sockeye/inference.py:376:32: error[no-matching-overload] No overload of bound method `get` matches arguments
- sockeye/inference.py:376:32: error[no-matching-overload] No overload of bound method `get` matches arguments
- Found 416 diagnostics
+ Found 415 diagnostics

dulwich (https://github.com/dulwich/dulwich)
- dulwich/walk.py:474:35: error[invalid-argument-type] Argument to bound method `_reorder` is incorrect: Expected `Iterator[WalkEntry]`, found `Iterator[WalkEntry | None]`
- Found 231 diagnostics
+ Found 230 diagnostics

poetry (https://github.com/python-poetry/poetry)
- tests/console/commands/test_show.py:42:12: warning[redundant-cast] Value is already of type `F@output_format_parametrize`
- Found 978 diagnostics
+ Found 977 diagnostics

pydantic (https://github.com/pydantic/pydantic)
- pydantic/_internal/_mock_val_ser.py:137:5: error[invalid-assignment] Object of type `MockValSer[SchemaValidator | PluggableSchemaValidator | SchemaSerializer]` is not assignable to attribute `validator` of type `SchemaValidator | PluggableSchemaValidator`
+ pydantic/_internal/_mock_val_ser.py:137:5: error[invalid-assignment] Object of type `MockValSer[Unknown]` is not assignable to attribute `validator` of type `SchemaValidator | PluggableSchemaValidator`
- pydantic/_internal/_mock_val_ser.py:143:5: error[invalid-assignment] Object of type `MockValSer[SchemaValidator | PluggableSchemaValidator | SchemaSerializer]` is not assignable to attribute `serializer` of type `SchemaSerializer`
+ pydantic/_internal/_mock_val_ser.py:143:5: error[invalid-assignment] Object of type `MockValSer[Unknown]` is not assignable to attribute `serializer` of type `SchemaSerializer`
- pydantic/_internal/_mock_val_ser.py:176:5: error[invalid-assignment] Object of type `MockValSer[SchemaValidator | PluggableSchemaValidator | SchemaSerializer]` is not assignable to attribute `__pydantic_validator__` of type `SchemaValidator | PluggableSchemaValidator`
+ pydantic/_internal/_mock_val_ser.py:176:5: error[invalid-assignment] Object of type `MockValSer[Unknown]` is not assignable to attribute `__pydantic_validator__` of type `SchemaValidator | PluggableSchemaValidator`
- pydantic/_internal/_mock_val_ser.py:182:5: error[invalid-assignment] Object of type `MockValSer[SchemaValidator | PluggableSchemaValidator | SchemaSerializer]` is not assignable to attribute `__pydantic_serializer__` of type `SchemaSerializer`
+ pydantic/_internal/_mock_val_ser.py:182:5: error[invalid-assignment] Object of type `MockValSer[Unknown]` is not assignable to attribute `__pydantic_serializer__` of type `SchemaSerializer`

Tanjun (https://github.com/FasterSpeeding/Tanjun)
- tanjun/annotations.py:1949:74: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `int | float`, found `(int | float) &amp; ~int`
- tanjun/annotations.py:1996:74: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `int | float`, found `(int | float) &amp; ~int`
- Found 133 diagnostics
+ Found 131 diagnostics

mkdocs (https://github.com/mkdocs/mkdocs)
- mkdocs/contrib/search/__init__.py:44:34: error[invalid-argument-type] Argument to bound method `remove` is incorrect: Expected `Never`, found `Unknown &amp; ~Literal[&quot;en&quot;]`
- mkdocs/contrib/search/__init__.py:48:34: error[invalid-argument-type] Argument to bound method `remove` is incorrect: Expected `Never`, found `Unknown &amp; ~Literal[&quot;en&quot;]`
- mkdocs/contrib/search/__init__.py:49:34: error[invalid-argument-type] Argument to bound method `append` is incorrect: Expected `Never`, found `Unknown &amp; ~AlwaysFalsy`
- Found 223 diagnostics
+ Found 220 diagnostics

altair (https://github.com/vega/altair)
- altair/datasets/_reader.py:335:16: error[invalid-argument-type] Argument to bound method `lazy` is incorrect: Argument type `IntoFrameT@Reader` does not satisfy upper bound `LazyFrame[LazyFrameT@LazyFrame]` of type variable `Self`
- Found 1059 diagnostics
+ Found 1058 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Unknown | Bottom[Series[Any, Any]], Any]`
+ static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Unknown, Any]`
- static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | ndarray[Never, Never] | TypeBlocks | ... omitted 6 union elements, object_]`
+ static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, object_]`

rotki (https://github.com/rotki/rotki)
+ rotkehlchen/chain/decoding/tools.py:96:44: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- rotkehlchen/chain/decoding/tools.py:97:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `BTCAddress | ChecksumAddress | SubstrateAddress | SolanaAddress`, found `A@BaseDecoderTools`
+ rotkehlchen/chain/decoding/tools.py:99:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `Sequence[A@BaseDecoderTools]`, found `Unknown | tuple[BTCAddress, ...] | tuple[ChecksumAddress, ...] | tuple[SubstrateAddress, ...] | tuple[SolanaAddress, ...]`
- rotkehlchen/chain/decoding/tools.py:98:13: error[invalid-argument-type] Argument to function `decode_transfer_direction` is incorrect: Expected `BTCAddress | ChecksumAddress | SubstrateAddress | SolanaAddress | None`, found `A@BaseDecoderTools | None`
+ rotkehlchen/chain/decoding/tools.py:100:62: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- Found 2056 diagnostics
+ Found 2057 diagnostics

zulip (https://github.com/zulip/zulip)
- zerver/lib/markdown/__init__.py:1083:24: error[not-subscriptable] Cannot subscript object of type `None` with no `__getitem__` method
- zerver/lib/markdown/__init__.py:1087:13: error[not-subscriptable] Cannot subscript object of type `None` with no `__getitem__` method
- zerver/lib/markdown/__init__.py:1107:27: error[not-iterable] Object of type `None` is not iterable
- zerver/lib/markdown/__init__.py:1149:50: error[invalid-argument-type] Argument to bound method `handle_video_inlining` is incorrect: Expected `ResultWithFamily[tuple[str, str | None]]`, found `ResultWithFamily[tuple[str, str | None] | None]`
- zerver/lib/markdown/__init__.py:1159:50: error[invalid-argument-type] Argument to bound method `handle_image_inlining` is incorrect: Expected `ResultWithFamily[tuple[str, str | None]]`, found `ResultWithFamily[tuple[str, str | None] | None] | ResultWithFamily[tuple[str, str]]`
+ zerver/lib/markdown/__init__.py:1159:50: error[invalid-argument-type] Argument to bound method `handle_image_inlining` is incorrect: Expected `ResultWithFamily[tuple[str, str | None]]`, found `ResultWithFamily[tuple[str, str | None]] | ResultWithFamily[tuple[str, str]]`
- zerver/lib/markdown/__init__.py:1171:56: error[invalid-argument-type] Argument to bound method `handle_youtube_url_inlining` is incorrect: Expected `ResultWithFamily[tuple[str, str | None]]`, found `ResultWithFamily[tuple[str, str | None] | None]`
- zerver/lib/markdown/nested_code_blocks.py:30:58: error[invalid-argument-type] Argument to bound method `get_nested_code_blocks` is incorrect: Expected `list[ResultWithFamily[tuple[str, str | None]]]`, found `list[ResultWithFamily[tuple[str, str | None] | None]]`
- Found 3675 diagnostics
+ Found 3669 diagnostics

core (https://github.com/home-assistant/core)
- homeassistant/components/advantage_air/__init__.py:69:43: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[dict[str, Any]]`, found `DataUpdateCoordinator[None]`
- homeassistant/components/airvisual/__init__.py:220:5: error[invalid-assignment] Object of type `DataUpdateCoordinator[dict[str, Any] | None]` is not assignable to attribute `runtime_data` of type `DataUpdateCoordinator[dict[str, Any]]`
- homeassistant/components/airvisual_pro/__init__.py:91:43: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[dict[str, Any]]`, found `DataUpdateCoordinator[dict[str, Any] | None]`
- homeassistant/components/asuswrt/router.py:104:16: error[invalid-return-type] Return type does not match returned value: expected `DataUpdateCoordinator[dict[str, Any]]`, found `DataUpdateCoordinator[dict[str, int] | None]`
- homeassistant/components/hvv_departures/binary_sensor.py:123:27: error[unresolved-attribute] Object of type `None` has no attribute `items`
- homeassistant/components/iammeter/sensor.py:146:13: error[not-subscriptable] Cannot subscript object of type `None` with no `__getitem__` method
- homeassistant/components/iammeter/sensor.py:147:21: error[not-subscriptable] Cannot subscript object of type `None` with no `__getitem__` method
- homeassistant/components/iammeter/sensor.py:151:28: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `DataUpdateCoordinator[dict[str, Any]]`, found `DataUpdateCoordinator[None]`
- homeassistant/components/iammeter/sensor.py:156:28: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `DataUpdateCoordinator[dict[str, Any]]`, found `DataUpdateCoordinator[None]`
+ homeassistant/components/led_ble/__init__.py:91:59: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[None]`, found `DataUpdateCoordinator[dict[str, Any]]`
- homeassistant/components/meteo_france/__init__.py:96:18: error[unresolved-attribute] Object of type `None` has no attribute `position`
+ homeassistant/components/meteo_france/__init__.py:96:18: error[unresolved-attribute] Object of type `dict[str, Any]` has no attribute `position`
- homeassistant/components/nut/__init__.py:119:40: error[invalid-argument-type] Argument to function `_unique_id_from_status` is incorrect: Expected `dict[str, str]`, found `dict[str, str] | None`
- homeassistant/components/nut/__init__.py:129:28: warning[possibly-missing-attribute] Attribute `get` may be missing on object of type `dict[str, str] | None`
- homeassistant/components/nut/__init__.py:156:9: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[dict[str, Any]]`, found `DataUpdateCoordinator[dict[str, str] | None]`
+ homeassistant/components/nws/__init__.py:133:9: error[invalid-argument-type] Argument is incorrect: Expected `TimestampDataUpdateCoordinator[None]`, found `TimestampDataUpdateCoordinator[dict[str, Any]]`
+ homeassistant/components/nws/__init__.py:134:9: error[invalid-argument-type] Argument is incorrect: Expected `TimestampDataUpdateCoordinator[None]`, found `TimestampDataUpdateCoordinator[dict[str, Any]]`
+ homeassistant/components/pi_hole/__init__.py:154:42: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[None]`, found `DataUpdateCoordinator[dict[str, Any]]`
- homeassistant/components/powerwall/__init__.py:236:43: error[invalid-assignment] Invalid assignment to key &quot;coordinator&quot; with declared type `DataUpdateCoordinator[PowerwallData] | None` on TypedDict `PowerwallRuntimeData`: value of type `DataUpdateCoordinator[PowerwallData | None]`
- homeassistant/components/renault/services.py:124:42: error[unresolved-attribute] Object of type `None` has no attribute `raw_data`
- homeassistant/components/renault/services.py:133:9: error[unresolved-attribute] Object of type `None` has no attribute `update`
- homeassistant/components/renault/services.py:136:16: error[unresolved-attribute] Object of type `None` has no attribute `schedules`
- homeassistant/components/renault/services.py:138:47: error[unresolved-attribute] Object of type `None` has no attribute `schedules`
- homeassistant/components/renault/services.py:153:9: error[unresolved-attribute] Object of type `None` has no attribute `update`
- homeassistant/components/renault/services.py:156:16: error[unresolved-attribute] Object of type `None` has no attribute `schedules`
- homeassistant/components/renault/services.py:158:45: error[unresolved-attribute] Object of type `None` has no attribute `schedules`
+ homeassistant/components/reolink/__init__.py:261:9: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[None]`, found `DataUpdateCoordinator[dict[str, Any]]`
+ homeassistant/components/reolink/__init__.py:262:9: error[invalid-argument-type] Argument is incorrect: Expected `DataUpdateCoordinator[None]`, found `DataUpdateCoordinator[dict[str, Any]]`
+ homeassistant/components/reolink/__init__.py:269:36: error[invalid-argument-type] Argument to function `register_callbacks` is incorrect: Expected `DataUpdateCoordinator[None]`, found `DataUpdateCoordinator[dict[str, Any]]`
- homeassistant/components/schluter/climate.py:74:42: error[unresolved-attribute] Object of type `None` has no attribute `items`
- homeassistant/components/senz/__init__.py:79:46: error[invalid-assignment] Object of type `DataUpdateCoordinator[dict[str, Unknown] | None]` is not assignable to `SENZDataUpdateCoordinator`
- homeassistant/components/smarttub/controller.py:73:9: error[invalid-assignment] Object of type `DataUpdateCoordinator[dict[str, Any] | None]` is not assignable to attribute `coordinator` of type `DataUpdateCoordinator[dict[str, Any]]`
- homeassistant/components/spotify/__init__.py:82:63: error[invalid-assignment] Object of type `DataUpdateCoordinator[list[Unknown] | None]` is not assignable to `DataUpdateCoordinator[list[Unknown]]`
- homeassistant/components/supla/__init__.py:123:36: error[unresolved-attribute] Object of type `None` has no attribute `items`
- homeassistant/components/tesla_wall_connector/__init__.py:71:42: error[invalid-assignment] Object of type `DataUpdateCoordinator[dict[str, Any] | None]` is not assignable to `DataUpdateCoordinator[dict[str, Any]]`
- Found 14509 diagnostics
+ Found 14490 diagnostics


</code></pre>
</details>

<p>No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2026-01-10 15:42</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2>Merging this PR will <strong>improve performance by 27.64%</strong></h2>
<p><code>⚡ 1</code> improved benchmark<br />
<code>✅ 22</code> untouched benchmarks<br />
<code>⏩ 30</code> skipped benchmarks[^skipped]</p>
<h3>Performance Changes</h3>
<h2>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Efficiency |
| --- | ---- | --------- | ------ | ------ | ---------- |
| ⚡ | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Funion-fast-path-still-vec?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Apydantic&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=benchmark"><code>pydantic</code></a> | 10.4 s | 8.1 s | +27.64% |</h2>
<p><sub>Comparing <code>alex/union-fast-path-still-vec</code> (31d7e8c) with <code>main</code> (ed355b6)</sub></p>
<a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Funion-fast-path-still-vec?utm_source=github&utm_medium=comment-v2&utm_content=button">
  <picture>
    <source media="(prefers-color-scheme: dark)" srcset="https://codspeed.io/pr-report/open-in-codspeed-dark.svg">
    <source media="(prefers-color-scheme: light)" srcset="https://codspeed.io/pr-report/open-in-codspeed-light.svg">
    <img alt="Open in CodSpeed" src="https://codspeed.io/pr-report/open-in-codspeed-light.svg" width="169" height="32">
  </picture>
</a>

<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Funion-fast-path-still-vec?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment-v2&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2026-01-16 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2026-01-16 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2026-01-16 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2026-01-16 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @AlexWaygood on 2026-01-16 20:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-16 20:09</div>
            <div class="timeline-body"><!-- generated-comment ty ecosystem-analyzer -->

<h2><code>ecosystem-analyzer</code> results</h2>
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>invalid-argument-type</code> | 8 | 79 | 2 |
| <code>possibly-missing-attribute</code> | 0 | 10 | 3 |
| <code>unresolved-attribute</code> | 0 | 10 | 3 |
| <code>invalid-assignment</code> | 0 | 6 | 4 |
| <code>invalid-await</code> | 0 | 9 | 0 |
| <code>invalid-return-type</code> | 0 | 3 | 4 |
| <code>not-subscriptable</code> | 0 | 4 | 0 |
| <code>no-matching-overload</code> | 0 | 2 | 0 |
| <code>unused-ignore-comment</code> | 1 | 1 | 0 |
| <code>not-iterable</code> | 0 | 1 | 0 |
| <code>redundant-cast</code> | 0 | 1 | 0 |
| <strong>Total</strong> | <strong>9</strong> | <strong>126</strong> | <strong>16</strong> |</p>
<p><strong><a href="https://5622a012.ty-ecosystem-ext.pages.dev/diff">Full report with detailed diff</a></strong> (<a href="https://5622a012.ty-ecosystem-ext.pages.dev/timing">timing results</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2026-01-16 20:37</div>
            <div class="timeline-body"><p>This looks good to me, nice work! I think the behavior change is an improvement, and I don't think we necessarily need to fully explain it. It's intuitive to me that it arises from doing fewer unnecessary <code>has_relation_to</code> comparisons in union cases, though I haven't fully traced out the details.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2026-01-16 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2026-01-16 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2026-01-16 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2026-01-17 07:18</div>
            <div class="timeline-body"><blockquote>
<p>It's <em>possible</em> that there are pathologically large unions where iterating over the union twice would mean that this new implementation of subtyping against union types is actually slower.</p>
</blockquote>
<p>Iterating through a contiguous slice like this is really fast! I would only anticipate this would cause a performance problem if it makes us do something &quot;expensive enough&quot; to each union element in the first traversal, where something in our previous single traversal would let us short-circuit and return early without processing every element. <code>when_any</code> <em>does</em> short-circuit if any of the union elements returns <code>AlwaysTrue</code>. But in this branch, the first traversal is just doing a simple equality check. Any code that with large enough unions to make this first traversal expensive will have many deeper performance issues.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-17 08:09:24 UTC
    </footer>
</body>
</html>
