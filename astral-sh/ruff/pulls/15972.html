<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Initial set of descriptor protocol tests - astral-sh/ruff #15972</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Initial set of descriptor protocol tests</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15972">#15972</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-02-05 14:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-02-05 14:52</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This is a first step towards creating a test suite for <a href="https://docs.python.org/3/howto/descriptor.html">descriptors</a>. It does not (yet) aim to be exhaustive.</p>
<p>relevant ticket: #15966</p>
<h2>Test Plan</h2>
<p>Compared desired behavior with the runtime behavior and the behavior of existing type checkers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">testing</span> added by @sharkdp on 2025-02-05 14:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-02-05 14:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-02-05 14:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-02-05 14:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-02-05 14:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-02-05 15:18</div>
            <div class="timeline-body"><p>Nice. Something else you could add (but doesn't <em>need</em> to be this PR) is descriptors that have different set-types to their get-types:</p>
<pre><code class="language-py">class Foo:
    def __init__(self):
        self._value: int | None = None

    def __get__(self) -&gt; int | None:
        return self._value

    def __set__(self, val: int | str) -&gt; None:
        self._value = int(val)

class Bar:
    f = Foo()

b = Bar()
reveal_type(b.f)  # revealed: int | None
b.f = &quot;42&quot;  # okay!
b.f = None  # error!
reveal_type(b.f)  # revealed: int | None
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2025-02-05 16:42</div>
            <div class="timeline-body"><p>I was wondering if it would make sense to include the two most common implicit descriptors:</p>
<pre><code class="language-md">## Built-in property descriptor

The built-in `property` decorator creates a descriptor. It is implemented in Python, but behaves the same as custom descriptor. It should correctly infer return and setter types:

```python
class C:
    _name: str | None = None
    
    @property
    def name(self) -&gt; str:
        return self. _name or &quot;Unset&quot;
        
    @name.setter
    def name(self, value: str | None) -&gt; None:
        self._value = value

c = C()
reveal_type(c._name)  # revealed: str | None
reveal_type(c.name)  # revealed: str
reveal_type(C.name)  # TODO: should be some virtual `builtins.property` instance

c.name = &quot;new&quot;  # okay!
c.name = 42  # error!
```

## Built-in classmethod descriptor

Similarly to `property`, `classmethod` decorator creates an implicit descriptor that binds the first argument to the class instead of the instance. Type inference should work for both class and instance access:

```python
class C:
    def __init__(self, value: str) -&gt; None:
          self._name: str = value

    @classmethod
    def factory(cls, value: str) -&gt; &quot;C&quot;:
        return cls(value)
        
    @classmethod
    def get_name(cls) -&gt; str:
        return cls.__name__

reveal_type(C.factory)  # TODO: should be some virtual `builtins.classmethod` instance
reveal_type(C(&quot;42&quot;).factory)  # TODO: should be some virtual `builtins.classmethod` instance

c1 = C.factory(&quot;test&quot;)  # okay
reveal_type(c1)  # revealed: C
reveal_type(C.get_name())  # revealed: str
reveal_type(C(&quot;42&quot;).get_name())  # revealed: str
```
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-05 16:52</div>
            <div class="timeline-body"><blockquote>
<p>I was wondering if it would make sense to include the two most common implicit descriptors:</p>
</blockquote>
<p>These look like great tests to add! I think we'll probably have enough tests for both <code>classmethod</code> and <code>property</code> in due course that it would make sense to devote a whole mdtest suite to each. I'll leave it to @sharkdp whether he wants to add those new files in this PR or not :-)</p>
<blockquote>
<pre><code>reveal_type(C.name)  # TODO: should be some virtual `builtins.property` instance
</code></pre>
</blockquote>
<p>Hmm, not sure what you mean by &quot;virtual&quot; here -- I think this should just be a normal <code>builtins.property</code> instance?</p>
<blockquote>
<pre><code>reveal_type(C.factory)  # TODO: should be some virtual `builtins.classmethod` instance
reveal_type(C(&quot;42&quot;).factory)  # TODO: should be some virtual `builtins.classmethod` instance
</code></pre>
</blockquote>
<p>This isn't <em>quite</em> correct, unfortunately. The <code>factory</code> object stored in <code>C</code>'s <code>__dict__</code> here is an instance of <code>builtins.classmethod</code>. But if you access it on the class or the instance, you get a <code>types.MethodType</code> instance, not a <code>classmethod</code> instance (due to the descriptor protocol):</p>
<pre><code class="language-pycon">&gt;&gt;&gt; class Foo:
...     @classmethod
...     def bar(cls): ...
...     
&gt;&gt;&gt; Foo.__dict__['bar']
&lt;classmethod(&lt;function Foo.bar at 0x1057ae2a0&gt;)&gt;
&gt;&gt;&gt; isinstance(Foo.__dict__['bar'], classmethod)
True
&gt;&gt;&gt; Foo.bar
&lt;bound method Foo.bar of &lt;class '__main__.Foo'&gt;&gt;
&gt;&gt;&gt; import types
&gt;&gt;&gt; isinstance(Foo.bar, types.MethodType)
True
&gt;&gt;&gt; isinstance(Foo.bar, classmethod)
False
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2025-02-05 17:20</div>
            <div class="timeline-body"><p>@AlexWaygood sorry, my bad, rushed this one in case @sharkdp decided to merge early. Was writing from my head. Thanks a lot for pointing out my mistakes!</p>
<blockquote>
<p>Hmm, not sure what you mean by &quot;virtual&quot; here -- I think this should just be a normal builtins.property instance?</p>
</blockquote>
<p>I remember that <code>property</code> is not implemented in pure Python, so I wasn't sure how the return object class is called. Thanks for correcting!</p>
<p>Same for the other comment. Let me correct myself:</p>
<pre><code class="language-md">## Built-in property descriptor

The built-in `property` decorator creates a descriptor. It should correctly infer return and setter types:

```python
class C:
    _name: str | None = None
    
    @property
    def name(self) -&gt; str:
        return self. _name or &quot;Unset&quot;
        
    @name.setter
    def name(self, value: str | None) -&gt; None:
        self._value = value

c = C()
reveal_type(c._name)  # revealed: str | None
reveal_type(c.name)  # revealed: str
reveal_type(C.name)  # revealed: `builtins.property`

c.name = &quot;new&quot;  # okay!
c.name = 42  # error!
```

## Built-in classmethod descriptor

Similarly to `property`, `classmethod` decorator creates an implicit descriptor that binds the first argument to the class instead of the instance.

```python
class C:
    def __init__(self, value: str) -&gt; None:
          self._name: str = value

    @classmethod
    def factory(cls, value: str) -&gt; &quot;C&quot;:
        return cls(value)
        
    @classmethod
    def get_name(cls) -&gt; str:
        return cls.__name__

c1 = C.factory(&quot;test&quot;)  # okay
reveal_type(c1)  # revealed: C
reveal_type(C.get_name())  # revealed: str
reveal_type(C(&quot;42&quot;).get_name())  # revealed: str
```
</code></pre>
<p>I think adding the test for <code>__dict__</code> access is a bit too much for initial tests. There are also <code>__set_name__</code> that can theoretically do some magic with initialization and <code>__delete__</code> is not covered. But I'll elaborate on that in the #15966</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-02-05 17:29</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>Hmm, not sure what you mean by &quot;virtual&quot; here -- I think this should just be a normal builtins.property instance?</p>
</blockquote>
<p>I remember that <code>property</code> is not implemented in pure Python, so I wasn't sure how the return object class is called. Thanks for correcting!</p>
</blockquote>
<p>Yes, <code>property</code> is implemented in C, but it's still a class, and it still has instances just like any other class. Python's object model is thankfully very consistent on this point (nowadays, at least -- it wasn't always so in the early days of Python!).</p>
<blockquote>
<p>I think adding the test for <code>__dict__</code> access is a bit too much for initial tests.</p>
</blockquote>
<p>Oh, absolutely! I'm not suggesting that we should add that to our tests. That was just an example to help demonstrate that there <em>is</em> a <code>classmethod</code> instance <em>somewhere</em> -- it's just not what is returned when the class method is accessed, regardless of whether the class method is accessed on the instance or the class</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-02-05 18:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-02-05 18:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-02-05 18:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-02-05 18:49</div>
            <div class="timeline-body"><blockquote>
<p>rushed this one in case @sharkdp decided to merge early</p>
</blockquote>
<p>@mishamsk Thank you for your contribution! I am merging this, but the whole idea here was just to set up an initial batch of tests that we could later extend. Please feel free to send changes/extensions to this document if/when you want to work on descriptors.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:57:52 UTC
    </footer>
</body>
</html>
