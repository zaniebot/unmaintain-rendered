<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Move intersection type tests to Markdown - astral-sh/ruff #15396</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Move intersection type tests to Markdown</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15396">#15396</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-01-10 11:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-01-10 11:01</div>
            <div class="timeline-body"><h2>Summary</h2>
<p><a href="https://github.com/astral-sh/ruff/blob/david/intersection-type-tests/crates/red_knot_python_semantic/resources/mdtest/intersection_types.md"><strong>Rendered version of the new test suite</strong></a></p>
<p>Moves most of our existing intersection-types tests to a dedicated Markdown test suite, extends the test coverage, unifies the notation for these tests, groups tests into a proper structure, and adds some explanations for various simplification strategies.</p>
<p>This changeset also:</p>
<ul>
<li>Adds a new simplification where <code>~Never</code> is removed from intersections.</li>
<li>Adds a new simplification where adding <code>~object</code> simplifies the whole intersection to <code>Never</code></li>
<li>Avoids unnecessary assignment-checks between inferred and declared type. This was added to this changeset to avoid many false positive errors in this test suite.</li>
</ul>
<p>Resolves the task described in this old comment <a href="https://github.com/astral-sh/ruff/pull/13962/files/e01da82a5a0ef6a2af0aa4dc50f898cffadb4a33..e7e432bca2b3f24979da55a9a34ad765aaaae8d1#r1819924085">here</a>.</p>
<h2>Test Plan</h2>
<p>Running the new Markdown tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2025-01-10 11:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-01-10 11:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-01-10 11:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-01-10 11:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-01-10 11:07</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:7 on 2025-01-10 11:35</div>
            <div class="timeline-body"><pre><code class="language-suggestion">intersection types (note that we display negative contributions at the end; the order does not matter):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:34 on 2025-01-10 11:36</div>
            <div class="timeline-body"><pre><code class="language-suggestion">We use `P`, `Q`, `R`, ‚Ä¶ to denote types that are non-disjoint:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:48 on 2025-01-10 11:38</div>
            <div class="timeline-body"><p>Because I keep forgetting why this is the case:</p>
<pre><code class="language-suggestion">
Although `P` is not a subtype of `Q` and `Q` is not a subtype of `P`, the two types are not disjoint because it would be possible to create a class `S` that inherits from both `P` and `Q` using multiple inheritance. An instance of `S` would be a member of the `P` type _and_ the `Q` type.

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:103 on 2025-01-10 11:42</div>
            <div class="timeline-body"><pre><code class="language-suggestion">### Single-element unions
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:192 on 2025-01-10 11:43</div>
            <div class="timeline-body"><pre><code class="language-suggestion">We always normalize our representation to a *union of intersections*, so when we add a *union to an
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:196 on 2025-01-10 11:45</div>
            <div class="timeline-body"><p>probably off-topic for this PR, but: I think we should add parentheses to the display for these. I find it impossible to remember what the precedence is, and I think users will as well. This would be much easier to read IMO:</p>
<pre><code class="language-suggestion">    reveal_type(i1)  # revealed: (P &amp; Q) | (P &amp; R) | (P &amp; S)
    reveal_type(i2)  # revealed: (P &amp; S) | (Q &amp; S) | (R &amp; S)
    reveal_type(i3)  # revealed: (P &amp; R) | (Q &amp; R) | (P &amp; S) | (Q &amp; S)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:321 on 2025-01-10 11:51</div>
            <div class="timeline-body"><p>Just to make sure I understand properly: this follows from the intuition that the type <code>~int</code> is really a shorthand way of saying <code>object &amp; ~int</code>, and therefore <code>~Never</code> is a shorthand for <code>object &amp; ~Never</code>, which is the same as <code>&lt;the set of all possible objects&gt; - &lt;the empty set&gt;</code>, which is the same as <code>&lt;the set of all possible objects&gt;</code>, which is the <code>object</code> type. Right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:388 on 2025-01-10 11:53</div>
            <div class="timeline-body"><p>Following https://github.com/astral-sh/ruff/pull/15272, we should now understand e.g. <code>type[bool]</code> and <code>type[str]</code> as disjoint -- since <code>bool</code> is an <code>@final</code> class, we should eagerly simplify the type <code>type[bool]</code> to <code>Literal[bool]</code>, which we should understand as being disjoint from <code>type[str]</code>. It could be worth adding a test for that here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:426 on 2025-01-10 11:53</div>
            <div class="timeline-body"><p>Very elegantly described :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:650 on 2025-01-10 11:55</div>
            <div class="timeline-body"><p>reminds me of the &quot;he protecc&quot; meme üòÜ most importantly -- he intersecc</p>
<pre><code class="language-suggestion">Dynamic types do not cancel each other out. Intersecting an unknown set of values with the negation
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-10 11:58</div>
            <div class="timeline-body"><p>The tests look fantastic! Haven't reviewed the code changes yet</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:314 on 2025-01-10 11:59</div>
            <div class="timeline-body"><p>may as well? it could be handy in tests at some point</p>
<pre><code class="language-suggestion">#[derive(Debug, Clone, PartialEq, Eq)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:196 on 2025-01-10 12:03</div>
            <div class="timeline-body"><p>I think I personally prefer to remove the parentheses, so let's indeed leave it for another day :smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 12:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:319 on 2025-01-10 12:11</div>
            <div class="timeline-body"><p>Worth using a struct variant for this? Feel like it would remove the chance of us forgetting which is which</p>
<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -316,7 +316,10 @@ enum DeclaredAndInferredType&lt;'db&gt; {
     /// We know that both the declared and inferred types are the same.
     AreTheSame(Type&lt;'db&gt;),
     /// Declared and inferred types might be different, we need to check assignability.
-    MightBeDifferent(Type&lt;'db&gt;, Type&lt;'db&gt;),
+    MightBeDifferent {
+        declared: Type&lt;'db&gt;,
+        inferred: Type&lt;'db&gt;,
+    },
 }
 
 /// Builder to infer all types in a region.
@@ -911,13 +914,13 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
 
         let (declared_ty, inferred_ty) = match declared_and_inferred_ty {
             DeclaredAndInferredType::AreTheSame(ty) =&gt; (ty, ty),
-            DeclaredAndInferredType::MightBeDifferent(declared_ty, inferred_ty) =&gt; {
-                if inferred_ty.is_assignable_to(self.db(), *declared_ty) {
-                    (declared_ty, inferred_ty)
+            DeclaredAndInferredType::MightBeDifferent { declared, inferred } =&gt; {
+                if inferred.is_assignable_to(self.db(), *declared) {
+                    (declared, inferred)
                 } else {
-                    report_invalid_assignment(&amp;self.context, node, *declared_ty, *inferred_ty);
+                    report_invalid_assignment(&amp;self.context, node, *declared, *inferred);
                     // if the assignment is invalid, fall back to assuming the annotation is correct
-                    (declared_ty, declared_ty)
+                    (declared, declared)
                 }
             }
         };
@@ -1212,10 +1215,10 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
             let declared_ty = self.file_expression_ty(annotation);
             let declared_and_inferred_ty = if let Some(default_ty) = default_ty {
                 if default_ty.is_assignable_to(self.db(), declared_ty) {
-                    DeclaredAndInferredType::MightBeDifferent(
-                        declared_ty,
-                        UnionType::from_elements(self.db(), [declared_ty, default_ty]),
-                    )
+                    DeclaredAndInferredType::MightBeDifferent {
+                        declared: declared_ty,
+                        inferred: UnionType::from_elements(self.db(), [declared_ty, default_ty]),
+                    }
                 } else if self.in_stub()
                     &amp;&amp; default
                         .as_ref()
@@ -2083,7 +2086,10 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
             self.add_declaration_with_binding(
                 assignment.into(),
                 definition,
-                &amp;DeclaredAndInferredType::MightBeDifferent(annotation_ty, value_ty),
+                &amp;DeclaredAndInferredType::MightBeDifferent {
+                    declared: annotation_ty,
+                    inferred: value_ty,
+                },
             );
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-10 12:13</div>
            <div class="timeline-body"><p>Nice. The code changes feel like they're kinda papering over the underlying issue a <em>little</em> bit (we really <em>should</em> recognise <code>int &amp; Any</code> as being assignable to <code>int &amp; Any</code>!!), but I think skipping the assignability check for function-parameter definitions is probably a worthwhile optimisation anyway. So this LGTM</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 12:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:321 on 2025-01-10 12:15</div>
            <div class="timeline-body"><p>Yes, exactly. In this document, I tried to move away a bit from how we represent these types internally. I think it's not important that we represent <code>~T</code> as an intersection with a single negative contribution (where the empty &quot;positive side&quot; represents <code>object</code>). What's more important is that the negation-operation represents the set-theoretic complement w.r.t. the set of all possible values (<code>object</code>).</p>
<p>Set theory calls this set of all possible elements the &quot;universe&quot;. In our case, <code>object</code> is the universe. And <code>Never</code> is the empty set ‚àÖ. The tests here are a manifestation of the universal complement laws</p>
<p>U<sup>‚àÅ</sup> = ‚àÖ
‚àÖ<sup>‚àÅ</sup> = U</p>
<p>I wonder if it makes sense to refer to these more set-theoretic terms in the document. And if it makes sense to test a few more of the <a href="https://en.wikipedia.org/wiki/Complement_(set_theory">laws</a>#Properties_2) in a systematic way (I think we probably test most of them already, but it's distributed across the whole document).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 12:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:319 on 2025-01-10 12:17</div>
            <div class="timeline-body"><p>Ah, yes. It was named <code>DeclaredAndInferred</code> at first, but then I changed the name of the variant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 12:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:321 on 2025-01-10 12:53</div>
            <div class="timeline-body"><p>That actually revealed one more thing that we <em>could</em> simplify. I chose not to implement this right now, as it seems rather costly: if we see <code>T | ~T</code>, we could simplify that to <code>object</code>. I added a test that describes that we don't perform this optimization at the moment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-01-10 12:55</div>
            <div class="timeline-body"><p>Excellent!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 12:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:321 on 2025-01-10 12:56</div>
            <div class="timeline-body"><p>Let me know if you think that we should add this. I think it would be straightforward to add a (simple) version of this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-10 12:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:321 on 2025-01-10 12:59</div>
            <div class="timeline-body"><blockquote>
<p>Let me know if you think that we should add this.</p>
</blockquote>
<p>The simplification of <code>T | ~T</code> to <code>object</code>? Yes, I think we probably should simplify that. But it can probably be done as a followup, right? This PR looks mergeable right now to me</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-01-10 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-01-10 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-10 13:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 13:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:321 on 2025-01-10 13:34</div>
            <div class="timeline-body"><p>Working on this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-10 16:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:110 on 2025-01-10 16:20</div>
            <div class="timeline-body"><p>This should say &quot;intersection of a single element&quot;?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-10 16:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:518 on 2025-01-10 16:26</div>
            <div class="timeline-body"><p>&quot;Here we can get remove&quot; -&gt; &quot;Here we can remove&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:426 on 2025-01-10 16:27</div>
            <div class="timeline-body"><p>&quot;overlaps&quot; seems not strong enough here, since it only means &quot;not disjoint from&quot; -- what is needed for this simplification to be valid is recognizing that ~Y is necessarily a super-set of X, if X and Y are disjoint.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-10 16:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-01-10 16:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:48 on 2025-01-10 16:51</div>
            <div class="timeline-body"><p>Gah yes of course!  I was thinking exactly this, thank you for the clarification</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-01-10 21:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/intersection_types.md</code>:426 on 2025-01-10 21:37</div>
            <div class="timeline-body"><p>Yes. I was inadvertently using &quot;overlaps with&quot; to mean &quot;fully overlaps with&quot; (pictorially speaking), I'll fix this.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 20:34:30 UTC
    </footer>
</body>
</html>
