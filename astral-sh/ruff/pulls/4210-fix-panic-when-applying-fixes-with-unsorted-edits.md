```yaml
number: 4210
title: Fix panic when applying fixes with unsorted edits
type: pull_request
state: closed
author: MichaReiser
labels: []
assignees: []
base: main
head: fix-panic-unsorted-multi-edit-fix
created_at: 2023-05-03T14:56:33Z
updated_at: 2023-07-24T15:01:42Z
url: https://github.com/astral-sh/ruff/pull/4210
synced_at: 2026-01-12T15:55:14Z
```

# Fix panic when applying fixes with unsorted edits

---

_@MichaReiser_

I'm undecided whether this is the proper fix or if we should rather change `Fix` to store a `BTreeSet` and sort the edits by the start location. But even then, there's still the possibility that two edits in a single `Fix` overlap, causing a panic. 

Fixes #4208

## Test Plan

Tested that running ruff with the example from #4208 no longer panics

---

_Comment by @MichaReiser on 2023-05-03 14:56_

Current dependencies on/for this PR:
* main
  * **PR #4210** <a href="https://app.graphite.dev/github/pr/charliermarsh/ruff/4210" target="_blank"><img src="https://static.graphite.dev/graphite-32x32.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ

This comment was auto-generated by [Graphite](https://app.graphite.dev/github/pr/charliermarsh/ruff/4210?utm_source=stack-comment).

---

_Comment by @github-actions[bot] on 2023-05-03 15:08_

## PR Check Results
### Ecosystem
âœ… ecosystem check detected no changes.

### Benchmark
#### Linux
```
group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.01     20.7Â±0.65ms  2015.7 KB/sec    1.00     20.4Â±0.70ms  2039.8 KB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.7Â±0.14ms     3.5 MB/sec    1.04      4.9Â±0.26ms     3.4 MB/sec
linter/all-rules/numpy/globals.py          1.00   585.2Â±22.23Âµs     5.0 MB/sec    1.03   602.2Â±31.02Âµs     4.9 MB/sec
linter/all-rules/pydantic/types.py         1.01      8.5Â±0.38ms     3.0 MB/sec    1.00      8.5Â±0.36ms     3.0 MB/sec
linter/default-rules/large/dataset.py      1.06     10.2Â±0.43ms     4.0 MB/sec    1.00      9.6Â±0.33ms     4.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.05      2.1Â±0.10ms     7.9 MB/sec    1.00      2.0Â±0.07ms     8.3 MB/sec
linter/default-rules/numpy/globals.py      1.03    246.8Â±9.57Âµs    12.0 MB/sec    1.00   238.6Â±10.95Âµs    12.4 MB/sec
linter/default-rules/pydantic/types.py     1.04      4.5Â±0.14ms     5.7 MB/sec    1.00      4.3Â±0.18ms     6.0 MB/sec
parser/large/dataset.py                    1.01      7.8Â±0.20ms     5.2 MB/sec    1.00      7.7Â±0.17ms     5.3 MB/sec
parser/numpy/ctypeslib.py                  1.00  1494.2Â±55.63Âµs    11.1 MB/sec    1.00  1493.0Â±58.01Âµs    11.2 MB/sec
parser/numpy/globals.py                    1.01    145.3Â±7.10Âµs    20.3 MB/sec    1.00    144.6Â±6.51Âµs    20.4 MB/sec
parser/pydantic/types.py                   1.00      3.3Â±0.08ms     7.8 MB/sec    1.00      3.3Â±0.11ms     7.8 MB/sec
```

#### Windows
```
group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.01     22.7Â±0.78ms  1838.6 KB/sec    1.00     22.4Â±0.74ms  1863.8 KB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      5.5Â±0.24ms     3.0 MB/sec    1.00      5.5Â±0.21ms     3.0 MB/sec
linter/all-rules/numpy/globals.py          1.00   636.1Â±37.65Âµs     4.6 MB/sec    1.01   645.2Â±31.77Âµs     4.6 MB/sec
linter/all-rules/pydantic/types.py         1.00      9.1Â±0.34ms     2.8 MB/sec    1.05      9.6Â±0.44ms     2.7 MB/sec
linter/default-rules/large/dataset.py      1.00     11.0Â±0.31ms     3.7 MB/sec    1.01     11.2Â±0.33ms     3.6 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00      2.3Â±0.12ms     7.1 MB/sec    1.03      2.4Â±0.09ms     7.0 MB/sec
linter/default-rules/numpy/globals.py      1.01   266.9Â±19.92Âµs    11.1 MB/sec    1.00   264.8Â±16.96Âµs    11.1 MB/sec
linter/default-rules/pydantic/types.py     1.00      5.0Â±0.25ms     5.1 MB/sec    1.00      5.0Â±0.20ms     5.1 MB/sec
parser/large/dataset.py                    1.01      8.9Â±0.28ms     4.6 MB/sec    1.00      8.9Â±0.37ms     4.6 MB/sec
parser/numpy/ctypeslib.py                  1.04  1708.5Â±84.25Âµs     9.7 MB/sec    1.00  1650.2Â±157.85Âµs    10.1 MB/sec
parser/numpy/globals.py                    1.00   168.8Â±10.01Âµs    17.5 MB/sec    1.02    172.4Â±9.97Âµs    17.1 MB/sec
parser/pydantic/types.py                   1.05      3.8Â±0.20ms     6.7 MB/sec    1.00      3.6Â±0.13ms     7.0 MB/sec
```
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

---

_@evanrittenhouse reviewed on 2023-05-03 16:56_

---

_Review comment by @evanrittenhouse on `crates/ruff/src/autofix/mod.rs`:65 on 2023-05-03 16:56_

For my own curiosity, why do we need `sorted_unstable` here?

---

_@MichaReiser reviewed on 2023-05-03 17:35_

---

_Review comment by @MichaReiser on `crates/ruff/src/autofix/mod.rs`:65 on 2023-05-03 17:35_

Do you mean why sort_unstable over sort or why sort the edits in general?

---

_Review comment by @evanrittenhouse on `crates/ruff/src/autofix/mod.rs`:65 on 2023-05-03 18:09_

Why `sort_unstable` over `sort`. IIUC, this PR basically sorts fixes to avoid overlaps. From a (brief) reading, `unstable_sort` doesn't preserve order between equal-ordered components, which doesn't seem like it matters for this PR. So I'm wondering, if it doesn't matter, why we're specifying `unstable`. 

Obviously I could very well be wrong about it mattering as well :)

---

_@evanrittenhouse reviewed on 2023-05-03 18:09_

---

_@charliermarsh approved on 2023-05-04 02:43_

My intent had been to have the constructor enforce the invariant that edits on `Fix` are sorted and non-overlapping, but I guess that isn't _actually_ enforced in the code at all.

I might vote to also "fix" whichever rule is generating out-of-order edits.

---

_@MichaReiser reviewed on 2023-05-04 06:37_

---

_Review comment by @MichaReiser on `crates/ruff/src/autofix/mod.rs`:65 on 2023-05-04 06:37_

The main motivation is that `sort_unstable` tends to be faster than `sort` and two edits in the same `Fix` with the same start position are problematic anyway (should really be a single edit).

> It is typically faster than stable sorting, except in a few special cases, e.g., when the slice consists of several concatenated sorted sequences. [source](https://doc.rust-lang.org/std/primitive.slice.html#method.sort_unstable)





---

_Comment by @MichaReiser on 2023-05-04 06:50_

> My intent had been to have the constructor enforce the invariant that edits on Fix are sorted and non-overlapping, but I guess that isn't actually enforced in the code at all.

We should add such a check to the `Fix` constructor then and document the invariant. But let's wait for the fix refactor before making any changes to `Fix`. 

> I might vote to also "fix" whichever rule is generating out-of-order edits.

That's a good point, the issue is that the `suppressible_exception` rule adds an import for `contextlib.suppress` but our `get_or_import_symbol` import doesn't enforce that the import is added before the use, resulting in Ruff emitting broken code. 

That's why the proper fix for this is to instead make our whole import handling location aware so that it only respects imports *before* a certain location or adds new imports to the last import block *before* the specific location.



---

_Closed by @MichaReiser on 2023-05-04 06:50_

---

_Comment by @charliermarsh on 2023-05-04 14:17_

@MichaReiser - I still think this could make sense to merge!

---

_Comment by @MichaReiser on 2023-05-04 14:20_

> @MichaReiser - I still think this could make sense to merge!

I'm conflicted. It seems to cover issues with the fix creation that we should fix instead. 

---

_Branch deleted on 2023-07-24 15:01_

---
