<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] add `SyntheticTypedDictType` and implement `normalized` and `is_equivalent_to` - astral-sh/ruff #21784</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] add <code>SyntheticTypedDictType</code> and implement <code>normalized</code> and <code>is_equivalent_to</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21784">#21784</a>
        opened by <a href="https://github.com/oconnor663">@oconnor663</a>
        on 2025-12-04 04:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a></div>
            <div class="timeline-body"><p>This PR cribs a lot of @ibraheemdev's work on https://github.com/astral-sh/ruff/pull/20732.</p>
<p>This depends on a couple of upstream changes, and the first commit is a temporary/dummy commit that pins git hashes for these:</p>
<ul>
<li>https://github.com/salsa-rs/salsa/pull/1033</li>
<li>https://github.com/bircni/get-size2/pull/40</li>
</ul>
<p>Those pins (at least the second one, which overwrites a published version number) aren't intended to land, and ~I'll need to fix up this PR once / assuming I can get the upstream changes shipped.~ Update: This is done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "add `SyntheticTypedDictType` and implement `normalized` and `is_equivalent_to`" to "[ty] add `SyntheticTypedDictType` and implement `normalized` and `is_equivalent_to`" by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @oconnor663 on 2025-12-04 04:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:743 on 2025-12-04 04:06</div>
            <div class="timeline-body"><p>Should a <code>SynthesizedTypedDictType</code> have a name? I've gone with no here since it's the output of <code>normalized</code>, but if this is going to be reused for functional <code>TypedDict</code>s at some point, clearly those will need to put their name somewhere.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-04 04:06</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests ‚úÖ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/display.rs</code>:920 on 2025-12-04 04:06</div>
            <div class="timeline-body"><p>What's a good way to get test coverage of displaying a normalized value?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4294 on 2025-12-04 04:07</div>
            <div class="timeline-body"><p>I've copied this special case from https://github.com/astral-sh/ruff/pull/20732, but I'm not sure how to test it. What's a good way to access a member of a normalized type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/chatgpt-codex-connector[bot]">@chatgpt-codex-connector[bot]</a> reviewed on 2025-12-04 04:07</div>
            <div class="timeline-body"><h3>üí° Codex Review</h3>
<p>Here are some automated review suggestions for this pull request.</p>
<details> <summary>‚ÑπÔ∏è About Codex in GitHub</summary>
<br/>

<p><a href="http://chatgpt.com/codex/settings/general">Your team has set up Codex to review pull requests in this repo</a>. Reviews are triggered when you</p>
<ul>
<li>Open a pull request for review</li>
<li>Mark a draft as ready</li>
<li>Comment &quot;@codex review&quot;.</li>
</ul>
<p>If Codex has suggestions, it will comment; otherwise it will react with üëç.</p>
<p>Codex can also answer questions or update the PR. Try commenting &quot;@codex address that feedback&quot;.</p>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/chatgpt-codex-connector[bot]">@chatgpt-codex-connector[bot]</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:307 on 2025-12-04 04:07</div>
            <div class="timeline-body"><p><strong><sub><sub><img src="https://img.shields.io/badge/P0-red?style=flat" alt="P0 Badge" /></sub></sub>  Clone items before interning normalized TypedDict</strong></p>
<p>In <code>TypedDictType::normalized_impl</code> you call <code>SynthesizedTypedDictType::new(db, self.params(db), self.items(db))</code>, but <code>items</code> returns a borrowed <code>&amp;FxOrderMap&lt;Name, Field&gt;</code> while the interned constructor expects an owned map. This does not compile (a shared reference cannot be moved into the interned value), so any attempt to normalize a TypedDict will fail at build time. You need to clone or otherwise materialize an owned map before interning.</p>
<p>Useful? React with üëç¬†/ üëé.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-04 04:08</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">hydra-zen (https://github.com/mit-ll-responsible-ai/hydra-zen)
+ src/hydra_zen/structured_configs/_implementations.py:2982:60: error[invalid-argument-type] Argument to function `make_dataclass` is incorrect: Expected `dict[str, Any] | None`, found `bool`
+ src/hydra_zen/structured_configs/_implementations.py:2982:60: error[invalid-argument-type] Argument to function `make_dataclass` is incorrect: Expected `bool`, found `str | None`
+ src/hydra_zen/structured_configs/_implementations.py:2982:60: error[invalid-argument-type] Argument to function `make_dataclass` is incorrect: Expected `bool`, found `dict[str, Any] | None`
+ src/hydra_zen/structured_configs/_implementations.py:3342:52: error[invalid-argument-type] Argument to function `make_dataclass` is incorrect: Expected `dict[str, Any] | None`, found `bool`
+ src/hydra_zen/structured_configs/_implementations.py:3342:52: error[invalid-argument-type] Argument to function `make_dataclass` is incorrect: Expected `bool`, found `str | None`
+ src/hydra_zen/structured_configs/_implementations.py:3342:52: error[invalid-argument-type] Argument to function `make_dataclass` is incorrect: Expected `bool`, found `dict[str, Any] | None`
- Found 540 diagnostics
+ Found 546 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/_logging.py:153:13: warning[unsupported-base] Unsupported class base with type `&lt;class 'Mapping[str, Style]'&gt; | &lt;class 'Mapping[str, Divergent]'&gt;`
- src/scikit_build_core/build/wheel.py:98:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 43 diagnostics
+ Found 41 diagnostics

pydantic (https://github.com/pydantic/pydantic)
- pydantic/_internal/_schema_gather.py:126:28: error[invalid-key] Unknown key &quot;steps&quot; for TypedDict `DataclassSchema` - did you mean &quot;type&quot;?
+ pydantic/_internal/_schema_gather.py:126:28: error[invalid-key] Unknown key &quot;steps&quot; for TypedDict `DataclassSchema` - did you mean &quot;slots&quot;?
- pydantic/fields.py:943:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:943:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:983:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:983:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1026:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1026:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1066:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1066:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1109:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1109:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1148:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1148:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1188:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`
+ pydantic/fields.py:1188:5: error[invalid-parameter-default] Default value of type `PydanticUndefinedType` is not assignable to annotated parameter type `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`
- pydantic/fields.py:1567:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, int | float | str | ... omitted 3 union elements] | ((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, int | float | str | ... omitted 3 union elements], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`
+ pydantic/fields.py:1567:13: error[invalid-argument-type] Argument is incorrect: Expected `dict[str, Divergent] | ((dict[str, Divergent], /) -&gt; None) | None`, found `Top[dict[Unknown, Unknown]] | (((dict[str, Divergent], /) -&gt; None) &amp; ~Top[dict[Unknown, Unknown]]) | None`


</code></pre>
</details>

<details>
<summary>Memory usage changes were detected when running on open source projects</summary>

<pre><code class="language-diff">sphinx (https://github.com/sphinx-doc/sphinx)
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`

prefect (https://github.com/PrefectHQ/prefect)
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`
+ WARN expected `heap_size` to be provided by Salsa query `class_based_items`


</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-04 04:10</div>
            <div class="timeline-body"><p>Making <code>.items()</code> work here is the ultimately why this PR replaces <code>FxIndexMap</code> with <code>FxOrderMap</code> in several places, and why it needs the upstream changes. The items need to be <code>Hash</code> to be a valid member of <code>struct SynthesizedTypedDictType</code> (which is interned), but they also need to be <code>salsa::Update</code> to be a valid return type from <code>ClassLiteral::fields</code> (which is tracked).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:1435 on 2025-12-04 04:13</div>
            <div class="timeline-body"><p>Does discarding <code>first_declaration</code> cause any problems here? Normalization does rely on it, and one of the union test cases breaks if we retain <code>Some(_)</code> here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:305 on 2025-12-04 04:14</div>
            <div class="timeline-body"><p>Would it be better to inline <code>SynthesizedTypedDictType::normalized_impl</code> here instead of creating two instances here and throwing the first away?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:307 on 2025-12-04 04:16</div>
            <div class="timeline-body"><p>Actually is <em>is</em> surprising to me that this works. (But it does work.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-04 04:18</div>
            <div class="timeline-body"><p>Relevant: https://github.com/astral-sh/ruff/pull/21512/files#r2538696880</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 04:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-04 04:24</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>‚úÖ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>‚úÖ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-12-04 04:24</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/synthesized_typeddict?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a></h2>
<h3>Merging #21784 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>synthesized_typeddict</code> (c127766) with <code>main</code> (a2fb2ee)</sub></p>
<h3>Summary</h3>
<p><code>‚úÖ 22</code> untouched<br />
<code>‚è© 30</code> skipped[^skipped]</p>
<p>[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/synthesized_typeddict?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-04 08:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:307 on 2025-12-04 08:08</div>
            <div class="timeline-body"><p>Salsa allows interned value lookups by reference and only clones creates an owned instance (by cloning) if the value hasn't been interned yet</p>
<p>I'm not sure I understand what chatgpt is asking recommending or even trying to protect against.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-04 11:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-04 11:49</div>
            <div class="timeline-body"><p>...I think <code>TypedDict::items()</code> actually needs to return a <code>BTreeMap</code> rather than an <code>FxIndexMap</code> or an <code>FxOrderMap</code>. It's important for <code>ClassLiteral::fields()</code> to return a map that keeps track of insertion order, because for dataclasses and namedtuples, we need to be able to check whether any fields without default values come after fields with default values. But <code>TypedDict::items()</code> has different concerns. We need this assertion to pass, and it currently doesn't on your branch, because the fields of the <code>TypedDict</code> appear in different orders for the two <code>TypedDict</code>s:</p>
<pre><code class="language-py">from ty_extensions import static_assert, is_equivalent_to
from typing import TypedDict

class Foo(TypedDict):
    x: int
    y: str

class Baz(TypedDict):
    y: str
    x: int

static_assert(is_equivalent_to(int | Foo, int | Baz))
</code></pre>
<p>that assertion will only pass if the <code>.items()</code> returned for <code>Foo</code> compares equal to the <code>.items()</code> returned by <code>Baz</code>. I.e., the maps must either have an equality semantics that doesn't care about order, or the maps must maintain <em>sorted</em> order rather than <em>insertion</em> order.</p>
<p><code>ProtocolInterface</code> is a wrapper around a <code>BTreeMap</code> (rather than <code>FxHashMap</code>, <code>IndexMap</code> or <code>OrderMap</code>), for very similar reasons:</p>
<p>https://github.com/astral-sh/ruff/blob/b8ecc83a54fd5d7955bf1ab4fb82fe18dcb52283/crates/ty_python_semantic/src/types/protocol_class.rs#L174-L184</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-04 14:04</div>
            <div class="timeline-body"><blockquote>
<p>This depends on a couple of upstream changes, and the first commit is a temporary/dummy commit that pins git hashes for these:</p>
<ul>
<li>https://github.com/salsa-rs/salsa/pull/1033</li>
<li>https://github.com/bircni/get-size2/pull/40</li>
</ul>
</blockquote>
<p>while we wait for the upstream <code>getsize2</code> change to land, you can use the implementations of <code>heap_size</code> we have in this repo for <code>OrderMap</code> and <code>OrderSet</code>: https://github.com/astral-sh/ruff/blob/326025d45f87548caba9a56c5606d80f85abc5ff/crates/ruff_memory_usage/src/lib.rs#L46-L57</p>
<p>But see my comment at https://github.com/astral-sh/ruff/pull/21784#discussion_r2588745548 -- I think we may actually need to use a <code>BTreeMap</code> for the items of a synthesized typeddict, since we need two equivalent typeddicts to normalize to synthesized typeddicts that compare equal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:743 on 2025-12-04 14:06</div>
            <div class="timeline-body"><p>They should not have a name -- two equivalent TypedDicts must normalize to synthesized typeddicts that compare equal, and that becomes harder if synthesized typeddicts carry a name around with them.</p>
<p>If we reuse this infrastructure for functional typeddicts, functional typeddicts will have to be a wrapper around a synthesized typeddict, since functional typeddicts definitely need to carry a name around with them. But it's this kind of question that makes me sceptical that functional typeddicts and synthesized typeddicts really have that much in common; I'm not sure we <em>will</em> end up reusing this infrastructure much for functional typeddicts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-04 14:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-04 14:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/display.rs</code>:920 on 2025-12-04 14:07</div>
            <div class="timeline-body"><p>For protocols, I just added some Rust unit tests at the bottom of this module:</p>
<p>https://github.com/astral-sh/ruff/blob/326025d45f87548caba9a56c5606d80f85abc5ff/crates/ty_python_semantic/src/types/display.rs#L2322-L2345</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-04 14:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:1435 on 2025-12-04 14:10</div>
            <div class="timeline-body"><p>I think this is the right thing to do. We only use <code>first_declaration</code> as a way to easily figure out what the appropriate range is for subdiagnostics in various places. Synthesized typeddicts should only ever be created &quot;on the fly&quot; so shouldn't feature in diagnostics much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bircni">@bircni</a> on 2025-12-04 15:54</div>
            <div class="timeline-body"><p>Just published the new get-size version with the implementation!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-04 16:04</div>
            <div class="timeline-body"><p>@bircni incredible thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 16:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-04 16:35</div>
            <div class="timeline-body"><p>Hmm, a type mismatch between <code>ClassLiteral::fields</code> and <code>SynthesizedTypedDictType::items</code> here will be awkward, because currently we want to return a reference to the map. We could refactor things to return an opaque iterator instead (and then we'd need a separate method for lookup-by-name?). Or I could just make sure that the <code>SynthesizedTypedDictType</code> map is always sorted during construction (or possibly during normalization, though is_equivalent_to doesn't normalize, so construction is probably better). Do you have a preference?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-04 19:25</div>
            <div class="timeline-body"><p>Ah I forgot that I did an order-independent comparison in <code>is_equivalent_to_impl</code>, so I only need to sort in <code>normalized_impl</code>. I think this works: c985fa9081d6d2a9adc10e32fadf3a0862e2b7ed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 19:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @oconnor663 on 2025-12-04 19:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-04 19:40</div>
            <div class="timeline-body"><!-- generated-comment ty ecosystem-analyzer -->

<h2><code>ecosystem-analyzer</code> results</h2>
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>unsupported-base</code> | 2 | 0 | 0 |
| <code>redundant-cast</code> | 0 | 0 | 1 |
| <strong>Total</strong> | <strong>2</strong> | <strong>0</strong> | <strong>1</strong> |</p>
<p><strong><a href="https://synthesized-typeddict.ecosystem-663.pages.dev/diff">Full report with detailed diff</a></strong> (<a href="https://synthesized-typeddict.ecosystem-663.pages.dev/timing">timing results</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-04 19:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/display.rs</code>:920 on 2025-12-04 19:46</div>
            <div class="timeline-body"><p>e1976473c0fd0dc3b9e36bdf02f67c3a225677c3</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-04 19:55</div>
            <div class="timeline-body"><p>Hmm, the change I made to redundant cast warnings changed one unrelated union cast warning in the ecosystem analysis. Is this better or worse than before? Before:</p>
<pre><code>warning[redundant-cast]: Value is already of type `Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;]`
  --&gt; basic_checker.py:85:21
   |
83 |     lines = [&quot;type&quot;, &quot;number&quot;, &quot;old number&quot;, &quot;difference&quot;, &quot;%documented&quot;, &quot;%badname&quot;]
84 |     for node_type in (&quot;module&quot;, &quot;class&quot;, &quot;method&quot;, &quot;function&quot;):
85 |         node_type = cast(Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;], node_type)
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |         new = stats.get_node_count(node_type)
87 |         old = old_stats.get_node_count(node_type) if old_stats else None
   |
info: rule `redundant-cast` is enabled by default
</code></pre>
<p>After:</p>
<pre><code>warning[redundant-cast]: Value is already of type `Literal[&quot;module&quot;, &quot;class&quot;, &quot;method&quot;, &quot;function&quot;]`, which is equivalent to `Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;]`
  --&gt; basic_checker.py:85:21
   |
83 |     lines = [&quot;type&quot;, &quot;number&quot;, &quot;old number&quot;, &quot;difference&quot;, &quot;%documented&quot;, &quot;%badname&quot;]
84 |     for node_type in (&quot;module&quot;, &quot;class&quot;, &quot;method&quot;, &quot;function&quot;):
85 |         node_type = cast(Literal[&quot;function&quot;, &quot;class&quot;, &quot;method&quot;, &quot;module&quot;], node_type)
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
86 |         new = stats.get_node_count(node_type)
87 |         old = old_stats.get_node_count(node_type) if old_stats else None
   |
info: rule `redundant-cast` is enabled by default
</code></pre>
<p>Is this unhelpful with unions? Like it's <em>interesting</em> and possibly <em>surprising</em> that <code>Foo</code> and <code>Bar</code> typeddicts can be equivalent, but it's <em>boring</em> and <em>obvious</em> that the same union in a different order is the same union? I could check specifically for <code>TypedDict</code> (and <code>Protocol</code>) when emitting this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-04 20:46</div>
            <div class="timeline-body"><p>@AlexWaygood says the <code>beartype</code> diagnostic in the ecosystem report is flaky, so other than the &quot;eye doctor: better or worse, better or worse&quot; question above, the report is clean.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-05 00:14</div>
            <div class="timeline-body"><p>I think the redundant-cast change is fine as-is, if anything a small improvement, even in the &quot;obvious&quot; case. I suppose we could even make it more explicit by naming both types in any case where they are equivalent-but-not-identical: &quot;Value is already of type X which is equivalent to type Y&quot;. But I don't know that it's worth bothering to do that unless we get evidence that someone is confused by the shorter form that assumes you can read the <code>cast</code> type yourself.</p>
<p>EDIT: oops, I failed to scroll to the right and notice that the longer form I suggested is exactly what you already did! I think that's just fine, even in a more-obvious case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-05 05:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4294 on 2025-12-05 05:33</div>
            <div class="timeline-body"><p>I've expanded the TODO comment here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-05 15:09</div>
            <div class="timeline-body"><p>~~The last unaddressed issue that I know of on this PR is the Pydantic regression.~~ I'm looking at that now. It's presumably our old friend the gigantic recursive union?</p>
<p>Edit: <em>very</em> premature :grimacing:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-05 15:12</div>
            <div class="timeline-body"><p>I would only <em>expect</em> a pydantic regression on this PR if (1) we're using <code>Type::is_equivalent_to</code> in our codebase somewhere where we shouldn't be or (2) pydantic is making extensive use of <code>assert_type</code> and/or <code>cast</code>. It might be worth checking those things?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-05 18:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-05 18:35</div>
            <div class="timeline-body"><p>It's <em>possible</em> to make it work with a <code>BTreeMap</code>:</p>
<details>
<summary>Patch</summary>

<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/diagnostic.rs b/crates/ty_python_semantic/src/types/diagnostic.rs
index bf32c6aa7f..d839b5d011 100644
--- a/crates/ty_python_semantic/src/types/diagnostic.rs
+++ b/crates/ty_python_semantic/src/types/diagnostic.rs
@@ -33,7 +33,7 @@ use crate::types::{
 };
 use crate::types::{KnownInstanceType, MemberLookupPolicy};
 use crate::{
-    Db, DisplaySettings, FxIndexMap, FxOrderMap, Module, ModuleName, Program, declare_lint,
+    Db, DisplaySettings, FxIndexMap, Module, ModuleName, Program, declare_lint,
 };
 use itertools::Itertools;
 use ruff_db::{
@@ -46,6 +46,7 @@ use ruff_python_ast::token::parentheses_iterator;
 use ruff_python_ast::{self as ast, AnyNodeRef, StringFlags};
 use ruff_text_size::{Ranged, TextRange};
 use rustc_hash::FxHashSet;
+use std::collections::BTreeMap;
 use std::fmt::{self, Formatter};
 
 /// Registers all known type check lints.
@@ -3473,7 +3474,7 @@ pub(crate) fn report_invalid_key_on_typed_dict&lt;'db&gt;(
     typed_dict_ty: Type&lt;'db&gt;,
     full_object_ty: Option&lt;Type&lt;'db&gt;&gt;,
     key_ty: Type&lt;'db&gt;,
-    items: &amp;FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;,
+    items: &amp;BTreeMap&lt;Name, Field&lt;'db&gt;&gt;,
 ) {
     let db = context.db();
     if let Some(builder) = context.report_lint(&amp;INVALID_KEY, key_node) {
diff --git a/crates/ty_python_semantic/src/types/display.rs b/crates/ty_python_semantic/src/types/display.rs
index f5e98ec86a..9abd93bdee 100644
--- a/crates/ty_python_semantic/src/types/display.rs
+++ b/crates/ty_python_semantic/src/types/display.rs
@@ -2307,9 +2307,12 @@ impl&lt;'db&gt; FmtDetailed&lt;'db&gt; for DisplayKnownInstanceRepr&lt;'db&gt; {
 
 #[cfg(test)]
 mod tests {
+    use std::collections::BTreeMap;
+
     use insta::assert_snapshot;
     use ruff_python_ast::name::Name;
 
+    use crate::Db;
     use crate::db::tests::setup_db;
     use crate::place::typing_extensions_symbol;
     use crate::types::class::{Field, FieldKind};
@@ -2318,7 +2321,6 @@ mod tests {
         KnownClass, Parameter, Parameters, Signature, StringLiteralType, Type, TypedDictParams,
         TypedDictType,
     };
-    use crate::{Db, FxOrderMap};
 
     #[test]
     fn string_literal_display() {
@@ -2367,7 +2369,7 @@ mod tests {
     fn synthesized_typeddict_display() {
         let db = setup_db();
 
-        let mut items = FxOrderMap::default();
+        let mut items = BTreeMap::default();
         items.insert(
             Name::new(&quot;foo&quot;),
             Field {
diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index 6e4d2d5726..3b8affad9c 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -1,3 +1,5 @@
+use std::collections::BTreeMap;
+
 use bitflags::bitflags;
 use ruff_db::diagnostic::{Annotation, Diagnostic, Span, SubDiagnostic, SubDiagnosticSeverity};
 use ruff_db::parsed::parsed_module;
@@ -12,6 +14,7 @@ use super::diagnostic::{
     report_missing_typed_dict_key,
 };
 use super::{ApplyTypeMappingVisitor, Type, TypeMapping, visitor};
+use crate::Db;
 use crate::semantic_index::definition::Definition;
 use crate::types::constraints::ConstraintSet;
 use crate::types::generics::InferableTypeVars;
@@ -20,7 +23,6 @@ use crate::types::{
     IsDisjointVisitor, IsEquivalentVisitor, KnownClass, NormalizedVisitor, Parameter, Parameters,
     Signature, StringLiteralType, TypeContext, TypeRelation, TypeVarVariance, UnionType,
 };
-use crate::{Db, FxOrderMap};
 
 use ordermap::OrderSet;
 
@@ -67,12 +69,22 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
         }
     }
 
-    pub(crate) fn items(self, db: &amp;'db dyn Db) -&gt; &amp;'db FxOrderMap&lt;Name, Field&lt;'db&gt;&gt; {
+    pub(crate) fn items(self, db: &amp;'db dyn Db) -&gt; &amp;'db BTreeMap&lt;Name, Field&lt;'db&gt;&gt; {
+        #[salsa::tracked(returns(ref))]
+        fn class_based_items&lt;'db&gt;(
+            db: &amp;'db dyn Db,
+            class: ClassType&lt;'db&gt;,
+        ) -&gt; BTreeMap&lt;Name, Field&lt;'db&gt;&gt; {
+            let (class_literal, specialization) = class.class_literal(db);
+            class_literal
+                .fields(db, specialization, CodeGeneratorKind::TypedDict)
+                .into_iter()
+                .map(|(name, field)| (name.clone(), field.clone()))
+                .collect()
+        }
+
         match self {
-            Self::Class(defining_class) =&gt; {
-                let (class_literal, specialization) = defining_class.class_literal(db);
-                class_literal.fields(db, specialization, CodeGeneratorKind::TypedDict)
-            }
+            Self::Class(defining_class) =&gt; class_based_items(db, defining_class),
             Self::Synthesized(synthesized) =&gt; synthesized.items(db),
         }
     }
@@ -355,14 +367,14 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
     pub(crate) fn synthesized_member(
         db: &amp;'db dyn Db,
         instance_ty: Type&lt;'db&gt;,
-        fields: &amp;FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;,
+        fields: impl IntoIterator&lt;Item = (&amp;'db Name, &amp;'db Field&lt;'db&gt;)&gt;,
         name: &amp;str,
     ) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
         match name {
             &quot;__setitem__&quot; =&gt; {
                 // Add (key type, value type) overloads for all TypedDict items (&quot;fields&quot;) that are not read-only:
                 let mut writeable_fields = fields
-                    .iter()
+                    .into_iter()
                     .filter(|(_, field)| !field.is_read_only())
                     .peekable();
 
@@ -418,7 +430,7 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
             }
             &quot;__getitem__&quot; =&gt; {
                 // Add (key -&gt; value type) overloads for all TypedDict items (&quot;fields&quot;):
-                let overloads = fields.iter().map(|(name, field)| {
+                let overloads = fields.into_iter().map(|(name, field)| {
                     let key_type = Type::StringLiteral(StringLiteralType::new(db, name.as_str()));
 
                     Signature::new(
@@ -550,7 +562,7 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
             }
             &quot;pop&quot; =&gt; {
                 let overloads = fields
-                    .iter()
+                    .into_iter()
                     .filter(|(_, field)| {
                         // Only synthesize `pop` for fields that are not required.
                         !field.is_required()
@@ -608,7 +620,7 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
                 )))
             }
             &quot;setdefault&quot; =&gt; {
-                let overloads = fields.iter().map(|(name, field)| {
+                let overloads = fields.into_iter().map(|(name, field)| {
                     let key_type = Type::StringLiteral(StringLiteralType::new(db, name.as_str()));
 
                     // `setdefault` always returns the field type
@@ -1049,13 +1061,13 @@ pub(super) fn validate_typed_dict_dict_literal&lt;'db&gt;(
     }
 }
 
-#[salsa::interned(debug, heap_size=SynthesizedTypedDictType::heap_size)]
+#[salsa::interned(debug, heap_size=ruff_memory_usage::heap_size)]
 #[derive(PartialOrd, Ord)]
 pub struct SynthesizedTypedDictType&lt;'db&gt; {
     pub(crate) params: TypedDictParams,
 
     #[returns(ref)]
-    pub(crate) items: FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;,
+    pub(crate) items: BTreeMap&lt;Name, Field&lt;'db&gt;&gt;,
 }
 
 // The Salsa heap is tracked separately.
@@ -1079,26 +1091,20 @@ impl&lt;'db&gt; SynthesizedTypedDictType&lt;'db&gt; {
 
                 (name.clone(), field)
             })
-            .collect::&lt;FxOrderMap&lt;_, _&gt;&gt;();
+            .collect::&lt;BTreeMap&lt;_, _&gt;&gt;();
 
         SynthesizedTypedDictType::new(db, self.params(db), items)
     }
 
     pub(crate) fn normalized_impl(self, db: &amp;'db dyn Db, visitor: &amp;NormalizedVisitor&lt;'db&gt;) -&gt; Self {
-        let mut items = self
+        let items = self
             .items(db)
             .iter()
             .map(|(name, field)| {
                 let field = field.clone().normalized_impl(db, visitor);
                 (name.clone(), field)
             })
-            .collect::&lt;FxOrderMap&lt;_, _&gt;&gt;();
-        // `Hash`/`Eq` for `FxOrderMap` includes the key order, so we need to sort.
-        items.sort_unstable_keys();
+            .collect::&lt;BTreeMap&lt;_, _&gt;&gt;();
         Self::new(db, self.params(db), items)
     }
-
-    fn heap_size((params, items): &amp;(TypedDictParams, FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;)) -&gt; usize {
-        ruff_memory_usage::heap_size(params) + ruff_memory_usage::order_map_heap_size(items)
-    }
 }
</code></pre>
</details>

<p>And in some ways I like ^that approach better, because the invariant that <code>TypedDict</code> items should always be in sorted order is then maintained by the type itself rather than us having to remember to sort the <code>FxOrderMap</code> every time we create a synthesized typed dict. The disadvantage though is that we have to add yet another Salsa query, which probably means that it uses more memory. And it's also more code. And it doesn't have any impact on semantics. So I think what you have already with the <code>FxOrderMap</code> approach is totally fine!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:927 on 2025-12-05 18:41</div>
            <div class="timeline-body"><p>to me these <code># error: [type-assertion-failure]</code> assertions feel a little confusing -- 99% of the time when there's a <code>type-assertion-failure</code> diagnostic or <code>static-assert</code> diagnostic in an mdtest, it has a big <code>TODO</code> comment next to it saying that it <em>should</em> pass, it just doesn't yet. But these <code>assert_type</code> calls are <em>deliberately</em> failing, which is a bit unusual!</p>
<p>I think this is really just saying the same thing as the <code>static_assert(not is_equivalent_to(Foo, FewerFields))</code> call immediately above, so I'd be inclined to omit it (same for the other <code># error: [type-assertion-failure]</code> calls in this file)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/display.rs</code>:906 on 2025-12-05 19:26</div>
            <div class="timeline-body"><p>looks like this TODO is now done :-)</p>
<pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:286 on 2025-12-05 19:35</div>
            <div class="timeline-body"><p>I don't think <code>to_meta_class</code> is an accurate name for what this method is doing (and... I don't think it's doing what it's trying to do correctly either üòÑ). A synthesized typeddict doesn't have a class, so it doesn't have a metaclass either. A class-based TypedDict <em>does</em> have a class, and therefore it also has a metaclass, but this method doesn't return the <em>metaclass</em> of a class-based typeddict, it just returns that class-based typeddict's <em>defining</em> class.</p>
<p>It looks like this method is actually being used to return a <code>ClassType</code> that can then be used to construct the meta-<em>type</em> of a <code>TypedDict</code> instance-type. So on that basis, we should rename this method <code>to_meta_type</code>, and have it return a <code>Type</code> rather than a <code>ClassType</code>.</p>
<p>But I also don't think this method gives the correct answer for the meta-type of a synthesized typeddict. A typeddict's meta-type is used for looking up synthesized TypedDict methods such as <code>__getitem__</code> -- if you return <code>type[TypedDictFallback]</code> here rather than <code>type[&lt;synthetic typeddict&gt;]</code>, then when we start doing member lookups on synthetic <code>TypedDict</code>s, we'll return the wrong results for members like <code>__getitem__</code>. As you noted in https://github.com/astral-sh/ruff/pull/21784/files#r2587403973, we don't ever do any member lookups on synthesized typeddicts yet, but we <em>will</em> if we start adding them to intersections in order to fix the <code>TypedDict</code> part of https://github.com/astral-sh/ty/issues/1479. Giving a good answer for the meta-type of a synthesized <code>TypedDict</code> may involve adding a new variant to the <code>SubclassOfInner</code> enum in <code>subclass_of.rs</code>.</p>
<p>For now, I would recommend applying something like this patch. Then we can revisit the question of an accurate meta-type for synthesized <code>TypedDict</code>s when we actually start using them in more places. It's very hard to write tests for right now, when we use them in so few places :-)</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types.rs b/crates/ty_python_semantic/src/types.rs
index e7459ce7fb..2ab9c3beba 100644
--- a/crates/ty_python_semantic/src/types.rs
+++ b/crates/ty_python_semantic/src/types.rs
@@ -7524,7 +7524,13 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
             Type::ProtocolInstance(protocol) =&gt; protocol.to_meta_type(db),
             // `TypedDict` instances are instances of `dict` at runtime, but its important that we
             // understand a more specific meta type in order to correctly handle `__getitem__`.
-            Type::TypedDict(typed_dict) =&gt; typed_dict.to_meta_class(db).into(),
+            Type::TypedDict(typed_dict) =&gt; match typed_dict {
+                TypedDictType::Class(class) =&gt; SubclassOfType::from(db, class),
+                TypedDictType::Synthesized(_) =&gt; SubclassOfType::from(
+                    db,
+                    todo_type!(&quot;TypedDict synthesized meta-type&quot;).expect_dynamic(),
+                ),
+            },
             Type::TypeAlias(alias) =&gt; alias.value_type(db).to_meta_type(db),
             Type::NewTypeInstance(newtype) =&gt; Type::from(newtype.base_class_type(db)),
         }
diff --git a/crates/ty_python_semantic/src/types/subclass_of.rs b/crates/ty_python_semantic/src/types/subclass_of.rs
index 1045817a53..c6bb9d0378 100644
--- a/crates/ty_python_semantic/src/types/subclass_of.rs
+++ b/crates/ty_python_semantic/src/types/subclass_of.rs
@@ -8,7 +8,7 @@ use crate::types::{
     ApplyTypeMappingVisitor, BoundTypeVarInstance, ClassType, DynamicType,
     FindLegacyTypeVarsVisitor, HasRelationToVisitor, IsDisjointVisitor, KnownClass,
     MaterializationKind, MemberLookupPolicy, NormalizedVisitor, SpecialFormType, Type, TypeContext,
-    TypeMapping, TypeRelation, TypeVarBoundOrConstraints, todo_type,
+    TypeMapping, TypeRelation, TypeVarBoundOrConstraints, TypedDictType, todo_type,
 };
 use crate::{Db, FxOrderSet};
 
@@ -381,7 +381,12 @@ impl&lt;'db&gt; SubclassOfInner&lt;'db&gt; {
     pub(crate) fn try_from_instance(db: &amp;'db dyn Db, ty: Type&lt;'db&gt;) -&gt; Option&lt;Self&gt; {
         Some(match ty {
             Type::NominalInstance(instance) =&gt; SubclassOfInner::Class(instance.class(db)),
-            Type::TypedDict(typed_dict) =&gt; SubclassOfInner::Class(typed_dict.to_meta_class(db)),
+            Type::TypedDict(typed_dict) =&gt; match typed_dict {
+                TypedDictType::Class(class) =&gt; SubclassOfInner::Class(class),
+                TypedDictType::Synthesized(_) =&gt; SubclassOfInner::Dynamic(
+                    todo_type!(&quot;type[T] for synthesized TypedDicts&quot;).expect_dynamic(),
+                ),
+            },
             Type::TypeVar(bound_typevar) =&gt; SubclassOfInner::TypeVar(bound_typevar),
             Type::Dynamic(DynamicType::Any) =&gt; SubclassOfInner::Dynamic(DynamicType::Any),
             Type::Dynamic(DynamicType::Unknown) =&gt; SubclassOfInner::Dynamic(DynamicType::Unknown),
diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index 6e4d2d5726..a7e5360a06 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -282,24 +282,6 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
         }
     }
 
-    /// Return the meta-type of this `TypedDict` type.
-    pub(super) fn to_meta_class(self, db: &amp;'db dyn Db) -&gt; ClassType&lt;'db&gt; {
-        // `TypedDict` instances are instances of `dict` at runtime, but its important that we
-        // understand a more specific meta type in order to correctly handle `__getitem__`.
-        match self {
-            TypedDictType::Class(defining_class) =&gt; defining_class,
-            TypedDictType::Synthesized(_) =&gt; KnownClass::TypedDictFallback
-                .try_to_class_literal(db)
-                .map(|class| class.default_specialization(db))
-                .unwrap_or_else(|| {
-                    KnownClass::Object
-                        .try_to_class_literal(db)
-                        .map(|class| class.default_specialization(db))
-                        .expect(&quot;object class must exist&quot;)
-                }),
-        }
-    }
-
     pub(crate) fn normalized_impl(self, db: &amp;'db dyn Db, visitor: &amp;NormalizedVisitor&lt;'db&gt;) -&gt; Self {
         match self {
             TypedDictType::Class(_) =&gt; {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4294 on 2025-12-05 19:40</div>
            <div class="timeline-body"><p>Given that no tests fail if I remove this right now, I would be inclined to remove this special case for now and add it back when we actually start creating synthesized typeddicts in more places, as part of https://github.com/astral-sh/ty/issues/1479. It's very hard to write tests for this right now, as you say, so it's very hard to verify whether this is in fact correct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/function.rs</code>:1619 on 2025-12-05 19:45</div>
            <div class="timeline-body"><p>What about using an <code>info</code> subdiagnostic for the extra information? it feels a <em>bit</em> verbose to me for <code>--output-format=concise</code>:</p>
<pre><code class="language-suggestion">                        let mut diagnostic = builder.into_diagnostic(format_args!(
                            &quot;Value is already of type `{}`&quot;,
                            casted_type.display(db),
                        ));
                        diagnostic.info(format_args!(
                            &quot;This type is equivalent to `{}`&quot;,
                            source_type.display(db),
                        ));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:325 on 2025-12-05 19:51</div>
            <div class="timeline-body"><p>I don't think this is correct. These assertions should pass, but currently doesn't on your branch:</p>
<pre><code class="language-py">from ty_extensions import static_assert, is_equivalent_to
from typing_extensions import TypedDict, NotRequired

class Foo(TypedDict, total=False):
    x: int
    y: str

class Baz(TypedDict):
    y: NotRequired[str]
    x: NotRequired[int]

static_assert(is_equivalent_to(Foo, Baz))
static_assert(is_equivalent_to(Foo | int, int | Baz))
</code></pre>
<p>A <code>total=False</code> <code>TypedDict</code> can still be equivalent to a <code>total=True</code> <code>TypedDict</code> if all the fields in the <code>total=True</code> <code>TypedDict</code> are marked as <code>NotRequired</code>. These should also pass, for similar reasons:</p>
<pre><code class="language-py">from ty_extensions import static_assert, is_equivalent_to
from typing_extensions import TypedDict, NotRequired, Required

class Foo(TypedDict, total=False):
    x: int
    y: Required[str]

class Baz(TypedDict):
    y: str
    x: NotRequired[int]

static_assert(is_equivalent_to(Foo, Baz))
static_assert(is_equivalent_to(Foo | int, int | Baz))
</code></pre>
<p>I think what this also implies is that <code>SyntheticTypedDictType</code> should not have a <code>params</code> field. Instead, normalizing a class-based <code>TypedDict</code> should apply the <code>total=False</code> parameter to the <code>is_required</code> flag on each <code>TypedDict</code> field</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:349 on 2025-12-05 19:52</div>
            <div class="timeline-body"><p>I think you're missing an opportunity for an early return here:</p>
<pre><code class="language-suggestion">            constraints.intersect(
                db,
                field.declared_ty.is_equivalent_to_impl(
                    db,
                    other_field.declared_ty,
                    inferable,
                    visitor,
                ),
            );
            if constraints.is_never_satisfied(db) {
                return constraints;
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-05 19:57</div>
            <div class="timeline-body"><p>Thanks! A lot of this looks good, but I think there's a few issues here to iron out</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-05 22:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:105 on 2025-12-05 22:57</div>
            <div class="timeline-body"><blockquote>
<p>rather than us having to remember to sort the FxOrderMap every time we create a synthesized typed dict</p>
</blockquote>
<p>Fwiw, I think we currently only need to remember this when we <em>normalize</em> a typeddict, which feels in line with other things we need to remember to normalize stuff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-05 23:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:927 on 2025-12-05 23:02</div>
            <div class="timeline-body"><p>241e53584d</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-05 23:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:286 on 2025-12-05 23:21</div>
            <div class="timeline-body"><p>Oof, thanks for walking me through this.</p>
<blockquote>
<p>Giving a good answer for the meta-type of a synthesized TypedDict may involve adding a new variant to the SubclassOfInner enum in subclass_of.rs.</p>
</blockquote>
<p>Yes now that you mention it, that's what https://github.com/astral-sh/ruff/pull/20732 did.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-05 23:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:349 on 2025-12-05 23:34</div>
            <div class="timeline-body"><p>Aside: Why does GitHub display this diff as though it modifies the 9 lines above, when it actually only adds 3 new lines below? It this just a hack to add in some context?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-05 23:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/function.rs</code>:1619 on 2025-12-05 23:45</div>
            <div class="timeline-body"><p>This <code>info:</code> diagnostic is obviously better than my super long line, but I think we still want to suppress it if the source and cast types are in fact (visually) identical. I.e. we don't want to say &quot;Value is already of type <code>int</code>...info: This type is equivalent to <code>int</code>&quot;. I've put the check back in in d470fc0b82.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-06 00:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:325 on 2025-12-06 00:40</div>
            <div class="timeline-body"><p>Another oof. Thanks for catching these.</p>
<p>Thinking ahead to when we add support for <code>closed</code> and <code>extra_items</code>, there's no way to &quot;distribute&quot; those across the fields, so in those cases I think <code>SyntheticTypedDictType</code> will need to track them. But it's probably cleaner to track those two individually, rather than including a whole <code>TypedDictParams</code> and normalizing and/or ignoring the <code>TOTAL</code> bit in there? So yes, agreed on removing the <code>params</code> field.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-06 01:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:325 on 2025-12-06 01:03</div>
            <div class="timeline-body"><p>0de150a1ec3b036617c69b325b71d026c74cd7e5</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-07 15:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:325 on 2025-12-07 15:02</div>
            <div class="timeline-body"><blockquote>
<p>Thinking ahead to when we add support for <code>closed</code> and <code>extra_items</code>, there's no way to &quot;distribute&quot; those across the fields, so in those cases I think <code>SyntheticTypedDictType</code> will need to track them. But it's probably cleaner to track those two individually, rather than including a whole <code>TypedDictParams</code> and normalizing and/or ignoring the <code>TOTAL</code> bit in there? So yes, agreed on removing the <code>params</code> field.</p>
</blockquote>
<p>Right. And that does make me wonder, once again, if it would give us more flexibility if <code>TypedDictType::items()</code> returned a different type to <code>ClassLiteral::fields()</code>. E.g. if we had something like this, it would be trivial to add support for <code>closed</code> and <code>extra_items</code> in the future:</p>
<details>
<summary>Patch</summary>

<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/class.rs b/crates/ty_python_semantic/src/types/class.rs
index f0fdfd38e8..ecd1518678 100644
--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -1417,7 +1417,7 @@ pub(crate) enum FieldKind&lt;'db&gt; {
 
 /// Metadata regarding a dataclass field/attribute or a `TypedDict` &quot;item&quot; / key-value pair.
 #[derive(Debug, Clone, PartialEq, Eq, Hash, salsa::Update, get_size2::GetSize)]
-pub struct Field&lt;'db&gt; {
+pub(super) struct Field&lt;'db&gt; {
     /// The declared type of the field
     pub(crate) declared_ty: Type&lt;'db&gt;,
     /// Kind-specific metadata for this field
@@ -1447,34 +1447,6 @@ impl&lt;'db&gt; Field&lt;'db&gt; {
         }
     }
 
-    pub(super) fn apply_type_mapping_impl&lt;'a&gt;(
-        self,
-        db: &amp;'db dyn Db,
-        type_mapping: &amp;TypeMapping&lt;'a, 'db&gt;,
-        tcx: TypeContext&lt;'db&gt;,
-        visitor: &amp;ApplyTypeMappingVisitor&lt;'db&gt;,
-    ) -&gt; Self {
-        Field {
-            kind: self.kind,
-            first_declaration: self.first_declaration,
-            declared_ty: self
-                .declared_ty
-                .apply_type_mapping_impl(db, type_mapping, tcx, visitor),
-        }
-    }
-
-    pub(super) fn normalized_impl(
-        &amp;self,
-        db: &amp;'db dyn Db,
-        visitor: &amp;NormalizedVisitor&lt;'db&gt;,
-    ) -&gt; Self {
-        Field {
-            kind: self.kind.clone(),
-            first_declaration: None,
-            declared_ty: self.declared_ty.normalized_impl(db, visitor),
-        }
-    }
-
     /// Returns true if this field is a `dataclasses.KW_ONLY` sentinel.
     /// &lt;https://docs.python.org/3/library/dataclasses.html#dataclasses.KW_ONLY&gt;
     pub(crate) fn is_kw_only_sentinel(&amp;self, db: &amp;'db dyn Db) -&gt; bool {
diff --git a/crates/ty_python_semantic/src/types/diagnostic.rs b/crates/ty_python_semantic/src/types/diagnostic.rs
index bf32c6aa7f..23bb5b1a16 100644
--- a/crates/ty_python_semantic/src/types/diagnostic.rs
+++ b/crates/ty_python_semantic/src/types/diagnostic.rs
@@ -14,9 +14,7 @@ use crate::semantic_index::place::{PlaceTable, ScopedPlaceId};
 use crate::semantic_index::{global_scope, place_table, use_def_map};
 use crate::suppression::FileSuppressionId;
 use crate::types::call::CallError;
-use crate::types::class::{
-    CodeGeneratorKind, DisjointBase, DisjointBaseKind, Field, MethodDecorator,
-};
+use crate::types::class::{CodeGeneratorKind, DisjointBase, DisjointBaseKind, MethodDecorator};
 use crate::types::function::{FunctionDecorators, FunctionType, KnownFunction, OverloadLiteral};
 use crate::types::infer::UnsupportedComparisonError;
 use crate::types::overrides::MethodKind;
@@ -26,15 +24,14 @@ use crate::types::string_annotation::{
     RAW_STRING_TYPE_ANNOTATION,
 };
 use crate::types::tuple::TupleSpec;
+use crate::types::typed_dict::TypedDictSchema;
 use crate::types::{
     BoundTypeVarInstance, ClassType, DynamicType, LintDiagnosticGuard, Protocol,
     ProtocolInstanceType, SpecialFormType, SubclassOfInner, Type, TypeContext, binding_type,
     protocol_class::ProtocolClass,
 };
 use crate::types::{KnownInstanceType, MemberLookupPolicy};
-use crate::{
-    Db, DisplaySettings, FxIndexMap, FxOrderMap, Module, ModuleName, Program, declare_lint,
-};
+use crate::{Db, DisplaySettings, FxIndexMap, Module, ModuleName, Program, declare_lint};
 use itertools::Itertools;
 use ruff_db::{
     diagnostic::{Annotation, Diagnostic, Span, SubDiagnostic, SubDiagnosticSeverity},
@@ -3473,7 +3470,7 @@ pub(crate) fn report_invalid_key_on_typed_dict&lt;'db&gt;(
     typed_dict_ty: Type&lt;'db&gt;,
     full_object_ty: Option&lt;Type&lt;'db&gt;&gt;,
     key_ty: Type&lt;'db&gt;,
-    items: &amp;FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;,
+    items: &amp;TypedDictSchema&lt;'db&gt;,
 ) {
     let db = context.db();
     if let Some(builder) = context.report_lint(&amp;INVALID_KEY, key_node) {
diff --git a/crates/ty_python_semantic/src/types/display.rs b/crates/ty_python_semantic/src/types/display.rs
index db6a8b6e37..f7ce65834e 100644
--- a/crates/ty_python_semantic/src/types/display.rs
+++ b/crates/ty_python_semantic/src/types/display.rs
@@ -2382,14 +2382,15 @@ mod tests {
     use insta::assert_snapshot;
     use ruff_python_ast::name::Name;
 
+    use crate::Db;
     use crate::db::tests::setup_db;
     use crate::place::typing_extensions_symbol;
-    use crate::types::class::{Field, FieldKind};
-    use crate::types::typed_dict::SynthesizedTypedDictType;
+    use crate::types::typed_dict::{
+        SynthesizedTypedDictType, TypedDictFieldBuilder, TypedDictSchema,
+    };
     use crate::types::{
-        KnownClass, Parameter, Parameters, Signature, StringLiteralType, Type, TypedDictType,
+        KnownClass, Parameter, Parameters, Signature, Type, TypedDictType,
     };
-    use crate::{Db, FxOrderMap};
 
     #[test]
     fn string_literal_display() {
@@ -2438,28 +2439,18 @@ mod tests {
     fn synthesized_typeddict_display() {
         let db = setup_db();
 
-        let mut items = FxOrderMap::default();
+        let mut items = TypedDictSchema::default();
         items.insert(
             Name::new(&quot;foo&quot;),
-            Field {
-                declared_ty: Type::IntLiteral(42),
-                kind: FieldKind::TypedDict {
-                    is_required: true,
-                    is_read_only: false,
-                },
-                first_declaration: None,
-            },
+            TypedDictFieldBuilder::new(Type::IntLiteral(42))
+                .required(true)
+                .build(),
         );
         items.insert(
             Name::new(&quot;bar&quot;),
-            Field {
-                declared_ty: Type::StringLiteral(StringLiteralType::new(&amp;db, &quot;hello&quot;)),
-                kind: FieldKind::TypedDict {
-                    is_required: true,
-                    is_read_only: false,
-                },
-                first_declaration: None,
-            },
+            TypedDictFieldBuilder::new(Type::string_literal(&amp;db, &quot;hello&quot;))
+                .required(true)
+                .build(),
         );
 
         let synthesized = SynthesizedTypedDictType::new(&amp;db, items);
diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index a3be4fb05a..d0ae2f0bde 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -1,3 +1,6 @@
+use std::collections::BTreeMap;
+use std::ops::{Deref, DerefMut};
+
 use bitflags::bitflags;
 use ruff_db::diagnostic::{Annotation, Diagnostic, Span, SubDiagnostic, SubDiagnosticSeverity};
 use ruff_db::parsed::parsed_module;
@@ -12,14 +15,15 @@ use super::diagnostic::{
     report_missing_typed_dict_key,
 };
 use super::{ApplyTypeMappingVisitor, Type, TypeMapping, visitor};
+use crate::Db;
 use crate::semantic_index::definition::Definition;
+use crate::types::class::FieldKind;
 use crate::types::constraints::ConstraintSet;
 use crate::types::generics::InferableTypeVars;
 use crate::types::{
     HasRelationToVisitor, IsDisjointVisitor, IsEquivalentVisitor, NormalizedVisitor, TypeContext,
     TypeRelation,
 };
-use crate::{Db, FxOrderMap};
 
 use ordermap::OrderSet;
 
@@ -66,12 +70,37 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
         }
     }
 
-    pub(crate) fn items(self, db: &amp;'db dyn Db) -&gt; &amp;'db FxOrderMap&lt;Name, Field&lt;'db&gt;&gt; {
+    pub(crate) fn items(self, db: &amp;'db dyn Db) -&gt; &amp;'db TypedDictSchema&lt;'db&gt; {
+        #[salsa::tracked(returns(ref))]
+        fn class_based_items&lt;'db&gt;(db: &amp;'db dyn Db, class: ClassType&lt;'db&gt;) -&gt; TypedDictSchema&lt;'db&gt; {
+            let (class_literal, specialization) = class.class_literal(db);
+            class_literal
+                .fields(db, specialization, CodeGeneratorKind::TypedDict)
+                .into_iter()
+                .map(|(name, field)| {
+                    let field = match field {
+                        Field {
+                            first_declaration,
+                            declared_ty,
+                            kind:
+                                FieldKind::TypedDict {
+                                    is_required,
+                                    is_read_only,
+                                },
+                        } =&gt; TypedDictFieldBuilder::new(*declared_ty)
+                            .required(*is_required)
+                            .read_only(*is_read_only)
+                            .first_declaration(*first_declaration)
+                            .build(),
+                        _ =&gt; unreachable!(&quot;TypedDict field expected&quot;),
+                    };
+                    (name.clone(), field)
+                })
+                .collect()
+        }
+
         match self {
-            Self::Class(defining_class) =&gt; {
-                let (class_literal, specialization) = defining_class.class_literal(db);
-                class_literal.fields(db, specialization, CodeGeneratorKind::TypedDict)
-            }
+            Self::Class(defining_class) =&gt; class_based_items(db, defining_class),
             Self::Synthesized(synthesized) =&gt; synthesized.items(db),
         }
     }
@@ -303,7 +332,7 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
             let Some(other_field) = other_items.get(name) else {
                 return ConstraintSet::from(false);
             };
-            if field.kind != other_field.kind {
+            if field.flags != other_field.flags {
                 return ConstraintSet::from(false);
             }
             constraints.intersect(
@@ -716,11 +745,11 @@ pub(super) fn validate_typed_dict_dict_literal&lt;'db&gt;(
     }
 }
 
-#[salsa::interned(debug, heap_size=SynthesizedTypedDictType::heap_size)]
+#[salsa::interned(debug)]
 #[derive(PartialOrd, Ord)]
 pub struct SynthesizedTypedDictType&lt;'db&gt; {
     #[returns(ref)]
-    pub(crate) items: FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;,
+    pub(crate) items: TypedDictSchema&lt;'db&gt;,
 }
 
 // The Salsa heap is tracked separately.
@@ -744,26 +773,145 @@ impl&lt;'db&gt; SynthesizedTypedDictType&lt;'db&gt; {
 
                 (name.clone(), field)
             })
-            .collect::&lt;FxOrderMap&lt;_, _&gt;&gt;();
+            .collect::&lt;TypedDictSchema&lt;'db&gt;&gt;();
 
         SynthesizedTypedDictType::new(db, items)
     }
 
     pub(crate) fn normalized_impl(self, db: &amp;'db dyn Db, visitor: &amp;NormalizedVisitor&lt;'db&gt;) -&gt; Self {
-        let mut items = self
+        let items = self
             .items(db)
             .iter()
             .map(|(name, field)| {
                 let field = field.clone().normalized_impl(db, visitor);
                 (name.clone(), field)
             })
-            .collect::&lt;FxOrderMap&lt;_, _&gt;&gt;();
-        // `Hash`/`Eq` for `FxOrderMap` includes the key order, so we need to sort.
-        items.sort_unstable_keys();
+            .collect::&lt;TypedDictSchema&lt;'db&gt;&gt;();
         Self::new(db, items)
     }
+}
+
+#[derive(Debug, Clone, PartialEq, Eq, Hash, Default, get_size2::GetSize, salsa::Update)]
+pub struct TypedDictSchema&lt;'db&gt;(BTreeMap&lt;Name, TypedDictField&lt;'db&gt;&gt;);
+
+impl&lt;'db&gt; Deref for TypedDictSchema&lt;'db&gt; {
+    type Target = BTreeMap&lt;Name, TypedDictField&lt;'db&gt;&gt;;
+
+    fn deref(&amp;self) -&gt; &amp;Self::Target {
+        &amp;self.0
+    }
+}
+
+impl DerefMut for TypedDictSchema&lt;'_&gt; {
+    fn deref_mut(&amp;mut self) -&gt; &amp;mut Self::Target {
+        &amp;mut self.0
+    }
+}
+
+impl&lt;'a&gt; IntoIterator for &amp;'a TypedDictSchema&lt;'_&gt; {
+    type Item = (&amp;'a Name, &amp;'a TypedDictField&lt;'a&gt;);
+    type IntoIter = std::collections::btree_map::Iter&lt;'a, Name, TypedDictField&lt;'a&gt;&gt;;
+
+    fn into_iter(self) -&gt; Self::IntoIter {
+        self.0.iter()
+    }
+}
+
+impl&lt;'db&gt; FromIterator&lt;(Name, TypedDictField&lt;'db&gt;)&gt; for TypedDictSchema&lt;'db&gt; {
+    fn from_iter&lt;T: IntoIterator&lt;Item = (Name, TypedDictField&lt;'db&gt;)&gt;&gt;(iter: T) -&gt; Self {
+        Self(iter.into_iter().collect())
+    }
+}
+
+#[derive(Debug, Clone, PartialEq, Eq, Hash, get_size2::GetSize, salsa::Update)]
+pub struct TypedDictField&lt;'db&gt; {
+    pub(super) declared_ty: Type&lt;'db&gt;,
+    flags: TypedDictFieldFlags,
+    first_declaration: Option&lt;Definition&lt;'db&gt;&gt;,
+}
+
+impl&lt;'db&gt; TypedDictField&lt;'db&gt; {
+    pub(crate) const fn is_required(&amp;self) -&gt; bool {
+        self.flags.contains(TypedDictFieldFlags::REQUIRED)
+    }
+
+    pub(crate) const fn is_read_only(&amp;self) -&gt; bool {
+        self.flags.contains(TypedDictFieldFlags::READ_ONLY)
+    }
+
+    pub(crate) fn apply_type_mapping_impl&lt;'a&gt;(
+        self,
+        db: &amp;'db dyn Db,
+        type_mapping: &amp;TypeMapping&lt;'a, 'db&gt;,
+        tcx: TypeContext&lt;'db&gt;,
+        visitor: &amp;ApplyTypeMappingVisitor&lt;'db&gt;,
+    ) -&gt; Self {
+        Self {
+            declared_ty: self
+                .declared_ty
+                .apply_type_mapping_impl(db, type_mapping, tcx, visitor),
+            flags: self.flags,
+            first_declaration: self.first_declaration,
+        }
+    }
+
+    pub(crate) fn normalized_impl(self, db: &amp;'db dyn Db, visitor: &amp;NormalizedVisitor&lt;'db&gt;) -&gt; Self {
+        Self {
+            declared_ty: self.declared_ty.normalized_impl(db, visitor),
+            flags: self.flags,
+            // A normalized typed-dict field does not hold onto the original declaration,
+            // since a normalized typed-dict is an abstract type where equality does not depend
+            // on the source-code definition.
+            first_declaration: None,
+        }
+    }
+}
+
+pub(super) struct TypedDictFieldBuilder&lt;'db&gt; {
+    declared_ty: Type&lt;'db&gt;,
+    flags: TypedDictFieldFlags,
+    first_declaration: Option&lt;Definition&lt;'db&gt;&gt;,
+}
+
+impl&lt;'db&gt; TypedDictFieldBuilder&lt;'db&gt; {
+    pub(crate) fn new(declared_ty: Type&lt;'db&gt;) -&gt; Self {
+        Self {
+            declared_ty,
+            flags: TypedDictFieldFlags::empty(),
+            first_declaration: None,
+        }
+    }
+
+    pub(crate) fn required(mut self, yes: bool) -&gt; Self {
+        self.flags.set(TypedDictFieldFlags::REQUIRED, yes);
+        self
+    }
+
+    pub(crate) fn read_only(mut self, yes: bool) -&gt; Self {
+        self.flags.set(TypedDictFieldFlags::READ_ONLY, yes);
+        self
+    }
 
-    fn heap_size((items,): &amp;(FxOrderMap&lt;Name, Field&lt;'db&gt;&gt;,)) -&gt; usize {
-        ruff_memory_usage::order_map_heap_size(items)
+    pub(crate) fn first_declaration(mut self, definition: Option&lt;Definition&lt;'db&gt;&gt;) -&gt; Self {
+        self.first_declaration = definition;
+        self
+    }
+
+    pub(crate) fn build(self) -&gt; TypedDictField&lt;'db&gt; {
+        TypedDictField {
+            declared_ty: self.declared_ty,
+            flags: self.flags,
+            first_declaration: self.first_declaration,
+        }
     }
 }
+
+bitflags! {
+    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, salsa::Update)]
+    struct TypedDictFieldFlags: u8 {
+        const REQUIRED = 1 &lt;&lt; 0;
+        const READ_ONLY = 1 &lt;&lt; 1;
+    }
+}
+
+impl get_size2::GetSize for TypedDictFieldFlags {}
</code></pre>
</details>

<p>It also feels like it would be more strongly typed, since we <em>know</em> that <code>field.kind</code> won't ever be a <code>FieldKind::Dataclass</code> or <code>FieldKind::NamedTuple</code> in the context of the map returned by <code>TypedDictType::items()</code>, but that isn't currently reflected by the type that the method returns.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/function.rs</code>:1626 on 2025-12-07 15:06</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">                        let source_display = source_type.display(db).to_string();
                        let casted_display = casted_type.display(db).to_string();
                        let mut diagnostic = builder.into_diagnostic(format_args!(
                            &quot;Value is already of type `{casted_display}`&quot;,
                        ));
                        if source_display != casted_display {
                            diagnostic.info(format_args!(
                                &quot;`{casted_display}` is equivalent to `{source_display}`&quot;,
                            ));
                        }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:305 on 2025-12-07 15:07</div>
            <div class="timeline-body"><p>I think this is fine</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:322 on 2025-12-07 15:11</div>
            <div class="timeline-body"><p>nit: you could do this a bit more concisely if you imported the <code>IteratorConstraintsExtension</code> trait:</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index a3be4fb05a..9aa2c9a4ac 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -13,7 +13,7 @@ use super::diagnostic::{
 };
 use super::{ApplyTypeMappingVisitor, Type, TypeMapping, visitor};
 use crate::semantic_index::definition::Definition;
-use crate::types::constraints::ConstraintSet;
+use crate::types::constraints::{ConstraintSet, IteratorConstraintsExtension};
 use crate::types::generics::InferableTypeVars;
 use crate::types::{
     HasRelationToVisitor, IsDisjointVisitor, IsEquivalentVisitor, NormalizedVisitor, TypeContext,
@@ -298,28 +298,17 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
             return ConstraintSet::from(false);
         }
         let other_items = other.items(db);
-        let mut constraints = ConstraintSet::from(true);
-        for (name, field) in self.items(db) {
+        self.items(db).iter().when_all(db, |(name, field)| {
             let Some(other_field) = other_items.get(name) else {
                 return ConstraintSet::from(false);
             };
             if field.kind != other_field.kind {
                 return ConstraintSet::from(false);
             }
-            constraints.intersect(
-                db,
-                field.declared_ty.is_equivalent_to_impl(
-                    db,
-                    other_field.declared_ty,
-                    inferable,
-                    visitor,
-                ),
-            );
-            if constraints.is_never_satisfied(db) {
-                return constraints;
-            }
-        }
-        constraints
+            field
+                .declared_ty
+                .is_equivalent_to_impl(db, other_field.declared_ty, inferable, visitor)
+        })
     }
 }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1 on 2025-12-07 15:12</div>
            <div class="timeline-body"><p>Could you add a few tests that involve recursive TypedDicts?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-12-07 15:12</div>
            <div class="timeline-body"><p>Thank you!! LGTM, though I'd still love it if we could figure out why the big pydantic regression is occurring</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @sharkdp removed by @sharkdp on 2025-12-08 09:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-08 19:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:325 on 2025-12-08 19:51</div>
            <div class="timeline-body"><p>Ah this is definitely a lot cleaner. And again #20732 did something similar: https://github.com/astral-sh/ruff/pull/20732/files#diff-2f6787010a635a3508de77c9d28673b9d281045bd33cb5bda175d35b0a74120cR387</p>
<p>Out of curiosity, why provide <code>TypedDictFieldBuilder</code>? It seems pretty straightforward to construct a <code>TypedDictField</code> in place. (Edit: Oh now I see it, it makes things things shorter in <code>display.rs</code> tests.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:325 on 2025-12-08 20:04</div>
            <div class="timeline-body"><p>a7dd59ab88</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-08 20:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-08 20:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:322 on 2025-12-08 20:08</div>
            <div class="timeline-body"><p>neato</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-08 20:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1 on 2025-12-08 20:26</div>
            <div class="timeline-body"><p>Interesting, direct recursion works fine, but recursion via <code>list[]</code> crashes...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-08 20:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1 on 2025-12-08 20:41</div>
            <div class="timeline-body"><p>Looks like it was just a missing <code>visit</code> call: 1c05f28472</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-08 21:49</div>
            <div class="timeline-body"><p>I think the updates to the Cargo.toml/Cargo.lock files are probably not necessary with the latest version of this PR? They're obviously harmless, but they could probably be a standalone change at this point</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-08 21:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1 on 2025-12-08 21:49</div>
            <div class="timeline-body"><p>Nice, that looks correct!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-08 22:47</div>
            <div class="timeline-body"><blockquote>
<p>I think the updates to the Cargo.toml/Cargo.lock files are probably not necessary with the latest version of this PR? They're obviously harmless, but they could probably be a standalone change at this point</p>
</blockquote>
<p>There are still a few places in <code>class.rs</code> where this PR changes <code>IndexMap</code> -&gt; <code>OrderMap</code>, which depends on the <code>Cargo.toml</code> bumps. This PR no longer requires those changes after your patch, but we've also said (or at least Ibraheem said?) that would generally prefer to switch to <code>OrderMap</code>, so I've split all that out into a separate PR: https://github.com/astral-sh/ruff/pull/21854</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-09 01:59</div>
            <div class="timeline-body"><p>Some notes from digging into the performance regression today:</p>
<p>It's definitely our old friend <code>CoreSchema</code>, the gigantic <code>TypedDict</code> union. Not very surprising. One of the files affected in this particular PR is <a href="https://github.com/pydantic/pydantic/blob/main/pydantic/functional_serializers.py"><code>functional_serializers.py</code></a>, which typechecks in ~0.05s on <code>main</code> and ~1s on this branch. I can shrink that entire file down to this while still preserving most of that gap:</p>
<pre><code class="language-py">from pydantic_core.core_schema import CoreSchema

def foo(core_schema: CoreSchema):
    core_schema.copy()
</code></pre>
<p>I'm not sure why <code>.copy()</code> in particular would be affected by these changes?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-09 02:46</div>
            <div class="timeline-body"><p>Can you profile main vs this branch checking that minimized example (e.g. using <code>samply record</code>)? With that big a difference in runtime, I would think the more-precise location of the extra time spent should jump out (and the stacks should help clarify from where we are calling the newly-expensive function).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-09 19:01</div>
            <div class="timeline-body"><p>I already shared this with @oconnor663 but for broader visibility:</p>
<ul>
<li>Here's my profile https://share.firefox.dev/4pzdJ0u</li>
<li>What stands out is that we spend a significant amount within <code>Eq</code> and <code>Hash</code> that we didn't before. We call <code>Eq</code> a lot within <code>UnionBuilder</code> and <code>Hash</code> in <code>normalize_impl</code> (because we intern the value).</li>
</ul>
<p>I'm not aware of any tricks to make either of those magically go away, but some of our typing wizards may do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-09 19:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:305 on 2025-12-09 19:17</div>
            <div class="timeline-body"><p>An alternative that might be worth here is to cache <code>synthesized instead of </code>self.items()` like this</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index 89ef0016f1..0a3f2f9cdd 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -71,36 +71,10 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
     }
 
     pub(crate) fn items(self, db: &amp;'db dyn Db) -&gt; &amp;'db TypedDictSchema&lt;'db&gt; {
-        #[salsa::tracked(returns(ref))]
-        fn class_based_items&lt;'db&gt;(db: &amp;'db dyn Db, class: ClassType&lt;'db&gt;) -&gt; TypedDictSchema&lt;'db&gt; {
-            let (class_literal, specialization) = class.class_literal(db);
-            class_literal
-                .fields(db, specialization, CodeGeneratorKind::TypedDict)
-                .into_iter()
-                .map(|(name, field)| {
-                    let field = match field {
-                        Field {
-                            first_declaration,
-                            declared_ty,
-                            kind:
-                                FieldKind::TypedDict {
-                                    is_required,
-                                    is_read_only,
-                                },
-                        } =&gt; TypedDictFieldBuilder::new(*declared_ty)
-                            .required(*is_required)
-                            .read_only(*is_read_only)
-                            .first_declaration(*first_declaration)
-                            .build(),
-                        _ =&gt; unreachable!(&quot;TypedDict field expected&quot;),
-                    };
-                    (name.clone(), field)
-                })
-                .collect()
-        }
-
         match self {
-            Self::Class(defining_class) =&gt; class_based_items(db, defining_class),
+            Self::Class(defining_class) =&gt; {
+                SynthesizedTypedDictType::for_class(db, defining_class).items(db)
+            }
             Self::Synthesized(synthesized) =&gt; synthesized.items(db),
         }
     }
@@ -300,8 +274,8 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
 
     pub(crate) fn normalized_impl(self, db: &amp;'db dyn Db, visitor: &amp;NormalizedVisitor&lt;'db&gt;) -&gt; Self {
         match self {
-            TypedDictType::Class(_) =&gt; {
-                let synthesized = SynthesizedTypedDictType::new(db, self.items(db));
+            TypedDictType::Class(class) =&gt; {
+                let synthesized = SynthesizedTypedDictType::for_class(db, class);
                 TypedDictType::Synthesized(synthesized.normalized_impl(db, visitor))
             }
             TypedDictType::Synthesized(synthesized) =&gt; {
@@ -323,11 +297,13 @@ impl&lt;'db&gt; TypedDictType&lt;'db&gt; {
         // Compare the fields without requiring them to be in sorted order. Class-based `TypedDict`
         // fields are not sorted. We do sort synthetic fields in `normalized_impl`, but there will
         // soon be other sources of `SynthesizedTypedDictType` besides normalization.
-        if self.items(db).len() != other.items(db).len() {
+        let self_items = self.items(db);
+        let other_items = other.items(db);
+        if self_items.len() != other_items.len() {
             return ConstraintSet::from(false);
         }
-        let other_items = other.items(db);
-        self.items(db).iter().when_all(db, |(name, field)| {
+
+        self_items.iter().when_all(db, |(name, field)| {
             let Some(other_field) = other_items.get(name) else {
                 return ConstraintSet::from(false);
             };
@@ -744,7 +720,37 @@ pub struct SynthesizedTypedDictType&lt;'db&gt; {
 // The Salsa heap is tracked separately.
 impl get_size2::GetSize for SynthesizedTypedDictType&lt;'_&gt; {}
 
+#[salsa::tracked]
 impl&lt;'db&gt; SynthesizedTypedDictType&lt;'db&gt; {
+    #[salsa::tracked]
+    fn for_class(db: &amp;'db dyn Db, class: ClassType&lt;'db&gt;) -&gt; SynthesizedTypedDictType&lt;'db&gt; {
+        let (class_literal, specialization) = class.class_literal(db);
+        let items: TypedDictSchema&lt;'db&gt; = class_literal
+            .fields(db, specialization, CodeGeneratorKind::TypedDict)
+            .into_iter()
+            .map(|(name, field)| {
+                let field = match field {
+                    Field {
+                        first_declaration,
+                        declared_ty,
+                        kind:
+                            FieldKind::TypedDict {
+                                is_required,
+                                is_read_only,
+                            },
+                    } =&gt; TypedDictFieldBuilder::new(*declared_ty)
+                        .required(*is_required)
+                        .read_only(*is_read_only)
+                        .first_declaration(*first_declaration)
+                        .build(),
+                    _ =&gt; unreachable!(&quot;TypedDict field expected&quot;),
+                };
+                (name.clone(), field)
+            })
+            .collect();
+        SynthesizedTypedDictType::new(db, items)
+    }
+
     pub(super) fn apply_type_mapping_impl&lt;'a&gt;(
         self,
         db: &amp;'db dyn Db,
@@ -768,15 +774,20 @@ impl&lt;'db&gt; SynthesizedTypedDictType&lt;'db&gt; {
     }
 
     pub(crate) fn normalized_impl(self, db: &amp;'db dyn Db, visitor: &amp;NormalizedVisitor&lt;'db&gt;) -&gt; Self {
+        let mut changed = false;
         let items = self
             .items(db)
             .iter()
             .map(|(name, field)| {
-                let field = field.clone().normalized_impl(db, visitor);
-                (name.clone(), field)
+                let new_field = field.clone().normalized_impl(db, visitor);
+                if !changed &amp;&amp; &amp;new_field != field {
+                    changed = true;
+                }
+                (name.clone(), new_field)
             })
             .collect::&lt;TypedDictSchema&lt;'db&gt;&gt;();
-        Self::new(db, items)
+
+        if changed { Self::new(db, items) } else { self }
     }
 }
 
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-09 19:35</div>
            <div class="timeline-body"><p>@MichaReiser + @AlexWaygood, thanks for chatting up a storm with me this morning. Here's something more I've noticed staring at all our profiles. The reduced <code>copy()</code> example above spends ~all of its time inside of <code>BoundMethodType::has_relation_to_impl</code>. Two things jump out at me about that:</p>
<ul>
<li>That methods recurses on both the function/method type being called, and on the receiver object. Given that <code>CoreSchema</code> shows up on both sides of that, that could be part of why we're blowing up here?</li>
<li>The function/method side of that immediately calls <code>normalize</code> in the <code>Redundancy</code> case.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-09 19:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:340 on 2025-12-09 19:40</div>
            <div class="timeline-body"><p>I don't think this will change performance much but you could make use of the fact that you have two <code>BTreeMap</code> where both should return the keys in the same order if they have the same fields:</p>
<pre><code class="language-suggestion">        let mut other_items_iter = other_items.iter();

        self_items.iter().when_all(db, |(name, field)| {
            let Some((other_name, other_field)) = other_items_iter.next() else {
                return ConstraintSet::from(false);
            };

            if name != other_name || field.flags != other_field.flags {
                return ConstraintSet::from(false);
            }
            field
                .declared_ty
                .is_equivalent_to_impl(db, other_field.declared_ty, inferable, visitor)
        })
</code></pre>
<p>Doing the same in <code>has_relation_to</code> seems a bit trickier and would require <code>peek_if</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-12-09 19:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:340 on 2025-12-09 19:59</div>
            <div class="timeline-body"><p>This is how you could do the same in <code>has_relation_to</code> but it's a bit trickier:</p>
<pre><code class="language-rust">let mut self_items_iter = self_items.iter().peekable();

        for (target_item_name, target_item_field) in target_items {
            // Skip over preceeding fields.
            let _ = {
                self_items_iter
                    .peeking_take_while(|(name, _)| *name &lt; target_item_name)
                    .last()
            };
            let self_item_field = self_items_iter
                .peeking_next(|(name, _)| *name == target_item_name)
                .map(|(_, field)| field);
</code></pre>
<p>or use <code>Itertools::merge_by</code></p>
<pre><code class="language-rust">for pair in a.iter().merge_join_by(b.iter(), |(k1, _), (k2, _)| k1.cmp(k2)) {
    match pair {
        EitherOrBoth::Both((k, v1), (_, v2)) =&gt; {
            // Key exists in both maps
        }
        EitherOrBoth::Left((k, v1)) =&gt; {
            // Only in `a`
        }
        EitherOrBoth::Right((k, v2)) =&gt; {
            // Only in `b`
        }
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-09 20:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:340 on 2025-12-09 20:20</div>
            <div class="timeline-body"><p>Yes (to the first diff above), and the comment here about not being in sorted order is entirely wrong now :) I think since we're doing a length check up front, we can go ahead and <code>zip</code> the iterators, which is a little shorter: 3e5b534c9a64e1a5a09b0ae57b7ca2695849af72</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-09 20:58</div>
            <div class="timeline-body"><ul>
<li>Moving the <code>TypedDictType</code> special case as early as possible in <code>UnionBuilder::push_type</code> doesn't make a difference here.</li>
<li>Caching the conversion from class-based to synthetic typeddict saves 10% here in this most pathological case, but it doesn't close the bulk of the gap. As far as I know, I can't cache normalized_impl directly (which is what I'd really prefer to do), because of the visitor it takes.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-10 18:11</div>
            <div class="timeline-body"><p>I've pushed an <code>EXPERIMENTAL COMMIT</code> which I don't intend to actually land, which deletes the call to <code>normalized</code> that I think is at the heart of this PR's regression:</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/function.rs b/crates/ty_python_semantic/src/types/function.rs
index 421504e09b..9bf73f116d 100644
--- a/crates/ty_python_semantic/src/types/function.rs
+++ b/crates/ty_python_semantic/src/types/function.rs
@@ -1022,30 +1022,18 @@ impl&lt;'db&gt; FunctionType&lt;'db&gt; {
     pub(crate) fn has_relation_to_impl(
         self,
         db: &amp;'db dyn Db,
         other: Self,
         inferable: InferableTypeVars&lt;'_, 'db&gt;,
         relation: TypeRelation&lt;'db&gt;,
         relation_visitor: &amp;HasRelationToVisitor&lt;'db&gt;,
         disjointness_visitor: &amp;IsDisjointVisitor&lt;'db&gt;,
     ) -&gt; ConstraintSet&lt;'db&gt; {
-        // A function type is the subtype of itself, and not of any other function type. However,
-        // our representation of a function type includes any specialization that should be applied
-        // to the signature. Different specializations of the same function type are only subtypes
-        // of each other if they result in subtype signatures.
-        if matches!(
-            relation,
-            TypeRelation::Subtyping | TypeRelation::Redundancy | TypeRelation::SubtypingAssuming(_)
-        ) &amp;&amp; self.normalized(db) == other.normalized(db)
-        {
-            return ConstraintSet::from(true);
-        }
-
         if self.literal(db) != other.literal(db) {
             return ConstraintSet::from(false);
         }
</code></pre>
<p>This does seem to fix the perf regression (and not break tests) locally. I'm curious to see what CodSpeed says. If CodSpeed is green, I will probably land this PR as-is (reverting this experimental commit of course) and fork off an issue to track this regression.</p>
<p>(btw I'm sure there's a more direct way to run CodSpeed on a random branch, either locally or in the cloud, so if anyone knows the non-dumb workflow for this please do let me know)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:740 on 2025-12-10 18:37</div>
            <div class="timeline-body"><p>Nit: for most other salsa-interned structs where we derive Ord, we add a note like this one here: https://github.com/astral-sh/ruff/blob/f7528bd325e20205facad414cf8462e922bbffa8/crates/ty_python_semantic/src/types.rs#L8652</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:1 on 2025-12-10 18:38</div>
            <div class="timeline-body"><p>Nit: are the new <code>Hash</code> derives in this file still necessary on the latest version of this PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-12-10 18:39</div>
            <div class="timeline-body"><p>The performance experiment looks like it was pretty successful to me!! It totally solved the regression and had zero impact on both our test suite and the primer report for this PR. Great job üòÉ</p>
<p>This looks ready to go now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-10 19:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:305 on 2025-12-10 19:47</div>
            <div class="timeline-body"><p>My intuition is that normal code (read: not Pydantic) is going to spend more time looking up the <code>.items()</code> of regular class-based <code>TypedDict</code>s than it spends normalizing, so caching <code>.items()</code> makes sense to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-10 19:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:740 on 2025-12-10 19:55</div>
            <div class="timeline-body"><p>These derives were no longer necessary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-10 19:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/class.rs</code>:1 on 2025-12-10 19:55</div>
            <div class="timeline-body"><p>I ended up reverting <em>all</em> the changes in <code>class.rs</code> :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-10 19:57</div>
            <div class="timeline-body"><p>If the &quot;experimental&quot; commit fixed the pydantic regression and didn't add regressions anywhere else (which is what it looks like to me in CodSpeed), then I don't see any reason to revert that change here or wait for later to re-evaluate in https://github.com/astral-sh/ty/issues/1845 -- I think we should just include that change in this PR. What's the downside?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-10 20:03</div>
            <div class="timeline-body"><blockquote>
<p>(btw I'm sure there's a more direct way to run CodSpeed on a random branch, either locally or in the cloud, so if anyone knows the non-dumb workflow for this please do let me know)</p>
</blockquote>
<p>AFAIK you have to make a PR, but it could be a separate draft PR (possibly based on an existing PR) if you want to &quot;hide&quot; it more.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-10 20:06</div>
            <div class="timeline-body"><blockquote>
<p>If the &quot;experimental&quot; commit fixed the pydantic regression and didn't add regressions anywhere else (which is what it looks like to me in CodSpeed), then I don't see any reason to revert that change here or wait for later to re-evaluate in <a href="https://github.com/astral-sh/ty/issues/1845">astral-sh/ty#1845</a> -- I think we should just include that change in this PR. What's the downside?</p>
</blockquote>
<p>Wait, yeah, same comment! Why revert a successful experiment? If we don't introduce a performance regression in the first place, there's no need to create a followup issue. It seemed like that commit had zero downsides!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @oconnor663 on 2025-12-10 20:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @oconnor663 on 2025-12-10 20:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-12-10 20:36</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:17:49 UTC
    </footer>
</body>
</html>
