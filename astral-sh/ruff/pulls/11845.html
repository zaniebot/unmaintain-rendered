<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement re-lexing logic for better error recovery - astral-sh/ruff #11845</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement re-lexing logic for better error recovery</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/11845">#11845</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2024-06-12 06:34
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR implements the re-lexing logic in the parser.</p>
<p>This logic is only applied when recovering from an error during list parsing. The logic is as follows:</p>
<ol>
<li>During list parsing, if an unexpected token is encountered and it detects that an outer context can understand it and thus recover from it, it invokes the re-lexing logic in the lexer</li>
<li>This logic first checks if the lexer is in a parenthesized context and returns if it's not. Thus, the logic is a no-op if the lexer isn't in a parenthesized context</li>
<li>It then reduces the nesting level by 1. It shouldn't reset it to 0 because otherwise the recovery from nested list parsing will be incorrect</li>
<li>Then, it tries to find last newline character going backwards from the current position of the lexer. This avoids any whitespaces but if it encounters any character other than newline or whitespace, it aborts.</li>
<li>Now, if there's a newline character, then it needs to be re-lexed in a logical context which means that the lexer needs to emit it as a <code>Newline</code> token instead of <code>NonLogicalNewline</code>.</li>
<li>If the re-lexing gives a different token than the current one, the token source needs to update it's token collection to remove all the tokens which comes after the new current position.</li>
</ol>
<p>It turns out that the list parsing isn't that happy with the results so it requires some re-arranging such that the following two errors are raised correctly:</p>
<ol>
<li>Expected comma</li>
<li>Recovery context error</li>
</ol>
<p>For (1), the following scenarios needs to be considered:</p>
<ul>
<li>Missing comma between two elements</li>
<li>Half parsed element because the grammar doesn't allow it (for example, named expressions)</li>
</ul>
<p>For (2), the following scenarios needs to be considered:</p>
<ol>
<li>If the parser is at a comma which means that there's a missing element otherwise the comma would've been consumed by the first <code>eat</code> call above. And, the parser doesn't take the re-lexing route on a comma token.</li>
<li>If it's the first element and the current token is not a comma which means that it's an invalid element.</li>
</ol>
<p>resolves: #11640</p>
<h2>Test Plan</h2>
<ul>
<li>[x] Update existing test snapshots and validate them</li>
<li>[x] Add additional test cases specific to the re-lexing logic and validate the snapshots</li>
<li>[x] Run the fuzzer on 3000+ valid inputs</li>
<li>[x] Run the fuzzer on invalid inputs</li>
<li>[x] Run the parser on various open source projects</li>
<li>[x] Make sure the ecosystem changes are none</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">parser</span> added by @dhruvmanila on 2024-06-12 06:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-12 06:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/tests/snapshots/invalid_syntax@from_import_missing_rpar.py.snap</code>:145 on 2024-06-12 06:45</div>
            <div class="timeline-body"><p>Woah, this is so much better. Nice!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-06-12 09:00</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dhruvmanila on 2024-06-12 17:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-13 06:25</div>
            <div class="timeline-body"><blockquote>
<p>It then reduces the nesting level by 1. It shouldn't reset it to 0 because otherwise the recovery from nested list parsing will be incorrect</p>
</blockquote>
<p>What happens if we have something like</p>
<pre><code class="language-python(a,">c
)
</code></pre>
<p>In this case, the parser should recover from the unclosed <code>[</code>, but the parser and lexer should remain in a parenthesied context because of the <code>(</code>. Or does that work out of the box already, because <code>)</code> is a list terminator, and the parser won't recover past it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1371 on 2024-06-13 06:27</div>
            <div class="timeline-body"><p>Should the below logic run when the nesting level remains greater than one? I woudl expect that it shouldn't change the lexed token because newlines must still be lexed as <code>NonLogicalNewline</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1364 on 2024-06-13 06:29</div>
            <div class="timeline-body"><p>What's your reasoning for returning a <code>bool</code> over the re-lexed kind of the token?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1317 on 2024-06-13 06:29</div>
            <div class="timeline-body"><p>I would expand the comment with some explanation for which tokens this is relevant. Like which tokens may change in this situation or what kind of different tokens could be emitted.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/parser/mod.rs</code>:545 on 2024-06-13 06:32</div>
            <div class="timeline-body"><p>Nit: We can always unset it. Checking that it's true isn't realy necessary. All that matters here is that it's always <code>false</code> after.</p>
<pre><code class="language-suggestion">                
                first_element = false;

</code></pre>
<p>what I would find more interesting in the comment is the reason why we should only unset it when we've completely parsed the first element.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-06-13 06:38</div>
            <div class="timeline-body"><blockquote>
<p>In this case, the parser should recover from the unclosed <code>[</code>, but the parser and lexer should remain in a parenthesied context because of the <code>(</code>. Or does that work out of the box already, because <code>)</code> is a list terminator, and the parser won't recover past it?</p>
</blockquote>
<p>Is the code snippet up-to date as you've mentioned <code>[</code> and <code>(</code> which isn't present in the snippet? :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/token_source.rs</code>:75 on 2024-06-13 06:39</div>
            <div class="timeline-body"><p>Is it possible that more than the last token changes? I would have expected that it is just the last token for which the range and kind changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/tests/snapshots/invalid_syntax@class_def_unclosed_type_param_list.py.snap</code>:111 on 2024-06-13 06:40</div>
            <div class="timeline-body"><p>this is pretty cool! Nice to see how all the work accumulated to now having a single, accurate error message.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/tests/snapshots/invalid_syntax@expressions__arguments__unclosed_1.py.snap</code>:86 on 2024-06-13 06:42</div>
            <div class="timeline-body"><p>Yes, no more EOF parse errors!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/tests/snapshots/invalid_syntax@function_def_unclosed_parameter_list.py.snap</code>:216 on 2024-06-13 06:43</div>
            <div class="timeline-body"><p>Awesome!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/tests/snapshots/invalid_syntax@re_lex_logical_token.py.snap</code>:560 on 2024-06-13 06:44</div>
            <div class="timeline-body"><p>Should we map <code>NonLogicalNewline</code> to newline? It seems an odd error message to show to users.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-13 06:46</div>
            <div class="timeline-body"><p>I love this. It's so exciting to see how the hard work is paying off and we now get much better error messages.</p>
<p>I've left some open questions before approving but this is definetely looking good!</p>
<p>Do you know how our messages compare with CPython or Pyright? Do you see any significant difference?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-06-13 06:48</div>
            <div class="timeline-body"><blockquote>
<p>Is the code snippet up-to date as you've mentioned [ and ( which isn't present in the snippet? :)</p>
</blockquote>
<p>Uhm, not sure what happened here</p>
<pre><code class="language-python">(a, [b, 
	c
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1371 on 2024-06-13 08:06</div>
            <div class="timeline-body"><p>That's a good point. It shouldn't really be required but in case of nested list parsing like for example:</p>
<pre><code class="language-py">if call(foo, [a, b
    def bar():
        pass
</code></pre>
<p>If we don't move the lexer back to the newline character after <code>b</code>, the &quot;expected <code>]</code>&quot; error will be at the <code>def</code> token:</p>
<pre><code>Syntax Error: Expected ']', found 'def' at byte range 23..26
  |
1 | if call(foo, [a, b
2 |     def bar():
  |     ^^^ Syntax Error: Expected ']', found 'def'
3 |         pass
  |
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 08:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 08:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1364 on 2024-06-13 08:07</div>
            <div class="timeline-body"><p>I think initially I kept it as <code>Option&lt;TokenKind&gt;</code> but the current usage doesn't really require the token itself. I don't think there's any other particular reason to use <code>bool</code> apart from that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 08:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/token_source.rs</code>:75 on 2024-06-13 08:08</div>
            <div class="timeline-body"><p>Yes, it is possible because this vector contains trivia tokens as well. So, for something like:</p>
<pre><code class="language-py">if call(foo


    def bar():
        pass
</code></pre>
<p>There are three <code>NonLogicalNewline</code> tokens which needs to be removed and replace with a single <code>Newline</code> token.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 08:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/tests/snapshots/invalid_syntax@re_lex_logical_token.py.snap</code>:560 on 2024-06-13 08:10</div>
            <div class="timeline-body"><p>Yeah, it is odd. I could map it to &quot;newline&quot; in the <code>Display</code> implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-06-13 08:36</div>
            <div class="timeline-body"><blockquote>
<p>Uhm, not sure what happened here</p>
<pre><code class="language-python">(a, [b, 
  c
)
</code></pre>
</blockquote>
<p>Ok, so this is a bit problematic because when the lexer emitted the <code>)</code> token, it reduced the nesting level by 1 and now the re-lexing also reduces the nesting level by 1 making it 0 which means that there'll be <code>Newline</code> token after <code>c</code> which is incorrect. We could check if the current token would reduce the nesting level in re-lexing logic and avoid reducing it again. I'll need to do some more testing for these kind of scenarios.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-13 08:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1371 on 2024-06-13 08:36</div>
            <div class="timeline-body"><p>Should we set <code>self.nesting = 0</code> in that case?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-13 08:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1364 on 2024-06-13 08:37</div>
            <div class="timeline-body"><p>What I meant was to return the re-lexed token kind or the current token kind if no re-lexing happens, so that it's just a <code>TokenKind</code> (and in line with <code>lex_token</code>). But if all we need is a bool, than that's fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-13 08:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/token_source.rs</code>:75 on 2024-06-13 08:38</div>
            <div class="timeline-body"><p>Hmm, I wonder if there's a case where testing for <code>start() &gt;=</code> won't be sufficiently accurate. But I think the only zero-width tokens that exist are dedent tokens and we should never see them when calling this function</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 08:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1371 on 2024-06-13 08:46</div>
            <div class="timeline-body"><p>I'm not sure how that would help. Can you expand a bit?</p>
<p>If we set it to 0, then the outer context (the one considering <code>(</code>) will not recover correctly as it'll not try to re-lex the token.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 09:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/token_source.rs</code>:75 on 2024-06-13 09:41</div>
            <div class="timeline-body"><p>Yeah, that's correct. We should never see a <code>Dedent</code> token here because the lexer is in a parenthesized context when it was moved.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-06-13 10:21</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>Uhm, not sure what happened here</p>
<pre><code class="language-python">(a, [b, 
  c
)
</code></pre>
</blockquote>
<p>Ok, so this is a bit problematic because when the lexer emitted the <code>)</code> token, it reduced the nesting level by 1 and now the re-lexing also reduces the nesting level by 1 making it 0 which means that there'll be <code>Newline</code> token after <code>c</code> which is incorrect. We could check if the current token would reduce the nesting level in re-lexing logic and avoid reducing it again. I'll need to do some more testing for these kind of scenarios.</p>
</blockquote>
<p>Ok, I've fixed this bug and expanded the documentation and inline comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dhruvmanila on 2024-06-13 10:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-06-13 10:28</div>
            <div class="timeline-body"><blockquote>
<p>Do you know how our messages compare with CPython or Pyright? Do you see any significant difference?</p>
</blockquote>
<p>The CPython parser higlights two kinds of errors which is probably done by the lexer:</p>
<ol>
<li>Highlighting the opening parenthesis which doesn't have a closing parenthesis:</li>
</ol>
<pre><code>    if call(foo, [a, b]
           ^
SyntaxError: '(' was never closed
</code></pre>
<ol start="2">
<li>Highlighting the closing parenthesis to consider it a mismatch with the opening one:</li>
</ol>
<pre><code>    if call(foo, [a, b)
                      ^
SyntaxError: closing parenthesis ')' does not match opening parenthesis '['
</code></pre>
<p>While Pyright gets really confused:</p>
<ul>
<li>https://pyright-play.net/?code=JYMwBAxghgNjAUID2SA0YDaV0CMC6AUGMWACYCm4OUATvAJQBcRJrADlAM6dA</li>
<li>https://pyright-play.net/?code=JYMwBAxghgNjAUID2SA0YDaV0CMCUAUGMWACYCm4OUATvHgFxEksAOUAzh0A</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1371 on 2024-06-13 12:10</div>
            <div class="timeline-body"><p>I don't know if it would help with anything but I find it confusing that the lexer might return a <code>Newline</code> token or similar while <code>self.nesting &gt; 0</code>. Or, if that's never the case, why it is necessary to run the relexing if <code>self.nesting &gt; 0</code>, if there's never the chance that the lexed token is going to be different.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-06-13 12:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-06-13 15:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_parser/src/lexer.rs</code>:1371 on 2024-06-13 15:17</div>
            <div class="timeline-body"><p>I don't think it returns a <code>Newline</code> token if <code>nesting &gt; 0</code>. Considering the above example, the inner list parsing (within <code>[</code>) will try to recover and re-lex it as a <code>NonLogicalNewline</code> and then the outer list parsing (within <code>(</code>) will re-lex it as a <code>Newline</code> because only now the nesting is 0.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-06-14 07:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-06-14 12:43</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/dhruv/re-lexing">CodSpeed Performance Report</a></h2>
<h3>Merging #11845 will <strong>not alter performance</strong></h3>
<p><sub>Comparing <code>dhruv/re-lexing</code> (1989946) with <code>main</code> (1f654ee)</sub></p>
<h3>Summary</h3>
<p><code>✅ 30</code> untouched benchmarks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dhruvmanila on 2024-06-17 06:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2024-06-17 06:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-06-17 06:47</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:04:48 UTC
    </footer>
</body>
</html>
