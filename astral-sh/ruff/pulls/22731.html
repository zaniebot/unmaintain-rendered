<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Make `infer_subscript_expression_types` a method on `Type` - astral-sh/ruff #22731</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Make <code>infer_subscript_expression_types</code> a method on <code>Type</code></h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22731">#22731</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2026-01-19 18:58
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>A refactor in anticipation of https://github.com/astral-sh/ruff/pull/22654.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @charliermarsh on 2026-01-19 18:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @charliermarsh on 2026-01-19 18:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @charliermarsh on 2026-01-19 18:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-19 19:02</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">prefect (https://github.com/PrefectHQ/prefect)
- src/integrations/prefect-dbt/prefect_dbt/core/settings.py:94:28: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/integrations/prefect-dbt/prefect_dbt/core/settings.py:94:28: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any]` is not assignable to `dict[str, Any]`
- src/integrations/prefect-dbt/prefect_dbt/core/settings.py:99:28: error[invalid-assignment] Object of type `T@resolve_variables | str | int | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/integrations/prefect-dbt/prefect_dbt/core/settings.py:99:28: error[invalid-assignment] Object of type `T@resolve_variables | dict[str, Any]` is not assignable to `dict[str, Any]`
- src/prefect/cli/deploy/_core.py:86:21: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/prefect/cli/deploy/_core.py:86:21: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any]` is not assignable to `dict[str, Any]`
- src/prefect/cli/deploy/_core.py:87:21: error[invalid-assignment] Object of type `T@resolve_variables | str | int | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/prefect/cli/deploy/_core.py:87:21: error[invalid-assignment] Object of type `T@resolve_variables` is not assignable to `dict[str, Any]`
- src/prefect/deployments/runner.py:795:70: warning[possibly-missing-attribute] Attribute `__name__` may be missing on object of type `Unknown | (((...) -&gt; Any) &amp; ((*args: object, **kwargs: object) -&gt; object))`
+ src/prefect/deployments/runner.py:795:70: warning[possibly-missing-attribute] Attribute `__name__` may be missing on object of type `Unknown | ((...) -&gt; Any)`
- src/prefect/deployments/steps/core.py:137:38: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements`
+ src/prefect/deployments/steps/core.py:137:38: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any]`
+ src/prefect/flow_engine.py:812:32: error[invalid-await] `Unknown | R@FlowRunEngine | Coroutine[Any, Any, R@FlowRunEngine]` is not awaitable
+ src/prefect/flow_engine.py:1401:24: error[invalid-await] `Unknown | R@AsyncFlowRunEngine | Coroutine[Any, Any, R@AsyncFlowRunEngine]` is not awaitable
+ src/prefect/flow_engine.py:1482:43: error[invalid-argument-type] Argument to function `next` is incorrect: Expected `SupportsNext[Unknown]`, found `Unknown | R@run_generator_flow_sync`
+ src/prefect/flow_engine.py:1490:21: warning[possibly-missing-attribute] Attribute `throw` may be missing on object of type `Unknown | R@run_generator_flow_sync`
+ src/prefect/flow_engine.py:1524:44: warning[possibly-missing-attribute] Attribute `__anext__` may be missing on object of type `Unknown | R@run_generator_flow_async`
+ src/prefect/flow_engine.py:1531:25: warning[possibly-missing-attribute] Attribute `throw` may be missing on object of type `Unknown | R@run_generator_flow_async`
- src/prefect/flows.py:286:34: error[unresolved-attribute] Object of type `((**P@Flow) -&gt; R@Flow) &amp; ((*args: object, **kwargs: object) -&gt; object)` has no attribute `__name__`
+ src/prefect/flows.py:286:34: error[unresolved-attribute] Object of type `(**P@Flow) -&gt; R@Flow` has no attribute `__name__`
- src/prefect/flows.py:404:68: error[unresolved-attribute] Object of type `((**P@Flow) -&gt; R@Flow) &amp; ((*args: object, **kwargs: object) -&gt; object)` has no attribute `__name__`
+ src/prefect/flows.py:404:68: error[unresolved-attribute] Object of type `(**P@Flow) -&gt; R@Flow` has no attribute `__name__`
- src/prefect/flows.py:1750:53: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/prefect/utilities/templating.py:320:13: error[invalid-assignment] Invalid subscript assignment with key of type `object` and value of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` on object of type `dict[str, Any]`
+ src/prefect/utilities/templating.py:320:13: error[invalid-assignment] Invalid subscript assignment with key of type `object` and value of type `T@resolve_block_document_references | dict[str, Any]` on object of type `dict[str, Any]`
- src/prefect/utilities/templating.py:323:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_block_document_references | dict[str, Any]`, found `list[T@resolve_block_document_references | dict[str, Any] | str | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:323:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_block_document_references | dict[str, Any]`, found `list[T@resolve_block_document_references | dict[str, Any] | Unknown]`
- src/prefect/utilities/templating.py:437:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `dict[object, T@resolve_variables | str | int | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:437:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `dict[object, T@resolve_variables | Unknown]`
- src/prefect/utilities/templating.py:442:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `list[T@resolve_variables | str | int | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:442:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `list[T@resolve_variables | Unknown]`
- src/prefect/workers/base.py:232:13: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements`
+ src/prefect/workers/base.py:232:13: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any]`
- src/prefect/workers/base.py:234:20: error[invalid-argument-type] Argument expression after ** must be a mapping type: Found `T@resolve_variables | str | int | ... omitted 4 union elements`
+ src/prefect/workers/base.py:234:20: error[invalid-argument-type] Argument expression after ** must be a mapping type: Found `T@resolve_variables`
- Found 5406 diagnostics
+ Found 5411 diagnostics

scikit-build-core (https://github.com/scikit-build/scikit-build-core)
- src/scikit_build_core/build/wheel.py:99:20: error[no-matching-overload] No overload of bound method `__init__` matches arguments
- Found 47 diagnostics
+ Found 46 diagnostics

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Bus[Any] | Bottom[Series[Any, Any]] | ndarray[Never, Never] | ... omitted 6 union elements, object_]`
- static_frame/core/bus.py:675:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Bus[Any], object_]`, found `InterGetItemILocReduces[Bus[Any] | ndarray[Never, Never] | TypeBlocks | ... omitted 6 union elements, object_ | Self@iloc]`
+ static_frame/core/bus.py:675:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Bus[Any], object_]`, found `InterGetItemILocReduces[Self@iloc | Bus[Any], object_ | Self@iloc]`
- static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Bottom[Series[Any, Any]] | Unknown, Any]`
+ static_frame/core/node_selector.py:526:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[TVContainer_co@InterfaceSelectQuartet, Any]`, found `InterGetItemLocReduces[Unknown | Bottom[Series[Any, Any]], Any]`
- static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, TVDtype@Series]`
- static_frame/core/series.py:4072:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[SeriesHE[Any, Any], TVDtype@SeriesHE]`, found `InterGetItemILocReduces[Bottom[Series[Any, Any]] | ndarray[Never, Never] | TypeBlocks | ... omitted 7 union elements, TVDtype@SeriesHE]`
- static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | Bottom[Index[Any]] | TypeBlocks | ... omitted 6 union elements, object_]`
- Found 1825 diagnostics
+ Found 1821 diagnostics

pandas-stubs (https://github.com/pandas-dev/pandas-stubs)
+ tests/frame/test_groupby.py:229:15: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[str | bytes | int | ... omitted 12 union elements]`
+ tests/frame/test_groupby.py:625:15: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[str | bytes | int | ... omitted 12 union elements]`
- Found 4449 diagnostics
+ Found 4451 diagnostics

core (https://github.com/home-assistant/core)
+ homeassistant/util/variance.py:47:12: error[invalid-return-type] Return type does not match returned value: expected `(**_P@ignore_variance) -&gt; _R@ignore_variance`, found `_Wrapped[_P@ignore_variance, _R@ignore_variance | int | float | datetime, _P@ignore_variance, _R@ignore_variance | int | float | datetime]`
- Found 14491 diagnostics
+ Found 14492 diagnostics


</code></pre>
</details>

<p>No memory usage changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @charliermarsh on 2026-01-19 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @charliermarsh on 2026-01-19 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @charliermarsh on 2026-01-19 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @charliermarsh on 2026-01-19 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @charliermarsh on 2026-01-19 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2026-01-19 19:03</div>
            <div class="timeline-body"><p>Okay, looks like a no-op as expected (those look like the usual suspects in mypy-primer).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-19 19:04</div>
            <div class="timeline-body"><!-- generated-comment ty ecosystem-analyzer -->

<h2><code>ecosystem-analyzer</code> results</h2>
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>invalid-return-type</code> | 0 | 4 | 6 |
| <code>invalid-argument-type</code> | 2 | 1 | 5 |
| <code>invalid-parameter-default</code> | 0 | 0 | 7 |
| <code>invalid-assignment</code> | 0 | 0 | 5 |
| <code>unused-ignore-comment</code> | 0 | 2 | 0 |
| <strong>Total</strong> | <strong>2</strong> | <strong>7</strong> | <strong>23</strong> |</p>
<p><strong><a href="https://36f9a527.ty-ecosystem-ext.pages.dev/diff">Full report with detailed diff</a></strong> (<a href="https://36f9a527.ty-ecosystem-ext.pages.dev/timing">timing results</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2026-01-19 19:05</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2><a href="https://github.com/python/typing/blob/dece44f2922ca390fe314145d09939514a21e76e/conformance/">Typing conformance results</a></h2>
<p>No changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-19 19:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-19 19:11</div>
            <div class="timeline-body"><p>We don't really use the <code>infer</code> terminology on <code>Type</code>. In general, the methods on <code>Type</code> are expressed in type operations. E.g <code>Type::subscript</code> would be a good fit, and it would be a salsa query.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types.rs</code>:9721 on 2026-01-19 19:11</div>
            <div class="timeline-body"><p>What do you think of moving all this plentyfull new code to <code>subscript.rs</code> to not make <code>types.rs</code> even bigg</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-19 19:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-19 19:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-19 19:15</div>
            <div class="timeline-body"><blockquote>
<p>it would be a salsa query</p>
</blockquote>
<p>Would it? <code>Type::try_iterate()</code> and <code>Type::try_call()</code> are not Salsa queries. I think most methods like this are <em>not</em> Salsa queries?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-19 19:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:9721 on 2026-01-19 19:16</div>
            <div class="timeline-body"><p>yes, I agree -- or even an entirely new module :-) though <code>subscript.rs</code> <em>is</em> very well named for what this new code does...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-19 19:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-19 19:21</div>
            <div class="timeline-body"><p>I agree that <code>Type::subscript()</code> is what we'd usually call this, though</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2026-01-19 19:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types.rs</code>:9721 on 2026-01-19 19:26</div>
            <div class="timeline-body"><p>Aye aye!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2026-01-19 19:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-19 19:28</div>
            <div class="timeline-body"><p>I renamed it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2026-01-19 19:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types.rs</code>:9721 on 2026-01-19 19:28</div>
            <div class="timeline-body"><p>I moved it into <code>types/subscript.rs</code> and left the top-level <code>subscript.rs</code> as-is (I suppose that could be renamed to <code>index</code> or <code>pyindex</code> though).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/subscript.rs</code>:1 on 2026-01-19 19:28</div>
            <div class="timeline-body"><p>Oh, I was thinking we could put the new <code>Type</code> method in this module too? We have to find some way to split up <code>types.rs</code> ðŸ˜† and there's precedent now with all the type-relation methods being in <code>types/relation.rs</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-19 19:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2026-01-19 19:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ty_python_semantic/src/types/subscript.rs</code>:1 on 2026-01-19 19:29</div>
            <div class="timeline-body"><p>I totally defer to you, I didn't realize we had <code>impl</code> blocks outside of <code>types.rs</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-19 19:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/subscript.rs</code>:1 on 2026-01-19 19:35</div>
            <div class="timeline-body"><p>I say let's pull it all out of <code>types.rs</code>! Both <code>types.rs</code> and <code>infer/builder.rs</code> are monster files where GitHub now struggles with syntax highlighting; it's a medium-term goal to reduce them both in size</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @charliermarsh on 2026-01-19 20:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-19 20:31</div>
            <div class="timeline-body"><p>(will review tomorrow morning -- thank you!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-20 06:55</div>
            <div class="timeline-body"><p><code>try_call</code> is different. It doesn't accept any AST-dependent arguments, nor does it access the <code>semantic_index</code>. It entirely operates on the Type-IR.</p>
<p>Which is very different to what we have here with</p>
<pre><code>		expr_context: ast::ExprContext,
        scope_id: ScopeId&lt;'db&gt;,
        index: &amp;'db SemanticIndex&lt;'db&gt;,
        typevar_binding_context: Option&lt;Definition&lt;'db&gt;&gt;,
</code></pre>
<p>But I also find it difficult to give any advice here with this little information in the summary. Where and how do we plan on using this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-20 06:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-20 08:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-20 08:39</div>
            <div class="timeline-body"><p>Ah I think this new method should probably operate on the Type IR too (good catch, I haven't really looked at the code yet).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-20 11:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-20 11:30</div>
            <div class="timeline-body"><p>So the only AST node passed in here is <code>ast::ExprContext</code>, which doesn't hold a <code>TextRange</code> or node index in it. So I don't <em>think</em> that this should cause any issues with overly eager Salsa invalidation?</p>
<p>https://github.com/astral-sh/ruff/blob/0a1dddbf73e368a2019617ee907b0eb271eca979/crates/ruff_python_ast/src/nodes.rs#L2478-L2486</p>
<p>If even passing this in as an argument could cause issues, though, then it could be easily replaced with a boolean <code>in_store_context</code> parameter. All we do with it is check that <code>expr_context != ExprContext::Store</code> towards the end of the method.</p>
<p>Passing in the <code>scope_id</code>, <code>index</code> and <code>typevar_binding_context</code> are different, though... and I don't see a way to avoid that, given how special-cased several subscript operations are in the Python type system. So it may well be best to make this a Salsa-tracked query, like @MichaReiser suggests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-20 11:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-20 11:35</div>
            <div class="timeline-body"><blockquote>
<p>But I also find it difficult to give any advice here with this little information in the summary. Where and how do we plan on using this?</p>
</blockquote>
<p>The main motivation is to make this a &quot;pure&quot; method that does not have side effects (does not eagerly emit diagnostics), and instead returns a <code>Result</code> that allows the caller to either emit a diagnostic or discard the error, as it sees fit.</p>
<p>The new design will make it much easier to implement subscript support for intersections (https://github.com/astral-sh/ruff/pull/22654), because for subscript support on intersections we need to speculatively call <code>Type::subscript()</code> on each intersection element, and only report a diagnostic if the call would fail on <em>each</em> intersection element.</p>
<p>This new design will also make it easier to improve our subscript diagnostics on union types in the future. Right now if you have an object of type <code>int | range</code> and you try to subscript it, ty will report two diagnostics -- one for subscripting an object of type <code>int</code> and one for subscripting an object of type <code>range</code>. Ideally we would combine these two into a single diagnostic, but that's hard with the current <code>TypeInferencBuilder::infer_subscript_expression_types()</code> method that eagerly emits diagnostics as soon as it encounters them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2026-01-20 11:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-20 11:59</div>
            <div class="timeline-body"><p>Always making this a salsa query might negatively impact memory usage and isn't really necessary when called in the type inference builder.</p>
<p>I wonder if this should just be a standalone helper function instead that we call from the type inference builder (uncached), and we can later add a <code>try_subscript</code> with whatever we exactly need in <code>Type::subscript.</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2026-01-20 12:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3789 on 2026-01-20 12:07</div>
            <div class="timeline-body"><p>Okay, so I think we can make this a pure method that doesn't depend on state (like <code>Type::try_call</code>, <code>Type::try_iterate</code>, etc.) by moving the special cases for <code>Generic[]</code> subscripts, <code>Protocol</code> subscripts and <code>Concatenate</code> subscripts out of the method and back into the <code>TypeInferenceBuilder</code>. This patch passes all tests, and means that the <code>Type</code> method no longer needs to have <code>index</code>, <code>typevar_binding_context</code> or <code>scope</code> passed in. Unlike the special cases we apply for tuple subscripts, string-literal subscripts, etc., it isn't important for us to apply these special cases recursively: it's not necessary for us to recognise the very special nature of these special forms in the very unlikely event that they appear in a union or intersection:</p>
<details>

<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/infer/builder.rs b/crates/ty_python_semantic/src/types/infer/builder.rs
index ce93043720..71f703ef62 100644
--- a/crates/ty_python_semantic/src/types/infer/builder.rs
+++ b/crates/ty_python_semantic/src/types/infer/builder.rs
@@ -109,6 +109,7 @@ use crate::types::infer::nearest_enclosing_function;
 use crate::types::mro::{DynamicMroErrorKind, StaticMroErrorKind};
 use crate::types::newtype::NewType;
 use crate::types::subclass_of::SubclassOfInner;
+use crate::types::subscript::{SubscriptError, SubscriptErrorKind};
 use crate::types::tuple::{Tuple, TupleLength, TupleSpec, TupleSpecBuilder, TupleType};
 use crate::types::typed_dict::{
     TypedDictAssignmentKind, validate_typed_dict_constructor, validate_typed_dict_dict_literal,
@@ -123,7 +124,7 @@ use crate::types::{
     TrackedConstraintSet, Truthiness, Type, TypeAliasType, TypeAndQualifiers, TypeContext,
     TypeQualifiers, TypeVarBoundOrConstraints, TypeVarBoundOrConstraintsEvaluation,
     TypeVarDefaultEvaluation, TypeVarIdentity, TypeVarInstance, TypeVarKind, TypeVarVariance,
-    TypedDictType, UnionBuilder, UnionType, UnionTypeInstance, binding_type,
+    TypedDictType, UnionBuilder, UnionType, UnionTypeInstance, any_over_type, binding_type,
     definition_expression_type, infer_scope_types, todo_type,
 };
 use crate::types::{CallableTypes, overrides};
@@ -14453,20 +14454,141 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
         slice_ty: Type&lt;'db&gt;,
         expr_context: ExprContext,
     ) -&gt; Type&lt;'db&gt; {
-        match value_ty.subscript(
-            self.db(),
-            slice_ty,
-            expr_context,
-            self.scope(),
-            self.index,
-            self.typevar_binding_context,
-        ) {
-            Ok(result) =&gt; result,
-            Err(error) =&gt; {
-                error.report_diagnostics(&amp;self.context, subscript);
-                error.result_type()
+        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
+        enum LegacyGenericContextError&lt;'db&gt; {
+            /// It's invalid to subscript `Generic` or `Protocol` with this type.
+            InvalidArgument(Type&lt;'db&gt;),
+            /// It's invalid to subscript `Generic` or `Protocol` with a variadic tuple type.
+            /// We should emit a diagnostic for this, but we don't yet.
+            VariadicTupleArguments,
+            /// It's valid to subscribe `Generic` or `Protocol` with this type,
+            /// but the type is not yet supported.
+            NotYetSupported,
+        }
+
+        impl&lt;'db&gt; LegacyGenericContextError&lt;'db&gt; {
+            const fn into_type(self) -&gt; Type&lt;'db&gt; {
+                match self {
+                    LegacyGenericContextError::InvalidArgument(_)
+                    | LegacyGenericContextError::VariadicTupleArguments =&gt; Type::unknown(),
+                    LegacyGenericContextError::NotYetSupported =&gt; {
+                        todo_type!(&quot;ParamSpecs and TypeVarTuples&quot;)
+                    }
+                }
             }
         }
+
+        let db = self.db();
+
+        let legacy_generic_class_context = |typevars: Type&lt;'db&gt;| -&gt; Result&lt;
+            GenericContext&lt;'db&gt;,
+            LegacyGenericContextError&lt;'db&gt;,
+        &gt; {
+            let typevars_class_tuple_spec = typevars.exact_tuple_instance_spec(db);
+
+            let typevars = if let Some(tuple_spec) = typevars_class_tuple_spec.as_deref() {
+                match tuple_spec {
+                    Tuple::Fixed(typevars) =&gt; typevars.elements_slice(),
+                    Tuple::Variable(_) =&gt; {
+                        return Err(LegacyGenericContextError::VariadicTupleArguments);
+                    }
+                }
+            } else {
+                std::slice::from_ref(&amp;typevars)
+            };
+
+            let typevars: Result&lt;FxOrderSet&lt;_&gt;, LegacyGenericContextError&lt;'db&gt;&gt; = typevars
+                .iter()
+                .map(|typevar| {
+                    let argument_ty = *typevar;
+                    if let Type::KnownInstance(KnownInstanceType::TypeVar(typevar)) = argument_ty {
+                        bind_typevar(
+                            db,
+                            self.index,
+                            self.scope().file_scope_id(db),
+                            self.typevar_binding_context,
+                            typevar,
+                        )
+                        .ok_or(LegacyGenericContextError::InvalidArgument(argument_ty))
+                    } else if any_over_type(
+                        db,
+                        argument_ty,
+                        &amp;|ty| match ty {
+                            Type::Dynamic(
+                                DynamicType::TodoUnpack | DynamicType::TodoStarredExpression,
+                            ) =&gt; true,
+                            Type::NominalInstance(nominal) =&gt; {
+                                nominal.has_known_class(db, KnownClass::TypeVarTuple)
+                            }
+                            _ =&gt; false,
+                        },
+                        true,
+                    ) {
+                        Err(LegacyGenericContextError::NotYetSupported)
+                    } else {
+                        Err(LegacyGenericContextError::InvalidArgument(argument_ty))
+                    }
+                })
+                .collect();
+            typevars.map(|typevars| GenericContext::from_typevar_instances(db, typevars))
+        };
+
+        // Special typing forms for which subscriptions are context-dependent are parsed here,
+        // outside of `Type::subscript`, which is a pure function that doesn't depend on the
+        // semantic index or any context-dependent state.
+        let subscript_result = match value_ty {
+            Type::SpecialForm(SpecialFormType::Generic) =&gt; {
+                match legacy_generic_class_context(slice_ty) {
+                    Ok(context) =&gt; Ok(Type::KnownInstance(KnownInstanceType::SubscriptedGeneric(
+                        context,
+                    ))),
+                    Err(LegacyGenericContextError::InvalidArgument(argument_ty)) =&gt; {
+                        Err(SubscriptError::new(
+                            Type::unknown(),
+                            SubscriptErrorKind::InvalidLegacyGenericArgument {
+                                origin: &quot;Generic&quot;,
+                                argument_ty,
+                            },
+                        ))
+                    }
+                    Err(error) =&gt; Ok(error.into_type()),
+                }
+            }
+            Type::SpecialForm(SpecialFormType::Protocol) =&gt; {
+                match legacy_generic_class_context(slice_ty) {
+                    Ok(context) =&gt; Ok(Type::KnownInstance(KnownInstanceType::SubscriptedProtocol(
+                        context,
+                    ))),
+                    Err(LegacyGenericContextError::InvalidArgument(argument_ty)) =&gt; {
+                        Err(SubscriptError::new(
+                            Type::unknown(),
+                            SubscriptErrorKind::InvalidLegacyGenericArgument {
+                                origin: &quot;Protocol&quot;,
+                                argument_ty,
+                            },
+                        ))
+                    }
+                    Err(error) =&gt; Ok(error.into_type()),
+                }
+            }
+            Type::SpecialForm(SpecialFormType::Concatenate) =&gt; {
+                // TODO: Add proper support for `Concatenate`
+                let mut variables = FxOrderSet::default();
+                slice_ty.bind_and_find_all_legacy_typevars(
+                    db,
+                    self.typevar_binding_context,
+                    &amp;mut variables,
+                );
+                let generic_context = GenericContext::from_typevar_instances(db, variables);
+                Ok(Type::Dynamic(DynamicType::UnknownGeneric(generic_context)))
+            }
+            _ =&gt; value_ty.subscript(self.db(), slice_ty, expr_context),
+        };
+
+        subscript_result.unwrap_or_else(|e| {
+            e.report_diagnostics(&amp;self.context, subscript);
+            e.result_type()
+        })
     }
 
     fn infer_slice_expression(&amp;mut self, slice: &amp;ast::ExprSlice) -&gt; Type&lt;'db&gt; {
diff --git a/crates/ty_python_semantic/src/types/subscript.rs b/crates/ty_python_semantic/src/types/subscript.rs
index 9397e7e3e3..e78465d401 100644
--- a/crates/ty_python_semantic/src/types/subscript.rs
+++ b/crates/ty_python_semantic/src/types/subscript.rs
@@ -1,12 +1,9 @@
 use itertools::Itertools;
 use ruff_python_ast as ast;
 
+use crate::Db;
 use crate::place::{DefinedPlace, Definedness, Place};
-use crate::semantic_index::SemanticIndex;
-use crate::semantic_index::definition::Definition;
-use crate::semantic_index::scope::ScopeId;
 use crate::subscript::{PyIndex, PySlice};
-use crate::{Db, FxOrderSet};
 
 use super::call::{Bindings, CallArguments, CallDunderError, CallError, CallErrorKind};
 use super::class::KnownClass;
@@ -17,12 +14,10 @@ use super::diagnostic::{
     report_index_out_of_bounds, report_invalid_key_on_typed_dict, report_not_subscriptable,
     report_slice_step_size_zero,
 };
-use super::generics::{GenericContext, bind_typevar};
 use super::infer::TypeContext;
 use super::instance::SliceLiteral;
 use super::special_form::SpecialFormType;
-use super::tuple::{Tuple, TupleSpec};
-use super::visitor::any_over_type;
+use super::tuple::TupleSpec;
 use super::{
     DynamicType, KnownInstanceType, Type, TypeAliasType, UnionBuilder, UnionType, todo_type,
 };
@@ -34,7 +29,7 @@ pub(crate) struct SubscriptError&lt;'db&gt; {
 }
 
 #[derive(Debug)]
-enum SubscriptErrorKind&lt;'db&gt; {
+pub(crate) enum SubscriptErrorKind&lt;'db&gt; {
     /// An index is out of bounds for a literal tuple/string/bytes subscript.
     IndexOutOfBounds {
         kind: &amp;'static str,
@@ -83,7 +78,7 @@ enum SubscriptErrorKind&lt;'db&gt; {
 }
 
 impl&lt;'db&gt; SubscriptError&lt;'db&gt; {
-    fn new(result_ty: Type&lt;'db&gt;, error: SubscriptErrorKind&lt;'db&gt;) -&gt; Self {
+    pub(crate) fn new(result_ty: Type&lt;'db&gt;, error: SubscriptErrorKind&lt;'db&gt;) -&gt; Self {
         Self {
             result_ty,
             errors: vec![error],
@@ -293,87 +288,7 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
         db: &amp;'db dyn Db,
         slice_ty: Type&lt;'db&gt;,
         expr_context: ast::ExprContext,
-        scope_id: ScopeId&lt;'db&gt;,
-        index: &amp;'db SemanticIndex&lt;'db&gt;,
-        typevar_binding_context: Option&lt;Definition&lt;'db&gt;&gt;,
     ) -&gt; Result&lt;Type&lt;'db&gt;, SubscriptError&lt;'db&gt;&gt; {
-        #[derive(Debug, Clone, Copy, PartialEq, Eq)]
-        enum LegacyGenericContextError&lt;'db&gt; {
-            /// It's invalid to subscript `Generic` or `Protocol` with this type.
-            InvalidArgument(Type&lt;'db&gt;),
-            /// It's invalid to subscript `Generic` or `Protocol` with a variadic tuple type.
-            /// We should emit a diagnostic for this, but we don't yet.
-            VariadicTupleArguments,
-            /// It's valid to subscribe `Generic` or `Protocol` with this type,
-            /// but the type is not yet supported.
-            NotYetSupported,
-        }
-
-        impl&lt;'db&gt; LegacyGenericContextError&lt;'db&gt; {
-            const fn into_type(self) -&gt; Type&lt;'db&gt; {
-                match self {
-                    LegacyGenericContextError::InvalidArgument(_)
-                    | LegacyGenericContextError::VariadicTupleArguments =&gt; Type::unknown(),
-                    LegacyGenericContextError::NotYetSupported =&gt; {
-                        todo_type!(&quot;ParamSpecs and TypeVarTuples&quot;)
-                    }
-                }
-            }
-        }
-
-        let legacy_generic_class_context = |typevars: Type&lt;'db&gt;| -&gt; Result&lt;
-            GenericContext&lt;'db&gt;,
-            LegacyGenericContextError&lt;'db&gt;,
-        &gt; {
-            let typevars_class_tuple_spec = typevars.exact_tuple_instance_spec(db);
-
-            let typevars = if let Some(tuple_spec) = typevars_class_tuple_spec.as_deref() {
-                match tuple_spec {
-                    Tuple::Fixed(typevars) =&gt; typevars.elements_slice(),
-                    Tuple::Variable(_) =&gt; {
-                        return Err(LegacyGenericContextError::VariadicTupleArguments);
-                    }
-                }
-            } else {
-                std::slice::from_ref(&amp;typevars)
-            };
-
-            let typevars: Result&lt;FxOrderSet&lt;_&gt;, LegacyGenericContextError&lt;'db&gt;&gt; = typevars
-                .iter()
-                .map(|typevar| {
-                    let argument_ty = *typevar;
-                    if let Type::KnownInstance(KnownInstanceType::TypeVar(typevar)) = argument_ty {
-                        bind_typevar(
-                            db,
-                            index,
-                            scope_id.file_scope_id(db),
-                            typevar_binding_context,
-                            typevar,
-                        )
-                        .ok_or(LegacyGenericContextError::InvalidArgument(argument_ty))
-                    } else if any_over_type(
-                        db,
-                        argument_ty,
-                        &amp;|ty| match ty {
-                            Type::Dynamic(
-                                DynamicType::TodoUnpack | DynamicType::TodoStarredExpression,
-                            ) =&gt; true,
-                            Type::NominalInstance(nominal) =&gt; {
-                                nominal.has_known_class(db, KnownClass::TypeVarTuple)
-                            }
-                            _ =&gt; false,
-                        },
-                        true,
-                    ) {
-                        Err(LegacyGenericContextError::NotYetSupported)
-                    } else {
-                        Err(LegacyGenericContextError::InvalidArgument(argument_ty))
-                    }
-                })
-                .collect();
-            typevars.map(|typevars| GenericContext::from_typevar_instances(db, typevars))
-        };
-
         let value_ty = self;
 
         let inferred = match (value_ty, slice_ty) {
@@ -383,18 +298,12 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 db,
                 slice_ty,
                 expr_context,
-                scope_id,
-                index,
-                typevar_binding_context,
             )),
 
             (_, Type::TypeAlias(alias)) =&gt; Some(value_ty.subscript(
                 db,
                 alias.value_type(db),
                 expr_context,
-                scope_id,
-                index,
-                typevar_binding_context,
             )),
 
             (Type::Union(union), _) =&gt; Some(map_union_subscript(db, union, |element| {
@@ -402,9 +311,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                     db,
                     slice_ty,
                     expr_context,
-                    scope_id,
-                    index,
-                    typevar_binding_context,
                 )
             })),
 
@@ -413,9 +319,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                     db,
                     element,
                     expr_context,
-                    scope_id,
-                    index,
-                    typevar_binding_context,
                 )
             })),
 
@@ -556,9 +459,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                     db,
                     Type::IntLiteral(i64::from(bool)),
                     expr_context,
-                    scope_id,
-                    index,
-                    typevar_binding_context,
                 ))
             }
 
@@ -569,30 +469,9 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                     db,
                     Type::IntLiteral(i64::from(bool)),
                     expr_context,
-                    scope_id,
-                    index,
-                    typevar_binding_context,
                 ))
             }
 
-            (Type::SpecialForm(SpecialFormType::Protocol), typevars) =&gt; Some(
-                match legacy_generic_class_context(typevars) {
-                    Ok(context) =&gt; Ok(Type::KnownInstance(
-                        KnownInstanceType::SubscriptedProtocol(context),
-                    )),
-                    Err(LegacyGenericContextError::InvalidArgument(argument_ty)) =&gt; Err(
-                        SubscriptError::new(
-                            Type::unknown(),
-                            SubscriptErrorKind::InvalidLegacyGenericArgument {
-                                origin: &quot;Protocol&quot;,
-                                argument_ty,
-                            },
-                        ),
-                    ),
-                    Err(error) =&gt; Ok(error.into_type()),
-                },
-            ),
-
             (Type::KnownInstance(KnownInstanceType::SubscriptedProtocol(_)), _) =&gt; {
                 // TODO: emit a diagnostic
                 Some(Ok(todo_type!(&quot;doubly-specialized typing.Protocol&quot;)))
@@ -611,24 +490,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 )))
             }
 
-            (Type::SpecialForm(SpecialFormType::Generic), typevars) =&gt; Some(
-                match legacy_generic_class_context(typevars) {
-                    Ok(context) =&gt; Ok(Type::KnownInstance(
-                        KnownInstanceType::SubscriptedGeneric(context),
-                    )),
-                    Err(LegacyGenericContextError::InvalidArgument(argument_ty)) =&gt; Err(
-                        SubscriptError::new(
-                            Type::unknown(),
-                            SubscriptErrorKind::InvalidLegacyGenericArgument {
-                                origin: &quot;Generic&quot;,
-                                argument_ty,
-                            },
-                        ),
-                    ),
-                    Err(error) =&gt; Ok(error.into_type()),
-                },
-            ),
-
             (Type::KnownInstance(KnownInstanceType::SubscriptedGeneric(_)), _) =&gt; {
                 // TODO: emit a diagnostic
                 Some(Ok(todo_type!(&quot;doubly-specialized typing.Generic&quot;)))
@@ -638,18 +499,6 @@ impl&lt;'db&gt; Type&lt;'db&gt; {
                 Some(Ok(Type::Dynamic(DynamicType::TodoUnpack)))
             }
 
-            (Type::SpecialForm(SpecialFormType::Concatenate), _) =&gt; {
-                // TODO: Add proper support for `Concatenate`
-                let mut variables = FxOrderSet::default();
-                slice_ty.bind_and_find_all_legacy_typevars(
-                    db,
-                    typevar_binding_context,
-                    &amp;mut variables,
-                );
-                let generic_context = GenericContext::from_typevar_instances(db, variables);
-                Some(Ok(Type::Dynamic(DynamicType::UnknownGeneric(generic_context))))
-            }
-
             (Type::SpecialForm(special_form), _) if special_form.class().is_special_form() =&gt; {
                 Some(Ok(todo_type!(&quot;Inference of subscript on special form&quot;)))
             }
</code></pre>
</details>

<p>Then we don't need to add any Salsa caching, and we end up with a very similar design to what we use elsewhere for recursive operations on <code>Type</code>s.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 12:38:57 UTC
    </footer>
</body>
</html>
