<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] support implicit global name lookups - astral-sh/ruff #12374</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] support implicit global name lookups</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12374">#12374</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-07-18 03:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>Support falling back to a global name lookup if a name isn't defined in the local scope, in the cases where that is correct according to Python semantics.</p>
<p>In class scopes, a name lookup checks the local namespace first, and if the name isn't found there, looks it up in globals.</p>
<p>In function scopes (and type parameter scopes, which are function-like), if a name has any definitions in the local scope, it is a local, and accessing it when none of those definitions have executed yet just results in an <code>UnboundLocalError</code>, it does not fall back to a global. If the name does not have any definitions in the local scope, then it is an implicit global.</p>
<p>Public symbol type lookups never include such a fall back. For example, if a name is not defined in a class scope, it is not available as a member on that class, even if a name lookup within the class scope would have fallen back to a global lookup.</p>
<p>This PR makes the <code>@override</code> lint rule work again.</p>
<p>Not yet included/supported in this PR:</p>
<ul>
<li>Support for free variables / closures: a free symbol in a nested function-like scope referring to a symbol in an outer function-like scope.</li>
<li>Support for <code>global</code> and <code>nonlocal</code> statements, which force a symbol to be treated as global or nonlocal even if it has definitions in the local scope.</li>
<li>Module-global lookups should fall back to builtins if the name isn't found in the module scope.</li>
</ul>
<p>I would like to expose nicer APIs for the various kinds of symbols (explicit global, implicit global, free, etc), but this will also wait for a later PR, when more kinds of symbols are supported.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-07-18 03:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-07-18 03:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-07-18 03:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-07-18 03:28</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/cjm/scope-lookups">CodSpeed Performance Report</a></h2>
<h3>Merging #12374 will <strong>degrade performances by 10.44%</strong></h3>
<p><sub>Comparing <code>cjm/scope-lookups</code> (b2b4bd7) with <code>main</code> (811f78d)</sub></p>
<h3>Summary</h3>
<p><code>‚ùå 3 (üëÅ 3)</code> regressions
<code>‚úÖ 30</code> untouched benchmarks</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>cjm/scope-lookups</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| üëÅ | <code>red_knot_check_file[without_parse]</code> | 234.7 ¬µs | 262.1 ¬µs | -10.44% |
| üëÅ | <code>red_knot_check_file[incremental]</code> | 89.2 ¬µs | 95.5 ¬µs | -6.58% |
| üëÅ | <code>red_knot_check_file[cold]</code> | 318.8 ¬µs | 345.4 ¬µs | -7.7% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-07-18 03:35</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-07-18 03:39</div>
            <div class="timeline-body"><p>As expected, this gives back the wins (and a bit more) that we saw previously when switching to per-definition inference and removing this lookup to other scopes. Not only are we now doing extra work on names that are global references (and actually also wrongly on names that are arguments, because we currently don't create definitions for arguments), but that means we actually now recognize the decorator and run the lint rule, so we're just doing a lot more work in the benchmark than before.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:111 on 2024-07-18 06:20</div>
            <div class="timeline-body"><p>I would not have expected <code>ClassTypeParameters</code> to be in here. A comment might be useful here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:30 on 2024-07-18 06:21</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        use_def.public_may_be_unbound(symbol).then_some(Type::Unbound),
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:697 on 2024-07-18 06:25</div>
            <div class="timeline-body"><p>I think it would help readability if we move some declarations closer to the blocks that use them rather than defining all of them upfront.</p>
<pre><code class="language-rust">let file_scope_id = self.scope.file_scope_id(self.db);
let use_def = self.index.use_def_map(file_scope_id);
let use_id = name.scoped_use_id(self.db, self.scope);
let definitions = use_def.use_definitions(use_id);
let may_be_unbound = use_def.use_may_be_unbound(use_id);


let unbound_ty = if may_be_unbound {
		let symbols = self.index.symbol_table(file_scope_id);
    // SAFETY: the symbol table always creates a symbol for every Name node.
    let symbol = symbols.symbol_by_name(id).unwrap();

    if !symbol.is_defined() || !self.scope.is_function_like(self.db) {
        // implicit global
        Some(module_global_symbol_ty_by_name(self.db, self.file, id))
    } else {
        Some(Type::Unbound)
    }
} else {
    None
};
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-07-18 06:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-18 12:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:111 on 2024-07-18 12:08</div>
            <div class="timeline-body"><p>This is because the actual values of type parameters (whether they're type parameters for a class or type parameters for a function) are lazily evaluated (so that you can have forward references in them). The way this is implemented internally in Python is just by creating a function that is executed when you try to access the value for the first time. All of which is to say that although the user probably doesn't think of themselves as creating a function when they use type parameters (either for a class for for a function), the scoping rules for type parameter scopes are very analogous to function scopes. Similarly, we'll probably return <code>true</code> for this function in the future if <code>self.node(db)</code> is a comprehension or generator expression of some kind, once we support those.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:73 on 2024-07-18 12:15</div>
            <div class="timeline-body"><p>If you use markdown headings, VSCode is able to render some beautiful docs when I hover over the <code>definitions_ty</code> symbol in another file:</p>
<pre><code class="language-suggestion">/// # Panics:
///
/// If called with zero definitions and no `unbound_ty`. This is a logic error,
</code></pre>
<p><img src="https://github.com/user-attachments/assets/ffa945ea-f277-46ad-b0dc-4131abf4e8ab" alt="image" /></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:62 on 2024-07-18 12:15</div>
            <div class="timeline-body"><pre><code class="language-suggestion">/// Infer the combined type of an array of [`Definition`]s, plus one optional &quot;unbound type&quot;.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:68 on 2024-07-18 12:15</div>
            <div class="timeline-body"><pre><code class="language-suggestion">/// the given [`Definition`]s. If this isn't possible, then it will be `None`. If it is possible,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:684 on 2024-07-18 12:18</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                let symbol = symbols.symbol_by_name(id)
                    .expect(&quot;Expected the symbol table to always crate a symbol for every Name node&quot;);
</code></pre>
<p>You should also remove the <code>allow(unused)</code> suppression in <code>symbols.rs</code>:</p>
<p>https://github.com/astral-sh/ruff/blob/648cca199bbf0d2b4b04414404bca866fe5b52c9/crates/red_knot_python_semantic/src/semantic_index/symbol.rs#L195-L200</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-18 12:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-18 16:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/symbol.rs</code>:111 on 2024-07-18 16:14</div>
            <div class="timeline-body"><p>Yes, these scopes behave like function scopes in terms of name resolution. See e.g. https://github.com/python/cpython/blob/main/Python/symtable.c#L545-L552 in CPython. Will add a comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-07-18 17:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-07-18 17:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-07-18 17:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:05:22 UTC
    </footer>
</body>
</html>
