<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Fix bug where ty would think all types had an `__mro__` attribute - astral-sh/ruff #20995</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Fix bug where ty would think all types had an <code>__mro__</code> attribute</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20995">#20995</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-10-20 13:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-20 13:12</div>
            <div class="timeline-body"><h2>Summary</h2>
<p><strong>This PR is best reviewed with the &quot;hide whitespace changes&quot; option enabled on GitHub.</strong></p>
<p>This PR fixes a bug where ty would consider all types as having an <code>__mro__</code> attribute, when in reality this is only true for instances of <code>type</code>. The bug is fixed by lifting our special-casing for the <code>__mro__</code> attribute out of <code>Type::member()</code> and into <code>TypeInferenceBuilder::infer_attribute_load()</code>. This means that we now only infer precise types for the <code>__mro__</code> attribute for literal attribute accesses, whereas we previously also inferred this precise type for implicit attribute accesses. I think that's okay, however: we only really need the precise inference of <code>__mro__</code> for our internal tests. Calling <code>iter_mro()</code> at a higher level (rather than in the guts of <code>Type::member()</code>) also appears to have the effect that we properly propagate the specialisation of a generic class down through the entire MRO when inferring the type of <code>someclass.__mro__</code>, resulting in more intuitive types being revealed in our <code>mro.md</code> test.</p>
<p>The type displayed in the tooltip for some autocomplete suggestions also becomes less precise, but that also seems fine. I don't think users of autocompletion need a type that's so precise there; the less precise type seems like it's probably less noisy.</p>
<p>Fixes https://github.com/astral-sh/ty/issues/986</p>
<h2>Test Plan</h2>
<p>Existing mdtests updated and TODOs removed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2025-10-20 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2025-10-20 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @AlexWaygood on 2025-10-20 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2025-10-20 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @AlexWaygood on 2025-10-20 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2025-10-20 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-10-20 13:29</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Fmro-attr?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a></h2>
<h3>Merging #20995 will <strong>improve performances by 6.23%</strong></h3>
<p><sub>Comparing <code>alex/mro-attr</code> (7c5ad22) with <code>main</code> (3c7f56f)</sub></p>
<h3>Summary</h3>
<p><code>⚡ 1</code> improvement<br />
<code>✅ 20</code> untouched<br />
<code>⏩ 30</code> skipped[^skipped]</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | ---- | --------- | ------ | ------ | ------ |
| ⚡ | Simulation | <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Fmro-attr?uri=crates%2Fruff_benchmark%2Fbenches%2Fty.rs%3A%3Amicro%3A%3Abenchmark_many_enum_members%3A%3Aty_micro%5Bmany_enum_members%5D&amp;runnerMode=Instrumentation&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>ty_micro[many_enum_members]</code></a> | 90.2 ms | 84.9 ms | +6.23% |
[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/alex%2Fmro-attr?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-20 16:08</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">beartype (https://github.com/beartype/beartype)
+ beartype/_util/hint/pep/proposal/pep484/pep484generic.py:418:18: warning[possibly-missing-attribute] Attribute `__mro__` may be missing on object of type `None | type`
- Found 514 diagnostics
+ Found 515 diagnostics

sympy (https://github.com/sympy/sympy)
+ sympy/core/function.py:186:39: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `Iterable[Unknown]`, found `~AlwaysFalsy`
+ sympy/core/function.py:188:29: error[invalid-argument-type] Argument to function `as_int` is incorrect: Expected `SupportsIndex`, found `~None`
- Found 13696 diagnostics
+ Found 13698 diagnostics

</code></pre>
</details>
No memory usage changes detected ✅

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-10-20 18:19</div>
            <div class="timeline-body"><blockquote>
<p>This PR fixes a bug where ty would consider all types as having an <code>__mro__</code> attribute, when in reality this is only true for instances of <code>type</code>. The bug is fixed by lifting our special-casing for the <code>__mro__</code> attribute out of <code>Type::member()</code> and into <code>TypeInferenceBuilder::infer_attribute_load()</code>. This means that we now only infer precise types for the <code>__mro__</code> attribute for literal attribute accesses, whereas we previously also inferred this precise type for implicit attribute accesses.</p>
</blockquote>
<p>It seems like this could have been fixed by moving that special handling to <code>class_member</code> instead?</p>
<p>Special-casing things in type inference (instead of core <code>Type</code> operations) is something I would wish we would do less of, not more. It's probably not very relevant for <code>.__mro__</code>, but in general, there are a lot of disadvantages to specializing things in type inference. The whole attribute access &quot;machinery&quot; with the descriptor protocol etc. will be overwritten, unions/intersections won't be handled, etc.</p>
<blockquote>
<p>The type displayed in the tooltip for some autocomplete suggestions also becomes less precise, but that also seems fine. I don't think users of autocompletion need a type that's so precise there</p>
</blockquote>
<p>They probably don't <em>need</em> it, but I found it kind of nice?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-20 21:49</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<details>
<summary>Changes were detected when running ty on typing conformance tests</summary>

<pre><code class="language-diff">--- old-output.txt	2025-10-27 11:15:58.398773069 +0000
+++ new-output.txt	2025-10-27 11:16:01.520786835 +0000
@@ -867,11 +867,9 @@
 specialtypes_type.py:56:7: error[invalid-argument-type] Argument to function `func4` is incorrect: Expected `type[BasicUser] | type[ProUser]`, found `&lt;class 'TeamUser'&gt;`
 specialtypes_type.py:76:17: error[invalid-type-form] type[...] must have exactly one type argument
 specialtypes_type.py:84:5: error[type-assertion-failure] Argument does not have asserted type `type[Any]`
-specialtypes_type.py:98:5: error[type-assertion-failure] Argument does not have asserted type `tuple[type, ...]`
 specialtypes_type.py:99:17: error[unresolved-attribute] Object of type `type` has no attribute `unknown`
 specialtypes_type.py:100:17: error[unresolved-attribute] Object of type `type` has no attribute `unknown`
 specialtypes_type.py:102:5: error[type-assertion-failure] Argument does not have asserted type `tuple[type, ...]`
-specialtypes_type.py:106:5: error[type-assertion-failure] Argument does not have asserted type `tuple[type, ...]`
 specialtypes_type.py:107:17: error[unresolved-attribute] Object of type `type` has no attribute `unknown`
 specialtypes_type.py:108:17: error[unresolved-attribute] Object of type `type` has no attribute `unknown`
 specialtypes_type.py:110:5: error[type-assertion-failure] Argument does not have asserted type `tuple[type, ...]`
@@ -948,5 +946,5 @@
 typeddicts_usage.py:28:17: error[missing-typed-dict-key] Missing required key 'name' in TypedDict `Movie` constructor
 typeddicts_usage.py:28:18: error[invalid-key] Invalid key access on TypedDict `Movie`: Unknown key &quot;title&quot;
 typeddicts_usage.py:40:24: error[invalid-type-form] The special form `typing.TypedDict` is not allowed in type expressions. Did you mean to use a concrete TypedDict or `collections.abc.Mapping[str, object]` instead?
-Found 950 diagnostics
+Found 948 diagnostics
 WARN A fatal error occurred while checking some files. Not all project files were analyzed. See the diagnostics list above for details.
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-10-21 01:43</div>
            <div class="timeline-body"><blockquote>
<p>Special-casing things in type inference (instead of core <code>Type</code> operations) is something I would wish we would do less of, not more.</p>
</blockquote>
<p>+1</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-21 12:33</div>
            <div class="timeline-body"><blockquote>
<p>Special-casing things in type inference (instead of core <code>Type</code> operations) is something I would wish we would do less of, not more.</p>
</blockquote>
<p>In general, I absolutely agree. In this specific case, though, I worry that ty's inferred MRO for a class is often pretty different to a class's actual MRO at runtime, because of various fictions typeshed would (for very good reasons) have us believe. For example, we infer the MRO of <code>tuple</code> on <code>main</code> as <code>tuple[&lt;class 'tuple[Unknown, ...]'&gt;, &lt;class 'Sequence[_T_co@tuple]'&gt;, &lt;class 'Reversible[_T_co@tuple]'&gt;, &lt;class 'Collection[_T_co@tuple]'&gt;, &lt;class 'Iterable[_T_co@tuple]'&gt;, &lt;class 'Container[_T_co@tuple]'&gt;, typing.Protocol, typing.Generic, &lt;class 'object'&gt;]</code>. But at runtime:</p>
<pre><code class="language-pycon">&gt;&gt;&gt; tuple.__mro__
(&lt;class 'tuple'&gt;, &lt;class 'object'&gt;)
</code></pre>
<p>Not only is typeshed's MRO for <code>tuple</code> much longer than the actual one at runtime, the MRO that we display also contains generic aliases in it, which can never appear in an MRO at runtime -- only actual class objects can appear in MROs at runtime. The lengthy MRO typeshed gives us is a white lie from typeshed, because otherwise there'd be no way to get us or other type checkers to understand that <code>tuple</code> should be considered a subtype of <code>Sequence</code> (<code>Sequence</code> is not a <code>Protocol</code>, and that's an intentional design decision in the type system). But I think displaying these frankly inaccurate MROs in things like autocomplete tooltips could honestly be pretty confusing for users, and having them be propagated through all type inference by baking the special case into <code>Type::member()</code> could have unexpected results in far-off places; to me it seems much better to keep the special case localized to actual attribute expressions in the source code. As the codspeed report shows, keeping the special case localized also seems to result in performance improvements on some microbenchmarks!</p>
<p>Honestly, after writing this all out, I'm not even sure whether we should special-case inference of the <code>__mro__</code> attribute at all. Maybe our MRO tests should instead use a custom <code>ty_extensions.reveal_mro()</code> helper instead? Precise inference for the <code>__mro__</code> attribute here wasn't ever implemented because it was something we felt users needed; it was implemented so that we'd have an easy way to write isolated unit tests for our MRO inference logic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-10-21 13:29</div>
            <div class="timeline-body"><blockquote>
<p>Honestly, after writing this all out, I'm not even sure whether we should special-case inference of the <code>__mro__</code> attribute at all. Maybe our MRO tests should instead use a custom <code>ty_extensions.reveal_mro()</code> helper instead?</p>
</blockquote>
<p>I got the same feeling when reading your comment and was glad to find that paragraph at the end :+1: :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/mro.md</code>:197 on 2025-10-26 14:00</div>
            <div class="timeline-body"><p>this demonstrates the improved semantics from this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/named_tuple.md</code>:333 on 2025-10-26 14:00</div>
            <div class="timeline-body"><p>this demonstrates the improved semantics from this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-26 14:00</div>
            <div class="timeline-body"><p>Most of the changes to the tests are now a result of switching over to the custom <code>reveal_mro</code> assertions, so I'm annotating the changes that show how the semantics are improved as a result of this PR:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-10-26 14:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_completion_eval/completion-evaluation-tasks.csv</code>:23 on 2025-10-26 14:02</div>
            <div class="timeline-body"><p>this change is because there is now another <code>ty_extensions</code> function (<code>reveal_mro</code>) that currently has a higher rank than <code>typing.reveal_type</code> in autocomplete suggestions, but would have a lower rank in an ideal world: https://github.com/astral-sh/ruff/blob/64ab79e5721ec6fdd2182fbf9d39a26534ccca43/crates/ty_completion_eval/truth/ty-extensions-lower-stdlib/main.py#L2</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-10-26 14:32</div>
            <div class="timeline-body"><p>The beartype primer hit is clearly a false negative going away. The sympy primer hits are a bit more complicated, but also look like true positives to me. The issue is that at line 177, we infer the type of <code>nargs</code> as <code>object | Any</code>: <code>Any</code> is the type of <code>nargs</code> before the <code>for</code> loop, and <code>object</code> is the type assigned to it from inside the <code>for</code> loop. <code>object | Any</code> just simplifies to <code>object</code>.</p>
<p>The conformance suite diff is also good: two false positives going away.</p>
<p>This PR should be ready for another round of review now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-10-27 08:42</div>
            <div class="timeline-body"><p>Thank you! This looks great now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2025-10-27 11:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-10-27 11:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-10-27 11:19</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:00:12 UTC
    </footer>
</body>
</html>
