<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add isort.force-sort-within-sections setting - astral-sh/ruff #1635</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add isort.force-sort-within-sections setting</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/1635">#1635</a>
        opened by <a href="https://github.com/mattoberle">@mattoberle</a>
        on 2023-01-04 19:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/mattoberle">@mattoberle</a> on 2023-01-04 19:54</div>
            <div class="timeline-body"><p>This commit is a first attempt at addressing issue #1003.</p>
<p>The default <code>isort</code> behavior is <code>force-sort-within-sections = false</code>,
which places <code>from X import Y</code> statements after <code>import X</code> statements.</p>
<p>When <code>force-sort-within-sections = true</code> all imports are sorted by module name.
When module names are equivalent, the <code>import</code> statement comes before the <code>from</code> statement.</p>
<ul>
<li>https://pycqa.github.io/isort/docs/configuration/options.html#force-sort-within-sections</li>
</ul>
<p>~Initially I tried out an <code>enum</code> + <code>match</code> approach but I was struggling to come up with anything that didn't require <code>Copy</code> support.~</p>
<hr />
<p>~The approach in this PR <em>works</em> from what I've been able to test...
But it's lacking in clarity.
The <code>merge_imports</code> function returns a vector of tuples that represent the final import order:~</p>
<pre><code>[(0 or 1, idx)]
</code></pre>
<p>~Where...~</p>
<ul>
<li>~<code>0</code> means use the <code>import_block.import</code> vector with index <code>idx</code>~</li>
<li>~<code>1</code> means use the <code>import_block.import_from</code> vector with index <code>idx</code>~</li>
</ul>
<p>~Those integers are essentially a stand-in for a type or enum, I'm just not sure what the idiomatic thing to return would be.~</p>
<ul>
<li>~An new enum like <code>ImportType::ImportFrom / ImportType::Import</code> defined in <code>types.rs</code>?~</li>
<li>~Is there a better way to do this lazily (eg. return an iterator) rather than eagerly construct the vector in <code>merge_imports</code>?~</li>
</ul>
<p><strong>Edit:</strong> Swapped out the previous approach with an iterator and enum match.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mattoberle">@mattoberle</a> reviewed on 2023-01-04 22:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mattoberle">@mattoberle</a> on <code>src/isort/sorting.rs</code>:85 on 2023-01-04 22:31</div>
            <div class="timeline-body"><p>Guessing that <code>.unwrap()</code> could be unsafe here, although I don't understand the case that results in <code>module</code> being <code>None</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/andersk">@andersk</a> reviewed on 2023-01-04 22:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/andersk">@andersk</a> on <code>src/isort/sorting.rs</code>:85 on 2023-01-04 22:34</div>
            <div class="timeline-body"><p>That happens for <code>from . import foo</code> (or <code>..</code>, <code>...</code>, etc.).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mattoberle">@mattoberle</a> reviewed on 2023-01-04 22:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mattoberle">@mattoberle</a> on <code>src/isort/sorting.rs</code>:85 on 2023-01-04 22:56</div>
            <div class="timeline-body"><p>Makes sense.
I threw one of those into my test cases but I suppose that since the block in the case is only homogeneous <code>import from</code> statements we never hit these middle conditions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mattoberle">@mattoberle</a> reviewed on 2023-01-04 23:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mattoberle">@mattoberle</a> on <code>src/isort/sorting.rs</code>:85 on 2023-01-04 23:37</div>
            <div class="timeline-body"><p>I dug into this a bit.</p>
<p>Given the current callers, <code>.unwrap()</code> will never return <code>None</code> because relative imports <em>always</em> use the <code>from X import Y</code> syntax. An import like <code>import .my_module</code> is invalid.
Relative imports are sorted in their own section and aren't compared to other first-party imports.</p>
<p>That doesn't necessarily guarantee this code path won't be hit with a missing module given a different set of settings down the road.</p>
<p>What's the best way to handle this, something like?</p>
<pre><code class="language-rs">fn cmp_option_str(a: Option&lt;&amp;String&gt;, b: Option&lt;&amp;String&gt;) -&gt; Ordering {
    match (a, b) {
        (None, None) =&gt; Ordering::Equal,
        (None, Some(_)) =&gt; Ordering::Less,
        (Some(_), None) =&gt; Ordering::Greater,
        (Some(x), Some(y)) =&gt; natord::compare_ignore_case(x, y),
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-05 19:11</div>
            <div class="timeline-body"><p>Will review this today, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @charliermarsh by @charliermarsh on 2023-01-05 19:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>src/isort/mod.rs</code>:610 on 2023-01-06 02:22</div>
            <div class="timeline-body"><p>Nit: can you destructure directly? (Like: <code>AnyImport::Import((alias, comments))</code>?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>src/isort/mod.rs</code>:601 on 2023-01-06 02:23</div>
            <div class="timeline-body"><p>Maybe instead, <code>let mut it</code>, and then call <code>sorted_by</code> on it if <code>force_sort_within_sections</code>? That way, we avoid the oddity of <code>else { Ordering::Greater }</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>src/isort/sorting.rs</code>:85 on 2023-01-06 02:23</div>
            <div class="timeline-body"><p>Yeah we should do something like what you have there, just to be safe. You can see some examples of that <code>None</code> handling in functions like <code>cmp_level</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-01-06 02:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mattoberle">@mattoberle</a> reviewed on 2023-01-06 17:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mattoberle">@mattoberle</a> on <code>src/isort/mod.rs</code>:601 on 2023-01-06 17:29</div>
            <div class="timeline-body"><p>I was sort of able to do this, although I had to <code>.collect</code> before (and within) the <code>if</code> block to ensure <code>it </code> was the same type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mattoberle">@mattoberle</a> on 2023-01-06 19:11</div>
            <div class="timeline-body"><p>Okay, I think I have this (nearly) passing (maybe a few tasks to get it up-to-date with upstream).</p>
<ul>
<li>Modified some match blocks to deref in the patterns.</li>
<li>Put the additional sort into an <code>if</code> block.</li>
<li>Replaced the bare <code>.unwrap</code> with something safer.</li>
</ul>
<p>I was struggling to put together a function that would take <code>Option&lt;&amp;str&gt;</code> arguments for a comparison.
<code>alias.name</code> is always the same type, but <code>import_from.module</code> seems to be <code>Option&lt;String&gt;</code> or <code>Option&lt;str&gt;</code> depending on whether I was running in GHA or locally. (Maybe something to do with the <code>wasm</code> target)?</p>
<p>I ultimately just unwrapped to an empty str, which I think results in the same set or sort rules getting applied (<code>&quot;&quot;</code> is before any non-empty string).</p>
<hr />
<p>In the broader picture: Is it weird to take something called <code>OrderedImportBlock</code> and then re-order it?
That was definitely the easy-way, but I started another branch that refactored things a bit...</p>
<ol>
<li>Collect all import data and put them into an unsorted <code>Vec&lt;EitherImport&gt;</code> (or unevaluated iterator).</li>
<li>Apply sort rules.</li>
<li>Iterate over the <code>EitherImport</code>s, writing to output.</li>
</ol>
<p>In that pattern there is no  concept of <code>OrderedImportBlock</code> with different <code>import</code> and <code>import_from</code> vectors.
Sorting the statements is contained within the <code>cmp_*</code> function and match blocks can consider the various settings.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-06 20:04</div>
            <div class="timeline-body"><p>I'd definitely be interested to see your other branch!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-06 20:05</div>
            <div class="timeline-body"><p>(I can help with the Option<String> conversions, we changed those recently.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-01-09 06:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-01-09 06:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-01-09 06:07</div>
            <div class="timeline-body"><p>Merging this for now! I see what you're saying with the refactor. I may knock it out, you're also welcome to PR it. Thank you for the contribution :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-01-09 06:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>src/isort/mod.rs</code>:601 on 2023-01-09 06:07</div>
            <div class="timeline-body"><p>If we use <code>sort_by</code> instead of <code>sorted_by</code>, we can avoid that allocation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mattoberle">@mattoberle</a> on 2023-01-09 18:24</div>
            <div class="timeline-body"><blockquote>
<p>Merging this for now! I see what you're saying with the refactor. I may knock it out, you're also welcome to PR it. Thank you for the contribution :)</p>
</blockquote>
<p>Thanks for your help with this!
My existing branch on the refactor is incomplete at this point (and out-of-date WRT feedback here).
If I find some time this week I'll work on getting it PR-ready, but if you have a vision don't let that stop you-- I think the exercise will still be worth it on my end.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 05:38:32 UTC
    </footer>
</body>
</html>
