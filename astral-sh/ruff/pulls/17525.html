<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Move `InstanceType` to its own submodule - astral-sh/ruff #17525</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Move <code>InstanceType</code> to its own submodule</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17525">#17525</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-04-21 16:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body">Summary
<p>This PR moves red-knot&#x27;s <code>InstanceType</code> struct out of <code>class.rs</code> and into its own submodule. The <code>InstanceType::class</code> field is made private; the <em>only</em> way of creating <code>InstanceType</code>s is now through the <code>Type::instance()</code> method (which is also moved to the new <code>instance.rs</code> submodule).</p>
<p>The motivation for this change is that it helps pave the way for adding a new <code>Type::ProtocolInstance</code> variant. When we have such a variant, I&#x27;m envisaging that the <code>Type::instance()</code> method would change to look something like this:</p>
<pre><code>impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
    pub fn instance(db: &amp;&#x27;db dyn Db, class: ClassType&lt;&#x27;db&gt;) -&gt; Self {
        if class.is_protocol(db) {
            Self::ProtocolInstance(ProtocolInstanceType { class })
        } else {
            Self::Instance(InstanceType { class })
        }
    }
}
</code></pre>
<p>Since the <code>Type::instance()</code> method would be the only public constructor for both <code>InstanceType</code> and <code>ProtocolInstanceType</code>, this would guarantee the invariant that nominal instance types would always be represented in our model using <code>Type::Instance</code> variants, and <code>Protocol</code> instance types would always be represented using <code>Type::ProtocolInstance</code> variants.</p>
<p>I also moved the <code>KnownInstanceType</code> enum to its own submodule in this PR, as it has very little to do with the other types in <code>class.rs</code>, and has equally little to do with either <code>InstanceType</code> or the <code>ProtocolInstanceType</code> that live (/will live) in <code>instance.rs</code>.</p>
<p>This PR is best reviewed commit by commit! I tried to include helpful commit messages explaining what each commit does.</p>
Test Plan
<p><code>cargo test -p red_knot_python_semantic</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-21 16:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-21 16:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-21 16:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-21 16:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-21 16:11</div>
            <div class="timeline-body">

<code>mypy_primer</code> results
<p>No ecosystem changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-04-21 16:27</div>
            <div class="timeline-body"><p>Changes here look fine to me either way. I&#x27;m curious to learn more about the pros and cons of a separate <code>Type::ProtocolInstance</code> vs reusing <code>Type::Instance</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-04-21 17:16</div>
            <div class="timeline-body"><blockquote>
<p>Changes here look fine to me either way. I&#x27;m curious to learn more about the pros and cons of a separate <code>Type::ProtocolInstance</code> vs reusing <code>Type::Instance</code>.</p>
</blockquote>
<p>To make sure I understand the alternative you&#x27;re suggesting: <code>InstanceType</code> would become an enum, and <code>ProtocolInstance</code> would live there instead of in <code>Type</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-04-21 17:29</div>
            <div class="timeline-body"><blockquote>
<p>To make sure I understand the alternative you&#x27;re suggesting: <code>InstanceType</code> would become an enum, and <code>ProtocolInstance</code> would live there instead of in <code>Type</code>?</p>
</blockquote>
<p>No, I was asking why we need an enum or <code>ProtocolInstance</code> at any level. It seems possible in principle for protocols to live entirely within <code>Type::Instance</code> and <code>InstanceType</code>, and differentiate internally based on <code>class.is_protocol()</code> of the wrapped class.</p>
<p>I do think there are likely advantages in clarity (and maybe even in performance) to having a separate variant, because it means we don&#x27;t have to check <code>is_protocol()</code> as often, and because the behavior of many methods will be entirely different for protocols vs other instances, and because semantically protocol types are a very different thing from instance types. So I&#x27;m not trying to say it would be better not to have a separate variant. I&#x27;m just interested in whether there are reasons I&#x27;m not seeing why it is <em>necessary</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for <a href="https://github.com/sharkdp">@sharkdp</a> removed by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-22 07:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-22 11:30</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;m curious to learn more about the pros and cons of a separate <code>Type::ProtocolInstance</code> vs reusing <code>Type::Instance</code>.</p>
</blockquote>
<p>Ah, sorry. Perhaps I should have written up a short design doc for this. I remember discussing this plan with you in a 1:1, but that was probably a couple of weeks ago by now, and that anyway wasn&#x27;t a conversation that was visible to the rest of the team :-(</p>
<p>The first reason why I think it makes sense for <code>ProtocolInstance</code> to be a separate variant is just that it will be much less bug-prone than trying to combine nominal and structural subtyping in one variant. Protocol instances will have fundamentally different logic to nominal instances in many of our core type-relational methods such as <code>Type::is_subtype_of</code>, <code>Type::is_assignable_to</code>, <code>Type::is_equivalent_to</code> and <code>Type::is_gradual_equivalent_to</code>. We saw in <a href="https://github.com/astral-sh/ruff/pull/17126">astral-sh/ruff#17126</a> that there were several bugs in our core type-relational methods to do with the four types nested under <code>Type::Callable</code>, mostly to do with the fact that we were often treating the four types as though they were the same when they were not. Nesting the types in the same variant made these mistakes easy to make and hard to spot: some of the bugs I fixed in that PR I knew about before I started working on the PR, but most of them I only discovered through the process of flattening out the nested type into four <code>Type</code> variants. I think having a separate <code>ProtocolInstance</code> variant from the start will be a sounder foundation on which to build structural subtyping.</p>
<p>A second reason is that, as we&#x27;ve discussed in the past, I think we will have to support synthesized protocols as well as protocols that point to a specific class definition. This will be important for normalizing protocols into types that share the same Salsa ID if they are in fact equivalent to each other, which is necessary for our implementation of <code>Type::is_equivalent_to</code> for union types. I.e., we need to ensure that this test eventually passes:</p>
<p>https://github.com/astral-sh/ruff/blob/d2b20f736789ab954445604546e25562e3906a19/crates/red_knot_python_semantic/resources/mdtest/protocols.md?plain=1#L650-L664</p>
<p>So I&#x27;m imagining that the <code>Type::ProtocolInstance</code> variant will wrap a type that looks something like this:</p>
<pre><code>enum ProtocolInstanceType&lt;&#x27;db&gt; {
    FromClass(ClassType&lt;&#x27;db&gt;),
    Synthesized(SynthesizedProtocolType&lt;&#x27;db&gt;),
}

#[salsa::tracked]
struct SynthesizedProtocolType&lt;&#x27;db&gt; {
    members: Box&lt;[ProtocolMember&lt;&#x27;db&gt;]&gt;,
}
</code></pre>
<p>As we&#x27;ve also discussed in the past, this also has the advantage that we will in the future be able to consider removing the <code>Type::Callable</code> variant and instead represent <code>Callable</code> types as synthesized protocols with a single member (<code>__call__</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-22 11:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-04-22 11:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-22 11:34</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:13:31 UTC
    </footer>
</body>
</html>
