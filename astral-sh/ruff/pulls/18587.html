<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Add decorator check for implicit attribute assignments - astral-sh/ruff #18587</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Add decorator check for implicit attribute assignments</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18587">#18587</a>
        opened by <a href="https://github.com/med1844">@med1844</a>
        on 2025-06-09 02:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a></div>
            <div class="timeline-body">

Summary


<p>Previously, the checks for implicit attribute assignments didn&#x27;t properly account for method decorators. This PR fixes that by:</p>
<ul>
<li>Adding a decorator check in <code>implicit_instance_attribute</code>. This allows it to filter out methods with mismatching decorators when analyzing attribute assignments.</li>
<li>Adding attribute search for implicit class attributes: if an attribute can&#x27;t be found directly in the class body, the <code>ClassLiteral::own_class_member</code> function will now search in classmethods.</li>
<li>Adding <code>staticmethod</code>: it has been added into <code>KnownClass</code> and together with the new decorator check, it will no longer expose attributes when the assignment target name is the same as the first method name.</li>
</ul>
<p>If accepted, it should fix <a href="https://github.com/astral-sh/ty/issues/205">astral-sh/ty#205</a> and <a href="https://github.com/astral-sh/ty/issues/207">astral-sh/ty#207</a>.</p>
Test Plan


<p>This is tested with existing mdtest suites and is able to get most of the TODO marks for implicit assignments in classmethods and staticmethods removed.</p>
<p>However, there&#x27;s one specific test case I failed to figure out how to correctly resolve:</p>
<p>https://github.com/med1844/ruff/blob/b279508bdc63c1ed6fc4ccf9d43d3719fe7a202b/crates/ty_python_semantic/resources/mdtest/attributes.md?plain=1#L754-L755</p>
<p>I tried to add <code>instance_member().is_unbound()</code> check in this <a href="https://github.com/med1844/ruff/blob/b279508bdc63c1ed6fc4ccf9d43d3719fe7a202b/crates/ty_python_semantic/src/types/infer.rs#L3299-L3301">else branch</a> but it causes tests with class attributes defined in class body to fail. While it&#x27;s possible to implicitly add <code>ClassVar</code> to qualifiers to make this assignment fail and keep everything else passing, it doesn&#x27;t feel like the right solution.</p>
<p>Another problem is that this PR also kind of breaks <code>dependency_implicit_instance_attribute</code> and <code>dependency_own_instance_member</code> in <code>src/types/infer.rs</code>. This seems to be caused by the new decorator check, which uses the inferred method function type to get the inferred decorator type. Thus, any change inside function body causes re-inferring method type. As a result, both &quot;no re-infer&quot; assertions in these two tests fails. I&#x27;m not 100% sure, but that&#x27;s my current theory.</p>
<p>Thank you very much for taking time to review üôè</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 02:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 02:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 02:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 02:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Add decorator check for implicit attribute assignments&quot; to &quot;[ty] Add decorator check for implicit attribute assignments&quot; by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 02:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-09 02:57</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>rich (https://github.com/Textualize/rich)
- warning[possibly-unbound-attribute] tests/test_text.py:247:9: Attribute `link` on type `str | Style` is possibly unbound
+ warning[possibly-unbound-attribute] tests/test_text.py:247:9: Attribute `link` on type `Unknown | str | Style` is possibly unbound
- warning[possibly-unbound-attribute] tests/test_text.py:261:9: Attribute `link` on type `str | Style` is possibly unbound
+ warning[possibly-unbound-attribute] tests/test_text.py:261:9: Attribute `link` on type `Unknown | str | Style` is possibly unbound

cki-lib (https://gitlab.com/cki-project/cki-lib)
+ error[invalid-assignment] tests/test_psql.py:40:9: Object of type `Literal[0]` is not assignable to attribute `closed` on type `Unknown | None`
+ error[invalid-assignment] tests/test_psql.py:50:9: Object of type `Literal[2]` is not assignable to attribute `closed` on type `Unknown | None`
+ error[invalid-assignment] tests/test_psql.py:83:9: Object of type `Literal[0]` is not assignable to attribute `closed` on type `Unknown | None`
- Found 166 diagnostics
+ Found 169 diagnostics

colour (https://github.com/colour-science/colour)
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:221:13: Object of type `SpectralShape` is not assignable to attribute `_shape` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:222:13: Object of type `MultiSpectralDistributions` is not assignable to attribute `_cmfs` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:222:24: Object of type `SpectralDistribution` is not assignable to attribute `_sd_D65` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:223:13: Object of type `Unknown` is not assignable to attribute `_XYZ_D65` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:224:13: Object of type `Unknown` is not assignable to attribute `_xy_D65` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:226:13: Object of type `RGB_Colourspace` is not assignable to attribute `_RGB_colourspace` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[invalid-assignment] colour/recovery/tests/test_jakob2019.py:228:13: Object of type `LUT3D_Jakob2019` is not assignable to attribute `_LUT` on type `type[TestLUT3D_Jakob2019] &amp; ~&lt;Protocol with members &#x27;_LUT&#x27;&gt;`
- error[unresolved-attribute] colour/recovery/tests/test_jakob2019.py:231:16: Attribute `_LUT` can only be accessed on instances, not on the class object `type[TestLUT3D_Jakob2019]` itself.
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:221:13: Attribute `_shape` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:222:13: Attribute `_cmfs` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:222:24: Attribute `_sd_D65` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:223:13: Attribute `_XYZ_D65` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:224:13: Attribute `_xy_D65` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:226:13: Attribute `_RGB_colourspace` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:228:13: Attribute `_LUT` on type `type[TestLUT3D_Jakob2019]` is possibly unbound
+ warning[possibly-unbound-attribute] colour/recovery/tests/test_jakob2019.py:231:16: Attribute `_LUT` on type `type[TestLUT3D_Jakob2019]` is possibly unbound

bandersnatch (https://github.com/pypa/bandersnatch)
+ error[missing-argument] src/bandersnatch_storage_plugins/swift.py:172:16: No argument provided for required parameter `path` of bound method `mkdir`
+ error[missing-argument] src/bandersnatch_storage_plugins/swift.py:178:13: No argument provided for required parameter `path` of bound method `delete_file`
+ error[missing-argument] src/bandersnatch_storage_plugins/swift.py:187:16: No arguments provided for required parameters `source`, `dest` of bound method `copy_file`
+ error[missing-argument] src/bandersnatch_storage_plugins/swift.py:192:13: No argument provided for required parameter `path` of bound method `rmdir`
+ error[missing-argument] src/bandersnatch_storage_plugins/swift.py:199:16: No arguments provided for required parameters `source`, `dest` of bound method `copy_file`
+ error[missing-argument] src/bandersnatch_storage_plugins/swift.py:203:16: No arguments provided for required parameters `source`, `dest` of bound method `copy_file`
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:128:13: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:138:14: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:140:17: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:156:14: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:158:17: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:172:16: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:178:13: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:187:16: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:192:13: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:199:16: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:203:16: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:213:16: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- error[unresolved-attribute] src/bandersnatch_storage_plugins/swift.py:219:16: Attribute `BACKEND` can only be accessed on instances, not on the class object `&lt;class &#x27;_SwiftAccessor&#x27;&gt;` itself.
- Found 132 diagnostics
+ Found 125 diagnostics

mitmproxy (https://github.com/mitmproxy/mitmproxy)
- error[invalid-return-type] examples/contrib/ntlm_upstream_proxy.py:79:33: Return type does not match returned value: expected `HTTPFlow`, found `(@Todo(Type::Intersection.call()) &amp; HTTPFlow) | None`
+ error[invalid-return-type] examples/contrib/ntlm_upstream_proxy.py:79:33: Return type does not match returned value: expected `HTTPFlow`, found `@Todo(Type::Intersection.call()) | (@Todo(Type::Intersection.call()) &amp; HTTPFlow) | None`

freqtrade (https://github.com/freqtrade/freqtrade)
- error[unresolved-attribute] freqtrade/rpc/api_server/deps.py:19:16: Attribute `_rpc` can only be accessed on instances, not on the class object `&lt;class &#x27;ApiServer&#x27;&gt;` itself.
- error[invalid-attribute-access] freqtrade/rpc/api_server/webserver.py:80:13: Cannot assign to instance attribute `_rpc` from the class object `&lt;class &#x27;ApiServer&#x27;&gt;`
- error[unresolved-attribute] freqtrade/rpc/api_server/webserver.py:89:13: Attribute `_rpc` can only be accessed on instances, not on the class object `&lt;class &#x27;ApiServer&#x27;&gt;` itself.
- Found 445 diagnostics
+ Found 442 diagnostics

scrapy (https://github.com/scrapy/scrapy)
- error[unresolved-attribute] tests/test_closespider.py:30:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_closespider.py:40:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_closespider.py:59:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_closespider.py:77:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_closespider.py:87:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_closespider.py:89:36: Type `Spider | None` has no attribute `exception_cls`
- error[unresolved-attribute] tests/test_closespider.py:99:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_closespider.py:109:18: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_contracts.py:535:16: Type `Spider | None` has no attribute `visited`
- error[unresolved-attribute] tests/test_crawl.py:79:20: Type `Spider | None` has no attribute `urls_visited`
- error[unresolved-attribute] tests/test_crawl.py:127:16: Type `Spider | None` has no attribute `t1`
- error[unresolved-attribute] tests/test_crawl.py:128:16: Type `Spider | None` has no attribute `t2`
- error[unresolved-attribute] tests/test_crawl.py:129:16: Type `Spider | None` has no attribute `t2`
- error[unresolved-attribute] tests/test_crawl.py:129:36: Type `Spider | None` has no attribute `t1`
- error[unresolved-attribute] tests/test_crawl.py:135:16: Type `Spider | None` has no attribute `t1`
- error[unresolved-attribute] tests/test_crawl.py:136:16: Type `Spider | None` has no attribute `t2`
- error[unresolved-attribute] tests/test_crawl.py:137:16: Type `Spider | None` has no attribute `t2_err`
- error[unresolved-attribute] tests/test_crawl.py:138:16: Type `Spider | None` has no attribute `t2_err`
- error[unresolved-attribute] tests/test_crawl.py:138:40: Type `Spider | None` has no attribute `t1`
- error[unresolved-attribute] tests/test_crawl.py:143:16: Type `Spider | None` has no attribute `t1`
- error[unresolved-attribute] tests/test_crawl.py:144:16: Type `Spider | None` has no attribute `t2`
- error[unresolved-attribute] tests/test_crawl.py:145:16: Type `Spider | None` has no attribute `t2_err`
- error[unresolved-attribute] tests/test_crawl.py:146:16: Type `Spider | None` has no attribute `t2_err`
- error[unresolved-attribute] tests/test_crawl.py:146:40: Type `Spider | None` has no attribute `t1`
- error[unresolved-attribute] tests/test_crawl.py:243:16: Type `Spider | None` has no attribute `visited`
- error[unresolved-attribute] tests/test_crawl.py:252:16: Type `Spider | None` has no attribute `visited`
- error[unresolved-attribute] tests/test_crawl.py:325:31: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:326:34: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:328:39: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:331:39: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:334:39: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:337:39: Type `Spider | None` has no attribute `meta`
- error[invalid-argument-type] tests/test_crawl.py:347:42: Argument to function `get_engine_status` is incorrect: Expected `ExecutionEngine`, found `Unknown | ExecutionEngine | None`
- warning[possibly-unbound-attribute] tests/test_crawl.py:355:43: Attribute `name` on type `Spider | None` is possibly unbound
- error[invalid-argument-type] tests/test_crawl.py:365:45: Argument to function `format_engine_status` is incorrect: Expected `ExecutionEngine`, found `Unknown | ExecutionEngine | None`
- warning[possibly-unbound-attribute] tests/test_crawl.py:380:43: Attribute `name` on type `Spider | None` is possibly unbound
- error[unresolved-attribute] tests/test_crawl.py:634:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:641:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:654:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:664:22: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:673:22: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:681:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:682:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:683:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:683:56: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:687:17: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:688:15: Type `Spider | None` has no attribute `full_response_length`
- error[unresolved-attribute] tests/test_crawl.py:695:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:696:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:697:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:698:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:699:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:701:34: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:703:17: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:704:15: Type `Spider | None` has no attribute `full_response_length`
- error[unresolved-attribute] tests/test_crawl.py:711:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:712:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:713:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:713:59: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:721:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:722:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:723:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:724:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:725:16: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_crawl.py:727:37: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_downloader_handlers_http_base.py:617:19: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_downloader_handlers_http_base.py:628:19: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_downloader_handlers_http_base.py:630:18: Type `Spider | None` has no attribute `meta`
- warning[possibly-unbound-attribute] tests/test_downloaderslotssettings.py:69:17: Attribute `downloader` on type `ExecutionEngine | None` is possibly unbound
- error[unresolved-attribute] tests/test_downloaderslotssettings.py:70:17: Type `Spider | None` has no attribute `times`
- error[invalid-assignment] tests/test_pqueues.py:101:9: Object of type `MockEngine` is not assignable to attribute `engine` of type `ExecutionEngine | None`
- error[unresolved-attribute] tests/test_proxy_connect.py:116:27: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_attribute_binding.py:74:20: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_attribute_binding.py:83:23: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_attribute_binding.py:100:19: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_attribute_binding.py:133:20: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_attribute_binding.py:166:20: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_attribute_binding.py:189:20: Type `Spider | None` has no attribute `meta`
- error[unresolved-attribute] tests/test_request_cb_kwargs.py:167:20: Type `Spider | None` has no attribute `checks`
- error[unresolved-attribute] tests/test_request_cb_kwargs.py:168:20: Type `Spider | None` has no attribute `checks`
- error[unresolved-attribute] tests/test_request_left.py:41:16: Type `Spider | None` has no attribute `caught_times`
- error[unresolved-attribute] tests/test_request_left.py:47:16: Type `Spider | None` has no attribute `caught_times`
- error[unresolved-attribute] tests/test_request_left.py:53:16: Type `Spider | None` has no attribute `caught_times`
- error[unresolved-attribute] tests/test_request_left.py:59:16: Type `Spider | None` has no attribute `caught_times`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:189:20: Type `Spider | None` has no attribute `skipped`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:189:44: Type `Spider | None` has no attribute `skipped`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:190:16: Type `Spider | None` has no attribute `parsed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:191:16: Type `Spider | None` has no attribute `failed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:204:16: Type `Spider | None` has no attribute `parsed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:205:16: Type `Spider | None` has no attribute `skipped`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:206:16: Type `Spider | None` has no attribute `failed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:219:16: Type `Spider | None` has no attribute `parsed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:220:16: Type `Spider | None` has no attribute `failed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:231:16: Type `Spider | None` has no attribute `parsed`
- error[unresolved-attribute] tests/test_spidermiddleware_httperror.py:232:16: Type `Spider | None` has no attribute `failed`
- Found 1253 diagnostics
+ Found 1158 diagnostics

pytest (https://github.com/pytest-dev/pytest)
+ warning[unused-ignore-comment] testing/test_terminal.py:1988:33: Unused blanket `type: ignore` directive
- Found 647 diagnostics
+ Found 648 diagnostics

prefect (https://github.com/PrefectHQ/prefect)
- warning[possibly-unbound-attribute] src/prefect/server/orchestration/global_policy.py:460:13: Attribute `state_details` on type `(Unknown &amp; State) | (Unknown &amp; None) | Unknown | State | None` is possibly unbound
+ warning[possibly-unbound-attribute] src/prefect/server/orchestration/global_policy.py:460:13: Attribute `state_details` on type `Unknown | (Unknown &amp; None) | (State &amp; @Todo(specialized non-generic class)) | None` is possibly unbound

dd-trace-py (https://github.com/DataDog/dd-trace-py)
- error[invalid-assignment] tests/ci_visibility/api/fake_runner_efd_all_pass.py:25:5: Object of type `int` is not assignable to attribute `start_ns` on type `Span | None`
+ error[invalid-assignment] tests/ci_visibility/api/fake_runner_efd_all_pass.py:25:5: Object of type `Unknown | int` is not assignable to attribute `start_ns` on type `Span | None`
- error[invalid-assignment] tests/ci_visibility/api/fake_runner_efd_mix_fail.py:25:5: Object of type `int` is not assignable to attribute `start_ns` on type `Span | None`
+ error[invalid-assignment] tests/ci_visibility/api/fake_runner_efd_mix_fail.py:25:5: Object of type `Unknown | int` is not assignable to attribute `start_ns` on type `Span | None`
- error[invalid-assignment] tests/ci_visibility/api/fake_runner_efd_mix_pass.py:25:5: Object of type `int` is not assignable to attribute `start_ns` on type `Span | None`
+ error[invalid-assignment] tests/ci_visibility/api/fake_runner_efd_mix_pass.py:25:5: Object of type `Unknown | int` is not assignable to attribute `start_ns` on type `Span | None`

zulip (https://github.com/zulip/zulip)
+ error[invalid-assignment] zerver/lib/narrow.py:882:17: Object of type `Unknown | str | int | list[int]` is not assignable to `str | int`
+ error[invalid-argument-type] zerver/lib/narrow.py:911:70: Argument to function `get_stream_by_narrow_operand_access_unchecked` is incorrect: Expected `str | int`, found `Unknown | str | int | list[int]`
+ error[invalid-argument-type] zerver/lib/narrow.py:945:69: Argument to function `maybe_rename_general_chat_to_empty_topic` is incorrect: Expected `str`, found `Unknown | str | int | list[int]`
+ error[unsupported-operator] zerver/views/message_fetch.py:209:42: Operator `+` is unsupported between objects of type `Literal[&quot;is:&quot;]` and `Unknown | str | int | list[int]`
- Found 7465 diagnostics
+ Found 7469 diagnostics

</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-06-09 03:00</div>
            <div class="timeline-body">



<a href="https://codspeed.io/astral-sh/ruff/branches/med1844%3Acheck_assignments_in_classmethods?runnerMode=Instrumentation">CodSpeed Instrumentation Performance Report</a>
Merging #18587 will <strong>degrade performances by 6.91%</strong>
<p>Comparing <code>med1844:check_assignments_in_classmethods</code> (08be875) with <code>main</code> (ca79338)</p>
Summary
<p><code>‚ùå 1 (üëÅ 1)</code> regressions<br>
<code>‚úÖ 36</code> untouched benchmarks</p>
Benchmarks breakdown
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| üëÅ | <code>ty_micro[many_string_assignments]</code> | 66.5 ms | 71.5 ms | -6.91% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 03:15</div>
            <div class="timeline-body"><p>mypy primer looks really bad... converting to draft for now. I think I might have messed up staticmethods...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 03:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/med1844">@med1844</a> on 2025-06-09 04:36</div>
            <div class="timeline-body"><p>Removing the mapping <code>&quot;staticmethod&quot; =&gt; Self::StaticMethod</code> in <code>KnownClass::try_from_file_and_name</code> seems to fix mypy primer, but this will break the known class round trip test. Will look further into this tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-06-09 10:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-10 11:21</div>
            <div class="timeline-body"><p>Thank you for working on this. I&#x27;m not doing a review for now since it&#x27;s still a draft. Let us know when you need help with this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/med1844">@med1844</a> on 2025-06-11 04:41</div>
            <div class="timeline-body"><p>It took me a good while to manually check why there&#x27;s so many more diagnostics in <code>mypy_primer</code>. For example in <a href="https://github.com/caronc/apprise/tree/master"><code>apprise</code></a> there&#x27;s 774 more diagnostics.</p>
<p>I thought it&#x27;s me that screwed up some <code>staticmethod</code> property, but further inspection shows that it&#x27;s because now <code>staticmethod</code> are supported, it actually enables <code>ty</code> to check more code, and the diagnostics yielded are actually correct.</p>
<p>As for <code>apprise</code>, it turns out it&#x27;s caused by the combination of checking more code, and low quality <code>.pyi</code> stub files. For example, <code>NotifyBase</code> defined in <a href="https://github.com/caronc/apprise/blob/master/apprise/plugins/base.py#L47">normal python file</a> inherits <code>URLBase</code>, but in the <a href="https://github.com/caronc/apprise/blob/master/apprise/plugins/base.pyi#L1">stub file</a> it doesn&#x27;t! I checked some other diagnostics in <code>apprise</code> and they all seem to point to some faulty <code>.pyi</code> file. By modifying this <code>.pyi</code> to inherit <code>URLBase</code> and re-run <code>ty</code> again locally, I was able to get rid of 61 diagnostics...</p>
<p>So, the conclusion is that to my best knowledge, the <code>staticmethod</code> implementation itself is ok. I&#x27;m change this PR to be ready for review.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/med1844">@med1844</a> on 2025-06-11 04:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-11 05:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-11 05:42</div>
            <div class="timeline-body"><p>Can you tell us more what the reason is that these tests are commented out?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-11 15:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-11 15:07</div>
            <div class="timeline-body"><p>Unfortunately it seems to be related to the new <code>implicit_instance_attribute</code> call I added in <code>ClassLiteral::own_class_member</code>. Adding that call alone would crash these two tests.</p>
<p>Edit: My previous analysis is not correct</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-12 06:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-12 06:15</div>
            <div class="timeline-body"><p>We probably need to fix this. It suggests that we now have queries that introduce cross-module dependencies (where the query needs to re-run not if just one file changes, but if any file changes).</p>
<p>A good starting point would be to figure out what the query trace/backtrace is when <code>implicit_instance_attribute</code> is called. The next step is then to discuss whether we need to introduce a new salsa query boundary or if the call shouldn&#x27;t be happening at that place to begin with.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/med1844">@med1844</a> on 2025-06-13 00:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-13 00:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-13 00:35</div>
            <div class="timeline-body"><p>Sounds good I will do some salsa crash course and see if I can figure this out. At the mean time I will mark this PR as draft.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-15 18:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-15 18:46</div>
            <div class="timeline-body"><p>After some deep dive into salsa internals, it seems to be caused by when calling <code>infer_expression_type(Id(1000))</code> (i.e. in <code>&quot;/src/main.py&quot;</code>) it tries to find <code>__new__</code> of class <code>C</code> in the class body using the newly added <code>implicit_instance_attribute</code> call.</p>
<p>This added <code>parsed_module(Id(409))</code> (i.e. <code>&quot;/src/mod.py&quot;</code>) alongside some other salsa queries as ingredients for <code>infer_expression_type(Id(1000))</code> to derive. This file is modified later, causing re-run and thus test failure.</p>
<p>Guard the newly added <code>implicit_instance_attribute</code> call with <code>if name != &quot;__new__&quot;</code> would make these two tests pass, though I&#x27;m worried that this might not be enough. I will look deeper into this and update the PR once I have a better understanding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-17 02:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 02:02</div>
            <div class="timeline-body"><p>The typical solution to these kinds of problems is to ensure that the cross-module information is protected by a Salsa query (that is, we call some Salsa query that ends up querying <code>parsed_module</code> for the source module of class C). That means that if the source module for class <code>C</code> changes in a way that doesn&#x27;t impact the result of the intermediate query, other modules&#x27; type information won&#x27;t be invalidated by that change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-17 02:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 02:02</div>
            <div class="timeline-body"><p>Thanks for working on this important feature! Let us know if there are other questions we can answer; these Salsa dependency issues are tricky.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-17 05:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 05:09</div>
            <div class="timeline-body"><p>Thank you very much for the tips, that&#x27;s god-send for someone drowning in tracing log... though I&#x27;m not very sure how that cross-module information is protected in existing code base but I will keep digging into this when free, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-17 15:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 15:03</div>
            <div class="timeline-body"><p>I guess that means the newly created salsa query would take <code>parsed_module(&quot;mod.py&quot;)</code> and decide it doesn&#x27;t change the query result in a meaningful way, so it would fail <code>shallow_verify_memo</code> but pass <code>deep_verify_memo</code>, and thus the new query as ingredient would not be marked as changed, as result <code>infer_expression_types</code> won&#x27;t re-execute because this ingredient is not changing...? Is this what &quot;new salsa query boundary&quot; mean?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-17 15:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 15:43</div>
            <div class="timeline-body"><p>Yes, that&#x27;s an accurate description! Getting even further into the Salsa weeds, the unchanged output of the query in revision N+1 would be &quot;back-dated&quot; to revision N (because although it re-executed in revision N+1, its output did not change between N and N+1). This means that all other queries depending on that output don&#x27;t need to re-execute in N+1.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-17 15:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 15:45</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;m not very sure how that cross-module information is protected in existing code base</p>
</blockquote>
<p>There&#x27;s no specific single thing that ensures this protection -- we try to catch issues using regression tests like the one that is failing here. But in general we try to ensure that wherever we use <code>parsed_module</code> and rely on the AST, it is in a function that can only be called while analyzing that same module, not while analyzing some other module. And if we need such information while analyzing some other module, then we need to add a query to get it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-17 15:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-17 15:46</div>
            <div class="timeline-body"><p>I haven&#x27;t looked into the details here, but from the description above, it sounds like we need the implicit-attribute lookup for <code>__new__</code> to go through a Salsa query. I&#x27;m not sure without looking in more detail whether there is an existing query we could be using here, or we need a new one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-18 04:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-18 04:44</div>
            <div class="timeline-body"><p>It confuses me for a good while why all existing <code>implicit_instance_attribute</code> calls won&#x27;t trigger <code>infer_expression_types</code> again even though it&#x27;s called inside of that query. It turns out the upstream call to <code>Type::member_lookup_with_policy</code> was being tracked, and thus it&#x27;s result won&#x27;t change after the parsed module changed.
The place where I added the new call doesn&#x27;t have a similar intermediate query, and thus the parsed module becomes a direct dependency of <code>infer_expression_types</code> and causing the re-run.
So yes, your analysis is correct, thanks for the guidance! Now the root cause is clear, it should be now possible to completely eliminate the bug.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-18 14:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-18 14:21</div>
            <div class="timeline-body"><p>It seems that <code>own_class_member</code> is also guarded by a salsa query (<code>Type::class_member_with_policy</code>), that&#x27;s why it works for most inputs. The reason why <code>__new__</code> fails is because <code>Type::try_call_constructor</code> calls <code>Type::find_name_in_mro_with_policy</code> directly, which bypasses salsa tracked queries (<code>class_member_with_policy</code> and <code>member_lookup_with_policy</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-18 18:41</div>
            <div class="timeline-body"><p>Thanks for tracking this down! This seems like a pre-existing issue which would have affected us anytime someone instantiated a class from a module other than the one it is defined in.</p>
<p>I think the ideal approach here is that in a separate PR, we add an explicit test for this case (that defining a class in one module and instantiating it in another module should not mean that a trivial change to the first module requires re-inferring types in the second), and we add a new tracked query method <code>lookup_dunder_new</code> (which is just a light wrapper around <code>find_name_in_mro_with_policy</code>), which should fix it. Then we rebase this PR after landing that separate fix.</p>
<p>Are you interested in taking on this fix?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-18 18:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-19 04:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-19 04:13</div>
            <div class="timeline-body"><p>Thank you for help! I&#x27;m definitely interested. Though I don&#x27;t think it&#x27;s possible to create a test case that would capture the new dependency - it&#x27;s introduced by the new call after all. There doesn&#x27;t seem to exist any other downstream calls in <code>find_name_in_mro_with_policy</code> that would introduce dependency on <code>parsed_module</code>.</p>
<p>The new query sounds good. I&#x27;m also experimenting modifying <code>implicit_instance_attribute</code> to be tracked.</p>
<p>Regarding new PRs, I think it might also make sense to split out the staticmethod support into another separate PR, so we will have 3 PRs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-19 23:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-19 23:09</div>
            <div class="timeline-body"><p>Confirmed that marking <code>implicit_instance_attribute</code> with <code>#[salsa::tracked]</code> would solve the issue, the code will pass tests without the <code>if name != &quot;__new__&quot;</code> guard.</p>
<p>I will work on the staticmethod PR and mark this one as ready to review once done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-20 17:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-20 17:13</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t think it&#x27;s possible to create a test case that would capture the new dependency - it&#x27;s introduced by the new call after all. There doesn&#x27;t seem to exist any other downstream calls in <code>find_name_in_mro_with_policy</code> that would introduce dependency on <code>parsed_module</code>.</p>
</blockquote>
<p>Based on your description of the issue (and a brief look at the code), it looked to me like a pre-existing problem on main that could be triggered simply by defining a class in one module and then instantiating it in another module (because the instantiation will call <code>try_call_constructor</code>, which will call <code>find_name_in_mro_with_policy</code>, all with no query protection.) If this is the case, it should be possible to create a test case (on main) that does this, and fails on main because the using module is wrongly invalidated by an irrelevant change to the defining module? Or am I missing some other factor that requires a change in this PR to trigger the issue?</p>
<blockquote>
<p>I&#x27;m also experimenting modifying <code>implicit_instance_attribute</code> to be tracked.</p>
</blockquote>
<p>I would expect this to fix the problem, and it could be a fine solution. The main issue is that there is a cost to every distinct memoized query-execution. So if memoizing <code>implicit_instance_attribute</code> means that in many common call paths we now go through two tracked queries instead of one, and the two memoizations are mostly redundant in terms of the work they avoid, this can harm efficiency. In this case it would be better to add a new query specific to the <code>__new__</code> lookup that is currently unguarded, so as to avoid unnecessary extra queries in other paths.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-21 03:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-21 03:52</div>
            <div class="timeline-body"><blockquote>
<p>it looked to me like a pre-existing problem on main that could be triggered simply by defining a class in one module and then instantiating it in another module</p>
</blockquote>
<p>This won&#x27;t trigger re-run. You can add the following test into <code>infer.rs</code> on main:</p>
<pre><code>    #[test]
    fn dependency_cross_module_class_and_instance() -&gt; anyhow::Result&lt;()&gt; {
        fn x_rhs_expression(db: &amp;TestDb) -&gt; Expression&lt;&#x27;_&gt; {
            let file_main = system_path_to_file(db, &quot;/src/main.py&quot;).unwrap();
            let ast = parsed_module(db, file_main).load(db);
            // Get the second statement in `main.py` (x = ‚Ä¶) and extract the expression
            // node on the right-hand side:
            let x_rhs_node = &amp;ast.syntax().body[1].as_assign_stmt().unwrap().value;

            let index = semantic_index(db, file_main);
            index.expression(x_rhs_node.as_ref())
        }

        let mut db = setup_db();

        db.write_dedented(
            &quot;/src/mod.py&quot;,
            r#&quot;
            class C:
                pass
            &quot;#,
        )?;
        db.write_dedented(
            &quot;/src/main.py&quot;,
            r#&quot;
            from mod import C
            x = C()
            &quot;#,
        )?;

        let file_main = system_path_to_file(&amp;db, &quot;/src/main.py&quot;).unwrap();
        let _attr_ty = global_symbol(&amp;db, file_main, &quot;x&quot;).place.expect_type();

        // Add a comment; this should not trigger the type of `x` to be re-inferred
        db.write_dedented(
            &quot;/src/mod.py&quot;,
            r#&quot;
            class C:
                # comment
                pass
            &quot;#,
        )?;

        let events = {
            db.clear_salsa_events();
            let _attr_ty = global_symbol(&amp;db, file_main, &quot;x&quot;).place.expect_type();
            db.take_salsa_events()
        };

        assert_function_query_was_not_run(
            &amp;db,
            infer_expression_types,
            x_rhs_expression(&amp;db),
            &amp;events,
        );

        Ok(())
    }
</code></pre>
<p>This test passes. The reason is because for normal class member lookup, the call path looks like</p>
<p><code>Type::member_lookup_with_policy/Type::class_member_with_policy (both tracked) -&gt; Type::find_name_in_mro_with_policy -&gt; ClassLiteral::class_member -&gt; ClassLiteral::class_member_inner -&gt; ClassLiteral::class_member_from_mro -&gt; ClassType::own_class_member -&gt; ClassLiteral::own_class_member</code>.</p>
<p>No other function in this call chain calls <code>parsed_module</code>. Therefore it&#x27;s safe to directly call <code>find_name_in_mro_with_policy</code> to query <code>__new__</code>. It&#x27;s the added call inside <code>own_class_member</code> that introduces dependency on <code>parsed_module</code>.</p>
<blockquote>
<p>avoid unnecessary extra queries in other paths.</p>
</blockquote>
<p>Got it! I will try to create a query for <code>__new__</code> lookup. Though my previous attempt failed to get it compile. <code>fn lookup_dunder_new(self, _db: &amp;&#x27;db dyn Db) -&gt; PlaceAndQualifiers&lt;&#x27;db&gt;</code> compiles but returning <code>Option&lt;PlaceAndQualifiers&lt;&#x27;db&gt;&gt;</code> ended up compiler shouting at me &quot;the trait bound <code>types::Type&lt;&#x27;db&gt;: SalsaStructInDb</code> is not satisfied&quot;. But I guess it&#x27;s solvable, just need more time and effort.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-21 20:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-21 20:43</div>
            <div class="timeline-body"><p>Ah, makes sense! Sorry I didn&#x27;t fully grasp that this PR was adding the AST access within the <code>__new__</code> lookup.</p>
<blockquote>
<p>the trait bound <code>types::Type&lt;&#x27;db&gt;: SalsaStructInDb</code> is not satisfied</p>
</blockquote>
<p>Ah! I think this is an unfortunate gotcha in Salsa, where the sole argument to a query function must be a Salsa input, interned struct, or tracked struct. If there are multiple arguments, they are implicitly combined into a hidden interned struct, but if there is only a single argument, and it is not a Salsa tracked struct, then you get this error.</p>
<p>In this case, the sole argument is <code>self</code>, which is a <code>Type</code>, which is not a Salsa struct.</p>
<p>The workaround is ugly, but you can just add a second unused argument of type <code>()</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/med1844">@med1844</a> reviewed on 2025-06-21 22:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/med1844">@med1844</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:10356 on 2025-06-21 22:26</div>
            <div class="timeline-body"><p>No need to sorry and thank you for the tips! My previous workaround is to simply create <code>find_name_in_mro_with_policy_tracked</code> but the unit type with <code>lookup_dunder_new</code> seems much better here.</p>
<p>I think it&#x27;s finally ready to review! Thank you very much again, it&#x27;s been really helpful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/med1844">@med1844</a> on 2025-06-21 22:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-23 18:36</div>
            <div class="timeline-body"><p>Thank you very much for working on this! I am planning to review this tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-24 08:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-06-24 09:31</div>
            <div class="timeline-body"><p>Thank you very much ‚Äî this is great!</p>
<p>In particular, thank you for going through the salsa debugging session and for adding a incremental-computation test.</p>
<p>While looking through the ecosystem changes, I noticed a behavior related to attributes that are implicitly defined in methods with an unknown decorator:</p>
<pre><code>class C:
    @unknown_decorator
    def f(self):
        self.x: int = 1

C.x  # this was previously an error
</code></pre>
<p>We now consider these attributes to be available on the class itself. I think this is actually a good example of the gradual guarantee: <code>unknown_decorator</code> <em>could</em>, in principle, be an alias to <code>builtins.classmethod</code>. And so it seems good to not show an error here. Because if <code>unknown_decorator</code> was annotated appropriately, we would not show an error as well.</p>
<p>I added a test to document this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-24 09:35</div>
            <div class="timeline-body"><blockquote>
<p>However, there&#x27;s one specific test case I failed to figure out how to correctly resolve:</p>
<p>https://github.com/med1844/ruff/blob/b279508bdc63c1ed6fc4ccf9d43d3719fe7a202b/crates/ty_python_semantic/resources/mdtest/attributes.md?plain=1#L754-L755</p>
<p>I tried to add <code>instance_member().is_unbound()</code> check in this <a href="https://github.com/med1844/ruff/blob/b279508bdc63c1ed6fc4ccf9d43d3719fe7a202b/crates/ty_python_semantic/src/types/infer.rs#L3299-L3301">else branch</a> but it causes tests with class attributes defined in class body to fail. While it&#x27;s possible to implicitly add <code>ClassVar</code> to qualifiers to make this assignment fail and keep everything else passing, it doesn&#x27;t feel like the right solution.</p>
</blockquote>
<p>I think it&#x27;s fine to keep this for a follow-up changeset. I generally agree with your analysis, but maybe adding an implicit <code>ClassVar</code> qualifier to attributes that are defined in <code>@classmethod</code>s wouldn&#x27;t be too bad? This would mean that we handle the <code>x</code> attributes on the following two classes equivalently, which seems like a good thing?</p>
<pre><code>class C1:
    x: ClassVar[int]

class C2:
    @classmethod
    def method(cls):
        cls.x: int
</code></pre>
<p>If this is inconsistent for some reason (maybe when printing the type + qualifiers of <code>C2.x</code> somewhere), we could perhaps add a new <code>ImplicitClassVar</code> qualifier with similar behavior?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-24 09:41</div>
            <div class="timeline-body"><blockquote>
<p>Merging #18587 will <strong>degrade performances by 6.91%</strong>
<code>ty_micro[many_string_assignments]</code></p>
</blockquote>
<p>I acknowledged this performance regression. There are also a few smaller 1-2% regressions in other benchmarks. On this branch, we need to do a lot more work on <em>every attribute access</em> <code>obj.x</code>. Since we always look up <code>x</code> on the type of <code>obj</code> first, and <code>x</code> might be implicitly defined in a <code>@classmethod</code> on the type of <code>obj</code>, we now go through all methods on the type of <code>obj</code> twice, instead of just once (looking for implicit <em>instance</em> attributes).</p>
<p>The <code>many_string_assignments</code> benchmark is affected in particular, presumably because it accesses attributes (e.g. <code>__add__</code>) on <code>str</code> with a lot of methods.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-24 09:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-24 09:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/med1844">@med1844</a> on 2025-06-24 15:44</div>
            <div class="timeline-body"><p>Thank you for the review and the commits! Sorry I was not paying enough attention to code comments.</p>
<p>Regarding the test case:</p>
<blockquote>
<p>but maybe adding an implicit <code>ClassVar</code> qualifier to attributes that are defined in <code>@classmethod</code>s wouldn&#x27;t be too bad?</p>
</blockquote>
<p>My main concern is that it would be surprising for users to see <code>C2.x</code> implicitly become a class variable in the diagnostics without being explicitly marked as such. It could be especially confusing for those not already familiar with <code>ClassVar</code>.</p>
<blockquote>
<p>If this is inconsistent for some reason (maybe when printing the type + qualifiers of <code>C2.x</code> somewhere), we could perhaps add a new <code>ImplicitClassVar</code> qualifier with similar behavior?</p>
</blockquote>
<p>I&#x27;m not a huge fan of adding something so similar to <code>ClassVar</code>, but if there isn&#x27;t a more elegant approach, this would be the best option. It would also allow us to provide a more user-friendly diagnostic message.</p>
<p>If we decides to go with <code>ImplicitClassVar</code>, I will create a follow up PR, which should be relatively small.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-25 07:07</div>
            <div class="timeline-body"><blockquote>
<p>My main concern is that it would be surprising for users to see C2.x implicitly become a class variable in the diagnostics without being explicitly marked as such. It could be especially confusing for those not already familiar with ClassVar.</p>
</blockquote>
<p>:+1:</p>
<blockquote>
<p>if there isn&#x27;t a more elegant approach</p>
</blockquote>
<p>I think we&#x27;ll eventually want to add a richer return type for methods such as <code>Type::member_lookup_with_policy</code> that would not just return type, boundness information, and qualifiers, but also other metadata such as:</p>
<ul>
<li>was the attribute found on the meta type or on the instance?</li>
<li>did we end up calling a descriptor <code>__get__</code> method while resolving the attribute access?</li>
<li>if so, was is a data or a non-data descriptor?</li>
<li>if we could not resolve the attribute access, what was the reason (not found anywhere, call to <code>__get__</code> failed, ‚Ä¶)</li>
</ul>
<p>In this process, we could probably also add metadata for what is needed here.</p>
<blockquote>
<p>I&#x27;m not a huge fan of adding something so similar to <code>ClassVar</code></p>
</blockquote>
<p>I think we could probably try to build a nice abstraction? <code>TypeQualifiers</code> could become a single-field struct that stores the bitflags internally. We could then provide an API that can not be misused: a <code>is_class_var()</code> method that would return true for both explicit and &quot;implicit&quot; <code>ClassVar</code>s. And a second method for displaying/explaining a type with such a qualifier to the user, that would distinguish between the two flags.</p>
<p>What I&#x27;m more concerned about is the fact that type qualifiers have a rather precise meaning, and they are only associated with <em>declared</em> / explicitly annotated symbols or attributes. With this change, we would also attach non-trivial type qualifiers to attributes that were defined without an annotation (<code>cls.x = 1</code> in a <code>@classmethod</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/med1844">@med1844</a> on 2025-06-25 15:26</div>
            <div class="timeline-body"><p>I&#x27;m not sure if I fully understands your points, here&#x27;s my understanding:</p>
<ul>
<li>We can add <code>ImplicitClassVar</code>, and also add more methods into <code>TypeQualifiers</code> to provide better abstraction.</li>
<li>This will be replaced with a separate metadata field in future.</li>
</ul>
<p>The metadata approach seems to solve the root problem and is extensible, though I guess it needs a little bit more refactoring.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-25 17:55</div>
            <div class="timeline-body"><blockquote>
<p>The metadata approach seems to solve the root problem and is extensible, though I guess it needs a little bit more refactoring.</p>
</blockquote>
<p>Yes, exactly. I&#x27;m afraid this would be a larger project, but the issue here is not that urgent, I think. So it might make sense to just wait for that metadata refactoring/extension.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/med1844">@med1844</a> on 2025-06-26 03:52</div>
            <div class="timeline-body"><p>Sounds good! I will work on other issues while waiting for the refactor.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:15:24 UTC
    </footer>
</body>
</html>
