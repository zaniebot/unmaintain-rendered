<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Use an interval map for scopes by expression - astral-sh/ruff #19025</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Use an interval map for scopes by expression</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/19025">#19025</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2025-06-29 14:45
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-29 14:45</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>The semantic index stores a map from expression to scope because we need to know in which <code>TypeInference</code> (scope) to look up the expression's type. Today, we use a hash map to store the expression-to-scope mapping.</p>
<p>This PR replaces the hash map with an interval map (vector-based) that maps a range of node IDs (expressions) to their corresponding scope. The advantage of an interval map over a hash map is that it reduces memory consumption from <code>O(expressions)</code> to <code>O(~scopes)</code>.</p>
<p>The main downside (other than increased complexity) is that the lookup complexity increases from <code>O(1)</code> to <code>O(log(~scopes))</code>. Looking at the benchmark results, the fact that we need to write less data outweighs the slightly slower lookup times.</p>
<p>The instrumented benchmarks show a 1-2% performance improvement. I measured memory consumption on a large project and the overall memory consumption of all semantic indices decreased by about 5%,</p>
<h2>Test plan</h2>
<p><code>cargo test</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @MichaReiser on 2025-06-29 14:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @MichaReiser on 2025-06-29 14:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @MichaReiser on 2025-06-29 14:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @MichaReiser on 2025-06-29 14:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-29 14:48</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅</p>
<details>
<summary>Memory usage changes were detected when running on open source projects</summary>

<pre><code class="language-diff">flake8 (https://github.com/pycqa/flake8)
-     memo fields = ~66MB
+     memo fields = ~63MB

prefect (https://github.com/PrefectHQ/prefect)
-     memo fields = ~568MB
+     memo fields = ~541MB

</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-29 14:55</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @MichaReiser on 2025-07-12 16:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @MichaReiser on 2025-07-12 16:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @MichaReiser on 2025-07-12 16:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @MichaReiser on 2025-07-12 16:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @MichaReiser on 2025-07-12 16:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:2661 on 2025-07-14 07:28</div>
            <div class="timeline-body"><p>Is this something that would change with the proposal in https://github.com/astral-sh/ruff/pull/19271?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:2696 on 2025-07-14 07:42</div>
            <div class="timeline-body"><p>Using <code>rposition</code> may require walking large distances back if the inner interleaving scopes are large? Would it make sense to use a binary search here? Something like</p>
<pre><code class="language-suggestion">        if self
            .expression_and_scope
            .last()
            .is_none_or(|last| last.0 &lt;= expression_index)
        {
            self.expression_and_scope.push((expression_index, scope));
            return;
        }

        if self.expression_and_scope[0].0 &gt; expression_index {
            self.expression_and_scope
                .insert(0, (expression_index, scope));
            return;
        }

        let insertion_point = self
            .expression_and_scope
            .partition_point(|(index, _)| *index &lt;= expression_index);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:2722 on 2025-07-14 07:51</div>
            <div class="timeline-body"><p>Not sure if better, but avoids wrapping/unwrapping of node indices into u32's (with theoretical overflow problems)</p>
<pre><code class="language-suggestion">        let mut range = first.0..=first.0;

        for (index, scope) in iter {
            if scope == current_scope {
                range = (*range.start())..=index;
                continue;
            }

            interval_map.push((range, current_scope));

            current_scope = scope;
            range = index..=index;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-07-14 07:51</div>
            <div class="timeline-body"><p>Very nice — thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-14 07:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:2661 on 2025-07-14 07:53</div>
            <div class="timeline-body"><p>Yes, but I don't think it would invalidate the entire approach. Instead, we would have to use a regular <code>sort</code> call in <code>build</code> before building the interval map (and Rust's sorting claims to be pretty good at sorting mostly sorted data)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/semantic_index/builder.rs</code>:2696 on 2025-07-14 07:54</div>
            <div class="timeline-body"><p>I initially used a binary search and it was slower :)</p>
<p>I think this is simply because we don't have any large interleaved scopes. The only weird scoping is with comprehensions and they are only very few expressions</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-07-14 07:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2025-07-14 11:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2025-07-14 11:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-07-14 11:51</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:33:37 UTC
    </footer>
</body>
</html>
