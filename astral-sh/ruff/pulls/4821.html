<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`perflint`] Add `perflint` plugin, add first rule `PERF102` - astral-sh/ruff #4821</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>perflint</code>] Add <code>perflint</code> plugin, add first rule <code>PERF102</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/4821">#4821</a>
        opened by <a href="https://github.com/qdegraaf">@qdegraaf</a>
        on 2023-06-02 23:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/qdegraaf">@qdegraaf</a> on 2023-06-02 23:56</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Adds boilerplate for implementing the <a href="https://github.com/tonybaloney/perflint/">perflint</a> plugin, plus a first rule.</p>
<ul>
<li><p>[x] ~~Add check that <code>items()</code> is called on a <code>dict</code>~~</p>
<ul>
<li>Upstream implementation in <code>perflint</code> does not do this, neither does a similar check in Ruff (<code>SIM118</code>). Code checks for some heuristics (no args, return value is an iterable of tuples etc., unpacked into two vars one of which is dummied, etc.) which should minimise the risk. See also discussion in Discord. @charliermarsh it is an open question whether or not it is a good idea to autofix in this situation, I'll leave that call to you. Can remove if too risky.</li>
</ul>
</li>
<li><p>[x] Add autofix</p>
</li>
</ul>
<h2>Test Plan</h2>
<p>Fixture added for PER8102</p>
<h2>Issue link</h2>
<p>Refers: https://github.com/charliermarsh/ruff/issues/4789</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-06-03 00:28</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Ecosystem</h3>
<p>ℹ️ ecosystem check <strong>detected changes</strong>. (+8, -0, 0 error(s))</p>
<details><summary>airflow (+6, -0)</summary>
<p>

<pre><code class="language-diff">+ airflow/utils/log/trigger_handler.py:115:21: PERF102 [*] When using only the values of a dict use the `values()` method
+ tests/kubernetes/test_pod_generator.py:564:21: PERF102 [*] When using only the values of a dict use the `values()` method
+ tests/providers/amazon/aws/waiters/test_custom_waiters.py:101:24: PERF102 [*] When using only the keys of a dict use the `keys()` method
+ tests/providers/amazon/aws/waiters/test_custom_waiters.py:72:24: PERF102 [*] When using only the keys of a dict use the `keys()` method
+ tests/serialization/test_dag_serialization.py:380:21: PERF102 [*] When using only the values of a dict use the `values()` method
+ tests/www/views/test_views_acl.py:124:24: PERF102 [*] When using only the keys of a dict use the `keys()` method
</code></pre>
</p>
</details>
<details><summary>bokeh (+2, -0)</summary>
<p>

<pre><code class="language-diff">+ src/bokeh/embed/util.py:333:30: PERF102 [*] When using only the values of a dict use the `values()` method
+ src/bokeh/models/sources.py:541:25: PERF102 [*] When using only the values of a dict use the `values()` method
</code></pre>
</p>
</details>

<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.01      6.4±0.02ms     6.4 MB/sec    1.00      6.3±0.01ms     6.5 MB/sec
formatter/numpy/ctypeslib.py               1.01   1327.8±3.94µs    12.5 MB/sec    1.00   1316.9±2.62µs    12.6 MB/sec
formatter/numpy/globals.py                 1.01    128.9±0.32µs    22.9 MB/sec    1.00    127.5±0.29µs    23.1 MB/sec
formatter/pydantic/types.py                1.00      2.6±0.00ms     9.9 MB/sec    1.00      2.6±0.02ms     9.9 MB/sec
linter/all-rules/large/dataset.py          1.00     13.7±0.08ms     3.0 MB/sec    1.00     13.8±0.10ms     3.0 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.3±0.01ms     5.0 MB/sec    1.00      3.3±0.01ms     5.0 MB/sec
linter/all-rules/numpy/globals.py          1.00    414.0±1.18µs     7.1 MB/sec    1.00    414.7±1.41µs     7.1 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.8±0.03ms     4.4 MB/sec    1.00      5.8±0.02ms     4.4 MB/sec
linter/default-rules/large/dataset.py      1.00      6.7±0.02ms     6.1 MB/sec    1.00      6.7±0.02ms     6.1 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1443.1±3.90µs    11.5 MB/sec    1.00   1446.6±3.63µs    11.5 MB/sec
linter/default-rules/numpy/globals.py      1.00    159.2±0.25µs    18.5 MB/sec    1.01    160.1±0.70µs    18.4 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.0±0.02ms     8.4 MB/sec    1.00      3.0±0.01ms     8.4 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      6.5±0.02ms     6.3 MB/sec    1.07      7.0±2.25ms     5.8 MB/sec
formatter/numpy/ctypeslib.py               1.00   1286.5±7.73µs    12.9 MB/sec    1.01  1297.9±35.90µs    12.8 MB/sec
formatter/numpy/globals.py                 1.01    124.4±9.32µs    23.7 MB/sec    1.00    123.0±1.46µs    24.0 MB/sec
formatter/pydantic/types.py                1.00      2.6±0.01ms     9.7 MB/sec    1.00      2.6±0.01ms     9.7 MB/sec
linter/all-rules/large/dataset.py          1.00     13.1±0.05ms     3.1 MB/sec    1.06     14.0±0.04ms     2.9 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.3±0.01ms     5.0 MB/sec    1.04      3.4±0.01ms     4.9 MB/sec
linter/all-rules/numpy/globals.py          1.00    342.3±3.35µs     8.6 MB/sec    1.04    354.4±2.11µs     8.3 MB/sec
linter/all-rules/pydantic/types.py         1.00      5.7±0.03ms     4.5 MB/sec    1.05      5.9±0.03ms     4.3 MB/sec
linter/default-rules/large/dataset.py      1.00      6.8±0.02ms     5.9 MB/sec    1.13      7.8±0.04ms     5.2 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1382.7±5.95µs    12.0 MB/sec    1.11  1537.6±14.58µs    10.8 MB/sec
linter/default-rules/numpy/globals.py      1.00    149.0±0.92µs    19.8 MB/sec    1.08    160.8±2.16µs    18.4 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.0±0.02ms     8.4 MB/sec    1.11      3.4±0.02ms     7.6 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @qdegraaf on 2023-06-03 10:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/auscompgeek">@auscompgeek</a> on 2023-06-03 12:58</div>
            <div class="timeline-body"><p>FWIW perflint's code prefix seems to be <code>W8xxx</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:99 on 2023-06-03 22:27</div>
            <div class="timeline-body"><p>You should be able to remove the length check here because your match pattern only matches for exactly two elements</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-06-03 22:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on 2023-06-04 11:13</div>
            <div class="timeline-body"><blockquote>
<p>FWIW perflint's code prefix seems to be <code>W8xxx</code></p>
</blockquote>
<p>Ah yeah, was worried that might clash with <code>Pycodestyle</code> plugin but that stops at <code>W6XX</code> both in the Ruff port and in the <a href="https://pycodestyle.pycqa.org/en/latest/intro.html#error-codes">original upstream implementation</a> by the looks of it. I'll make the prefix <code>W8</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`[perflint]` Add `perflint` plugin, add first rule PER8102" to "`[perflint]` Add `perflint` plugin, add first rule W8102" by @qdegraaf on 2023-06-04 11:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @charliermarsh by @MichaReiser on 2023-06-05 06:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/resources/test/fixtures/perflint/W8102.py</code>:1 on 2023-06-08 05:42</div>
            <div class="timeline-body"><p>Thanks for working on this. Can we add some more test cases?</p>
<pre><code class="language-python"># Parenthesis
for (key, value) in some_dict.items():
	...

for (key, _) in some_dict.items():
	...

for (_, value) in some_dict.items():
	...

# Single variable with `items`
for pair in some_dict.items():
	...
</code></pre>
<p>There are bunch of real world cases which can be used for testing purposes: https://sourcegraph.com/search?q=context:global+lang:Python+for+%5C(<em>,+</em>%5C)+in+%5Cw+%5C.items&amp;patternType=regexp&amp;sm=1&amp;groupBy=repo</p>
<ul>
<li>Key/value is a tuple where some elements are ignored</li>
<li>Key/value is a tuple but using <code>(_, _)</code> to ignore instead of <code>_</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-06-08 05:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/resources/test/fixtures/perflint/W8102.py</code>:1 on 2023-06-08 09:57</div>
            <div class="timeline-body"><p>Good catch thanks! I have added the extra test cases. Current implementation does not catch these yet so will find some time to come up with something clean to check for all three scenarios:</p>
<pre><code>ExprName, ExprName
ExprName, ExprTuple
ExprTuple, ExprTuple
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-06-08 09:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @qdegraaf on 2023-06-08 09:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/resources/test/fixtures/perflint/W8102.py</code>:1 on 2023-06-08 10:23</div>
            <div class="timeline-body"><p>Seeing as the tuples could be N-layers deep, recursion would seem a good fit and would probably be the first thing I try. I'm not familiar with Rust's attitude towards recursive functions though, or whether it has a better solution</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-06-08 10:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-06-08 19:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/resources/test/fixtures/perflint/W8102.py</code>:1 on 2023-06-08 19:56</div>
            <div class="timeline-body"><p>New edits should catch these scenarios. I'll see if I can make it a bit less clunky and verbose.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @qdegraaf on 2023-06-08 19:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:76 on 2023-06-09 01:57</div>
            <div class="timeline-body"><p>nit: Can we use the <code>let ... else { return }</code> pattern instead of <code>if let ... { ... }</code> to avoid nesting. It'll also make the code linear and easier to read :)</p>
<p>I think you're already using this pattern in a few other places.</p>
<pre><code class="language-rust">    let Expr::Call(ast::ExprCall { func, args, .. }) = iter else {
    	return;
    }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:88 on 2023-06-09 01:59</div>
            <div class="timeline-body"><p>nit: explicit names are good for posterity :)</p>
<pre><code class="language-suggestion">            range: tuple_range,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:129 on 2023-06-09 02:30</div>
            <div class="timeline-body"><p>Shouldn't this be outside the <code>if let Expr::Name(...</code> block? The same question for other branches as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:59 on 2023-06-09 02:47</div>
            <div class="timeline-body"><p>nit: Would <code>is_ignored_tuple_or_name</code> be better? I prefer to avoid negation in the name for better readability. Then the return comparison will be simpler: <code>id == &quot;_&quot;</code>. This would also make the recursive case easier to reason about.</p>
<pre><code class="language-suggestion">fn is_ignored_tuple_or_name(expr: &amp;Expr) -&gt; bool {
    if let Expr::Name(ast::ExprName { id, .. }) = expr {
        return id == &quot;_&quot;;
    }

    if let Expr::Tuple(ast::ExprTuple { elts, .. }) = expr {
        return elts.iter().all(is_ignored_tuple_or_name);
    }
    false
}

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:141 on 2023-06-09 02:49</div>
            <div class="timeline-body"><p>Using <code>is_ignored_tuple_or_name</code> would make this simpler as well. So, instead of negating the result here, we'll do it in the function itself.</p>
<pre><code class="language-suggestion">                    if !sub_elts
                        .iter()
                        .all(is_ignored_tuple_or_name)
</code></pre>
<p>If you think otherwise, using <code>is_not_ignored_tuple_or_name</code> could be simplified as:</p>
<pre><code class="language-suggestion">                    if sub_elts
                        .iter()
                        .any(is_not_ignored_tuple_or_name)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:223 on 2023-06-09 02:50</div>
            <div class="timeline-body"><p>Same as above</p>
<pre><code class="language-suggestion">                    if !sub_elts
                        .iter()
                        .all(is_ignored_tuple_or_name)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/snapshots/ruff__rules__perflint__tests__W8102_W8102.py.snap</code>:9 on 2023-06-09 02:55</div>
            <div class="timeline-body"><p>I would say the diagnostics should be at <code>.items()</code> instead, the <code>_</code> is the reason due to which the violation happens. And we're also suggesting to replace <code>.items()</code>. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-06-09 02:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:129 on 2023-06-10 09:30</div>
            <div class="timeline-body"><p>Depends on what we want the behaviour to be. Current implementation does not continue if it finds a violation for the first of the two args. So a case of</p>
<pre><code class="language-python">for _, _ in d.items():
    pass
</code></pre>
<p>Will trigger a violation only for the first arg. Do we think it should be the responsibility of this rule to check for a completely ignored <code>.items()</code> call? And if so what do we want to do with autofixes?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-06-10 09:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-06-10 09:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:76 on 2023-06-10 09:57</div>
            <div class="timeline-body"><p>Good suggestion! Done it for a bunch of <code>if let</code>'s now. Could go one or two steps further (and now maybe refactoring to some <code>fn</code> that can be called on both elements instead of having 4 branches of code for both scenarios for both elements). But already liking its readability much more so your call AFAIAC</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dhruvmanila by @dhruvmanila on 2023-06-10 16:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:35 on 2023-06-12 10:30</div>
            <div class="timeline-body"><p>Can this be a <code>&amp;'static str</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:69 on 2023-06-12 10:33</div>
            <div class="timeline-body"><p>nit:</p>
<pre><code class="language-suggestion">        return;
    };
</code></pre>
<p>rustfmt unfortunately doesn't support let-else yet</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2023-06-12 12:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:35 on 2023-06-12 12:37</div>
            <div class="timeline-body"><p>Unsure. It's a <code>String</code> for all other Violations I have found so I just stuck to that. Unsure if there is a specific reason for those violations to use <code>String</code> instead of <code>&amp;'static str</code> that is not valid in this case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/qdegraaf">@qdegraaf</a> reviewed on 2023-06-12 12:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:117 on 2023-06-12 17:00</div>
            <div class="timeline-body"><p>I think we could convert this into a function which can accept a <code>subset</code> parameter which could be an <code>enum</code> instead of a string and an <code>expr</code> parameter which would be the other expression node.</p>
<p>We could also simplify the extraction of <code>fix_val</code> to avoid creating an invalid state where the other element isn't a <code>Name</code> or <code>Tuple</code> node.</p>
<pre><code class="language-suggestion">                    let fix_val = match &amp;elts[1] {
                        Expr::Name(ast::ExprName { id, .. }) =&gt; id.as_str(),
                        Expr::Tuple(ast::ExprTuple {
                            range: val_range, ..
                        }) =&gt; checker.locator.slice(*val_range),
                        _ =&gt; panic!(&quot;Expected Expr::Name | Expr::Tuple&quot;),
                    };
                    diagnostic.set_fix(Fix::automatic_edits(
                        Edit::range_replacement(&quot;.values&quot;.to_string(), method_range),
                        [Edit::range_replacement(fix_val.to_string(), *tuple_range)],
                    ));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/registry.rs</code>:195 on 2023-06-12 17:06</div>
            <div class="timeline-body"><p>I'm not sure about the prefix here as we would want a 3 letter abbreviation for the plugin name (<code>PER</code>, <code>PRF</code>?). It's ok to deviate from the actual rule code for consistency :)</p>
<p>\cc @charliermarsh</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> approved on 2023-06-12 17:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-06-12 17:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:129 on 2023-06-12 17:13</div>
            <div class="timeline-body"><p>This is an interesting case. <code>perflint</code> seems to be triggering for both key and value place which doesn't seem correct to me. I guess the reason someone would want to use a loop like this is to do something <code>n</code> number of times where <code>n</code> is the dictionary length. I would suggest to ignore such cases plus I don't think it's the responsibility of this rule to check it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-06-12 18:59</div>
            <div class="timeline-body"><p>Will give this a pass and merge today.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/registry.rs</code>:195 on 2023-06-12 18:59</div>
            <div class="timeline-body"><p>Maybe <code>PERF</code>? We've started to use some four-letter prefixes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-06-12 18:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/qdegraaf">@qdegraaf</a> on 2023-06-12 20:26</div>
            <div class="timeline-body"><blockquote>
<p>Will give this a pass and merge today.</p>
</blockquote>
<p>Let me know if any input is requested. Happy to step aside though, earliest I can get round to @dhruvmanila's comments and extracting some stuff to a function is tomorrow evening (GMT+1)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-06-13 01:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/rules/perflint/rules/incorrect_dict_iterator.rs</code>:35 on 2023-06-13 01:18</div>
            <div class="timeline-body"><p>I recommend using an <code>enum</code> in cases like this (see below).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`[perflint]` Add `perflint` plugin, add first rule W8102" to "[`perflint`] Add `perflint` plugin, add first rule `PERF102`" by @charliermarsh on 2023-06-13 01:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by @charliermarsh on 2023-06-13 01:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-06-13 01:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-06-13 01:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-06-15 11:16</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 03:44:07 UTC
    </footer>
</body>
</html>
