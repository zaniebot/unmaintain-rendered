<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Match tuple formatting - astral-sh/ruff #18147</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Match tuple formatting</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18147">#18147</a>
        opened by <a href="https://github.com/maxmynter">@maxmynter</a>
        on 2025-05-17 04:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a></div>
            <div class="timeline-body">

<p>Closes #17969</p>
Summary
<p>Add check to sequence type determination of <code>match</code> formatting to distinguish between a list and a tuple whose leading element is a list.</p>
<p>Previously, we only checked for an opening bracket, <code>[</code>, now we additionally check for top level commata to determine if it is a tuple and return the according type.</p>
<p>The resulting formatting behaviour is consistent with Black.</p>


Test Plan
<p>Added a test case to ruff&#x27;s tests.
Note: this case is not covered in tests imported from Black.</p>
<p>Manually compared Black, and this fix on the example from the issue.</p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-05-17 04:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-05-17 04:57</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Formatter (stable)
<p>✅ ecosystem check detected no format changes.</p>
Formatter (preview)
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">formatter</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-17 15:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs</code>:97 on 2025-05-17 15:22</div>
            <div class="timeline-body"><p>I think the proper fix here is to only look at the text of the outer pattern by using:</p>
<pre><code>let text = &amp;source[TextRange::new(pattern.start(), pattern.values.first().map(Ranged::end).unwrap_or(pattern.end())];
</code></pre>
<p>This will return `` <code>case [], []:</code> because the <code>[</code> belongs to the inner pattern (and not the outer.</p>
<p>We can then use the same text for the elif on line 97</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-05-17 15:23</div>
            <div class="timeline-body"><p>Thank you. I&#x27;ve a small suggestion which may make this less fragile.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-05-18 02:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs</code>:97 on 2025-05-18 02:06</div>
            <div class="timeline-body"><p>I&#x27;m not sure if my understanding is correct.</p>
<p>On the on the first example of the issue it gives</p>
<pre><code>[crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs:82:29] &amp;source[TextRange::new(pattern.start(),
pattern.patterns.first().map(Ranged::end).unwrap_or(pattern.end()),)] = &quot;[]&quot;
</code></pre>
<p>Do you mean something  like this:</p>
<pre><code>    pub(crate) fn from_pattern(pattern: &amp;PatternMatchSequence, source: &amp;str) -&gt; SequenceType {
        let first_element = dbg!(&amp;source[TextRange::new(
            pattern.start(),
            pattern
                .patterns
                .first()
                .map(Ranged::end)
                .unwrap_or(pattern.end()),
        )]);
        if first_element.starts_with(&quot;[&quot;) {
            if first_element == &amp;source[pattern.range()] {
                SequenceType::List
            } else {
                SequenceType::TupleNoParens
            }
        } else if first_element.starts_with(&#x27;(&#x27;) {
</code></pre>
<p>(this breaks format and black compatibility tests, though).</p>
<p>We cannot check for a leading <code>[</code> because that way we cannot discriminate between a tuple that starts with a list, <code>[],_</code> and a list, <code>[_]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-05-18 15:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs</code>:97 on 2025-05-18 15:27</div>
            <div class="timeline-body"><p>Sorry, I messed up the code example. We should take the <code>start</code> of the first pattern, not the end</p>
<pre><code>let text = &amp;source[TextRange::new(pattern.start(), pattern.values.first().map(Ranged::start).unwrap_or(pattern.end())];
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-05-19 01:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs</code>:97 on 2025-05-19 01:14</div>
            <div class="timeline-body"><p>This implementation</p>
<pre><code>    pub(crate) fn from_pattern(pattern: &amp;PatternMatchSequence, source: &amp;str) -&gt; SequenceType {
        let text = &amp;source[TextRange::new(
            pattern.start(),
            pattern
                .patterns // Note: I use `.patterns` as `.values` doesn&#x27;t exist.
                .first()
                .map(Ranged::start)
                .unwrap_or(pattern.end()),
        )];
        if text.starts_with(&#x27;[&#x27;) {
            SequenceType::List
        } else if text.starts_with(&#x27;(&#x27;) {
...
</code></pre>
<p>fails for nested lists. E.g. the following Black consistency test:</p>
<pre><code>   65       │-    case [
         57 │+    case (
   66    58 │         [[5], (6)],
   67    59 │         [7],
   68       │-    ]:
         60 │+    ):
   69    61 │         pass
   70    62 │     case _:
</code></pre>
<p>The rationale behind counting top level commata was they are the defining <a href="https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences">characteristic</a> of a tuple.</p>
<p>Or am I still misunderstanding?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-05-19 06:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs</code>:97 on 2025-05-19 06:00</div>
            <div class="timeline-body"><p>This change is good! It reduces another incompatibility with black. But I do think that we also need to account for a trailing comma like this</p>
<pre><code>Index: crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs b/crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs
--- a/crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs	(revision 660375d429c41878c9a8866c383d5f7ec060c229)
+++ b/crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs	(date 1747634249453)
@@ -79,9 +79,27 @@
 
 impl SequenceType {
     pub(crate) fn from_pattern(pattern: &amp;PatternMatchSequence, source: &amp;str) -&gt; SequenceType {
-        if source[pattern.range()].starts_with(&#x27;[&#x27;) {
+        let before_first_pattern = &amp;source[TextRange::new(
+            pattern.start(),
+            pattern
+                .patterns
+                .first()
+                .map(Ranged::start)
+                .unwrap_or(pattern.end()),
+        )];
+
+        let after_last_pattern = &amp;source[TextRange::new(
+            pattern
+                .patterns
+                .last()
+                .map(Ranged::end)
+                .unwrap_or(pattern.start()),
+            pattern.end(),
+        )];
+
+        if before_first_pattern.starts_with(&#x27;[&#x27;) &amp;&amp; !after_last_pattern.ends_with(&#x27;,&#x27;) {
             SequenceType::List
-        } else if source[pattern.range()].starts_with(&#x27;(&#x27;) {
+        } else if before_first_pattern.starts_with(&#x27;(&#x27;) {
             // If the pattern is empty, it must be a parenthesized tuple with no members. (This
             // branch exists to differentiate between a tuple with and without its own parentheses,
             // but a tuple without its own parentheses must have at least one member.)
</code></pre>
<p>To correctly hanlde</p>
<pre><code>match more := (than, one), indeed,:
    case [[5], (6)],:
        pass
    case _:
        pass
</code></pre>
<p>but we should add a test for this. We should also add tests that this change doesn&#x27;t the formatting of any already formatted code (where Ruff added the extra <code>[</code> <code>]</code> because we otherwise need to gate this change behind preview mode.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/maxmynter">@maxmynter</a> reviewed on 2025-05-21 15:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/maxmynter">@maxmynter</a> on <code>crates/ruff_python_formatter/src/pattern/pattern_match_sequence.rs</code>:97 on 2025-05-21 15:29</div>
            <div class="timeline-body"><p>Allright, i&#x27;ve adapted the code according to your suggestions in <a href="https://github.com/astral-sh/ruff/pull/18147/commits/fdcebbc6bb8b8825a048737417491e9e5a29d0c0">fdcebbc</a></p>
<p>The updates to the Black compatibility are in <a href="https://github.com/astral-sh/ruff/pull/18147/commits/0ac564fe607afe47a72e7e0e31c5e24986326386">0ac564f</a> -- thanks for pointing out that the changes are desired. I was very much in a red things = bad mindset. Took some time to learn about how you do this after. :)</p>
<p>The previously applied formatting is not changed back. So i don&#x27;t think preview gating is necessary. I added a test for it in <a href="https://github.com/astral-sh/ruff/pull/18147/commits/019e5c01c9ba738f0c33b6ec9c6cff14e8db1fbd">019e5c0</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/maxmynter">@maxmynter</a> on 2025-05-21 15:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-22 05:51</div>
            <div class="timeline-body"><p>Nice, thank you</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-22 05:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-22 05:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-22 05:52</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:14:35 UTC
    </footer>
</body>
</html>
