<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Infer target types for unpacked tuple assignment - astral-sh/ruff #13316</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Infer target types for unpacked tuple assignment</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13316">#13316</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2024-09-10 18:45
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body">Summary
<p>This PR adds support for unpacking tuple expression in an assignment statement where the target expression can be a tuple or a list (the allowed sequence targets).</p>
<p>The implementation introduces a new <code>infer_assignment_target</code> which can then be used for other targets like the ones in for loops as well. This delegates it to the <code>infer_definition</code>. The final implementation uses a recursive function that visits the target expression in source order and compares the variable node that corresponds to the definition. At the same time, it keeps track of where it is on the assignment value type.</p>
<p>The logic also accounts for the number of elements on both sides such that it matches even if there&#x27;s a gap in between. For example, if there&#x27;s a starred expression like <code>(a, *b, c) = (1, 2, 3)</code>, then the type of <code>a</code> will be <code>Literal[1]</code> and the type of <code>b</code> will be <code>Literal[2]</code>.</p>
<p>There are a couple of follow-ups that can be done:</p>
<ul>
<li>Use this logic for other target positions like <code>for</code> loop</li>
<li>Add diagnostics for mis-match length between LHS and RHS</li>
</ul>
Test Plan
<p>Add various test cases using the new markdown test framework.
Validate that existing test cases pass.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-09-10 18:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-09-10 18:56</div>
            <div class="timeline-body"><p>There&#x27;s some more work needs to be done, please don&#x27;t look ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-10 22:20</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-09-11 19:01</div>
            <div class="timeline-body"><p>This is completely an incorrect solution, I quickly realize that this will require structural matching between the target expression and the value type. It would also be good to add caching here because we&#x27;ve definitions for each name node on the LHS and so we&#x27;d perform structural matching against the same target and value type for each name node that&#x27;s present on the LHS.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:85 on 2024-10-14 14:33</div>
            <div class="timeline-body"><p>As mentioned, the implementation of <code>infer_starred_expression</code> adds this diagnostic. This should be fixed when implementing assignment to a starred expression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:197 on 2024-10-14 14:39</div>
            <div class="timeline-body"><p>It&#x27;s interesting that mypy doesn&#x27;t support string unpacking (<a href="https://github.com/python/mypy/issues/13823">python/mypy#13823</a>) while Pyright can.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1251 on 2024-10-14 14:43</div>
            <div class="timeline-body"><p>This is basically doing something like combine <code>Literal[1], Literal[2]</code> into <code>int</code> and the assignment to starred expression should add the <code>list</code> to make it <code>list[int]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-14 14:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-14 14:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_workspace/tests/check.rs</code>:78 on 2024-10-14 14:48</div>
            <div class="timeline-body"><p>The reason this is required is because in a code like <code>(a, b) = (1, 2)</code>, the LHS expression is not available.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-14 16:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-14 16:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-14 16:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-14 16:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:65 on 2024-10-14 23:03</div>
            <div class="timeline-body"><p>I think it would be useful to have a TODO in this test that there should be a diagnostic here:</p>
<pre><code># TODO diagnostic
(a, b, c) = (1, 2)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:75 on 2024-10-14 23:08</div>
            <div class="timeline-body"><pre><code># TODO diagnostic
(a, b) = (1, 2, 3)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:85 on 2024-10-14 23:11</div>
            <div class="timeline-body"><p>But there actually should be a diagnostic here! Just not this one. (There should be one about not enough values to unpack. Can we make the TODO a bit clearer about that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:80 on 2024-10-14 23:12</div>
            <div class="timeline-body"><p>In general I prefer to use explanatory paragraphs like this to offer context/explanation for the tested behavior in general, and put TODO comments inline right next to the line that isn&#x27;t quite right yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:141 on 2024-10-14 23:14</div>
            <div class="timeline-body"><p>Fixing this will require creating a new Salsa tracked struct for unpacking assignments to ensure we just do the unpacking once, correct?</p>
<p>I don&#x27;t think I realized in our previous conversations that this would not just be a performance issue, but also a matter of diagnostics correctness. I think this raises the priority on a follow-up PR to create an <code>Unpack</code> tracked struct so we can Salsa-cache the unpacking and do it just once. (There are other unpacking cases we&#x27;ll need to handle -- for loops and comprehensions -- which is why this shouldn&#x27;t have an assignment-specific name.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:197 on 2024-10-14 23:16</div>
            <div class="timeline-body"><p>Yeah, I don&#x27;t like mypy&#x27;s behavior here. This is IMO lint-rule territory, not something a type checker should complain about.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:295 on 2024-10-14 23:39</div>
            <div class="timeline-body"><p>I think <code>into_tuple_type</code> would match the other similar methods better? We have <code>into_class_type</code> etc.</p>
<p>I&#x27;m not sure which is better -- it seems like these methods are cheap and non-consuming, which suggests maybe <code>as_</code> is actually better? But either way I&#x27;d rather be consistent.</p>
<p>cc @MichaReiser @AlexWaygood</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1172 on 2024-10-14 23:50</div>
            <div class="timeline-body"><p>I think names and sequences might be the only kinds of assignment targets that we ever handle as Definitions. Attribute and subscript assignments are fundamentally different; we need to check their validity, and possibly narrow on them as well, but they don&#x27;t define a symbol in this scope. So probably we can just get rid of these TODOs, and more explicitly label this case as &quot;assignment that doesn&#x27;t create a Definition.&quot; We just need to be sure our understanding of which assignments creates Definitions is the same both here and in semantic indexing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:524 on 2024-10-14 23:53</div>
            <div class="timeline-body"><p>I think we can call this <code>Name</code> -- I think those are the only two kinds of assignment targets we&#x27;ll ever create Definitions for.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:573 on 2024-10-14 23:55</div>
            <div class="timeline-body"><p>I think we can be more conservative here; if the target is a name, we can create an <code>AssignmentKind::Name</code>, if it&#x27;s anything else, I think it&#x27;s safe to not create a <code>current_assignment</code> at all; these must be either an attribute target, a subscript target, or malformed syntax, and I think our best option in any of those cases is to not create a Definition.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_workspace/tests/check.rs</code>:78 on 2024-10-15 00:05</div>
            <div class="timeline-body"><p>Since the RHS is a standalone expression whose type should be a cached Salsa query, I think we <em>could</em> query the type of that expression one more time and set a type on the entire LHS expression. But I&#x27;m not sure there&#x27;s any value to doing that; I&#x27;m happy with this change to our coverage goal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1246 on 2024-10-15 00:28</div>
            <div class="timeline-body"><p>This doesn&#x27;t look right to me; the <code>- 2</code> seems hardcoded to the case where <code>starred_index == 1</code>, and all the starred unpacking tests also have <code>starred_index == 1</code>. If I change one of the tests to have the starred element in a different position, inference of the element types from the end doesn&#x27;t seem to work correctly.</p>
<p>If this variable is supposed to be the number of remaining elements in the unpacking target, it seems like that should be something like <code>elts.len() - (starred_index + 1)</code> instead?</p>
<p>And let&#x27;s make sure we add a test for starred unpack where the starred element is not in second position.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1247 on 2024-10-15 00:31</div>
            <div class="timeline-body"><p>I don&#x27;t think the name <code>end_index</code> is very clear here. Seems like it should be the index of the last element to be &quot;gobbled&quot; by the starred element; maybe <code>starred_end_index</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1248 on 2024-10-15 00:39</div>
            <div class="timeline-body"><p>If we calculate <code>remaining</code> correctly above, then I think <code>end_index</code> should be purely a function of <code>tuple_ty.len()</code> and <code>remaining</code>; in fact it seems like it should be <code>tuple_ty.len(builder.db) - remaining - 1</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1251 on 2024-10-15 00:41</div>
            <div class="timeline-body"><p>Somewhere this Todo gets swallowed and turned into Unknown. Not sure why, and it&#x27;s not really a big deal, but if it&#x27;s not hard to preserve it as a Todo that would be nice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1261 on 2024-10-15 00:45</div>
            <div class="timeline-body"><p>This is handling the case where the starred element would be bound to nothing, i.e. match zero elements and turn into an empty list? Maybe add a comment with an example of what it is handling.</p>
<p>I wonder if this case could just be integrated into the above case; we should be able to detect that <code>starred_index..=end_index</code> is an empty range and just handle that as needed (or just handle an empty <code>starred_element_types</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1292 on 2024-10-15 00:51</div>
            <div class="timeline-body"><p>It seems like to assign Unknown correctly here (and in the future to correctly issue diagnostics for mismatched unpacking) we also need to account for starred element, if present?</p>
<p>Alternatively, we could just generalize the tuple RHS case above, so for a string RHS we get a slice of one-character StringLiteral types and otherwise all the logic is identical? That would avoid needing to implement the starred index handling twice.</p>
<p>I don&#x27;t think it&#x27;s necessary that we precisely infer literal string types from unpacking a literal string, only suggesting that in case it is just as easy as handling starred element explicitly here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-10-15 00:51</div>
            <div class="timeline-body"><p>This is great! A few issues, but seems quite close. Make sure for any bugs you fix in updating the PR, you also add a new test that would fail without that fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 05:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:85 on 2024-10-15 05:43</div>
            <div class="timeline-body"><p>Yeah, I can make the TODO clearer here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 05:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_workspace/tests/check.rs</code>:78 on 2024-10-15 05:47</div>
            <div class="timeline-body"><p>Yeah, I agree. As you&#x27;ve mentioned, I&#x27;m also unsure of what the benefit could be of getting the type of the LHS expression which is either a tuple or list.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 05:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:295 on 2024-10-15 05:56</div>
            <div class="timeline-body"><p>I think the reason those method names are using the <code>into_</code> prefix is because they consume <code>self</code> and return the relevant type while this method only returns a reference.</p>
<p>Also, this method isn&#x27;t required now but was in an earlier version. Sorry for the churn, I&#x27;ll remove this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 06:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1246 on 2024-10-15 06:04</div>
            <div class="timeline-body"><p>Yes, thanks for catching that, I totally did not intend that to happen.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 06:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1261 on 2024-10-15 06:16</div>
            <div class="timeline-body"><blockquote>
<p>I wonder if this case could just be integrated into the above case; we should be able to detect that <code>starred_index..=end_index</code> is an empty range and just handle that as needed (or just handle an empty <code>starred_element_types</code>.)</p>
</blockquote>
<p>Yeah, I think this is possible and should make it simpler. Thanks for the suggestion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1251 on 2024-10-15 06:33</div>
            <div class="timeline-body"><p>I got it, it&#x27;s because the <code>inner</code> function does not account for <code>Expr::Starred</code> and only checks for <code>Expr::Name</code>. So, it would return <code>None</code> which then defaults to <code>Unknown</code>.</p>
<p>So, the diff would become</p>
<pre><code>                 ast::Expr::Name(name) if name == variable =&gt; {
                     return Some(value_ty);
                 }
+                ast::Expr::Starred(ast::ExprStarred { value, .. }) =&gt; {
+                    // TODO: Wrap the `value_ty` in a list type.
+                    return inner(builder, value, value_ty, variable);
+                }
                 ast::Expr::List(ast::ExprList { elts, .. })
                 | ast::Expr::Tuple(ast::ExprTuple { elts, .. }) =&gt; match value_ty {
                     Type::Tuple(tuple_ty) =&gt; {
                         let starred_index = elts.iter().position(ast::Expr::is_starred_expr);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 06:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 10:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1172 on 2024-10-15 10:26</div>
            <div class="timeline-body"><p>Yeah, I think that makes sense.</p>
<p>I&#x27;m just trying to understand for &quot;assignment that doesn&#x27;t create a Definition.&quot; do you mean that something like <code>a.b = 1</code> won&#x27;t create a <code>Definition</code> or it won&#x27;t create an <code>AssignmentDefinition</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 10:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:524 on 2024-10-15 10:26</div>
            <div class="timeline-body"><p>Yeah, that&#x27;s correct. This helped me uncover <a href="https://github.com/astral-sh/ruff/issues/13759">astral-sh/ruff#13759</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 11:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:141 on 2024-10-15 11:58</div>
            <div class="timeline-body"><p>Yeah, that&#x27;s correct, we&#x27;d need a way to do unpacking once and cache it for future lookup. I can take this up as a follow-up at a high priority, will need to think about the required changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 12:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1292 on 2024-10-15 12:15</div>
            <div class="timeline-body"><p>Yeah, I need to account for the starred element here as well but I think it might not be as complex as the previous logic if it&#x27;s fine to infer the types as <code>LiteralString</code> instead of the precise <code>StringLiteral</code> with the correct character(s). So,</p>
<pre><code>(a, b, *c) = &quot;a&quot;
reveal_type(a)  # revealed: LiteralString
reveal_type(b)  # revealed: Unknown
reveal_type(c)  # revealed: Unknown

(a, b, *c) = &quot;ab&quot;
reveal_type(a)  # revealed: LiteralString
reveal_type(b)  # revealed: LiteralString
reveal_type(c)  # revealed: list[LiteralString]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-15 12:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:295 on 2024-10-15 12:18</div>
            <div class="timeline-body"><p>Yes, the <code>into_*</code> naming convention is because it consumes <code>self</code> -- but because <code>Type</code> is <code>Copy</code>, consuming <code>self</code> and returning an owned version of the underlying data is actually more ergonomic (and probably no less performant, or at least not significantly so) for these methods than returning a reference to the underlying data</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 12:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1292 on 2024-10-15 12:29</div>
            <div class="timeline-body"><p>Hmm, it might be useful to generalize it. We can convert the <code>StringLiteral</code> type into a <code>TupleType</code> containing <code>n</code> number of either <code>LiteralString</code> or <code>StringLiteral</code> (with the corresponding character) where <code>n</code> is the length of the containing string.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 12:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1292 on 2024-10-15 12:44</div>
            <div class="timeline-body"><p>I&#x27;ve addressed this feedback by splitting the <code>StringLiteral</code> type into a tuple type containing equal amount of <code>LiteralString</code> and delegating it back to the <code>inner</code> function for correct handling of starred expression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-15 12:48</div>
            <div class="timeline-body"><p>@carljm Thanks for the great review, I&#x27;ve addressed all of the feedback except for the duplicate diagnostic issue (<a href="https://github.com/astral-sh/ruff/pull/13316">astral-sh/ruff#13316</a>#discussion_r1800219731) which I&#x27;ll fix as a follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:135 on 2024-10-15 12:51</div>
            <div class="timeline-body"><p>The new test case where the starred expression isn&#x27;t at the same position as other test cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:218 on 2024-10-15 12:52</div>
            <div class="timeline-body"><p>These test cases are similar to that of the <code>Tuple</code> type above and it only differs such that we use strings and the correct revealed type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 12:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-15 13:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1172 on 2024-10-15 13:59</div>
            <div class="timeline-body"><p>I mean that <code>a.b = 1</code> (and <code>a[b] = 1</code>) won&#x27;t create a <code>Definition</code> at all, since it doesn&#x27;t define any name in the local scope. Though ultimately it may create some other kind of struct that we track relative to control-flow, if we want to narrow types based on such assignments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1172 on 2024-10-15 14:04</div>
            <div class="timeline-body"><p>It&#x27;s not important that we do anything about this comment in this PR, the existing TODO is OK, we have more to figure out here regardless.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-15 14:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1201 on 2024-10-15 14:11</div>
            <div class="timeline-body"><p>It looks like the only test exercising this case is the &quot;Non-iterable unpacking&quot; test case. But I think this case is also important if we unpack something that <em>is</em> iterable, but is not a literal tuple or string. Can we add a test for that? We can define our own type that implements <code>__iter__</code> (the iteration tests have examples of that), since the stdlib types will be mostly generic, which we don&#x27;t support yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1306 on 2024-10-15 14:17</div>
            <div class="timeline-body"><p>It occurs to me now that we probably need a case in here for handling an arbitrary unknown-length iterable type, where we just see what the type is from iterating it; similar to the case out in <code>infer_assignment_definition</code> that I commented on above. Because an arbitrary iterable type could occur inside a tuple we are unpacking.</p>
<p>We&#x27;d want to add a test for this, too, something like <code>a, (b, c), d = (1, MyIterableType(), 2)</code>.</p>
<p>And then if we have that case here, maybe we don&#x27;t also need it out in <code>infer_assignment_definition</code>, instead we could just send all Sequence assignments into this function?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1231 on 2024-10-15 14:27</div>
            <div class="timeline-body"><p>I think we need to clarify what we expect <code>value_ty</code> to be in this case; right now I think it&#x27;s inconsistent. If we are called from the full-unpack-with-starred case below, <code>value_ty</code> today will be <code>Todo</code> but in the future will already be a combined list type, so nothing further is needed here, we could just do this:</p>
<pre><code>                    return inner(builder, value, value_ty, variable);
</code></pre>
<p>But the problem is that in the &quot;too few elements to unpack, with starred&quot; case below (line 1271), we are instead always passing in a single element type as <code>value_ty</code> here. I think we should make my suggested change here, and resolve that discrepancy below.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:189 on 2024-10-15 14:33</div>
            <div class="timeline-body"><p>So if we make some changes I suggest below, I think we would end up inferring this as <code>LiteralString</code>, because we should assume <code>*b</code> matches nothing when we have too few items to unpack.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1271 on 2024-10-15 14:34</div>
            <div class="timeline-body"><p>As mentioned above, we&#x27;ll need to be consistent about what <code>value_ty</code> we pass in for a starred element; right now I think it&#x27;s inconsistent between the above case and this case. (Today the inconsistency is <code>Todo</code> above vs &quot;some single element type&quot; here, in the future it will be &quot;list type&quot; above vs &quot;some single element type&quot; here.)</p>
<p>I think this case is the one that is wrong: if we have too few items to unpack, the most sensible &quot;best effort&quot; is to assume starred always matches nothing, and match up the rest of the available items accordingly. That will mean making this case slightly more complex, so we pass in <code>Todo</code> for the starred element (with TODO comment that in future it will be <code>list[Any]</code>) and match up the rest of the available elements, skipping the starred one.</p>
<p>We could delay this change until a future PR that actually adds the Starred support, but I feel the changes I&#x27;m suggesting will make the current behavior clearer and leave things in a less confusing state for the author of that future PR. What do you think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-15 14:35</div>
            <div class="timeline-body"><p>Changes look great! I noticed a few more things in reviewing just now, sorry I didn&#x27;t catch these yesterday!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 16:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1306 on 2024-10-15 16:01</div>
            <div class="timeline-body"><p>Yeah, that makes sense. I&#x27;ve updated the test cases to include this at both top level and nested place. This also removes the need to do it in <code>infer_assignment_definition</code>. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:237 on 2024-10-15 16:05</div>
            <div class="timeline-body"><p>Creating <code>AstNodeRef</code>&#x27;s isn&#x27;t expensive but it also isn&#x27;t free because it requires bumping an <code>Arc</code> (and decrementing it later).</p>
<p>It might be worth to keep storing the assignment only with an index for the right target. I&#x27;m not sure what <code>variable</code> is for.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1243 on 2024-10-15 16:07</div>
            <div class="timeline-body"><pre><code>                                    &amp;tuple_ty.elements(builder.db)[..starred_index],
</code></pre>
<p>Possibly, depending on what <code>elements</code> returns</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-15 16:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 16:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:237 on 2024-10-15 16:17</div>
            <div class="timeline-body"><blockquote>
<p>It might be worth to keep storing the assignment only with an index for the right target. I&#x27;m not sure what <code>variable</code> is for.</p>
</blockquote>
<p>(lol, after writing a couple of sentences I realize which target you&#x27;re referring to.)</p>
<p>Ah, yes, I think that can be done.</p>
<p>The <code>variable</code> is used to find the symbol the definition belongs to in case the LHS is a sequence. It is also used to add the &quot;symbol -&gt; type&quot; mapping in <code>self.types.expressions</code> hashmap.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-15 16:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:237 on 2024-10-15 16:19</div>
            <div class="timeline-body"><p>Using indices is quite tricky because of arbitrary nesting of unpacking; this isn&#x27;t like imports where it&#x27;s a flat list of items. It&#x27;s possible but requires keeping a counter across the entire recursive traversal; I think the current code is a lot clearer.</p>
<p>I was unclear about <code>variable</code> at first also; I think it is needed for the unique per-Definition NodeKey. Perhaps <code>name</code> would be clearer than <code>variable</code> -- I think it is always a <code>Name</code> node.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 16:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/definition.rs</code>:237 on 2024-10-15 16:29</div>
            <div class="timeline-body"><blockquote>
<p>Using indices is quite tricky because of arbitrary nesting of unpacking; this isn&#x27;t like imports where it&#x27;s a flat list of items. It&#x27;s possible but requires keeping a counter across the entire recursive traversal; I think the current code is a lot clearer.</p>
</blockquote>
<p>I <em>think</em> Micha is talking about the <code>targets</code> list in a multi-assignment statement like <code>x = y = 1</code> in which case we could just store the single <code>AstNodeRef&lt;ast::StmtAssign&gt;</code> and a <code>usize</code> index into the <code>targets</code> list. @MichaReiser can confirm though</p>
<blockquote>
<p>I was unclear about <code>variable</code> at first also; I think it is needed for the unique per-Definition NodeKey. Perhaps <code>name</code> would be clearer than <code>variable</code> -- I think it is always a <code>Name</code> node.</p>
</blockquote>
<p>Yes, the <code>name</code> field already existed by the name of <code>target</code>, I mainly renamed it to variable to avoid any clash with the <code>targets</code> field in the node itself. I think <code>name</code> is more clear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 16:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1231 on 2024-10-15 16:32</div>
            <div class="timeline-body"><p>Yeah, I realized that while resolving your previous comment and playing around with some test cases. This makes sense, thanks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unpacking.md</code>:87 on 2024-10-15 16:47</div>
            <div class="timeline-body"><p>nit: would prefer it if we used modern syntax for type hints consistently</p>
<pre><code># TODO: Should be list[int] / list[Literal[2]] once support for assigning to starred expression is added
</code></pre>
<p>(the same applies to a bunch of other comments in this file ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:584 on 2024-10-15 16:52</div>
            <div class="timeline-body"><p>do we now need to set <code>self.current_assignment = None;</code> on completion of each iteration of this loop? It looks like the <code>current_assignment</code> could still be set to the assignment we dealt with in the previous iteration of the loop if the current iteration of the loop doesn&#x27;t create an assignment</p>
<pre><code>                    if let Some(kind) = kind {
                        self.current_assignment = Some(CurrentAssignment::Assign {
                            target,
                            value: &amp;node.value,
                            kind,
                        });
                    }
                    self.visit_expr(target);
                    self.current_assignment = None;
                }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 17:38</div>
            <div class="timeline-body"><p>I think ideally, for something like this:</p>
<pre><code>a, (b,), c, d = &quot;abcd&quot;
</code></pre>
<p>We&#x27;d infer <code>a</code> as being <code>Literal[&quot;a&quot;]</code>, <code>b</code> as <code>Literal[&quot;b&quot;]</code>, <code>c</code> as <code>Literal[&quot;c&quot;]</code> and <code>d</code> as <code>Literal[&quot;d&quot;]</code>. (At the moment they&#x27;re all <code>LiteralString</code>.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-15 17:42</div>
            <div class="timeline-body"><p>Nice -- this is complex stuff to get right!! A couple of small points on top of Micha&#x27;s and Carl&#x27;s comments:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 17:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1271 on 2024-10-15 17:51</div>
            <div class="timeline-body"><p>We discussed this internally and agreed that this is simpler / easier compared to the other alternative where we&#x27;d need to convert the type corresponding to the starred element at two places.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 18:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:584 on 2024-10-15 18:03</div>
            <div class="timeline-body"><p>Ah yes, good catch, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 18:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 18:05</div>
            <div class="timeline-body"><p>Yeah, I think that depends on how precise we want the types. For this case, I think it might make sense to do so.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-10-15 18:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 18:14</div>
            <div class="timeline-body"><p>I can do that as a follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-15 18:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 18:16</div>
            <div class="timeline-body"><p>Sounds good!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-15 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1197 on 2024-10-15 18:29</div>
            <div class="timeline-body"><pre><code>        let target_ty = match kind {
            AssignmentKind::Sequence =&gt; self.infer_sequence_unpacking(target, value_ty, name),
            _ =&gt; value_ty,
        };
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 18:33</div>
            <div class="timeline-body"><p>I agree that we <em>can</em> do this, I&#x27;m not sure we ever <em>need</em> to do it (pyright doesn&#x27;t do it, it will have some cost in complexity and perf), and I&#x27;m pretty sure there&#x27;s no need to do it <em>now</em>. I would suggest we defer it until or unless we see real motivating use cases. Avoiding duplicate diagnostics, supporting unpacking in for loops, and handling starred elements correctly are all much more important follow-ups. (Though handling starred elements correctly is blocked on generic list type, I think.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-15 18:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-15 18:47</div>
            <div class="timeline-body"><p>Given it&#x27;s quite late now for @dhruvmanila , I&#x27;m going to rebase this, apply my one suggested change, and go ahead and merge, to reduce our number of outstanding PRs and thus potential conflicts!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 18:47</div>
            <div class="timeline-body"><p>Fine by me if we don&#x27;t do it, that all makes sense! But in that case I think we should leave a comment saying that it&#x27;s a deliberate choice to infer a less precise type -- it <em>looked</em> like it could have been a mistake to me when I was reading through the diff :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-15 18:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1288 on 2024-10-15 18:55</div>
            <div class="timeline-body"><p>Makes sense, I&#x27;ll add such a comment!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-15 18:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/carljm">@carljm</a> on 2024-10-15 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2024-10-15 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-15 19:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2024-10-16 05:36</div>
            <div class="timeline-body"><p>Thanks @carljm for the reviews and merging!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:06:43 UTC
    </footer>
</body>
</html>
