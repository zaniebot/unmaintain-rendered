```yaml
number: 1111
title: Pycodestyle-whitespace-rules
type: pull_request
state: closed
author: nanthony007
labels: []
assignees: []
base: main
head: pycodestyle-whitespace-rules
created_at: 2022-12-06T20:34:55Z
updated_at: 2023-01-06T15:50:22Z
url: https://github.com/astral-sh/ruff/pull/1111
synced_at: 2026-01-12T05:36:31Z
```

# Pycodestyle-whitespace-rules

---

_Pull request opened by @nanthony007 on 2022-12-06 20:34_

Add support for E2 and maybe E3 pycodestyle rules.

---

_Comment by @nanthony007 on 2022-12-06 20:36_

So currently I've added the two variants to `src/checks.rs` and set the `CheckKind::WhiteSpaceAfter` to take a `char` expecting it to somewhere take the '(', '[', '{' characters. I also added a template for the E201 fixture. 

Now I just am unsure as to how to go about implementing logic for either AST for tokens as per CONTRIBUTING.md suggestions.

---

_Comment by @charliermarsh on 2022-12-06 21:05_

My approach here is to typically try and stay as closely as I can to the existing `pycodestyle` implementation -- you can see that check [here](https://github.com/PyCQA/pycodestyle/blob/6cddabcb0a2f301441731fba23f655563ea0aba9/pycodestyle.py#L424). So, typically, I'd say take that logic, and add it to `check_lines.rs` (the line-based checker, rather than the token- or AST-based checker).

The hiccup is that `pycodestyle` is running that check over "logical" lines rather than "physical" lines. (I'm not sure whether you're familiar with the distinction (I wasn't until recently), but a logical line is Python statement, while a physical line is an actual line-of-code in the editor. We don't have support for generating logical lines in `check_lines.rs` right now.

I could see a few paths forward here:

1. Add support for generating logical lines by porting that logic from `pycodestyle`. (Not totally trivial but maybe a good exercise if you're interested, and useful beyond this specific rule since it would make it much easier to port arbitrary `pycodestyle` rules.)
2. In `check_ast.rs#visit_stmt`, you could do something like this to extract the logical line based on the statement locations (we already know where statements start and end since we created an AST):

```rust
let text = checker.locator.slice_source_code_range(&Range::from_located(stmt));
```

Then, use run regular expressions against the `text` as in `pycodestyle`.


---

_Comment by @charliermarsh on 2022-12-07 19:27_

Another option is that I may be able to add the logical line code, in which case, adding new `pycodestyle` checks would be much easier.

---

_Comment by @nanthony007 on 2022-12-07 21:40_

Sorry for delayed response. I was working on a solution using method 2 you described. I believe I have a working solution but have three problems.

1. How to "activate" the rule. As in in `check_ast.rs` we frequently use the pattern `if self.settings.enabled.contains(&CheckCode::XXX)` but how do I activate this code? If I place the logic outside that block it runs and is successful but not within.
2. The logic I have for `logical_line` inside `#visit_stmt` function results in the message having the correct **row** for the error but defaults to the column 1 always and I am trying to find a way to return a new range while keeping the standard `Range::from_located(stmt)` pattern.
3. Finally the regex pattern they use in `pycodestyle` that you shared (I verified it is the one they still currently use on main as well) uses a backward look-around (`(?!=)`) which Rust-Regex does not support. I removed this and the code seems to function properly but it may be for capturing an edge-case my fixture file does not include.

I can check this code in if you would like to look at it.

I am also not opposed to attempting to implement the logical_line functionality myself. I believe it is found [here](https://github.com/PyCQA/pycodestyle/blob/0fd8b014cecae05ef4491254fa76fc765ec052c4/pycodestyle.py). 

---

_Comment by @charliermarsh on 2022-12-07 21:53_

Ok cool! 

I've made a little bit of progress on the logical line stuff, but I need to benchmark it to know if it's way too slow.

Happy to take a look at what you have thus far, it may end up being better. The main thing I was unsure about with Approach 2 (after writing that comment) is that statements are _nested_, so taking the source code for a single statement isn't actually equivalent to a logical line, unless I'm misunderstanding.

For example, if you have...

```py
def f():
  x = 1
```

And you use the approach I described above, the first string would be the entire function, and the second would be `x = 1`. But maybe there's a way around this...

To answer your questions:

1. If you've added a new check code, you should run `cargo dev generate-check-code-prefix` to update the autogenerated mapping. Then you can run `cargo run foo.py --select E201` or whatever the code is. Does that work?
2. We have some helpers that might be useful for this, `helpers::to_absolute` might do what you want!


---

_Comment by @charliermarsh on 2022-12-07 22:13_

https://github.com/charliermarsh/ruff/pull/1130 implements the logical line building, and it seems to work in testing a variety of cases against pycodestyle. But it's way too slow, like more than doubles Ruff's runtime on the CPython benchmark. All the time is spent building the logical lines.


---

_Comment by @nanthony007 on 2022-12-08 14:41_

Alright I figured I would just push my code and we can go from there. I focused on implementation. I basically pull out the logical line you suggested and then implement the regex search. You can see from returned data (first screenshot) that we are capturing the errors but always with column: 1. The print statements verify we can get the correct column using `stmt.location.column() + found + 1` (second screenshot). 

<img width="642" alt="CleanShot 2022-12-08 at 09 37 12@2x" src="https://user-images.githubusercontent.com/45318637/206474418-67e6b08a-caf6-44ba-9ccf-10438b6d842b.png">


<img width="434" alt="CleanShot 2022-12-08 at 09 36 50@2x" src="https://user-images.githubusercontent.com/45318637/206474361-62fce23f-2423-432e-af48-520682031d00.png">



---

_Comment by @charliermarsh on 2022-12-11 15:15_

I think that to get the right range, we'd want to do something like this:

```rs
self.add_check(Check::new(
    CheckKind::WhiteSpaceAfter(character),
    Range {
        location: Location::new(stmt.location.row(), stmt.location.column() + found),
        end_location: Location::new(stmt.location.row(), stmt.location.column() + found + 1)
    }
));
```

(Not exactly right, doesn't handle newlines and multiple whitespaces, but the idea would be to use `Range { ... }` rather than `Range::from_located(...)`.)


---

_Comment by @charliermarsh on 2022-12-11 15:18_

I think this approach is going to be somewhat limiting though, because it's not the case that each statement corresponds to one logical line.

For example, if we have a nested function:

```py
def f():
  def g():
    pass
```

Then with the current approach, we'd first look at this string:

```py
"""
def f():
  def g():
    pass
"""
```

And then, when we recursed, we'd look at this string:

```py
"""
  def g():
    pass
"""
```

Pycodestyle also has some rules whereby it removes comments and removes string contents (which I assume get in the way of the regular expressions), so we'd need to tokenize and find a way to handle those too.

In short, I think we _do_ need to create logical lines separately, or come up with a whole new strategy for this that's very different from Pycodestyle's strategy (e.g., iterate over the token stream, look for `Lpar` and `Lbrace` tokens, and see if they have whitespace after them).


---

_Comment by @charliermarsh on 2023-01-06 15:50_

Closing for now to keep the PR list up-to-date, can always reopen.

---

_Closed by @charliermarsh on 2023-01-06 15:50_

---
