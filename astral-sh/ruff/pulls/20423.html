<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] More constraint set simplifications via simpler constraint representation - astral-sh/ruff #20423</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] More constraint set simplifications via simpler constraint representation</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/20423">#20423</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-09-15 19:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>Previously, we used a very fine-grained representation for individual constraints: each constraint was <em>either</em> a range constraint, a not-equivalent constraint, or an incomparable constraint. These three pieces are enough to represent all of the &quot;real&quot; constraints we need to create — range constraints and their negation.</p>
<p>However, it meant that we weren't picking up as many chances to simplify constraint sets as we could. Our simplification logic depends on being able to look at <em>pairs</em> of constraints or clauses to see if they simplify relative to each other. With our fine-grained representation, we could easily encounter situations that we should have been able to simplify, but that would require looking at three or more individual constraints.</p>
<p>For instance, negating a range constraint would produce:</p>
<pre><code>¬(Base ≤ T ≤ Super) = ((T ≤ Base) ∧ (T ≠ Base)) ∨ (T ≁ Base) ∨
                      ((Super ≤ T) ∧ (T ≠ Super)) ∨ (T ≁ Super)
</code></pre>
<p>That is, <code>T</code> must be (strictly) less than <code>Base</code>, (strictly) greater than <code>Super</code>, or incomparable to either.</p>
<p>If we tried to union those back together, we should get <code>always</code>, since <code>x ∨ ¬x</code> should always be true, no matter what <code>x</code> is. But instead we would get:</p>
<pre><code>(Base ≤ T ≤ Super) ∨ ((T ≤ Base) ∧ (T ≠ Base)) ∨ (T ≁ Base) ∨ ((Super ≤ T) ∧ (T ≠
 Super)) ∨ (T ≁ Super)
</code></pre>
<p>Nothing would simplify relative to each other, because we'd have to look at all five union elements to see that together they do in fact combine to <code>always</code>.</p>
<p>The fine-grained representation was nice, because it made it easier to <a href="https://dcreager.net/theory/constraints/">work out the math</a> for intersections and unions of each kind of constraint. But being able to simplify is more important, since the example above comes up immediately in #20093 when trying to handle constrained typevars.</p>
<p>The fix in this PR is to go back to a more coarse-grained representation, where each individual constraint consists of a positive range (which might be <code>always</code> / <code>Never ≤ T ≤ object</code>), and zero or more negative ranges. The intuition is to think of a constraint as a region of the type space (representable as a range) with zero or more &quot;holes&quot; removed from it.</p>
<p>With this representation, negating a range constraint produces:</p>
<pre><code>¬(Base ≤ T ≤ Super) = (always ∧ ¬(Base ≤ T ≤ Super))
</code></pre>
<p>(That looks trivial, because it is! We just move the positive range to the negative side.)</p>
<p>The math is not that much harder than before, because there are only three combinations to consider (each for intersection and union) — though the fact that there can be multiple holes in a constraint does require some nested loops. But the mdtest suite gives me confidence that this is not introducing any new issues, and it definitely removes a troublesome TODO.</p>
<p>(As an aside, this change also means that we are back to having each clause contain no more than one individual constraint for any typevar. This turned out to be important, because part of our simplification logic was also depending on that!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @dcreager on 2025-09-15 19:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @dcreager on 2025-09-15 19:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-15 19:06</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-09-15 19:10</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅
No memory usage changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dcreager on 2025-09-15 20:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-09-15 20:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-09-15 20:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dcreager on 2025-09-15 20:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dcreager on 2025-09-15 20:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:828 on 2025-09-15 20:29</div>
            <div class="timeline-body"><p>Does this comment reflect something that still needs to be looked into in this PR, or should it be removed?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:837 on 2025-09-15 20:29</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Returns the union of this individual constraint and another, if it can be simplified to a
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:875 on 2025-09-15 20:31</div>
            <div class="timeline-body"><p>Is it worth (or have you already done) some experimentation on what performs best here? This optimizes for a single negated range -- is that the most common case? Is it better to use a regular <code>Vec</code> and optimize for zero negated ranges?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-09-15 20:36</div>
            <div class="timeline-body"><p>Looks good. Net reduction in LOC and better simplification is a good sign.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:828 on 2025-09-16 13:03</div>
            <div class="timeline-body"><p>Yes thank you! Updated</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/constraints.rs</code>:875 on 2025-09-16 13:04</div>
            <div class="timeline-body"><p>I think that analysis won't be meaningful until #20093 lands (or as part of reviewing it). At the moment in real workloads we're still only creating constraint sets that are equivalent to <code>true</code> or <code>false</code>.</p>
<p>That said, my intuition is that this will be a common case, since there several negations in our various <code>has_relation_to</code> methods, and negating any range constraint would produce a constraint with one negated range in this field.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-09-16 13:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-09-16 14:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-09-16 14:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-09-16 14:05</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:15:48 UTC
    </footer>
</body>
</html>
