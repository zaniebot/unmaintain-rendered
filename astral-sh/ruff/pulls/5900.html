<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement pylint's `empty-comment` rule (`PLR2044`) - astral-sh/ruff #5900</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement pylint&#x27;s <code>empty-comment</code> rule (<code>PLR2044</code>)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/5900">#5900</a>
        opened by <a href="https://github.com/jelly">@jelly</a>
        on 2023-07-19 20:45
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jelly">@jelly</a></div>
            <div class="timeline-body"><p>Implement empty-comment
https://pylint.pycqa.org/en/latest/user_guide/messages/refactor/empty-comment.html</p>
<p>Issue #970</p>
<p>Note, I&#x27;ve written some small programs in Rust but don&#x27;t call myself experienced :)
Last note, the <code>--fix</code> will leave trailing spaces, but I guess that&#x27;s fine as it might be tricky to determine what more to remove? Or should the code be a bit smarter and <code>rtrim()</code> after dropping the trailing <code>#</code>?</p>
Summary
<p>Implement pylint&#x27;s <code>empty-comment</code> rule.</p>
<p>Pylint implementation https://github.com/pylint-dev/pylint/blob/c4281bcff86b66fdf8518e7f57dc3405c8da3a4f/pylint/extensions/empty_comment.py#L43</p>
Test Plan
<p>Manually and by running the unit test from https://github.com/pylint-dev/pylint/blob/c4281bcff86b66fdf8518e7f57dc3405c8da3a4f/tests/functional/ext/empty_comment/empty_comment.py#L4</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-07-19 21:36</div>
            <div class="timeline-body">PR Check Results
Benchmark
Linux
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.07     12.3±0.64ms     3.3 MB/sec    1.00     11.5±0.71ms     3.5 MB/sec
formatter/numpy/ctypeslib.py               1.08      2.4±0.10ms     6.9 MB/sec    1.00      2.2±0.08ms     7.5 MB/sec
formatter/numpy/globals.py                 1.00   267.2±13.48µs    11.0 MB/sec    1.00   266.2±14.09µs    11.1 MB/sec
formatter/pydantic/types.py                1.04      5.2±0.26ms     4.9 MB/sec    1.00      5.0±0.15ms     5.1 MB/sec
linter/all-rules/large/dataset.py          1.04     17.5±0.99ms     2.3 MB/sec    1.00     16.9±0.83ms     2.4 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.10      4.4±0.28ms     3.8 MB/sec    1.00      3.9±0.11ms     4.2 MB/sec
linter/all-rules/numpy/globals.py          1.13   578.8±44.42µs     5.1 MB/sec    1.00   512.2±29.32µs     5.8 MB/sec
linter/all-rules/pydantic/types.py         1.09      7.9±0.47ms     3.2 MB/sec    1.00      7.3±0.25ms     3.5 MB/sec
linter/default-rules/large/dataset.py      1.09      8.8±0.40ms     4.6 MB/sec    1.00      8.1±0.31ms     5.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.05  1867.0±95.64µs     8.9 MB/sec    1.00  1782.5±94.20µs     9.3 MB/sec
linter/default-rules/numpy/globals.py      1.03   218.8±12.50µs    13.5 MB/sec    1.00   213.0±14.95µs    13.9 MB/sec
linter/default-rules/pydantic/types.py     1.05      4.0±0.38ms     6.4 MB/sec    1.00      3.8±0.20ms     6.8 MB/sec
</code></pre>
Windows
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00     11.1±0.24ms     3.7 MB/sec    1.00     11.2±0.16ms     3.6 MB/sec
formatter/numpy/ctypeslib.py               1.00      2.2±0.06ms     7.6 MB/sec    1.00      2.2±0.06ms     7.6 MB/sec
formatter/numpy/globals.py                 1.00    246.4±8.95µs    12.0 MB/sec    1.04   255.5±16.78µs    11.5 MB/sec
formatter/pydantic/types.py                1.00      4.7±0.16ms     5.4 MB/sec    1.03      4.9±0.16ms     5.2 MB/sec
linter/all-rules/large/dataset.py          1.00     15.4±0.20ms     2.6 MB/sec    1.03     15.9±0.41ms     2.6 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.1±0.07ms     4.1 MB/sec    1.01      4.1±0.05ms     4.1 MB/sec
linter/all-rules/numpy/globals.py          1.00    490.3±7.16µs     6.0 MB/sec    1.02   500.2±10.72µs     5.9 MB/sec
linter/all-rules/pydantic/types.py         1.00      7.0±0.17ms     3.6 MB/sec    1.03      7.2±0.16ms     3.5 MB/sec
linter/default-rules/large/dataset.py      1.00      8.1±0.11ms     5.0 MB/sec    1.01      8.2±0.12ms     5.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1676.9±31.40µs     9.9 MB/sec    1.01  1693.3±23.28µs     9.8 MB/sec
linter/default-rules/numpy/globals.py      1.00    189.7±4.81µs    15.6 MB/sec    1.04   196.6±12.24µs    15.0 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.6±0.05ms     7.1 MB/sec    1.01      3.6±0.06ms     7.0 MB/sec
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-07-19 23:02</div>
            <div class="timeline-body"><p>Welcome! Thanks for contributing :)</p>
<blockquote>
<p>This PR is still draft as locally running cargo dev generate-all add the new PLR2044 rule, but also removes RUF014 which does not seem expected.</p>
</blockquote>
<p>This should be resolved by #5832 — sorry about that!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/jelly">@jelly</a> on 2023-07-20 15:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">rule</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-20 16:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-07-20 16:42</div>
            <div class="timeline-body"><p>Haven&#x27;t had a chance to dig in yet but one thing to be mindful of is that this rule is part of a Pylint extension and so isn&#x27;t enabled by default. We typically mark these as &quot;nursery&quot; as a hack to require explicit opt-in.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jelly">@jelly</a> on 2023-07-20 18:14</div>
            <div class="timeline-body"><blockquote>
<p>Haven&#x27;t had a chance to dig in yet but one thing to be mindful of is that this rule is part of a Pylint extension and so isn&#x27;t enabled by default. We typically mark these as &quot;nursery&quot; as a hack to require explicit opt-in.</p>
</blockquote>
<p>Ah that makes sense, I just picked the easiest rule to implement. I&#x27;ve queued it up locally as I suppose  there will be more things to address :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 06:58</div>
            <div class="timeline-body"><p>I&#x27;m not entirely sure if I understand this code correctly but I think this can go wrong for multiline strings</p>
<pre><code>a = &quot;&quot;&quot;A multiline string
that goes contains a # that looks like a comment&quot;&quot;&quot; #
</code></pre>
<p>There&#x27;s no good way for you to detect this by just looking at the source (the same can happen for single quoted strings).</p>
<p>From what I understand you&#x27;re trying to achieve is to see if the comment is all empty. You can do this by using <code>trim_end_matches(|c| is_python_whitespace(c) || c == &#x27;#&#x27;)</code>. This should trim all whitespace and <code>#</code> from the comment text. The comment is empty if the resulting string is <code>&quot;&quot;</code>, and the comment is non empty if there&#x27;s some text remaining.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/snapshots/ruff__rules__pylint__tests__PLR2044_empty_comment_0.py.snap</code>:75 on 2023-07-25 06:59</div>
            <div class="timeline-body"><p>Would you mind adding a. test with a multiline string?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2023-07-25 06:59</div>
            <div class="timeline-body"><p>Thanks for your contribution. I believe there&#x27;s an issue with <code>#</code> in multiline strings that we need to address. See my inline comments for a more in-depth explanation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jelly">@jelly</a> reviewed on 2023-07-25 17:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/jelly">@jelly</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 17:20</div>
            <div class="timeline-body"><p>Right, I am happy to use that implementation. I thought the requirement was to re-implement the existing pylint logic. Happy to change that of course.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jelly">@jelly</a> reviewed on 2023-07-25 17:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/jelly">@jelly</a> on <code>crates/ruff/src/rules/pylint/snapshots/ruff__rules__pylint__tests__PLR2044_empty_comment_0.py.snap</code>:75 on 2023-07-25 17:35</div>
            <div class="timeline-body"><p>Locally, I&#x27;ve added it and it indeed does not get marked as empty comment with pylint or this current PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-07-25 17:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 17:47</div>
            <div class="timeline-body"><p>Let&#x27;s hope my suggestion is correct :sweat_smile:</p>
<p>Our goal is to implement rules with the same semantic but we&#x27;re free to diverge on how we implement the rule to get better performance or higher correctness.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jelly">@jelly</a> reviewed on 2023-07-25 18:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/jelly">@jelly</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 18:12</div>
            <div class="timeline-body"><p>So, I&#x27;m trying out your suggestion but this logic will also trim <code>########</code> as an empty comment and <code>a = x # fooo #</code> also as an empty comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-07-25 18:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 18:21</div>
            <div class="timeline-body"><p>The fist example makes sense to me. Should it only consider comments as empty if the # are separated by a space?</p>
<p>The second example is surprising to me. Can you share your code?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jelly">@jelly</a> reviewed on 2023-07-25 18:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/jelly">@jelly</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 18:29</div>
            <div class="timeline-body"><p>The second example is in the test, oh woops:</p>
<pre><code>print(b)  #
print(b)  # this is fine#
b = &quot;#this#is#fine#&quot;  # 
</code></pre>
<p>My assumption is that you compare the trimmed line with the normal line, if anything was removed it has an empty comment? But maybe that&#x27;s wrong :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-07-25 18:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 18:45</div>
            <div class="timeline-body"><p>I think that&#x27;s too aggressive because it also is true if only part of a comment was removed. Can you try testing if the trimmed comment is empty (it won&#x27;t sole the first problem)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/jelly">@jelly</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-25 19:06</div>
            <div class="timeline-body"><p>So, that would mean only useless comments on an a line would be stripped? And not <code>print(1) #</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jelly">@jelly</a> reviewed on 2023-07-25 19:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-07-26 06:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pylint/rules/empty_comment.rs</code>:58 on 2023-07-26 06:24</div>
            <div class="timeline-body"><p>What I understand is that the rule should flag the following comments:</p>
<pre><code># 
end_of_line #
end_of_line_nested # # # 
</code></pre>
<p>But it should not flag</p>
<pre><code>#########
&quot;&quot;&quot;abcd
efg # hij&quot; 
efg # hij #&quot; 
</code></pre>
<p>How about</p>
<pre><code>end_of_line ######
</code></pre>
<p>Assuming this is correct. The way I would approach the rule is by only looking at the comment text and ignoring the line entirely to detect empty comments (fixing requires detecting if it is an own-line or end of line comment)</p>
<pre><code>let comment_text = locator.slice(comment_range);

if comment_text.trim_start_matches(|c| c == &quot;#&quot; || is_python_whitespace(c)).is_empty() {
	// create diagnostic
}
</code></pre>
<p>The condition is true if the comment only consists of whitespace or <code>#</code> (there are no remaining other characters). This incorrectly flags <code>######</code>.</p>
<pre><code>let comment_text = locator.slice(comment_range);
let mut rest = comment_text;

loop {
	rest = comment_text.trim_start_matches(is_python_whitespace).trim_start_matches(&#x27;#&#x27;);	

	if rest.is_empty() {
		// Comment consist only of `#...whitespace` sequences. 
		break;
	}

	// `##` or `# a`
	if !rest.starts_with(is_python_whitespace) {
		return;
	}
}

// create diagnostic
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-30 22:23</div>
            <div class="timeline-body"><p>Closing this as stale. Feel free to re-open if you are interested in working on it again!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/zanieb">@zanieb</a> on 2023-11-30 22:23</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:55:29 UTC
    </footer>
</body>
</html>
