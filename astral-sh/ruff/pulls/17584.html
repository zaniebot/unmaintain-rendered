<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allow EXE001 &amp; EXE002 on WSL, fix issues with other cases of mounting non-unix filesystems - astral-sh/ruff #17584</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Allow EXE001 &amp; EXE002 on WSL, fix issues with other cases of mounting non-unix filesystems</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17584">#17584</a>
        opened by <a href="https://github.com/MusicalNinjaDad">@MusicalNinjaDad</a>
        on 2025-04-23 15:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/MusicalNinjaDad">@MusicalNinjaDad</a> on 2025-04-23 15:29</div>
            <div class="timeline-body"><p>Handle non-unix filesystems in a way which satisfies not only WSL (#3110, #5445, fixes #10084) but also non-WSL (#12941) cases.</p>
<h2>tl;dr</h2>
<p>Seems to be a touch faster than current implementation on <em>normal</em> systems; simple to document &amp; use; also supports cases like #12941 / external FAT-drives / ...</p>
<p><strong>The key changes are in: <a href="https://github.com/MusicalNinjaDad/forks-ruff/blob/wsl_shebang/crates/ruff_linter/src/rules/flake8_executable/helpers.rs"><code>crates/ruff_linter/src/rules/flake8_executable/helpers.rs</code></a></strong></p>
<pre><code class="language-rust">// Some file systems do not support executable bits. Instead, everything is executable.
// See #3110, #5445, #10084, #12941
//
// Benchmarking shows better performance vs previous approach of checking `is_wsl()` 
// as long as we use a `OnceLock` and a simple test first (filemode of pyproject.toml).
#[cfg(target_family = &quot;unix&quot;)]
static EXECUTABLE_BY_DEFAULT: OnceLock&lt;bool&gt; = OnceLock::new();

#[cfg(target_family = &quot;unix&quot;)]
pub(super) fn executable_by_default(settings: &amp;LinterSettings) -&gt; bool {
    *EXECUTABLE_BY_DEFAULT.get_or_init(|| {
        is_executable(&amp;settings.project_root.join(&quot;pyproject.toml&quot;)).unwrap_or(true)
            // if pyproject.toml is executable or doesn't exist, run a slower check too:
            &amp;&amp; NamedTempFile::new_in(&amp;settings.project_root)
                .map_err(std::convert::Into::into)
                .and_then(|tmpfile| is_executable(tmpfile.path()))
                .unwrap_or(false) // Assume a normal filesystem in case of read-only, IOError, ...
    })
}
</code></pre>
<h2>Open Questions</h2>
<ul>
<li>[ ] Stick with this approach? (I'd suggest: yes)<ul>
<li>Do you have any info on how often users will have no pyproject.toml available?</li>
</ul>
</li>
<li>[ ] Keep test workflow? (I'd suggest: yes, given the very targetted trigger, as long as pinning the SHAs won't lead to dependabot running it too often)</li>
<li>[ ] Keep benches? (I'd suggest: keeping them disabled - is there a better way than just commenting out the section in <code>Cargo.toml</code>, it doesn't seem worth a cfg option?)</li>
</ul>
<h2>Approach &amp; Alternatives considered</h2>
<h3>Recommended Approach: Check filemode of <code>pyproject.toml</code>, fallback to a <code>NamedTempFile</code></h3>
<ul>
<li>Using a <code>OnceLock</code> to ensure we only run this check once</li>
<li>If <code>project_root/pyproject.toml</code> exists: check the filemode. If it's not executable - then files aren't executable by default</li>
<li>If it is, or doesn't exist: create a <code>NamedTempFile</code> in <code>project_root</code> and check the filemode</li>
</ul>
<h4>Pros</h4>
<ul>
<li>Single approach for all cases</li>
<li>Guaranteed to catch all cases</li>
<li>Faster than current implementation (if pyproject.toml exists)</li>
</ul>
<h4>Cons</h4>
<ul>
<li>(Probably) has a very small performance cost (consistently at the edge of what I could measure) for EXE002 in the specific case when<ul>
<li>no pyproject.toml is available in the project_root, or this has been accidentally set to executable (assuming this is a rare case?)</li>
<li>file is not executable &amp; has no shebang (usual case)</li>
<li>not WSL (usual case)</li>
<li>project is small or user is linting a single file</li>
</ul>
</li>
</ul>
<h3>Alternative 1: Manual Override</h3>
<p>See <a href="https://github.com/MusicalNinjaDad/forks-ruff/blob/617cf6d39abe9b1954c2f291bb23aeacb22d8c9e/crates/ruff_linter/src/rules/flake8_executable/mod.rs">617cf6d39abe9b1954c2f291bb23aeacb22d8c9e</a></p>
<ul>
<li>Provide a environment-variable override</li>
<li>Otherwise only test default filemode on WSL</li>
</ul>
<h4>Pros</h4>
<ul>
<li>No risk of checking a tempfile unless using WSL</li>
<li>Allows for cases like #12941</li>
<li>Follows precedent of <code>RUFF_CACHE_DIR</code></li>
</ul>
<h4>Cons</h4>
<ul>
<li>Requires users to find the relevant documentation and set a specific variable</li>
<li>Either invoves testing an env-var during the check (feels wrong);</li>
<li>or threading the value through clap (such as RUFF_CACHE_DIR) which forces the inclusion of a <a href="https://docs.astral.sh/ruff/settings/#cache-dir">project-level config setting</a> and spreads the change over a much wider footprint in the codebase</li>
<li>Very difficult to document well</li>
</ul>
<h3>Alternative 2: Check filesystem type</h3>
<p>I've not tried this one, but could envision:</p>
<ul>
<li>Use <code>std::os::linux::fs::MetadataExt</code> to identify the actual location of <code>project_root</code></li>
<li>Use <code>sysinfo[linux-netdevs]::Disks</code> to identify the corresponding filesystem</li>
<li>Check against a list of known-incompatible filesystem types</li>
</ul>
<h4>Pros</h4>
<ul>
<li>No risk of checking a tempfile</li>
<li>Allows for cases like #12941</li>
</ul>
<h4>Cons</h4>
<ul>
<li>Requires us to identify and maintain a list of incompatible filesystems (9s, FAT, xFAT, NTFS, CIFS, ...?) and will still miss some edge cases (mounting a share from a windows server via NFS)</li>
<li>Will require special-case handling for symlinks</li>
</ul>
<h2>Performance</h2>
<p>I've added specific benchmarks for these lints, as they are disabled in the normal benches. Benching them is consistently inconsistent (!) - always giving fluctations of +/-2.x% on one or two of the four benches (different ones each time), when repeating on the same codebase.</p>
<p>However, this change does <em>consistently</em> show:</p>
<ul>
<li>an <em>improvement</em> of &gt;3% on one or two of the benches (except NotExecutableNoShebang)</li>
<li>fluctations on <code>NotExecutableNoShebang</code> <em>within the ranges</em> I've identified on repeated runs of the same bench on main (&lt; +/-3%)</li>
</ul>
<p><strong>comparing <code>931c66ad19dcaab4ef5feb3c26378f1d9946c31b</code> to <code>main</code>:</strong></p>
<pre><code class="language-text">cargo bench -p ruff_benchmark --bench flake8_executable -- --baseline=main
   Compiling ruff_linter v0.11.5 (/workspaces/ruff/crates/ruff_linter)
   Compiling ruff_benchmark v0.0.0 (/workspaces/ruff/crates/ruff_benchmark)
    Finished `bench` profile [optimized] target(s) in 38.30s
     Running benches/flake8_executable.rs (target/release/deps/flake8_executable-06a3575d2cd1f0b1)
linter/flake8-executable/flake8_executable/ExeNoShebang.py
                        time:   [9.0996 µs 9.1445 µs 9.1924 µs]
                        thrpt:  [27.181 MiB/s 27.324 MiB/s 27.459 MiB/s]
                 change:
                        time:   [-5.8123% -4.9335% -4.0262%] (p = 0.00 &lt; 0.05)
                        thrpt:  [+4.1951% +5.1895% +6.1709%]
                        Performance has improved.
Found 110 outliers among 1000 measurements (11.00%)
  43 (4.30%) high mild
  67 (6.70%) high severe
linter/flake8-executable/flake8_executable/ExeWithShebang.py
                        time:   [9.1686 µs 9.2228 µs 9.2824 µs]
                        thrpt:  [29.281 MiB/s 29.470 MiB/s 29.644 MiB/s]
                 change:
                        time:   [-6.2566% -5.2503% -4.2142%] (p = 0.00 &lt; 0.05)
                        thrpt:  [+4.3996% +5.5412% +6.6742%]
                        Performance has improved.
Found 101 outliers among 1000 measurements (10.10%)
  49 (4.90%) high mild
  52 (5.20%) high severe
linter/flake8-executable/flake8_executable/NotExeNoShebang.py
                        time:   [9.0720 µs 9.1410 µs 9.2203 µs]
                        thrpt:  [27.203 MiB/s 27.439 MiB/s 27.647 MiB/s]
                 change:
                        time:   [-3.4066% -2.5059% -1.4969%] (p = 0.00 &lt; 0.05)
                        thrpt:  [+1.5196% +2.5703% +3.5267%]
                        Performance has improved.
Found 125 outliers among 1000 measurements (12.50%)
  49 (4.90%) high mild
  76 (7.60%) high severe
linter/flake8-executable/flake8_executable/NotExeWithShebang.py
                        time:   [9.3081 µs 9.3810 µs 9.4674 µs]
                        thrpt:  [28.809 MiB/s 29.075 MiB/s 29.303 MiB/s]
                 change:
                        time:   [-2.1660% -1.3733% -0.5070%] (p = 0.00 &lt; 0.05)
                        thrpt:  [+0.5096% +1.3925% +2.2139%]
                        Change within noise threshold.
Found 98 outliers among 1000 measurements (9.80%)
  45 (4.50%) high mild
  53 (5.30%) high severe
</code></pre>
<h2>Testing</h2>
<p>To test this while working on it I've added the following test infrastructure:</p>
<ul>
<li>Specific test cases for EXE001 &amp; EXE002 on non-unix filesystems</li>
<li>A <code>cfg</code> option <code>test-environment</code> set via <code>RUFF_TEST_ENVIRONMENT</code>, to avoid including any system identification logic in the tests themselves</li>
<li>(the naming of the tests &amp; config value is not 100% semantically correct but best reflects the most likely use case)</li>
<li>A github workflow which runs the tests for flake8_executable on: native linux, WSL using the windows filesystem, WSL using the native filesystem<ul>
<li>it (only) triggers on changes to <code>**/flake8_executable/**</code> or itself</li>
<li>takes about 5 minutes to run, and an additional 3 minutes on first run.</li>
<li>and caches the WSL installation to save on windows runner time. This cache should rotate away quite quickly given the specific trigger.</li>
</ul>
</li>
</ul>
<p>As an aside - the test workflow nicely shows the performance penalty of using /mnt/c on WSL:</p>
<ul>
<li>building ruff with crates/ &amp; target/ on /mnt/c takes almost 15 minutes vs 90 seconds if target/ is on the native filesystem.</li>
<li>running the 30 EXE* ruff tests takes 10s (!!) if the fixtures are on /mnt/c and 0.6s if they are on the native filesystem. So users linting projects stored on /mnt/c will be taking a 20x performance penalty vs storing their codebase under $HOME.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MusicalNinjaDad">@MusicalNinjaDad</a> on <code>crates/ruff_linter/src/rules/flake8_executable/rules/shebang_missing_executable_file.rs</code>:79 on 2025-04-23 20:33</div>
            <div class="timeline-body"><p>Need to update to correct signature</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MusicalNinjaDad">@MusicalNinjaDad</a> on <code>crates/ruff_linter/src/rules/flake8_executable/helpers.rs</code>:25 on 2025-04-23 20:34</div>
            <div class="timeline-body"><p>2x #cfg family unix</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MusicalNinjaDad">@MusicalNinjaDad</a> reviewed on 2025-04-23 20:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @MusicalNinjaDad on 2025-04-25 11:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-05-12 07:40</div>
            <div class="timeline-body"><p>Thank you. Your test setup is very impressive.</p>
<p>There's a lot happening right now. I'm not sure when I'll get the time to review this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MusicalNinjaDad">@MusicalNinjaDad</a> on 2025-05-12 11:41</div>
            <div class="timeline-body"><p>Thanks - I fully understand and that quick note was really valuable.</p>
<p>I'd also personally much rather have red-knot available than this included in ruff ;)</p>
<p>I'll probably hang back on taking up other topics until I do get feedback on this (unless I get bored or randomly motivated) - so I can include any feedback on style etc from the start.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:51:28 UTC
    </footer>
</body>
</html>
