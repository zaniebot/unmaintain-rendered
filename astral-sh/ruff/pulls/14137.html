<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Improve `Symbol` API for callable types - astral-sh/ruff #14137</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Improve <code>Symbol</code> API for callable types</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14137">#14137</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-11-06 19:34
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a></div>
            <div class="timeline-body">Summary
<ul>
<li>Get rid of <code>Symbol::unwrap_or</code> (unclear semantics, not needed anymore)</li>
<li>Introduce <code>Type::call_dunder</code></li>
<li>Emit new diagnostic for possibly-unbound <code>__iter__</code> methods</li>
<li>Better diagnostics for callables with possibly-unbound / possibly-non-callable <code>__call__</code> methods</li>
</ul>
<p>part of: #14022</p>
<p>closes #14016</p>
Test Plan
<ul>
<li>Updated test for iterables with possibly-unbound <code>__iter__</code> methods.</li>
<li>New tests for callables</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-11-06 19:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-11-06 19:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-11-06 19:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-11-06 19:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-11-06 19:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:65 on 2024-11-06 19:39</div>
            <div class="timeline-body"><p>Discussion: Arguably, this method is not much better in terms of making its semantics clear. But <code>get_return_type_if_definitely_bound_and_callable</code> didn&#x27;t sound very catchy.</p>
<p>And it is extremely useful for simplifying code at the call sites (three, so far). I tried various other ways of rewriting the part in <code>infer_binary_expression_type</code>, and nothing came close to what we have with <code>get_return_type_if_callable</code>. The trick is that we intentionally merge two things in the <code>None</code> answer: (possible) unboundness and non-callability. This is also why this combines both <code>.call(…)</code> and <code>.return_ty</code>.</p>
<p>That said, I&#x27;m very open to other suggestions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-11-06 19:48</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Linter (stable)
<p>✅ ecosystem check detected no linter changes.</p>
Linter (preview)
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:57 on 2024-11-06 21:17</div>
            <div class="timeline-body"><p>I would just call this return_type_if_callable. Getters are rather uncommon in Rust (set methods are more common but also rear)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-11-06 21:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-11-06 21:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:57 on 2024-11-06 21:42</div>
            <div class="timeline-body"><p>I had <code>return_type_if_callable</code> first, but it could be read as: &quot;return the (inner) type if this symbol is callable&quot; — which is not what it does :man_shrugging:. Due to the dual meaning of &quot;return&quot; here. But I&#x27;m happy to select the shorter name.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-11-06 21:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:57 on 2024-11-06 21:44</div>
            <div class="timeline-body"><p>Hmm, I see. How about <code>callable_return_type</code> : The callable&#x27;s return type or possibly just <code>call_return_type</code> to resemble <code>x.call().return_ty</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:57 on 2024-11-06 23:26</div>
            <div class="timeline-body"><p>Alternative suggestion: just name it <code>call</code> :) This is parallel to <code>Type::call</code>, and I think it&#x27;s a reasonable assumption that the return <code>Type</code> of a method named <code>call</code> is the type returned by the call.</p>
<p>I also think we could improve explicitness and consistency here significantly, while not regressing ergonomics much, if this returned a <code>CallOutcome</code> and we added <code>MaybeNotBound</code> as a possible <code>CallOutcome</code>? Then we can continue to consolidate and improve our APIs on <code>CallOutcome</code> (which already includes a method for &quot;get me the return type as Option or None if error&quot;) and consistently return those from all calls. Then call sites which really do want to ignore all reasons for the error can do so with just one more chained method call, but it&#x27;s a bit more explicit what they are doing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:65 on 2024-11-06 23:26</div>
            <div class="timeline-body"><p>See above -- I like this, but my suggestion is to have it return <code>CallOutcome</code>, and keep all our logic for &quot;simplifying&quot; call outcomes consolidated in one place as methods on <code>CallOutcome</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-11-06 23:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-11-07 09:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:57 on 2024-11-07 09:13</div>
            <div class="timeline-body"><blockquote>
<p>I also think we could improve explicitness and consistency here significantly, while not regressing ergonomics much, if this returned a <code>CallOutcome</code> and we added <code>MaybeNotBound</code> as a possible <code>CallOutcome</code>?</p>
</blockquote>
<p>I had tried this before, and did so again now. I think it&#x27;s more explicit, but the disadvantage of this approach is that we now have a few <code>CallOutcome</code> variants that are possible results of <code>Symbol::call</code>, but not of <code>Type::call</code>. Callers which use <code>Type::call</code> will now have to (implicitly or explicitly) ignore the possibility of <code>CallOutcome::Unbound</code> and similar. This is not a major issue right now, though. A related discussion is #13996, because we now squeeze even more cases through <code>return_ty</code> (<em>what does <code>None</code> mean?</em>) and <code>return_ty_result</code> (<em>under which circumstances will I get a return type?</em>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-11-07 09:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:57 on 2024-11-07 09:15</div>
            <div class="timeline-body"><p>On the plus side, this new version helped me to find some previously unhandled cases of possible unboundness. See new tests in <code>call/callable_instance.md</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1213 on 2024-11-07 17:29</div>
            <div class="timeline-body"><p>I think this comment can be removed, since this method is no longer handling this; it&#x27;s part of the semantics of <code>call_dunder</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1971 on 2024-11-07 17:32</div>
            <div class="timeline-body"><p>naming nit: this is really saying the <code>__iter__</code> method is possibly unbound, right? So maybe it should be named <code>PossiblyUnboundIterMethod</code> or <code>PossiblyUnboundDunderIter</code> to parallel the <code>CallOutcome</code> variant?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-11-07 17:32</div>
            <div class="timeline-body"><p>This looks good to me, just a couple minor nits! Thanks for pushing through a few different versions of this :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-07 17:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1311 on 2024-11-07 17:37</div>
            <div class="timeline-body"><p>Should/can we use <code>call_dunder</code> here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-11-07 18:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1311 on 2024-11-07 18:24</div>
            <div class="timeline-body"><p>It&#x27;s slightly awkward since we only use the boundness information inside the nested conditional, but it&#x27;s only slightly more code — while being more consistent.</p>
<p>We can actually also use it below for <code>__get_item__</code> where it improved the code a lot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-11-07 18:40</div>
            <div class="timeline-body"><p>Looks good to me!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-11-07 18:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-11-07 18:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-11-07 18:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:08:10 UTC
    </footer>
</body>
</html>
