<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Add and test when constraint sets are satisfied by their typevars - astral-sh/ruff #21129</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Add and test when constraint sets are satisfied by their typevars</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21129">#21129</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-10-29 18:45
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/dcreager">@dcreager</a> on 2025-10-29 18:45</div>
            <div class="timeline-body"><p>This PR adds a new <code>satisfied_by_all_typevar</code> method, which implements one of the final steps of actually using these dang constraint sets. Constraint sets exist to help us check assignability and subtyping of types in the presence of typevars. We construct a constraint set describing the conditions under which assignability holds between the two types. Then we check whether that constraint set is satisfied for the valid specializations of the relevant typevars (which is this new method).</p>
<p>We also add a new <code>ty_extensions.ConstraintSet</code> method so that we can test this method's behavior in mdtests, before hooking it up to the rest of the specialization inference machinery.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @dcreager on 2025-10-29 18:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @dcreager on 2025-10-29 18:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-29 18:48</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-29 18:49</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected âœ…
No memory usage changes detected âœ…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @dcreager on 2025-10-29 20:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @dcreager on 2025-10-29 20:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @dcreager on 2025-10-29 20:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @dcreager on 2025-10-29 20:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @dcreager on 2025-10-29 20:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-29 21:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:58 on 2025-10-29 21:22</div>
            <div class="timeline-body"><p>I don't think I understand why <code>T &lt;= Super</code> satisfies <code>T &lt;= Base</code>, given that <code>Super</code> isn't a subtype of <code>Base</code>. Or am I reading this the wrong way around? Or is the <code>Never</code> part important?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-29 21:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:62 on 2025-10-29 21:23</div>
            <div class="timeline-body"><p>I don't think I understand the why but I trust you on this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-29 21:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:80 on 2025-10-29 21:25</div>
            <div class="timeline-body"><p>Hmm, same here. Why is <code>Super</code> satisfying the constraint, given that it isn't <code>Base</code> or <code>Unrelated</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-29 21:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:110 on 2025-10-29 21:32</div>
            <div class="timeline-body"><p>Gosh... it took me way too long to notice the difference to the unbounded example on line 40... We don't pass any type var here...</p>
<p>Should we use a different method name for this? It seems very subtle, but maybe it's obvious for someone more familiar with all this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_vendored/ty_extensions/ty_extensions.pyi</code>:78 on 2025-10-29 21:33</div>
            <div class="timeline-body"><p>I'd find it helpful to document the behavior when <code>inferable</code> is empty. Naively, I'd assume it always returns <code>true</code> or <code>false</code> but the actual behavior seems to be different?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-29 21:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-30 18:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:110 on 2025-10-30 18:15</div>
            <div class="timeline-body"><p>I can make it a keyword-only parameter, which I think will call out the difference more clearly</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-30 19:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:58 on 2025-10-30 19:16</div>
            <div class="timeline-body"><p>We discussed this sync â€” the key point is that the implication is in the other direction. (The typevar bounds/constraints need to imply the constraint set being checked.) So here, <code>T</code> must specialize to a subtype of <code>Base</code>. <code>Base</code> is a subtype of <code>Super</code>, so every valid specialization of <code>T</code> is also a subtype of <code>Super</code>. (Technically, this test is in the inferable section, so we only need <em>one</em> valid specialization of <code>T</code> to satisfy the constraint set. In this case, <em>every</em> valid specialization does, so you'll see that this same test also holds down in the non-inferable section.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:62 on 2025-10-30 19:20</div>
            <div class="timeline-body"><p>This is trying to show that <code>Never</code> is sneaky, especially for inferable typevars. Since <code>T</code> is inferable, we only need <em>one</em> specialization to satisfy the constraint set. <code>Never</code> is a valid specialization, since <code>Never â‰¤ Base</code>. And <code>Never â‰¤ Unrelated</code>, so the constraint set is satisfied for the <code>T = Never</code> case. That's enough for an inferable typevar.</p>
<p>The corresponding test in the non-inferable section fails, though, since there we need <em>all</em> valid specializations to satisfy the constraint set. And <code>T = Base</code> is a counter-example where it doesn't.</p>
<p>This tells me that it might help to change the structure of this file? Right now I have inferable/non-inferable as the top-level sections, and different kinds of typevar bounds/constraints as (unlabeled) subsections. Maybe instead I should have &quot;unbounded&quot;, &quot;bound&quot;, and &quot;constrained&quot; as the top-level sections, to more clearly call out how the behavior is different for inferable vs non-inferable?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:80 on 2025-10-30 19:21</div>
            <div class="timeline-body"><p>Same as above. This is in inferable position, so we only need one specialization of <code>T</code> to satisfy the constraint set. <code>T = Base</code> does, so the check passes. Down below in the non-inferable section, the check fails, because <code>T = Unrelated</code> is a valid specialization that doesn't satisfy the constraint set.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-30 19:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-30 20:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:62 on 2025-10-30 20:48</div>
            <div class="timeline-body"><blockquote>
<p>This tells me that it might help to change the structure of this file?</p>
</blockquote>
<p>I did this, and added more explanatory comments for each example. Hopefully that helps clarify the logic a bit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @AlexWaygood removed by @AlexWaygood on 2025-10-30 20:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-30 20:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_vendored/ty_extensions/ty_extensions.pyi</code>:78 on 2025-10-30 20:49</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-30 21:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:20 on 2025-10-30 21:49</div>
            <div class="timeline-body"><p>This is great. Thanks for adding it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:64 on 2025-10-30 21:53</div>
            <div class="timeline-body"><p>I've a slight preference towards making <code>inferable</code> optional over this somewhat magical <code>()</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:175 on 2025-10-30 23:14</div>
            <div class="timeline-body"><p>I'm still somewhat confused by the DSL here but I (maybe?) finally figured out how to read this?</p>
<p>Is my understanding correct that this results in:</p>
<pre><code>Never &lt;= any(Base, Unrelated) &lt;= Super
</code></pre>
<p>which is true because <code>Base</code> satisfies this constraint.</p>
<p>And the next example is:</p>
<pre><code>Never &lt; forall(Base, Unrelated) &lt; Super
</code></pre>
<p>which is false, because <code>Unrelated</code> doesn't satisfy this constraint.</p>
<p>The part I'm struggling with right now is what a real-world example of <code>static_assert(ConstraintSet.range(Never, T, Super).satisfied_by_all_typevars(inferable=tuple[T]))</code> would look like?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-10-30 23:18</div>
            <div class="timeline-body"><p>Thanks again for taking the time to explain this to me during our phone call. The reasoning in the mdtests make sense to me. Altough I'm still finding the DSL slightly confusing. But maybe that just is because I fail to map it to an example using Python</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:175 on 2025-10-31 14:02</div>
            <div class="timeline-body"><blockquote>
<p>I'm still somewhat confused by the DSL here but I (maybe?) finally figured out how to read this?</p>
</blockquote>
<p>I would formalize it differently, but I think your notation leads to the right understanding:</p>
<blockquote>
<p>Is my understanding correct that this results in:</p>
<pre><code>Never &lt;= any(Base, Unrelated) &lt;= Super
</code></pre>
<p>which is true because <code>Base</code> satisfies this constraint.</p>
</blockquote>
<p>Yes</p>
<blockquote>
<p>And the next example is:</p>
<pre><code>Never &lt; forall(Base, Unrelated) &lt; Super
</code></pre>
<p>which is false, because <code>Unrelated</code> doesn't satisfy this constraint.</p>
</blockquote>
<p>This should use <code>&lt;=</code> instead of <code>&lt;</code> like the first example, but otherwise yes.</p>
<blockquote>
<p>The part I'm struggling with right now is what a real-world example of <code>static_assert(ConstraintSet.range(Never, T, Super).satisfied_by_all_typevars(inferable=tuple[T]))</code> would look like?</p>
</blockquote>
<p>I'm actually not sure what Python I could write that would result in this check either! We need something that wants to check that an instance of <code>T</code> is assignable to <code>Super</code>. The non-inferable case is easy:</p>
<pre><code class="language-py">def f[T: (Base, Unrelated)](t: T):
    x: Super = t
</code></pre>
<p>But in the <code>T</code> inferable case, we would be invoking this function. And I'm not sure what Python code would lead to a <code>T â‰¤ Super</code> check.</p>
<p>The problem is that I can't limit myself to implementing these algorithms for constraint set checks that have obvious Python analogues. ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:64 on 2025-10-31 14:04</div>
            <div class="timeline-body"><p>Done</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-31 14:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-31 14:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/resources/mdtest/type_properties/satisfied_by_all_typevars.md</code>:175 on 2025-10-31 14:51</div>
            <div class="timeline-body"><blockquote>
<p>But in the <code>T</code> inferable case, we would be invoking this function. And I'm not sure what Python code would lead to a <code>T â‰¤ Super</code> check.</p>
</blockquote>
<p>Ah maybe via the return type:</p>
<pre><code class="language-py">def f[T: (Base, Unrelated)]() -&gt; T:
    raise NotImplementedError

x: Super = f()
</code></pre>
<p>(Disregard the fact that there is no real function body that we could write that would satisfy that signature!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @dcreager on 2025-10-31 14:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-10-31 14:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-10-31 14:53</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 17:00:13 UTC
    </footer>
</body>
</html>
