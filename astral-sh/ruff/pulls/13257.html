<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Add a new type representing the set of objects available on a certain Python version - astral-sh/ruff #13257</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Add a new type representing the set of objects available on a certain Python version</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13257">#13257</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-09-05 18:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-05 18:15</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Python types can and should be thought of in terms of set theory. The <code>int</code> type represents the set of all objects for which the <code>__class__</code> attribute of that object is a subclass of <code>int</code>. The <code>int | str</code> type represents the union of two sets: the first being the set of all objects for which the <code>__class__</code> attribute of that object is a subclass of <code>int</code>, the second being the set of all objects for which the <code>__class__</code> attribute of that object is a subclass of <code>str</code>.</p>
<p>We intend to implement support for <code>sys.version_info</code> branches using types; this will allow us to implement support for multiversion checking in the future. Some examples of how we intend this to work are:</p>
<pre><code class="language-py"># The code is being checked with `--target-version=3.13,3.12`,
# indicating that we want it to be checked for correctness on Python 3.13 and Python 3.12 simultaneously

import sys

x = 42

if sys.version_info &gt;= (3, 13):
    x = 42
    reveal_type(x) # Literal[42] &amp; ExistsOnVersion[3.13]

reveal_type(x) # Literal[42] | (Literal[42] &amp; ExistsOnVersion[3.13]) (simplifies to Literal[42])

if sys.version_info &gt;= (3, 13):
    y = 42
    reveal_type(y) # Literal[42] &amp; ExistsOnVersion[3.13]
else:
    y = 56
    reveal_type(y) # Literal[56] &amp; ExistsOnVersion[3.12, 3.11, 3.10, 3.9, 3.8]

reveal_type(y) # (Literal[42] &amp; ExistsOnVersion[3.13) | (Literal[56] &amp; ExistsOnVersion[3.12])
</code></pre>
<p>This PR adds the <code>ExistsOnVersion</code> type and implements display for it. It is not yet inferred anywhere.</p>
<h2>Test Plan</h2>
<p><code>cargo test -p red_knot_python_semantic</code></p>
<p>Co-authored-by: Carl Meyer <a href="mailto:carl@astral.sh">carl@astral.sh</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-09-05 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-09-05 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-09-05 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-05 18:29</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-09-05 19:40</div>
            <div class="timeline-body"><p>Looks good to me, but that's not too surprising since we paired to write it ðŸ˜† feel free to wait for an independent reviewer if you want.</p>
<p>I did realize re-reading the design bits we wrote up that the concept of a constraint applied to a definition, at the time of definition, based on a prior check, will be new for our use-def map and require some additional work there to support. (Currently constraints apply to definitions if they appear between the definition and the use, not before the definition.) But it shouldn't be too hard to add this support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:164 on 2024-09-06 06:13</div>
            <div class="timeline-body"><p>What's the motivation for using an enum with a fixed set of versions rather than a more generic representation of <code>major.minor</code>? Do we need to support narrowing by patch version?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:232 on 2024-09-06 06:15</div>
            <div class="timeline-body"><p>I'm inclined to instead implement the type as a specialized intersection type. Meaning, the type signature is <code>{ inner: Type, version: Version }</code>. It could help with performance because the <code>IntersectionType</code> is somewhat expensive because it needs to allocate a <code>HashSet</code>. A specialized type could avoid that allocation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-06 06:23</div>
            <div class="timeline-body"><p>I love that you jumped right onto this and I kind of feel bad to now be the person pushing back, considering that I motivated this to large degrees.</p>
<p>I think it would be good to spend some time writing a design document for this demonstrating how this new typing feature would be used, considering that we walk new terain. I'm also interested to better understand how this feature works with our current <code>target_version</code> which is always a single version. Would that need to become a version range? What changes are required to the module resolver? How do we get this version (requires-python is always a minimal version constraint. Is there a way to configure that a user wants exactly one version?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:164 on 2024-09-06 22:26</div>
            <div class="timeline-body"><p>We need a fixed set of supported versions because otherwise the implementation becomes <em>much</em> more complex; we can no longer just use intersections and unions, we have to implement a whole dedicated system for resolving sets of inequality constraints, like uv has, just for this one case. With a fixed set of supported versions, if we see <code>if sys.version_info &gt;= (3, 11)</code> we can easily resolve that to <code>ExistsOnVersion(3.11) | ExistsOnVersion(3.12) | ExistsOnVersion(3.13)</code>. Without it, we have to represent <code>sys.version_info &gt;= (3, 11)</code> as an inequality, and implement constraint solving for arbitrary sets of inequality constraints.</p>
<p>It's <em>possible</em>, but it's a lot of extra work to take on unless we really need to. And I don't see why we'd need to; there will always be a finite and known set of Python versions supported by red-knot.</p>
<p>I don't think we need to support narrowing by patch version. Patch versions are not supposed to change features in ways that would require differing typing. Typeshed never narrows on patch versions, and neither pyright nor mypy support it. (Mypy doesn't even understand <code>sys.version_info</code> checks if they check the patch version; pyright still understands them, but treats them as if the patch version wasn't there at all.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-06 22:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-06 22:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:232 on 2024-09-06 22:32</div>
            <div class="timeline-body"><p>Hmm, I kind of like this idea. I'm not totally convinced by the performance motivation: we will have <em>lots</em> of intersections due to narrowing constraints in general, and we will need to make our intersection implementation perform as well as we possibly can; I suspect that version/platform narrowing will end up as a small overall percentage of our intersection types.</p>
<p>But I think it might simplify the implementation to do this, because these types <em>are</em> special: they shouldn't ever exist outside of an intersection, and whenever we encounter them (and haven't already narrowed them away), we should treat them as if they were just the inner type. I think this will be a bit simpler than treating them as <code>object</code> and relying on intersection simplification to simplify <code>foo &amp; object</code> to <code>foo</code>.</p>
<p>Note that we will have <code>Foo &amp; (PythonVersion[3.11] | PythonVersion[3.12])</code>, which can't directly be represented this way, but it can distribute to <code>(Foo &amp; PythonVersion[3.11]) | (Foo &amp; PythonVersion[3.12])</code> (which we would do anyway, since we normalize to disjunctive normal form), so that should work fine with this representation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-06 22:42</div>
            <div class="timeline-body"><blockquote>
<p>I love that you jumped right onto this</p>
</blockquote>
<p>Alex and I have a weekly pair-programming session on Thursdays, where we tend to jump into a random new fun thing that sounds interesting to both of us ðŸ˜† That's how we ended up getting unplanned builtins support, too.</p>
<blockquote>
<p>I'm also interested to better understand how this feature works with our current <code>target_version</code> which is always a single version. Would that need to become a version range?</p>
</blockquote>
<p>This will work fine with a single target Python version, or with an arbitrary set of target Python versions. All it means is that any non-target Python version immediately resolves away to <code>Never</code>, but it doesn't matter if the non-target-version set is &quot;all but one version&quot; or &quot;all but X versions&quot;. So implementing support for <code>sys.version</code> checks in this way doesn't require us to immediately start doing multi-version checking, it just leaves the door open that it will be possible in the future.</p>
<blockquote>
<p>How do we get this version (requires-python is always a minimal version constraint. Is there a way to configure that a user wants exactly one version?)</p>
</blockquote>
<p>If we don't do multi-version-checking, then we kind of need to give the user a red-knot-specific config to specify exactly one version to check. (Though we could default to checking the minimum <code>requires-python</code> version.)</p>
<p>If we do multi-version-checking, then it's kind of cool that our default can be <code>requires-python</code> and newer, but I think we still need more granular red-knot-specific config. (What if red-knot supports the latest and greatest Python but my library hasn't added support for it yet; I should still be able to upgrade red-knot and keep using it.)</p>
<blockquote>
<p>I think it would be good to spend some time writing a design document for this</p>
</blockquote>
<p>I'm not opposed to this, but I also don't think we have to answer all questions about multi-version checking as a blocker to implementing support for <code>sys.version_info</code> checks in a way that makes it possible to do multi-version checking in the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-26 18:28</div>
            <div class="timeline-body"><p>After further discussion internally, we decided that our initial implementation of a type checker will <em>not</em> support multiversion checking.</p>
<p>This doesn't mean that it's a feature we don't want! It's still something we'd love to do, if at all feasible. <em>However</em>, it would also come with a lot of complexities. After re-evaluating, we think other things have priority for now, and we think it should be possible to add support for multi-version checking at a later stage rather than doing it now.</p>
<p>TL;DR: closing this PR for now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-10-26 18:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-26 18:28</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:00:06 UTC
    </footer>
</body>
</html>
