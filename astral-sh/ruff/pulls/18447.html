<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove `Message::to_rule` - astral-sh/ruff #18447</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Remove <code>Message::to_rule</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18447">#18447</a>
        opened by <a href="https://github.com/ntBre">@ntBre</a>
        on 2025-06-03 18:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-03 18:55</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>As the title says, this PR removes the <code>Message::to_rule</code> method by replacing related uses of <code>Rule</code> with <code>NoqaCode</code> (or the rule's name in the case of the cache). Where it seemed a <code>Rule</code> was really needed, we convert back to the <code>Rule</code> by parsing either the rule name (with <code>str::parse</code>) or the <code>NoqaCode</code> (with <code>Rule::from_code</code>).</p>
<p>I thought this was kind of like cheating and that it might not resolve this part of Micha's <a href="https://github.com/astral-sh/ruff/pull/18391#issuecomment-2933764275">comment</a>:</p>
<blockquote>
<p>because we can't add Rule to Diagnostic or <strong>have it anywhere in our shared rendering logic</strong></p>
</blockquote>
<p>but after looking again, the only remaining <code>Rule</code> conversion in rendering code is for the SARIF output format. The other two non-test <code>Rule</code> conversions are for caching and writing a fix summary, which I don't think fall into the shared rendering logic. That leaves the SARIF format as the only real problem, but maybe we can delay that for now.</p>
<p>The motivation here is that we won't be able to store a <code>Rule</code> on the new <code>Diagnostic</code> type, but we should be able to store a <code>NoqaCode</code>, likely as a string.</p>
<h2>Test Plan</h2>
<p>Existing tests</p>
<h2><a href="https://codspeed.io/astral-sh/ruff/branches/brent%2Fremove-to-rule">Benchmarks</a></h2>
<p>Almost no perf regression, only -1% on <code>linter/default-rules[large/dataset.py]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @ntBre on 2025-06-03 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">diagnostics</span> added by @ntBre on 2025-06-03 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-06-03 19:01</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-06-03 19:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @ntBre on 2025-06-03 19:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @ntBre on 2025-06-03 19:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @ntBre on 2025-06-03 19:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/cache.rs</code>:443 on 2025-06-04 06:29</div>
            <div class="timeline-body"><p>Unrelated to your PR: Does that mean we drop syntax errors from the cache?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/cache.rs</code>:360 on 2025-06-04 06:31</div>
            <div class="timeline-body"><p>Could we move this call to the serialization and keep storing a <code>Rule</code> in the cache?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/printer.rs</code>:507 on 2025-06-04 06:39</div>
            <div class="timeline-body"><p>Does <code>rule.to_string</code> return the rule name? I'm inclined to change <code>FixTable</code> to a map from <code>noqa</code> to <code>(name, usize)</code>. This removes the need to lookup the rule.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/fix/mod.rs</code>:134 on 2025-06-04 06:46</div>
            <div class="timeline-body"><p>Hmm. This hurts readability quiet a bit but I understnad why it's necessary. Calling <code>noqa_code</code> isn't cheap.</p>
<p>I think a nice solution here could be to add a <code>has_noqa_code(code: &amp;str)</code> method to <code>Rule</code> (or make calling <code>noqa</code> cheap).</p>
<p>Or wait, could we compare the kebab case names instead? These can be retrieved cheaply</p>
<pre><code>let redefined_while_unused = Rule::RedefinedWhileUnused.as_ref();
</code></pre>
<p>We could even make this more explicit by adding a <code>name</code> method to <code>Rule</code> that returns a <code>LintName</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/message/mod.rs</code>:228 on 2025-06-04 06:51</div>
            <div class="timeline-body"><p>Nit: Rename to <code>noqa_code</code>, now that the conversion is free.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:74 on 2025-06-04 06:56</div>
            <div class="timeline-body"><p>I think I'd prefer if we would preserve the name during the transformation instead of looking up the rule here again:</p>
<pre><code class="language-rust">        let unique_rules: HashSet&lt;_&gt; = results.iter().filter_map(|result| result.code).collect();
</code></pre>
<p>This could be changed to be a hash map that maps from code to name (or HashSet with <code>(NoqaCode, &amp;str)</code> as key).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:69 on 2025-06-04 06:57</div>
            <div class="timeline-body"><p>It's a bit silly that <code>parse_code</code> strips the prefix again, when <code>NoqaCode</code> already has the prefix. If not too hard, would it make sense to add a <code>parse_noqa</code> method that matches on <code>code.prefix()</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/rules/pyflakes/mod.rs</code>:781 on 2025-06-04 06:59</div>
            <div class="timeline-body"><p>Not too important but we could also consider transforming <code>expected</code> and <code>actual</code> and map them to the rule names instead. This avoids the rule lookup</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/noqa.rs</code>:818 on 2025-06-04 07:04</div>
            <div class="timeline-body"><p>Can you double check if we need to use a <code>HashSet</code> for <code>noqa_codes</code> in case there are multiple matches for the same code? Or does it not matter, or does some other code guarantee that there are no duplicates?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_server/src/lint.rs</code>:172 on 2025-06-04 07:06</div>
            <div class="timeline-body"><p>Nit: maybe for another PR, but I'd prefer to use <code>message.is_syntax_error</code> over <code>to_noqa_code</code> to decide if something is a syntax error or not. Ideally, that would also allow us to remove needing both <code>to_lsp_diagnostic</code> and <code>syntax_error_to_lsp_diagnostic</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2025-06-04 07:07</div>
            <div class="timeline-body"><p>Thank you. This is great. I think we can avoid the <code>from_code</code> in a few more places, but this, overall looks good</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-04 07:32</div>
            <div class="timeline-body"><p>Here a patch for adding a <code>rule.name</code> method (it also allows us to remove the <code>AsStrRef</code> derive:</p>
<details>
<summary>Patch</summary>

<pre><code class="language-patch">diff --git a/crates/ruff/src/commands/rule.rs b/crates/ruff/src/commands/rule.rs
index 45b071d2e..adc761b3e 100644
--- a/crates/ruff/src/commands/rule.rs
+++ b/crates/ruff/src/commands/rule.rs
@@ -30,7 +30,7 @@ impl&lt;'a&gt; Explanation&lt;'a&gt; {
         let (linter, _) = Linter::parse_code(&amp;code).unwrap();
         let fix = rule.fixable().to_string();
         Self {
-            name: rule.as_ref(),
+            name: rule.name().as_str(),
             code,
             linter: linter.name(),
             summary: rule.message_formats()[0],
@@ -44,7 +44,7 @@ impl&lt;'a&gt; Explanation&lt;'a&gt; {
 
 fn format_rule_text(rule: Rule) -&gt; String {
     let mut output = String::new();
-    let _ = write!(&amp;mut output, &quot;# {} ({})&quot;, rule.as_ref(), rule.noqa_code());
+    let _ = write!(&amp;mut output, &quot;# {} ({})&quot;, rule.name(), rule.noqa_code());
     output.push('\n');
     output.push('\n');
 
diff --git a/crates/ruff_dev/src/generate_docs.rs b/crates/ruff_dev/src/generate_docs.rs
index d191e8264..5f2309328 100644
--- a/crates/ruff_dev/src/generate_docs.rs
+++ b/crates/ruff_dev/src/generate_docs.rs
@@ -29,7 +29,7 @@ pub(crate) fn main(args: &amp;Args) -&gt; Result&lt;()&gt; {
         if let Some(explanation) = rule.explanation() {
             let mut output = String::new();
 
-            let _ = writeln!(&amp;mut output, &quot;# {} ({})&quot;, rule.as_ref(), rule.noqa_code());
+            let _ = writeln!(&amp;mut output, &quot;# {} ({})&quot;, rule.name(), rule.noqa_code());
 
             let (linter, _) = Linter::parse_code(&amp;rule.noqa_code().to_string()).unwrap();
             if linter.url().is_some() {
@@ -101,7 +101,7 @@ pub(crate) fn main(args: &amp;Args) -&gt; Result&lt;()&gt; {
             let filename = PathBuf::from(ROOT_DIR)
                 .join(&quot;docs&quot;)
                 .join(&quot;rules&quot;)
-                .join(rule.as_ref())
+                .join(&amp;*rule.name())
                 .with_extension(&quot;md&quot;);
 
             if args.dry_run {
diff --git a/crates/ruff_dev/src/generate_rules_table.rs b/crates/ruff_dev/src/generate_rules_table.rs
index 48b1cdc2c..3255f8f42 100644
--- a/crates/ruff_dev/src/generate_rules_table.rs
+++ b/crates/ruff_dev/src/generate_rules_table.rs
@@ -55,7 +55,7 @@ fn generate_table(table_out: &amp;mut String, rules: impl IntoIterator&lt;Item = Rule&gt;,
             FixAvailability::None =&gt; format!(&quot;&lt;span {SYMBOL_STYLE}&gt;&lt;/span&gt;&quot;),
         };
 
-        let rule_name = rule.as_ref();
+        let rule_name = rule.name();
 
         // If the message ends in a bracketed expression (like: &quot;Use {replacement}&quot;), escape the
         // brackets. Otherwise, it'll be interpreted as an HTML attribute via the `attr_list`
diff --git a/crates/ruff_linter/src/codes.rs b/crates/ruff_linter/src/codes.rs
index fafb840a0..c31e989a4 100644
--- a/crates/ruff_linter/src/codes.rs
+++ b/crates/ruff_linter/src/codes.rs
@@ -4,7 +4,7 @@
 /// `--select`. For pylint this is e.g. C0414 and E0118 but also C and E01.
 use std::fmt::Formatter;
 
-use strum_macros::{AsRefStr, EnumIter};
+use strum_macros::EnumIter;
 
 use crate::registry::Linter;
 use crate::rule_selector::is_single_rule_selector;
diff --git a/crates/ruff_linter/src/logging.rs b/crates/ruff_linter/src/logging.rs
index dadf6ce25..b59c63737 100644
--- a/crates/ruff_linter/src/logging.rs
+++ b/crates/ruff_linter/src/logging.rs
@@ -20,7 +20,7 @@ pub static IDENTIFIERS: LazyLock&lt;Mutex&lt;Vec&lt;&amp;'static str&gt;&gt;&gt; = LazyLock::new(Mutex
 /// Warn a user once, with uniqueness determined by the given ID.
 #[macro_export]
 macro_rules! warn_user_once_by_id {
-    ($id:expr, $($arg:tt)*) =&gt; {
+    ($id:expr, $($arg:tt)*) =&gt; {{
         use colored::Colorize;
         use log::warn;
 
@@ -31,7 +31,7 @@ macro_rules! warn_user_once_by_id {
                 states.push($id);
             }
         }
-    };
+    }};
 }
 
 pub static MESSAGES: LazyLock&lt;Mutex&lt;FxHashSet&lt;String&gt;&gt;&gt; = LazyLock::new(Mutex::default);
diff --git a/crates/ruff_linter/src/registry.rs b/crates/ruff_linter/src/registry.rs
index 9b03a8b7f..2f8a92324 100644
--- a/crates/ruff_linter/src/registry.rs
+++ b/crates/ruff_linter/src/registry.rs
@@ -1,6 +1,7 @@
 //! Remnant of the registry of all [`Rule`] implementations, now it's reexporting from codes.rs
 //! with some helper symbols
 
+use ruff_db::diagnostic::LintName;
 use strum_macros::EnumIter;
 
 pub use codes::Rule;
@@ -348,9 +349,18 @@ impl Rule {
 
     /// Return the URL for the rule documentation, if it exists.
     pub fn url(&amp;self) -&gt; Option&lt;String&gt; {
-        self.explanation()
-            .is_some()
-            .then(|| format!(&quot;{}/rules/{}&quot;, env!(&quot;CARGO_PKG_HOMEPAGE&quot;), self.as_ref()))
+        self.explanation().is_some().then(|| {
+            format!(
+                &quot;{}/rules/{name}&quot;,
+                env!(&quot;CARGO_PKG_HOMEPAGE&quot;),
+                name = self.name()
+            )
+        })
+    }
+
+    pub fn name(&amp;self) -&gt; LintName {
+        let name: &amp;'static str = self.into();
+        LintName::of(name)
     }
 }
 
@@ -421,7 +431,7 @@ pub mod clap_completion {
         fn possible_values(&amp;self) -&gt; Option&lt;Box&lt;dyn Iterator&lt;Item = PossibleValue&gt; + '_&gt;&gt; {
             Some(Box::new(Rule::iter().map(|rule| {
                 let name = rule.noqa_code().to_string();
-                let help = rule.as_ref().to_string();
+                let help: &amp;'static str = rule.into();
                 PossibleValue::new(name).help(help)
             })))
         }
@@ -443,7 +453,7 @@ mod tests {
             assert!(
                 rule.explanation().is_some(),
                 &quot;Rule {} is missing documentation&quot;,
-                rule.as_ref()
+                rule.name()
             );
         }
     }
@@ -460,10 +470,10 @@ mod tests {
             .collect();
 
         for rule in Rule::iter() {
-            let rule_name = rule.as_ref();
+            let rule_name = rule.name();
             for pattern in &amp;patterns {
                 assert!(
-                    !pattern.matches(rule_name),
+                    !pattern.matches(&amp;*rule_name),
                     &quot;{rule_name} does not match naming convention, see CONTRIBUTING.md&quot;
                 );
             }
diff --git a/crates/ruff_linter/src/registry/rule_set.rs b/crates/ruff_linter/src/registry/rule_set.rs
index d83ff0771..62601d722 100644
--- a/crates/ruff_linter/src/registry/rule_set.rs
+++ b/crates/ruff_linter/src/registry/rule_set.rs
@@ -302,9 +302,8 @@ impl Display for RuleSet {
         } else {
             writeln!(f, &quot;[&quot;)?;
             for rule in self {
-                let name = rule.as_ref();
                 let code = rule.noqa_code();
-                writeln!(f, &quot;\t{name} ({code}),&quot;)?;
+                writeln!(f, &quot;\t{name} ({code}),&quot;, name = rule.name())?;
             }
             write!(f, &quot;]&quot;)?;
         }
diff --git a/crates/ruff_linter/src/rule_selector.rs b/crates/ruff_linter/src/rule_selector.rs
index 7588aa9f6..74f069b97 100644
--- a/crates/ruff_linter/src/rule_selector.rs
+++ b/crates/ruff_linter/src/rule_selector.rs
@@ -485,8 +485,7 @@ pub mod clap_completion {
                                     prefix.linter().common_prefix(),
                                     prefix.short_code()
                                 );
-                                let name: &amp;'static str = rule.into();
-                                return Some(PossibleValue::new(code).help(name));
+                                return Some(PossibleValue::new(code).help(rule.name().as_str()));
                             }
 
                             None
diff --git a/crates/ruff_linter/src/rules/fastapi/mod.rs b/crates/ruff_linter/src/rules/fastapi/mod.rs
index 90f52b7d6..60f180973 100644
--- a/crates/ruff_linter/src/rules/fastapi/mod.rs
+++ b/crates/ruff_linter/src/rules/fastapi/mod.rs
@@ -3,7 +3,6 @@ pub(crate) mod rules;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -18,7 +17,7 @@ mod tests {
     #[test_case(Rule::FastApiNonAnnotatedDependency, Path::new(&quot;FAST002_1.py&quot;))]
     #[test_case(Rule::FastApiUnusedPathParameter, Path::new(&quot;FAST003.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;fastapi&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
@@ -32,7 +31,7 @@ mod tests {
     #[test_case(Rule::FastApiNonAnnotatedDependency, Path::new(&quot;FAST002_0.py&quot;))]
     #[test_case(Rule::FastApiNonAnnotatedDependency, Path::new(&quot;FAST002_1.py&quot;))]
     fn rules_py38(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}_py38&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}_py38&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;fastapi&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
diff --git a/crates/ruff_linter/src/rules/flake8_fixme/mod.rs b/crates/ruff_linter/src/rules/flake8_fixme/mod.rs
index d2433fc8b..44071d1b7 100644
--- a/crates/ruff_linter/src/rules/flake8_fixme/mod.rs
+++ b/crates/ruff_linter/src/rules/flake8_fixme/mod.rs
@@ -16,7 +16,7 @@ mod tests {
     #[test_case(Rule::LineContainsTodo; &quot;T003&quot;)]
     #[test_case(Rule::LineContainsXxx; &quot;T004&quot;)]
     fn rules(rule_code: Rule) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_T00.py&quot;, rule_code.as_ref());
+        let snapshot = format!(&quot;{}_T00.py&quot;, rule_code.name());
         let diagnostics = test_path(
             Path::new(&quot;flake8_fixme/T00.py&quot;),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_linter/src/rules/flake8_gettext/mod.rs b/crates/ruff_linter/src/rules/flake8_gettext/mod.rs
index 09d440526..cd385932a 100644
--- a/crates/ruff_linter/src/rules/flake8_gettext/mod.rs
+++ b/crates/ruff_linter/src/rules/flake8_gettext/mod.rs
@@ -29,7 +29,7 @@ mod tests {
     #[test_case(Rule::FormatInGetTextFuncCall, Path::new(&quot;INT002.py&quot;))]
     #[test_case(Rule::PrintfInGetTextFuncCall, Path::new(&quot;INT003.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_gettext&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_linter/src/rules/flake8_raise/mod.rs b/crates/ruff_linter/src/rules/flake8_raise/mod.rs
index d2d636b1e..178045453 100644
--- a/crates/ruff_linter/src/rules/flake8_raise/mod.rs
+++ b/crates/ruff_linter/src/rules/flake8_raise/mod.rs
@@ -3,7 +3,6 @@ pub(crate) mod rules;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -15,7 +14,7 @@ mod tests {
 
     #[test_case(Rule::UnnecessaryParenOnRaiseException, Path::new(&quot;RSE102.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_raise&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_linter/src/rules/flake8_self/mod.rs b/crates/ruff_linter/src/rules/flake8_self/mod.rs
index a445b40ba..7a3f83ddd 100644
--- a/crates/ruff_linter/src/rules/flake8_self/mod.rs
+++ b/crates/ruff_linter/src/rules/flake8_self/mod.rs
@@ -4,7 +4,6 @@ pub mod settings;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use crate::registry::Rule;
@@ -18,7 +17,7 @@ mod tests {
     #[test_case(Rule::PrivateMemberAccess, Path::new(&quot;SLF001.py&quot;))]
     #[test_case(Rule::PrivateMemberAccess, Path::new(&quot;SLF001_1.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_self&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_linter/src/rules/flake8_todos/mod.rs b/crates/ruff_linter/src/rules/flake8_todos/mod.rs
index 7a4129a78..486c46af0 100644
--- a/crates/ruff_linter/src/rules/flake8_todos/mod.rs
+++ b/crates/ruff_linter/src/rules/flake8_todos/mod.rs
@@ -2,7 +2,6 @@ pub(crate) mod rules;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -20,7 +19,7 @@ mod tests {
     #[test_case(Rule::InvalidTodoCapitalization, Path::new(&quot;TD006.py&quot;))]
     #[test_case(Rule::MissingSpaceAfterTodoColon, Path::new(&quot;TD007.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_todos&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_linter/src/rules/flake8_type_checking/mod.rs b/crates/ruff_linter/src/rules/flake8_type_checking/mod.rs
index f5b777ec4..acdb788f5 100644
--- a/crates/ruff_linter/src/rules/flake8_type_checking/mod.rs
+++ b/crates/ruff_linter/src/rules/flake8_type_checking/mod.rs
@@ -6,7 +6,6 @@ pub mod settings;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -55,7 +54,7 @@ mod tests {
     #[test_case(Rule::TypingOnlyThirdPartyImport, Path::new(&quot;typing_modules_1.py&quot;))]
     #[test_case(Rule::TypingOnlyThirdPartyImport, Path::new(&quot;typing_modules_2.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
@@ -70,7 +69,7 @@ mod tests {
     #[test_case(Rule::QuotedTypeAlias, Path::new(&quot;TC008.py&quot;))]
     #[test_case(Rule::QuotedTypeAlias, Path::new(&quot;TC008_typing_execution_context.py&quot;))]
     fn type_alias_rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rules(vec![
@@ -84,11 +83,7 @@ mod tests {
 
     #[test_case(Rule::QuotedTypeAlias, Path::new(&quot;TC008_union_syntax_pre_py310.py&quot;))]
     fn type_alias_rules_pre_py310(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(
-            &quot;pre_py310_{}_{}&quot;,
-            rule_code.as_ref(),
-            path.to_string_lossy()
-        );
+        let snapshot = format!(&quot;pre_py310_{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -107,7 +102,7 @@ mod tests {
     #[test_case(Rule::RuntimeImportInTypeCheckingBlock, Path::new(&quot;quote3.py&quot;))]
     #[test_case(Rule::TypingOnlyThirdPartyImport, Path::new(&quot;quote3.py&quot;))]
     fn quote(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;quote_{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;quote_{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -126,7 +121,7 @@ mod tests {
     #[test_case(Rule::TypingOnlyStandardLibraryImport, Path::new(&quot;init_var.py&quot;))]
     #[test_case(Rule::TypingOnlyStandardLibraryImport, Path::new(&quot;kw_only.py&quot;))]
     fn strict(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;strict_{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;strict_{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -170,7 +165,7 @@ mod tests {
         Path::new(&quot;exempt_type_checking_3.py&quot;)
     )]
     fn exempt_type_checking(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -207,7 +202,7 @@ mod tests {
         Path::new(&quot;runtime_evaluated_base_classes_5.py&quot;)
     )]
     fn runtime_evaluated_base_classes(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -238,7 +233,7 @@ mod tests {
         Path::new(&quot;runtime_evaluated_decorators_3.py&quot;)
     )]
     fn runtime_evaluated_decorators(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -264,7 +259,7 @@ mod tests {
         Path::new(&quot;module/undefined.py&quot;)
     )]
     fn base_class_same_file(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -282,7 +277,7 @@ mod tests {
     #[test_case(Rule::RuntimeImportInTypeCheckingBlock, Path::new(&quot;module/app.py&quot;))]
     #[test_case(Rule::TypingOnlyStandardLibraryImport, Path::new(&quot;module/routes.py&quot;))]
     fn decorator_same_file(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;flake8_type_checking&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
diff --git a/crates/ruff_linter/src/rules/numpy/mod.rs b/crates/ruff_linter/src/rules/numpy/mod.rs
index 7a313eac2..9403f2501 100644
--- a/crates/ruff_linter/src/rules/numpy/mod.rs
+++ b/crates/ruff_linter/src/rules/numpy/mod.rs
@@ -4,7 +4,6 @@ pub(crate) mod rules;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -22,7 +21,7 @@ mod tests {
     #[test_case(Rule::Numpy2Deprecation, Path::new(&quot;NPY201_2.py&quot;))]
     #[test_case(Rule::Numpy2Deprecation, Path::new(&quot;NPY201_3.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;numpy&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_linter/src/rules/pydoclint/mod.rs b/crates/ruff_linter/src/rules/pydoclint/mod.rs
index af4131e42..6e2ff9402 100644
--- a/crates/ruff_linter/src/rules/pydoclint/mod.rs
+++ b/crates/ruff_linter/src/rules/pydoclint/mod.rs
@@ -4,7 +4,6 @@ pub mod settings;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -20,7 +19,7 @@ mod tests {
 
     #[test_case(Rule::DocstringMissingException, Path::new(&quot;DOC501.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;pydoclint&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
@@ -36,7 +35,7 @@ mod tests {
     #[test_case(Rule::DocstringMissingException, Path::new(&quot;DOC501_google.py&quot;))]
     #[test_case(Rule::DocstringExtraneousException, Path::new(&quot;DOC502_google.py&quot;))]
     fn rules_google_style(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;pydoclint&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -58,7 +57,7 @@ mod tests {
     #[test_case(Rule::DocstringMissingException, Path::new(&quot;DOC501_numpy.py&quot;))]
     #[test_case(Rule::DocstringExtraneousException, Path::new(&quot;DOC502_numpy.py&quot;))]
     fn rules_numpy_style(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;pydoclint&quot;).join(path).as_path(),
             &amp;settings::LinterSettings {
@@ -79,7 +78,7 @@ mod tests {
     fn rules_google_style_ignore_one_line(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
         let snapshot = format!(
             &quot;{}_{}_ignore_one_line&quot;,
-            rule_code.as_ref(),
+            rule_code.name(),
             path.to_string_lossy()
         );
         let diagnostics = test_path(
diff --git a/crates/ruff_linter/src/rules/tryceratops/mod.rs b/crates/ruff_linter/src/rules/tryceratops/mod.rs
index 21f3a0138..8d431aae6 100644
--- a/crates/ruff_linter/src/rules/tryceratops/mod.rs
+++ b/crates/ruff_linter/src/rules/tryceratops/mod.rs
@@ -4,7 +4,6 @@ pub(crate) mod rules;
 
 #[cfg(test)]
 mod tests {
-    use std::convert::AsRef;
     use std::path::Path;
 
     use anyhow::Result;
@@ -25,7 +24,7 @@ mod tests {
     #[test_case(Rule::ErrorInsteadOfException, Path::new(&quot;TRY400.py&quot;))]
     #[test_case(Rule::VerboseLogMessage, Path::new(&quot;TRY401.py&quot;))]
     fn rules(rule_code: Rule, path: &amp;Path) -&gt; Result&lt;()&gt; {
-        let snapshot = format!(&quot;{}_{}&quot;, rule_code.as_ref(), path.to_string_lossy());
+        let snapshot = format!(&quot;{}_{}&quot;, rule_code.name(), path.to_string_lossy());
         let diagnostics = test_path(
             Path::new(&quot;tryceratops&quot;).join(path).as_path(),
             &amp;settings::LinterSettings::for_rule(rule_code),
diff --git a/crates/ruff_macros/src/map_codes.rs b/crates/ruff_macros/src/map_codes.rs
index 7d1ccaf02..39993af6a 100644
--- a/crates/ruff_macros/src/map_codes.rs
+++ b/crates/ruff_macros/src/map_codes.rs
@@ -174,7 +174,7 @@ pub(crate) fn map_codes(func: &amp;ItemFn) -&gt; syn::Result&lt;TokenStream&gt; {
 
         output.extend(quote! {
             impl #linter {
-                pub fn rules(&amp;self) -&gt; ::std::vec::IntoIter&lt;Rule&gt; {
+                pub(crate) fn rules(&amp;self) -&gt; ::std::vec::IntoIter&lt;Rule&gt; {
                     match self { #prefix_into_iter_match_arms }
                 }
             }
@@ -182,7 +182,7 @@ pub(crate) fn map_codes(func: &amp;ItemFn) -&gt; syn::Result&lt;TokenStream&gt; {
     }
     output.extend(quote! {
         impl RuleCodePrefix {
-            pub fn parse(linter: &amp;Linter, code: &amp;str) -&gt; Result&lt;Self, crate::registry::FromCodeError&gt; {
+            pub(crate) fn parse(linter: &amp;Linter, code: &amp;str) -&gt; Result&lt;Self, crate::registry::FromCodeError&gt; {
                 use std::str::FromStr;
 
                 Ok(match linter {
@@ -190,7 +190,7 @@ pub(crate) fn map_codes(func: &amp;ItemFn) -&gt; syn::Result&lt;TokenStream&gt; {
                 })
             }
 
-            pub fn rules(&amp;self) -&gt; ::std::vec::IntoIter&lt;Rule&gt; {
+            pub(crate) fn rules(&amp;self) -&gt; ::std::vec::IntoIter&lt;Rule&gt; {
                 match self {
                     #(RuleCodePrefix::#linter_idents(prefix) =&gt; prefix.clone().rules(),)*
                 }
@@ -319,7 +319,7 @@ See also https://github.com/astral-sh/ruff/issues/2186.
                 matches!(self.group(), RuleGroup::Preview)
             }
 
-            pub fn is_stable(&amp;self) -&gt; bool {
+            pub(crate) fn is_stable(&amp;self) -&gt; bool {
                 matches!(self.group(), RuleGroup::Stable)
             }
 
@@ -371,7 +371,7 @@ fn generate_iter_impl(
     quote! {
         impl Linter {
             /// Rules not in the preview.
-            pub fn rules(self: &amp;Linter) -&gt; ::std::vec::IntoIter&lt;Rule&gt; {
+            pub(crate) fn rules(self: &amp;Linter) -&gt; ::std::vec::IntoIter&lt;Rule&gt; {
                 match self {
                     #linter_rules_match_arms
                 }
@@ -385,7 +385,7 @@ fn generate_iter_impl(
         }
 
         impl RuleCodePrefix {
-            pub fn iter() -&gt; impl Iterator&lt;Item = RuleCodePrefix&gt; {
+            pub(crate) fn iter() -&gt; impl Iterator&lt;Item = RuleCodePrefix&gt; {
                 use strum::IntoEnumIterator;
 
                 let mut prefixes = Vec::new();
@@ -436,7 +436,6 @@ fn register_rules&lt;'a&gt;(input: impl Iterator&lt;Item = &amp;'a Rule&gt;) -&gt; TokenStream {
             PartialOrd,
             Ord,
             ::ruff_macros::CacheKey,
-            AsRefStr,
             ::strum_macros::IntoStaticStr,
             ::strum_macros::EnumString,
             ::serde::Serialize,
diff --git a/crates/ruff_server/src/server/api/requests/hover.rs b/crates/ruff_server/src/server/api/requests/hover.rs
index 6b391e15b..846f3654c 100644
--- a/crates/ruff_server/src/server/api/requests/hover.rs
+++ b/crates/ruff_server/src/server/api/requests/hover.rs
@@ -85,7 +85,7 @@ pub(crate) fn hover(
 
 fn format_rule_text(rule: Rule) -&gt; String {
     let mut output = String::new();
-    let _ = write!(&amp;mut output, &quot;# {} ({})&quot;, rule.as_ref(), rule.noqa_code());
+    let _ = write!(&amp;mut output, &quot;# {} ({})&quot;, rule.name(), rule.noqa_code());
     output.push('\n');
     output.push('\n');
 
diff --git a/crates/ruff_workspace/src/configuration.rs b/crates/ruff_workspace/src/configuration.rs
index 684a2b434..ae0d23150 100644
--- a/crates/ruff_workspace/src/configuration.rs
+++ b/crates/ruff_workspace/src/configuration.rs
@@ -1098,7 +1098,7 @@ impl LintConfiguration {
         // approach to give each pair it's own `warn_user_once`.
         for (preferred, expendable, message) in INCOMPATIBLE_CODES {
             if rules.enabled(*preferred) &amp;&amp; rules.enabled(*expendable) {
-                warn_user_once_by_id!(expendable.as_ref(), &quot;{}&quot;, message);
+                warn_user_once_by_id!(expendable.name().as_str(), &quot;{}&quot;, message);
                 rules.disable(*expendable);
             }
         }
</code></pre>
</details>

<p>IMO, it improves readability over the <code>to_string</code>, <code>as_ref</code> or <code>let name: &amp;'static str = rule.into()</code> calls</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 13:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:69 on 2025-06-04 13:42</div>
            <div class="timeline-body"><p>I looked into this a bit last week, and the tricky thing is that despite <code>NoqaCode</code> having two <code>&amp;'static str</code>s and a <code>prefix</code> and <code>suffix</code>  method, they don't always do what you expect because in cases with multiple common prefixes (at least I think this is the cause, from what I remember) the &quot;prefix&quot; will actually be empty and the whole code is in the &quot;suffix.&quot; That's why <code>parse_code</code> is implemented like this, I think.</p>
<p>This is also what I was trying to work around with my proc macro changes in https://github.com/astral-sh/ruff/pull/18391.</p>
<p>Here's the macro code for generating the <code>common_prefix</code> method:</p>
<p>https://github.com/astral-sh/ruff/blob/43277a1536e74379d04d249777567f2c245b829c/crates/ruff_macros/src/rule_namespace.rs#L89-L96</p>
<p>And then the construction of <code>NoqaCode</code>s uses it:</p>
<p>https://github.com/astral-sh/ruff/blob/43277a1536e74379d04d249777567f2c245b829c/crates/ruff_macros/src/map_codes.rs#L291-L293</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 13:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:69 on 2025-06-04 13:44</div>
            <div class="timeline-body"><p>I think your idea about storing a single <code>&amp;str</code> and a <code>usize</code> here might help, but it's still a bit tricky to get everything into a single <code>&amp;'static str</code>. We might still need my <code>const</code> tricks from the other PR to <code>concat!</code> them here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 13:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff/src/cache.rs</code>:443 on 2025-06-04 13:51</div>
            <div class="timeline-body"><p>I think we also avoid caching files with syntax errors, but that happens somewhere else. Here I think:</p>
<p>https://github.com/astral-sh/ruff/blob/43277a1536e74379d04d249777567f2c245b829c/crates/ruff/src/diagnostics.rs#L326-L331</p>
<p>(the comment is a bit outdated, <code>has_syntax_errors</code> includes semantic and version errors too)</p>
<p>So this filter shouldn't actually do anything anymore, except double check that the later <code>parse</code> call should be unwrappable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 13:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff/src/cache.rs</code>:360 on 2025-06-04 13:59</div>
            <div class="timeline-body"><p>Yes, good idea! I also added a comment explaining the filter/syntax error handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 14:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/noqa.rs</code>:818 on 2025-06-04 14:15</div>
            <div class="timeline-body"><p>Oh good catch. The one place this is called with a non-single-element vec is here:</p>
<p>https://github.com/astral-sh/ruff/blob/11db567b0b493b107446124d4121c3a5257fd6c3/crates/ruff_linter/src/noqa.rs#L814-L823</p>
<p>so I guess it's possible that there would be duplicates if the user had duplicate noqa comments in the input, if I'm reading this correctly. I can change it to a <code>HashSet</code> to avoid that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ntBre">@ntBre</a> on 2025-06-04 14:31</div>
            <div class="timeline-body"><p>Thanks for the patch! I also got confused a couple times by the various options but hadn't tried to fix it. This should help a lot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 14:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:74 on 2025-06-04 14:46</div>
            <div class="timeline-body"><p>I think we need the rule to call <code>message_formats</code>  and <code>explanation</code> anyway, right? I could be missing something here.</p>
<p>I previously tried a bigger refactor here where I passed the <code>Message::body</code> and <code>Message::suggestion</code> instead of <code>message_formats</code> and <code>explanation</code>, but they are quite different. <code>body</code> and <code>message_formats[0]</code> are pretty similar, and <code>body</code> is actually preferable, in my opinion, because it has the placeholders from <code>message_formats</code> filled in. But <code>explanation</code> is the full rule documentation, which I don't think we have easy access to except via the <code>Rule</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 15:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/fix/mod.rs</code>:134 on 2025-06-04 15:03</div>
            <div class="timeline-body"><p>I feel like I'm missing something here, but how does comparing the names help with readability? If we had a <code>const</code> way of getting the rule names, we could restore the <code>match</code> approach with something like:</p>
<pre><code class="language-rust">const REDEFINED_WHILE_UNUSED: &amp;str = Rule::RedefinedWhileUnused.name();

match (name1, name2) {
    (REDEFINED_WHILE_UNUSED, REDEFINED_WHILE_UNUSED) =&gt; Ordering::Equal,
    /* ... */
}
</code></pre>
<p>but it looks like the derived <code>IntoStaticStr</code> impl is not const. We could generate our own const version with our <code>kebab_case</code> macro, though.</p>
<p>Otherwise I guess I'm just picturing swapping out the <code>noqa_code</code> calls for <code>name</code> calls, which doesn't seem to help too much. Again I could be wrong,  but I don't think calling <code>name</code> is much cheaper than <code>noqa_code</code> either. It does have to call <code>Linter::common_prefix</code>, but that's just a match on the <code>Linter</code> enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-04 15:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:74 on 2025-06-04 15:06</div>
            <div class="timeline-body"><p>Oh, I didn't notice that it uses <code>message_formats</code>. I guess yes, in this case we'll need the rule</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-04 15:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/fix/mod.rs</code>:134 on 2025-06-04 15:08</div>
            <div class="timeline-body"><blockquote>
<p>but I don't think calling name is much cheaper than noqa_code e</p>
</blockquote>
<p>Doesn't <code>noqa_code</code> allocate because how <code>noqa_code</code> is designed today?</p>
<p>I agree, that it probably doesn't help with readability. Although we could probably inline the expression and hope for the compiler to inline the static string pointer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 15:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/fix/mod.rs</code>:134 on 2025-06-04 15:15</div>
            <div class="timeline-body"><p>I didn't think so since it's just two static strings:</p>
<p>https://github.com/astral-sh/ruff/blob/f1883d71a4d47a56f8dd8c1874db40f12bc3b105/crates/ruff_linter/src/codes.rs#L13-L14</p>
<p>Maybe I have too narrow a view of allocation, I was looking for a <code>String</code> to indicate that.</p>
<p>I can still switch it to <code>LintName</code>, one <code>&amp;'static str</code> should still be faster than two, either way. I was hoping I missed something with the readability though, the <code>match</code> was much nicer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 19:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_server/src/lint.rs</code>:172 on 2025-06-04 19:25</div>
            <div class="timeline-body"><p>Yeah... we actually end up using it like that in several, if not most, places. I guess this was the benefit of the separate <code>DiagnosticMessage</code> and <code>SyntaxErrorMessage</code> enum variants. It's just a bit unfortunate to make this explicit because you end up with an <code>is_syntax_error</code> check followed by an <code>unwrap</code>/<code>expect</code> if you need the noqa code.</p>
<p>In this case, it does look straightforward to combine <code>to_lsp_diagnostic</code> and <code>syntax_error_to_lsp_diagnostic</code>, so maybe we can treat them uniformly in other cases too. I'm happy to follow up with that!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-04 19:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:152 on 2025-06-04 19:32</div>
            <div class="timeline-body"><p>How do you feel about moving the <code>cfg</code> attrs here just to the <code>uri</code> attribute? Or alternatively something like</p>
<pre><code class="language-rust">let uri = cfg!(target_arch = &quot;wasm32&quot;) {
    path.display().to_string()
} else { 
      url::Url::from_file_path(&amp;path)
                .map_err(|()| anyhow::anyhow!(&quot;Failed to convert path to URL: {}&quot;, path.display()))?
                .to_string()
};
</code></pre>
<p>That's the only difference between these two <code>from_message</code> implementations. I guess it's pretty minor in this case, but I'm curious about your thoughts in general. I've managed to forget to update the wasm version at least twice in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-05 07:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/fix/mod.rs</code>:134 on 2025-06-05 07:05</div>
            <div class="timeline-body"><p>oh right. It only allocates when getting the full string. You're right. sorry</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-05 07:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:152 on 2025-06-05 07:07</div>
            <div class="timeline-body"><p>I don't know if you can use the inline <code>cfg</code> but I'm definetely in favor of reducing unnecessary code duplication</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-05 13:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:152 on 2025-06-05 13:26</div>
            <div class="timeline-body"><p>Ah you're right. <code>Url::from_file_path</code> isn't available on WASM. I'll just leave it alone for now, but good to know. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-05 14:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/message/sarif.rs</code>:152 on 2025-06-05 14:02</div>
            <div class="timeline-body"><p>The easiest would be to extract the URI conversion into it's own function and gate that</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-06-05 16:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/diagnostics.rs</code>:1 on 2025-06-05 16:34</div>
            <div class="timeline-body"><p>Nice cleanup in this commit!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ntBre">@ntBre</a> reviewed on 2025-06-05 16:36</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ntBre">@ntBre</a> on <code>crates/ruff/src/diagnostics.rs</code>:1 on 2025-06-05 16:36</div>
            <div class="timeline-body"><p>Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @ntBre on 2025-06-05 16:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ntBre on 2025-06-05 16:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-06-05 16:48</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:45:32 UTC
    </footer>
</body>
</html>
