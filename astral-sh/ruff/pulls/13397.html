<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] add support for typing_extensions.reveal_type - astral-sh/ruff #13397</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] add support for typing_extensions.reveal_type</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13397">#13397</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-09-18 21:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 21:19</div>
            <div class="timeline-body"><p>Before <code>typing.reveal_type</code> existed, there was <code>typing_extensions.reveal_type</code>. We should support both.</p>
<p>Also adds a test to verify that we can handle aliasing of <code>reveal_type</code> to a different name.</p>
<p>Adds a bit of code to ensure that if we have a union of different <code>reveal_type</code> functions (e.g. a union containing both <code>typing_extensions.reveal_type</code> and <code>typing.reveal_type</code>) we still emit the reveal-type diagnostic only once. This is probably unlikely in practice, but it doesn't hurt to handle it smoothly. (It comes up now because we don't support <code>version_info</code> checks yet, so <code>typing_extensions.reveal_type</code> is actually that union.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-09-18 21:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-09-18 21:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-09-18 21:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-18 21:32</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:710 on 2024-09-19 01:08</div>
            <div class="timeline-body"><p>This solves the specific case, but not the general case. In general, there'll be a large number of symbols that could come from <code>typing</code> or <code>typing_extension</code>, and we won't care which. I think we should add a separate method to <code>FunctionType</code> (<code>FunctionType::is_typing_symbol</code>?) where <code>foo.is_typing_symbol(&quot;X&quot;)</code> returns <code>true</code> if the qualified name of the type of <code>foo</code> is either <code>typing.X</code> or <code>typing_extensions.X</code> (and the module search path is a standard-library search path). That will make it less likely (though of course not impossible) in the future that we'll forget to account for the possibility that the symbol might come from <code>typing_extensions</code> rather than <code>typing</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 01:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:862 on 2024-09-19 04:17</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                    &amp;&amp; matches!(module.name(), &quot;typing&quot; | &quot;typing_extensions&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-09-19 04:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 04:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:862 on 2024-09-19 04:26</div>
            <div class="timeline-body"><p>oops, this should fix the build failure introduced by my previous suggestion:</p>
<pre><code class="language-suggestion">                    &amp;&amp; matches!(&amp;**module.name(), &quot;typing&quot; | &quot;typing_extensions&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 04:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:862 on 2024-09-19 04:27</div>
            <div class="timeline-body"><p>or this:</p>
<pre><code class="language-suggestion">                    &amp;&amp; matches!(module.name().as_str(), &quot;typing&quot; | &quot;typing_extensions&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-09-19 04:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-09-19 04:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-19 04:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-19 06:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:783 on 2024-09-19 06:14</div>
            <div class="timeline-body"><p>I wonder if this demonstrates a more general problem where we probably don't want to emit one diagnostic for each union member if some of them are not callable.</p>
<p>For example type script groups the error:</p>
<pre><code class="language-ts">let a: number | string;

a();
</code></pre>
<pre><code>This expression is not callable.
  No constituent of type 'string | number' is callable.(2349)
</code></pre>
<p>and I think that's better than having multiple diagnostics with the same range.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 17:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:783 on 2024-09-19 17:42</div>
            <div class="timeline-body"><p>I understand the idea, but I'm confused by the comment, because I think the code here already implements exactly what you're asking for? We already consolidate all not-callable errors from calling a union and emit just a single diagnostic naming all the not-callable elements of the union.</p>
<p>The one thing we don't do is have a special error message for the case when all the union elements are not callable; in the case you show from typescript we would currently emit <code>Union elements string, number of type 'string | number' are not callable.</code>. But this additional case would be easy to add if we want it.</p>
<p>This wasn't implemented in this PR, it was implemented in the original PR that added union-call support: https://github.com/astral-sh/ruff/pull/13384</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:30:59 UTC
    </footer>
</body>
</html>
