<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Literal special form - astral-sh/ruff #13874</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Literal special form</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13874">#13874</a>
        opened by <a href="https://github.com/Glyphack">@Glyphack</a>
        on 2024-10-22 06:58
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a></div>
            <div class="timeline-body"><p>Handling <code>Literal</code> type in annotations.</p>
<p>Resolves: #13672</p>
<h2>Implementation</h2>
<p>Since Literals are not a fully defined type in typeshed. I used a trick to figure out when a special form is a literal.
When we are inferring assignment types I am checking if the type of that assignment was resolved to typing.SpecialForm and the name of the target is <code>Literal</code> if that is the case then I am re creating a new instance type and set the known instance field to <code>KnownInstance:Literal</code>.</p>
<p><strong>Why not defining a new type?</strong></p>
<p>From this <a href="https://github.com/python/typeshed/issues/6219">issue</a> I learned that we want to resolve members to SpecialMethod class. So if we create a new instance here we can rely on the member resolving in that already exists.</p>
<h2>Tests</h2>
<p>https://typing.readthedocs.io/en/latest/spec/literal.html#equivalence-of-two-literals
Since the type of the value inside Literal is evaluated as a Literal(LiteralString, LiteralInt, ...) then the equality is only true when types and value are equal.</p>
<p>https://typing.readthedocs.io/en/latest/spec/literal.html#legal-and-illegal-parameterizations</p>
<p>The illegal parameterizations are mostly implemented I'm currently checking the slice expression and the slice type to make sure it's valid.</p>
<p>Not covered:</p>
<ol>
<li>I did not find an easy way to error on things like <code>Literal[&quot;foo&quot;.replace(&quot;o&quot;, &quot;b&quot;)]</code> because I cannot fully disable attribute expressions in the Literal since enum members are allowed.</li>
<li>parenthesized Tuples are not allowed. Although pyright allows <a href="https://pyright-play.net/?code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAySMApiAIYA2AUNeQFyHFlUDaAFAIwCUAugLxRO1IA">this</a> in the doc is stated that tuples containing valid literal types are illegal. Tuples are valid in case of <code>Literal[&quot;w&quot;, &quot;r&quot;]</code> for example.</li>
</ol>
<p>The union creation with Literals is not working because I saw comments about Union not implemented yet.
https://typing.readthedocs.io/en/latest/spec/literal.html#shortening-unions-of-literals</p>
<!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the  following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<!-- What's the purpose of the change? What does it do, and why? -->

<h2>Test Plan</h2>
<!-- How was it tested? -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @Glyphack on 2024-10-22 22:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @Glyphack on 2024-10-22 22:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @Glyphack on 2024-10-22 22:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @Glyphack on 2024-10-22 22:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-22 22:27</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:20 on 2024-10-22 23:49</div>
            <div class="timeline-body"><p>I don't think it's correct for us to infer a literal type from the use of <code>Literal</code> in a value expression like this, only in a type expression (an expression in a type annotation position). So the tests (above and below) using <code>x</code> and <code>mode</code> are correct, but these highlighted tests are not. I would expect all of these to reveal <code>typing._SpecialForm</code>, as mypy does. (Pyright reveals <code>type[Literal[2]]</code> for <code>Literal[2]</code> in a value expression, but I don't feel that's correct or a well-defined type, since <code>type[...]</code> is only defined when parametrized by a class name.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:24 on 2024-10-22 23:50</div>
            <div class="timeline-body"><p>can probably remove this comment?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unary/instance.md</code>:22 on 2024-10-22 23:50</div>
            <div class="timeline-body"><p>shouldn't it be <code>Literal[True]</code>, since that's what <code>__invert__</code> returns on this type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1194 on 2024-10-22 23:55</div>
            <div class="timeline-body"><p>Probably this should match the actual name of the symbol in the <code>typing</code> module?</p>
<pre><code class="language-suggestion">            Self::SpecialForm =&gt; &quot;_SpecialForm&quot;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1222 on 2024-10-22 23:57</div>
            <div class="timeline-body"><p>This doesn't look right, because SpecialForm doesn't exist in the <code>_typeshed</code> module, which is where <code>typeshed_symbol_ty</code> will look for it.</p>
<p>We should get <code>_SpecialForm</code> from the <code>typing</code> module, and we currently don't have any KnownClass from there, so we'll need to add a <code>typing_symbol_ty</code> in <code>red_knot_python_semantic/src/stdlib.rs</code> (along with <code>CoreStdlibModule::Typing</code>) and use that here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1377 on 2024-10-22 23:59</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // If the variable is annotated with SpecialForm then create a new class with name of the
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1373 on 2024-10-23 00:01</div>
            <div class="timeline-body"><p>We should use another <code>if-let</code> here to guard against the possibility that the target isn't a simple Name (in which case we can just assume this isn't any known special form, but we shouldn't panic)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1382 on 2024-10-23 00:17</div>
            <div class="timeline-body"><p>Special forms are not classes at runtime, they are instances of <code>typing._SpecialForm</code>, and this is also how they are represented in typeshed, so we should not pretend they are classes. The type of <code>typing.Literal</code> should be <code>Type::Instance(&lt;ClassType of typing._SpecialForm&gt;)</code>.</p>
<p>But we do need to be able to recognize <code>typing.Literal</code> later, and not pretending it's a class means we can't use <code>KnownClass</code> to recognize it later.</p>
<p>We can introduce <code>KnownInstance</code> enum and expand <code>Type::Instance</code> to be a struct variant with a <code>known: Option&lt;KnownInstance&gt;</code> field and a <code>class: ClassType</code> field, so that we can mark certain instance types as known. This is the most generic/correct approach (since it means that wherever we don't check the <code>known</code> field it will behave like a regular instance of <code>typing._SpecialForm</code>), and I think it shouldn't actually make the <code>Type</code> enum any larger, because <code>ClassType</code> is a Salsa u32 ID, so even with an extra <code>Option&lt;KnownInstance&gt;</code> field we should still be able to be smaller than the <code>IntLiteral(i64)</code> variant. (We'll want to verify -- by temporarily inserting a <code>dbg!(std::mem::sizeof::&lt;Type&gt;());</code> somewhere before and after the change -- that we haven't made <code>Type</code> larger, though, since that would be a high cost. Maybe we should actually just add a unit test somewhere that asserts on the size of <code>Type</code>, so we don't accidentally make it bigger.)</p>
<p>For now <code>KnownInstance</code> can just include <code>Literal</code> as its only variant; in the future we'll add more variants for other known special forms.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3341 on 2024-10-23 00:18</div>
            <div class="timeline-body"><p>I think here we should not be handling special forms at all, since this is type inference for value expressions, not type expressions. (This is related to the comment on the tests above.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3530 on 2024-10-23 00:22</div>
            <div class="timeline-body"><p>Here is where we need the code to recognize special forms, but we should not be falling back to <code>infer_subscript_expression</code> here (that's for value expressions), instead we should have a dedicated <code>infer_subscript_type_expression</code> method, which should use <code>infer_type_expression</code> on the value and the index, and for now handle only the case where the value is <code>typing.Literal</code> special form, otherwise just return <code>Todo</code>.</p>
<p>(The fact that <code>infer_subscript_expression</code> was previously called here was just an easy placeholder way to ensure we cover all the sub-expressions, until we added proper support for inferring types correctly in type expressions.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-10-23 00:23</div>
            <div class="timeline-body"><p>Nice work! This task is actually quite a bit harder than I made it sound, I was forgetting some of the complexity in recognizing special forms :) This is a really good initial effort. Let me know if any of the comments below don't make sense or need further clarification.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-10-23 00:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-24 17:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/resources/mdtest/unary/instance.md</code>:22 on 2024-10-24 17:10</div>
            <div class="timeline-body"><p>Oops right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-27 17:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:20 on 2024-10-27 17:16</div>
            <div class="timeline-body"><p>Thanks for the explanation. I changed these to be used as annotations instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-27 17:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3530 on 2024-10-27 17:22</div>
            <div class="timeline-body"><p>That makes sense. Just one question, should we use <code>infer_type_expression</code> for all indexes?
For example Literal in <a href="https://typing.readthedocs.io/en/latest/spec/annotations.html#grammar-token-expression-grammar-type_expression">here</a> is defined with an expression in the index. Others have <code>annotation_expression</code> in their grammar. So here I use <code>infer_type_expression</code> for other things but if it's Literal I use <code>infer_expression</code>.</p>
<p>My reasoning behind it was when the value is <code>True</code>. The <code>True</code> itself should not have any meaning when used alone in the type annotation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:78 on 2024-10-27 20:59</div>
            <div class="timeline-body"><pre><code class="language-suggestion">/// Lookup the type of `symbol` in the `typing` module namespace.
///
/// Returns `Unbound` if the `typing` module isn't available for some reason.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-27 21:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-10-27 21:21</div>
            <div class="timeline-body"><p>I applied the comments will spend another day on adding diagnostic messages for https://typing.readthedocs.io/en/latest/spec/literal.html#legal-and-illegal-parameterizations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-10-28 20:46</div>
            <div class="timeline-body"><p>Okay I added more parts of the legal and illegal parameters from the spec. Right now we have:</p>
<ol>
<li>All Literal types I managed to do this through a lot of recursion.</li>
<li>Nested Literals</li>
</ol>
<p>I think the remaining part is assignability check. Right now the Literals are unwrapped to their inner type I don't think this is the right way, is it? It works in the tests but I'm not sure if Literal types should carry some special flags with themselves.</p>
<p>I did not find an easy way to error on things like Literal[&quot;foo&quot;.replace(&quot;o&quot;, &quot;b&quot;)] because I cannot fully disable attribute expressions in the Literal since enum members are allowed.
I can do the same I did on nested literals:</p>
<ol>
<li>Check if it's attribute</li>
<li>Check the type of value and if it's a class and has Enum in bases otherwise emit diagnostic.</li>
</ol>
<p>Does this sound good?</p>
<p>parenthesized Tuples are not allowed. Although pyright allows <a href="https://pyright-play.net/?code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAySMApiAIYA2AUNeQFyHFlUDaAFAIwCUAugLxRO1IA">this</a> in the doc is stated that tuples containing valid literal types are illegal. Tuples are valid in case of Literal[&quot;w&quot;, &quot;r&quot;] for example.</p>
<p>Also I'm not correctly joining union when it's possible. I left it as a todo in the tests:</p>
<pre><code>    # TODO: revealed: Literal[1, 2, 3, &quot;foo&quot;, 5] | None
    reveal_type(union_var)  # revealed: Literal[1, 2, 3] | Literal[&quot;foo&quot;] | Literal[5] | None
</code></pre>
<p>Please let me know what do you think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @Glyphack on 2024-10-28 21:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @Glyphack on 2024-10-28 21:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Add Literal special form to types" to "Literal special form" by @Glyphack on 2024-10-28 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Literal special form" to "[red-knot] Literal special form" by @Glyphack on 2024-10-28 21:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-28 22:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:576 on 2024-10-28 22:31</div>
            <div class="timeline-body"><p>I'm thinking to go over all of the instance of <code>Instance(class_type)</code> and rename to <code>Instance(instance)</code> so it's not misleading.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-28 22:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3562 on 2024-10-28 22:35</div>
            <div class="timeline-body"><p>I created this function so I can call this on each parameter inside the [] so if we have <code>Literal[Literal[expr]]</code> it's converted to <code>Literal[expr]</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-28 22:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3485 on 2024-10-28 22:37</div>
            <div class="timeline-body"><p>I needed to keep this here because we have a test case that checks we emit unsubscriptable error in type annotations so I kept it here with a todo to not break that test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:17 on 2024-10-28 23:38</div>
            <div class="timeline-body"><p>This looks identical to <code>a4</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:53 on 2024-10-28 23:40</div>
            <div class="timeline-body"><p>Preference is to skip the full message assertion when it's not really specific to the test case, just generic to the error code:</p>
<pre><code class="language-suggestion"># error: [invalid-literal-parameter]
invalid1: Literal[3 + 4]
# error: [invalid-literal-parameter]
invalid2: Literal[4 + 3j]
# error: [invalid-literal-parameter]
invalid3: Literal[(3, 4)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:78 on 2024-10-28 23:43</div>
            <div class="timeline-body"><p>This comment was marked resolved, but it looks like it is still relevant and not addressed yet? I un-resolved it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1194 on 2024-10-29 00:07</div>
            <div class="timeline-body"><p>(Un-resolved this comment, because it doesn't look addressed.) Is there a reason this needs to stay <code>&quot;SpecialForm&quot;</code> and not match the actual name in the module?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1223 on 2024-10-29 00:08</div>
            <div class="timeline-body"><p>We don't do this assert for the other special forms, I don't think we need to here either.</p>
<pre><code class="language-suggestion">            Self::SpecialForm =&gt; typing_symbol_ty(db, self.as_str())
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-29 01:22</div>
            <div class="timeline-body"><p>Explaining the commit I just pushed:</p>
<p>My intent in suggesting <code>InstanceType</code> was that it would not be a Salsa interned struct, but just a regular struct that would be stored inline in <code>Type</code>, so we wouldn't add an extra layer of database queries. That's why I was discussing the size of <code>Type</code>. I wanted to verify that this really worked, and didn't increase the size of <code>Type</code>, before making the suggestion -- and once I had verified that, I figured I might as well push the changes and not ask you to make them again :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:576 on 2024-10-29 01:23</div>
            <div class="timeline-body"><p>Yes, agree that we should do this before landing this PR. I did a couple more in the commit I just pushed, but not all of them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2209 on 2024-10-29 01:25</div>
            <div class="timeline-body"><p>Awesome, thank you for adding this!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1377 on 2024-10-29 01:26</div>
            <div class="timeline-body"><p>This comment also doesn't look resolved?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1035 on 2024-10-29 01:32</div>
            <div class="timeline-body"><p>This isn't right; <code>.to_instance()</code> on an instance should never return itself; an instance is not an instance of itself.</p>
<p>The fact that we need this to make tests pass indicates we need to do something different in type inference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1384 on 2024-10-29 01:39</div>
            <div class="timeline-body"><p>Let's use <code>maybe_from_module</code> and <code>check_module</code> methods on <code>KnownInstance</code> (similar to <code>KnownClass</code>) to a) require that we only recognize <code>Literal</code> if defined in <code>typing</code> or <code>typing_extensions</code>, and b) avoid having to explicitly list each <code>KnownInstance</code> here (there will be more in future.)</p>
<p>Also let's add tests showing that we <em>do</em> recognize <code>typing_extensions.Literal</code> as well as <code>typing.Literal</code>, and that we <em>don't</em> recognize <code>some_other_random_module.Literal</code>, even if it's defined using an annotation with <code>_SpecialForm</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2725 on 2024-10-29 01:40</div>
            <div class="timeline-body"><p>Here and below, if all we need is the class we could unpack right in the match (e.g. <code>Type::Instance(InstanceType { class_type: left_class, .. })</code>) instead of pulling out the attributes afterward. Up to you which you think is nicer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3456 on 2024-10-29 01:43</div>
            <div class="timeline-body"><p>nit: We have a separate impl section of <code>TypeInferenceBuilder</code> below for inference of type expressions (it has the comment <code>// Type expressions</code> and its first method is <code>infer_type_expression</code>). Let's put all type-expression-specific inference methods there, beneath <code>infer_type_expression</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3485 on 2024-10-29 01:51</div>
            <div class="timeline-body"><p>I think if you look carefully at those test cases, they all have their own TODO comments saying that they <em>shouldn't</em> emit that unsubscriptable error :)</p>
<p>This PR will eventually need to merge with https://github.com/astral-sh/ruff/pull/13943 so you can look at what @AlexWaygood did there and follow the same approach.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3492 on 2024-10-29 01:53</div>
            <div class="timeline-body"><p>This comment seems out of place and probably unnecessary? There's nothing near this comment named <code>slice_ty</code>, and I'm not sure what &quot;treated as expression&quot; means -- the slice of a subscript expression <em>is</em> an expression in the AST, that's just a fact.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3548 on 2024-10-29 01:56</div>
            <div class="timeline-body"><p>I think a better approach here would be for <code>infer_literal_parameter_type</code> to return <code>Option&lt;Type&lt;'db&gt;&gt;</code>, and return <code>None</code> if the literal parameter is not valid, otherwise the right <code>Type</code>. Then you only need to emit the error in one place (if <code>infer_literal_parameter_type</code> returns <code>None</code>), and you don't need these two extra match statements here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3557 on 2024-10-29 01:59</div>
            <div class="timeline-body"><p>Doesn't seem right to use <code>infer_expression</code> here, it should be <code>infer_type_expression</code> -- and then you shouldn't have to repeat the recognition of <code>Literal</code> below, or the invalid-literal-parameter error, <code>infer_type_expression</code> should do all that for you? You just have to verify the type you get back is a literal type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3585 on 2024-10-29 02:01</div>
            <div class="timeline-body"><p>Rather than matching out in <code>infer_parameterized_known_instance_type_expression</code> on AST forms known not to be valid, I think we should explicitly match here on each AST form known to be valid, and directly return the right type, without relying on <code>self.infer_expression</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-10-29 02:02</div>
            <div class="timeline-body"><p>Tests are looking really good here! I pushed some changes to the <code>InstanceType</code> implementation (so it's not Salsa-interned), and left some comments on the inference implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-29 07:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:78 on 2024-10-29 07:56</div>
            <div class="timeline-body"><p>IIRC @Glyphack did apply this suggestion using the GitHub web UI... Possibly it was accidentally lost in a force-push following that @Glyphack? :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-29 08:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:78 on 2024-10-29 08:01</div>
            <div class="timeline-body"><p>Yes I'm sorry about that it caused a lot of resolved ones to be unresolved again. I will keep the comments open so I check them again before requesing review.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-10-29 08:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1194 on 2024-10-29 08:22</div>
            <div class="timeline-body"><p>No sorry I accidentally force pushed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3544 on 2024-10-29 13:56</div>
            <div class="timeline-body"><p>there's a bit of a footgun here in our current design, in that you should never really use <code>UnionType::new()</code> directly, because it doesn't deduplicate the elements in the union. Instead you should always use <code>UnionType::from_elements()</code>, which takes care of all the deduplication for you</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3574 on 2024-10-29 13:58</div>
            <div class="timeline-body"><p>the formatting here is somewhat skew-whiff (I think <code>cargo fmt</code> is failing to spot it because of the macro, unfortunately)</p>
<pre><code class="language-suggestion">                    self.add_diagnostic(
                        parameters.into(),
                        &quot;invalid-literal-parameter&quot;,
                        format_args!(
                            &quot;Type arguments for `Literal` must be None, a literal value (int, bool, str, or bytes), or an enum value&quot;,
                        ),
                    );
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3584 on 2024-10-29 14:01</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            ruff_python_ast::Expr::Tuple(t) =&gt; {
                let elements: Box&lt;_&gt; = t.iter().map(|elt| self.infer_literal_parameter_type(elt)).collect();
                Type::Tuple(TupleType::new(self.db, elements))
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-29 14:01</div>
            <div class="timeline-body"><p>A couple more comments on top of Carl's</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 14:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2725 on 2024-11-02 14:31</div>
            <div class="timeline-body"><p>I agree this is nicer, I initially made that mistake with making it interned and tried a lot to use this syntax to work but couldn't. I will change to this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 14:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3492 on 2024-11-02 14:49</div>
            <div class="timeline-body"><p>I was trying to explain why I used <code>self.infer_expression</code> function on literal parameters and not infer them using type annotation method. I moved the comment down to the right place where we call the function.
I'm open to suggestions to how to describe this. My point here is to remind this rule:
<img src="https://github.com/user-attachments/assets/124915b4-add8-4cad-ab31-6d4bc8bddc47" alt="image" /></p>
<p>But after applying other comments it's not a single place to put this anymore so I removed the comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 15:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3574 on 2024-11-02 15:12</div>
            <div class="timeline-body"><p>Thanks I was confused why it's not being formatted. I cannot apply this because I resolved other comments first but I will double check final changes are correctly formatted.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 15:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3584 on 2024-11-02 15:25</div>
            <div class="timeline-body"><p>I like this better than the for loop but after applying one of Carl's comments I changed the return type to Option. So here one of the elements might be mapped to None. I changed this suggestion to this so it will return None and emit the diagnostic if one of the elements could not be inferred:</p>
<pre><code class="language-python">                let Ok(elements): Result&lt;Box&lt;_&gt;, _&gt; = t
                    .iter()
                    .map(|elt| self.infer_literal_parameter_type(elt).ok_or(&quot;invalid element&quot;))
                    .collect() else {return None};
</code></pre>
<p>Let me know if there's a better way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 15:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3585 on 2024-11-02 15:44</div>
            <div class="timeline-body"><p>Got it. Do you mean to not rely only on <code>infer_expression</code> so I call each ast type infer method separately? for example for boolean call:</p>
<pre><code>ruff_python_ast::Expr::BooleanLiteral(literal) =&gt; {
                self.infer_boolean_literal_expression(literal)
            }
</code></pre>
<p>Or do you mean to completely not rely on those functions and return the type directly? I did use the functions to avoid repeating them could something go wrong this way?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 15:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3557 on 2024-11-02 15:59</div>
            <div class="timeline-body"><p>Thanks. Do you think it's useful to add a function that can detect if a type is any of the Literal types? I put it here since it's only here at the moment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 16:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1384 on 2024-11-02 16:05</div>
            <div class="timeline-body"><p>I applied this. But the tests were not failing when I initially added them before fixing the logic to not rely only on string names. I will check why this is happening. So it works but I don't understand how ðŸ˜„
I'm checking why it is this way. Is it a blocker for this PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @Glyphack on 2024-11-02 16:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 16:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:250 on 2024-11-02 16:57</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            if let Type::Instance(InstanceType { class_type, .. }) = new_positive {
                if class_type.is_known(db, KnownClass::Bool) {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-02 16:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1355 on 2024-11-02 16:59</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        // If the declared variable is annotated with _SpecialForm class then we treat it differently
        // by assigning the known field to the instance.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @Glyphack on 2024-11-02 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @Glyphack on 2024-11-02 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1401 on 2024-11-04 14:52</div>
            <div class="timeline-body"><p>Unfortunately there is also a <code>typing_extensions._SpecialForm</code>, which I think we also need to account for here:</p>
<p>https://github.com/astral-sh/ruff/blob/a7a78f939c2c393aa846b97fdbd32c1c3bfc7b34/crates/red_knot_vendored/vendor/typeshed/stdlib/typing_extensions.pyi#L193-L198</p>
<pre><code class="language-suggestion">            Self::SpecialForm =&gt; {
                matches!(module.name().as_str(), &quot;typing&quot; | &quot;typing_extensions&quot;)
            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1957 on 2024-11-04 14:54</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        self.known == Some(known_instance)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2088 on 2024-11-04 15:00</div>
            <div class="timeline-body"><p>I think the <code>known</code> method here needs to have a different name, or it conflicts with the name of the field on the class. Rust <em>lets</em> you do that, but I find it pretty confusing to have a method the same name as a field that does quite a different thing ðŸ˜†</p>
<p>How about <code>new_known()</code> and <code>new_unknown</code> for the two constructors? That would also have the nice property of making it obvious that they are parallel to each other</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-04 15:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1424 on 2024-11-04 15:03</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        candidate.check_module(module).then_some(candidate)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1505 on 2024-11-04 15:05</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                        .and_then(|module| KnownInstance::maybe_from_module(module, &amp;name_expr.id));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4040 on 2024-11-04 15:07</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                Type::Todo  // TODO: generics
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1494 on 2024-11-04 15:09</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    Literal,
    // TODO: fill this enum out with more special forms, etc.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4056 on 2024-11-04 15:10</div>
            <div class="timeline-body"><p>I think we do need <em>some</em> kind of message here to the user telling them what went wrong :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4088 on 2024-11-04 15:12</div>
            <div class="timeline-body"><p>Are parenthesized tuples explicitly disallowed by the spec? That would surprise me if so, since <code>Literal[1, 2]</code> and <code>Literal[(1, 2)]</code> have the same AST from Python's point of view.</p>
<p>If they're not explicitly disallowed, I'd prefer to allow them</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4095 on 2024-11-04 15:14</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                let elements = t
                    .iter()
                    .map(|elt| self.infer_literal_parameter_type(elt))
                    .collect::&lt;Option&lt;Box&lt;_&gt;&gt;&gt;()?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4117 on 2024-11-04 15:15</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                if matches!(u.op, UnaryOp::USub | UnaryOp::UAdd)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-04 15:16</div>
            <div class="timeline-body"><p>Nice, this looks great!! A few nitpicks, but nothing serious. There's a new merge conflict (sorry!) resulting from the recent removal of <code>Type::None</code> in favour of <code>Type::Instance(_typeshed.NoneType)</code>, but it shouldn't be too hard to fix, I don't think</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-04 18:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4088 on 2024-11-04 18:14</div>
            <div class="timeline-body"><p>I might misunderstood this. See the second point here:
<img width="1051" alt="image" src="https://github.com/user-attachments/assets/a40a8d84-863b-4dca-963f-a1698b0f45ee"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-11-04 18:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4056 on 2024-11-04 18:20</div>
            <div class="timeline-body"><p>Yeah I misunderstood this comment and removed the message.
https://github.com/astral-sh/ruff/pull/13874#discussion_r1819898105
Was the previous message good?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-04 18:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4056 on 2024-11-04 18:26</div>
            <div class="timeline-body"><p>yes, the previous message was fine! We should <em>have</em> a message here, we just shouldn't <em>assert</em> the message in our tests (because it's unnecessary).</p>
<p>For example, take our <code>cyclic-class-def</code> error code: we emit a message here, and it will be shown to users:</p>
<p>https://github.com/astral-sh/ruff/blob/b7e32b0a18487e8c9813e0d189d7a5d625ff5c3f/crates/red_knot_python_semantic/src/types/infer.rs#L481-L489</p>
<p>but we don't assert the full message in our tests, because it's the same every time, and it would just be a pain to update all those tests if we ever changed the error message slightly. Instead, we just assert the error code:</p>
<p>https://github.com/astral-sh/ruff/blob/b7e32b0a18487e8c9813e0d189d7a5d625ff5c3f/crates/red_knot_python_semantic/resources/mdtest/mro.md?plain=1#L350-L351</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-04 18:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4088 on 2024-11-04 18:32</div>
            <div class="timeline-body"><p>So, this section of the spec here is clear that <code>Literal[(1, 2)]</code> should not mean the same thing as <code>tuple[Literal[1], Literal[1]]</code>. A big part of the reason for this is that type checkers like mypy who use Python's AST wouldn't be able to tell the difference between <code>Literal[(1, 2)]</code> and <code>Literal[1, 2]</code>: the two expressions have the same AST in Python.</p>
<p>The spec here does not explicitly say whether <code>Literal[(1, 2)]</code> should mean the same thing as <code>Literal[1, 2]</code> or not. However, I think it would be unreasonable to say that they should <em>not</em> mean the same thing. As I just mentioned, type checkers like mypy that use Python's AST can't easily tell the difference, so it would be very hard for them to enforce that rule if the spec mandated it. Pyright <a href="https://pyright-play.net/?strict=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAySMApiAIYA2AUNQCYnBTAAU5AnAFyHFlUDaLAIwAaKACYAlAF1JnalEVQQJAG4kqAfXgISbdpOpA">seems to enforce this rule anyway</a>, but I think that's a bit silly personally.</p>
<p>I'm curious for @carljm's thoughts here!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-04 22:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4088 on 2024-11-04 22:21</div>
            <div class="timeline-body"><p>By my reading, the spec is quite clear that <code>Literal[(1, &quot;foo&quot;, &quot;bar&quot;)]</code> is a disallowed form; it seems like a stretch to me to try to read it any other way. It's specifically listed under forms that are &quot;intentionally disallowed by design.&quot; If the spec meant to say &quot;this form is valid, with this meaning&quot;, then it could and would say that, instead of saying that it's an invalid form. It even says <code>Literal[(1, 2, 3)]</code> &quot;could easily be confused with&quot; <code>Literal[1, 2, 3]</code>, which is a very weird thing to say if the intended meaning is that those should be equivalent.</p>
<p>An argument could be made that the spec should be changed to make <code>Literal[(1, 2, 3)]</code> equivalent to <code>Literal[1, 2, 3]</code>, because the Python typing spec shouldn't distinguish forms that can't be distinguished in the CPython AST. I have mixed feelings about that argument, but I don't care too much either way. I wouldn't champion such a change, nor would I oppose it.</p>
<p>But we <em>can</em> distinguish these forms, and it's a lot easier to disallow something now and allow it in the future than the other way around, so I think we should follow the spec and disallow it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-11-04 22:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4088 on 2024-11-04 22:32</div>
            <div class="timeline-body"><p>It seems especially unlikely to me that this really was the intended meaning of the spec, given that the PEP that introduced <code>Literal</code> (which was copied over to the spec verbatim) was written by a team of mypy developers. It's very hard for me to believe that they really wanted to specify something here that they knew they wouldn't be able to enforce in their reference implementation of the feature; it seems to me much more plausible that they meant only to say that parameterising <code>Literal</code> with a tuple literal wouldn't imply a tuple type.</p>
<p>But I don't feel too strongly, and I agree that it's easier to move from disallowed-&gt;allowed than vice versa. So let's leave things as @Glyphack has them for now ðŸ‘</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:79 on 2024-11-05 00:33</div>
            <div class="timeline-body"><p>I merged in main and this changed to <code>Literal[26]</code>, which is what it should be. I'm not sure why the merge from main fixed it? Maybe I fixed some logic in merge conflict resolution.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/literal/literal.md</code>:69 on 2024-11-05 00:40</div>
            <div class="timeline-body"><p>I think this test was passing for the wrong reason (for the same reason the below test wrongly had <code>@Todo</code>).</p>
<p>The reason this test was behaving oddly turned out to be pretty subtle. Locally within the same scope, we don't consider an annotated assignment with no RHS to actually define the name (because, well, at runtime it doesn't.) So what was actually happening here on the <code>a1: Literal[26]</code> line is that we failed to find a value for <code>Literal</code> in the same scope, and we looked it up in builtins, and we found it there! Imported from <code>typing.Literal</code>, because <code>builtins.pyi</code> actually does import <code>Literal</code> from <code>typing</code>, and we haven't yet implemented the re-export rules for imports that would tell us to ignore it: https://github.com/astral-sh/ruff/issues/14099 So currently we wrongly treat <code>typing.Literal</code> as a built-in :)</p>
<p>I fixed this test to create its &quot;custom&quot; <code>Literal</code> in a separate type stub and import it from there, which makes the test work as expected.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-11-05 00:42</div>
            <div class="timeline-body"><p>There were some things about the behavior of this PR that confused me, so I went ahead and merged in main and did the merge conflict resolution so I could explore those things. Since I did the work, going ahead and pushing it (with a few other small changes) to make sure we don't duplicate work.</p>
<p>Now continuing to review the rest...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2088 on 2024-11-05 00:54</div>
            <div class="timeline-body"><p>Hmm, I quite like the names as they are :/ There's no actual conflict; the method is an associated method, so it can't be called on an instance of the struct, only as <code>InstanceType::known</code>, and the field can only be accessed on an instance (<code>self.known</code>). And they are closely related and refer to the same thing, so it's not like we have a terminology clash that's confusing two unrelated concepts. It makes sense to me to have a constructor named <code>known</code> that creates an instance of the struct with its optional <code>known</code> field set to <code>Some(...)</code>.</p>
<p>I feel like avoiding this is maybe a Python habit, where it really would be a problem.</p>
<p>Using <code>new_*</code> for alternate constructors feels unwieldy and unusual. The <code>Default</code> trait doesn't define a <code>new_default</code> method, it defines a <code>default</code> method. And I feel that <code>new_unknown</code> is too close to the <code>Unknown</code> type. I prefer &quot;anonymous&quot; over &quot;unknown&quot; as the opposite to a &quot;known&quot; instance or class.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-11-05 01:28</div>
            <div class="timeline-body"><p>Great work!! The fixes needed were minor, and I really want to get this merged now to avoid more conflict resolution needed tomorrow, so I went ahead and made the small updates and am going to go ahead and merge it. If anyone has review comments on the bits that I'm landing unreviewed (or on the <code>InstanceType::known</code> naming question), one of us can put up a small follow-up PR tomorrow to take care of them.</p>
<p>Thank you @Glyphack for all your work on this! It definitely turned out to be more complex than I'd initially realized :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-11-05 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-11-05 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-11-05 04:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-11-05 04:37</div>
            <div class="timeline-body"><p>Thanks for your time and guidance, I appreciate it.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:07:09 UTC
    </footer>
</body>
</html>
