<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] infer function's return type - astral-sh/ruff #17371</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] infer function's return type</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17371">#17371</a>
        opened by <a href="https://github.com/mtshiba">@mtshiba</a>
        on 2025-04-13 05:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-04-13 05:48</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR closes astral-sh/ty#128.</p>
<p><code>FunctionType::infer_return_type</code> is added to infer the return type of a function when its return type is not specified.</p>
<h2>TODOs</h2>
<ul>
<li>[x] infer simple function's return type
~~- [ ] infer generator's return type~~
~~- [ ] infer coroutine's return type~~
~~- [ ] infer lambda function's return type~~</li>
</ul>
<h2>Test Plan</h2>
<p>New test cases are added to <code>mdtest/function/return_type.md</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-04-13 05:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @mtshiba on 2025-04-13 05:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @mtshiba on 2025-04-13 05:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @mtshiba on 2025-04-13 05:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-13 05:50</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">zipp (https://github.com/jaraco/zipp)
+ zipp/__init__.py:373:29: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `str | PathLike[str]`, found `Unknown | str | None`
+ zipp/__init__.py:433:16: error[no-matching-overload] No overload of function `join` matches arguments
+ zipp/glob.py:67:16: error[no-matching-overload] No overload of bound method `join` matches arguments
- Found 4 diagnostics
+ Found 7 diagnostics

attrs (https://github.com/python-attrs/attrs)
+ src/attr/_make.py:453:19: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Self@from_counting_attr | Unknown`
+ src/attr/_make.py:457:19: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Self@from_counting_attr | Unknown`
- src/attr/_make.py:475:35: warning[possibly-missing-attribute] Attribute `init` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:475:35: warning[possibly-missing-attribute] Attribute `init` may be missing on object of type `Unknown | Self@evolve`
- src/attr/_make.py:475:59: warning[possibly-missing-attribute] Attribute `kw_only` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:475:59: warning[possibly-missing-attribute] Attribute `kw_only` may be missing on object of type `Unknown | Self@evolve`
- src/attr/_make.py:480:37: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:480:37: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Unknown | Self@evolve`
- src/attr/_make.py:487:16: warning[possibly-missing-attribute] Attribute `alias` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:487:16: warning[possibly-missing-attribute] Attribute `alias` may be missing on object of type `Unknown | Self@evolve`
- src/attr/_make.py:489:70: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:489:70: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Unknown | Self@evolve`
- src/attr/_make.py:493:19: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:493:19: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Unknown | Self@evolve`
- src/attr/_make.py:797:13: error[invalid-assignment] Object of type `ReferenceType[Unknown]` is not assignable to attribute `__attrs_base_of_slotted__` on type `Unknown | type`
+ src/attr/_make.py:797:13: error[invalid-assignment] Object of type `ReferenceType[Unknown | type]` is not assignable to attribute `__attrs_base_of_slotted__` on type `Unknown | type`
+ src/attr/_make.py:809:13: warning[possibly-missing-attribute] Attribute `__attrs_init_subclass__` may be missing on object of type `Unknown | type`
- src/attr/_make.py:1061:13: error[invalid-argument-type] Argument to function `_make_hash_script` is incorrect: Expected `list[Attribute | Unknown]`, found `Unknown | type`
+ src/attr/_make.py:1061:13: error[invalid-argument-type] Argument to function `_make_hash_script` is incorrect: Expected `list[Attribute]`, found `Unknown | type`
- src/attr/_make.py:1608:13: error[invalid-assignment] Object of type `tuple[Attribute | Unknown, ...]` is not assignable to `list[Attribute | Unknown]`
+ src/attr/_make.py:1608:13: error[invalid-assignment] Object of type `tuple[Attribute, ...]` is not assignable to `list[Attribute]`
- src/attr/_make.py:1609:29: warning[possibly-missing-attribute] Attribute `hash` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1609:48: warning[possibly-missing-attribute] Attribute `hash` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1609:67: warning[possibly-missing-attribute] Attribute `eq` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1647:16: warning[possibly-missing-attribute] Attribute `eq_key` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1648:32: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1649:35: warning[possibly-missing-attribute] Attribute `eq_key` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1651:57: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:1654:62: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2189:12: warning[possibly-missing-attribute] Attribute `validator` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2192:21: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2193:26: warning[possibly-missing-attribute] Attribute `on_setattr` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2194:13: warning[possibly-missing-attribute] Attribute `on_setattr` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2198:20: warning[possibly-missing-attribute] Attribute `alias` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2200:34: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2201:48: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2203:12: warning[possibly-missing-attribute] Attribute `converter` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2203:55: warning[possibly-missing-attribute] Attribute `converter` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2204:35: warning[possibly-missing-attribute] Attribute `converter` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2206:25: warning[possibly-missing-attribute] Attribute `converter` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2208:12: warning[possibly-missing-attribute] Attribute `init` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2210:58: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2220:66: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2231:56: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2241:62: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2252:14: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2254:16: warning[possibly-missing-attribute] Attribute `kw_only` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2266:62: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2274:16: warning[possibly-missing-attribute] Attribute `kw_only` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2281:54: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2299:62: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2315:52: warning[possibly-missing-attribute] Attribute `default` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2317:16: warning[possibly-missing-attribute] Attribute `kw_only` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2329:62: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2335:12: warning[possibly-missing-attribute] Attribute `init` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2336:16: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2337:41: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2373:33: warning[possibly-missing-attribute] Attribute `name` may be missing on object of type `Attribute | Unknown`
- src/attr/_make.py:2373:60: warning[possibly-missing-attribute] Attribute `init` may be missing on object of type `Attribute | Unknown`
+ src/attr/_make.py:1609:29: error[unresolved-attribute] Object of type `Attribute` has no attribute `hash`
+ src/attr/_make.py:1609:48: error[unresolved-attribute] Object of type `Attribute` has no attribute `hash`
+ src/attr/_make.py:1609:67: error[unresolved-attribute] Object of type `Attribute` has no attribute `eq`
+ src/attr/_make.py:1647:16: error[unresolved-attribute] Object of type `Attribute` has no attribute `eq_key`
+ src/attr/_make.py:1648:32: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:1649:35: error[unresolved-attribute] Object of type `Attribute` has no attribute `eq_key`
+ src/attr/_make.py:1651:57: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:1654:62: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2189:12: error[unresolved-attribute] Object of type `Attribute` has no attribute `validator`
+ src/attr/_make.py:2192:21: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2193:26: error[unresolved-attribute] Object of type `Attribute` has no attribute `on_setattr`
+ src/attr/_make.py:2194:13: error[unresolved-attribute] Object of type `Attribute` has no attribute `on_setattr`
+ src/attr/_make.py:2198:20: error[unresolved-attribute] Object of type `Attribute` has no attribute `alias`
+ src/attr/_make.py:2200:34: error[unresolved-attribute] Object of type `Attribute` has no attribute `default`
+ src/attr/_make.py:2201:48: error[unresolved-attribute] Object of type `Attribute` has no attribute `default`
+ src/attr/_make.py:2203:12: error[unresolved-attribute] Object of type `Attribute` has no attribute `converter`
+ src/attr/_make.py:2203:55: error[unresolved-attribute] Object of type `Attribute` has no attribute `converter`
+ src/attr/_make.py:2204:35: error[unresolved-attribute] Object of type `Attribute` has no attribute `converter`
+ src/attr/_make.py:2206:25: error[unresolved-attribute] Object of type `Attribute` has no attribute `converter`
+ src/attr/_make.py:2208:12: error[unresolved-attribute] Object of type `Attribute` has no attribute `init`
+ src/attr/_make.py:2210:58: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2220:66: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2231:56: error[unresolved-attribute] Object of type `Attribute` has no attribute `default`
+ src/attr/_make.py:2241:62: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2252:14: error[unresolved-attribute] Object of type `Attribute` has no attribute `default`
+ src/attr/_make.py:2254:16: error[unresolved-attribute] Object of type `Attribute` has no attribute `kw_only`
+ src/attr/_make.py:2266:62: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2274:16: error[unresolved-attribute] Object of type `Attribute` has no attribute `kw_only`
+ src/attr/_make.py:2281:54: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2299:62: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2315:52: error[unresolved-attribute] Object of type `Attribute` has no attribute `default`
+ src/attr/_make.py:2317:16: error[unresolved-attribute] Object of type `Attribute` has no attribute `kw_only`
+ src/attr/_make.py:2329:62: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2335:12: error[unresolved-attribute] Object of type `Attribute` has no attribute `init`
+ src/attr/_make.py:2336:16: error[unresolved-attribute] Object of type `Attribute` has no attribute `type`
+ src/attr/_make.py:2337:41: error[unresolved-attribute] Object of type `Attribute` has no attribute `type`
+ src/attr/_make.py:2373:33: error[unresolved-attribute] Object of type `Attribute` has no attribute `name`
+ src/attr/_make.py:2373:60: error[unresolved-attribute] Object of type `Attribute` has no attribute `init`
+ src/attr/_make.py:2641:13: error[invalid-assignment] Object of type `type` is not assignable to `&lt;class 'Attribute'&gt;`
+ src/attr/_make.py:3038:11: error[invalid-assignment] Object of type `type` is not assignable to `&lt;class 'Factory'&gt;`
+ src/attr/_make.py:3157:13: error[invalid-assignment] Object of type `type` is not assignable to `&lt;class 'Converter'&gt;`
+ src/attr/_make.py:3278:18: error[not-iterable] Object of type `Unknown | _CountingAttr` may not be iterable
+ src/attr/_version_info.py:86:16: error[unsupported-operator] Operator `&lt;` is not supported between objects of type `list[Unknown] | @Todo | tuple[Unknown, ...]` and `Unknown | tuple[Unknown, ...]`
+ src/attr/validators.py:98:34: error[invalid-argument-type] Argument to function `isinstance` is incorrect: Expected `type | tuple[Divergent, ...]`, found `Unknown | _CountingAttr`
+ src/attr/validators.py:137:16: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:138:53: warning[possibly-missing-attribute] Attribute `pattern` may be missing on object of type `Unknown | _CountingAttr`
+ src/attr/validators.py:206:9: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:240:26: error[unsupported-operator] Operator `in` is not supported between objects of type `Unknown` and `Unknown | _CountingAttr`
+ src/attr/validators.py:342:13: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:345:13: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:396:13: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:400:17: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:402:17: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:468:16: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:544:12: error[unsupported-operator] Operator `&gt;` is not supported between objects of type `int` and `Unknown | _CountingAttr`
+ src/attr/validators.py:573:12: error[unsupported-operator] Operator `&lt;` is not supported between objects of type `int` and `Unknown | _CountingAttr`
+ src/attr/validators.py:602:34: error[invalid-argument-type] Argument to function `issubclass` is incorrect: Expected `type | tuple[Divergent, ...]`, found `Unknown | _CountingAttr`
+ src/attr/validators.py:650:13: error[call-non-callable] Object of type `_CountingAttr` is not callable
+ src/attr/validators.py:651:16: error[invalid-exception-caught] Invalid object caught in an exception handler: Object has type `Unknown | _CountingAttr`
+ src/attr/validators.py:655:17: warning[possibly-missing-attribute] Attribute `format` may be missing on object of type `Unknown | _CountingAttr`
+ src/attr/validators.py:710:18: error[not-iterable] Object of type `Unknown | _CountingAttr` may not be iterable
+ tests/test_make.py:1365:16: warning[possibly-missing-attribute] Attribute `__attrs_attrs__` may be missing on object of type `Unknown | type`
+ tests/test_make.py:1380:16: warning[possibly-missing-attribute] Attribute `__attrs_attrs__` may be missing on object of type `Unknown | type`
+ tests/test_make.py:1468:30: warning[possibly-missing-attribute] Attribute `echo` may be missing on object of type `Unknown | type`
+ tests/test_make.py:1487:25: warning[possibly-missing-attribute] Attribute `__attrs_attrs__` may be missing on object of type `Unknown | type`
+ tests/test_make.py:3051:30: warning[possibly-missing-attribute] Attribute `__match_args__` may be missing on object of type `Unknown | type`
+ tests/test_make.py:3057:22: warning[possibly-missing-attribute] Attribute `__match_args__` may be missing on object of type `Unknown | type`
+ tests/test_make.py:3060:26: warning[possibly-missing-attribute] Attribute `__match_args__` may be missing on object of type `Unknown | type`
- Found 616 diagnostics
+ Found 649 diagnostics

parso (https://github.com/davidhalter/parso)
+ parso/__init__.py:58:26: error[invalid-argument-type] Argument to bound method `parse` is incorrect: Expected `str | bytes`, found `Unknown | None`
- parso/grammar.py:163:27: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
+ parso/grammar.py:199:16: warning[possibly-missing-attribute] Attribute `walk` may be missing on object of type `Unknown | None | Normalizer`
+ parso/grammar.py:203:9: warning[possibly-missing-attribute] Attribute `walk` may be missing on object of type `Unknown | None | Normalizer`
+ parso/grammar.py:204:16: warning[possibly-missing-attribute] Attribute `issues` may be missing on object of type `Unknown | None | Normalizer`
+ parso/pgen2/grammar_parser.py:106:20: error[not-iterable] Object of type `None` is not iterable
+ parso/python/diff.py:423:17: error[not-subscriptable] Cannot subscript object of type `None` with no `__getitem__` method
+ parso/python/diff.py:621:16: warning[possibly-missing-attribute] Attribute `tree_node` may be missing on object of type `Unknown | None`
+ parso/python/diff.py:622:9: warning[possibly-missing-attribute] Attribute `add_tree_nodes` may be missing on object of type `Unknown | None`
+ parso/python/errors.py:783:12: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Unknown | None`
+ parso/python/errors.py:784:26: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Unknown | None`
+ parso/python/errors.py:784:54: warning[possibly-missing-attribute] Attribute `children` may be missing on object of type `Unknown | None`
+ parso/python/errors.py:1166:20: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Unknown | None`
+ parso/python/errors.py:1167:34: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Unknown | None`
+ parso/python/errors.py:1167:62: warning[possibly-missing-attribute] Attribute `children` may be missing on object of type `Unknown | None`
- parso/python/pep8.py:362:17: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Unknown | IndentationNode | None`
+ parso/python/pep8.py:362:17: warning[possibly-missing-attribute] Attribute `type` may be missing on object of type `Unknown | None | IndentationNode`
- parso/python/pep8.py:363:37: warning[possibly-missing-attribute] Attribute `parent` may be missing on object of type `Unknown | IndentationNode | None`
+ parso/python/pep8.py:363:37: warning[possibly-missing-attribute] Attribute `parent` may be missing on object of type `Unknown | None | IndentationNode`
- parso/python/tokenize.py:109:9: error[invalid-assignment] Invalid subscript assignment with key of type `tuple[Unknown, ...]` and value of type `Unknown` on object of type `dict[PythonVersionInfo, TokenCollection]`
+ parso/python/tokenize.py:109:9: error[invalid-assignment] Invalid subscript assignment with key of type `tuple[Unknown, ...]` and value of type `TokenCollection` on object of type `dict[PythonVersionInfo, TokenCollection]`
+ parso/python/tokenize.py:588:31: error[invalid-assignment] Object of type `Pattern[Unknown] | None` is not assignable to `Pattern[Unknown]`
+ parso/python/tree.py:135:21: warning[possibly-missing-attribute] Attribute `token_type` may be missing on object of type `(Unknown &amp; ~None) | NodeOrLeaf`
+ parso/python/tree.py:1129:20: warning[possibly-missing-attribute] Attribute `children` may be missing on object of type `Unknown | NodeOrLeaf`
+ parso/python/tree.py:1130:24: warning[possibly-missing-attribute] Attribute `children` may be missing on object of type `Unknown | NodeOrLeaf`
+ parso/python/tree.py:1131:26: warning[possibly-missing-attribute] Attribute `children` may be missing on object of type `Unknown | NodeOrLeaf`
+ parso/python/tree.py:1149:20: warning[possibly-missing-attribute] Attribute `children` may be missing on object of type `Unknown | NodeOrLeaf`
+ parso/tree.py:447:16: warning[possibly-missing-attribute] Attribute `replace` may be missing on object of type `Unknown | None`
- Found 199 diagnostics
+ Found 219 diagnostics

kornia (https://github.com/kornia/kornia)
+ kornia/feature/dedode/transformer/dinov2.py:317:30: error[invalid-argument-type] Method `__getitem__` of type `Overload[(i: SupportsIndex, /) -&gt; Unknown, (s: slice[Any, Any, Any], /) -&gt; list[Unknown]]` cannot be called with key of type `Literal[&quot;x_norm_clstoken&quot;]` on object of type `list[Unknown]`
- Found 758 diagnostics
+ Found 759 diagnostics

pip (https://github.com/pypa/pip)
+ src/pip/_internal/cli/cmdoptions.py:123:51: error[invalid-argument-type] Argument to function `get_file_content` is incorrect: Expected `PipSession`, found `Self@__enter__ | Unknown`
+ src/pip/_internal/commands/index.py:119:17: error[invalid-argument-type] Argument to bound method `_build_package_finder` is incorrect: Expected `PipSession`, found `Self@__enter__ | Unknown`
+ src/pip/_internal/commands/list.py:245:58: error[invalid-argument-type] Argument to bound method `_build_package_finder` is incorrect: Expected `PipSession`, found `Self@__enter__ | Unknown`
+ src/pip/_internal/index/collector.py:311:9: error[invalid-argument-type] Argument is incorrect: Expected `bytes`, found `(Unknown &amp; ~Literal[False]) | None | (bytes &amp; ~AlwaysFalsy) | Literal[b&quot;&quot;]`
- src/pip/_vendor/cachecontrol/adapter.py:162:39: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- src/pip/_vendor/cachecontrol/serialize.py:35:46: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
+ src/pip/_vendor/cachecontrol/serialize.py:36:45: error[invalid-argument-type] Argument to function `len` is incorrect: Expected `Sized`, found `None | bytes | Unknown`
+ src/pip/_vendor/cachecontrol/serialize.py:146:47: error[invalid-argument-type] Argument to bound method `prepare_response` is incorrect: Expected `Mapping[str, Any]`, found `int | Unknown | None | ... omitted 9 union elements`
+ src/pip/_vendor/distlib/compat.py:1127:22: error[call-non-callable] Object of type `ModuleType` is not callable
+ src/pip/_vendor/distlib/resources.py:196:33: error[not-iterable] Object of type `Unknown | Self@__get__` may not be iterable
+ src/pip/_vendor/distlib/resources.py:196:33: warning[possibly-missing-attribute] Attribute `resources` may be missing on object of type `Unknown | ResourceContainer | Resource`
+ src/pip/_vendor/distlib/resources.py:202:28: warning[possibly-missing-attribute] Attribute `is_container` may be missing on object of type `None | ResourceContainer | Resource | Unknown`
+ src/pip/_vendor/msgpack/fallback.py:540:29: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | Buffer`, found `None | Unknown | int | bytearray`
+ src/pip/_vendor/msgpack/fallback.py:542:23: warning[possibly-missing-attribute] Attribute `decode` may be missing on object of type `None | Unknown | int | bytearray`
+ src/pip/_vendor/msgpack/fallback.py:545:26: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | Buffer`, found `None | Unknown | int | bytearray`
+ src/pip/_vendor/msgpack/fallback.py:548:49: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | Buffer`, found `None | Unknown | int | bytearray`
+ src/pip/_vendor/msgpack/fallback.py:558:48: error[invalid-argument-type] Argument to function `__new__` is incorrect: Expected `Iterable[SupportsIndex] | SupportsIndex | SupportsBytes | Buffer`, found `None | Unknown | int | bytearray`
+ src/pip/_vendor/pkg_resources/__init__.py:2308:28: error[invalid-argument-type] Argument to function `distributions_from_metadata` is incorrect: Expected `str`, found `str | bytes`
+ src/pip/_vendor/pkg_resources/__init__.py:2308:28: error[invalid-argument-type] Argument to function `find_distributions` is incorrect: Expected `str`, found `str | bytes`
+ src/pip/_vendor/pkg_resources/__init__.py:2828:13: error[invalid-assignment] Invalid subscript assignment with key of type `Unknown | str` and value of type `Self@parse | Unknown` on object of type `dict[str, Self@parse_group]`
+ src/pip/_vendor/pkg_resources/__init__.py:2852:13: error[invalid-assignment] Invalid subscript assignment with key of type `str` and value of type `dict[str, Self@parse_group] | Unknown` on object of type `dict[str, dict[str, Self@parse_map]]`
+ src/pip/_vendor/pkg_resources/__init__.py:2941:16: error[unsupported-operator] Operator `&lt;` is not supported between two objects of type `tuple[Unknown | Version, Unknown | int, Unknown | str, Unknown | str | None, (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;], (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;]]`
+ src/pip/_vendor/pkg_resources/__init__.py:2944:16: error[unsupported-operator] Operator `&lt;=` is not supported between two objects of type `tuple[Unknown | Version, Unknown | int, Unknown | str, Unknown | str | None, (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;], (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;]]`
+ src/pip/_vendor/pkg_resources/__init__.py:2947:16: error[unsupported-operator] Operator `&gt;` is not supported between two objects of type `tuple[Unknown | Version, Unknown | int, Unknown | str, Unknown | str | None, (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;], (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;]]`
+ src/pip/_vendor/pkg_resources/__init__.py:2950:16: error[unsupported-operator] Operator `&gt;=` is not supported between two objects of type `tuple[Unknown | Version, Unknown | int, Unknown | str, Unknown | str | None, (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;], (Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[&quot;&quot;]]`
- src/pip/_vendor/pkg_resources/__init__.py:3466:40: error[invalid-argument-type] Argument to bound method `contains` is incorrect: Expected `Version | str`, found `(str &amp; ~Distribution) | (tuple[str, ...] &amp; ~Distribution) | Unknown`
+ src/pip/_vendor/pkg_resources/__init__.py:3466:40: error[invalid-argument-type] Argument to bound method `contains` is incorrect: Expected `Version | str`, found `str | (tuple[str, ...] &amp; ~Distribution) | Unknown`
+ src/pip/_vendor/pygments/lexers/python.py:362:42: error[invalid-argument-type] Argument to function `fstring_rules` is incorrect: Expected `PythonLexer`, found `Any | _TokenType`
+ src/pip/_vendor/pygments/lexers/python.py:363:42: error[invalid-argument-type] Argument to function `fstring_rules` is incorrect: Expected `PythonLexer`, found `Any | _TokenType`
+ src/pip/_vendor/pygments/lexers/python.py:364:45: error[invalid-argument-type] Argument to function `innerstring_rules` is incorrect: Expected `PythonLexer`, found `Any | _TokenType`
+ src/pip/_vendor/pygments/lexers/python.py:365:45: error[invalid-argument-type] Argument to function `innerstring_rules` is incorrect: Expected `PythonLexer`, found `Any | _TokenType`
+ src/pip/_vendor/pygments/lexers/python.py:611:45: error[invalid-argument-type] Argument to function `innerstring_rules` is incorrect: Expected `Python2Lexer`, found `Any | _TokenType`
+ src/pip/_vendor/pygments/lexers/python.py:612:45: error[invalid-argument-type] Argument to function `innerstring_rules` is incorrect: Expected `Python2Lexer`, found `Any | _TokenType`
+ src/pip/_vendor/pygments/sphinxext.py:108:26: warning[possibly-missing-attribute] Attribute `filenames` may be missing on object of type `Unknown | None`
+ src/pip/_vendor/pygments/sphinxext.py:108:48: warning[possibly-missing-attribute] Attribute `alias_filenames` may be missing on object of type `Unknown | None`
+ src/pip/_vendor/pygments/sphinxext.py:111:46: warning[possibly-missing-attribute] Attribute `url` may be missing on object of type `Unknown | None`
+ src/pip/_vendor/requests/models.py:121:26: error[not-iterable] Object of type `None | list[Unknown]` may not be iterable
+ src/pip/_vendor/requests/models.py:155:27: error[not-iterable] Object of type `None | list[Unknown]` may not be iterable
+ src/pip/_vendor/requests/models.py:173:21: error[not-iterable] Object of type `None | list[Unknown]` may not be iterable
+ src/pip/_vendor/requests/models.py:602:17: error[call-non-callable] Object of type `tuple[str, str]` is not callable
- src/pip/_vendor/requests/models.py:935:41: error[invalid-argument-type] Argument to class `str` is incorrect: Expected `str`, found `Unknown | None`
+ src/pip/_vendor/requests/models.py:935:41: error[invalid-argument-type] Argument to class `str` is incorrect: Expected `str`, found `Unknown | None | Literal[&quot;utf-8&quot;]`
+ src/pip/_vendor/requests/sessions.py:80:5: error[no-matching-overload] No overload of bound method `update` matches arguments
+ src/pip/_vendor/requests/utils.py:615:31: error[invalid-argument-type] Argument to class `str` is incorrect: Expected `str`, found `None | Unknown | Literal[&quot;ISO-8859-1&quot;, &quot;utf-8&quot;]`
+ src/pip/_vendor/rich/syntax.py:167:27: error[unsupported-operator] Operator `+` is not supported between objects of type `Literal[&quot;#&quot;]` and `(Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[True]`
+ src/pip/_vendor/rich/syntax.py:168:29: error[unsupported-operator] Operator `+` is not supported between objects of type `Literal[&quot;#&quot;]` and `(Unknown &amp; ~AlwaysFalsy) | (str &amp; ~AlwaysFalsy) | Literal[True]`
+ src/pip/_vendor/rich/syntax.py:169:21: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `bool | None`, found `Unknown | str | None | bool`
+ src/pip/_vendor/rich/syntax.py:170:21: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `bool | None`, found `Unknown | str | None | bool`
+ src/pip/_vendor/rich/syntax.py:171:21: error[invalid-argument-type] Argument to bound method `__init__` is incorrect: Expected `bool | None`, found `Unknown | str | None | bool`
- src/pip/_vendor/urllib3/connectionpool.py:785:21: warning[possibly-missing-attribute] Attribute `proxy` may be missing on object of type `None | Unknown`
+ src/pip/_vendor/urllib3/connectionpool.py:785:21: warning[possibly-missing-attribute] Attribute `proxy` may be missing on object of type `None | Unknown | HTTPConnection`
- src/pip/_vendor/urllib3/connectionpool.py:786:21: warning[possibly-missing-attribute] Attribute `proxy` may be missing on object of type `None | Unknown`
+ src/pip/_vendor/urllib3/connectionpool.py:786:21: warning[possibly-missing-attribute] Attribute `proxy` may be missing on object of type `None | Unknown | HTTPConnection`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:136:5: warning[possibly-missing-attribute] Attribute `SecItemImport` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:146:5: warning[possibly-missing-attribute] Attribute `SecItemImport` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:148:5: warning[possibly-missing-attribute] Attribute `SecCertificateGetTypeID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:149:5: warning[possibly-missing-attribute] Attribute `SecCertificateGetTypeID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:151:5: warning[possibly-missing-attribute] Attribute `SecIdentityGetTypeID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:152:5: warning[possibly-missing-attribute] Attribute `SecIdentityGetTypeID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:154:5: warning[possibly-missing-attribute] Attribute `SecKeyGetTypeID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:155:5: warning[possibly-missing-attribute] Attribute `SecKeyGetTypeID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:157:5: warning[possibly-missing-attribute] Attribute `SecCertificateCreateWithData` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:158:5: warning[possibly-missing-attribute] Attribute `SecCertificateCreateWithData` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:160:5: warning[possibly-missing-attribute] Attribute `SecCertificateCopyData` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:161:5: warning[possibly-missing-attribute] Attribute `SecCertificateCopyData` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:163:5: warning[possibly-missing-attribute] Attribute `SecCopyErrorMessageString` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:164:5: warning[possibly-missing-attribute] Attribute `SecCopyErrorMessageString` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:166:5: warning[possibly-missing-attribute] Attribute `SecIdentityCreateWithCertificate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:171:5: warning[possibly-missing-attribute] Attribute `SecIdentityCreateWithCertificate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:173:5: warning[possibly-missing-attribute] Attribute `SecKeychainCreate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:181:5: warning[possibly-missing-attribute] Attribute `SecKeychainCreate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:183:5: warning[possibly-missing-attribute] Attribute `SecKeychainDelete` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:184:5: warning[possibly-missing-attribute] Attribute `SecKeychainDelete` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:186:5: warning[possibly-missing-attribute] Attribute `SecPKCS12Import` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:191:5: warning[possibly-missing-attribute] Attribute `SecPKCS12Import` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:198:5: warning[possibly-missing-attribute] Attribute `SSLSetIOFuncs` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:199:5: warning[possibly-missing-attribute] Attribute `SSLSetIOFuncs` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:201:5: warning[possibly-missing-attribute] Attribute `SSLSetPeerID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:202:5: warning[possibly-missing-attribute] Attribute `SSLSetPeerID` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:204:5: warning[possibly-missing-attribute] Attribute `SSLSetCertificate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:205:5: warning[possibly-missing-attribute] Attribute `SSLSetCertificate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:207:5: warning[possibly-missing-attribute] Attribute `SSLSetCertificateAuthorities` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:208:5: warning[possibly-missing-attribute] Attribute `SSLSetCertificateAuthorities` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:210:5: warning[possibly-missing-attribute] Attribute `SSLSetConnection` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:211:5: warning[possibly-missing-attribute] Attribute `SSLSetConnection` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:213:5: warning[possibly-missing-attribute] Attribute `SSLSetPeerDomainName` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:214:5: warning[possibly-missing-attribute] Attribute `SSLSetPeerDomainName` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:216:5: warning[possibly-missing-attribute] Attribute `SSLHandshake` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:217:5: warning[possibly-missing-attribute] Attribute `SSLHandshake` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:219:5: warning[possibly-missing-attribute] Attribute `SSLRead` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:220:5: warning[possibly-missing-attribute] Attribute `SSLRead` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:222:5: warning[possibly-missing-attribute] Attribute `SSLWrite` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:223:5: warning[possibly-missing-attribute] Attribute `SSLWrite` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:225:5: warning[possibly-missing-attribute] Attribute `SSLClose` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:226:5: warning[possibly-missing-attribute] Attribute `SSLClose` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:228:5: warning[possibly-missing-attribute] Attribute `SSLGetNumberSupportedCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:229:5: warning[possibly-missing-attribute] Attribute `SSLGetNumberSupportedCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:231:5: warning[possibly-missing-attribute] Attribute `SSLGetSupportedCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:236:5: warning[possibly-missing-attribute] Attribute `SSLGetSupportedCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:238:5: warning[possibly-missing-attribute] Attribute `SSLSetEnabledCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:243:5: warning[possibly-missing-attribute] Attribute `SSLSetEnabledCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:245:5: error[unresolved-attribute] Unresolved attribute `argtype` on type `_NamedFuncPointer`.
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:245:5: warning[possibly-missing-attribute] Attribute `SSLGetNumberEnabledCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:246:5: warning[possibly-missing-attribute] Attribute `SSLGetNumberEnabledCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:248:5: warning[possibly-missing-attribute] Attribute `SSLGetEnabledCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:253:5: warning[possibly-missing-attribute] Attribute `SSLGetEnabledCiphers` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:255:5: warning[possibly-missing-attribute] Attribute `SSLGetNegotiatedCipher` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:256:5: warning[possibly-missing-attribute] Attribute `SSLGetNegotiatedCipher` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:258:5: warning[possibly-missing-attribute] Attribute `SSLGetNegotiatedProtocolVersion` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:262:5: warning[possibly-missing-attribute] Attribute `SSLGetNegotiatedProtocolVersion` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:264:5: warning[possibly-missing-attribute] Attribute `SSLCopyPeerTrust` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:265:5: warning[possibly-missing-attribute] Attribute `SSLCopyPeerTrust` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:267:5: warning[possibly-missing-attribute] Attribute `SecTrustSetAnchorCertificates` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:268:5: warning[possibly-missing-attribute] Attribute `SecTrustSetAnchorCertificates` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:270:5: error[unresolved-attribute] Unresolved attribute `argstypes` on type `_NamedFuncPointer`.
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:270:5: warning[possibly-missing-attribute] Attribute `SecTrustSetAnchorCertificatesOnly` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:271:5: warning[possibly-missing-attribute] Attribute `SecTrustSetAnchorCertificatesOnly` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:273:5: warning[possibly-missing-attribute] Attribute `SecTrustEvaluate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:274:5: warning[possibly-missing-attribute] Attribute `SecTrustEvaluate` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:276:5: warning[possibly-missing-attribute] Attribute `SecTrustGetCertificateCount` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:277:5: warning[possibly-missing-attribute] Attribute `SecTrustGetCertificateCount` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:279:5: warning[possibly-missing-attribute] Attribute `SecTrustGetCertificateAtIndex` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:280:5: warning[possibly-missing-attribute] Attribute `SecTrustGetCertificateAtIndex` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:282:5: warning[possibly-missing-attribute] Attribute `SSLCreateContext` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:287:5: warning[possibly-missing-attribute] Attribute `SSLCreateContext` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:289:5: warning[possibly-missing-attribute] Attribute `SSLSetSessionOption` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:290:5: warning[possibly-missing-attribute] Attribute `SSLSetSessionOption` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:292:5: warning[possibly-missing-attribute] Attribute `SSLSetProtocolVersionMin` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:293:5: warning[possibly-missing-attribute] Attribute `SSLSetProtocolVersionMin` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:295:5: warning[possibly-missing-attribute] Attribute `SSLSetProtocolVersionMax` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:296:5: warning[possibly-missing-attribute] Attribute `SSLSetProtocolVersionMax` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:299:9: warning[possibly-missing-attribute] Attribute `SSLSetALPNProtocols` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:300:9: warning[possibly-missing-attribute] Attribute `SSLSetALPNProtocols` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:305:5: warning[possibly-missing-attribute] Attribute `SecCopyErrorMessageString` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:306:5: warning[possibly-missing-attribute] Attribute `SecCopyErrorMessageString` may be missing on object of type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:308:5: error[invalid-assignment] Object of type `type[_CFunctionType]` is not assignable to attribute `SSLReadFunc` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:309:5: error[invalid-assignment] Object of type `type[_CFunctionType]` is not assignable to attribute `SSLWriteFunc` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:310:5: error[invalid-assignment] Object of type `type[_Pointer[c_void_p]]` is not assignable to attribute `SSLContextRef` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:311:5: error[invalid-assignment] Object of type `&lt;class 'c_uint32'&gt;` is not assignable to attribute `SSLProtocol` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:312:5: error[invalid-assignment] Object of type `&lt;class 'c_uint32'&gt;` is not assignable to attribute `SSLCipherSuite` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:313:5: error[invalid-assignment] Object of type `type[_Pointer[c_void_p]]` is not assignable to attribute `SecIdentityRef` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:314:5: error[invalid-assignment] Object of type `type[_Pointer[c_void_p]]` is not assignable to attribute `SecKeychainRef` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:315:5: error[invalid-assignment] Object of type `type[_Pointer[c_void_p]]` is not assignable to attribute `SecTrustRef` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:316:5: error[invalid-assignment] Object of type `&lt;class 'c_uint32'&gt;` is not assignable to attribute `SecTrustResultType` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:317:5: error[invalid-assignment] Object of type `&lt;class 'c_uint32'&gt;` is not assignable to attribute `SecExternalFormat` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:318:5: error[invalid-assignment] Object of type `&lt;class 'c_int32'&gt;` is not assignable to attribute `OSStatus` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:320:5: error[invalid-assignment] Object of type `_Pointer[c_void_p]` is not assignable to attribute `kSecImportExportPassphrase` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:321:9: error[invalid-argument-type] Argument to bound method `in_dll` is incorrect: Expected `CDLL`, found `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:323:5: error[invalid-assignment] Object of type `_Pointer[c_void_p]` is not assignable to attribute `kSecImportItemIdentity` on type `CDLL | None`
+ src/pip/_vendor/urllib3/contrib/_securetransport/bindings.py:324:9: error[invalid-argument-type] Argument to bound method `in_dll` is 

... (truncated 65012 lines) ...
</code></pre>
</details>

<details>
<summary>Memory usage changes were detected when running on open source projects</summary>

<pre><code class="language-diff">trio (https://github.com/python-trio/trio)
-     struct metadata = ~10MB
+     struct metadata = ~11MB
-     struct fields = ~11MB
+     struct fields = ~12MB
-     memo fields = ~108MB
+     memo fields = ~113MB

prefect (https://github.com/PrefectHQ/prefect)
-     memo metadata = ~167MB
+     memo metadata = ~176MB


</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-04-13 07:35</div>
            <div class="timeline-body"><p>Most of the changes detected by mypy_primer appear to be due to ill-typed code errors now being caught correctly.</p>
<p>Code like the following now produces false positive warnings, but this may be resolved by type narrowing of the instance attributes, which I'm currently working on as a separate issue.</p>
<pre><code class="language-python">from typing import reveal_type

class C:
    def __init__(self):
        self.x: int = 1

class D:
    def __init__(self):
        self.c: C | None = None

def get_d():
    return D()

d = get_d()
d.c = C()
# TODO: no error
# error: [possibly-unbound-attribute] &quot;Attribute `x` on type `C | None` is possibly unbound&quot;
reveal_type(d.c.x)  # revealed: int
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-04-13 14:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-04-14 07:30</div>
            <div class="timeline-body"><p>Thank you for looking into this!</p>
<blockquote>
<p>but this may be resolved by type narrowing of the instance attributes, which I'm currently working on as a separate issue</p>
</blockquote>
<p>I'm assuming you're talking about https://github.com/astral-sh/ty/issues/164? Good to know that you are already working on this, because I planned to do that this week :smile:. I think it would be great to work on this first. Narrowing on attribute expressions will lead to a large reduction in false positives. And it seems like it would help us evaluate the ecosystem changes in this PR more clearly, if we implement narrowing on attribute assignments first.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-04-15 16:55</div>
            <div class="timeline-body"><p>If a function contains a yield expression, i.e. if it is a generator, current type inference is incorrect. But supporting this requires solving another issues, so I will leave it as a TODO for now.</p>
<p>As for return type inference for normal functions, I think the work is completed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review request for @AlexWaygood removed by @AlexWaygood on 2025-04-15 17:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] infer function's return type" to "[ty] infer function's return type" by @MichaReiser on 2025-05-08 16:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-09 00:44</div>
            <div class="timeline-body"><p>Sorry that I haven't gotten around to reviewing this PR yet. There's just been a lot to do, and providing this feature is lower on my priority list than some other features. But I realize that places a burden on you to keep it up to date with (rapidly changing) main branch. But I will try to find time to review it soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:560 on 2025-05-22 22:16</div>
            <div class="timeline-body"><p>This should be an invalid-override error (if we detected invalid overrides, which we don't yet). The base method accepts an argument of any type; this method accepts only ints.</p>
<p>I think that is fixable by giving <code>T</code> an upper bound above in the base method: <code>def g[T: int]</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:330 on 2025-05-22 22:18</div>
            <div class="timeline-body"><p>These results are unsound; we would allow the override of <code>D.g</code> over <code>C.g</code> only because of the lack of return annotation on <code>D.g</code>, but the return type we infer for <code>D.g</code> creates a Liskov violation: <code>int</code> is not a subtype of <code>Literal[1]</code>.</p>
<p>I think if we infer a return type for a method which is not assignable to the return types of any overridden method, we should emit an invalid-override diagnostic on the overriding method. (This can be a TODO, doesn't have to be implemented in this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:344 on 2025-05-22 22:21</div>
            <div class="timeline-body"><p>We could also have a TODO (or implement) that if <code>H</code> were final we could safely infer <code>Never</code> as its return type.</p>
<pre><code class="language-suggestion"># We can only reveal `Literal[2]` here, not `Never`, because of potential
# subclasses of `H`, which are bound by the annotated return types of
# `F.f` and `G.f`, but are not bound by our inference on `H.f`.
reveal_type(H().f())  # revealed: Literal[2]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4243 on 2025-05-22 22:46</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    /// Returns the inferred return type of `self` if it is a function literal / bound method.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-22 22:56</div>
            <div class="timeline-body"><p>Partial review here; plane is landing now so submitting the comments I have. Will come back to this later.</p>
<p>Thank you for working on this, and sorry for the slow review! It's a very useful feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4318 on 2025-06-10 22:41</div>
            <div class="timeline-body"><p>naming nit: functions are verbs (and we prefer <code>type</code> over <code>ty</code>), let's name this callback <code>infer_return_type</code> not <code>inferred_return_ty</code> (and same for all similar locations)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:597 on 2025-06-10 22:48</div>
            <div class="timeline-body"><p>On second look, I think we should have a TODO here that this should be an invalid inheritance error (when we enforce Liskov), because <code>F.f</code> is not assignable to <code>G.f</code>. This matches what both <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=168022fc3037fe95cfacb39af9f54a7b">mypy</a> and <a href="https://pyright-play.net/?strict=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAySMApiAIYA2AUNQMaXkDOTUAYgFzVQ9QAmJYFGAAKJiUrAAlFAC0APkLEyVANoBGADRQATAF0uvI1BAkYAVxAoo62g2asA4od4Cho8ZJkKlpCpVUdbQBmA25jHlMLKyhgu0YWKAAJETZtRykXHgQHIA">pyright</a> do, and I think it's correct: the MRO of <code>H</code> will be serialized with <code>F</code> below <code>G</code>, therefore <code>F.f</code> must be assignable to <code>G.f</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:354 on 2025-06-10 22:49</div>
            <div class="timeline-body"><p>And given the above, I think this can just reveal <code>Literal[1, 2]</code> (that is, the return type of <code>F.f</code>). If we enforce Liskov correctly, we don't need to do any intersecting, we can just look for the nearest <code>f</code> in the MRO, which will simplify the implementation a lot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6986 on 2025-06-10 22:50</div>
            <div class="timeline-body"><p>Given the above comments on the tests, I think we don't need this method -- it can be replaced by a simple linear MRO lookup.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-06-10 22:51</div>
            <div class="timeline-body"><p>Ok, reviewed this again (and more fully). I think it's pretty close, but we can simplify the handling of multiple inheritance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-06-21 06:15</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a></h2>
<h3>Merging #17371 will <strong>degrade performance by 39.89%</strong></h3>
<p><sub>Comparing <code>mtshiba:infer-return-type</code> (f5e5165) with <code>main</code> (f619783)</sub></p>
<h3>Summary</h3>
<p><code> 4</code> regressions<br />
<code> 48</code> untouched</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?utm_source=github&amp;utm_medium=comment&amp;utm_content=acknowledge">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
<h3>Benchmarks breakdown</h3>
<p>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Efficiency |
| --- | ---- | --------- | ------ | ------ | ---------- |
|  | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Asympy&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>sympy</code></a> | 52.1 s | 86.6 s | -39.89% |
|  | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Apandas&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>pandas</code></a> | 64.8 s | 68.5 s | -5.51% |
|  | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Afreqtrade&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>freqtrade</code></a> | 8.1 s | 8.5 s | -5.26% |
|  | Simulation | <a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?uri=crates%2Fruff_benchmark%2Fbenches%2Fty.rs%3A%3Aproject%3A%3Aattrs%3A%3Aproject%3A%3Aattrs&amp;runnerMode=Instrumentation&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>attrs</code></a> | 436.2 ms | 498.8 ms | -12.54% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-06-23 03:37</div>
            <div class="timeline-body"><p>Since ty has type inference by fixed-point iteration, I thought that this PR would be able to infer the return type for recursive functions without any additional work. But, it seems that this is incorrect in some cases.</p>
<pre><code class="language-python">def divergent(value):
    if type(value) is tuple:
        return (divergent(value[0]),)
    else:
        return None
</code></pre>
<p>The return type inference for this function diverges because it becomes <code>tuple[tuple[tuple[...] | None] | None] | None</code>. We need to detect and suppress this kind of divergence.</p>
<p>A formally complete solution to the problem is to synthesize a recursive type, that is, to infer it as follows:</p>
<pre><code class="language-python">type NestedTuple[T] = T | tuple[NestedTuple[T]]

def divergent[T](value: NestedTuple[T]) -&gt; NestedTuple[None]:
    if type(value) is tuple:
        return (divergent(value[0]),)
    else:
        return None
</code></pre>
<p>I'm not sure if this is actually possible in Python's type system. ML languages provide complete type inference, including for recursive functions, but it may only be possible due to the nature of the lack of narrowing and subtyping.</p>
<p>So a practical solution would be to detect unstoppable recursion at some point and make the resulting type some kind of gradual type.</p>
<p>This is still troublesome, simply stopping the recursion at some point and falling back to <code>Unknown</code> will still not allow a fixed point to be reached (in the case of a divergent type, the next revision will end up with a type like <code>tuple[Unknown] | None</code>).
Also, functions with many <code>return</code>s will cause the resulting union type to grow explosively within cycles, so if the recursion is not detected within the first few cycles, a significant amount of time/memory will be consumed.</p>
<p>One approach I'm thinking of is to classify recursive functions as divergent / non-divergent (such as <code>fibonacci/even/odd</code>) and monitor them with <code>TypeInferenceBuilder</code>. If the former is detected, replace the divergent part of the union of the function's return type with <code>Unknown</code> in both <code>Type::infer_return_type</code> and <code>TypeInference::infer_return_type</code>. This attempts to discover divergence syntactically.</p>
<p>Another approach is to limit not only the number of elements (= &quot;width&quot;) but also the &quot;depth&quot; when building union types.
We currently limit the maximum number of literals a union type can have to 200. This is mainly for an optimization, but it also helps to prevent union types from diverging. So what about limiting the depth of a union type as well? (or limit the total number of types in a union type  depth * width)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-23 09:09</div>
            <div class="timeline-body"><p>This PR seems to blow up the runtime for the large wall-time benchmark.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-06-23 14:12</div>
            <div class="timeline-body"><blockquote>
<p>This PR seems to blow up the runtime for the large wall-time benchmark.</p>
</blockquote>
<p>I suspect this is caused by an exploding union type when trying to infer the return type of a divergent recursive function.</p>
<p>For example, this function is causing a hang: https://github.com/quora/asynq/blob/1bf4f7b5596401000c8db92a5e08a667d11092b2/asynq/async_task.py#L427-L471</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-02 17:33</div>
            <div class="timeline-body"><p>I think the issues we run into here on some recursive functions are closely related to the existing issues we have with recursive type aliases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @mtshiba on 2025-07-07 11:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-07-07 11:42</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p> ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p> ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:252 on 2025-07-07 14:51</div>
            <div class="timeline-body"><p>It's a bit unfortunate that we can't infer <code>bool</code> here, but pyright gives the same result.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/resources/primer/bad.txt</code>:23 on 2025-07-07 14:54</div>
            <div class="timeline-body"><p>When I checked locally, no stack overflow occurred in a single thread (it can also be confirmed that there was no stack overflow in ty_walltime).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-07-07 14:57</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_WALLTIME_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?runnerMode=WallTime">CodSpeed WallTime Performance Report</a></h2>
<h3>Merging #17371 will <strong>degrade performances by 32.81%</strong></h3>
<p><sub>Comparing <code>mtshiba:infer-return-type</code> (706eff8) with <code>main</code> (edeb458)</sub></p>
<h3>Summary</h3>
<p><code> 2</code> regressions<br />
<code> 6</code> untouched</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/mtshiba%3Ainfer-return-type?runnerMode=WallTime">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
|  | <code>large[sympy]</code> | 44.1 s | 65.6 s | -32.81% |
|  | <code>medium[pandas]</code> | 32.5 s | 34 s | -4.19% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-07-07 14:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ruff_benchmark/benches/ty_walltime.rs</code>:202 on 2025-07-07 15:05</div>
            <div class="timeline-body"><p>The number of errors in the sympy checks has increased from about 10000 to 70000. The degradation of the benchmark is likely due to an explosion in the number of errors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-07-07 15:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-07-07 15:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:368 on 2025-07-22 02:16</div>
            <div class="timeline-body"><p>I think what we reveal here is not super important, since it's the result of an invalid override, but it is important that we not reveal an unspecialized <code>T</code> here. If anything we could just fall back to <code>Unknown</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/narrow/type.md</code>:145 on 2025-07-22 02:20</div>
            <div class="timeline-body"><p>Maybe let's have the custom <code>type()</code> function imported from a stub, so we can keep the clear original intent of the test here, without RTI making it more confusing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/primer/bad.txt</code>:23 on 2025-07-22 02:21</div>
            <div class="timeline-body"><p>I would really prefer to see if we can eliminate these stack overflows before we land this. Have you looked at stack traces? Do you know what we are doing when we stack overflow?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-07-22 02:31</div>
            <div class="timeline-body"><p>The behavior here is looking pretty good to me, overall. Thanks for your continued work on it!</p>
<p>The cycle-detection by manually maintaining a stack of function scopes we are inferring is interesting; I've considered something similar for recursive type aliases, but I've been trying to avoid it. I need to think about that a bit more -- it seems like it can introduce non-determinism, depending on what call we try to infer first?</p>
<p>I'm hesitant to land this while it introduces new stack overflows.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2025-07-28 09:10</div>
            <div class="timeline-body"><p>Based on Carl's feedback</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-08-01 18:06</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests </p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-08-04 17:25</div>
            <div class="timeline-body"><blockquote>
<p>The cycle-detection by manually maintaining a stack of function scopes we are inferring is interesting; I've considered something similar for recursive type aliases, but I've been trying to avoid it. I need to think about that a bit more -- it seems like it can introduce non-determinism, depending on what call we try to infer first?</p>
</blockquote>
<p>As you point out, this change definitely introduces non-determinism that affects the inference results, and I strongly feel that we should look for an alternative way. (I confirmed that even without stack overflows, the number of errors in mypy_primer results fluctuates each time during multi-threaded execution. If I understand correctly, salsa assumes that query functions are pure, and having manual call stack breaks this assumption. This must be the cause of the non-determinism.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-08-04 17:48</div>
            <div class="timeline-body"><p>The out of bound <code>CallStack</code> without a proper equality also breaks salsa caching.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @carljm on 2025-08-06 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-06 21:26</div>
            <div class="timeline-body"><p>Marking this draft for now; please mark ready when its ready for review again. (This just helps streamline my notifications workflow.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7031 on 2025-09-08 07:09</div>
            <div class="timeline-body"><p>We now introduce the <code>Divergent</code> type for function return type inference, but I think this should also help suppress other divergent type inference.
For example, the inference of this code currently causes a panic. This can also be suppressed with <code>Divergent</code>:</p>
<pre><code class="language-python">class C:
    def f(self, x: &quot;C&quot;):
        self.x = (x.x, None)

c = C()
reveal_type(c.x)  # should be: tuple[Divergent, None]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:311 on 2025-09-08 08:01</div>
            <div class="timeline-body"><p>In the current implementation, return type inference is performed when the function is actually called, but it is also possible to calculate the return type when obtaining the signature of the function.
This would make a difference, for example, when using a function as a higher-order function.</p>
<pre><code class="language-python">reveal_type(f)  # current: def f() -&gt; Unknown
reveal_type(f)  # should be?: def f() -&gt; Literal[1]
</code></pre>
<p>The reasons for currently choosing the former are as follows:</p>
<ul>
<li>There is a question about whether the return type not explicitly specified in the function should be exposed in the signature (pyright does expose it).</li>
<li>There are many changes, such as the change in the behavior of <code>CallableTypeOf</code> (this is less important than the first reason).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-09-08 09:26</div>
            <div class="timeline-body"><p>The causes of the false positives reported by mypy_primer are as follows:</p>
<h2>incomplete decorator support (sympy)</h2>
<p>The arithmetic operations on the <code>Expr</code> class are not working correctly. Decorated function inference is not supported yet.</p>
<p>https://github.com/sympy/sympy/blob/5bb8ffb0dd2d21af10d2fa3c0a3710bba4c11d76/sympy/core/expr.py#L249-L252</p>
<h2>submodule resolution issue (scrapy)</h2>
<p>The <code>scrapy.signals</code> module is being interpreted as a <code>Tuple[Unknown, Unknown, Unknown]</code> type. This is likely because <code>__getattr__</code> defined in <code>scrapy/__init__.py</code> returns a three-element tuple. ~~However, it is unclear to me why attribute resolution via <code>__getattr__</code> takes precedence due to function return type inference.~~
Previously, <code>__getattr__</code> defined in the module did not specify a return type, so <code>scrapy.signals</code> was interpreted as <code>Unknown</code>, but now it recognizes that <code>__getattr__</code> returns a tuple, so an error occurs.</p>
<p>This may be related to https://github.com/astral-sh/ty/issues/1053</p>
<h2>others</h2>
<p>The following errors are consistent with the current Python type spec.</p>
<ul>
<li>implicit overloading
For example, a function like this:</li>
</ul>
<pre><code class="language-python">def f(type):
    if type is int:
        return 1
    elif type is str:
        return &quot;a&quot;

reveal_type(f(int)) # revealed: Literal[1, &quot;a&quot;] | None
f(int) + 1 # error
</code></pre>
<ul>
<li><p><code>__slots__</code> (attrs)
Attributes defined with <code>__slots__</code> are reported as unresolved.</p>
</li>
<li><p><code>setattr</code> (sympy, etc.)
Attributes set with <code>setattr</code> are reported as unresolved. I think it would be possible in principle to make attributes set with a literal string be recognized as class attributes, but no other type checker does this.</p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-09-08 10:15</div>
            <div class="timeline-body"><p>The main remaining concern is performance. According to the codspeed report, sympy's check time has worsened by about 30%. But I believe this is a necessary trade-off.</p>
<p>I believe this is due to an increase in the number of checks, that is, there is a cost to addressing errors/inferences that have been overlooked by <code>Unknown</code>. In fact, the number of errors reported in sympy has increased from about 10,000 to about 70,000 (for reference, pyright reports approximately 35,000 errors).</p>
<p>Here are the local measurements of the sympy check times for each type checker:</p>
<p>ty(main):</p>
<pre><code>$ hyperfine -i &quot;ty check&quot;

Benchmark 1: ty check
  Time (mean  ):      1.901 s   0.118 s    [User: 20.211 s, System: 3.641 s]
  Range (min  max):    1.799 s   2.188 s    10 runs
</code></pre>
<p>ty(#17371):</p>
<pre><code>$ hyperfine -i &quot;ty check&quot;

Benchmark 1: ty check
  Time (mean  ):      7.290 s   1.341 s    [User: 28.048 s, System: 3.558 s]
  Range (min  max):    5.232 s   9.058 s    10 runs
</code></pre>
<p>pyright:</p>
<pre><code>$ hyperfine -i &quot;pyright&quot;

Benchmark 1: pyright
  Time (mean  ):     118.239 s   7.783 s    [User: 163.368 s, System: 4.845 s]
  Range (min  max):   110.686 s  139.539 s    10 runs
</code></pre>
<p>mypy:</p>
<pre><code>$ hyperfine -i &quot;mypy -p sympy --no-incremental&quot;

Benchmark 1: mypy -p sympy --no-incremental
  Time (mean  ):     35.555 s   2.398 s    [User: 31.747 s, System: 3.255 s]
  Range (min  max):   33.484 s  39.311 s    10 runs
</code></pre>
<p>mypy(check-untyped-defs):</p>
<pre><code>$ hyperfine -i &quot;mypy -p sympy --no-incremental --check-untyped-defs&quot;

Benchmark 1: mypy -p sympy --no-incremental --check-untyped-defs
  Time (mean  ):     69.795 s   0.740 s    [User: 66.414 s, System: 2.764 s]
  Range (min  max):   68.843 s  70.830 s    10 runs
</code></pre>
<p>pyright is generally considered faster than mypy, but its inferiority in sympy's inspection time suggests that return type inference and its impact are heavy in some cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-08 10:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @mtshiba on 2025-09-08 10:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-09-08 12:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/corpus/divergent.py</code>:1 on 2025-09-09 00:17</div>
            <div class="timeline-body"><p>The cases in this file look like cases that would be better to have as mdtests than just corpus tests?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/diagnostics/semantic_syntax_errors.md</code>:63 on 2025-09-09 00:19</div>
            <div class="timeline-body"><p>Same as above.</p>
<pre><code class="language-suggestion">async def elements(n):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/diagnostics/semantic_syntax_errors.md</code>:21 on 2025-09-09 00:20</div>
            <div class="timeline-body"><p>It's fine if async generator type inference support is a TODO, but the &quot;semantic syntax errors&quot; test file doesn't seem like the right place to record that TODO (better to have a failing test with TODO in the return type inference tests), and I don't understand why we need to add the explicit <code>-&gt; Unknown</code> annotation here (the test seems to pass without it.)</p>
<pre><code class="language-suggestion">async def elements(n):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/diagnostics/semantic_syntax_errors.md</code>:341 on 2025-09-09 00:20</div>
            <div class="timeline-body"><pre><code class="language-suggestion">async def elements(n):
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:311 on 2025-09-09 00:21</div>
            <div class="timeline-body"><p>It seems fine to leave this for a future PR if it results in a lot of test changes needed, but I think we should probably be consistent here. If we will infer the return type of a call to <code>f()</code> as <code>Literal[1]</code>, then we should also consider its signature to have a return type of <code>Literal[1]</code>. So I think this could be upgraded to a TODO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/function/return_type.md</code>:481 on 2025-09-09 00:37</div>
            <div class="timeline-body"><p>This doesn't seem to match what is implemented.</p>
<p>I don't think it's critical what we do in case of error (except of course that we should throw an error, which is captured above.) So I think this line could probably just be deleted?</p>
<pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:6568 on 2025-09-09 00:53</div>
            <div class="timeline-body"><p>Can this method be replaced by using the existing <code>any_over_type</code> function, which searches a type given any predicate function?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7031 on 2025-09-09 00:59</div>
            <div class="timeline-body"><p>This is really useful and I think we have a lot of other urgent needs for it. Do you think it could be worthwhile to extract this type as a separate PR in which we make use of it in a simpler case (like the one you show here), to simplify review?</p>
<p>I do think this PR for function return-type inference is close, and it will be great to land it soon, but there are a few things here we may still want to iterate on, and it would be great to have access to the <code>Divergent</code> type as soon as possible to help with addressing other recursion panics comprehensively.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-09 01:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-09 04:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7031 on 2025-09-09 04:35</div>
            <div class="timeline-body"><p>OK, I created #20312.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-09 12:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/resources/corpus/divergent.py</code>:1 on 2025-09-09 12:04</div>
            <div class="timeline-body"><p>These cases are essentially subtle variations of functions already described in <a href="https://github.com/mtshiba/ruff/blob/4f68d19e4e213720891a3089b44f64e958060da3/crates/ty_python_semantic/resources/mdtest/function/return_type.md#free-function">return_type.md</a> or things that cause panics discovered during debugging, added to prevent regressions rather than to explain ty's behavior, so they may be a bit verbose to describe in mdtest.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-09 13:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/resources/mdtest/diagnostics/semantic_syntax_errors.md</code>:21 on 2025-09-09 13:05</div>
            <div class="timeline-body"><p>This appears to be a temporary workaround that was necessary before adding the handling to intentionally set the return type of async functions to <code>Unknown</code>. This annotation is indeed no longer needed, and I have added to <code>return_type.md</code> that return type inference for async functions is a TODO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-09-09 17:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-09-11 10:10</div>
            <div class="timeline-body"><p>Wait, we might be able to get a better result.</p>
<p>Currently, we converge the return type by replacing &quot;types containing <code>Divergent</code> types&quot; (let's call these recursive types) with <code>Divergent</code> types. However, this is a bit unsatisfactory because it loses some of the structure of the return type.</p>
<p>So instead, we replace the recursive type contained within the &quot;type containing a recursive type&quot; (let's call this a nested recursive type) with <code>Divergent</code> types.</p>
<p>For example, consider the following function:</p>
<pre><code class="language-python">def f(n):
    if n == 0:
        return 0
    elif n % 2 == 0:
        return [f(n-1)]
    else:
        return (f(n-1),)
</code></pre>
<p>The return type of this function is <code> X. Literal[0] | list[X] | tuple[X]</code> according to recursive type theory.
The type variable <code>X</code> in this recursive type corresponds to our <code>Divergent</code>.</p>
<p>At the 0th iteration, we obtain <code>Literal[0] | tuple[Divergent] | list[Divergent]</code>. We leave the recursive type as is.
At the 1st iteration, we obtain <code>Literal[0] | tuple[Literal[0] | tuple[Divergent] | list[Divergent]] | list[Literal[0] | tuple[Divergent] | list[Divergent]]</code>. Since this is a nested recursive type, we will &quot;lower&quot; it.</p>
<pre><code>Literal[0] | tuple[Literal[0] | tuple[Divergent] | list[Divergent]] | list[Literal[0] | tuple[Divergent] | list[Divergent]]
=&gt; Literal[0] | tuple[Literal[0] | Divergent | Divergent] | list[Literal[0] | Divergent | Divergent]
=&gt; Literal[0] | tuple[Literal[0] | Divergent] | list[Literal[0] | Divergent]
=&gt; Literal[0] | tuple[Divergent] | list[Divergent]
</code></pre>
<p>Since this is the same as the value from the 0th iteration, it is converged. We have obtained a type with the exact same structure as the recursive type!</p>
<p>The final conversion can be achieved with the following rule: <code>G[T | Divergent] = G[Divergent]</code>
This is allowed because <code>T</code> is expected to appear at the top level of the return type, as in <code>T | G[T | Divergent]</code>.</p>
<p>To summarize the rules here:</p>
<ul>
<li><code>T | Divergent = T (T is a non-recursive type)</code></li>
<li><code>G[R] = G[Divergent] (R is a recursive type, e.g. G[Divergent])</code></li>
<li><code>G[T | Divergent] = G[Divergent] (T is a non-recursive type)</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @mtshiba on 2025-09-11 10:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-11 14:03</div>
            <div class="timeline-body"><p>Yes, I think that makes sense, and corresponds to what I did in the final version of https://github.com/astral-sh/ruff/pull/20333 for tuple literals: if any element of the tuple we are constructing contains Divergent (is a recursive type), it is replaced by Divergent. This allowed me to get the result <code>Unknown | tuple[Divergent, Literal[0]</code> in the test in that PR (we can ignore the <code>Unknown</code>, it comes from our general policy of unioning un-annotated attribute types with <code>Unknown</code>) rather than just <code>Unknown | Divergent</code>.</p>
<p>I was planning to next apply this approach to all generic specializations (not just tuple literals) so as to solve Salsa &quot;too many iterations&quot; panics on many more cases of recursive type aliases. I don't want to conflict if you are doing similar work in this PR, but I do think we can and should implement this as a separate PR from return type inference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-12 16:48</div>
            <div class="timeline-body"><blockquote>
<ul>
<li><p><code>T | Divergent = T (T is a non-recursive type)</code></p>
</li>
<li><p><code>G[R] = G[Divergent] (R is a recursive type, e.g. G[Divergent])</code></p>
</li>
<li><p><code>G[T | Divergent] = G[Divergent] (T is a non-recursive type)</code></p>
</li>
</ul>
</blockquote>
<p>It seems challenging to implement both rule 1 and rule 3, as they seem contradictory (or at least require some kind of context-sensitive handling). Do you have a plan for this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-09-12 18:14</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<ul>
<li><code>T | Divergent = T (T is a non-recursive type)</code></li>
<li><code>G[R] = G[Divergent] (R is a recursive type, e.g. G[Divergent])</code></li>
<li><code>G[T | Divergent] = G[Divergent] (T is a non-recursive type)</code></li>
</ul>
</blockquote>
<p>It seems challenging to implement both rule 1 and rule 3, as they seem contradictory (or at least require some kind of context-sensitive handling). Do you have a plan for this?</p>
</blockquote>
<p>I realized that this could actually be implemented as normalization rules for recursive types rather than rules for union types.
In 69953ff67d57a15500511ac9c53a6a53271e9d21, I added a mode to <code>NormalizedVisitor</code> that normalizes recursive types. <code>NormalizedVisitor</code> retains the nesting level of the type currently visiting, and changes the normalization handling depending on the nesting level (the nesting level increases by one inside a tuple, etc.; the nesting level remains unchanged inside a union).</p>
<ul>
<li>If <code>Divergent</code> appears at level 0, it is replaced with <code>Never</code>. (e.g. <code>Divergent | int =&gt; int</code>)</li>
<li>If a recursive type appears at level 1 or above, it is replaced with <code>Divergent</code>. (e.g. <code>tuple[tuple[Divergent]] =&gt; tuple[Divergent], tuple[Divergent | int] =&gt; tuple[Divergent]</code>)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-12 19:28</div>
            <div class="timeline-body"><p>I see how that could work, as a type transform that we would use in place of the simpler &quot;if ty.has_divergent_type(div): return div&quot; type approach. I'm not sure it's a good idea to combine it with the existing <code>Type::normalized</code> function. That function transforms types extensively and we never use it on types that we plan to persist, it's only used for checking type equivalence.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3050 on 2025-09-15 16:34</div>
            <div class="timeline-body"><p>I wonder if we should build this into Salsa (so that cycle recovery functions receive the previous two values, if any, not just the latest value, and can &quot;fallback&quot; to the union of the previous two), rather than requiring the query implementations to handle it internally.</p>
<p>This way of handling it seems problematic because it means that every single use of <code>class_member_with_policy</code> always creates a self-cycle, even if it otherwise wouldn't have created any cycle at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-09-15 17:04</div>
            <div class="timeline-body"><p>I am seeing that sometimes we have cycles in a query that doesn't have access to any scope (e.g. <code>Type::member_lookup_with_policy</code>). I think it might be too restrictive to require a <code>ScopeId</code> to always be present as the discriminant for a <code>DivergentType</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-15 17:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-16 13:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/tests/corpus.rs</code>:174 on 2025-09-16 13:06</div>
            <div class="timeline-body"><p>Good news!
I've successfully generalized the recursive function type inference technique and applied it to other divergent type inference (without using <code>CycleRecoveryAction::Fallback</code>), that is, I basically solved <a href="https://github.com/astral-sh/ty/issues/256">#256</a>. However, the current implementation seems to significantly degrade performance. I'll investigate this a bit more, then split this PR into a new one organized around closing <a href="https://github.com/astral-sh/ty/issues/256">#256</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-16 13:09</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3050 on 2025-09-16 13:09</div>
            <div class="timeline-body"><p>Yes, I looked into whether we could do this using salsa's public API, but I couldn't find a safe way to do it other than actually calling the query.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-16 13:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-09-16 13:14</div>
            <div class="timeline-body"><p>I've come to believe that the correct modeling here is that the <code>Divergent</code> type holds the entire argument set of the divergent query.</p>
<p>The correct mechanism for suppressing divergence is:</p>
<ul>
<li>When a tracked function that returns a &quot;struct containing types&quot; enters a cycle, the initial value of the cycle is set not to <code>Never</code> (or, a struct containing it), but to the <code>Divergent</code> type that contains information that uniquely identifies the point of divergence. (Until now, I have only considered function return type inference, so I thought that scope information was sufficient, but to apply this technique more generally to various tracked functions, <code>DivergentType</code> should hold all of the arguments passed by the <code>cycle_initial</code> function.)</li>
<li>From the next cycle, the <code>Divergent</code> type becomes the fallback type within that inference.</li>
<li>To deal with type inference that &quot;oscillates&quot; periodically, the type from the previous cycle is unioned with the current type. This ensures that if the type converges, it will grow monotonically and will no longer oscillate.</li>
<li>To prevent recursive types from exploding, all types are normalized at the end of the process using the <code>recursive_type_normalized</code> method.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/cycle.md</code>:34 on 2025-09-16 17:18</div>
            <div class="timeline-body"><p>Why does <code>Divergent</code> not turn into <code>Never</code> and disappear in the union on normalization here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/narrow/type.md</code>:154 on 2025-09-16 17:25</div>
            <div class="timeline-body"><p>The point of this test is simply that we don't apply the special-case narrowing for <code>builtins.type</code> just because a custom callable happens to have the name <code>type</code>. Having an annotated return type on the custom callable confuses this. Let's remove the <code>-&gt; TypeOf[int]</code> here, and restore the test assertions below to what they were originally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/attributes.md</code>:2451 on 2025-09-16 17:26</div>
            <div class="timeline-body"><pre><code class="language-suggestion">    # TODO invalid override error
    def flip(self) -&gt; &quot;Base&quot;:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3050 on 2025-09-16 17:48</div>
            <div class="timeline-body"><p>We are salsa maintainers and should feel free to add/extend the public API as needed to support valid use cases. I think we could easily make it so that cycle-recovery functions receive the last two values instead of just the last one.</p>
<p>Relatedly, one case I've been looking at which still has trouble in this PR is this one:</p>
<pre><code class="language-py">from typing import Generic, TypeVar

B = TypeVar(&quot;B&quot;, bound=&quot;Base&quot;)

class Base(Generic[B]):
    pass
</code></pre>
<p>The simple &quot;union last two&quot; strategy does not work well here, because we end up inferring <code>B</code> as the union of two typevars (with different upper bounds), and that union doesn't simplify. I think we would need to be aware that the divergence is in the upper bound, specifically, and union the upper bound types, not the type of the entire typevar?</p>
<p>(For PEP 695 typevars the upper bounds/constraints are lazy, and I intend to do the same for legacy typevars, which I think would resolve this.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3916 on 2025-09-16 17:51</div>
            <div class="timeline-body"><p>As discussed before, this makes every member lookup always a self-cycle, requiring iteration to resolve, which is expensive. I suspect this is where a lot of the performance regression in this PR comes from. I think we need to build this into Salsa such that we do this unioning in the cycle-recovery function, not inside the query function itself, so the query function doesn't have to unconditionally call itself.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-09-16 20:08</div>
            <div class="timeline-body"><p>Incorporating a full unique identifier for the current query instance (that is, the query plus its arguments) into the <code>Divergent</code> type makes sense to me. I think we could potentially make this simpler / more efficient by having Salsa provide us a unique u32 identifier for the current query instance, to the initial/recovery functions. Salsa already has this ID internally.</p>
<p>Unioning to prevent oscillation makes sense, but I think we need to have Salsa provide the previous value and do this unioning in the cycle-recover function -- we can't create self-cycles in every query function.</p>
<p>There will also be challenges here to do the unioning at the right level. I gave an example in another comment where we can't just union two TypeVar together because we are iterating on the type of their bound. Similarly, if in one iteration we get <code>list[Never]</code> and the next iteration we get <code>list[int]</code>, we can't just union those together to get <code>list[Never] | list[int]</code>, which doesn't simplify. We need to do the unioning at the correct level so we get <code>list[Never | int] == list[int]</code>. Still thinking about how we can reliably identify the correct level at which to do this union.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-16 20:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-17 08:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3050 on 2025-09-17 08:21</div>
            <div class="timeline-body"><p>The code no longer panics since 6b9c889c127dc23d4e1c882697b6f936f83ec029.</p>
<p>In fact, the divergence appears to have been caused by a different reason.</p>
<p>What I did in 6b9c889c127dc23d4e1c882697b6f936f83ec029 was to make all functions that use <code>{Scope, Expression, Definition}Inference</code> cycle-safe.
This means that when using these structs, we need to make sure that <code>infer_{scope, expression, definition}_types</code> actually converge. If they don't converge, and we're using a value in the middle of the cycle, we need to make sure that the Divergent type propagates.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-17 08:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/resources/mdtest/cycle.md</code>:34 on 2025-09-17 08:27</div>
            <div class="timeline-body"><p>Fixed in 8593f11170298855490196e7593eed44b6cc6f39.</p>
<p>The cause is related to this <a href="https://github.com/astral-sh/ruff/pull/17371#discussion_r2354717565">comment</a>: <code>Divergent</code> types were not propagating properly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-17 11:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3050 on 2025-09-17 11:34</div>
            <div class="timeline-body"><p>Ah, well, it seems there are still some cases of divergence related to this.</p>
<pre><code class="language-python">from typing import TypeVar

Rec = TypeVar(&quot;Rec&quot;, bound=&quot;Rec&quot;)
</code></pre>
<p>As you pointed out, the cause is <code>TypeVar</code>. <code>Rec | Rec</code> is not simplified, resulting in divergence.</p>
<p>Can't we remove <code>TypeVar</code>'s dependency on <code>TypeVarBoundOrConstraintsEvaluation</code> and <code>TypeVarDefaultEvaluation</code> or replace them with stable IDs or methods?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-17 17:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:3050 on 2025-09-17 17:58</div>
            <div class="timeline-body"><blockquote>
<p>Can't we remove <code>TypeVar</code>'s dependency on <code>TypeVarBoundOrConstraintsEvaluation</code> and <code>TypeVarDefaultEvaluation</code> or replace them with stable IDs or methods?</p>
</blockquote>
<p>Yes, this is what I mentioned above:</p>
<blockquote>
<p>(For PEP 695 typevars the upper bounds/constraints are lazy, and I intend to do the same for legacy typevars, which I think would resolve this.)</p>
</blockquote>
<p>It may be the best thing for this particular TypeVar case is just to move forward with that. I can prioritize it as soon as I finish fixing and land the PEP 613 TypeAlias support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-17 18:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-09-17 18:02</div>
            <div class="timeline-body"><p>So there are two potential Salsa changes discussed here:</p>
<ol>
<li>Have Salsa provide the two most recent values, not just the most recent value, to the cycle recovery function.</li>
<li>Have Salsa provide a unique ID for the current query+arguments to the cycle recovery function.</li>
</ol>
<p>I think both are technically pretty easy; the latter may just be slightly tricky due to privacy rules: it will probably require either exposing some internal Salsa types, or converting Salsa's internal ID into an opaque u32.</p>
<p>I can work on either or both of these if you agree that they would be useful here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-18 13:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-09-18 13:58</div>
            <div class="timeline-body"><p>Yes, I think both are useful.</p>
<p>But, even if the cycle recovery function has the two most recent values, I think the following oscillating case will not converge.</p>
<pre><code class="language-python">class C:
    def flip(self) -&gt; &quot;D&quot;:
        return D()

class D(C):
    def flip(self) -&gt; &quot;C&quot;:
        return C()

def c_or_d(n: int):
    if n == 0:
        return D()
    else:
        # 0th: Divergent.flip() == Divergent
        # 1st: D.flip() == C
        # not converged, fallback: previous | current == Divergent | C == C
        # 2nd: C.flip() == D
        # not converged, fallback: previous | current == C | D == C
        # 3rd: C.flip() == D
        # not converged, fallback: previous | current == C | D == C
        # ...
        return c_or_d(n - 1).flip()
</code></pre>
<p>The reason the return type doen't converge here is that the types are unioned after the convergence test.
The value joining (union) operation must be performed before the convergence test (and I think the value joining operation and the operation of selecting <code>CycleRecovery::Iterate</code> or <code>CycleRecovery::Fallback</code> as the cycle recovery are independent).</p>
<p>Therefore, I think it's necessary to specify an additional value joining operation in the tracked function. For example, like this:</p>
<pre><code class="language-rust">fn return_type_cycle_join&lt;'db&gt;(
    db: &amp;'db dyn Db,
  previous: &amp;Type&lt;'db&gt;,
  current: &amp;Type&lt;'db&gt;
  _self: FunctionType&lt;'db&gt;,
) -&gt; Type&lt;'db&gt; {
    // Recursive type normalization is also required, in reality
  UnionType::from_elements(db, [previous, current])
}

#[tracked]
impl&lt;'db&gt; FunctionType&lt;'db&gt; {
  #[salsa::tracked(cycle_fn=return_type_cycle_recover, cycle_initial=return_type_cycle_initial, cycle_join=return_type_cycle_join)]
  pub(crate) fn infer_return_type(self, db: &amp;'db dyn Db) -&gt; Type&lt;'db&gt; {
      ...
  }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-18 14:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-09-18 14:19</div>
            <div class="timeline-body"><p>Also, while this is just a thought and not required here, we could consider adding a trait called <code>JoinSemiLattice</code> to salsa. (The term is borrowed from set theory and is sometimes mentioned in the context of type theory. That is, a type can be thought of as a &quot;join-semilattice&quot;, a partially ordered structure with a minimal element  = Never(Divergent) and a join operation = union)
In our use case, <code>Type</code> is clearly <code>JoinSemiLattice</code>, and it could also be implemented to <code>{Scope, Expression, Definition}Inference</code>.</p>
<pre><code class="language-rust">trait JoinSemiLattice&lt;'db&gt; {
    // Operation equivalent to `cycle_initial`
    // To generate a `Divergent` type, information about the query input is required.
    // Here, it is treated as an imaginary data type called `QueryId`.
    fn bottom(db: &amp;'db dyn Db, id: QueryId) -&gt; Self; 
    // Operation equivalent to `cycle_join`
    fn join(db: &amp;'db dyn Db, id: QueryId, left: &amp;Self, right: &amp;Self) -&gt; Self;
}
</code></pre>
<pre><code class="language-rust">impl&lt;'db&gt; JoinSemiLattice&lt;'db&gt; for Type&lt;'db&gt; { 
    fn bottom(db: &amp;'db dyn Db, id: QueryId) -&gt; Self { 
        Type::divergent(DivergentType::new(db, id)) 
    }
    fn join(db: &amp;'db dyn Db, id: QueryId, left: &amp;Self, right: &amp;Self) -&gt; Self { 
        let visitor = RecursiveTypeNormalizedVisitor::new(db, Self::bottom(db, id));
        UnionType::from_elements(db, [left, right]).recursive_type_normalized(db, &amp;visitor)
    }
}
</code></pre>
<p>The advantage of implementing this trait is that it allows the result type to define standard handling when a cycle occurs, eliminating the need to specify <code>cycle_initial/cycle_join</code> each time we create a tracked function. Another advantage is that it allows us to use the Rust type system's checks without relying on macros. However, since the query inputs are abstracted, this approach is probably optional.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-09-25 06:00</div>
            <div class="timeline-body"><p>Parts not directly related to this PR have been moved to #20566, which aims to make recursive type inference converge more generally.</p>
<p>The handling of recursive type inference in this PR should be replaced with something more sophisticated, but I think it's best to land this PR first and complete it in #20566.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-09-25 06:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types/builder.rs</code>:211 on 2025-09-25 06:22</div>
            <div class="timeline-body"><p>The reason we had to lower the limit here is that the addition of new query function <code>infer_return_type</code> (which can form cycles) has caused delays in convergence for existing query functions (such as <code>infer_scope_types</code>).
Specifically, I have found that a panic can occur unless <code>MAX_UNION_LITERALS+ITERATIONS_BEFORE_FALLBACK&lt;199</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @mtshiba on 2025-09-25 06:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-09-25 06:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:630 on 2025-09-25 22:02</div>
            <div class="timeline-body"><p>Why do we need this method if it's just an alias for <code>fallback_type()</code> method?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer.rs</code>:669 on 2025-09-25 22:04</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            // TODO: this means that every `infer_return_type` creates a self-cycle that must be iterated.
            // Instead, have Salsa provide both previous and current value so we can do this in the
            // recovery function.
            union = union.add(previous_cycle_value.recursive_type_normalized(db, &amp;visitor));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:1537 on 2025-09-25 22:14</div>
            <div class="timeline-body"><p>We could probably implement <code>Into&lt;ExpressionNodeKey&gt;</code> for <code>&amp;Box&lt;Expr&gt;</code> to avoid the need for this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:4774 on 2025-09-25 22:21</div>
            <div class="timeline-body"><p>Why do we need to store the expression key instead of storing the type directly?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:1957 on 2025-09-25 22:23</div>
            <div class="timeline-body"><p>Why would we fallback to <code>Type::none</code> here?</p>
<p>It seems like we should just <code>expect</code> here, we should always have inferred a type for every returnee expression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:1350 on 2025-09-25 22:29</div>
            <div class="timeline-body"><p>If the level &gt;= 1 and <code>self</code> does not contain <code>visitor.div</code>, do we need to keep walking <code>self</code> recursively, or could we just short-circuit and return <code>self</code>? It seems we will not change anything in the visit.</p>
<p>It's not really clear to me that we even need all the many added <code>recursive_type_normalized</code> methods in this PR, and all the <code>level</code> and <code>visit_no_shift</code> stuff either. Wouldn't it be an equivalent implementation if we just match on unions here, visit all their elements, and for any other type, check <code>has_divergent_type</code> and return <code>div</code> if so?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/src/types.rs</code>:9515 on 2025-09-25 22:30</div>
            <div class="timeline-body"><p>Does this need to be a separate Salsa query, or could we just infer the return type of <code>self.function(db)</code>?</p>
<p>We could add the union with <code>Unknown</code> here rather than inside <code>ScopeInference::infer_return_type</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-09-25 22:42</div>
            <div class="timeline-body"><p>This is looking good! Some comments and questions inline.</p>
<p>I will be a bit hesitant to land this before type-of-self lands, because type-of-self is critical, and the more new type information we introduce, the more blockers we encounter there. (This already happened with the dict literal inference PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2025-10-22 10:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ty_python_semantic/src/types.rs</code>:7151 on 2025-10-22 10:45</div>
            <div class="timeline-body"><p>The reason we don't have a trait is because we want to pass the query arguments to the cycle recovery function and those are variadic.</p>
<p>I don't see any reason why we can't have that trait inside ty</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-06 09:40</div>
            <div class="timeline-body"><p>Now we have proper cycle handling, Liskov checks, and type-of-self. I think it's a good time to reboot this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @mtshiba on 2025-12-15 10:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-18 15:50</div>
            <div class="timeline-body"><p>It appears that abnormal memory consumption was occurring during the scipy inspection and ty was killed.</p>
<p><a href="https://profiler.firefox.com/public/x0rzn43ca8jg0wvy4es9c0abb7a5v21z8xdeyf8/flame-graph/?globalTrackOrder=0&amp;hiddenLocalTracksByPid=30516-0w57wlnwx8&amp;symbolServer=http%3A%2F%2F127.0.0.1%3A3000%2F1yskjwj2ya41kgmsrmr9yj2diwwq0nbxxb6kmzg&amp;thread=n&amp;v=12">The profiling result</a> seem to suggest that <code>IntersectionBuilder</code> is a hotspot.
In particular, cloning and dropping <code>IntersectionBuilder</code> take a long time and huge amounts of memory.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-18 16:11</div>
            <div class="timeline-body"><p>Hmm, in fact, this is a result of fixed-point iterations not converging and the intersection type growing without bound?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-18 16:47</div>
            <div class="timeline-body"><p>The handling of unions in <code>IntersectionBuilder::add_positive_impl</code> seems to exponentially increase the number of <code>intersections</code>, which seems inherently problematic?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-18 17:35</div>
            <div class="timeline-body"><p>mypy_primer: https://github.com/astral-sh/ruff/pull/17371#issuecomment-2799694845
codspeed: https://github.com/astral-sh/ruff/pull/17371#issuecomment-2993362046
type conformance test: https://github.com/astral-sh/ruff/pull/17371#issuecomment-3145365663
ruff_ecosystem: https://github.com/astral-sh/ruff/pull/17371#issuecomment-3044655961</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 17:38</div>
            <div class="timeline-body"><blockquote>
<p>The handling of unions in <code>IntersectionBuilder::add_positive_impl</code> seems to exponentially increase the number of <code>intersections</code>, which seems inherently problematic?</p>
</blockquote>
<p>Yes, it could be problematic, but it's required to keep set-theoretic types in disjunctive normal form, which is valuable, and in most practical cases, unions/intersections don't grow large enough for it to be a problem. We could set some size-maximums with fallback to a less precise type, would have to look at the specific case that causes a blowup. If it's due to fixpoint iteration not converging, then that seems like the key issue to fix.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-18 17:46</div>
            <div class="timeline-body"><p>Fixed <code>IntersectionBuilder</code> to not have multiple identical <code>InnerIntersectionBuilder</code>s.
<a href="https://github.com/astral-sh/ruff/pull/17371#issuecomment-2993362046">The pydantic result</a> is interesting. It might be worth breaking out as a separate PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-18 18:14</div>
            <div class="timeline-body"><p>Opened #22055. Thanks to this change, scipy no longer seems to be killed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @mtshiba on 2025-12-19 16:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-19 16:08</div>
            <div class="timeline-body"><!-- generated-comment ty ecosystem-analyzer -->

<h2><code>ecosystem-analyzer</code> results</h2>
<p>| Lint rule | Added | Removed | Changed |
|-----------|------:|--------:|--------:|
| <code>unsupported-operator</code> | 35,575 | 0 | 73 |
| <code>possibly-missing-attribute</code> | 15,046 | 86 | 339 |
| <code>invalid-argument-type</code> | 3,481 | 82 | 239 |
| <code>non-subscriptable</code> | 2,222 | 0 | 0 |
| <code>invalid-assignment</code> | 1,638 | 11 | 33 |
| <code>not-iterable</code> | 1,341 | 0 | 8 |
| <code>unresolved-attribute</code> | 1,209 | 12 | 3 |
| <code>no-matching-overload</code> | 728 | 0 | 0 |
| <code>call-non-callable</code> | 703 | 2 | 0 |
| <code>invalid-return-type</code> | 363 | 2 | 26 |
| <code>too-many-positional-arguments</code> | 290 | 3 | 0 |
| <code>unknown-argument</code> | 146 | 8 | 0 |
| <code>unsupported-base</code> | 145 | 0 | 0 |
| <code>invalid-await</code> | 115 | 0 | 6 |
| <code>invalid-key</code> | 115 | 0 | 0 |
| <code>unused-ignore-comment</code> | 20 | 83 | 0 |
| <code>missing-argument</code> | 44 | 4 | 0 |
| <code>index-out-of-bounds</code> | 43 | 4 | 0 |
| <code>parameter-already-assigned</code> | 2 | 19 | 0 |
| <code>division-by-zero</code> | 8 | 0 | 0 |
| <code>invalid-context-manager</code> | 7 | 0 | 0 |
| <code>deprecated</code> | 3 | 2 | 0 |
| <code>invalid-type-form</code> | 2 | 0 | 0 |
| <code>possibly-unresolved-reference</code> | 0 | 2 | 0 |
| <code>invalid-exception-caught</code> | 1 | 0 | 0 |
| <code>invalid-method-override</code> | 1 | 0 | 0 |
| <strong>Total</strong> | <strong>63,248</strong> | <strong>320</strong> | <strong>727</strong> |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @mtshiba on 2025-12-19 17:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @mtshiba on 2025-12-19 17:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @carljm on 2025-12-23 04:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @carljm on 2025-12-23 04:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> removed by @mtshiba on 2025-12-23 05:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ecosystem-analyzer</span> added by @mtshiba on 2025-12-23 05:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-23 07:29</div>
            <div class="timeline-body"><p>Given the many new diagnostics, I think we should consider adding a new <code>analysis.&lt;option&gt;</code> to control whether return type inference is on.</p>
<p>I also suggest running the <code>ty-benchmarks</code> on this o get a better sense for the performance impact (note that <code>ty-benchmarks</code> turns off return type inference for all other type checkers that support it for a fair comparison)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mtshiba">@mtshiba</a> reviewed on 2025-12-23 09:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mtshiba">@mtshiba</a> on <code>crates/ty_python_semantic/src/types/call/bind.rs</code>:3160 on 2025-12-23 09:10</div>
            <div class="timeline-body"><p>This addresses <a href="https://github.com/astral-sh/ruff/pull/17371/files#diff-8c9ae4384d5808e43fce19d9835dd6e49048297bd4989c5379ebe0f476d34e4f">a pattern</a> that was not considered in #22068, but I'm not sure if this is the best approach.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 16:36:41 UTC
    </footer>
</body>
</html>
