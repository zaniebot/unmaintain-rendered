<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Implement disjointness for TypedDicts - astral-sh/ruff #22044</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Implement disjointness for TypedDicts</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22044">#22044</a>
        opened by <a href="https://github.com/oconnor663">@oconnor663</a>
        on 2025-12-18 00:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a></div>
            <div class="timeline-body"><p>This is a preliminary step to tagged union narrowing for <code>TypedDict</code>: <a href="https://github.com/astral-sh/ty/issues/1479">astral-sh/ty#1479</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/carljm">@carljm</a> by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 00:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/AlexWaygood">@AlexWaygood</a> by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 00:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 00:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/dcreager">@dcreager</a> by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 00:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-18 00:53</div>
            <div class="timeline-body">

Diagnostic diff on <a href="https://github.com/python/typing/tree/9f6d8ced7cd1c8d92687a4e9c96d7716452e471e/conformance">typing conformance tests</a>
<p>No changes detected when running ty on typing conformance tests ‚úÖ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 00:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1896 on 2025-12-18 00:53</div>
            <div class="timeline-body"><p>Is this sort of &quot;one dynamic type winds up in multiple fields&quot; situation ever something we reason about? Is there a name for this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 00:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4050 on 2025-12-18 00:54</div>
            <div class="timeline-body"><p>Could we just make this <code>ConstraintSet::from(true)</code> and declare that <code>TypedDict</code>s are disjoint from anything that isn&#x27;t a <code>TypedDict</code>? I assume cases like <code>object</code> and <code>Mapping</code> are handled above? (But I should probably test for that...)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astral-sh-bot[bot]">@astral-sh-bot[bot]</a> on 2025-12-18 00:54</div>
            <div class="timeline-body">

<code>mypy_primer</code> results

Changes were detected when running on open source projects

<pre><code>prefect (https://github.com/PrefectHQ/prefect)
- src/integrations/prefect-dbt/prefect_dbt/core/settings.py:94:28: error[invalid-assignment] Object of type `dict[str, Any] | T@resolve_block_document_references | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/integrations/prefect-dbt/prefect_dbt/core/settings.py:94:28: error[invalid-assignment] Object of type `dict[str, Any] | T@resolve_block_document_references | int | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
- src/integrations/prefect-dbt/prefect_dbt/core/settings.py:99:28: error[invalid-assignment] Object of type `dict[str, Any] | T@resolve_variables | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/integrations/prefect-dbt/prefect_dbt/core/settings.py:99:28: error[invalid-assignment] Object of type `dict[str, Any] | int | T@resolve_variables | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
- src/prefect/cli/deploy/_core.py:86:21: error[invalid-assignment] Object of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/prefect/cli/deploy/_core.py:86:21: error[invalid-assignment] Object of type `T@resolve_block_document_references | int | dict[str, Any] | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
- src/prefect/cli/deploy/_core.py:87:21: error[invalid-assignment] Object of type `T@resolve_variables | str | int | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
+ src/prefect/cli/deploy/_core.py:87:21: error[invalid-assignment] Object of type `int | T@resolve_variables | float | ... omitted 4 union elements` is not assignable to `dict[str, Any]`
- src/prefect/deployments/steps/core.py:137:38: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements`
+ src/prefect/deployments/steps/core.py:137:38: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | int | dict[str, Any] | ... omitted 4 union elements`
- src/prefect/utilities/templating.py:320:13: error[invalid-assignment] Invalid subscript assignment with key of type `object` and value of type `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements` on object of type `dict[str, Any]`
+ src/prefect/utilities/templating.py:320:13: error[invalid-assignment] Invalid subscript assignment with key of type `object` and value of type `T@resolve_block_document_references | int | dict[str, Any] | ... omitted 4 union elements` on object of type `dict[str, Any]`
- src/prefect/utilities/templating.py:323:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_block_document_references | dict[str, Any]`, found `list[T@resolve_block_document_references | dict[str, Any] | str | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:323:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_block_document_references | dict[str, Any]`, found `list[T@resolve_block_document_references | int | dict[str, Any] | ... omitted 5 union elements]`
- src/prefect/utilities/templating.py:437:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `dict[object, T@resolve_variables | str | int | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:437:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `dict[object, int | T@resolve_variables | float | ... omitted 5 union elements]`
- src/prefect/utilities/templating.py:442:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `list[T@resolve_variables | str | int | ... omitted 5 union elements]`
+ src/prefect/utilities/templating.py:442:16: error[invalid-return-type] Return type does not match returned value: expected `T@resolve_variables`, found `list[int | T@resolve_variables | float | ... omitted 5 union elements]`
- src/prefect/workers/base.py:228:13: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | dict[str, Any] | str | ... omitted 4 union elements`
+ src/prefect/workers/base.py:228:13: error[invalid-argument-type] Argument is incorrect: Expected `T@resolve_variables`, found `T@resolve_block_document_references | int | dict[str, Any] | ... omitted 4 union elements`
- src/prefect/workers/base.py:230:20: error[invalid-argument-type] Argument expression after ** must be a mapping type: Found `T@resolve_variables | str | int | ... omitted 4 union elements`
+ src/prefect/workers/base.py:230:20: error[invalid-argument-type] Argument expression after ** must be a mapping type: Found `int | T@resolve_variables | float | ... omitted 4 union elements`

openlibrary (https://github.com/internetarchive/openlibrary)
- openlibrary/core/lists/model.py:430:24: warning[possibly-missing-attribute] Attribute `key` may be missing on object of type `(Thing &amp; ~str &amp; ~Top[dict[Unknown, Unknown]]) | (AnnotatedSeed &amp; ~str &amp; ~Top[dict[Unknown, Unknown]])`
+ openlibrary/core/lists/model.py:430:24: warning[possibly-missing-attribute] Attribute `key` may be missing on object of type `(Thing &amp; ~str &amp; ~Top[dict[Unknown, Unknown]]) | (AnnotatedSeed &amp; ~Top[dict[Unknown, Unknown]])`
- openlibrary/core/lists/model.py:431:13: error[invalid-assignment] Object of type `(Thing &amp; ~str &amp; ~Top[dict[Unknown, Unknown]]) | (AnnotatedSeed &amp; ~str &amp; ~Top[dict[Unknown, Unknown]])` is not assignable to attribute `value` of type `Thing | str`
+ openlibrary/core/lists/model.py:431:13: error[invalid-assignment] Object of type `(Thing &amp; ~str &amp; ~Top[dict[Unknown, Unknown]]) | (AnnotatedSeed &amp; ~Top[dict[Unknown, Unknown]])` is not assignable to attribute `value` of type `Thing | str`
+ openlibrary/plugins/openlibrary/lists.py:89:19: error[invalid-key] Unknown key &quot;key&quot; for TypedDict `AnnotatedSeedDict`: Unknown key &quot;key&quot;
- Found 1152 diagnostics
+ Found 1153 diagnostics

altair (https://github.com/vega/altair)
- altair/vegalite/v6/api.py:655:21: error[invalid-assignment] Object of type `(OperatorMixin &amp; Top[dict[Unknown, Unknown]] &amp; ~Parameter &amp; ~PredicateComposition &amp; ~Expression) | (Expr &amp; Top[dict[Unknown, Unknown]] &amp; ~Parameter &amp; ~PredicateComposition &amp; ~Expression) | (_ConditionExtra &amp; Top[dict[Unknown, Unknown]] &amp; ~Parameter &amp; ~PredicateComposition &amp; ~Expression)` is not assignable to `_ConditionExtra`
+ altair/vegalite/v6/api.py:655:21: error[invalid-assignment] Object of type `(OperatorMixin &amp; Top[dict[Unknown, Unknown]] &amp; ~Parameter &amp; ~PredicateComposition &amp; ~Expression) | (Expr &amp; Top[dict[Unknown, Unknown]] &amp; ~Parameter &amp; ~PredicateComposition &amp; ~Expression) | (_ConditionExtra &amp; Top[dict[Unknown, Unknown]])` is not assignable to `_ConditionExtra`

egglog-python (https://github.com/egraphs-good/egglog-python)
- python/egglog/examples/jointree.py:38:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:38:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:39:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:39:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:40:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:40:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:41:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:41:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:42:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:42:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:43:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:43:10: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:53:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:53:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/examples/jointree.py:64:22: error[invalid-argument-type] Argument to bound method `extract` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/examples/jointree.py:64:22: error[invalid-argument-type] Argument to bound method `extract` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/array_api_jit.py:32:86: error[invalid-argument-type] Argument to function `try_evaling` is incorrect: Expected `BuiltinExpr`, found `(...) -&gt; Unknown &amp; BaseExpr`
+ python/egglog/exp/array_api_jit.py:32:86: error[invalid-argument-type] Argument to function `try_evaling` is incorrect: Expected `BuiltinExpr`, found `(...) -&gt; BaseExpr &amp; Unknown`
- python/egglog/exp/program_gen.py:131:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:131:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:181:46: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:181:46: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:183:39: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:183:39: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:188:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:188:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:198:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:198:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:224:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:224:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:228:46: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:228:46: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:231:66: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:231:66: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:234:46: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:234:46: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:234:67: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:234:67: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:237:47: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:237:47: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:237:91: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:237:91: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:252:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:252:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:253:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:253:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:265:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:265:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:266:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:266:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:274:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:274:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:275:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:275:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:285:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:285:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:286:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:286:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:302:56: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:302:56: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:304:49: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:304:49: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:312:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:312:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:325:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:325:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:340:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:340:12: error[invalid-argument-type] Argument to function `eq` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:353:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:353:12: error[invalid-argument-type] Argument to function `ne` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:373:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:373:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:374:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:374:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:375:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:375:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:403:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:403:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:404:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:404:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:405:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:405:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/egglog/exp/program_gen.py:406:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/egglog/exp/program_gen.py:406:14: error[invalid-argument-type] Argument to function `set_` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
- python/tests/test_array_api.py:290:92: error[invalid-argument-type] Argument to function `try_evaling` is incorrect: Expected `BuiltinExpr`, found `(...) -&gt; Unknown &amp; BaseExpr`
+ python/tests/test_array_api.py:290:92: error[invalid-argument-type] Argument to function `try_evaling` is incorrect: Expected `BuiltinExpr`, found `(...) -&gt; BaseExpr &amp; Unknown`
- python/tests/test_program_gen.py:87:47: error[invalid-argument-type] Argument to bound method `extract` is incorrect: Argument type `(...) -&gt; Unknown &amp; BaseExpr` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`
+ python/tests/test_program_gen.py:87:47: error[invalid-argument-type] Argument to bound method `extract` is incorrect: Argument type `(...) -&gt; BaseExpr &amp; Unknown` does not satisfy upper bound `BaseExpr` of type variable `BASE_EXPR`

static-frame (https://github.com/static-frame/static-frame)
- static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Bus[Any] | Top[Index[Any]] | Top[Series[Any, Any]] | ... omitted 7 union elements, object_]`
+ static_frame/core/bus.py:671:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemLocReduces[Bus[Any], object_]`, found `InterGetItemLocReduces[Bus[Any] | Top[Series[Any, Any]] | TypeBlocks | ... omitted 7 union elements, object_]`
- static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | TypeBlocks | Batch | ... omitted 6 union elements, generic[object]]`
+ static_frame/core/series.py:772:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Series[Any, Any], TVDtype@Series]`, found `InterGetItemILocReduces[Series[Any, Any] | Top[Index[Any]] | TypeBlocks | ... omitted 6 union elements, generic[object]]`
- static_frame/core/series.py:4072:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[SeriesHE[Any, Any], TVDtype@SeriesHE]`, found `InterGetItemILocReduces[SeriesHE[Any, Any] | TypeBlocks | Batch | ... omitted 7 union elements, generic[object]]`
+ static_frame/core/series.py:4072:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[SeriesHE[Any, Any], TVDtype@SeriesHE]`, found `InterGetItemILocReduces[SeriesHE[Any, Any] | Top[Index[Any]] | TypeBlocks | ... omitted 7 union elements, generic[object]]`
- static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | TypeBlocks | Batch | ... omitted 7 union elements, generic[object]]`
+ static_frame/core/yarn.py:418:16: error[invalid-return-type] Return type does not match returned value: expected `InterGetItemILocReduces[Yarn[Any], object_]`, found `InterGetItemILocReduces[Yarn[Any] | Top[Index[Any]] | TypeBlocks | ... omitted 7 union elements, generic[object]]`

pandas-stubs (https://github.com/pandas-dev/pandas-stubs)
- tests/test_groupby.py:433:11: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[(Any &amp; str) | (Any &amp; bytes) | (Any &amp; int) | ... omitted 12 union elements]`
+ tests/test_groupby.py:433:11: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[(str &amp; Any) | (bytes &amp; Any) | (int &amp; Any) | ... omitted 12 union elements]`
- tests/test_resampler.py:394:11: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[(Any &amp; str) | (Any &amp; bytes) | (Any &amp; int) | ... omitted 12 union elements]`
+ tests/test_resampler.py:394:11: error[type-assertion-failure] Type `Series[Any]` does not match asserted type `Series[(str &amp; Any) | (bytes &amp; Any) | (int &amp; Any) | ... omitted 12 union elements]`

zulip (https://github.com/zulip/zulip)
+ zerver/lib/markdown/__init__.py:1122:54: error[invalid-argument-type] Argument to bound method `handle_image_inlining` is incorrect: Expected `ResultWithFamily[tuple[str, str | None]]`, found `ResultWithFamily[tuple[str, str]]`
+ zerver/lib/markdown/__init__.py:1131:54: error[invalid-argument-type] Argument to bound method `handle_video_inlining` is incorrect: Expected `ResultWithFamily[tuple[str, str | None]]`, found `ResultWithFamily[tuple[str, str]]`
- Found 3674 diagnostics
+ Found 3676 diagnostics

core (https://github.com/home-assistant/core)
- homeassistant/components/aprilaire/coordinator.py:106:41: warning[unused-ignore-comment] Unused blanket `type: ignore` directive
- homeassistant/components/nexia/entity.py:110:9: error[unsupported-operator] Operator `|=` is not supported between objects of type `DeviceInfo &amp; ~None` and `dict[Unknown | str, Unknown | set[Unknown | tuple[str, Unknown]] | tuple[str, Unknown]]`
+ homeassistant/components/nexia/entity.py:110:9: error[unsupported-operator] Operator `|=` is not supported between objects of type `DeviceInfo` and `dict[Unknown | str, Unknown | set[Unknown | tuple[str, Unknown]] | tuple[str, Unknown]]`
- Found 14415 diagnostics
+ Found 14414 diagnostics

pydantic (https://github.com/pydantic/pydantic)
- pydantic/_internal/_generate_schema.py:2773:21: error[unresolved-attribute] Object of type `DefinitionReferenceSchema &amp; ~None` has no attribute `clear`
+ pydantic/_internal/_generate_schema.py:2773:21: error[unresolved-attribute] Object of type `DefinitionReferenceSchema` has no attribute `clear`
- pydantic/_internal/_generate_schema.py:2780:21: error[unresolved-attribute] Object of type `DefinitionReferenceSchema &amp; ~None` has no attribute `clear`
+ pydantic/_internal/_generate_schema.py:2780:21: error[unresolved-attribute] Object of type `DefinitionReferenceSchema` has no attribute `clear`


</code></pre>


<p>No memory usage changes detected ‚úÖ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-12-18 01:10</div>
            <div class="timeline-body">

<a href="https://codspeed.io/astral-sh/ruff/branches/typeddict_disjoint?utm_source=github&amp;utm_medium=comment&amp;utm_content=header">CodSpeed Performance Report</a>
Merging #22044 will <strong>improve performances by 70.52%</strong>
<p>Comparing <code>typeddict_disjoint</code> (18c5ae7) with <code>main</code> (2e44a86)</p>
Summary
<p><code>‚ö° 1</code> improvement<br>
<code>‚úÖ 21</code> untouched<br>
<code>‚è© 30</code> skipped[^skipped]</p>
Benchmarks breakdown
<p>|     | Mode | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | ---- | --------- | ------ | ------ | ------ |
| ‚ö° | WallTime | <a href="https://codspeed.io/astral-sh/ruff/branches/typeddict_disjoint?uri=crates%2Fruff_benchmark%2Fbenches%2Fty_walltime.rs%3A%3Alarge%5Bpydantic%5D&amp;runnerMode=WallTime&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=benchmark"><code>large[pydantic]</code></a> | 219.4 s | 128.7 s | +70.52% |
[^skipped]: 30 benchmarks were skipped, so the baseline results were used instead. If they were deleted from the codebase, <a href="https://codspeed.io/astral-sh/ruff/branches/typeddict_disjoint?sectionId=benchmark-comparison-section-baseline-result-skipped&amp;utm_source=github&amp;utm_medium=comment&amp;utm_content=archive">click here and archive them to remove them from the performance reports</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 01:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4050 on 2025-12-18 01:21</div>
            <div class="timeline-body"><p>I added a &quot;Disjointness with other types&quot; section to the mdtests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-18 06:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;[ty] `TypedDictType::is_disjoint_from_impl`&quot; to &quot;[ty] Implement disjointness for TypedDicts&quot; by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-18 12:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-18 12:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4052 on 2025-12-18 12:26</div>
            <div class="timeline-body"><p>I&#x27;m not sure cases like <code>object</code> and <code>Mapping</code> <em>are</em> handled above. But yes, <code>TypedDict</code> types are disjoint from almost all non-<code>TypedDict</code> types. For now, I would do this:</p>
<pre><code>diff --git a/crates/ty_python_semantic/resources/mdtest/typed_dict.md b/crates/ty_python_semantic/resources/mdtest/typed_dict.md
index c303a61642..f7cff1f03b 100644
--- a/crates/ty_python_semantic/resources/mdtest/typed_dict.md
+++ b/crates/ty_python_semantic/resources/mdtest/typed_dict.md
@@ -2002,9 +2002,11 @@ class RegularNonTD: ...
 
 static_assert(not is_disjoint_from(TD, object))
 static_assert(not is_disjoint_from(TD, Mapping[str, object]))
-# TODO: We should be able to assert that these are disjoint.
-static_assert(not is_disjoint_from(TD, Mapping[int, object]))
-static_assert(not is_disjoint_from(TD, RegularNonTD))
+static_assert(is_disjoint_from(TD, Mapping[int, object]))
+static_assert(is_disjoint_from(TD, RegularNonTD))
+
+# TODO: should pass
+static_assert(is_disjoint_from(TD, dict[str, str]))  # error: [static-assert-error]
 ```
 
 [subtyping section]: https://typing.python.org/en/latest/spec/typeddict.html#subtyping-between-typeddict-types
diff --git a/crates/ty_python_semantic/src/types.rs b/crates/ty_python_semantic/src/types.rs
index edb68a5b2c..d79173686e 100644
--- a/crates/ty_python_semantic/src/types.rs
+++ b/crates/ty_python_semantic/src/types.rs
@@ -4046,10 +4046,17 @@ impl&lt;&#x27;db&gt; Type&lt;&#x27;db&gt; {
                 })
             }
 
-            (Type::TypedDict(_), _) | (_, Type::TypedDict(_)) =&gt; {
-                // TODO: Implement disjointness for TypedDict with other types.
-                ConstraintSet::from(false)
-            }
+            (Type::TypedDict(_), other) | (other, Type::TypedDict(_)) =&gt; KnownClass::Dict
+                .to_specialized_instance(db, [KnownClass::Str.to_instance(db), Type::any()])
+                .has_relation_to_impl(
+                    db,
+                    other,
+                    inferable,
+                    TypeRelation::Assignability,
+                    relation_visitor,
+                    disjointness_visitor,
+                )
+                .negate(db),
         }
     }
</code></pre>
<p>What this is saying is: for any type <code>T</code>, if <code>dict[str, Any]</code> is not assignable to <code>T</code>, then all <code>TypedDict</code> types will always be disjoint from <code>T</code>. (Actually, that might be good to add as a comment, if you accept my patch above.)</p>
<p>This still leave us with some false negatives: you can see the added failing test I added in my patch above. But it gets rid fo most false negatives, and it&#x27;s okay for our disjointness implementation to have some false negatives. The main thing we want to avoid is false positives.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1 on 2025-12-18 14:09</div>
            <div class="timeline-body"><p>Fantastic test suite!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/typed_dict.md</code>:1896 on 2025-12-18 14:11</div>
            <div class="timeline-body"><p>hmm, yeah, this is pretty interesting. No, I haven&#x27;t come across this problem before, but thinking about it, it must exist for other generic types in our model too. I wouldn&#x27;t worry about it too much right now, but it could be worth opening a followup issue to discuss it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:348 on 2025-12-18 14:57</div>
            <div class="timeline-body"><p>nit: if this whole comment uses <code>///</code> rather than <code>//</code>, it&#x27;ll be rendered as a <em>beautiful</em> tooltip when I hover over the method in VSCode locally :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:406 on 2025-12-18 15:00</div>
            <div class="timeline-body"><p>üôÉ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:416 on 2025-12-18 15:05</div>
            <div class="timeline-body"><p>if we never look at the name here, can we simplify slightly by having <code>btreemap_overlapping_items</code> only yield the value pairs?</p>
<pre><code>diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index d392a85db5..2d080f9104 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -413,7 +413,7 @@ impl&lt;&#x27;db&gt; TypedDictType&lt;&#x27;db&gt; {
         relation_visitor: &amp;HasRelationToVisitor&lt;&#x27;db&gt;,
     ) -&gt; ConstraintSet&lt;&#x27;db&gt; {
         let fields_in_common = btreemap_overlapping_items(self.items(db), other.items(db));
-        fields_in_common.when_any(db, |(_name, (self_field, other_field))| {
+        fields_in_common.when_any(db, |(self_field, other_field)| {
             // Condition 1 above.
             if self_field.is_required() || other_field.is_required() {
                 if (!self_field.is_required() &amp;&amp; !self_field.is_read_only())
@@ -1051,14 +1051,14 @@ bitflags! {
 
 impl get_size2::GetSize for TypedDictFieldFlags {}
 
-/// Yield all the key/val pairs where the same key is present in both `BTreeMap`s. Take advantage
+/// Yield all the values where the same key is present in both `BTreeMap`s. Take advantage
 /// of the fact that keys are sorted to walk through each map once without doing any lookups. It
 /// would be nice if `BTreeMap` had something like `BTreeSet::intersection` that did this for us,
 /// but as far as I know we have to do it ourselves. Life is hard.
 fn btreemap_overlapping_items&lt;&#x27;a, K, V1, V2&gt;(
     left: &amp;&#x27;a BTreeMap&lt;K, V1&gt;,
     right: &amp;&#x27;a BTreeMap&lt;K, V2&gt;,
-) -&gt; impl Iterator&lt;Item = (&amp;&#x27;a K, (&amp;&#x27;a V1, &amp;&#x27;a V2))&gt;
+) -&gt; impl Iterator&lt;Item = (&amp;&#x27;a V1, &amp;&#x27;a V2)&gt;
 where
     K: Ord,
 {
@@ -1073,7 +1073,7 @@ where
                     // Matching keys. Yield this pair of values and advance both iterators.
                     left_items.next();
                     right_items.next();
-                    return Some((left_key, (left_val, right_val)));
+                    return Some((left_val, right_val));
                 }
                 Ordering::Less =&gt; {
                     // `left_items` is behind `right_items` in key order. Advance `left_items`.
@@ -1097,11 +1097,11 @@ fn test_btreemap_overlapping_items() {
     let right = BTreeMap::from_iter([(&quot;b&quot;, 2.0), (&quot;d&quot;, 4.0), (&quot;f&quot;, 6.0)]);
     assert_eq!(
         btreemap_overlapping_items(&amp;left, &amp;right).collect::&lt;Vec&lt;_&gt;&gt;(),
-        vec![(&amp;&quot;b&quot;, (&amp;2, &amp;2.0)), (&amp;&quot;d&quot;, (&amp;4, &amp;4.0))],
+        vec![(&amp;2, &amp;2.0), (&amp;4, &amp;4.0)],
     );
     assert_eq!(
         btreemap_overlapping_items(&amp;right, &amp;left).collect::&lt;Vec&lt;_&gt;&gt;(),
-        vec![(&amp;&quot;b&quot;, (&amp;2.0, &amp;2)), (&amp;&quot;d&quot;, (&amp;4.0, &amp;4))],
+        vec![(&amp;2.0, &amp;2), (&amp;4.0, &amp;4)],
     );
 
     // A case where one side is empty.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2025-12-18 15:07</div>
            <div class="timeline-body"><p>This looks great!! Really good job</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 16:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:348 on 2025-12-18 16:33</div>
            <div class="timeline-body"><p>I had it that way until 367e2f7ddff57ca2c048d9951dc2403f00732044 :sob::</p>
<pre><code>Clippy and Cargo want very different things here. Clippy demands that
the numbered list is indented, but that makes Cargo think it&#x27;s Rust code
and start trying to compile it. I don&#x27;t know how to make them both
happy, so I&#x27;m making it a regular `//` comment block instead of an
actual `///` doc comment, which seems to shut them both up...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-12-18 16:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:348 on 2025-12-18 16:57</div>
            <div class="timeline-body"><p>Bah, that&#x27;s annoying. You could put the numbered list inside a <code>```none</code> fence? This seems to appease both Clippy and Cargo:</p>
<pre><code>
diff --git a/crates/ty_python_semantic/src/types/typed_dict.rs b/crates/ty_python_semantic/src/types/typed_dict.rs
index d392a85db5..e25ad80d07 100644
--- a/crates/ty_python_semantic/src/types/typed_dict.rs
+++ b/crates/ty_python_semantic/src/types/typed_dict.rs
@@ -343,67 +343,73 @@ impl&lt;&#x27;db&gt; TypedDictType&lt;&#x27;db&gt; {
         )
     }
 
-    // Two `TypedDict`s `A` and `B` are disjoint if it&#x27;s impossible to come up with a third
-    // `TypedDict` `C` that&#x27;s fully-static and assignable to both of them.
-    //
-    // `TypedDict` assignability is determined field-by-field, so we determine disjointness
-    // similarly. For any field that&#x27;s only in `A`, it&#x27;s always possible for our hypothetical `C`
-    // to copy/paste that field without losing assignability to `B` (and vice versa), so we only
-    // need to consider fields that are present in both `A` and `B`.
-    //
-    // There are three properties of each field to consider: the declared type, whether it&#x27;s
-    // mutable (&quot;mut&quot; vs &quot;imm&quot; below), and whether it&#x27;s required (&quot;req&quot; vs &quot;opt&quot; below). Here&#x27;s a
-    // table summary of the restrictions on the declared type of a source field (for us that means
-    // in `C`, which we want to be assignable to both `A` and `B`) given a destination field (for
-    // us that means in either `A` or `B`). For completeness we&#x27;ll also include the possibility
-    // that the source field is missing entirely, though we&#x27;ll soon see that we can ignore that
-    // case. This table is essentially what `has_relation_to_impl` implements above. Here
-    // &quot;equivalent&quot; means the source and destination types must be equivalent/compatible,
-    // &quot;assignable&quot; means the source must be assignable to the destination, and &quot;-&quot; means the
-    // assignment is never allowed:
-    //
-    //    source‚Üí | mut + req  | mut + opt  | imm + req  | imm + opt  |   [missing]   |
-    // ‚Üìdest      |            |            |            |            |               |
-    // -----------|------------|------------|------------|------------|---------------|
-    // mut + req  | equivalent |     -      |     -      |     -      |       -       |
-    // mut + opt  |     -      | equivalent |     -      |     -      |       -       |
-    // imm + req  | assignable |     -      | assignable |     -      |       -       |
-    // imm + opt  | assignable | assignable | assignable | assignable | [dest is obj] |
-    //
-    // We can cut that table down substantially by noticing two things:
-    //
-    // - We don&#x27;t need to consider the cases where the source field (in `C`) is `ReadOnly`/&quot;imm&quot;,
-    //   because the mutable version of the same field is always &quot;strictly more assignable&quot;. In
-    //   other words, nothing in the `TypedDict` assignability rules ever requires a source field
-    //   to be immutable.
-    // - We don&#x27;t need to consider the special case where the source field is missing, because
-    //   that&#x27;s only allowed when the destination is `ReadOnly[NotRequired[object]]`, which is
-    //   compatible with *any* choice of source field.
-    //
-    // The cases we actually need to reason about are this smaller table:
-    //
-    //    source‚Üí | mut + req  | mut + opt  |
-    // ‚Üìdest      |            |            |
-    // -----------|------------|------------|
-    // mut + req  | equivalent |     -      |
-    // mut + opt  |     -      | equivalent |
-    // imm + req  | assignable |     -      |
-    // imm + opt  | assignable | assignable |
-    //
-    // So, given a field name that&#x27;s in both `A` and `B`, here are the conditions where it&#x27;s
-    // *impossible* to choose a source field for `C` that&#x27;s compatible with both destinations,
-    // which tells us that `A` and `B` are disjoint:
-    //
-    //  1. If one side is &quot;mut+opt&quot; (which forces the field in `C` to be &quot;opt&quot;) and the other
-    //     side is &quot;req&quot; (which forces the field in `C` to be &quot;req&quot;).
-    // 2a. If both sides are mutable, and their types are not equivalent/compatible. (Because
-    //     the type in `C` must be compatible with both of them.)
-    // 2b. If one sides is mutable, and its type is not assignable to the immutable side&#x27;s type.
-    //     (Because the type in `C` must be compatible with the mutable side.)
-    // 2c. If both sides are immutable, and their types are disjoint. (Because the type in `C`
-    //      must be assignable to both.)
-    //
-    // TODO: Adding support for `closed` and `extra_items` will complicate this.
+    /// Two `TypedDict`s `A` and `B` are disjoint if it&#x27;s impossible to come up with a third
+    /// `TypedDict` `C` that&#x27;s fully-static and assignable to both of them.
+    ///
+    /// `TypedDict` assignability is determined field-by-field, so we determine disjointness
+    /// similarly. For any field that&#x27;s only in `A`, it&#x27;s always possible for our hypothetical `C`
+    /// to copy/paste that field without losing assignability to `B` (and vice versa), so we only
+    /// need to consider fields that are present in both `A` and `B`.
+    ///
+    /// There are three properties of each field to consider: the declared type, whether it&#x27;s
+    /// mutable (&quot;mut&quot; vs &quot;imm&quot; below), and whether it&#x27;s required (&quot;req&quot; vs &quot;opt&quot; below). Here&#x27;s a
+    /// table summary of the restrictions on the declared type of a source field (for us that means
+    /// in `C`, which we want to be assignable to both `A` and `B`) given a destination field (for
+    /// us that means in either `A` or `B`). For completeness we&#x27;ll also include the possibility
+    /// that the source field is missing entirely, though we&#x27;ll soon see that we can ignore that
+    /// case. This table is essentially what `has_relation_to_impl` implements above. Here
+    /// &quot;equivalent&quot; means the source and destination types must be equivalent/compatible,
+    /// &quot;assignable&quot; means the source must be assignable to the destination, and &quot;-&quot; means the
+    /// assignment is never allowed:
+    ///
+    /// ```none
+    ///    source‚Üí | mut + req  | mut + opt  | imm + req  | imm + opt  |   [missing]   |
+    /// ‚Üìdest      |            |            |            |            |               |
+    /// -----------|------------|------------|------------|------------|---------------|
+    /// mut + req  | equivalent |     -      |     -      |     -      |       -       |
+    /// mut + opt  |     -      | equivalent |     -      |     -      |       -       |
+    /// imm + req  | assignable |     -      | assignable |     -      |       -       |
+    /// imm + opt  | assignable | assignable | assignable | assignable | [dest is obj] |
+    /// ```
+    ///
+    /// We can cut that table down substantially by noticing two things:
+    ///
+    /// - We don&#x27;t need to consider the cases where the source field (in `C`) is `ReadOnly`/&quot;imm&quot;,
+    ///   because the mutable version of the same field is always &quot;strictly more assignable&quot;. In
+    ///   other words, nothing in the `TypedDict` assignability rules ever requires a source field
+    ///   to be immutable.
+    /// - We don&#x27;t need to consider the special case where the source field is missing, because
+    ///   that&#x27;s only allowed when the destination is `ReadOnly[NotRequired[object]]`, which is
+    ///   compatible with *any* choice of source field.
+    ///
+    /// The cases we actually need to reason about are this smaller table:
+    ///
+    /// ```none
+    ///    source‚Üí | mut + req  | mut + opt  |
+    /// ‚Üìdest      |            |            |
+    /// -----------|------------|------------|
+    /// mut + req  | equivalent |     -      |
+    /// mut + opt  |     -      | equivalent |
+    /// imm + req  | assignable |     -      |
+    /// imm + opt  | assignable | assignable |
+    /// ```
+    ///
+    /// So, given a field name that&#x27;s in both `A` and `B`, here are the conditions where it&#x27;s
+    /// *impossible* to choose a source field for `C` that&#x27;s compatible with both destinations,
+    /// which tells us that `A` and `B` are disjoint:
+    ///
+    /// ```none
+    /// 1. If one side is &quot;mut+opt&quot; (which forces the field in `C` to be &quot;opt&quot;) and the other
+    ///    side is &quot;req&quot; (which forces the field in `C` to be &quot;req&quot;).
+    /// 2a. If both sides are mutable, and their types are not equivalent/compatible. (Because
+    ///    the type in `C` must be compatible with both of them.)
+    /// 2b. If one sides is mutable, and its type is not assignable to the immutable side&#x27;s type.
+    ///    (Because the type in `C` must be compatible with the mutable side.)
+    /// 2c. If both sides are immutable, and their types are disjoint. (Because the type in `C`
+    ///    must be assignable to both.)
+    /// ```
+    ///
+    /// TODO: Adding support for `closed` and `extra_items` will complicate this.
     pub(crate) fn is_disjoint_from_impl(
         self,
         db: &amp;&#x27;db dyn Db,

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 19:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:416 on 2025-12-18 19:53</div>
            <div class="timeline-body"><p>1addb0bdbd</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 19:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types.rs</code>:4052 on 2025-12-18 19:54</div>
            <div class="timeline-body"><p>Oh that&#x27;s sick, ty. df5bc749a8</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/oconnor663">@oconnor663</a> reviewed on 2025-12-18 19:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/oconnor663">@oconnor663</a> on <code>crates/ty_python_semantic/src/types/typed_dict.rs</code>:348 on 2025-12-18 19:55</div>
            <div class="timeline-body"><p>I replaced 2a/2b/2c with 2/3/4, and that seemed to work: f64830ab4a</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 21:16</div>
            <div class="timeline-body"><p>This mypy_primer hit is in fact a new false positive:</p>
<pre><code>+ openlibrary/plugins/openlibrary/lists.py:89:19: error[invalid-key] Unknown key &quot;key&quot; for TypedDict `AnnotatedSeedDict`: Unknown key &quot;key&quot;
</code></pre>
<p>Previously <a href="https://github.com/internetarchive/openlibrary/blob/ee5541d5a9fce74a60a6f6685c519b1c271832c8/openlibrary/plugins/openlibrary/lists.py#L89">the type of <code>seed</code> on this line</a> was <code>(ThingReferenceDict &amp; ~str) | (AnnotatedSeedDict &amp; ~str)</code>, which I guess(?) dodged our check that <code>[&quot;key&quot;]</code> matches a field name in all of the possible <code>TypedDict</code>s. As of this PR, that simplifies to <code>ThingReferenceDict | AnnotatedSeedDict</code>, which does get checked, and we complain that <code>&quot;key&quot;</code> isn&#x27;t a valid field name for <code>AnnotatedSeedDict</code>. ~~What we&#x27;re missing is that the previous <code>elif &#x27;thing&#x27; in seed</code> check was guaranteed to match <code>AnnotatedSeedDict</code>, so in fact the type of <code>seed</code> here should be just <code>ThingReferenceDict</code>, which makes <code>[&quot;key&quot;]</code> valid. I think my follow-up work on union simplification is likely to help with this, and a minimized version of this will make a good test case for it.~~</p>
<p>Edit: This is mistaken, see the next comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 21:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-18 21:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-12-18 21:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-19 17:56</div>
            <div class="timeline-body"><p>Hmm, actually my comment above is mistaken. <code>elif &#x27;thing&#x27; in seed</code> <em>looks</em> like it should narrow the union to <code>AnnotatedSeedDict</code>, but unfortunately these <code>TypedDict</code>s are <code>closed=False</code> (the default and the only option prior to Python 3.15), which means that <code>ThingReferenceDict</code> is <em>allowed</em> to contain the key <code>&#x27;thing&#x27;</code>. Concretely, it could&#x27;ve been assigned to with another <code>TypedDict</code> type that has all of these fields put together. This error is actually a true positive, which is the main motivating case for adding the <code>closed</code> feature: https://peps.python.org/pep-0728/#disallowing-extra-items-explicitly</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:21:52 UTC
    </footer>
</body>
</html>
