<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] optimize building large unions of literals - astral-sh/ruff #17403</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] optimize building large unions of literals</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/17403">#17403</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-04-15 01:28
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2025-04-15 01:28</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Special-case literal types in <code>UnionBuilder</code> to speed up building large unions of literals.</p>
<p>This optimization is extremely effective at speeding up building even a very large union (it improves the large-unions benchmark by 41x!). The problem we can run into is that it is easy to then run into another operation on the very large union (for instance, narrowing may add it to an intersection, which then distributes it over the intersection) which is still slow.</p>
<p>I think it is possible to avoid this by extending this optimized &quot;grouped&quot; representation throughout not just <code>UnionBuilder</code>, but all of our union and intersection representations. I have some work in this direction, but rather than spending more time on it right now, I'd rather just land this much, along with a limit on the size of these unions (to avoid building really big unions quickly and then hitting issues where they are used.)</p>
<h2>Test Plan</h2>
<p>Existing tests and benchmarks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-04-15 01:38</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2025-04-15 01:42</div>
            <div class="timeline-body"><!-- __CODSPEED_PERFORMANCE_REPORT_COMMENT__ -->

<!-- __CODSPEED_INSTRUMENTATION_PERFORMANCE_REPORT_COMMENT__ -->

<h2><a href="https://codspeed.io/astral-sh/ruff/branches/cjm%2Fbigunions3">CodSpeed Performance Report</a></h2>
<h3>Merging #17403 will <strong>improve performances by ×41</strong></h3>
<p><sub>Comparing <code>cjm/bigunions3</code> (a99bdc3) with <code>main</code> (13ea4e5)</sub></p>
<h3>Summary</h3>
<p><code>⚡ 1</code> improvements<br />
<code>✅ 32</code> untouched benchmarks</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>BASE</code> | <code>HEAD</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ⚡ | <code>red_knot_micro[many_string_assignments]</code> | 3,211.2 ms | 79 ms | ×41 |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @AlexWaygood on 2025-04-15 09:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2025-04-15 09:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @carljm on 2025-04-16 01:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2025-04-16 01:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @carljm on 2025-04-16 01:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @carljm on 2025-04-16 01:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:191 on 2025-04-16 06:54</div>
            <div class="timeline-body"><p>Maybe</p>
<pre><code class="language-suggestion">                            UnionElement::IntLiterals(literals) =&gt; {
                                Type::IntLiteral(*literals.first().unwrap())
                            }
                            UnionElement::StringLiterals(literals) =&gt; {
                                Type::StringLiteral(*literals.first().unwrap())
                            }
                            UnionElement::BytesLiterals(literals) =&gt; {
                                Type::BytesLiteral(*literals.first().unwrap())
                            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> approved on 2025-04-16 07:04</div>
            <div class="timeline-body"><p>This looks great, thanks. The fact that we now show union elements grouped by literal type also seems like a UX improvement, even if we potentially disrupt the original source code order. It seems unlikely that someone wants to preserve the order of <code>Literal[1] | Literal[&quot;a&quot;] | Literal[2]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-04-16 07:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:113 on 2025-04-16 07:05</div>
            <div class="timeline-body"><p>Slightly disappointing that we can't use something like the following here (you might have tried as well). Doesn't work with the <code>FxHasher</code>, for some reason.</p>
<pre><code class="language-suggestion">                    self.elements.push(UnionElement::StringLiterals([literal].into()));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:113 on 2025-04-16 09:38</div>
            <div class="timeline-body"><p>This <em>does</em> compile, however:</p>
<pre><code class="language-suggestion">                    self.elements
                        .push(UnionElement::StringLiterals(FxOrderSet::from_iter([
                            literal,
                        ])));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:135 on 2025-04-16 09:42</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                    self.elements
                        .push(UnionElement::BytesLiterals(FxOrderSet::from_iter([
                            literal,
                        ])));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:157 on 2025-04-16 09:42</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                    self.elements
                        .push(UnionElement::IntLiterals(FxOrderSet::from_iter([
                            literal,
                        ])));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:191 on 2025-04-16 09:44</div>
            <div class="timeline-body"><p>or even</p>
<pre><code class="language-suggestion">                            UnionElement::IntLiterals(literals) =&gt; Type::IntLiteral(literals[0]),
                            UnionElement::StringLiterals(literals) =&gt; {
                                Type::StringLiteral(literals[0])
                            }
                            UnionElement::BytesLiterals(literals) =&gt; {
                                Type::BytesLiteral(literals[0])
                            }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-04-16 09:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-04-16 13:05</div>
            <div class="timeline-body"><blockquote>
<p>will <strong>improve performances by ×41</strong></p>
</blockquote>
<p>I guess that's <em>pretty</em> good...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 13:21</div>
            <div class="timeline-body"><p>I think a lot of the logic below would become simpler if this was expanded out into four separate fields:</p>
<pre><code class="language-suggestion">    elements: Vec&lt;Type&lt;'db&gt;&gt;,
    int_literals: FxOrderSet&lt;i64&gt;,
    string_literals: FxOrderSet&lt;StringLiteralType&lt;'db&gt;&gt;,
    bytes_literals: FxOrderSet&lt;BytesLiteralType&lt;'db&gt;&gt;,
</code></pre>
<p>That would come at the cost of <code>UnionBuilder</code> having to store the three <code>FxOrderSet</code>s even if the union being built doesn't contain any literals of that type — but that would only be temporary, since they would disappear as part of building the final <code>Type</code>.</p>
<p>It would also mean a fixed ordering for the elements of the resulting union (depending on which order you visit the fields in <code>build</code>). That is, e.g., all ints before all strings before all bytes before other types. With the current approach, literals of each type will be grouped together, and the ordering of the types will depend on the order when the first literal of each type is added to the builder. (I don't think either is necessarily better than the other, just calling out a ramification of this suggestion.)</p>
<hr />
<p>A third alternative, which I mentioned briefly in Discord, would be to have a separate field for all literals, keyed by their supertype:</p>
<pre><code class="language-rust">    elements: Vec&lt;Type&lt;'db&gt;&gt;,
    literals: FxOrderMap&lt;Type&lt;'db&gt;, FxOrderSet&lt;Type&lt;'db&gt;&gt;&gt;,
</code></pre>
<p>That would also simplify e.g. the <code>add</code> logic below, since instead of iterating through <code>elements</code> looking for an existing <code>StringLiterals</code>, you would use <code>entry</code> and <code>or_default</code> to create the string literal set if needed.</p>
<p>This version would retain the &quot;types ordered by insertion&quot; property of the current approach, and (I think) is the representation we would want to extend this logic to enum types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:38 on 2025-04-16 13:21</div>
            <div class="timeline-body"><p>Excellent writeup</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-16 13:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-16 13:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 13:48</div>
            <div class="timeline-body"><p>Yes, I considered both of those representations, and they would have some advantages, but I decided against them for the reason you noted: we aim to preserve order of user-provided unions (on a best-effort basis, assuming the union does not simplify). We preferably don't want the user to write <code>Literal[1] | None</code> and then we repeat back to them <code>None | Literal[1]</code>. The implementation I chose preserves this property (except for grouping same-kind literals, which I think is more acceptable and generally an improvement), and I think remains reasonably straightforward. I think this implementation can also be extended to enums via a new variant of <code>UnionElement</code> which holds both the enum super-type as well as a set of all the present enum members.</p>
<p>We could decide that preserving order of user-authored unions is not that important, and it's more important to gain the advantages of another implementation. But I didn't see a strong case for that at this point.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 13:51</div>
            <div class="timeline-body"><p>Will go ahead and merge this for now, happy to revisit in another PR if you see sufficiently strong reasons to prefer an alternative.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-16 13:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-16 13:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 13:54</div>
            <div class="timeline-body"><blockquote>
<p>Will go ahead and merge this for now, happy to revisit in another PR if you see sufficiently strong reasons to prefer an alternative.</p>
</blockquote>
<p>The third alternative has this property too (since it uses <code>FxOrderMap</code> for the outer map), but I'm also okay with merging this as-is</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-16 13:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 13:54</div>
            <div class="timeline-body"><blockquote>
<p>The third alternative has this property too (since it uses <code>FxOrderMap</code> for the outer map), but I'm also okay with merging this as-is</p>
</blockquote>
<p>Ohh, although then you don't have that property relative to the non-literal elements.  Never mind, merge away!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-04-16 13:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 13:54</div>
            <div class="timeline-body"><p>In terms of linear-scan vs O(1) finding of the right hash-set for a certain literal kind, I'm essentially banking on the theory that this is fine because unions will remain small outside of literal types, and we have to do this for every other type anyway. If that theory is challenged in practice, we would need to adjust.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-04-16 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-04-16 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-04-16 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-04-16 14:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:55 on 2025-04-16 14:00</div>
            <div class="timeline-body"><blockquote>
<p>In terms of linear-scan vs O(1) finding of the right hash-set for a certain literal kind, I'm essentially banking on the theory that this is fine because unions will remain small outside of literal types, and we have to do this for every other type anyway. If that theory is challenged in practice, we would need to adjust.</p>
</blockquote>
<p>Agreed! To clarify, I was less worried about the linear scan because of performance, and more because of code readability.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 19:33:28 UTC
    </footer>
</body>
</html>
