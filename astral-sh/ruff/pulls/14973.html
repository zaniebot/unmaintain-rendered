<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Emit an error if a bare `Annotated` or `Literal` is used in a type expression - astral-sh/ruff #14973</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Emit an error if a bare <code>Annotated</code> or <code>Literal</code> is used in a type expression</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14973">#14973</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-12-14 18:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-14 18:15</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>These are both invalid annotations (the special forms <em>must</em> be parameterized -- <code>Literal</code> requires at least one argument, and <code>Annotated</code> at least two) but we currently don't emit errors on them:</p>
<pre><code class="language-py">from typing import Literal, Annotated

x: Literal
y: Annotated
</code></pre>
<p>This PR fixes that by modifying <code>Type::in_type_expression</code> to return a <code>Result</code>. The <code>Ok</code> variant of the result is a <code>Type</code>, and the <code>Err</code> variant is an error struct that wraps:</p>
<ul>
<li>the necessary information for emitting a diagnostic from the <code>TypeInferenceBuilder</code></li>
<li>the type that we should fallback to in the event of an error</li>
</ul>
<h2>Test Plan</h2>
<p>New mdtests added, and TODOs in existing mdtests have been fixed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-12-14 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-12-14 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-12-14 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @AlexWaygood on 2024-12-14 18:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-14 18:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/literal.md</code>:1 on 2024-12-14 18:17</div>
            <div class="timeline-body"><p>I moved this file from <code>resources/mdtest/literal/literal.md</code> to <code>resources/mdtest/annotations/literal.md</code>. That's where I expected to find it -- the other tests in the <code>resources/mdtest/literal</code> folder are all to do with checking we accurately infer types for objects created using Python literals -- <code>ast::Dict</code> expressions, etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-14 18:25</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-14 18:56</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md</code>:44 on 2024-12-14 18:56</div>
            <div class="timeline-body"><p>Or alternatively we could infer <code>Unknown</code> for the entire annotation if there's a single invalid sub-element in the type expression</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md</code>:44 on 2024-12-14 19:39</div>
            <div class="timeline-body"><p>I think what you have here is fine.</p>
<p>I had to think for a minute about whether it's even correct to map a union in a type expression (I mean not syntactically a pipe-union syntactic form directly in the type expression, but a name which evalues to a union type) to a union type in this way, but I think it's harmless and sort of automatically provides support for implicit type aliases like <code>X = int | str</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2070 on 2024-12-14 19:40</div>
            <div class="timeline-body"><p>Any reason not to use a boxed array here, since it should be immutable after construction?</p>
<pre><code class="language-suggestion">    invalid_expressions: Box&lt;[InvalidTypeExpression]&gt;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-14 19:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/annotations/annotated.md</code>:44 on 2024-12-14 19:41</div>
            <div class="timeline-body"><p>I should also add another test that just uses a bizarre annotation like <code>x: Annotated | bool</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4653 on 2024-12-14 19:45</div>
            <div class="timeline-body"><p>I feel like I slightly prefer the pattern we use in <code>CallOutcome</code> etc, where we have a method on the result type (or could just be on the error variant) that takes in a DiagnosticsBuilder and a node and emits the right diagnostics, returning the fallback type. This makes handling the result a bit more ergonomic (though you do have to explicitly pass in the diagnostics builder), and it prevents proliferating <code>infer_*</code> methods in <code>TypeInferenceBuilder</code> (which is already too large) that don't really fit the pattern of &quot;infer a type for an AST node.&quot;</p>
<p>I realize this means passing AST nodes into <code>types.rs</code>, but I see the result/outcome types as kind of an intermediate layer between type inference builder and <code>Type</code> operations, that brings together nodes, diagnostics, and type operation results. I already moved <code>CallOutcome</code> out of <code>types.rs</code>; we could move more of those result/outcome types out of <code>types.rs</code> to clarify this layering.</p>
<p>This is all kind of musing, though; open to arguments for the pattern you used here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-12-14 19:45</div>
            <div class="timeline-body"><p>Nice!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-14 20:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:2070 on 2024-12-14 20:05</div>
            <div class="timeline-body"><p>I went for a <code>Vec</code> because it's slightly simpler to use (less punctuation in the annotations, you don't need the <code>.into_boxed_slice()</code> call to convert from the <code>Vec</code> into the boxed slice, etc), and I doubt the space savings from using a boxed slice would lead to a significant speedup since it's not like we're storing this array in a cache for any significant amount of time: the array is consumed almost as soon as it's constructed.</p>
<p>However, even better than either a Vec or a boxed slice might be a SmallVec, as then we could avoid allocating in most situations! By far the most common situation is likely to be that only a single diagnostic needs to be emitted</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-15 02:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4653 on 2024-12-15 02:00</div>
            <div class="timeline-body"><p>I do feel like a <code>Result</code> works really well here. There really are only two possibilities -- either it's okay, and we don't need to emit a diagnostic, or it isn't, and we do. If I were to write a custom <code>*Outcome</code>-like enum here, I think it would end up looking exactly like <code>Result</code>, so reinventing the wheel feels a little silly. And I just don't know what I'd call the enum ðŸ˜†</p>
<p>But I totally take the point that the logic for unwrapping the error struct into a type (and emitting a diagnostic in the process) doesn't need to be on the <code>TypeInferenceBuilder</code>. I've moved it into an <code>InvalidTypeExpressionError::into_fallback_type()</code> method instead. I agree it's much nicer that way, and means we'll be able to easily move the enum into another submodule in the future if we want to.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2024-12-15 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-12-15 02:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-12-15 02:00</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 20:42:57 UTC
    </footer>
</body>
</html>
