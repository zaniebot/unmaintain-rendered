<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Remove `Type::Unbound` - astral-sh/ruff #13980</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Remove <code>Type::Unbound</code></h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13980">#13980</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-10-29 16:36
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-10-29 16:36</div>
            <div class="timeline-body"><!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<ul>
<li>Remove <code>Type::Unbound</code></li>
<li>Handle (potential) unboundness as a concept orthogonal to the type system (see new <code>Symbol</code> type)</li>
<li>Improve existing and add new diagnostics related to (potential) unboundness</li>
</ul>
<p>closes #13671</p>
<h2>Test Plan</h2>
<ul>
<li>Update existing markdown-based tests</li>
<li>Add new tests for added/modified functionality</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2024-10-29 17:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Remove `Type::Unbound`" to "[red-knot] Remove `Type::Unbound`" by @sharkdp on 2024-10-29 19:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-30 15:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md</code>:123 on 2024-10-30 15:34</div>
            <div class="timeline-body"><p>To do: restore original order?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-30 16:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:920 on 2024-10-30 16:10</div>
            <div class="timeline-body"><p>To do</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-30 16:51</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-10-30 20:00</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/david/remove-type-unknown">CodSpeed Performance Report</a></h2>
<h3>Merging #13980 will <strong>improve performances by 4.17%</strong></h3>
<p><sub>Comparing <code>david/remove-type-unknown</code> (13bbeb2) with <code>main</code> (d1189c2)</sub></p>
<h3>Summary</h3>
<p><code>âš¡ 1</code> improvements
<code>âœ… 31</code> untouched benchmarks</p>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>david/remove-type-unknown</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| âš¡ | <code>red_knot_check_file[cold]</code> | 66.1 ms | 63.4 ms | +4.17% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md</code>:83 on 2024-10-30 22:42</div>
            <div class="timeline-body"><p>There should be an error here, but it should be an <code>unsupported-operator</code> error, possibly with the information that <code>Foo.__iadd__</code> may be unbound as additional context. (This could be just a TODO comment in this PR, to be cleaned up when @charliermarsh revisits augmented-assignment to handle unbound dunders.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md</code>:103 on 2024-10-30 22:43</div>
            <div class="timeline-body"><p>There should not be a diagnostic here at all, since the case where <code>__iadd__</code> is unbound should just fall back to <code>__add__</code>. Again, this can just be a TODO comment to be handled separately in fixing up augmented assignment and unbound dunders.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/unbound.md</code>:11 on 2024-10-30 22:45</div>
            <div class="timeline-body"><p>Yes, exactly! This is one of the benefits of removing <code>Unbound</code> as a type; unboundness should not &quot;travel&quot; like a type, it should be resolved (e.g. by emitting a diagnostic and resolving to <code>Unknown</code>) at the point of reference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/unbound.md</code>:21 on 2024-10-30 22:46</div>
            <div class="timeline-body"><p>Yes, agreed - I think it would be too clever here to make that kind of assumption about the intent.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/boolean/short_circuit.md</code>:68 on 2024-10-30 22:48</div>
            <div class="timeline-body"><p>Unrelated, but since we're modifying a lot of assertions around here anyway, let's prefer error codes (there's nothing particularly interesting about this diagnostic message):</p>
<pre><code class="language-suggestion">    # error: [possibly-unresolved-reference]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/exception/basic.md</code>:44 on 2024-10-30 22:59</div>
            <div class="timeline-body"><p>This is pretty subtle; arguably in a Python file (not a type stub), without <code>from __future__ import annotations</code>, if we are checking a Python version prior to 3.9, it would be correct to emit a diagnostic here, because the code will fail at runtime; <code>tuple</code> is not indexable. But since Python 3.8 is already end-of-life, it may not be worth modeling this. Just adding some context here:</p>
<pre><code class="language-suggestion"># TODO: we should not emit these `call-potentially-unbound-method` errors for `tuple.__class_getitem__`
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/scopes/moduletype_attrs.md</code>:123 on 2024-10-31 00:23</div>
            <div class="timeline-body"><p>I don't think there's any need to care about this. The only reason we care about union ordering is when the union originates in a user-provided annotation, we want to preserve that order so if the union then appears in a diagnostic it looks similar to what they wrote. But even that is best-effort only. And in this scenario there's no user-provided or natural order, so whatever falls out of the implementation is fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:40 on 2024-10-31 00:30</div>
            <div class="timeline-body"><p>How do you see the tradeoffs between this representation and</p>
<pre><code class="language-suggestion">    Bound(Type&lt;'db&gt;),
    MaybeBound(Type&lt;'db&gt;),
</code></pre>
<p>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:33 on 2024-10-31 00:31</div>
            <div class="timeline-body"><p>I think &quot;bounded&quot; and &quot;bound&quot; have somewhat different meanings here, so this should be <code>Boundness</code>, not <code>Boundedness</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:54 on 2024-10-31 00:34</div>
            <div class="timeline-body"><p>Looking at the callsites, I think it might be more ergonomic if this method took another <code>SymbolLookupResult</code> instead of taking a <code>Type</code>? The usages seem to consistently follow the form &quot;if this other <code>SymbolLookupResult</code> has a <code>Type</code>, then replace unbound with that, otherwise do nothing&quot; -- this method could just do that internally?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:153 on 2024-10-31 04:01</div>
            <div class="timeline-body"><p>I don't think the semantics of this case are correct.</p>
<p>The intended overall semantics of this whole &quot;has public declarations&quot; case are described in this comment above:</p>
<blockquote>
<p>If the symbol is declared, the public type is based on declarations; otherwise, it's based on inference from bindings.</p>
</blockquote>
<p>So we should always be calling <code>declarations_ty</code> here with whatever declarations the symbol has, and passing in the <code>undeclared_ty</code> (the inferred type from bindings) as fallback for the undeclared, if undeclared is a possibility.</p>
<p>So if <code>undeclared_ty</code> is unbound, that just means we'll take whatever type we get from <code>declarations_ty</code> (we can pass in <code>None</code> for <code>undeclared_ty</code>) and return it as maybe-unbound. But we still need to get the type from the declarations.</p>
<p>(Seems like maybe we also need a test to cover this case; importing a symbol with declarations (e.g. <code>x: int</code>) only in some paths, and no bindings.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:291 on 2024-10-31 04:07</div>
            <div class="timeline-body"><p>Given that this function can only return &quot;bound&quot; or &quot;not bound&quot; (and the latter only in case no bindings are given), I wonder if it should just return <code>Option&lt;Type&lt;'db&gt;&gt;</code> instead of <code>SymbolLookupResult</code>?</p>
<p>Semantically it feels wrong for it to return <code>SymbolLookupResult</code>, because it's not looking up a symbol in a namespace, it's a lower-level function that is just giving us the union of the types of the given definitions (and constraints), which will always be a type if there are any definitions, or not if there are none.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:278 on 2024-10-31 04:08</div>
            <div class="timeline-body"><p>I think this comment (including above lines that I can't directly comment on) will need updating in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:64 on 2024-10-31 04:47</div>
            <div class="timeline-body"><p>Nit: maybe we should import these all from <code>super</code> instead, but let's put this import together with all the other <code>crate::types::</code> imports above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1948 on 2024-10-31 04:52</div>
            <div class="timeline-body"><p>I don't think we'll want to raise a diagnostic here; there are too many cases where we access a class member (e.g. a dunder method) and the caller will want to make its own decision about what diagnostic to raise, or possibly none at all, just fall back. So I think we can remove this TODO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1577 on 2024-10-31 05:06</div>
            <div class="timeline-body"><p>I don't think a <code>call-potentially-unbound-method</code> diagnostic is the desired behavior here; I think we should be falling back to the binary-op behavior below and unioning that with the result of calling the maybe-bound method. If binary-op is not supported then we would raise a diagnostic. I think @charliermarsh was planning to pick that up once this lands.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2418 on 2024-10-31 05:14</div>
            <div class="timeline-body"><p>This seems unnecessary/redundant if we will always call <code>bindings_ty</code>, because the result of calling <code>bindings_ty</code> will also tell us if the name has bindings or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:48 on 2024-10-31 05:21</div>
            <div class="timeline-body"><p>Given that all these methods now return <code>SymbolLookupResult</code>, it seems like we should maybe not do this here anymore? This is basically just unconditionally ignoring maybe-bound state and transforming it to always-bound. Is there any reason not to go ahead and inform the caller accurately if the name is maybe-bound? The caller can still ignore this fact if they want.</p>
<p>(This could be a Todo and investigated as a follow-up, if it looks like the blast radius would be large.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2557 on 2024-10-31 05:36</div>
            <div class="timeline-body"><p>It feels like we might be reinventing <code>replace_unbound_with</code> here? Maybe we should be first building a <code>SymbolLookupResult</code> from <code>may_be_unbound</code> and <code>bindings_ty</code>, and then using <code>replace_unbound_with</code> with the results of <code>self.lookup_name</code>, and then this code might get a bit clearer / more ergonomic? Not sure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2675 on 2024-10-31 05:41</div>
            <div class="timeline-body"><p>It does seem like we may want to find a way to improve the ergonomics of this case, so we don't have to repeat the diagnostic? But we can also make repeating the diagnostic more ergonomic by making it a method on <code>self.diagnostics</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 05:45</div>
            <div class="timeline-body"><p>This is looking really good! I probably gave this a more in-depth review than you were looking for, but hopefully the comments are useful! Let me know if you had higher-level questions I failed to answer in my comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 07:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:64 on 2024-10-31 07:39</div>
            <div class="timeline-body"><p>Yes. I also configured rust-analyzer to do this correctly/consistently in the future by setting <code>imports.prefix</code> to <code>crate</code> instead of <code>plain</code>: https://rust-analyzer.github.io/manual.html#auto-import</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 08:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:40 on 2024-10-31 08:15</div>
            <div class="timeline-body"><p>I started with the flat representation and then later changed it to the nested representation with the inner <code>Boundness</code> enum, mostly because it made pattern matching a little easier in some cases. And in a few places, it is useful to have a dedicated <code>Boundness</code> field that can be used on its own.</p>
<p>Also, I felt like this nested representation would be easier to extend once we add declared-ness as an additional piece of metadata. If we need to handle unbound/possibly-unbound/bound as well as undeclared/possibly-undeclared/declared in a flat representation, that would result in nine variants. Obviously, some of these are not sensible (undeclared &amp; bound, undeclared &amp; possibly-unbound, possibly-undeclared &amp; bound), so maybe the flat representation will be useful after all.</p>
<p>It's not obvious, but the size of <code>SymbolLookupResult</code> is the same in both cases (24 byte). The flat representation needs 16 byte for the <code>Type&lt;â€¦&gt;</code> variant + 8 byte for the enum discriminant, due to alignment restrictions. The largest variant in the nested representation (<code>Type(Type&lt;'db&gt;, Boundness)</code>) is 24 byte in size by its own. However, the compiler uses an optimization where the unused bits in the <code>Boundness</code> field are used for the enum discriminant (niche filling). So the overall size of the nested representation is also just 24 byte.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 08:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:54 on 2024-10-31 08:27</div>
            <div class="timeline-body"><p>There is one call-site which only passes a type, but yes. This suggestion simplifies the other three call sites a lot, thanks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 10:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2557 on 2024-10-31 10:01</div>
            <div class="timeline-body"><p>Hm, not quite. Since we need to return a type here, and <code>replace_unbound_with</code> returns a <code>SymbolLookupResult</code>. I'll look into other way of improving this code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 10:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md</code>:83 on 2024-10-31 10:13</div>
            <div class="timeline-body"><p>Ok, removed the unwanted diagnostic. Added a TODO comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 10:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/augmented.md</code>:103 on 2024-10-31 10:14</div>
            <div class="timeline-body"><p>Removed the unwanted diagnostic. Added a TODO comment in the code; TODO in Markdown is already there (few lines below)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 10:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:40 on 2024-10-31 10:54</div>
            <div class="timeline-body"><p>The flat representation also seemed more obvious to me at first too -- my first instinct would be to do something like this:</p>
<pre><code class="language-rs">enum SymbolLookupResult&lt;'db&gt; {
    /// The symbol is not bound in any code paths.
    ///
    /// All attempts to read the symbol result in a diagnostic.
    /// From the perspective of other expressions and statements,
    /// the symbol has type `Unknown`.
    AlwaysUnbound,

    /// The symbol is bound in some code paths, but not in others;
    /// `bound_ty` gives the type of the symbol in the paths in which it is bound.
    ///
    /// All attempts to read the symbol result in a diagnostic,
    /// but one that conveys less certainty than for symbols
    /// which are always unbound. From the perspective of other expressions
    /// and statements, the symbol has type `bound_ty`.
    PossiblyBound { bound_ty: Type&lt;'db&gt; },

    /// The symbol is bound in all code paths;
    /// reading the symbol never results in a diagnostic.
    AlwaysBound { ty: Type&lt;'db&gt; },
}
</code></pre>
<p>But I can see that the nested representation is much more extensible for the future, when we will also want to incorporate declaredness into <code>SymbolLookupResult</code>.</p>
<p>Throwing yet another option into the mix, did you consider something like this? The disadvantage of it is that there is an &quot;implicit invariant&quot; that <code>bound_ty</code> would always be <code>None</code> if <code>boundedness</code> was <code>Boundedness::Unbound</code>. But it would be highly extensible, since we could simply add <code>declared_ty</code> and <code>declaredness</code> fields later:</p>
<pre><code class="language-rs">enum Boundedness {
    /// The symbol is unbound in all code paths
    AlwaysUnbound,
    /// The symbol is bound in some code paths, unbound in others
    PossiblyBound,
    /// The symbol is bound in all code paths
    AlwaysBound
}

struct SymbolLookupResult&lt;'db&gt; {
    /// The bound type of the symbol.
    ///
    /// If `boundedness is `AlwaysUnbound`, this will be `None`;
    /// else, this will be equivalent to the union of the types
    /// in all code paths where the symbol is bound
    bound_ty: Option&lt;Type&lt;'db&gt;&gt;,

    boundedness: Boundedness,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 10:56</div>
            <div class="timeline-body"><p>I haven't looked at this closely yet, but my overall impression is that this is really exciting! The overall shape looks great. I think it's going to force us to write much more explicit and accurate code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 12:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:48 on 2024-10-31 12:33</div>
            <div class="timeline-body"><p>It looks like the blast radius is zero â€” all tests pass without this replacement logic. I was questioning why this was here and tried to reproduce it faithfully, but I fully agree with the analysis that this should be handled by the callers of this method. In fact, the callers are already forced to handle it with this new approach.</p>
<p>I tried (somewhat hard) to write a test case for this, but haven't succeeded so far. Postponed for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 12:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/exception/basic.md</code>:44 on 2024-10-31 12:43</div>
            <div class="timeline-body"><p>Okay, I changed the TODO message, but I'm not sure how to handle this case for now? Should we add a special case that prevents this diagnostic for <code>tuple.__class_getitem__</code>?</p>
<p>Or leave the TODO because this error will go away when we understand <code>sys.version_info</code> branches here? (and a more precise error will appear for versions &lt; 3.9)</p>
<p>https://github.com/python/typeshed/blob/355abb197eeabc406c3d03b65ff23245e6a38b4e/stdlib/builtins.pyi#L993-L994</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 12:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:40 on 2024-10-31 12:51</div>
            <div class="timeline-body"><blockquote>
<p>Throwing yet another option into the mix, did you consider something like this?</p>
</blockquote>
<p>To be honest: no :smile:. Give up the type-level safety for â€¦ what? Future extensibility... ? It's a bit hard for me to tell what we need here in the future, because I don't know how that declared-ness information will come in eventually. I built a simple solution for what we have now, but I'm open for change proposals, if you think it's something that needs to be addressed here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 12:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:153 on 2024-10-31 12:53</div>
            <div class="timeline-body"><p>You are right, thanks! I added a &quot;Maybe undeclared&quot; test case in <code>mdtest/import/conditional.md</code> (which would fail with my previous version). Please check if this is what you had in mind. I'm not sure if it is correct that no diagnostics are raised?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2024-10-31 12:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2024-10-31 12:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/with/with.md</code>:118 on 2024-10-31 13:24</div>
            <div class="timeline-body"><p>Nit: Most other diagnostics use the wording <code>possibly</code> over <code>potentially</code>. Both sound okay to me but I'm leaning towards the more consistent wording unless there's a specific reason you chose potentially</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:42 on 2024-10-31 13:26</div>
            <div class="timeline-body"><p>Nit: I typically expect that types named <code>Result</code> are aliases of the <code>std::result::Result</code> type which isn't the case. How about <code>SymbolType</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1928 on 2024-10-31 13:30</div>
            <div class="timeline-body"><p>My use of the term symbol has been imprecise in the past and @carljm corrected me many times. do all <code>name</code>s resolve to a symbol? If not, should we rename the <code>SymbolLookupResult</code> type?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1581 on 2024-10-31 13:32</div>
            <div class="timeline-body"><p>Nit: The diff here could be smaller if you used an <code>if let SymbolLookupResult::Type(..)</code> or in combination with an <code>as_type</code> method</p>
<pre><code>if let Some(class_member) = class.class_member(self.db, op.in_place_dunder()).as_type()) {
	...
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1824 on 2024-10-31 13:33</div>
            <div class="timeline-body"><p>Nit: Consider adding a <code>as_type</code> that returns an <code>Option&lt;Type&lt;'db&gt;&gt;</code> to remove the need to ignore the boundness</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-31 13:34</div>
            <div class="timeline-body"><p>Nice. Do we understand where the perf improvement is coming from? Is it because we now create fewer union types?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 13:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/resources/mdtest/with/with.md</code>:118 on 2024-10-31 13:42</div>
            <div class="timeline-body"><p>Will change it to &quot;possibly&quot; everywhere</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:42 on 2024-10-31 13:47</div>
            <div class="timeline-body"><p>I do know what you mean, but &quot;Result&quot; does <em>feel</em> like the most logical word to use here, since it's the result of attempting to lookup a symbol. Elsewhere we used the word &quot;Outcome&quot; for enums like this that represent the &quot;result&quot; of something but are not aliases of <code>std::result::Result</code>... But IIRC the previous feedback was that we didn't like that word either?</p>
<blockquote>
<p>How about <code>SymbolType</code>?</p>
</blockquote>
<p>I don't like this, because this is the convention we use for structs/enums that capture data inside variants of the <code>Type</code> enum (<code>UnionType</code>, <code>StringLiteralType</code>, <code>BytesLiteralType</code>, <code>TupleType</code>, etc.). This enum isn't that; it's very different.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 13:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 14:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1581 on 2024-10-31 14:54</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 15:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:89 on 2024-10-31 15:23</div>
            <div class="timeline-body"><p>I know that @MichaReiser asked for this method and @carljm liked Micha's comment... I worry that this blurs the line between bound symbols and possibly-but-not-necessarily bound symbols. In some ways, possibly-unbound symbols are more similar to unbound symbols than they are similar to always-bound symbols, in that attempts to read them should <em>always</em> cause us to emit a diagnostic. The fact that we currently have a blurred line between possibly-bound and always-bound symbols is exactly what causes the bugs outlined in https://github.com/astral-sh/ruff/issues/14012.</p>
<p>If there are situations where we really need to ignore that a symbol might possibly be unbound, I think I'd honestly prefer to be explicit about that by manually matching on the variants, rather than using this method that collapses it into a binary &quot;either you have a <code>Type</code>, or you don't&quot; enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 15:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:89 on 2024-10-31 15:24</div>
            <div class="timeline-body"><p>(I agree with what you said in standup earlier about merging this PR sooner rather than later to avoid merge conflicts. Don't let this comment block that from happening! This can always be tackled as a followup.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/exception/basic.md</code>:44 on 2024-10-31 15:42</div>
            <div class="timeline-body"><p>I think it's fine to leave it alone for now and let it be resolved by <code>sys.version_info</code> checking.</p>
<p>The real question is whether we want a diagnostic in general in such cases in user code (that can't be resolved to known-False or known-True) -- but I expect such cases are rare, so we don't need to spend a lot of time figuring that out now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 15:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 15:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:89 on 2024-10-31 15:48</div>
            <div class="timeline-body"><p>I actually had the same thought. And considered calling this function something like <code>Symbol::ignore_possibly_unbound</code> instead of the more innocent <code>Symbol::as_type</code>. I'll think about it and probably do a follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/symbol.rs</code>:91 on 2024-10-31 15:57</div>
            <div class="timeline-body"><p>I do think as a follow-up (not in this PR) we should carefully consider the naming of all these APIs.</p>
<p>Currently <code>unwrap_or</code>, <code>unwrap_or_unknown</code>, and <code>as_type</code> all three ignore possibly-unboundness of this symbol (the &quot;other&quot; type in the unwrap methods is only used in case of full-unboundness). And <code>replace_unbound_with</code> ignores possibly-unboundness of the <code>replacement</code> symbol.</p>
<p>I'm not totally confident that any of these choices are right (or if they are right, perhaps the name should clarify the behavior better), but it would require analysis of all the usage sites to reconsider how we should name/structure the APIs. Given this PR generally seems to maintain current behavior reasonably well, I think it makes sense to merge it now to avoid rebase conflicts and then consider this as follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2024-10-31 15:58</div>
            <div class="timeline-body"><p>nit</p>
<pre><code class="language-suggestion">            Some(Symbol::Type(ty, boundness)) =&gt; Symbol::Type(
                declarations_ty(db, declarations, Some(ty)).unwrap_or_else(|(ty, _)| ty),
                boundness,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2024-10-31 16:04</div>
            <div class="timeline-body"><p>I think what boundness value we should apply to a symbol that is declared in some paths (but not all) and bound in some paths (but not all) is pretty tricky and requires further attention in future. Right now here we are always just using the boundness from bindings and ignoring declarations for purposes of boundness, but that's weird, because we only even look at bindings if the symbol may be undeclared, which means in this example:</p>
<pre><code class="language-py">x: int

if flag:
    y: int
else
    y = 3
</code></pre>
<p>If we import from this module, we will currently report <code>x</code> as a definitely-bound symbol (even though it has no bindings at all!) but report <code>y</code> as possibly-unbound (even though every path has either a binding or a declaration for it.)</p>
<p>Possibly the behavior here should differ depending on whether we are importing from a stub or a regular Python module? But an argument could be made that even in a regular Python module, if it declares <code>x: int</code> at module level, we should just trust that and not require that we can see the binding of it.</p>
<p>This is not for this PR to resolve (the conclusion may mean starting to include declaredness info in <code>Symbol</code> as well), but it may be worth a TODO comment here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-31 16:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 16:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:89 on 2024-10-31 16:08</div>
            <div class="timeline-body"><p>I mentioned this in another comment, but this issue isn't specific to <code>as_type</code>. Basically all of the methods on Symbol currently ignore possibly-unboundness in some form.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-31 16:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2675 on 2024-10-31 16:08</div>
            <div class="timeline-body"><p>While I did that, I also found a new case that was not handled correctly. Added a test case:</p>
<pre><code class="language-py">def bool_instance() -&gt; bool:
    return True

if bool_instance():
    x = &quot;abc&quot;

class C:
    if bool_instance():
        x = 1

    # error: [possibly-unresolved-reference]
    y = x

reveal_type(C.y)  # revealed: Literal[1] | Literal[&quot;abc&quot;]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 16:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2024-10-31 16:10</div>
            <div class="timeline-body"><p>heh... I would prefer to rename the <code>Boundness</code> enum to <code>Boundedness</code> ðŸ˜†</p>
<p>but whatever, consistency is the most important thing!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 17:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:153 on 2024-10-31 17:05</div>
            <div class="timeline-body"><p>The test looks good!</p>
<p>I'm not sure if we should emit a diagnostic here or not either :) This gets into the questions I raised in my more recent comment. I will write that up into an issue for future follow-up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 17:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/stdlib.rs</code>:48 on 2024-10-31 17:07</div>
            <div class="timeline-body"><p>I'm not worried about not having a test specifically for this.</p>
<p>Writing a test for it that isn't overly dependent on details of typeshed would probably require a custom typeshed, which is a feature we want to add to mdtest but haven't yet.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 17:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:89 on 2024-10-31 17:17</div>
            <div class="timeline-body"><blockquote>
<p>in that attempts to read them should <em>always</em> cause us to emit a diagnostic</p>
</blockquote>
<p>I don't think this is always true. For example, if <code>__iadd__</code> is possibly unbound we should union its return type with the return type from <code>__add__</code>, and only emit a diagnostic if <code>__add__</code> doesn't exist.</p>
<p>But I do agree that callers should be the ones make the decision about suppressing such diagnostics, and the APIs should be very clear if they do that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 17:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:89 on 2024-10-31 17:21</div>
            <div class="timeline-body"><blockquote>
<p>I don't think this is always true. For example, if <code>__iadd__</code> is possibly unbound we should union its return type with the return type from <code>__add__</code>, and only emit a diagnostic if <code>__add__</code> doesn't exist.</p>
</blockquote>
<p>Right, that's a useful correction. But even here, we still need to account for the possibly-unbound nature and treat it differently to the case where it was definitely bound.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 17:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2675 on 2024-10-31 17:24</div>
            <div class="timeline-body"><p>I don't see this new test case in the PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 17:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2675 on 2024-10-31 17:25</div>
            <div class="timeline-body"><p>Oops, never mind, I see it now; not sure how I missed it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 18:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2024-10-31 18:23</div>
            <div class="timeline-body"><p>Why? To me they have different meanings, and &quot;boundedness&quot; is the wrong meaning.</p>
<p>&quot;Boundedness&quot; means &quot;being bounded&quot;, like having an upper bound or a lower bound on a value.</p>
<p>&quot;Boundness&quot; means &quot;being bound&quot;, as in &quot;bound to a value.&quot;</p>
<p>The meanings are related but to me clearly different.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2024-10-31 18:25</div>
            <div class="timeline-body"><p>Ah, yeah, good points. I should have thought about it more, sorry!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 18:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 18:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:76 on 2024-10-31 18:27</div>
            <div class="timeline-body"><p>No worries, I was just curious if this was a case of &quot;American English is not English&quot; or something else ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-10-31 18:45</div>
            <div class="timeline-body"><p>Oh shoot, sorry for merging https://github.com/astral-sh/ruff/pull/14016 :(</p>
<p>It didn't even occur to me that this would give you more tests to update. I won't merge anymore red-knot PRs until this lands! ðŸ˜„</p>
<p>Edit: And... it looks like you magically fixed a bunch of the TODOs I added in those tests? Thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2024-10-31 19:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2024-10-31 19:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-31 19:05</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:00:09 UTC
    </footer>
</body>
</html>
