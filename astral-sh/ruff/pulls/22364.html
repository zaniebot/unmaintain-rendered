<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Add a second benchmark for enums with many members - astral-sh/ruff #22364</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Add a second benchmark for enums with many members</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/22364">#22364</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2026-01-04 16:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-04 16:06</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Locally, I see a huge performance improvement on the branch for https://github.com/astral-sh/ruff/pull/22363 when running ty on the snippet in https://github.com/astral-sh/ty/issues/1588#issue-3641475502. However, this isn't reflected in the codspeed report for that PR. This suggests that we have some missing coverage in our benchmarks for code that uses huge enums -- which aren't uncommon in Python, especially in generated code.</p>
<p>This PR adds a benchmark based on the snippet in https://github.com/astral-sh/ty/issues/1588#issue-3641475502. If I rebase https://github.com/astral-sh/ruff/pull/22363 on top of this branch that adds the benchmark, I see a performance improvement of 67% on this benchmark from that PR branch.</p>
<h2>Test Plan</h2>
<ul>
<li><code>cargo bench -p ruff_benchmark --bench=ty</code></li>
<li>I checked that the generated code looked how I expected it to look using <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=d33cb2d66693c712f664ac582945b6d1">this Rust playground</a></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2026-01-04 16:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">testing</span> added by @AlexWaygood on 2026-01-04 16:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @AlexWaygood on 2026-01-04 16:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-04 17:20</div>
            <div class="timeline-body"><p>How long does it take to run that benchmark locally? It does seem that the benchmark sharding now becomes somewhat unbalanced (or the enum is larger than it has to be, which makes the benchmark run unnecessarily long)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-04 17:24</div>
            <div class="timeline-body"><blockquote>
<p>How long does it take to run that benchmark locally? It does seem that the benchmark sharding now becomes somewhat unbalanced (or the enum is larger than it has to be, which makes the benchmark run unnecessarily long)</p>
</blockquote>
<p>Yeah, I'll reduce the number of enum members a bit. Obviously you can see from https://github.com/astral-sh/ruff/pull/22363#issuecomment-3708264326 that the followup PR dramatically decreases the amount of time it takes the benchmark to run... but it's still slower than most of our other micro-benchmarks, even with that optimisation applied.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-04 17:25</div>
            <div class="timeline-body"><p>Though FWIW, locally it doesn't feel like it takes noticeably longer to run the <code>many_enum_members_2</code> benchmark compared to <code>many_enum_members</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-04 17:31</div>
            <div class="timeline-body"><blockquote>
<p>Though FWIW, locally it doesn't feel like it takes noticeably longer to run the many_enum_members_2 benchmark compared to many_enum_members</p>
</blockquote>
<p>I'm not suggesting that the issue is with the benchmark. It may mean that we have to reshard the benchmarks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-04 17:42</div>
            <div class="timeline-body"><p>Locally, this benchmark (with the current 64 enum members) takes:</p>
<ul>
<li>94.781 ms on this branch</li>
<li>30.765 ms on the branch for #22363</li>
</ul>
<p>If I reduce the number of enum members to 48, the benchmark takes:</p>
<ul>
<li>46.092 ms on this branch</li>
<li>19.032 ms on the branch for #22363</li>
</ul>
<p>For comparison, our existing <code>many_enum_members</code> benchmark takes 15.209 ms for me locally.</p>
<p>I'm happy to reduce the number of enum members or look at adjusting the sharding, whatever you'd prefer!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-04 17:51</div>
            <div class="timeline-body"><p>The codspeed numbers will look very different because instrumentation benchmarks take much longer to run (it takes 700ms for your new benchmark according to their own metric, I'm not sure this maps directly to walltime in CI).</p>
<p>Reducing the benchmark to 48 elements seems a good start to me. It still demonstrates the performance improvement without taking unnecessarily long to run. We can consider resharding later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2026-01-04 17:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2026-01-04 17:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2026-01-04 17:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2026-01-04 17:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 16:36:43 UTC
    </footer>
</body>
</html>
