<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] inferred type, not Unknown, for undeclared paths - astral-sh/ruff #13400</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] inferred type, not Unknown, for undeclared paths</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13400">#13400</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-09-18 22:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 22:44</div>
            <div class="timeline-body"><p>After looking at more cases (for example, the case in the added test in this PR), I realized that our previous rule, &quot;if a symbol has any declarations, use only declarations for its public type&quot; is not adequate. Rather than using <code>Unknown</code> as fallback if the symbol is not declared in some paths, we need to use the inferred type as fallback in that case.</p>
<p>For the paths where the symbol <em>was</em> declared, we know that any bindings must be assignable to the declared type in that path, so this won't change the overall declared type in those paths. But for paths where the symbol wasn't declared, this will give us a better type in place of <code>Unknown</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-09-18 22:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-09-18 22:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-18 22:58</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-09-18 23:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-09-19 02:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-09-19 04:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-09-19 04:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-19 04:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-09-19 06:00</div>
            <div class="timeline-body"><blockquote>
<p>After looking at more cases (for example, the case in the added test in this PR), I realized that our previous rule, &quot;if a symbol has any declarations, use only declarations for its public type&quot; is not adequate. Rather than using Unknown as fallback if the symbol is not declared in some paths, we need to use the inferred type as fallback in that case.</p>
</blockquote>
<p>Could you share some of those examples? It would be helpful if we look back to this PR in a few weeks and wonder why we changed it the way we did</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-19 06:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:202 on 2024-09-19 06:02</div>
            <div class="timeline-body"><p>Is it now possible that we emit one extra error if the <code>undeclared_ty</code> is not compatible with any of the declared ty?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-19 17:47</div>
            <div class="timeline-body"><blockquote>
<p>Could you share some of those examples? It would be helpful if we look back to this PR in a few weeks and wonder why we changed it the way we did</p>
</blockquote>
<p>I think the test I added summarizes the essential character of all the cases I considered; it's just the scenario where a name is only conditionally declared in a module, but is always bound, and then you import that name from another module.</p>
<p>(I wasn't looking at cases like this in real code, so I don't have those to point to, though I'm sure they exist. These were just additional cases I was thinking through after running into the real case in typeshed where a name is imported in one path and declared in another.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 17:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:202 on 2024-09-19 17:51</div>
            <div class="timeline-body"><p>That was already (intentionally) the case before, it's just that before <code>undeclared_ty</code> was hardcoded to <code>Unknown</code>. And <code>Unknown</code> is not equivalent to any other type, so it was already previously guaranteed to be an error if you tried assigning to a name that had been declared in one path but not in another.</p>
<p>Also, there are two cases where we check the declared type. One is for the public type (e.g. importing a symbol); this use case doesn't care if there are conflicts (that's not a problem the importing module cares about, it will just take the union and go with it). And this use case is the only one that now sets <code>undeclared_ty</code> to the inferred type.</p>
<p>The other use case is in <code>add_binding</code> to decide if an assignment is allowed. That's the only one that emits a diagnostic if there are conflicts. And that use case didn't change at all in this PR, it still always sets <code>undeclared_ty</code> to <code>Unknown</code> (the only difference is that that moved out of this function and into <code>add_binding</code>.)</p>
<p>So there's no change in this PR to what diagnostics will be emitted due to conflicting declared types.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:30:59 UTC
    </footer>
</body>
</html>
