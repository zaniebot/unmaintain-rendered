<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red knot] add `Type::is_disjoint_from` and intersection simplifications - astral-sh/ruff #13775</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red knot] add <code>Type::is_disjoint_from</code> and intersection simplifications</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13775">#13775</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-10-16 12:12
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-10-16 12:12</div>
            <div class="timeline-body"><h2>Summary</h2>
<ul>
<li>Add <code>Type::is_disjoint_from</code> as a way to test whether two types overlap</li>
<li>Add a first set of simplification rules for intersection types<ul>
<li><code>S &amp; T = S</code> for <code>S &lt;: T</code></li>
<li><code>S &amp; ~T = Never</code> for <code>S &lt;: T</code></li>
<li><code>~S &amp; ~T = ~T</code> for <code>S &lt;: T</code></li>
<li><code>A &amp; ~B = A</code> for <code>A</code> disjoint from <code>B</code></li>
<li><code>A &amp; B = Never</code> for <code>A</code> disjoint from <code>B</code></li>
<li><code>bool &amp; ~Literal[bool] = Literal[!bool]</code></li>
</ul>
</li>
</ul>
<p>resolves one item in astral-sh/ty#245</p>
<h2>Open questions:</h2>
<ul>
<li>Can we somehow leverage the (anti) symmetry between <code>positive</code> and <code>negative</code> contributions? I could imagine that there would be a way if we had <code>Type::Not(type)</code>/<code>Type::Negative(type)</code>, but with the <code>positive</code>/<code>negative</code> architecture, I'm not sure. Note that there is a certain duplication in the <code>add_positive</code>/<code>add_negative</code> functions (e.g. <code>S &amp; ~T = Never</code> is implemented twice), but other rules are actually not perfectly symmetric: <code>S &amp; T = S</code> vs <code>~S &amp; ~T = ~T</code>.</li>
<li>I'm not particularly proud of the way <code>add_positive</code>/<code>add_negative</code> turned out. They are long imperative-style functions with some mutability mixed in (<code>to_remove</code>). I'm happy to look into ways to improve this code <em>if we decide to go with this approach</em> of implementing a set of ad-hoc rules for simplification.</li>
<li>~~Is it useful to perform simplifications eagerly in <code>add_positive</code>/<code>add_negative</code>? (@carljm)~~ This is what I did for now.</li>
</ul>
<h2>Test Plan</h2>
<ul>
<li>Unit tests for <code>Type::is_disjoint_from</code></li>
<li>Observe changes in Markdown-based tests</li>
<li>Unit tests for <code>IntersectionBuilder::build()</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @sharkdp on 2024-10-16 12:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-16 12:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:479 on 2024-10-16 12:18</div>
            <div class="timeline-body"><p>There are 18 enum variants in <code>Type</code>, so 18 × 18 = 324 cases to cover. <code>is_disjoint_from</code> is symmetric, so in principle it's only one triangular part of the matrix, but that still leaves 171 cases. Not sure this is the best way to structure them...</p>
<p>I also tried nested <code>match</code> statements, but that makes the symmetry less clear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-16 12:26</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 11:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:598 on 2024-10-17 11:28</div>
            <div class="timeline-body"><p>I'm playing things save here, since</p>
<pre><code class="language-rs">!class_type.is_known(db, KnownClass::Int)
</code></pre>
<p>would potentially be wrong here, I assume? There might be a subclass of <code>int</code>, in which case instances of that subclass would potentially overlap with an <code>IntLiteral</code>.</p>
<p>And using something like</p>
<pre><code class="language-rs">ty@Type::Instance(..) =&gt; !ty.is_subtype_of(KnownClass::Bool.to_instance(db))
</code></pre>
<p>is dangerous, since <code>is_subtype_of</code> can return false-negative answers (return <code>false</code> for types that are not actually subtypes of each other).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 11:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:548 on 2024-10-17 11:29</div>
            <div class="timeline-body"><p>Is this save? My thinking was that <code>NoneType</code> can't be subclassed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 11:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:572 on 2024-10-17 11:30</div>
            <div class="timeline-body"><p>Same question here. <code>bool</code> is also final.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:548 on 2024-10-17 11:35</div>
            <div class="timeline-body"><p><code>NoneType</code> is however a subclass of <code>object</code>, so <code>Type::Instance(builtins.object)</code> is not disjoint from <code>Type::None</code></p>
<pre><code class="language-pycon">&gt;&gt;&gt; type(None).__mro__
(&lt;class 'NoneType'&gt;, &lt;class 'object'&gt;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:572 on 2024-10-17 11:36</div>
            <div class="timeline-body"><p>Same issue here. <code>Literal[True]</code> is a subtype of <code>bool</code>, but <code>bool</code> is a subtype of <code>object</code> (all classes in Python are subclasses of <code>object</code>, either explicitly or implicitly)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:598 on 2024-10-17 11:37</div>
            <div class="timeline-body"><p>I don't think subclasses of <code>int</code> are an issue here. An instance of an <code>int</code> subclass cannot be considered an <code>IntLiteral</code>; only an object <code>o</code> where <code>o.__class__ == int</code> can be considered an <code>IntLiteral</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 11:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:352 on 2024-10-17 11:38</div>
            <div class="timeline-body"><p>I didn't bother trying to integrate this with the new simplification logic, as I saw that there is a plan to remove <code>Type::Unbound</code> (#13671)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 11:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:228 on 2024-10-17 11:41</div>
            <div class="timeline-body"><p>This was certainly more efficient before. There are certainly ways to improve performance of <code>add_positive</code>/<code>add_negative</code>. Is it something I should look into now, or is it okay to postpone that to the point were the runtime of intersection-type-simplification becomes a problem (if ever).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 11:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 11:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:598 on 2024-10-17 11:44</div>
            <div class="timeline-body"><p>This is spec'd here: https://typing.readthedocs.io/en/latest/spec/literal.html#equivalence-of-two-literals</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:598 on 2024-10-17 12:37</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 12:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @sharkdp on 2024-10-17 12:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2024-10-17 12:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2024-10-17 12:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 12:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:551 on 2024-10-17 12:42</div>
            <div class="timeline-body"><p>Or maybe:</p>
<pre><code class="language-suggestion">                Type::Instance(class_type) =&gt; !matches!(
                    class_type.known(db),
                    Some(KnownClass::NoneType | KnownClass::Object)
                )
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 12:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:552 on 2024-10-17 12:59</div>
            <div class="timeline-body"><p>It seems like this is actually fewer lines (and has exhaustiveness verified at compile time, which is nice) if you do it without the inner <code>match</code>. It <em>does</em> feel less readable to do it that way, though, so I'm not sure if it's worth it:</p>
<pre><code class="language-suggestion">            (Type::None, Type::None) =&gt; false,
            (Type::None, Type::Instance(class)) | (Type::Instance(class), Type::None) =&gt; !matches!(
                class.known(db),
                Some(KnownClass::NoneType | KnownClass::Object)
            ),
            (
                Type::None,
                Type::IntLiteral(_)
                | Type::BooleanLiteral(_)
                | Type::StringLiteral(..)
                | Type::LiteralString
                | Type::BytesLiteral(..),
            )
            | (
                Type::IntLiteral(_)
                | Type::BooleanLiteral(_)
                | Type::StringLiteral(..)
                | Type::LiteralString
                | Type::BytesLiteral(..),
                Type::None,
            ) =&gt; true,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 13:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1834 on 2024-10-17 13:02</div>
            <div class="timeline-body"><p>nit: I'd find this slightly more readable</p>
<pre><code class="language-suggestion">        Intersection {
            pos: Vec&lt;Ty&gt;,
            neg: Vec&lt;Ty&gt;,
        },
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 13:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:228 on 2024-10-17 13:04</div>
            <div class="timeline-body"><p>I think the performance of intersections will likely be quite important in the long run (we'll probably create <em>lots</em> of intersections once our model is more fleshed out). That doesn't necessarily mean that we need to micro-optimise the initial implementation, I don't think (we can always iterate to improve performance), but it definitely means we should be mindful of performance at every stage.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 13:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:228 on 2024-10-17 13:15</div>
            <div class="timeline-body"><blockquote>
<p>we'll probably create lots of intersections once our model is more fleshed out</p>
</blockquote>
<p>but will we also create <em>large</em> intersections? Since we have this eager approach now where we simplify immediately, what would be an example for an intersection type that would grow large (&gt;= 3 elements)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-17 13:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:228 on 2024-10-17 13:17</div>
            <div class="timeline-body"><p>Good question! Not really sure how this is going to play out, in all honesty. Possibly @carljm has a better answer for you here :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-17 13:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:552 on 2024-10-17 13:39</div>
            <div class="timeline-body"><p>I think I prefer yours. My eyes hurt a bit, but it's good to get rid of the <code>unreachable!(…)</code>s.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:233 on 2024-10-17 20:57</div>
            <div class="timeline-body"><p>Could this use find to exit early?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:255 on 2024-10-17 20:58</div>
            <div class="timeline-body"><p>Nit: add break?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-17 20:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-10-17 22:28</div>
            <div class="timeline-body"><blockquote>
<p>Can we somehow leverage the (anti) symmetry between positive and negative contributions? I could imagine that there would be a way if we had Type::Not(type)/Type::Negative(type), but with the positive/negative architecture, I'm not sure.</p>
</blockquote>
<p>FWIW, I'm quite open to the idea that we discard the positive/negative approach in favor of a <code>Type::Not</code>, if it makes intersection simplification easier.</p>
<p>The downside is we then have to add handling for <code>Type::Not</code> throughout the type system, but I suspect that may actually not be too difficult, since in many places we can just treat it as <code>object</code>, which is less precise but never unsound.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/narrow/conditionals_is.md</code>:9 on 2024-10-17 22:31</div>
            <div class="timeline-body"><p>Love seeing these TODOs go away :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:479 on 2024-10-17 22:34</div>
            <div class="timeline-body"><p>FWIW I think this flat approach is better than nested, and matches what we do elsewhere for binary operations on types. It is a large space to cover (and will only get larger with time), but it helps a lot that we can usually have blanket cases for several types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:524 on 2024-10-17 23:02</div>
            <div class="timeline-body"><p>I think we can't be sure of this, at least not considering types we will support in future, without doing more checks.</p>
<ul>
<li><code>other</code> might be the homogenous arbitrary-length tuple type <code>tuple[T, ...]</code> (which we don't have support for yet); if all of our element types are subtypes of T, this is not disjoint</li>
<li><code>other</code> might be a user subtype of <code>tuple</code>, which, if generic over the same or compatible <code>*Ts</code>, would overlap with <code>Type::Tuple</code></li>
</ul>
<p>Both of these cases involve types we can't yet represent, so in a sense the <code>true</code> here is correct in terms of the types we are currently able to represent. But given that <code>other</code> is wildcard-matched here and we know such types exist in principle and we will support them in future, I think we should replace this <code>true</code> with <code>false</code>, plus a comment outlining the reasons why, and a TODO to actually check these cases, once we have the appropriate types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:541 on 2024-10-17 23:04</div>
            <div class="timeline-body"><p>I'm curious why you use <code>_</code> for <code>BooleanLiteral</code> but <code>..</code> for <code>StringLiteral</code> and <code>BytesLiteral</code>, since all three are length-one tuple variants. Not that it matters, just curious :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:543 on 2024-10-17 23:12</div>
            <div class="timeline-body"><p>For any two types which are both one of <code>None</code>, <code>BooleanLiteral</code>, <code>IntLiteral</code>, <code>StringLiteral</code>, and <code>BytesLiteral</code>, either the two types are identical or they are disjoint. (We can rely on this because Salsa already gives us type interning based on equality for <code>StringLiteralType</code> and <code>BytesLiteralType</code>.)</p>
<p>I think you could have a single case for this, and it would mostly (with the exception of <code>LiteralString</code>) subsume this case, and I think some others below as well?</p>
<p><code>LiteralString</code> should be manageable with a single case checking if the other type is <code>object</code> or <code>str</code>, otherwise it is disjoint.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:479 on 2024-10-17 23:13</div>
            <div class="timeline-body"><p>Do you think it's worth an <code>if self == other { return false }</code> shortcut here? That might simplify some cases below.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:531 on 2024-10-17 23:18</div>
            <div class="timeline-body"><p>Since <code>None</code> is disjoint with every non-union type that isn't <code>None</code> or <code>object</code>, and we already handled unions above, wouldn't this give us more precise results (that is, more correct <code>true</code> results) if we matched with any <code>other</code> type (not only instance types), and then returned <code>false</code> only if <code>other</code> is an <code>Instance</code> of <code>object</code> or <code>NoneType</code>, and otherwise returned <code>true</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:566 on 2024-10-17 23:25</div>
            <div class="timeline-body"><p>I think these two cases would both be subsumed by my suggestion above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:571 on 2024-10-17 23:34</div>
            <div class="timeline-body"><p>Similar comment to the one above about <code>None</code>: since a <code>BooleanLiteral</code> is disjoint from every non-union type that isn't <code>bool</code> or <code>object</code>, can we make this case more general so that it also returns <code>true</code> for all non Instance types?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:581 on 2024-10-17 23:35</div>
            <div class="timeline-body"><p>These would also be subsumed by above comments, I think?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:545 on 2024-10-17 23:35</div>
            <div class="timeline-body"><p>Similar comment as above for <code>None</code> and <code>BooleanLiteral</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:554 on 2024-10-17 23:36</div>
            <div class="timeline-body"><p>Similar as for <code>None</code>, <code>BooleanLiteral</code>, <code>IntLiteral</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:592 on 2024-10-17 23:37</div>
            <div class="timeline-body"><p>Would be subsumed by the general case for literal v literal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:588 on 2024-10-17 23:37</div>
            <div class="timeline-body"><p>Would be subsumed by the general case for literal v literal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:549 on 2024-10-17 23:38</div>
            <div class="timeline-body"><p>I think this would be subsumed by the more general case for <code>LiteralString</code> I suggested above?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:601 on 2024-10-17 23:39</div>
            <div class="timeline-body"><p>This case should be <code>true</code>, I think? The <code>LiteralString</code> type does not include any bytes objects. Would also be subsumed by the general case for <code>LiteralString</code> suggested above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:557 on 2024-10-17 23:40</div>
            <div class="timeline-body"><p>Would be subsumed by a general check for identity up top</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:562 on 2024-10-17 23:41</div>
            <div class="timeline-body"><p>Same comment as for various types above that this could match vs any type, not just <code>Type::Instance</code>; <code>LiteralString</code> is disjoint from any non-union type that is not <code>StringLiteral</code>, <code>str</code>, or <code>object</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:617 on 2024-10-17 23:43</div>
            <div class="timeline-body"><p>I think <code>false</code> is the correct answer here in general, barring at least one of the types being <code>final</code>, since Python allows multiple inheritance. (Could update the TODO to be more specific that <code>final</code> support is all there is left to do?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:228 on 2024-10-17 23:52</div>
            <div class="timeline-body"><p>I suspect intersections will not typically grow too large, because most intersections will come from type narrowing, and it would require a lot of nested conditionals to grow a large intersection this way. I think large unions (particularly of literals) will be more of a problem.</p>
<p>That said, I'm quite sure that at some point down the line, someone will present us with some pathological generated-code monstrosity that manages to create a very large intersection, so I suspect we will have to care to some degree :)</p>
<p>I guess I don't have a super clear answer here; I think we should take obvious opportunities to optimize if they don't cost extra hours/days, and then wait and see what we find with real code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:759 on 2024-10-18 00:15</div>
            <div class="timeline-body"><p>very minor nit: I prefer to use <code>#[test_case]</code> for this kind of thing so they fail or pass independently</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:220 on 2024-10-18 00:25</div>
            <div class="timeline-body"><p>I think this TODO comment is addressed by the new code below and can now be removed. We no longer have the old code that cancels positive vs negative based on <code>Type</code> equality (which was wrong for dynamic types), it's now subsumed by the pos v neg subtype check, which correctly handles dynamic types, since they don't participate in the subtype relation.</p>
<p>It would be good to add a test verifying that <code>Any &amp; ~Any</code> does not simplify to <code>Never</code> (and same for <code>Unknown</code> and <code>Todo</code>).</p>
<p>I think, however, that it should simplify to just <code>Any</code>. Adding <code>Any</code>, <code>Unknown</code>, or <code>Todo</code> to the negative side of an intersection should always just add them to the positive side of the intersection instead. The two are equivalent: &quot;must not be in some unknown set of values&quot; is equivalent to &quot;must be in some unknown set of values&quot;; the one &quot;unknown set of values&quot; is just the complement of the other. Since it's an unknown set anyway, we are free to replace it with its complement. Since this will be an easy change to make, and we want to add a related test anyway, I think we might as well add it to this PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:225 on 2024-10-18 00:41</div>
            <div class="timeline-body"><p>With the elimination of this code, I don't think we anymore depend on set operations (or <code>Type</code> equality at all) for <code>positive</code> or <code>negative</code>. Should we just make them vectors instead (like we already did for union elements), since that's lighter weight? In general we should be using semantic <code>Type</code> operators (<code>is_subtype_of</code>, <code>is_disjoint_from</code>) rather than simple <code>Type</code> object equality to make most decisions about intersection simplification anyway.</p>
<p>It might require one additional check to avoid adding exactly the same type to the positive or negative side that is already there, but that's a one-line check, we don't need all the <code>IndexSet</code> overhead for that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:242 on 2024-10-18 00:45</div>
            <div class="timeline-body"><p>I hadn't really processed from reading the tests below that in some of these cases the pairwise simplification also means we can eliminate anything else that's in the intersection; would it make sense to add cases with &quot;third types&quot; in the below tests to show explicitly which cases do or don't allow that simplification?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:236 on 2024-10-18 00:46</div>
            <div class="timeline-body"><p>Since either one is easy to do, which is cheaper, replacing <code>self</code> entirely or clearing <code>self.positive</code> and <code>self.negative</code>? Does the former have to allocate a new pair of <code>IndexSet</code> on the heap, and the latter not? (Maybe creating an empty <code>IndexSet</code> doesn't allocate anything on the heap until you add the first element, in which case we'd really only allocate once here.)</p>
<p>Same question applies to wherever we replace <code>*self</code> in this test.</p>
<p>(I don't think it's worth putting time into benchmarking or researching this at this point, just asking the question in case those of you with more Rust experience have an immediate intuition about it.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:255 on 2024-10-18 00:52</div>
            <div class="timeline-body"><p>It's possible that the new positive is a subtype of more than one existing element in the intersection, which themselves have no subtype relationship to each other. In this case we can remove more than one.</p>
<p>However, I don't think we can exercise that case yet, because I think it only occurs with multiple inheritance (or even more advanced types like Protocol), which would require proper <code>is_subtype_of</code> support for <code>Type::Instance</code>, which in turn would require MRO. Maybe a TODO to support this scenario?</p>
<p>Until we do, breaking here makes sense.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:276 on 2024-10-18 00:59</div>
            <div class="timeline-body"><p>Similar comment here: it is possible for two types to already be in <code>self.negative</code>, and the new positive type to be disjoint from both of them. In this case we should remove all the existing negative types that are disjoint from the new positive type.</p>
<p>This case I think we can easily test with existing types: if <code>self.negative</code> already has two different <code>IntLiteral</code> in it and we add a different <code>IntLiteral</code> to <code>positive</code>, for example.</p>
<p>One implementation thought: presuming this suggests using a vector for <code>to_remove</code>, we could consider <code>smallvec</code> backed by a length-1 array to avoid heap allocation in the typical 0-or-1 cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:289 on 2024-10-18 00:59</div>
            <div class="timeline-body"><p>Similarly I think this comment can be removed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:315 on 2024-10-18 01:03</div>
            <div class="timeline-body"><p>Same comment as in other <code>to_remove</code> cases; we can have two different existing negative types, and add a new negative type that is a supertype of both.</p>
<p>This also should be testable now: we have <code>~IntLiteral[1] &amp; ~IntLiteral[2]</code> and we add <code>~int</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> requested changes on 2024-10-18 01:12</div>
            <div class="timeline-body"><p>This is great! I suspect that this approach will carry us a long way; I'm not feeling any particular need to explore more radical approaches. (I'm not 100% sure, but I suspect that the lazy-BDD approach I linked you to may just not be workable anyway for the complexity of Python's type system; particularly inheritance and multiple inheritance.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 08:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:541 on 2024-10-18 08:23</div>
            <div class="timeline-body"><p>Just an oversight. I like to use <code>..</code> for matching on AST/Type enums (even if they have just one element <em>now</em>) because they tend to appear in <em>lots</em> of <code>match</code> statements. If I can be certain that changing the structure of a particular item will not require someone to revisit this pattern, I can make future refactorings easier by using <code>..</code> instead of <code>_</code>, <code>_, _</code>, ….</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 08:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:236 on 2024-10-18 08:37</div>
            <div class="timeline-body"><blockquote>
<p>Since either one is easy to do, which is cheaper, replacing <code>self</code> entirely or clearing <code>self.positive</code> and <code>self.negative</code>?</p>
</blockquote>
<p>In an earlier version on this branch, I used <code>self.positive.clear(); self.negative.clear();</code> everywhere, but then I changed it to <code>*self = Self::new()</code>. Not because it's shorter, but because it seems safer to me. If someone modifies this <code>struct</code> to hold additional members, or wants to enforce additional invariants, they don't have to make sure to reset state properly in N different places.</p>
<blockquote>
<p>Does the former have to allocate a new pair of <code>IndexSet</code> on the heap, and the latter not? (Maybe creating an empty <code>IndexSet</code> doesn't allocate anything on the heap until you add the first element, in which case we'd really only allocate once here.)</p>
</blockquote>
<p>For what it's worth, <a href="https://docs.rs/ordermap/latest/ordermap/map/struct.OrderMap.html#method.new"><code>OrderMap::new()</code></a> does not allocate. It's still true that using <code>.clear()</code> twice might be more efficient here because we could re-use the existing allocations when inserting new elements (later).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:233 on 2024-10-18 09:26</div>
            <div class="timeline-body"><p>That's much better, yes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 09:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 12:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:255 on 2024-10-18 12:47</div>
            <div class="timeline-body"><p>To be honest, I'd rather not <code>break</code> here. I feel it adds a lot of mental overhead and has questionable benefit.</p>
<p>If we add a <code>break</code>, we need to make sure that other — potentially more powerful — simplifications in the same loop (right now, only the <em>&quot;A &amp; B = Never, if A and B are disjoint&quot;</em> rule below) can not trigger <em>in addition</em> to this one. Right now, the only counter-example I can think of would be something like <code>(int &amp; ~Literal[1]) &amp; Never</code>. When we add <code>Never</code> as a third element to the intersection, this <code>new_positive &lt;: existing_positive</code> rule triggers first, because <code>Never &lt;: int</code>, and would lead to a removal of <code>int</code>. However, if we keep going, we would find out that <code>Never</code> and <code>int</code> are also disjoint! This would not just result in a <code>break</code>, but in a <code>return</code>, because we can immediately conclude that the overall result will be <code>Never</code>. We would not just skip this loop, but also the &quot;negative&quot; loop below.</p>
<p>I tried to write a test-case to show that <code>break</code>ing here is wrong, and eventually gave up. The example from above works in both cases (with and without <code>break</code>) because there are other simplifications in the <code>negative</code> branch below. But I'm not sure it invalidates my argument from above. I find it much easier to reason about this code (in the future, if we add more simplifications) if we don't add additional <code>break</code>s.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:524 on 2024-10-18 13:00</div>
            <div class="timeline-body"><p>Thank you. I hope it's okay if I use your explanation almost verbatim as a comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:255 on 2024-10-18 13:04</div>
            <div class="timeline-body"><p>I think it would be good in that case to add a comment why we aren't breaking early. I could see myself come by this code and add the break and then test if there are any failing tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-18 13:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:543 on 2024-10-18 13:12</div>
            <div class="timeline-body"><p>That is a great suggestion — thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:479 on 2024-10-18 13:26</div>
            <div class="timeline-body"><p>It might make some cases unnecessary, but then we would have to add <code>unreachable!(…)</code>, right?</p>
<p>Note: the shortcut leads to the wrong result if <code>self = other = Type::Never</code>, so it would need an additional condition to handle <code>Never</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:531 on 2024-10-18 13:27</div>
            <div class="timeline-body"><p>Changed. And added tests for every possible <code>None</code>-vs-X combination, since it seems particularly important.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:543 on 2024-10-18 13:43</div>
            <div class="timeline-body"><blockquote>
<p><code>LiteralString</code> should be manageable with a single case checking if the other type is <code>object</code> or <code>str</code>, otherwise it is disjoint.</p>
</blockquote>
<p>And we need to handle <code>!is_disjoint_from(LiteralString, StringLiteral(…))</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:549 on 2024-10-18 13:44</div>
            <div class="timeline-body"><p>No, I think this is required.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 13:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:601 on 2024-10-18 13:45</div>
            <div class="timeline-body"><p>Yeah, I don't know what I thought there. Fixed &amp; added test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 15:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:225 on 2024-10-18 15:30</div>
            <div class="timeline-body"><p>I did that change locally. It works fine, but I'm not sure I like it.</p>
<blockquote>
<p>It might require one additional check to avoid adding exactly the same type to the positive or negative side that is already there, but that's a one-line check, we don't need all the <code>IndexSet</code> overhead for that.</p>
</blockquote>
<p>But that's exactly what a set is designed for, right? We don't neet <code>OrderSet</code> — we could also use <code>HashSet</code> (because I assume we do not need to maintain insertion order for intersections, just for unions?). But turning every insertion/pop into an O(n) operation feels wrong. And we would probably want to wrap the <code>Vec</code> in a new datastructure for that, to make sure noone calls <code>.push</code> directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:242 on 2024-10-18 15:31</div>
            <div class="timeline-body"><p>Yes. This particular task is still open.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 15:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 15:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:276 on 2024-10-18 15:32</div>
            <div class="timeline-body"><p>This makes sense. This task is also still open.</p>
<blockquote>
<p>One implementation thought: presuming this suggests using a vector for <code>to_remove</code>, we could consider <code>smallvec</code> backed by a length-1 array to avoid heap allocation in the typical 0-or-1 cases.</p>
</blockquote>
<p>:+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:490 on 2024-10-18 16:04</div>
            <div class="timeline-body"><p>It just occurred to me now on second read-through that this case is incorrect if it comes before the union case, because the union of two <code>Type::Function</code> is not disjoint from one of those same <code>Type::Function</code>.</p>
<p>I think this case is really the same as the <code>None</code> and <code>Literal</code> types case below, and could probably just be merged with it?</p>
<p>Would be good to add a test case that would have caught this (to create a union of function or class types, define them in if/else branches.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:524 on 2024-10-18 16:37</div>
            <div class="timeline-body"><p>Sure, no problem, though I just realized my comment is imprecise:</p>
<blockquote>
<p>if all of our element types are subtypes of T, this is not disjoint</p>
</blockquote>
<p>should be &quot;non-disjoint with T&quot; rather than &quot;subtypes of T&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:225 on 2024-10-18 16:45</div>
            <div class="timeline-body"><p>I think it is already &quot;wrapped&quot; in the <code>IntersectionType</code> / <code>IntersectionBuilder</code>, so I'm not sure we'd need to wrap it again; the intersection builder code is already quite subtle, and a direct push to an internal vector that doesn't go through <code>add_negative</code> / <code>add_positive</code> would I think stand out as a bug more than many other bugs we might introduce.</p>
<blockquote>
<p>turning every insertion/pop into an O(n) operation feels wrong</p>
</blockquote>
<p>For insertions, they already are; I assume we could put this check inside our existing loop over <code>self.positive</code> (in <code>add_positive</code>) and over <code>self.negative</code> (in <code>add_negative</code>). But you're right this might make the removals we have to do in the builder sometimes a bit more expensive? Though I expect that for small intersections, hashing overhead might cost more.</p>
<p>I'm really just dumping some thoughts here for future. If you feel the change doesn't work out well, I'm happy to leave it as-is for now. This tradeoff between the hashing/allocation overhead of a hashset and the extra cost of pops is something that should really be decided by empirical performance data at some point when we do more focused optimization of intersection builder, not by guesses.</p>
<blockquote>
<p>because I assume we do not need to maintain insertion order for intersections, just for unions</p>
</blockquote>
<p>Good point! At least that is true until/unless we have a PEP for intersection types that gives users a way to spell them directly in annotations; then we might want to preserve their spelling when we can.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:531 on 2024-10-18 16:48</div>
            <div class="timeline-body"><p>This comment (and several like it below) are resolved, but I don't see the corresponding change in the code? Maybe just not committed/pushed yet?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-18 16:49</div>
            <div class="timeline-body"><p>Looks like this is still in-process, so didn't do a full re-review of the code, just a few responses to inline comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 17:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:225 on 2024-10-18 17:35</div>
            <div class="timeline-body"><blockquote>
<p>I think it is already &quot;wrapped&quot; in the <code>IntersectionType</code> / <code>IntersectionBuilder</code>, so I'm not sure we'd need to wrap it again</p>
</blockquote>
<p>There are several direct calls to <code>OrderSet::insert</code> in <strong><code>Inner</code></strong><code>IntersectionBuilder</code>, so if we replace that with <code>Vec</code>, we would need to wrap it again, or make sure we only call a helper function (<code>self.push_positive(type)</code>) instead of calling <code>self.positive.push(…)</code> directly.</p>
<blockquote>
<blockquote>
<p>turning every insertion/pop into an O(n) operation feels wrong</p>
</blockquote>
<p>For insertions, they already are</p>
</blockquote>
<p>(Oops. I meant to say &quot;every insertion/push&quot; there, not &quot;pop&quot;)</p>
<p>Why? <a href="https://docs.rs/ordermap/latest/ordermap/set/struct.OrderSet.html#method.insert"><code>OrderSet::insert</code></a> is O(1), amortized.</p>
<blockquote>
<p>This tradeoff between the hashing/allocation overhead of a hashset and the extra cost of pops is something that should really be decided by empirical performance data</p>
</blockquote>
<p>Yes, please! :smile: I think O(n) analysis might be completely misguided here. Even if someone has 10 nested <code>if</code> statement and manages to construct an intersection type that really has 10 elements inside (Maybe <code>int &amp; ~Literal[1] &amp; ~Literal[2] &amp; … &amp; ~Literal[9]</code>), an O(n²) operation wouldn't be the end of the world. My feeling is that we don't burn any bridges by not doing that directly, but I'd be glad to write some benchmarks and include them in this PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-18 17:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:225 on 2024-10-18 17:38</div>
            <div class="timeline-body"><p>I wouldn't spend time on benchmarks for this right now. Let's leave it as is, and revisit when our optimization work can be directed and motivated by profiles from real-world large codebases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-18 17:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:531 on 2024-10-18 17:40</div>
            <div class="timeline-body"><p>Never mind, I see now (after you pointed it out to me) that you instead handled this via new separate cases, for flatter matching. Makes sense, sorry for the noise!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 18:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:225 on 2024-10-18 18:03</div>
            <div class="timeline-body"><p>ok</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 19:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:242 on 2024-10-18 19:50</div>
            <div class="timeline-body"><p>I added this now for all simplifications.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:276 on 2024-10-18 19:50</div>
            <div class="timeline-body"><p>I added this now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 19:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 19:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:315 on 2024-10-18 19:51</div>
            <div class="timeline-body"><p>Added this as a test.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 20:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:490 on 2024-10-18 20:24</div>
            <div class="timeline-body"><blockquote>
<p>It just occurred to me now on second read-through that this case is incorrect if it comes before the union case, because the union of two <code>Type::Function</code> is not disjoint from one of those same <code>Type::Function</code>.</p>
</blockquote>
<p>Ah, you're right.</p>
<blockquote>
<p>I think this case is really the same as the <code>None</code> and <code>Literal</code> types case below, and could probably just be merged with it?</p>
</blockquote>
<p>:+1:</p>
<blockquote>
<p>Would be good to add a test case that would have caught this (to create a union of function or class types, define them in if/else branches.)</p>
</blockquote>
<p>Yes. I added a test that failed with the previous version.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 20:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:255 on 2024-10-18 20:28</div>
            <div class="timeline-body"><p>I first added the comment, but now removed it again. We now support removing multiple elements, so we can't break.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2024-10-18 20:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:261 on 2024-10-18 20:33</div>
            <div class="timeline-body"><p>I saw that there was a considerate effort to optimize similar code for unions. I chose to do something much simpler for intersections here, since — for now — we don't care about the order of elements in the intersection. So we can use <code>swap_remove_index</code> here which is O(1). We traverse <code>to_remove</code> backwards to avoid any index shifts. That is okay, because <code>to_remove</code> is sorted.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:537 on 2024-10-18 20:59</div>
            <div class="timeline-body"><p>Because <code>bool</code> is a subtype of <code>int</code> in Python (sadly), we must also include <code>KnownClass::Int</code> here.</p>
<p>There was already a test for this case, but it asserted wrongly that <code>int</code> and a <code>BooleanLiteral</code> were disjoint; I switched it to assert the opposite.</p>
<p>There was also an <code>IntersectionBuilder</code> test relying on this assumption of bool/int disjointness; I fixed it by using a <code>StringLiteral</code> instead of a <code>BooleanLiteral</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-18 21:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-18 21:30</div>
            <div class="timeline-body"><p>This is excellent work, thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-10-18 21:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-10-18 21:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-18 21:34</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:00:08 UTC
    </footer>
</body>
</html>
