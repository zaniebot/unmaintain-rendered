<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Track all read references in semantic model - astral-sh/ruff #4610</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Track all read references in semantic model</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/4610">#4610</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-05-23 19:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-23 19:31</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Historically, we've only tracked the <em>most recent</em> read reference for a given binding. To be a little more specific, we tracked the most recent &quot;runtime&quot;, &quot;typing-only&quot;, and &quot;synthetic&quot; reference (where a &quot;synthetic&quot; reference exists as a bit of a hack to implement always-used references, like <code>from foo import bar as bas</code>-style explicit re-exports).</p>
<p>For the flake8-type-checking autofix, I need to know the <em>first</em> usage of a given symbol. And in general, we need to track all references to every symbol in order to support a class of behaviors (like symbol renaming).</p>
<p>This PR modifies the semantic model to support full read-reference tracking. The design is such that we store all references on the model, and each binding stores a list of IDs for its read references.</p>
<p>I've left the reference categorization untouched to make this a non-behavioral change, but modified the behavior to remove the &quot;synthetic&quot; concept in https://github.com/charliermarsh/ruff/pull/4612.</p>
<p>In my lazy hyperfine testing, there wasn't a noticeable regression here, but let's see what the PR benchmarks say.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @charliermarsh on 2023-05-23 19:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 19:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/rules/flake8_bugbear/rules/unused_loop_control_variable.rs</code>:161 on 2023-05-23 19:31</div>
            <div class="timeline-body"><p>(I renamed this method.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 19:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/binding.rs</code>:31 on 2023-05-23 19:32</div>
            <div class="timeline-body"><p>Storing the reference IDs on <code>Binding</code> gives us the nice property that testing whether something is unused remains extremely cheap.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 19:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:236 on 2023-05-23 19:35</div>
            <div class="timeline-body"><p>I don't really have intuition on whether we should be defining methods like <code>push_reference</code> on <code>SemanticModel</code>, or on <code>References</code> and accessing them via attribute like this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/reference.rs</code>:40 on 2023-05-23 19:44</div>
            <div class="timeline-body"><p>We can and should remove this, but it should be done separately IMO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 19:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-05-23 19:46</div>
            <div class="timeline-body"><h2>PR Check Results</h2>
<h3>Ecosystem</h3>
<p>✅ ecosystem check detected no changes.</p>
<h3>Benchmark</h3>
<h4>Linux</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.00     19.6±0.76ms     2.1 MB/sec    1.01     19.7±0.51ms     2.1 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.6±0.15ms     3.6 MB/sec    1.03      4.7±0.18ms     3.5 MB/sec
linter/all-rules/numpy/globals.py          1.00   576.0±20.56µs     5.1 MB/sec    1.01   580.5±25.74µs     5.1 MB/sec
linter/all-rules/pydantic/types.py         1.00      7.9±0.23ms     3.2 MB/sec    1.06      8.3±0.32ms     3.1 MB/sec
linter/default-rules/large/dataset.py      1.00      9.2±0.26ms     4.4 MB/sec    1.09     10.0±0.29ms     4.1 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00      2.0±0.08ms     8.3 MB/sec    1.09      2.2±0.08ms     7.7 MB/sec
linter/default-rules/numpy/globals.py      1.00   242.9±11.82µs    12.1 MB/sec    1.05    254.5±9.95µs    11.6 MB/sec
linter/default-rules/pydantic/types.py     1.00      4.3±0.15ms     6.0 MB/sec    1.08      4.6±0.20ms     5.6 MB/sec
parser/large/dataset.py                    1.02      7.3±0.20ms     5.5 MB/sec    1.00      7.2±0.15ms     5.7 MB/sec
parser/numpy/ctypeslib.py                  1.03  1467.2±53.46µs    11.3 MB/sec    1.00  1428.3±70.24µs    11.7 MB/sec
parser/numpy/globals.py                    1.04    142.6±7.92µs    20.7 MB/sec    1.00    137.1±5.75µs    21.5 MB/sec
parser/pydantic/types.py                   1.02      3.2±0.09ms     8.1 MB/sec    1.00      3.1±0.10ms     8.2 MB/sec
</code></pre>
<h4>Windows</h4>
<pre><code>group                                      main                                   pr
-----                                      ----                                   --
linter/all-rules/large/dataset.py          1.01     21.4±0.28ms  1943.8 KB/sec    1.00     21.2±0.36ms  1961.5 KB/sec
linter/all-rules/numpy/ctypeslib.py        1.01      5.3±0.12ms     3.1 MB/sec    1.00      5.3±0.13ms     3.2 MB/sec
linter/all-rules/numpy/globals.py          1.00   629.4±19.44µs     4.7 MB/sec    1.00   630.4±24.74µs     4.7 MB/sec
linter/all-rules/pydantic/types.py         1.00      9.0±0.21ms     2.8 MB/sec    1.00      8.9±0.22ms     2.9 MB/sec
linter/default-rules/large/dataset.py      1.02     10.4±0.18ms     3.9 MB/sec    1.00     10.2±0.20ms     4.0 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.01      2.2±0.15ms     7.4 MB/sec    1.00      2.2±0.06ms     7.5 MB/sec
linter/default-rules/numpy/globals.py      1.00    259.5±8.99µs    11.4 MB/sec    1.03   268.3±14.56µs    11.0 MB/sec
linter/default-rules/pydantic/types.py     1.00      4.7±0.15ms     5.4 MB/sec    1.00      4.7±0.13ms     5.4 MB/sec
parser/large/dataset.py                    1.01      8.0±0.16ms     5.1 MB/sec    1.00      7.9±0.11ms     5.1 MB/sec
parser/numpy/ctypeslib.py                  1.00  1516.7±37.89µs    11.0 MB/sec    1.00  1511.4±39.73µs    11.0 MB/sec
parser/numpy/globals.py                    1.01    154.8±7.78µs    19.1 MB/sec    1.00    153.1±5.23µs    19.3 MB/sec
parser/pydantic/types.py                   1.00      3.4±0.08ms     7.5 MB/sec    1.00      3.4±0.09ms     7.5 MB/sec
</code></pre>
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 20:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/reference.rs</code>:40 on 2023-05-23 20:26</div>
            <div class="timeline-body"><p>See: https://github.com/charliermarsh/ruff/pull/4612</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:236 on 2023-05-23 21:39</div>
            <div class="timeline-body"><p>Creating a method on the semantic model makes the call shorter and allows to default to the current scope (so that you don't need to specify current scope everywhere)</p>
<p>I generally prefer to encapsulate all mutations, to have better control over how the data structures are modified (and only allow the operations that are valid)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-05-23 21:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:305 on 2023-05-23 21:41</div>
            <div class="timeline-body"><p>Same here: semantic_model.reference(binding_id, reference_id) is shorter, less to read in the future. It also hides how references are stored internally, making it easier to experiment with different representations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:4406 on 2023-05-23 21:44</div>
            <div class="timeline-body"><p>Nit: model.is_used(binding)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:4411 on 2023-05-23 21:45</div>
            <div class="timeline-body"><p>Do we have to clone here. It seems we're moving all other data</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs</code>:68 on 2023-05-23 21:47</div>
            <div class="timeline-body"><p>Nit: binding.references(). Makes it shorter and hides implementation details</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/reference.rs</code>:72 on 2023-05-23 21:50</div>
            <div class="timeline-body"><p>You should be able to derive the default implementation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-05-23 21:51</div>
            <div class="timeline-body"><p>Nice. We may want to look into ways that we can speed this up (smallvec?) because it seems to affect the performance significantly</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-23 22:11</div>
            <div class="timeline-body"><p>I'm game to try speeding this up, but I am a little skeptical that the difference is so great in practice. In my hyperfine benchmarks (which are less precise, but in some ways (?) more representative), there's basically no difference:</p>
<pre><code>❯ cargo build --release &amp;&amp; hyperfine --warmup 10 --runs 100 &quot;./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e&quot; &amp;&amp; cargo build --release &amp;&amp; hyperfine --warmup 10 --runs 100 &quot;./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e&quot; &amp;&amp; git co main &amp;&amp; cargo build --release &amp;&amp; hyperfine --warmup 10 --runs 100 &quot;./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e&quot; &amp;&amp; cargo build --release &amp;&amp; hyperfine --warmup 10 --runs 100 &quot;./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e&quot;
    Finished release [optimized] target(s) in 0.20s
Benchmark 1: ./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e
  Time (mean ± σ):     228.6 ms ±   4.5 ms    [User: 1795.1 ms, System: 68.5 ms]
  Range (min … max):   222.5 ms … 255.6 ms    100 runs

    Finished release [optimized] target(s) in 0.13s
Benchmark 1: ./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e
  Time (mean ± σ):     230.3 ms ±   4.6 ms    [User: 1804.0 ms, System: 68.4 ms]
  Range (min … max):   223.7 ms … 251.9 ms    100 runs

Switched to branch 'main'
Your branch is up to date with 'origin/main'.
   Compiling ruff_python_semantic v0.0.0 (/Users/crmarsh/workspace/staging/crates/ruff_python_semantic)
   Compiling ruff v0.0.269 (/Users/crmarsh/workspace/staging/crates/ruff)
   Compiling ruff_cli v0.0.269 (/Users/crmarsh/workspace/staging/crates/ruff_cli)
   Compiling ruff_dev v0.0.0 (/Users/crmarsh/workspace/staging/crates/ruff_dev)
   Compiling flake8-to-ruff v0.0.269 (/Users/crmarsh/workspace/staging/crates/flake8_to_ruff)
   Compiling ruff_wasm v0.0.0 (/Users/crmarsh/workspace/staging/crates/ruff_wasm)
    Finished release [optimized] target(s) in 1m 50s
Benchmark 1: ./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e
  Time (mean ± σ):     236.7 ms ±  12.1 ms    [User: 1773.4 ms, System: 70.6 ms]
  Range (min … max):   220.5 ms … 283.3 ms    100 runs

    Finished release [optimized] target(s) in 0.15s
Benchmark 1: ./target/release/ruff ./crates/ruff/resources/test/cpython/ --no-cache --silent -e
  Time (mean ± σ):     229.1 ms ±   7.0 ms    [User: 1805.6 ms, System: 72.1 ms]
  Range (min … max):   221.0 ms … 267.1 ms    100 runs

  Warning: Statistical outliers were detected. Consider re-running this benchmark on a quiet PC without any interferences from other programs. It might help to use the '--warmup' or '--prepare' options.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 22:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:4411 on 2023-05-23 22:15</div>
            <div class="timeline-body"><p>The fields on <code>existing</code> need to be cloned, yeah. The fields on <code>binding</code> are moved.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-23 22:22</div>
            <div class="timeline-body"><p>(Great feedback, thank you.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-23 22:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff/src/checkers/ast/mod.rs</code>:305 on 2023-05-23 22:35</div>
            <div class="timeline-body"><p>I simplified to <code>self.semantic_model.add_local_reference</code>, which creates and adds the reference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/flake8_type_checking/helpers.rs</code>:60 on 2023-05-24 07:19</div>
            <div class="timeline-body"><p>Nit: It could make sense to add <code>is_*</code> methods is this is something we commonly test for</p>
<pre><code class="language-suggestion">                
                semantic_model.references.resolve(reference_id).context().is_runtime()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/flake8_type_checking/rules/runtime_import_in_type_checking_block.rs</code>:67 on 2023-05-24 07:20</div>
            <div class="timeline-body"><p>Same for the <code>ExecutionContext</code>:</p>
<pre><code class="language-suggestion">    if binding.context.is_typing()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff/src/rules/pyflakes/rules/undefined_local.rs</code>:51 on 2023-05-24 07:22</div>
            <div class="timeline-body"><p>Nit and for another PR: Is <code>semantic_model().scope_id</code> the id of the current scope? Should we add a <code>is_current_scoipe(scope_id)</code> method or add a <code>model.current_scope_id()</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:135 on 2023-05-24 07:23</div>
            <div class="timeline-body"><p>Nit Nit: <code>context.invert()</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-05-24 07:23</div>
            <div class="timeline-body"><blockquote>
<p>I'm game to try speeding this up, but I am a little skeptical that the difference is so great in practice. In my hyperfine benchmarks (which are less precise, but in some ways (?) more representative), there's basically no difference:</p>
</blockquote>
<p>Yeah, that's fair. A few thoughts:</p>
<ul>
<li>I prefer building both release binaries and copying them to a dedicated location. Then run both hyperfine commands at once, to provide an as identical environment as possible to both benchmark runs (e.g. <code>cargo build</code> is very performance intense, running the benchmark right after may mean that the CPUs already thermal throttled)</li>
<li>The hyperfine benchmark is important to make &quot;meaningful&quot; decisions, but it also includes a lot of noise and is probably mainly limited by IO. I think it's worth spending some time optimizing our implementations if the microbenchmarks show a regression because performance dies by a thousand cuts. We may reach a point in the future where ruff suddenly is CPU limited, identifying all performance optimisations then will be much harder then when doing them right away.</li>
<li>Regressing performance is fine if we have a clear reason why the feature is needed.</li>
</ul>
<p>It may also be that the benchmarks on the CI are just flaky. I recommend you to run them locally on main (use <code>--save-baselne main</code>)  and then on your branch using <code>--baseline main</code>. You can use the time two tweet something nice on your phone or get a coffee or two ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-05-24 13:56</div>
            <div class="timeline-body"><p>I'll use the benchmarking time to tweet something nice about Micha!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/ruff_python_semantic/src/model.rs</code>:135 on 2023-05-24 14:08</div>
            <div class="timeline-body"><p>I'm going to do this in a separate PR, because these can be the same type once we remove <code>Synthetic</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-05-24 14:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @charliermarsh on 2023-05-24 14:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2023-05-24 14:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-05-24 14:14</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 03:50:43 UTC
    </footer>
</body>
</html>
