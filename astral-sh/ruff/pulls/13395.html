<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix/#13070 defer annotations when future is active - astral-sh/ruff #13395</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Fix/#13070 defer annotations when future is active</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13395">#13395</a>
        opened by <a href="https://github.com/Slyces">@Slyces</a>
        on 2024-09-18 16:05
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Slyces">@Slyces</a></div>
            <div class="timeline-body"><!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<p>This PR tries to provide support for deferred resolution of type-hints in files with <code>from __future__ import annotations</code>. Fixes #13070.</p>
<h3>Implementation</h3>
<p>Currently, the method <code>is_stub</code> is already used in multiple places to resolve deferred annotations. As all current usage of <code>is_stubs</code> are dedicated to deferred type inference, I decided in this implementation to refactor <code>is_stubs</code> &amp;&amp; <code>has_future_annotations</code> together in <code>are_all_types_deferred</code>.
We can also keep them separate and always test them together.</p>
<p>The main difficulty is how to know if that flag is active. I tried an implementation that checks this when building the semantic index. I do not know if it's the best choice (as <code>SemanticIndex</code> doesn't have any attribute similar to this), but the building of the semantic index already parses every statement in the file, which was ideal to find this flag.</p>
<p>Happy to get any feedback on a better spot for this if you can think of one.</p>
<h2>Test Plan</h2>
<p>There is currently one test addressing deferred annotations resolution, focused on builtins. I don't quite understand why builtins require deferred annotations, so I focused on test cases I encounter when coding in python.</p>
<p>In my experience, the two most common occurrences requiring deferred annotations (in regular code) are:</p>
<ul>
<li>Referencing a symbol before it's defined</li>
<li>Referencing a class inside one of its own methods</li>
</ul>
<p>Some testing led me to find that we don't currently support <a href="https://github.com/astral-sh/ruff/blob/4eb849aed3a6df9ce0f45dd7a2fdb525e31e61e3/crates/red_knot_python_semantic/src/types.rs#L439">type resolution for methods</a>, so I only tested the case of referencing a symbol before its definition.</p>
<p>I added 3 separate test case, all with the same base code:</p>
<pre><code class="language-python">def get_foo() -&gt; Foo: ...
class Foo: ...
foo = get_foo()  # Resolved if and only if deferred annotations are active
</code></pre>
<ul>
<li>Inside a source file (<code>*.py</code>, <code>foo</code> must not resolve (<code>Unknown</code>)</li>
<li>Inside a stub file (<code>*.pyi</code>), <code>foo</code> must resolve to <code>Foo</code></li>
<li>Inside a source file <strong>with __future__.annotations</strong>, <code>foo</code> must resolve to <code>Foo</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @Slyces on 2024-09-18 16:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @Slyces on 2024-09-18 16:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @Slyces on 2024-09-18 16:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-09-18 16:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-09-18 16:11</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/Slyces:fix/#13070-defer-annotations-when-future-is-active">CodSpeed Performance Report</a></h2>
<h3>Merging #13395 will <strong>degrade performances by 4.26%</strong></h3>
<p><sub>Comparing <code>Slyces:fix/#13070-defer-annotations-when-future-is-active</code> (301d065) with <code>main</code> (d3530ab)</sub></p>
<h3>Summary</h3>
<p><code>‚ùå 1</code> regressions
<code>‚úÖ 31</code> untouched benchmarks</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/Slyces:fix/#13070-defer-annotations-when-future-is-active">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>Slyces:fix/#13070-defer-annotations-when-future-is-active</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ‚ùå | <code>red_knot_check_file[incremental]</code> | 2.9 ms | 3 ms | -4.26% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-18 16:19</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>‚úÖ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Slyces">@Slyces</a> on 2024-09-18 16:36</div>
            <div class="timeline-body"><p>I just realised that the performance issue can probably be fixed by relying on the fact that <code>from __future__ import annotations</code> should always be the first import in a file - I'll try to get that to work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:324 on 2024-09-18 17:06</div>
            <div class="timeline-body"><p>nit: checking <code>has_future_annotations()</code> is slightly cheaper, maybe let's do that first?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-09-18 17:23</div>
            <div class="timeline-body"><p>This is fantastic, thank you!!</p>
<p>The semantic index builder is the right place to look for this, and the semantic index is the right place to put it. Any analysis that we can do without requiring a dependency on other files, we want to do in semantic indexing.</p>
<p>I suspect the performance regression on the incremental check is because tomllib (which we are using for our benchmark) does use <code>from __future__ import annotations</code>, and deferred types require an extra Salsa query and thus increase Salsa overhead on incremental check.</p>
<p>So I suspect that requiring <code>from __future__ import annotations</code> to be the first statement in a file won't help with the performance.</p>
<p>And I'm not sure if we even want to require it. A mis-placed <code>from __future__ import annotations</code> won't work at runtime (the module won't even import), but for our purposes I think we should assume the user intended for it to take effect, and we should still check the code assuming its use. Otherwise accidentally adding a line before your <code>from __future__ import annotations</code> could suddenly result in a ton of bogus diagnostics on your forward-reference annotations, which isn't really useful.</p>
<p>I think we should add a comment to this effect, where we check for <code>from __future__ import annotations</code> in the semantic index builder.</p>
<p>And I think we should emit a diagnostic ~in type inference~ if we run across a misplaced <code>__future__</code> import. But this is pretty much a separate thing and could be its own PR. (EDIT: I actually think probably it shouldn't be done in type inference; misplaced <code>__future__</code> imports are a syntax-level error that isn't really part of type-checking. So we'll want this diagnostic, but probably not in type inference, and definitely not in this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:553 on 2024-09-18 17:25</div>
            <div class="timeline-body"><p>Something like this:</p>
<pre><code class="language-suggestion">                    // Look for imports `from __future__ import annotations`, ignore `as ...`.
                    // We intentionally don't enforce the rules about location of `__future__` imports here,
                    // we assume the user's intent was to apply the `__future__` import, so we still check
                    // using it (and TODO will also emit a diagnostic about a mis-placed `__future__` import.)
                    self.has_future_annotations |= alias.name.id.as_str() == &quot;annotations&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-18 17:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Slyces">@Slyces</a> on 2024-09-18 17:27</div>
            <div class="timeline-body"><blockquote>
<p>So I suspect that requiring from <strong>future</strong> import annotations to be the first statement in a file won't help with the performance.</p>
</blockquote>
<p>That's somewhat of a relief (if it's true) because the implementation I have so far is not ideal. I will still try to go through with it to make sure that it is not the source of the regression</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 18:02</div>
            <div class="timeline-body"><blockquote>
<p>Some testing led me to find that we don't currently support <a href="https://github.com/astral-sh/ruff/blob/4eb849aed3a6df9ce0f45dd7a2fdb525e31e61e3/crates/red_knot_python_semantic/src/types.rs#L439">type resolution for methods</a></p>
</blockquote>
<p>This is true, though the spot in the code you linked is for supporting attribute access of attributes on function objects. To support method calls, I think what we are missing is understanding attribute access on instances of classes (as opposed to class objects): https://github.com/astral-sh/ruff/blob/c173ec5bc7cff4d453ddc6d45293aed5b79f0bbe/crates/red_knot_python_semantic/src/types.rs#L460</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 18:04</div>
            <div class="timeline-body"><blockquote>
<p>I will still try to go through with it to make sure that it is not the source of the regression</p>
</blockquote>
<p>If this is a lot of work, an easier way to check the performance impact would be to see how performance on the benchmark fares if you just consider <code>from __future__ import annotations</code> to always be true, without even looking for it in semantic index.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Slyces">@Slyces</a> on 2024-09-18 18:09</div>
            <div class="timeline-body"><p>While this is not related to the PR, I did waste some time on the difference between &quot;expected Unknown&quot; (e.g. resolution failed) vs. &quot;Not implemented Unknown&quot; (e.g. this case should yield a value for the current AST but we didn't code it yet).</p>
<p>Would it be worth considering a temporary value (until red-knot is feature complete or almost so) that would make this difference obvious? To be fair I'll also be more careful next time now that I know üôÇ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-18 18:24</div>
            <div class="timeline-body"><blockquote>
<p>Would it be worth considering a temporary value (until red-knot is feature complete or almost so) that would make this difference obvious?</p>
</blockquote>
<p>That's an interesting idea! I think we could have <code>Type::Unknown</code> contain another enum indicating the source of the unknown (mypy does something similar, @AlexWaygood has mentioned this before). Then most code handling Unknowns wouldn't have to care (we wouldn't have to add a new branch in every place that handles types), but we could display them differently.</p>
<p>This seems like a net positive to me! Not sure I would get to it soon, but if you're interested in doing it, I'd certainly consider a PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-09-18 18:27</div>
            <div class="timeline-body"><blockquote>
<p>That's an interesting idea! I think we could have <code>Type::Unknown</code> contain another enum indicating the source of the unknown (mypy does something similar, @AlexWaygood has mentioned this before). Then most code handling Unknowns wouldn't have to care (we wouldn't have to add a new branch in every place that handles types), but we could display them differently.</p>
</blockquote>
<p>Yes, see #12986 for previous discussion! I think the main concern with that PR was how to handle the inner enum in unions and intersections.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:561 on 2024-09-19 07:30</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                    self.has_future_annotations |= alias.name.id == &quot;annotations&quot;
                        &amp;&amp; node
                            .module
                            .as_ref()
                            .is_some_and(|module| module.id() == &quot;__future__&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:561 on 2024-09-19 07:31</div>
            <div class="timeline-body"><p>Or even</p>
<pre><code class="language-rust">                    self.has_future_annotations |= alias.name.id == &quot;annotations&quot;
                        &amp;&amp; node.module.as_deref() == Some(&quot;__future__&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:49 on 2024-09-19 07:32</div>
            <div class="timeline-body"><p>We probably want to make this a bit flag long term but a boolean is just fine for now :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-09-19 07:32</div>
            <div class="timeline-body"><p>This is great. Thanks you</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-09-19 08:11</div>
            <div class="timeline-body"><p>It's a bit a problem that I can't acknowledge the codspeed regression because the URl doesn't work haha</p>
<p>Okay, there's a way. Navigate to the runs page and open the results from there https://codspeed.io/astral-sh/ruff/runs/66ebdbcf6ba711013f9a14a5</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-09-19 08:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-09-19 08:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-19 08:13</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:06:34 UTC
    </footer>
</body>
</html>
