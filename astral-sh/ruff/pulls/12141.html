<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Respect typeshed's `VERSIONS` file when resolving stdlib modules - astral-sh/ruff #12141</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Respect typeshed's <code>VERSIONS</code> file when resolving stdlib modules</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12141">#12141</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-07-01 13:47
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>In the module resolver, we need to treat standard-library paths differently to paths relative to other module-resolver search paths. This is for three reasons:</p>
<ul>
<li>Unlike for other module-resolver paths, only <code>.pyi</code> files are valid relative to standard-library paths</li>
<li>When checking whether standard-library paths &quot;exist&quot;, we need to take account of typeshed's <code>VERSIONS</code> file as well as simply checking whether the path exists on disk.</li>
<li>Although this isn't implemented now, we will also at some point need to implement support for vendored standard-library files as well as standard-library files in a custom typeshed directory that actually exists on disk.</li>
</ul>
<p>Although it's not implemented here yet, two other kinds of paths will also need special treatment in the module resolver:</p>
<ul>
<li>The module resolver needs to treat <code>site-packages</code> search paths differently, due to the fact that a module <code>foo</code> could resolve to a <code>site-packages/foo</code> path or a <code>site-packages/foo-stubs/foo</code> path</li>
<li>If we decide to vendor third-party stubs from typeshed as well as standard-library stubs, these will need to be treated specially as well.</li>
</ul>
<p>To account for these differences, this PR introduces a new module, <code>crates/red_knot_module_resolver/src/path.rs</code>. The new module has two enums,  <code>ModuleResolutionPathBuf</code> and <code>ModuleResolutionPathRef</code>. Each enum has four different variants representing the four different kinds of search paths the module resolver must handle:</p>
<ul>
<li><code>ExtraPath</code>: paths representing Step (1) in the module resolution order at https://typing.readthedocs.io/en/latest/spec/distributing.html#import-resolution-ordering</li>
<li><code>FirstPartyPath</code>: paths representing first-party user code</li>
<li><code>StandardLibraryPath</code>: paths representing standard-library stubs from typeshed</li>
<li><code>SitePackagesPath</code>: paths representing steps (4) and (5) in the module resolution order at https://typing.readthedocs.io/en/latest/spec/distributing.html#import-resolution-ordering</li>
</ul>
<p>The different variants abstract over the fact that for different kinds of paths, there will be different answers to questions such as &quot;Is this a valid <code>join()</code> operation?&quot;, &quot;Does this path exist?&quot; and &quot;Does this path represent a directory?&quot;.</p>
<h2>Test Plan</h2>
<p>Unit tests have been added to <code>src/path.rs</code> and <code>src/typeshed/versions.rs</code>. Integration tests have been added to <code>src/resolver.rs</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-07-01 13:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-07-01 14:05</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>‚ÑπÔ∏è ecosystem check <strong>encountered linter errors</strong>. (no lint changes; 1 project error)</p>
<details><summary><a href="https://github.com/python-trio/trio">python-trio/trio</a> (error)</summary>
<p>

<pre><code>Failed to clone python-trio/trio: warning: Could not find remote branch master to clone.
fatal: Remote branch master not found in upstream origin
</code></pre>
</p>
</details>

<h3>Linter (preview)</h3>
<p>‚ÑπÔ∏è ecosystem check <strong>encountered linter errors</strong>. (no lint changes; 1 project error)</p>
<details><summary><a href="https://github.com/python-trio/trio">python-trio/trio</a> (error)</summary>
<p>
<pre>ruff check --no-cache --exit-zero --ignore RUF9 --output-format concise --preview</pre>
</p>
<p>

<pre><code>Failed to clone python-trio/trio: warning: Could not find remote branch master to clone.
fatal: Remote branch master not found in upstream origin
</code></pre>
</p>
</details>

<h3>Formatter (stable)</h3>
<p>‚ÑπÔ∏è ecosystem check <strong>encountered format errors</strong>. (no format changes; 1 project error)</p>
<details><summary><a href="https://github.com/python-trio/trio">python-trio/trio</a> (error)</summary>
<p>

<pre><code>Failed to clone python-trio/trio: warning: Could not find remote branch master to clone.
fatal: Remote branch master not found in upstream origin
</code></pre>
</p>
</details>

<h3>Formatter (preview)</h3>
<p>‚ÑπÔ∏è ecosystem check <strong>encountered format errors</strong>. (no format changes; 1 project error)</p>
<details><summary><a href="https://github.com/python-trio/trio">python-trio/trio</a> (error)</summary>
<p>
<pre>ruff format --preview</pre>
</p>
<p>

<pre><code>Failed to clone python-trio/trio: warning: Could not find remote branch master to clone.
fatal: Remote branch master not found in upstream origin
</code></pre>
</p>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/db.rs</code>:22 on 2024-07-01 14:18</div>
            <div class="timeline-body"><p>I think I would make a <code>typeshed_versions(db)</code> query instead. It should be possible to have zero-argument queries.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/module.rs</code>:23 on 2024-07-01 14:19</div>
            <div class="timeline-body"><p>Nit: The name <code>Entry</code> feels a bit odd there. Why not just <code>ModuleSearchPath</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:98 on 2024-07-01 14:21</div>
            <div class="timeline-body"><p>Nit: Just <code>exact</code>. <code>get</code> prefixes are uncommon in the Rust ecosystem</p>
<pre><code class="language-suggestion">    fn exact(&amp;self, module_name: &amp;ModuleName) -&gt; Option&lt;&amp;PyVersionRange&gt; {
        self.0.get(module_name)
    }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:85 on 2024-07-01 14:22</div>
            <div class="timeline-body"><p>What's the reason for supporting <code>Clone</code>? Seems expensive</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/db.rs</code>:65 on 2024-07-01 14:26</div>
            <div class="timeline-body"><p>Nit: Maybe add a <code>Default</code> or <code>empty</code> function to avoid this spreading everywhere</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-01 14:40</div>
            <div class="timeline-body"><p>I feel a bit mixed about having all those different <code>Path</code> versions. It feels like the right level of abstraction but it's a lot of code and it becomes hard to spot how they are different because of all the boilerplate that is identical between all paths. I think we should try to reduce the amount of code. I'm not entirely sure yet how, but I think we should try</p>
<p>I think a simpler design would be to just have an enum with different variants. Very similar to what we have with <code>ModuleSearchPath</code>. I think it would help readability because I can then see in the methods how the different path variants differ.</p>
<p>One thing that I think would already help if we wouldn't need both <code>Path</code> and <code>PathBuf</code> variants. Are there many places where we use <code>Path</code> where it helps to avoid allocating and where we can't use a <code>&amp;PathBuf</code>?</p>
<p>It seems that <code>ModuleSearchPath</code> implements a s similar interface to each <code>Path</code> variant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-07-01 14:54</div>
            <div class="timeline-body"><p>Thanks, agree that it's a lot of code (more than I thought it would be, and more than I'm comfortable with). I'll try to address that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:85 on 2024-07-01 15:20</div>
            <div class="timeline-body"><p>It's required for snapshotting. I'll put the <code>FxHashMap</code> behind an <code>Arc</code> to make it less expensive to clone. It makes sense for the inner mapping to be immutable: if the user changes the <code>VERSIONS</code> file, we'll need to reparse the whole thing anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-01 15:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-02 11:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:169 on 2024-07-02 11:19</div>
            <div class="timeline-body"><p>Unwrapping isn't correct here; if the paths fail to validate, we need to bail out from the whole process and tell the user that we were passed an invalid path in the configuration they gave us. Will do that soon.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-07-02 11:23</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/pull/12141/commits/d91626c5301ffb9e79653cf5afb6592c5f0ce8c2 made this PR around 600 lines of code shorter! The <code>path.rs</code> file looks pretty different now ü•≥</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-02 18:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:18 on 2024-07-02 18:45</div>
            <div class="timeline-body"><p>Unwrapping is obviously the wrong thing to do here... Should I just return a <code>Result</code> from this query? Not sure how to handle this. If the user passes us a custom typeshed directory with an invalid <code>VERSIONS</code> file, we can't infer any information about the standard library</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-07-02 19:00</div>
            <div class="timeline-body"><p>This still needs a lot more tests, but other than that it's basically where I want it to be now... though there's still a bunch of <code>.unwrap()</code> calls where I should be bubbling up errors instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-03 06:49</div>
            <div class="timeline-body"><blockquote>
<p>This still needs a lot more tests, but other than that it's basically where I want it to be now... though there's still a bunch of .unwrap() calls where I should be bubbling up errors instead.</p>
</blockquote>
<p>Handling and propagating errors is something that I have yet to fully figure out for Red Knot.</p>
<p>Generally, the idea is that query methods shouldn't fail and instead keep doing something useful to make ruff more error resilient and it simplifies consuming queries (it would be rather annoying if <code>source_text</code> returned a <code>Result</code> because all dependent queries would have to return a <code>Result</code> as well).</p>
<p>I could see this working for <code>source_text</code> where reading a file failed. ' source_text pushes a diagnostic using a Salsa accumulator, returns an empty string, and stores a flag on the result that the read operation failed. For most queries calling <code>source_text</code>, checking the error isn't necessary, an empty string works just fine for them. However, we probably want to check the error flag when calling <code>check_file</code> or <code>format</code> or any other &quot;file-level&quot; operation to short-circuit in this case.</p>
<p>I see two options for how we can handle this with versions:</p>
<ul>
<li>If reading <code>versions</code> fails (or the custom typeshed directory doesn't exist), emit a diagnostic and fall back to the vendored stubs.</li>
<li>It's still unclear to me if we handle settings as part of queries or if settings are discovered ahead of time when discovering all the workspace files. If that's the case, then parsing and resolving the settings would happen outside salsa where we could handle the error appropriately.</li>
</ul>
<p>For now, I think adding a TODO and/or opening an issue to follow up with error handling seems fine to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:41 on 2024-07-03 07:06</div>
            <div class="timeline-body"><p>To me the benefit of having all these different <code>Path</code> variants isn't entirely clear. I get the impression that we now use two forms to distinguish the paths:</p>
<ul>
<li>The variant in <code>ModuleResolutionPath</code></li>
<li>The different path types</li>
</ul>
<p>The only place where I see that we pass a specific path to a method is <code>StandardLibraryPath</code>. Considering that this method is private, I think it's fine to just pass <code>FileSystemPath</code>.</p>
<p>I would recommend removing the different path versions and just use <code>FileSystemPathBuf</code> everywhere and solely rely on the enum variant to distinguish the different cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:578 on 2024-07-03 07:09</div>
            <div class="timeline-body"><p>Do we rely on this logic a lot. I'm worried that this will bite us when adding support for vendored file system because implementing <code>AsRef</code> then becomes impossible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:635 on 2024-07-03 07:11</div>
            <div class="timeline-body"><p>The <code>Eq</code> implementation here are unused and I'm not quiet sure if an equal implementation that doesn't take the module search path variant into account matches what I would expect.</p>
<p>Let's also remove all other trait implementations that are currently unused. We can always add them once needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:410 on 2024-07-03 07:15</div>
            <div class="timeline-body"><p>Not a huge deal, but the method is non trivial and the <code>impl Into&lt;Self&gt;</code> means that this method will get monomorphized for each type; You can avoid monomorphization by creating an inline function</p>
<pre><code class="language-suggestion">    pub(crate) fn is_regular_package(&amp;self, db: &amp;dyn Db, search_path: impl Into&lt;Self&gt;) -&gt; bool {
    		fn is_regular_impl(path: &amp;ModuleResolutionSearchPath, db: &amp;dyn Db, search_path) -&gt; bool {
	        match (path, search_path) {
	            (Self::Extra(ExtraPath(fs_path)), Self::Extra(_))
	            | (Self::FirstParty(FirstPartyPath(fs_path)), Self::FirstParty(_))
	            | (Self::SitePackages(SitePackagesPath(fs_path)), Self::SitePackages(_)) =&gt; {
	                let file_system = db.file_system();
	                file_system.exists(&amp;fs_path.join(&quot;__init__.py&quot;))
	                    || file_system.exists(&amp;fs_path.join(&quot;__init__.pyi&quot;))
	            }
	            // Unlike the other variants:
	            // (1) Account for VERSIONS
	            // (2) Only test for `__init__.pyi`, not `__init__.py`
	            (Self::StandardLibrary(StandardLibraryPath(fs_path)), Self::StandardLibrary(stdlib_root)) =&gt; {
	                let Some(module_name) = self.as_module_name() else {
	                    return false;
	                };
	                let typeshed_versions = Self::load_typeshed_versions(db, stdlib_root);
	                match typeshed_versions.query_module(&amp;module_name, get_target_py_version(db)) {
	                    TypeshedVersionsQueryResult::Exists
	                    | TypeshedVersionsQueryResult::MaybeExists =&gt; {
	                        db.file_system().exists(&amp;fs_path.join(&quot;__init__.pyi&quot;))
	                    }
	                    TypeshedVersionsQueryResult::DoesNotExist =&gt; false,
	                }
	            }
	            (path, root) =&gt; unreachable!(
	                &quot;The search path should always be the same variant as `self` (got: {path:?}, {root:?})&quot;
	            )
	        }
	     }
	     is_regular_impl(self, db, search_path.into())    
    }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:51 on 2024-07-03 07:16</div>
            <div class="timeline-body"><p>I think I would call this enum <code>ModuleResolutionPathBuf</code> and the other <code>ModuleResolutionPath</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:472 on 2024-07-03 07:20</div>
            <div class="timeline-body"><p>Nit: I think we could move this to <code>ModuleName::from_components</code> where the argument is <code>impl IntoIterator&lt;Item=&amp;str&gt;</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:691 on 2024-07-03 07:22</div>
            <div class="timeline-body"><p>This is nead but doesn't seem needed at the moment. I recommend deleting it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:650 on 2024-07-03 07:23</div>
            <div class="timeline-body"><p>Nit: I think you can avoid the option here</p>
<pre><code class="language-suggestion">    parent_components: Option&lt;camino::Utf8Components&lt;'a&gt;&gt;,
    stem: Option&lt;&amp;'a str&gt;,
}

impl&lt;'a&gt; ModulePartIterator&lt;'a&gt; {
    #[must_use]
    fn from_fs_path(path: &amp;'a FileSystemPath) -&gt; Self {
        let mut parent_components = path.components();
        parent_components.next_back();
        Self {
            parent_components,
            stem: path.file_stem(),
        }
    }
}
</code></pre>
<p>This should also simplify the <code>next</code> implementation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:453 on 2024-07-03 07:25</div>
            <div class="timeline-body"><p>The Rust convention is to call this <code>to_module_name</code> because the conversation isn't &quot;free&quot;. See <a href="https://rust-lang.github.io/api-guidelines/naming.html#ad-hoc-conversions-follow-as_-to_-into_-conventions-c-conv">naming guidelines</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:439 on 2024-07-03 07:28</div>
            <div class="timeline-body"><p>Nit: I would be calling this <code>strip_dunder_init</code> to align with <code>str::strip_sufix</code> (strip is probably also a more familiar word to none native English or French speakers)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:68 on 2024-07-03 07:32</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            if let Some(extension) = camino::Utf8Path::new(component).extension() {
</code></pre>
<p>since you already depend on <code>Utf8Path</code> anyway and it avoids having to call <code>to_str</code> to deal with non unicode paths</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:356 on 2024-07-03 07:36</div>
            <div class="timeline-body"><p>I'm leaning towards removing all methods that take a <code>&amp;db</code> out of path and instead implement them as methods on <code>ModuleResolver</code>. It just feels a bit heavyweight to me that an <code>is_directory</code> call ends up loading the type shed versions. It also makes it harder to optimize caching of typeshed versions; e.g. the module resolver could load the typeshed versions once and cache them for the entire resolution of a <code>resolve_module</code> call where path needs to call <code>parse_typeshed_versions</code> for every <code>is_directory</code>, <code>is_regular_package</code>, ...  call</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:131 on 2024-07-03 07:37</div>
            <div class="timeline-body"><p>I wonder if we should change the settings to <code>Option&lt;(FileSystemPathBuf, TypeshedVersions)&gt;</code>. This way, parsing the typeshed versions happens outside of salsa (solves the error reporting problem).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:128 on 2024-07-03 07:40</div>
            <div class="timeline-body"><p>Nit: I'm inclined to rename <code>SupportedPyVersion</code> to <code>TargetPyVersion</code> considering that you named the field very consistently <code>target_version</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:169 on 2024-07-03 07:42</div>
            <div class="timeline-body"><p>I think this is where a builder for <code>ModuleSearchSettings</code> could help where <code>ModuleSearchSettings</code> stores <code>ModuleResolutionPath</code> internally but the builder exposes <code>with_extra(extras) -&gt; Result&lt;Self, Self&gt;</code> methods.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:15 on 2024-07-03 07:44</div>
            <div class="timeline-body"><p>You can use <code>return_ref</code> to avoid the need for an <code>Arc</code></p>
<pre><code class="language-suggestion">#[salsa::tracked(return_ref)]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:115 on 2024-07-03 07:45</div>
            <div class="timeline-body"><p>Nit: Can this method be <code>pub(crate)</code> (and maybe some other types and methods?)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-07-03 07:49</div>
            <div class="timeline-body"><p>This is looking good!</p>
<p>I think we can simplify it a bit further and I would move some code around but we're on a good path here!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @MichaReiser on 2024-07-03 07:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 08:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:131 on 2024-07-03 08:21</div>
            <div class="timeline-body"><p>Hmm, but we need to re-parse the <code>VERSIONS</code> file every time it changes if we're in an LSP context. I think a Salsa query is pretty well suited to this, if I understand correctly. The difficulty just comes in bubbling the error out of salsa</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:131 on 2024-07-03 08:27</div>
            <div class="timeline-body"><p>But the need for recomputing also applies to the <code>custom_typeshed</code> path?</p>
<p>Salsa will re-run all <code>resolve_module</code> queries when the <code>ModuleResolutionSettings</code> change. The only thing that happens outside (at least for now) is how we react to setting changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-03 08:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 08:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:131 on 2024-07-03 08:33</div>
            <div class="timeline-body"><p>The user won't pass a direct path to the VERSIONS file on the command line or in a config file. They'll pass a direct path to the custom typeshed directory, and the VERSIONS file is found inside that directory. If they then edit the contents of the VERSIONS file (or delete it entirely), we'll need to react to that change and attempt to re-parse the VERSIONS file in the custom typeshed directory, even though none of the settings passed by the user will have changed in any way</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:15 on 2024-07-03 09:25</div>
            <div class="timeline-body"><p>Ah nice, this means I also don't need to derive <code>Clone</code> at all for <code>TypeshedVersions</code>! I didn't like that at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 09:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 09:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:453 on 2024-07-03 09:37</div>
            <div class="timeline-body"><p>I tried making this change, but Clippy complained:</p>
<pre><code>warning: methods with the following characteristics: (`to_*` and `self` type is `Copy`) usually take `self` by value
   --&gt; crates/red_knot_module_resolver/src/path.rs:406:34
    |
406 |     pub(crate) fn to_module_name(&amp;self) -&gt; Option&lt;ModuleName&gt; {
    |                                  ^^^^^
    |
    = help: consider choosing a less ambiguous name
    = help: for further information visit https://rust-lang.github.io/rust-clippy/master/index.html#wrong_self_convention
    = note: `#[warn(clippy::wrong_self_convention)]` on by default
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:439 on 2024-07-03 09:39</div>
            <div class="timeline-body"><p>Pardon, monsieur</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 09:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 09:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:650 on 2024-07-03 09:44</div>
            <div class="timeline-body"><p>Hmm, not sure if that works or not. Let me write some tests for this bit of code before applying this change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 09:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:51 on 2024-07-03 09:52</div>
            <div class="timeline-body"><p>Hmm, I made this change, but now I'm wondering if that naming scheme is somewhat confusing. <code>FooPath</code> structs generally always need to be behind <code>&amp;</code> references when you use them, because they're unsized types. But it's impossible to have an unsized enum (unfortunately), so the enum that represents the borrowed version of the path cannot be an unsized type; instead, it holds references internally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 10:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:51 on 2024-07-03 10:01</div>
            <div class="timeline-body"><p>The owned enum is now called <code>ModuleResolutionPathBuf</code>, as per your suggestion, but the one that has borrowed variants I've renamed back to <code>ModuleResolutionPathRef</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 10:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:128 on 2024-07-03 10:12</div>
            <div class="timeline-body"><p>I see the logic there, but I already have a struct called <code>TargetPyVersion</code> in <code>supported_py_version.rs</code>. What do I call that if I give that name to the enum currently called <code>SupportedPyVersion</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 10:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:691 on 2024-07-03 10:14</div>
            <div class="timeline-body"><p>:( Then we have to have the default implementation for <code>last()</code>, which exhausts the entire iterator to get the last element</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 11:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:356 on 2024-07-03 11:21</div>
            <div class="timeline-body"><p>I see your point. However, the advantage of doing this as late as possible is that we only parse the typeshed versions when we actually need to: some module resolutions won't require us to look at typeshed <code>VERSIONS</code> at all, whereas if the method requires <code>TypeshedVersions</code> as an argument then we need to parse the <code>VERSIONS</code> file eagerly whether or not it ends up being resolved using a standard-library search path. <code>parse_typeshed_versions</code> is a Salsa-tracked function, as well, so the results should be memoized after the first call until the <code>VERSIONS</code> file is edited or deleted by the user from the custom typeshed directory (which should be very rare).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-03 13:24</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:691 on 2024-07-03 13:24</div>
            <div class="timeline-body"><p>Oh, I wasn't aware that we use <code>last</code> somewhere.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-03 13:26</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:453 on 2024-07-03 13:26</div>
            <div class="timeline-body"><p>This is because your type is copy, so you have to change from <code>&amp;self</code> to <code>self</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:453 on 2024-07-03 13:27</div>
            <div class="timeline-body"><p>Aha, thanks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 13:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 13:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:691 on 2024-07-03 13:41</div>
            <div class="timeline-body"><p>We don't. It just feels like a theoretical footgun to provide an <code>Iterator</code> interface that <em>could</em> have a very efficient <code>last()</code> method, but doesn't.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-03 13:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:691 on 2024-07-03 13:44</div>
            <div class="timeline-body"><p>I would remove it then. By default, calling <code>last</code> on an <code>Iterator</code> is <code>O(n)</code>. That's why I always double check if the iterator implements <code>DoubleEndedIterator</code> if I call the method in a hot code path.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 14:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:41 on 2024-07-03 14:10</div>
            <div class="timeline-body"><p>I'm not sure what the best long-term solution here is. In the long term, we may want to go back to this, as there are complications to do with <code>site-packages</code> that I haven't yet implemented. However, I agree that for now, this doesn't really buy us much. I've got rid of the inner structs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 14:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:578 on 2024-07-03 14:11</div>
            <div class="timeline-body"><p>I've just made a number of details more private to <code>path.rs</code>, so that we don't rely on this logic nearly as much. I think it should be fairly easy to adjust it when we add support for vendored files.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 14:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:691 on 2024-07-03 14:11</div>
            <div class="timeline-body"><p>Alright :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-03 15:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:650 on 2024-07-03 15:05</div>
            <div class="timeline-body"><p>You're right, this does do the right thing. The thing I was confused about is for some reason I wasn't sure whether <code>next_back()</code> calls consumed the end of the iterator in a way that would be guaranteed to then be reflected when walking the iterator from the start. But it makes sense that it would be.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-04 14:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:169 on 2024-07-04 14:10</div>
            <div class="timeline-body"><p>Possibly, but I'm still not sure I like that. I'd prefer to defer that to a followup, anyway. I'll add a TODO here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @AlexWaygood on 2024-07-04 16:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-07-04 16:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-07-04 16:47</div>
            <div class="timeline-body"><p>Okay -- I'm now happy with the test coverage here! This is out of draft mode now, and ready for review.</p>
<p>Again -- let me know if you would prefer me to split this up a bit. It would be pretty easy to do so, if that would make reviewing easier. I don't mind.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] WIP: respect typeshed's `VERSIONS` file when resolving stdlib modules" to "[red-knot] Respect typeshed's `VERSIONS` file when resolving stdlib modules" by @AlexWaygood on 2024-07-04 16:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-04 16:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/module_name.rs</code>:1 on 2024-07-04 16:57</div>
            <div class="timeline-body"><p>(This is nearly all just directly moved from <code>module.rs</code>, so that it can be imported in <code>path.rs</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:169 on 2024-07-04 16:59</div>
            <div class="timeline-body"><p>Seems fair. Can we add a <code>TODO</code> to all call sites where we do <code>unwrap</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:946 on 2024-07-04 17:01</div>
            <div class="timeline-body"><p>Can you try removing the <code>*</code> on both sides? I get the impression that both paths are probably already of the same type and we can just compare the references.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:121 on 2024-07-04 17:02</div>
            <div class="timeline-body"><p>You could move the test methods into mod tests</p>
<pre><code>#[cfg(test)]
mod tests {
	impl TypeshedVersions {
		fn len(&amp;self) -&gt; size { }

		...
}
</code></pre>
<p>It would remove the need for the comment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:161 on 2024-07-04 17:03</div>
            <div class="timeline-body"><p>Would you mind documenting the variants. To me it's not very clear what <code>MaybeExists</code> means</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-07-04 17:03</div>
            <div class="timeline-body"><p>I appreciate that it's still a bit light on docs. I can work on some more internal documentation for some of the added types tomorrow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:123 on 2024-07-04 17:06</div>
            <div class="timeline-body"><p>I recommend removing this code. It only gets outdated and doesn't convey a lot of information. On the other hand, I would find a comment explaining what the function does useful</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:128 on 2024-07-04 17:07</div>
            <div class="timeline-body"><p>Do we have many places where we pass something that isn't a <code>PyVersion</code>? I would otherwise recommend just taking a <code>PyVersion</code> to avoid any monomorphization (every <code>impl</code> is a tradeoff between calling convenience and code size)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-04 17:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:578 on 2024-07-04 17:15</div>
            <div class="timeline-body"><p>While writing tests, I realised that the two places where we still used this... were in fact bugs. So it's gone entirely now üòÑ</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:356 on 2024-07-05 06:25</div>
            <div class="timeline-body"><p>I agree, we should avoid resolving <code>TypeshedVersions</code> if they aren't needed. I think you can use an <code>Option</code> or <code>OnceCell</code> to cache the versions lazily. https://doc.rust-lang.org/std/cell/struct.OnceCell.html</p>
<blockquote>
<p>parse_typeshed_versions is a Salsa-tracked function,</p>
</blockquote>
<p>That's correct, but caching still has a non-trivial overhead of doing a lookup in a concurrent hash map and then checking if the revision is still fresh.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:131 on 2024-07-05 06:27</div>
            <div class="timeline-body"><p>That's a good point. I'm okay with delaying it. I do think that we want some form of eager validation of the typeshed path and possibly even abort if the path is invalid. But we can look into this when adding support for settings.</p>
<p>Having said that. I would expect that the CLI eagerly validates the custom typeshed path and aborts if the path doesn't exist or the versions file can't be parsed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:128 on 2024-07-05 06:28</div>
            <div class="timeline-body"><p>I think for now I would make <code>TargetPyVersion</code> a field on <code>ModuleResolutionSettings</code>. I expect that the field (and all other module resolution settings) will be derived from the settings long-term. It also simplifies the setup because we only need a single &quot;Input&quot; for everything module resolution later (and it solves your naming problem)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:290 on 2024-07-05 06:34</div>
            <div class="timeline-body"><p>The logic here is almost the same as in <code>is_regular_package</code> except that it doesn't append <code>__init__.pyi</code> to the file path. Is this intentional? If not, can we extract the common logic into a standalone function? Same for <code>is_directory</code>, they all seem to be almost the same.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:468 on 2024-07-05 06:36</div>
            <div class="timeline-body"><p>Is it possible that <code>strip_prefix</code> can create a path which violates the constraints that <code>Self::first_party</code> requires? If not, then use</p>
<pre><code class="language-suggestion">            ModuleResolutionPathRefInner::FirstParty(root) =&gt; absolute_path
                .strip_prefix(root)
                .ok()
                .map(|paht| Self(ModuleResolutionPathInner::FirstParty(path))),
            ModuleResolutionPathRefInner::StandardLibrary(root) =&gt; absolute_path
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:507 on 2024-07-05 06:37</div>
            <div class="timeline-body"><p>The <code>from</code> implementation here only seems to be necessary to implement <code>impl&lt;'a&gt; From&lt;&amp;'a ModuleResolutionPathBuf&gt; for ModuleResolutionPathRef&lt;'a&gt; {</code></p>
<p>I would remove this impl and instead move the code right into <code>impl&lt;'a&gt; From&lt;&amp;'a ModuleResolutionPathBuf&gt; for ModuleResolutionPathRef&lt;'a&gt; {</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:161 on 2024-07-05 06:38</div>
            <div class="timeline-body"><p>This implementation is unused. We should delete it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:537 on 2024-07-05 06:43</div>
            <div class="timeline-body"><p>This <code>Eq</code> implementation seems unused. Let's delete it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:549 on 2024-07-05 06:43</div>
            <div class="timeline-body"><p>You don't need the explicit lifetimes</p>
<pre><code class="language-suggestion">impl PartialEq&lt;FileSystemPath&gt; for ModuleResolutionPathRef&lt;'_&gt; {
    fn eq(&amp;self, other: &amp;FileSystemPath) -&gt; bool {
        self.0.as_file_system_path() == other
    }
}

impl PartialEq&lt;ModuleResolutionPathRef&lt;'_&gt;&gt; for FileSystemPath {
    fn eq(&amp;self, other: &amp;ModuleResolutionPathRef) -&gt; bool {
        self == other.0.as_file_system_path()
    }
}

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:567 on 2024-07-05 06:44</div>
            <div class="timeline-body"><p>I recomment using <code>assert_eq</code> here. It gives better error messages in case the path is <code>Some</code></p>
<pre><code class="language-suggestion">        assert_eq!(ModuleResolutionPathBuf::standard_library(&quot;foo.py&quot;), None);
        assert_eq!(ModuleResolutionPathBuf::standard_library(&quot;foo/__init__.py&quot;), None);
        assert_eq!(ModuleResolutionPathBuf::standard_library(&quot;foo.py.pyi&quot;), None);
    }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:581 on 2024-07-05 06:48</div>
            <div class="timeline-body"><p>I don't think snapshot testing is a good choise for these tests. In general, consider snapshot testing a last resort. I know, snapshot tests are very convenient to write but they come up at a cost:</p>
<ul>
<li>They aren't very explicit about what they are asserting. What is this test asserting: That the path is a <code>StandardLibrary</code> path or that the path is <code>foo</code> or both?</li>
<li>They are easy to update but changes are hard to review (because the assertions aren't explicit). The chances that I miss a true-positive test failure in a snapshot is a multitude higher than for a regular test.</li>
<li>Any changes to the debug output of <code>ModuleResolutionPath</code> breaks all tests.</li>
<li>Snapshot testing is a heavy infrastructure, making our tests slower</li>
</ul>
<p>I would stronlgy prefer to use regular assertions instead. Here, it's as easy as using `assert_eq(stdlib_path_test_case(&quot;foo&quot;), ModuleResolutionPathRef(ModuleResolutionPathInner::StandardLibrary(FileSystemPath::new(&quot;foo&quot;)));</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:576 on 2024-07-05 06:49</div>
            <div class="timeline-body"><p>The name here should either be <code>ModuleResolutionPathRef</code> or <code>ModuleResolutionPathBuf</code>, because no type <code>ModuleResolutionPath</code> exists.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:852 on 2024-07-05 06:50</div>
            <div class="timeline-body"><p>IMO: If the assertion is worth testing, than it shouldn't be a runtime assertion OR the constructor should return <code>None</code> in that case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:954 on 2024-07-05 06:52</div>
            <div class="timeline-body"><p>We should make sure that the debug implementations between <code>ModuleResolutionPathRef</code> and <code>ModuleResolutionPathBuf</code> are consistent (by either removing the custom Debug implementation or have a custom debug implementation for both).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:488 on 2024-07-05 06:57</div>
            <div class="timeline-body"><p>This test now seems to do way more than just asserting whether the file can be parsed and I find it hard to understand. It also depends on the real <code>VERSIONS</code> file, meaning a test failure here can either mean that the <code>VERSIONS</code> file has changed or that the implementation broke.</p>
<p>I would strongly prefer to split this test into smaller tests where each uses a trimmed down <code>VERSIONS</code> file (ideally, only the relevant lines for that test). Splitting this test into smaller tests will help readers to understand the test-scenario and expected output. For exmaple, to me it's unclear why we need this many tests? Are we trying to exhaustively test all possible versions or is each of these blocks testing a specific scenario?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:27 on 2024-07-05 07:00</div>
            <div class="timeline-body"><p>We should try to avoid creating unnecessary salsa ingredients. Querying them, persisting them, and keeping them in memory all comes at a cost. I think I would aim for a single input ingredient for everything module resolver related (which kind of comes back that <code>ModuleResolutionSettings</code> maybe should be that input and it gets created with a builder)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/db.rs</code>:226 on 2024-07-05 07:04</div>
            <div class="timeline-body"><p>Nit</p>
<pre><code class="language-suggestion">        let src = FileSystemPath::from(&quot;/src&quot;);
        let site_packages = FileSystemPath::from(&quot;/site_packages&quot;);
        let custom_typeshed = FileSystemPath::from(&quot;/typeshed&quot;);
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/db.rs</code>:232 on 2024-07-05 07:05</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        fs.create_directory_all(&amp;src)?;
        fs.create_directory_all(&amp;site_packages)?;
        fs.create_directory_all(&amp;custom_typeshed)?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/module_name.rs</code>:1 on 2024-07-05 07:08</div>
            <div class="timeline-body"><p>What's the <strong>not</strong> nearly part :D</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/module_name.rs</code>:172 on 2024-07-05 07:11</div>
            <div class="timeline-body"><p>IMO: The nesting here makes the code rather hard to read.</p>
<pre><code class="language-suggestion">        let name = if let Some(second_part) = components.next() {
            if !is_identifier(second_part) {
                return None;
            }
            let mut name = format!(&quot;{first_part}.{second_part}&quot;);
            for part in components {
                if !is_identifier(part) {
                    return None;
                }
                name.push('.');
                name.push_str(part);
            }
            CompactString::from(&amp;name)
        } else {
            CompactString::from(first_part)
        };

        Some(Self(name))
</code></pre>
<p>But I think we can simplify the implementation to</p>
<pre><code class="language-rust">        let mut components = components.into_iter();
        let first_part = components.next()?;
        if !is_identifier(first_part) {
            return None;
        }

        let mut name = first_part.to_compact_string();
        for part in components {
            if !is_identifier(part) {
                return None;
            }

            name.push('.');
            name.push_str(part);
        }

        Some(Self(name))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:169 on 2024-07-05 07:15</div>
            <div class="timeline-body"><p>Nit:</p>
<pre><code>let mut paths: Vec&lt;_&gt; = extra_paths
            .into_iter()
            .map(|path| ModuleResolutionPathBuf::extra(path).unwrap())
            .collect();
</code></pre>
<p>Makes it more obvious which path failed to unwrap.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:378 on 2024-07-05 07:19</div>
            <div class="timeline-body"><pre><code class="language-suggestion">            .write_file(&amp;foo_path, &quot;print('Hello, world!')&quot;)?;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:391 on 2024-07-05 07:19</div>
            <div class="timeline-body"><pre><code class="language-suggestion">        assert_eq!(&amp;foo_path, foo_module.file().path(&amp;db));
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:388 on 2024-07-05 07:22</div>
            <div class="timeline-body"><p>You can add one more <code>PartialEq</code> implementation to avoid all the stars here</p>
<pre><code class="language-rust">impl PartialEq&lt;ModuleResolutionPathRef&lt;'_&gt;&gt; for &amp;FileSystemPath {
    fn eq(&amp;self, other: &amp;ModuleResolutionPathRef) -&gt; bool {
        *self == other
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:373 on 2024-07-05 07:23</div>
            <div class="timeline-body"><p>Nit: Maybe consider adding a simple <code>setup_resolver_test()</code> function that calls <code>create_resolver_builder().build()</code> to make the tests a bit less verbose.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:510 on 2024-07-05 07:24</div>
            <div class="timeline-body"><p>I think I would move this into its own test. The boilerplate is fairly limited and it is testing something else.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:482 on 2024-07-05 07:25</div>
            <div class="timeline-body"><p>What's the difference between this test and the <code>py38</code> test other than the python version. Would just one of the tests be sufficient or are both needed to test the full behavior?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:539 on 2024-07-05 07:26</div>
            <div class="timeline-body"><p>I recommend you to go once more througth all <code>*</code> usages and see if you can use <code>&amp;</code> instead or don't need them all together.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:296 on 2024-07-05 07:28</div>
            <div class="timeline-body"><p>Nice, that's even better than a custom iterator!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:583 on 2024-07-05 07:39</div>
            <div class="timeline-body"><p>Wow, this is very intensive testing that you added for path and I really apprevciate your care and time that you took to write all of them.</p>
<p>I'm feeling a bit conflicted about some of the tests. I can see how they're useful when making the implementation but I fear they'll create a larger long-term coast than the value they provide (and writing the tests also comes at a cost):</p>
<ul>
<li>A lot of these (not all) tests test simple trivia. I can see that having the test can help when implementing the function but I'm not sure what the long-term value of the tests are and maintaining the code comes at a cost (and just looking at 1500 lines of tests is intimiating, and hides the real important tests).</li>
<li>Most of the tests are precisely testing the implementation (and often match the implementation 1:1). Any change to the implementation will require a change to the test, significantely reducing the value of the tests and increasing maintenance cost long term. The most valuable tests are tests that keep functioning even when you refactor code. I think the resolver tests are a good exmaple. We refactored the implementation 2 times but the tests are still mostly unchanged, providing a safety net when making the refactor. I don't this applies to some tests in this module. Refactoring the path representation would require rewriting all these tests.</li>
</ul>
<p>This makes me wonder how many of these tests we still need and if we could get the same coverage by extending our module resolver tests (e.g. by porting the tests from import resolver). I think we should at least reduce the number of tests. We don't need to aim for full exhaustiveness when testing.
For example, do we need all of the <code>stdlib_path_*</code> tests or would one where it returns <code>None</code> and one where it returns <code>Some</code> be sufficient? I do like the <code>module_name_*</code> but do we need all of them? Are all of them testing different code paths or are we trying to test for full exhaustiveness?</p>
<p>We don't need to do this as part of this PR, the PR is already big enough. But increasing the module resolver coverage seems desirable to me, especially if it helps to avoid some more &quot;boilerplate&quot;ish tests in here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:656 on 2024-07-05 07:43</div>
            <div class="timeline-body"><p>Uh, I don't think I understand what this method is doing. I think it tests that <code>to_module_name</code> of each variant returns the same module name and it then returns one of the module names?</p>
<p>I think writing out the assertions would make debugging this test much easier (and there are only three variants!). I would also take the expected module name as an argument, again, simplifying the code</p>
<pre><code class="language-suggestion">    fn assert_non_stdlib_module_name(path: &amp;str, expected_name: &amp;ModuleName) {    
        assert_eq!(&amp;ModuleResolutionPathRef::extra(path).unwrap().to_module_name(), expected_module_name);
        assert_eq!(&amp;ModuleResolutionPathRef::first_party(path).unwrap().to_module_name(), expected_module_name);
        assert_eq!(&amp;ModuleResolutionPathRef::site_packages(path).unwrap().to_module_name(), expected_module_name);
    }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:572 on 2024-07-05 07:45</div>
            <div class="timeline-body"><p>IMO, the helper function obscures the test logic because the function name isn't telling me anything about what <code>stdlib_test_case</code> is doing. I have to jump to the definition to understand the test case. I would just inline the method or rename the method to <code>unwrap_standard_library(path: &amp;str)</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:794 on 2024-07-05 07:51</div>
            <div class="timeline-body"><p>We should avoid numbering tests. It makes it extremelly difficult to understand what a test is testing and, from it, derive what the expected behavior is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-07-05 07:57</div>
            <div class="timeline-body"><p>Nice! Let's try to get this merged today. I think the PR summary needs updating ;)</p>
<p>Most of my comments are nits. My only real concern are the tests in <code>path.rs</code>. You showed a lot of care for writing all of them but I don't think snapshot testing is the appropriate tool for that level of testing and I'm worried that the tests are aiming for exhaustiveness, testing all details of the implementation, rather than the relevant observed module resolution behavior. That's why I think we should try to reduce them to the most important tests that are also worth keeping when refactoring the code. As a measure of the cost of the tests: I just spent close to an hour trying to understand the tests and figuring out which one's are showing the most important behavior of the implementation.</p>
<p>That's why I think we should reduce the tests and instead  aim to increase the module-resolver level testing (doesn't have to be part of this PR but I think that should be a goal for next week)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:296 on 2024-07-05 09:48</div>
            <div class="timeline-body"><p>yeah, I realised yesterday that I was overcomplicating it üòÑ your suggestion of adding a <code>ModuleName::from_components()</code> method made it much easier to see how to do it more simply :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 09:48</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 09:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/module_name.rs</code>:1 on 2024-07-05 09:49</div>
            <div class="timeline-body"><p>The <code>from_relative_path()</code> method is removed. A <code>from_components()</code> method is added instead.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 09:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:356 on 2024-07-05 09:55</div>
            <div class="timeline-body"><blockquote>
<p>I agree, we should avoid resolving <code>TypeshedVersions</code> if they aren't needed. I think you can use an <code>Option</code> or <code>OnceCell</code> to cache the versions lazily. <a href="https://doc.rust-lang.org/std/cell/struct.OnceCell.html">doc.rust-lang.org/std/cell/struct.OnceCell.html</a></p>
</blockquote>
<p>Ahh, that's very clever. Thanks!</p>
<blockquote>
<p>That's correct, but caching still has a non-trivial overhead of doing a lookup in a concurrent hash map and then checking if the revision is still fresh.</p>
</blockquote>
<p>Hmm, fair enough. I guess I'm used to Python, where looking things up in a cache is ~free for a method decorated with <code>@functools.lru_cache</code> :-) But I guess in Rust, ~everything's faster than Python, so the cost of looking things up in a cache becomes significant.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 12:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:356 on 2024-07-05 12:02</div>
            <div class="timeline-body"><p>It took me a while to figure out how to do this, as the lifetimes got quite complicated. In the end I succeeded, but I had to reintroduce an <code>Arc</code> in the <code>TypeshedVersions</code> struct rather than have the Salsa query return a reference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 12:17</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:468 on 2024-07-05 12:17</div>
            <div class="timeline-body"><p>Good point. I think you're right; validation here wouldn't be necessary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 12:27</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:468 on 2024-07-05 12:27</div>
            <div class="timeline-body"><p>Ah, no, validation <em>is</em> necessary here. <code>absolute_path</code> isn't a <code>ModuleResolutionPath</code>, it's a <code>FileSystemPath</code>, so it hasn't been validated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 12:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:852 on 2024-07-05 12:54</div>
            <div class="timeline-body"><p>I was worried that this would make <code>push()</code> and <code>join()</code> quite expensive. But your reasoning makes sense. If it's an invariant important enough to be tested (which I think it is), it should be asserted in release builds as well as debug builds. I've made the change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 13:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/module_name.rs</code>:172 on 2024-07-05 13:01</div>
            <div class="timeline-body"><blockquote>
<p>But I think we can simplify the implementation</p>
</blockquote>
<p>Does the <code>to_compact_string()</code> method allocate? The implementation I've written tries quite hard to avoid allocating if it's unnecessary</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 13:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:539 on 2024-07-05 13:02</div>
            <div class="timeline-body"><p>Thanks, I've done that. They were definitely necessary at some earlier point in this PR's history, but they no longer are. Annoying that Clippy didn't spot this :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 13:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:161 on 2024-07-05 13:15</div>
            <div class="timeline-body"><p>Done in https://github.com/astral-sh/ruff/pull/12141/commits/470f0c6f1595d9ee9eec65bbdbe31b6ebc1c494f</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 14:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:482 on 2024-07-05 14:12</div>
            <div class="timeline-body"><p>I think they're both needed. Only by testing both with py38 and py39 do we assert the important invariant that changing the target version results in different module-resolution behaviours even though the stubs are available on disk in both situations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 14:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:542 on 2024-07-05 14:18</div>
            <div class="timeline-body"><p>(I already copied over this test into <code>typeshed.rs</code> in a prior PR. I thought I'd deleted this commented out version, but I obviously hadn't.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 14:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:488 on 2024-07-05 14:22</div>
            <div class="timeline-body"><blockquote>
<p>It also depends on the real <code>VERSIONS</code> file</p>
</blockquote>
<p>I don't think that's true. This test only uses the mock.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 14:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/typeshed/versions.rs</code>:488 on 2024-07-05 14:23</div>
            <div class="timeline-body"><p>But I can definitely split this test up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 16:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:581 on 2024-07-05 16:16</div>
            <div class="timeline-body"><p>Thanks. I think I'm still figuring out exactly what's idiomatic and what's not when it comes to writing tests in Rust! I've removed snapshot testing for everything except the tests that are actually, and replaced it with simpler assertions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 16:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:583 on 2024-07-05 16:50</div>
            <div class="timeline-body"><p>Thanks! I've simplified the tests and reduced the overall number quite a lot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:38 on 2024-07-05 16:50</div>
            <div class="timeline-body"><p>I'm not sure I understand what restriction this is implementing. Why is it relevant only to the standard library, and only in the case where the component we are pushing has an extension?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:28 on 2024-07-05 16:57</div>
            <div class="timeline-body"><p>Should we also be tracking whether the final component of the path already has an extension, and if so disallow pushing any further components? I guess it's not clear to me how we decide which validity invariants need to be enforced here, because it doesn't seem like we enforce all of them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:89 on 2024-07-05 16:57</div>
            <div class="timeline-body"><p>Note that here you check this condition in all cases, whereas above you check it only if there is an extension.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 17:19</div>
            <div class="timeline-body"><p>I find it quite confusing in reading the code, and I think also it is error-prone, that we use the same type to represent both (a) a search path root, and (b) the path to an actual module. I think these are different things that need to obey different constraints (e.g. a search path root should never have any file extension at all) and provide different behaviors (e.g. a search path root shouldn't be mutable; we shouldn't ever push new components to it; many of the other methods provided here are also never used - and should never be used, because they aren't even meaningful - on a search root).</p>
<p>IMO it will be a lot clearer if we explicitly represent these as different types. Right now we only know which is which by context in the calling code; we get no help from the type system in differentiating two things that should never be confused with each other. I don't think it would even be that complex a change; it would just mean that in some cases where we currently &quot;clone&quot; a search root into an initial package path, we'd instead be explicitly constructing one type from the other.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:333 on 2024-07-05 17:24</div>
            <div class="timeline-body"><p>I'm finding it quite hard to understand the handling of relative vs absolute paths. Here in this method we create instances of <code>ModuleResolutionPathRef</code> that contain relative paths, but then in the above methods it seems like we expect them to contain absolute paths, because for non-stdlib variants we just ignore the passed-in search path entirely.</p>
<p>I think we should establish some clarity/invariants around which kinds of paths should be absolute and which should be relative.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:227 on 2024-07-05 17:25</div>
            <div class="timeline-body"><p>I really don't like that we ignore the passed-in search path entirely for non-stdlib variants in so many of these methods. It seems very error-prone. At the very least I'd want to see some debug assertions of consistency, though I'd rather have an API that didn't have redundant information in the first place (e.g. if module paths were enforced as always relative and required to be combined with a search path to be turned into an absolute path.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:182 on 2024-07-05 17:46</div>
            <div class="timeline-body"><p>Should this comment reference the appropriate section of the typing spec (which is what we actually care about) rather than the PEP?</p>
<p>Do we have any remaining intentional differences with the typing spec?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:195 on 2024-07-05 17:48</div>
            <div class="timeline-body"><p><code>ResolvedModuleResolutionSettings</code> is a kind of unfortunate name (due to the double use of &quot;Resolved/Resolution&quot; for very different meanings within the same name).</p>
<p>Could this just be <code>ModuleResolutionSettings</code> and the raw version be <code>RawModuleResolutionSettings</code> or <code>ModuleResolutionSettingsInput</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-05 17:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-05 17:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 17:57</div>
            <div class="timeline-body"><p>It might even make sense that a package/module path is always represented as simply a relative path and an Arc to a search root. Then the &quot;kind&quot; is already encoded in the search root kind, and we can also eliminate all these cases of needing to make sure the passed-in search root kind matches the module path kind.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 17:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:182 on 2024-07-05 17:59</div>
            <div class="timeline-body"><p>Yes, this comment is now out of date; good catch.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-05 19:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/resolver.rs</code>:195 on 2024-07-05 19:08</div>
            <div class="timeline-body"><p>I would leave it as is. Input is misleading because it gives the impression that it is a salsa input where it is not. We discussed alternatives, for example using a builder that directly constructs the &quot;resolved&quot; thing but decided to leave this for another day. I suspect that all of this will change anyway when we introduce settings</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-05 19:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 19:12</div>
            <div class="timeline-body"><p>Alex's first version used different types for each path variant and it added a ton of boilerplate code (about 1000 lines) that made it very hard to find the &quot;important&quot; bits. I also think that it didn't add much value because the only places where the different path types were used were in the match arms of that given variant. In which case using different types doesn't protect from much. If you screw up the variant name, than it is as easy to screw up the path type as well (and it's a very easy error to spot).</p>
<p>I would think differently if the paths were exposed externally, which they are not.</p>
<p>Whether we should expose the search path root from an actual path differently, I don't know. It's also unclear to me how the code would need to change for that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-05 19:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 19:14</div>
            <div class="timeline-body"><p>I don't think &quot;use different types for each path variant&quot; is at all related to the suggestion I'm making here. I don't think that would be a good idea.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:206 on 2024-07-05 19:25</div>
            <div class="timeline-body"><p><code>db</code>, should for consistency reasons always be the first argument</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-07-05 19:40</div>
            <div class="timeline-body"><p>You can avoid the <code>Arc</code> by adding a few lifetimes:</p>
<pre><code class="language-patch">Index: crates/red_knot_module_resolver/src/resolver.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/red_knot_module_resolver/src/resolver.rs b/crates/red_knot_module_resolver/src/resolver.rs
--- a/crates/red_knot_module_resolver/src/resolver.rs	(revision 4c7a1061a9e11a1b404e1c5cf6c334a2890a73c1)
+++ b/crates/red_knot_module_resolver/src/resolver.rs	(date 1720208092508)
@@ -309,11 +309,11 @@
     None
 }
 
-fn resolve_package&lt;'a, I&gt;(
-    db: &amp;dyn Db,
+fn resolve_package&lt;'a, 'db, I&gt;(
+    db: &amp;'db dyn Db,
     module_search_path: &amp;ModuleResolutionPathBuf,
     components: I,
-    typeshed_versions: &amp;LazyTypeshedVersions,
+    typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
     target_version: TargetVersion,
 ) -&gt; Result&lt;ResolvedPackage, PackageKind&gt;
 where
Index: crates/red_knot_module_resolver/src/typeshed/versions.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/red_knot_module_resolver/src/typeshed/versions.rs b/crates/red_knot_module_resolver/src/typeshed/versions.rs
--- a/crates/red_knot_module_resolver/src/typeshed/versions.rs	(revision 4c7a1061a9e11a1b404e1c5cf6c334a2890a73c1)
+++ b/crates/red_knot_module_resolver/src/typeshed/versions.rs	(date 1720207666907)
@@ -14,11 +14,13 @@
 
 use crate::db::Db;
 use crate::module_name::ModuleName;
+use crate::resolver::ResolvedModuleResolutionSettings;
 use crate::supported_py_version::TargetVersion;
+use crate::ModuleResolutionSettings;
 
-pub(crate) struct LazyTypeshedVersions(OnceCell&lt;TypeshedVersions&gt;);
+pub(crate) struct LazyTypeshedVersions&lt;'db&gt;(OnceCell&lt;&amp;'db TypeshedVersions&gt;);
 
-impl LazyTypeshedVersions {
+impl&lt;'db&gt; LazyTypeshedVersions&lt;'db&gt; {
     #[must_use]
     pub(crate) fn new() -&gt; Self {
         Self(OnceCell::new())
@@ -40,7 +42,7 @@
     pub(crate) fn query_module(
         &amp;self,
         module: &amp;ModuleName,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         stdlib_root: &amp;FileSystemPath,
         target_version: TargetVersion,
     ) -&gt; TypeshedVersionsQueryResult {
@@ -56,16 +58,14 @@
             // this should invalidate not just the specific module resolution we're currently attempting,
             // but all type inference that depends on any standard-library types.
             // Unwrapping here is not correct...
-            parse_typeshed_versions(db, versions_file)
-                .as_ref()
-                .unwrap()
-                .clone()
+            parse_typeshed_versions(db, versions_file).as_ref().unwrap()
         });
+
         versions.query_module(module, PyVersion::from(target_version))
     }
 }
 
-#[salsa::tracked]
+#[salsa::tracked(return_ref)]
 pub(crate) fn parse_typeshed_versions(
     db: &amp;dyn Db,
     versions_file: VfsFile,
@@ -152,8 +152,8 @@
     }
 }
 
-#[derive(Debug, Clone, PartialEq, Eq)]
-pub(crate) struct TypeshedVersions(Arc&lt;FxHashMap&lt;ModuleName, PyVersionRange&gt;&gt;);
+#[derive(Debug, PartialEq, Eq)]
+pub(crate) struct TypeshedVersions(FxHashMap&lt;ModuleName, PyVersionRange&gt;);
 
 impl TypeshedVersions {
     #[must_use]
@@ -300,7 +300,7 @@
                 reason: TypeshedVersionsParseErrorKind::EmptyVersionsFile,
             })
         } else {
-            Ok(Self(Arc::new(map)))
+            Ok(Self(map))
         }
     }
 }
Index: crates/red_knot_module_resolver/src/path.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/red_knot_module_resolver/src/path.rs b/crates/red_knot_module_resolver/src/path.rs
--- a/crates/red_knot_module_resolver/src/path.rs	(revision 4c7a1061a9e11a1b404e1c5cf6c334a2890a73c1)
+++ b/crates/red_knot_module_resolver/src/path.rs	(date 1720208063481)
@@ -108,11 +108,11 @@
     }
 
     #[must_use]
-    pub(crate) fn is_regular_package(
+    pub(crate) fn is_regular_package&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: &amp;Self,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; bool {
         ModuleResolutionPathRef::from(self).is_regular_package(
@@ -124,11 +124,11 @@
     }
 
     #[must_use]
-    pub(crate) fn is_directory(
+    pub(crate) fn is_directory&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: &amp;Self,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; bool {
         ModuleResolutionPathRef::from(self).is_directory(
@@ -158,11 +158,11 @@
     }
 
     /// Returns `None` if the path doesn't exist, isn't accessible, or if the path points to a directory.
-    pub(crate) fn to_vfs_file(
+    pub(crate) fn to_vfs_file&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: &amp;Self,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; Option&lt;VfsFile&gt; {
         ModuleResolutionPathRef::from(self).to_vfs_file(
@@ -198,12 +198,12 @@
 
 impl&lt;'a&gt; ModuleResolutionPathRefInner&lt;'a&gt; {
     #[must_use]
-    fn query_stdlib_version(
+    fn query_stdlib_version&lt;'db&gt;(
         module_path: &amp;'a FileSystemPath,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         stdlib_search_path: Self,
         stdlib_root: &amp;FileSystemPath,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         target_version: TargetVersion,
     ) -&gt; TypeshedVersionsQueryResult {
         let Some(module_name) = stdlib_search_path
@@ -216,11 +216,11 @@
     }
 
     #[must_use]
-    fn is_directory(
+    fn is_directory&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: Self,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; bool {
         match (self, search_path) {
@@ -241,11 +241,11 @@
     }
 
     #[must_use]
-    fn is_regular_package(
+    fn is_regular_package&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: Self,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; bool {
         fn is_non_stdlib_pkg(path: &amp;FileSystemPath, db: &amp;dyn Db) -&gt; bool {
@@ -274,11 +274,11 @@
         }
     }
 
-    fn to_vfs_file(
+    fn to_vfs_file&lt;'db&gt;(
         self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: Self,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; Option&lt;VfsFile&gt; {
         match (self, search_path) {
@@ -386,11 +386,11 @@
 
 impl&lt;'a&gt; ModuleResolutionPathRef&lt;'a&gt; {
     #[must_use]
-    pub(crate) fn is_directory(
+    pub(crate) fn is_directory&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: impl Into&lt;Self&gt;,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; bool {
         self.0
@@ -398,11 +398,11 @@
     }
 
     #[must_use]
-    pub(crate) fn is_regular_package(
+    pub(crate) fn is_regular_package&lt;'db&gt;(
         &amp;self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: impl Into&lt;Self&gt;,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; bool {
         self.0
@@ -410,11 +410,11 @@
     }
 
     #[must_use]
-    pub(crate) fn to_vfs_file(
+    pub(crate) fn to_vfs_file&lt;'db&gt;(
         self,
-        db: &amp;dyn Db,
+        db: &amp;'db dyn Db,
         search_path: impl Into&lt;Self&gt;,
-        typeshed_versions: &amp;LazyTypeshedVersions,
+        typeshed_versions: &amp;LazyTypeshedVersions&lt;'db&gt;,
         target_version: TargetVersion,
     ) -&gt; Option&lt;VfsFile&gt; {
         self.0
@@ -794,7 +794,7 @@
         );
     }
 
-    fn py38_stdlib_test_case() -&gt; (TestDb, ModuleResolutionPathBuf, LazyTypeshedVersions) {
+    fn py38_stdlib_test_case() -&gt; (TestDb, ModuleResolutionPathBuf) {
         let TestCase {
             db,
             custom_typeshed,
@@ -802,12 +802,14 @@
         } = create_resolver_builder().unwrap().build();
         let stdlib_module_path =
             ModuleResolutionPathBuf::stdlib_from_typeshed_root(&amp;custom_typeshed).unwrap();
-        (db, stdlib_module_path, LazyTypeshedVersions::new())
+        (db, stdlib_module_path)
     }
 
     #[test]
     fn mocked_typeshed_existing_regular_stdlib_pkg_py38() {
-        let (db, stdlib_path, versions) = py38_stdlib_test_case();
+        let (db, stdlib_path) = py38_stdlib_test_case();
+
+        let versions = LazyTypeshedVersions::new();
 
         let asyncio_regular_package = stdlib_path.join(&quot;asyncio&quot;);
         assert!(asyncio_regular_package.is_directory(
@@ -855,7 +857,9 @@
 
     #[test]
     fn mocked_typeshed_existing_namespace_stdlib_pkg_py38() {
-        let (db, stdlib_path, versions) = py38_stdlib_test_case();
+        let (db, stdlib_path) = py38_stdlib_test_case();
+
+        let versions = LazyTypeshedVersions::new();
 
         let xml_namespace_package = stdlib_path.join(&quot;xml&quot;);
         assert!(xml_namespace_package.is_directory(
@@ -886,7 +890,9 @@
 
     #[test]
     fn mocked_typeshed_single_file_stdlib_module_py38() {
-        let (db, stdlib_path, versions) = py38_stdlib_test_case();
+        let (db, stdlib_path) = py38_stdlib_test_case();
+
+        let versions = LazyTypeshedVersions::new();
 
         let functools_module = stdlib_path.join(&quot;functools.pyi&quot;);
         assert!(functools_module
@@ -903,9 +909,10 @@
 
     #[test]
     fn mocked_typeshed_nonexistent_regular_stdlib_pkg_py38() {
-        let (db, stdlib_path, versions) = py38_stdlib_test_case();
+        let (db, stdlib_path) = py38_stdlib_test_case();
 
         let collections_regular_package = stdlib_path.join(&quot;collections&quot;);
+        let versions = LazyTypeshedVersions::new();
         assert_eq!(
             collections_regular_package.to_vfs_file(
                 &amp;db,
@@ -931,7 +938,8 @@
 
     #[test]
     fn mocked_typeshed_nonexistent_namespace_stdlib_pkg_py38() {
-        let (db, stdlib_path, versions) = py38_stdlib_test_case();
+        let (db, stdlib_path) = py38_stdlib_test_case();
+        let versions = LazyTypeshedVersions::new();
 
         let importlib_namespace_package = stdlib_path.join(&quot;importlib&quot;);
         assert_eq!(
@@ -972,7 +980,8 @@
 
     #[test]
     fn mocked_typeshed_nonexistent_single_file_module_py38() {
-        let (db, stdlib_path, versions) = py38_stdlib_test_case();
+        let (db, stdlib_path) = py38_stdlib_test_case();
+        let versions = LazyTypeshedVersions::new();
 
         let non_existent = stdlib_path.join(&quot;doesnt_even_exist&quot;);
         assert_eq!(
@@ -988,7 +997,7 @@
         ));
     }
 
-    fn py39_stdlib_test_case() -&gt; (TestDb, ModuleResolutionPathBuf, LazyTypeshedVersions) {
+    fn py39_stdlib_test_case() -&gt; (TestDb, ModuleResolutionPathBuf) {
         let TestCase {
             db,
             custom_typeshed,
@@ -999,12 +1008,13 @@
             .build();
         let stdlib_module_path =
             ModuleResolutionPathBuf::stdlib_from_typeshed_root(&amp;custom_typeshed).unwrap();
-        (db, stdlib_module_path, LazyTypeshedVersions::new())
+        (db, stdlib_module_path)
     }
 
     #[test]
     fn mocked_typeshed_existing_regular_stdlib_pkgs_py39() {
-        let (db, stdlib_path, versions) = py39_stdlib_test_case();
+        let (db, stdlib_path) = py39_stdlib_test_case();
+        let versions = LazyTypeshedVersions::new();
 
         // Since we've set the target version to Py39,
         // `collections` should now exist as a directory, according to VERSIONS...
@@ -1057,7 +1067,9 @@
 
     #[test]
     fn mocked_typeshed_existing_namespace_stdlib_pkg_py39() {
-        let (db, stdlib_path, versions) = py39_stdlib_test_case();
+        let (db, stdlib_path) = py39_stdlib_test_case();
+
+        let versions = LazyTypeshedVersions::new();
 
         // The `importlib` directory now also exists...
         let importlib_namespace_package = stdlib_path.join(&quot;importlib&quot;);
@@ -1100,7 +1112,8 @@
 
     #[test]
     fn mocked_typeshed_nonexistent_namespace_stdlib_pkg_py39() {
-        let (db, stdlib_path, versions) = py39_stdlib_test_case();
+        let (db, stdlib_path) = py39_stdlib_test_case();
+        let versions = LazyTypeshedVersions::new();
 
         // The `xml` package no longer exists on py39:
         let xml_namespace_package = stdlib_path.join(&quot;xml&quot;);
</code></pre>
<p>You also don't need a new dependency. You can use <code>std::cell::OnceCell</code></p>
<p>But all the methods that take a <code>db</code> as argument feel a bit awkward because of the many arguments. It makes me wonder if we shouldn't create a stateful <code>ModuleResolver</code> struct that handles a single resolution</p>
<pre><code>struct ModuleResolver&lt;'db&gt; {
	db: &amp;'db Db,
	versions: Option&lt;&amp;'db TypeshedVersions&gt;,
	target_version: PyVersion
}

impl ModuleResolver {
	fn resolve_package(&amp;mut self, module_resolution_path, components) -&gt; Result&lt;ResolvedPackage, PackageKind&gt; {
		...
	}

	fn is_directory(&amp;mut self, module_resolution_path: &amp;ModuleResolutionPath) -&gt; bool {
		...
	}

	fn is_regular_package(&amp;mut self, ...)
}
</code></pre>
<p>The methods can all take <code>&amp;self</code> if <code>versions</code> uses a <code>OnceCell</code>, but I also don't mind passing a <code>mut</code>. Anyway, I don't think we have to do this now. I do like @carljm suggestion. Let's revisit this when also making that change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-07-05 20:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-07-05 20:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 20:02</div>
            <div class="timeline-body"><p>After offline discussion with @MichaReiser, our thinking is that this might be an improvement, but it might be better to record it in a TODO comment and land the PR so we don't have a big PR outstanding for so long.</p>
<p>I'm ok with this: this is all pretty much encapsulated in a few Salsa queries with simple API, so it's not like we will be writing a bunch of new code directly depending on these path abstractions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 21:42</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:38 on 2024-07-05 21:42</div>
            <div class="timeline-body"><p>Uhmm well if a file in a custom typeshed directory is something like <code>foo.bar.baz.pyi</code>, something pretty weird is going on. But I think you're right that this probably isn't something we really need to assert here. There are many potential ways in which a user-supplied custom typeshed directory could be weird, and we shouldn't bend over backwards to check for all of them. At some point, we need to trust what the user gives us.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 22:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 22:37</div>
            <div class="timeline-body"><p>Yeah, I agree that what you propose sounds cleaner, but I think what I have now is okay, and I'd like to land this now. If I have time next week, I'm happy to come back to this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-07-05 22:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_module_resolver/src/path.rs</code>:79 on 2024-07-05 22:40</div>
            <div class="timeline-body"><p>I've added a TODO</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @AlexWaygood on 2024-07-05 22:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-07-05 22:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-07-05 22:43</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:05:08 UTC
    </footer>
</body>
</html>
