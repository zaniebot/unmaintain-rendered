<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allow assigning ellipsis literal as parameter default value - astral-sh/ruff #14982</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Allow assigning ellipsis literal as parameter default value</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/14982">#14982</a>
        opened by <a href="https://github.com/Glyphack">@Glyphack</a>
        on 2024-12-15 12:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-12-15 12:01</div>
            <div class="timeline-body"><p>Resolves #14840</p>
<!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<p>Usage of ellipsis literal as default argument is allowed in stub files.</p>
<h2>Test Plan</h2>
<p>Added mdtest for both python files and stub files.</p>
<!-- How was it tested? -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-15 12:08</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-12-15 12:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> reviewed on 2024-12-15 17:05</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/InSyncWithFoo">@InSyncWithFoo</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:11 on 2024-12-15 17:05</div>
            <div class="timeline-body"><p>I think a <code>(x: int = Ellipsis)</code> test case should be added, if only for the record.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-12-15 19:23</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:11 on 2024-12-15 19:23</div>
            <div class="timeline-body"><p>Thanks for the suggestion. I added it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-15 21:11</div>
            <div class="timeline-body"><p>The pre-commit failure will go away if you merge in <code>main</code> or rebase :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-12-15 21:26</div>
            <div class="timeline-body"><p>Wow there's a bug in the new github UI for PRs it was not showing the rebase button I thought it's already up to date.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @Glyphack on 2024-12-15 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @Glyphack on 2024-12-15 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @Glyphack on 2024-12-15 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @Glyphack on 2024-12-15 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @Glyphack on 2024-12-15 21:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-16 19:10</div>
            <div class="timeline-body"><blockquote>
<p>Wow there's a bug in the new github UI for PRs it was not showing the rebase button I thought it's already up to date.</p>
</blockquote>
<p>Oh, that only appears for a repository if the maintainers have checked a certain box in the repository settings on GitHub. We haven't enabled it for Astral repositories because the rate of development is quite rapid, and some folks found it annoying to be constantly told that all their PRs were out of date with the <code>main</code> branch ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:7 on 2024-12-16 19:39</div>
            <div class="timeline-body"><p>This special case for <code>...</code> default values is only allowed in stub files, and the default mdtest path is <code>test.py</code>, which is not a stub file. So every test showing the special case working should have an explicit file path with <code>pyi</code> prefix, and we should also have a test for a <code>.py</code> filename showing that the special case is not applied, and a diagnostic for invalid default-value type is emitted.</p>
<pre><code class="language-suggestion">For default values the ellipsis literal `...` can be used, in a stub file only.

```py path=test.pyi
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:11 on 2024-12-16 19:40</div>
            <div class="timeline-body"><p>importing <code>typing.Dict</code> seems like an extraneous wrinkle for these tests. since there's no special behavior around it here.</p>
<pre><code class="language-suggestion">def f(x: int = ...) -&gt; None: ...
def f2(x: dict = ...) -&gt; None: ...
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:26 on 2024-12-16 19:41</div>
            <div class="timeline-body"><pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:61 on 2024-12-16 19:41</div>
            <div class="timeline-body"><pre><code class="language-suggestion">```py path=test.pyi
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:61 on 2024-12-16 19:41</div>
            <div class="timeline-body"><pre><code class="language-suggestion">```py path=test.pyi
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:14 on 2024-12-16 19:42</div>
            <div class="timeline-body"><p>This seems redundant with the dedicated &quot;Class and Module Level Attributes&quot; test below.</p>
<pre><code class="language-suggestion"></code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1130 on 2024-12-16 19:43</div>
            <div class="timeline-body"><pre><code class="language-suggestion">                } else if self.file.is_stub() &amp;&amp; default
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-16 19:43</div>
            <div class="timeline-body"><p>Thank you!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-12-16 21:25</div>
            <div class="timeline-body"><p>Thanks for the review.
I have a question, pyright behavior here is that in all files the assignment works only if the function body is also ellipsis. The link does not specify if it's stub file but pasting this into a python file locally shows the same warnings.
https://pyright-play.net/?strict=true&amp;code=CYUwZgBGAUAeBcECWA7ALhAvBAdHglBALQB8EAcgPYojwBQEjEATiGgK7MoSx12iQYCZOiy4CxMlRqI8OIA
Mypy does the same. Is this just a limitation of them or the specs are not strictly forbidding this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-16 21:44</div>
            <div class="timeline-body"><blockquote>
<p>This special case is only allowed in function and method arguments. Based on what I understand from <a href="https://typing.readthedocs.io/en/latest/guides/writing_stubs.html#module-level-attributes">typing.readthedocs.io/en/latest/guides/writing_stubs.html#module-level-attributes</a> and <a href="https://typing.readthedocs.io/en/latest/guides/writing_stubs.html#classes">typing.readthedocs.io/en/latest/guides/writing_stubs.html#classes</a>.</p>
<blockquote>
<p>Do not unnecessarily use an assignment for module-level attributes.</p>
</blockquote>
</blockquote>
<p>Ah, I think there's a small misunderstanding here. There are two halves of typing.readthedocs.io:</p>
<ul>
<li>One half of the website (https://typing.readthedocs.io/en/latest/spec/) is a formal typing spec: this is a set of rules that type checkers <em>must</em> follow if they claim to support all features of Python's typing system</li>
<li>The other half of the website (https://typing.readthedocs.io/en/latest/guides/) is a set of guides for users on how they <em>should</em> use annotations in their own runtime code and stub files. These are guides to best practices, but they aren't necessarily things that type checkers need to <em>enforce</em></li>
</ul>
<p>The two pages you link to there are both in the &quot;second half&quot; of the website: those paragraphs describe best practices for people writing stub files, but these aren't necessarily rules that type checkers have to <em>enforce</em> regarding stub files. The typing spec part of typing.readthedocs.io is here: https://typing.readthedocs.io/en/latest/spec/distributing.html#value-expressions. It states that type checkers should allow <code>...</code> as a value in many more places, even if the &quot;guides&quot; part of typing.readthedocs.io states that it wouldn't necessarily be <em>best practice</em> for users to do so. Here's what the spec has to say:</p>
<blockquote>
<p>In locations where value expressions can appear, such as the right-hand side of assignment statements and function parameter defaults, type checkers should support the following expressions:</p>
</blockquote>
<blockquote>
<ul>
<li>The ellipsis literal, <code>...</code>, which can stand in for any value
-Any value that is a <a href="https://typing.readthedocs.io/en/latest/spec/literal.html#literal-legal-parameters">legal parameter for typing.Literal</a></li>
<li>Floating point literals, such as 3.14</li>
<li>Complex literals, such as 1 + 2j</li>
</ul>
</blockquote>
<p>And later:</p>
<blockquote>
<p>Type checkers should support module-level variable annotations, with and without assignments:</p>
<pre><code class="language-py">x: int
x: int = 0
x = 0  # type: int
x = ...  # type: int
</code></pre>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-16 21:45</div>
            <div class="timeline-body"><p>So I think we should allow <code>...</code> as a value for any annotated symbol in stub files, in any context, not just parameter defaults</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-12-16 21:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:1 on 2024-12-16 21:46</div>
            <div class="timeline-body"><p>Could you possibly also add a test snippet demonstrating that <code>...</code> is <em>not</em> allowed as a default value in a non-stub file if it contradicts the annotation?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-16 21:49</div>
            <div class="timeline-body"><p>Thanks for that clarification, Alex! I was surprised that <code>x: int = ...</code> wouldn't be supported in a stub, and I read the links without noticing they weren't part of the spec.</p>
<p>I feel like the wording of the spec:</p>
<blockquote>
<p>In locations where value expressions can appear... type checkers should support the following expressions: ... The ellipsis literal, ..., which can stand in for any value</p>
</blockquote>
<p>Suggests a totally different implementation approach here, which is that in a stub file we should simply infer literal <code>...</code> expressions as type <code>Any</code>, which is assignable to anything. That seems better than trying to handle this at each point where we enforce assignability.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-16 21:52</div>
            <div class="timeline-body"><blockquote>
<p>I have a question, pyright behavior here is that in all files the assignment works only if the function body is also ellipsis ... Mypy does the same</p>
</blockquote>
<p>That's very interesting, good observation! I don't actually know why that is. It may be in order to support ellipsis defaults in overloads and protocol methods. I'm a little surprised that this appears to be handled by allowing it based on the body being <code>...</code>, rather than just allowing it contextually for overloads and protocols.</p>
<p>I'm not convinced we want to follow suit here; it seems incorrect to do this based on a body of <code>...</code>, considering that is a valid body for a regular Python function.</p>
<p>So I would say let's implement this only for stubs for now, and consider the best approach when we add overloads/protocols support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-16 21:53</div>
            <div class="timeline-body"><blockquote>
<p>Suggests a totally different implementation approach here, which is that in a stub file we should simply infer literal <code>...</code> expressions as type <code>Any</code>, which is assignable to anything. That seems better than trying to handle this at each point where we enforce assignability.</p>
</blockquote>
<p>That seems okay to me as long as we don't start inferring unions with <code>Any</code> for things imported from stub files... but I don't <em>think</em> we will, because declared types take precedence over inferred types for things imported from other modules, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-16 21:56</div>
            <div class="timeline-body"><blockquote>
<p>That seems okay to me as long as we don't start inferring unions with <code>Any</code> for things imported from stub files... but I don't <em>think</em> we will, because declared types take precedence over inferred types for things imported from other modules, right?</p>
</blockquote>
<p>Yes, that's right.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-12-16 22:19</div>
            <div class="timeline-body"><p>Thanks let me do try to change this to infer the type of ellipsis literal as Any instead of adding this special case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-16 22:35</div>
            <div class="timeline-body"><blockquote>
<p>Suggests a totally different implementation approach here, which is that in a stub file we should simply infer literal <code>...</code> expressions as type <code>Any</code>, which is assignable to anything. That seems better than trying to handle this at each point where we enforce assignability.</p>
</blockquote>
<p>Ok, after further discussion (thanks @AlexWaygood!) I think this is not a good idea, and might cause undesirable behavior in examples like this:</p>
<pre><code class="language-py">class Foo: ...

X: int = ...
Y: Foo = X
</code></pre>
<p>Where this should be flagged as an error, even in a type stub, but my suggestion (combined with our current handling of inferred dynamic type) would not consider it an error. (It might be worth including this as a test case.)</p>
<p>So I think the better approach is in fact to special-case handling of literal <code>...</code> in three different places: in function parameters, where you're doing it now; in <code>infer_annotated_assignment_definition</code>, and in <code>infer_assignment_definition</code>.</p>
<p>In the first two cases, if we see a literal <code>...</code> as the default-value or RHS, in a stub file, we should just discard that inference and record the declared type as the inferred type. In the third case, there is no declaratiion and we should record <code>Unknown</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-12-19 20:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1936 on 2024-12-19 20:31</div>
            <div class="timeline-body"><p>This was a bit confusing. Using <code>add_declaration</code> here fails because this assignment is a binding so the get here fails:
https://github.com/Glyphack/ruff/blob/9963252dfc51e08a53a1047344bd44cde1493d42/crates/red_knot_python_semantic/src/types/infer.rs#L839</p>
<p>This passes the test but can it possibly break some other behavior?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:5 on 2024-12-20 04:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">The ellipsis literal `...` can be used as a placeholder default value for a function parameter,
 in a stub file only, regardless of the type of the parameter.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:19 on 2024-12-20 04:52</div>
            <div class="timeline-body"><pre><code class="language-suggestion">The ellipsis literal can be assigned to a class or module attribute, regardless of its type, in a
stub file only.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:9 on 2024-12-20 04:54</div>
            <div class="timeline-body"><p>I think it would be good to show here that our type inference for the parameter is not impacted by the ellipsis.</p>
<p>(Also lets avoid <code>dict</code> here since its revealed type will change when we add generics.)</p>
<pre><code class="language-suggestion">def f(x: int = ...) -&gt; None:
    reveal_type(x)  # revealed: int
def f2(x: str = ...) -&gt; None:
    reveal_type(x)  # revealed: str
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:28 on 2024-12-20 04:56</div>
            <div class="timeline-body"><p>Also lets avoid <code>float</code> since its revealed type may change when we add the <code>float</code> special case.</p>
<pre><code class="language-suggestion">y: bytes = ...
reveal_type(y)  # revealed: bytes

class Foo:
    y: int = ...
    
reveal_type(Foo.y)  # revealed: int
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:27 on 2024-12-20 04:57</div>
            <div class="timeline-body"><pre><code class="language-suggestion">In a non-stub file, there's no special treatment of ellipsis literals. An ellipsis literal can only be assigned if
`EllipsisType` is actually assignable to the annotated type.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:41 on 2024-12-20 04:57</div>
            <div class="timeline-body"><pre><code class="language-suggestion">There is no special treatment of the builtin name `Ellipsis`, only of `...` literals.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1857 on 2024-12-20 05:00</div>
            <div class="timeline-body"><p>We should use <code>Type::Unknown</code> rather than <code>Type::Any</code> here. In our model, <code>Type::Any</code> is reserved for explicit uses of <code>typing.Any</code> as an annotation. Any dynamic type arising from lack of an annotation uses <code>Type::Unknown</code>.</p>
<p>Also we should add a test for this case (un-annotated assignment in a stub file, with <code>...</code> as RHS.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1907 on 2024-12-20 05:07</div>
            <div class="timeline-body"><p>It would be unusual, but I think valid according to the spec to do <code>FOO, BAR = ...</code> in a stub file. So I think we also should add a special case for <code>...</code> (only if <code>file.is_stub(db)</code> of course) in <code>infer_unpack_types</code> (where we infer the <code>value_ty</code> from the RHS expression). And a test for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1930 on 2024-12-20 05:09</div>
            <div class="timeline-body"><p>It seems we've forgotten the condition &quot;and the <code>value</code> expression is a literal <code>...</code>&quot; here. If that doesn't fail any test, we should definitely add a test with e.g. <code>x: int = 1</code> in a stub file showing we still infer <code>Literal[1]</code> for <code>x</code>, not <code>Unknown</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1987 on 2024-12-20 05:13</div>
            <div class="timeline-body"><p>I don't see any need to duplicate the <code>add_declaration_with_binding</code> call here.</p>
<p>And the type we fall back to should be the annotated type, not Unknown. We should add a test showing that after <code>x: int = ...</code> in a stub file, we infer <code>int</code>, not <code>Unknown</code>, for <code>x</code>.</p>
<pre><code class="language-suggestion">            let value_ty = if self.file().is_stub(self.db().upcast()) &amp;&amp; value.is_ellipsis_literal_expr() {
                annotation_ty
            } else {
                value_ty
            }
            self.add_declaration_with_binding(
                assignment.into(),
                definition,
                annotation_ty,
                value_ty,
            );
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-12-20 05:14</div>
            <div class="timeline-body"><p>Thank you! A few comments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-20 06:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1856 on 2024-12-20 06:55</div>
            <div class="timeline-body"><p>Nit: It might be worth introducing a <code>is_stub</code> function on <code>InferenceBuilder</code> that does the <code>self.file().is_stub(self.db().upcast())</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by @Glyphack on 2024-12-20 09:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-12-30 13:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1930 on 2024-12-30 13:35</div>
            <div class="timeline-body"><p>Yes it was not failing. Added a new test for it in <code>mdtest/assignment/annotations.md</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2024-12-30 14:09</div>
            <div class="timeline-body"><p>Out of curiosity I checked what pyright and mypy do when they encounter <code>...</code> while unpacking RHS(<a href="https://github.com/astral-sh/ruff/pull/14982#discussion_r1893479538">this comment</a>) in assignment.</p>
<p>With this <code>test.pyi</code>(in .py files this is invalid):</p>
<pre><code class="language-pyi">x, y = ...
</code></pre>
<p>Pyright:</p>
<pre><code>0 errors, 0 warnings, 0 informations
</code></pre>
<p>Mypy:</p>
<pre><code>test.pyi:1: error: &quot;EllipsisType&quot; object is not iterable  [misc]
Found 1 error in 1 file (checked 1 source file)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-12-30 18:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1907 on 2024-12-30 18:35</div>
            <div class="timeline-body"><p>I applied this change inside the unpacker since that was the first place that value type was being inferred. Also there was a match to check the expression being used. I hope this is what you meant as well.</p>
<p>But if I understand correctly we don't want the unpacking to happen in for loops so I'm checking that unpack value is of type <code>UnpackerValue::Assign</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-12-31 14:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1907 on 2024-12-31 14:50</div>
            <div class="timeline-body"><p>I spent some time to see if I can pull out the code for special case to <code>infer_unpack_types</code> itself. But I think we want the whole unpacking behavior to happen.
This could be done if we only want to treat the case where LHS is a tuple and RHS is <code>...</code>. But I feel this behavior would not be consistent. I also checked Pyright.</p>
<p>For the following <code>.pyi</code> file Pyright infers all variables the same.</p>
<pre><code>a, b = ...
reveal_type(a)
reveal_type(b)

[c] = ...
reveal_type(c)
</code></pre>
<p>I can't decide if we should only allow <code>a, b = ...</code> or other forms of unpacking as well so please let me know if you think the other way is better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2024-12-31 14:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/unpack.rs</code>:80 on 2024-12-31 14:55</div>
            <div class="timeline-body"><p>I wanted to keep this consistent with <code>is_iterable</code> so I created this. I think https://docs.rs/is-macro/latest/is_macro/ also works here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @Glyphack on 2024-12-31 14:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:19 on 2025-01-05 17:37</div>
            <div class="timeline-body"><pre><code class="language-suggestion">## Class and module symbols

The ellipsis literal can be assigned to a class or module symbol, regardless of its declared type,
in a stub file only.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:65 on 2025-01-05 17:39</div>
            <div class="timeline-body"><pre><code class="language-suggestion">## Use of `Ellipsis` symbol
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:67 on 2025-01-05 17:39</div>
            <div class="timeline-body"><pre><code class="language-suggestion">There is no special treatment of the builtin name `Ellipsis` in stubs, only of `...` literals.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:34 on 2025-01-05 17:41</div>
            <div class="timeline-body"><pre><code class="language-suggestion">
No diagnostic is emitted if an ellipsis literal is &quot;unpacked&quot; in a stub file as part of an
assignment statement:

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/stubs/ellipsis.md</code>:45 on 2025-01-05 17:42</div>
            <div class="timeline-body"><pre><code class="language-suggestion">
Iterating over an ellipsis literal as part of a `for` loop in a stub is invalid, however, and
results in a diagnostic:

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:439 on 2025-01-05 17:46</div>
            <div class="timeline-body"><p>nit: I'd call this method <code>in_stub</code> rather than <code>is_stub</code>, because (as your doc-comment points out!) it asks the question &quot;Are we <em>in</em> a stub file?&quot;</p>
<p>I'd also make it a method on <code>InferContext</code> rather than the <code>TypeInferenceBuilder</code>, as then we can use it from <code>unpacker.rs</code> as well as from <code>infer.rs</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:57 on 2025-01-05 17:58</div>
            <div class="timeline-body"><p>I think the debug assertion here still applies even if we're doing <code>foo, bar = ...</code> in a stub file. The debug assertion applies to the <em>target</em> expression (a.k.a. the left-hand side of the assignment statement), not the <em>value</em> expression (the right-hand side fo the assignment statement). Even in a stub file where the right-hand side is an ellipsis literal, this is still an important invariant to maintain. If I apply this diff to your branch, none of the red-knot tests fail:</p>
<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/types/unpacker.rs
+++ b/crates/red_knot_python_semantic/src/types/unpacker.rs
@@ -36,6 +36,11 @@ impl&lt;'db&gt; Unpacker&lt;'db&gt; {
     }
 
     pub(crate) fn unpack(&amp;mut self, target: &amp;ast::Expr, value: UnpackValue&lt;'db&gt;) {
+        debug_assert!(
+            matches!(target, ast::Expr::List(_) | ast::Expr::Tuple(_)),
+            &quot;Unpacking target must be a list or tuple&quot;
+        );
+
         let mut value_ty = infer_expression_types(self.db(), value.expression())
             .expression_ty(value.scoped_expression_id(self.db(), self.scope));
 
@@ -49,11 +54,6 @@ impl&lt;'db&gt; Unpacker&lt;'db&gt; {
             .is_ellipsis_literal_expr();
         if value.is_assign() &amp;&amp; is_in_stub_file &amp;&amp; value_is_ellipsis_literal {
             value_ty = Type::Unknown;
-        } else {
-            debug_assert!(
-                matches!(target, ast::Expr::List(_) | ast::Expr::Tuple(_)),
-                &quot;Unpacking target must be a list or tuple&quot;
-            );
         }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-05 17:59</div>
            <div class="timeline-body"><p>Thanks, this looks close! A few comments below</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-05 18:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1907 on 2025-01-05 18:01</div>
            <div class="timeline-body"><p>Blegh, it feels a bit unfortunate that we have to add special casing for unpacking in stub files, because it's really extremely rare to encounter unpacking in stub files. I can say with 100% confidence that there are zero assignment statements in typeshed that use unpacking, because there's a flake8-pyi lint rule prohbiting unpacking in stub files, and we run flake8-pyi in CI at typeshed. Having said that, spec compliance is obviously the most important thing here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2025-01-05 18:37</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:57 on 2025-01-05 18:37</div>
            <div class="timeline-body"><p>Thanks for the explanation. I thought this is checking RHS and moved it to this branch. I'll revert the change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/assignment/annotations.md</code>:126 on 2025-01-05 18:41</div>
            <div class="timeline-body"><pre><code class="language-suggestion">## Annotated assignments in stub files are inferred correctly
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:439 on 2025-01-05 18:44</div>
            <div class="timeline-body"><p>There can also be a wrapper <code>TypeInferenceBuilder::in_stub()</code> method that just does <code>self.context.in_stub()</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-01-05 18:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:43 on 2025-01-05 18:53</div>
            <div class="timeline-body"><p>I don't think any of the changes in the first few lines here (or to the doc-comment) are necessary; let's revert them to keep the diff clean :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:49 on 2025-01-05 18:54</div>
            <div class="timeline-body"><p>This can now use <code>InferContext::in_stub</code> method, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2025-01-05 18:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:439 on 2025-01-05 18:54</div>
            <div class="timeline-body"><p>Good point. Applied both.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:41 on 2025-01-05 18:55</div>
            <div class="timeline-body"><p>This is a minor nit, but I don't think we should remove the word &quot;expression&quot; here; the LHS isn't really a list or tuple (no such object is ever constructed), it's just an expression in that syntactic form</p>
<pre><code class="language-suggestion">            &quot;Unpacking target must be a list or tuple expression&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-05 18:56</div>
            <div class="timeline-body"><p>Looks good to me, modulo a couple small nits</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:56 on 2025-01-05 18:57</div>
            <div class="timeline-body"><p>You're doing a bit more work here than you need to if it's <em>not</em> a stub file, because all these conditions are evaluated whether or not it's a stub file. You can take advantage of boolean short-circuiting if you just use one combined test rather than assigning the intermediate variables:</p>
<pre><code class="language-suggestion">        if value.is_assign()
            &amp;&amp; self.context.in_stub()
            &amp;&amp; value
                .expression()
                .node_ref(self.db())
                .is_ellipsis_literal_expr()
        {
            value_ty = Type::Unknown;
        }

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-05 18:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-01-05 18:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:49 on 2025-01-05 18:58</div>
            <div class="timeline-body"><p>Oops, some simultaneous reviewing going on -- see my suggestion in https://github.com/astral-sh/ruff/pull/14982/files#r1903322714</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Glyphack">@Glyphack</a> on <code>crates/red_knot_python_semantic/src/types/unpacker.rs</code>:56 on 2025-01-05 19:02</div>
            <div class="timeline-body"><p>Oh the other change made this outdated. I apply this manually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Glyphack">@Glyphack</a> reviewed on 2025-01-05 19:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-01-05 19:11</div>
            <div class="timeline-body"><p>Looks great, thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2025-01-05 19:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-01-05 19:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-01-05 19:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Glyphack">@Glyphack</a> on 2025-01-05 19:44</div>
            <div class="timeline-body"><p>Thanks for your time and review.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 20:34:29 UTC
    </footer>
</body>
</html>
