<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] AnnAssign with no RHS is not a Definition - astral-sh/ruff #13247</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] AnnAssign with no RHS is not a Definition</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13247">#13247</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-09-04 19:27
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>My plan for handling declared types is to introduce a <code>Declaration</code> in addition to <code>Definition</code>. A <code>Declaration</code> is an annotation of a name with a type; a <code>Definition</code> is an actual runtime assignment of a value to a name. A few things (an annotated function parameter, an annotated-assignment with an RHS) are both a <code>Definition</code> and a <code>Declaration</code>.</p>
<p>This more cleanly separates type inference (only cares about <code>Definition</code>) from declared types (only impacted by a <code>Declaration</code>), and I think it will work out better than trying to squeeze everything into <code>Definition</code>. One of the tests in this PR (<code>annotation_only_assignment_transparent_to_local_inference</code>) demonstrates one reason why. The statement <code>x: int</code> should have no effect on local inference of the type of <code>x</code>; whatever the locally inferred type of <code>x</code> was before <code>x: int</code> should still be the inferred type after <code>x: int</code>. This is actually quite hard to do if <code>x: int</code> is considered a <code>Definition</code>, because a core assumption of the use-def map is that a <code>Definition</code> replaces the previous value. To achieve this would require some hackery to effectively treat <code>x: int</code> sort of as if it were <code>x: int = x</code>, but it's not really even equivalent to that, so this approach gets quite ugly.</p>
<p>As a first step in this plan, this PR stops treating AnnAssign with no RHS as a <code>Definition</code>, which fixes behavior in a couple added tests.</p>
<p>This actually makes things temporarily worse for the ellipsis-type test, since it is defined in typeshed only using annotated assignments with no RHS. This will be fixed properly by the upcoming addition of declarations, which should also treat a declared type as sufficient to import a name, at least from a stub.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-09-04 19:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-09-04 19:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-09-04 19:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-04 19:41</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:650 on 2024-09-05 05:58</div>
            <div class="timeline-body"><p>Nit: I would probably use a match here and combine it with the <code>if matches!(...)</code> above</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:653 on 2024-09-05 05:59</div>
            <div class="timeline-body"><p>It's a bit unfortunate that we first add the flags and then take them away right after but I don't have a suggestion on how to handle this more elegantly</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3988 on 2024-09-05 06:08</div>
            <div class="timeline-body"><p>I think this should be an error because the annotation is incorrect. The annotation should be <code>x: int | None</code> because it isn't guaranteed to be initialized in all paths.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-05 06:10</div>
            <div class="timeline-body"><blockquote>
<p>My plan for handling declared types is to introduce a Declaration in addition to Definition. A Declaration is an annotation of a name with a type; a Definition is an actual runtime assignment of a value to a name. A few things (an annotated function parameter, an annotated-assignment with an RHS) are both a Definition and a Declaration.</p>
</blockquote>
<p>I'm a bit concerned about creating two ingredients because of the performance implications. We sofar tried to come up to reduce the ingredients but this approach would increase the number of ingredients. Unfortunately, I don't feel like i have a good enough understanding of what you're trying to do or what motivates to have two ingredients to make a concrete suggestion.</p>
<p>Following the outlined logic, a fully annotated class or function should then also create a <code>Definition</code> and a <code>Declaration</code> because they are both. Arguably, even a partially annotated function is both (and so are its parameters).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-05 07:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3988 on 2024-09-05 07:08</div>
            <div class="timeline-body"><p><code>int | None</code> would be much less accurate here. <code>int | None</code> means &quot;the value could be an instance of <code>int</code>, or it could be the <code>None</code> singleton&quot;. But in no path is <code>x</code> assigned to the <code>None</code> singleton here, so it's impossible for the value of <code>x</code> to ever be <code>None</code>.</p>
<p>There's no way in Python to express with type annotations the idea that &quot;this variable may be undefined&quot;. We use <code>Type::Unbound</code> internally to track whether a variable has been defined in all branches or not, but that's not a specified type in Python's typing system that users are able to utilise in their annotations</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-05 07:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3988 on 2024-09-05 07:10</div>
            <div class="timeline-body"><p>Hmm, that's a rather interesting choice in python's type system.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-05 07:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3988 on 2024-09-05 07:15</div>
            <div class="timeline-body"><p>There have been proposals to improve this, but they've met with a somewhat cool reception. Some people have argued that allowing users to annotate variables as being only possibly defined would encourage users to write more unsafe code. https://mail.python.org/archives/list/typing-sig@python.org/thread/K3ME5IZIV3Q4PTH4PK7YHYJFGBZOLOJK/#K3ME5IZIV3Q4PTH4PK7YHYJFGBZOLOJK</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-05 10:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2913 on 2024-09-05 10:33</div>
            <div class="timeline-body"><p>Arguably this is actually an improvement, since at least I understand how we arrive at this conclusion now ðŸ˜† <code>Literal[EllipsisType]</code> is pretty baffling; I don't understand why we think <code>Ellipsis</code> is equal to the <code>EllipsisType</code> class object</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-05 10:38</div>
            <div class="timeline-body"><p>I think this is correct in terms of the semantics when it comes to runtime files, but I'd like to hear more about how you plan to handle the semantics of stub files. It seems like there are two possible ways of handling stubs:</p>
<ol>
<li>Say that annotations <em>do</em> actually create definitions in stub files as well as declarations</li>
<li>Say that annotations never create definitions, only declarations, but that a declaration has a different meaning in the context of a stub file</li>
</ol>
<p>It sounds like you've chosen option (2) here but intuitively to me that feels like the more complicated option</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-05 14:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2913 on 2024-09-05 14:38</div>
            <div class="timeline-body"><p>It's because of the wrong code in <code>infer_annotated_assignment</code> that I removed in this PR, where we inferred the annotation as a value expression and assign that type to the name.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-09-05 14:41</div>
            <div class="timeline-body"><p>There's no reason to block this PR. I think the code here looks good but I'm interested to learn more about how you plan to introduce a new <code>Declaration</code> ingredient.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-05 14:53</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4010 on 2024-09-05 14:53</div>
            <div class="timeline-body"><p>I guess a question I have here is: so what's the point of this annotation, if our more precise inference takes priority over the declared type? Should we emit a diagnostic warning the user that the declaration will have no effect?</p>
<p>Hmm, and what about something like this? Our precise inference will probably cause the type to be inferred as <code>list[Literal[1, 2, 3]]</code>, but that's clearly not what the user wants. And if we infer the precise type, we'll emit a spurious error on the <code>takes_list_of_ints(x)</code> call due to list invariance:</p>
<pre><code class="language-py">x: list[int] = [1, 2, 3]

def takes_list_of_ints(arg: list[int]) -&gt; None:
    pass

takes_list_of_ints(x)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-05 14:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:2913 on 2024-09-05 14:54</div>
            <div class="timeline-body"><p>Ah I see... thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-05 14:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/semantic_index/builder.rs</code>:653 on 2024-09-05 14:58</div>
            <div class="timeline-body"><p>I think I found a way to address both this and your above comment together; let me know what you think!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-05 15:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:3988 on 2024-09-05 15:00</div>
            <div class="timeline-body"><p>I think I tend to agree with Eric on this one; explicit annotations for undefined would just lead to a bunch more ugly code using <code>hasattr</code>, since that's how you'd have to narrow away the maybe-undefinedness. It's better to just have a diagnostic on use of a maybe-undefined name, and on failure to consistently initialize instance attributes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-05 15:05</div>
            <div class="timeline-body"><p>It looks like we need more of a design document on declared types implementation; let's move the broader discussion on my PR description there instead, since it's only tangentially related to this PR. This PR makes sense as an initial step regardless, because the added tests are needed and fix current bugs, and the implementation changes will be easy enough to adjust to whatever we do for declared types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-09-05 15:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-05 15:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:4010 on 2024-09-05 15:54</div>
            <div class="timeline-body"><p>This is something I can try to clarify more in the design doc, but I'll try to answer here briefly.</p>
<p>The <code>x: int</code> annotation in this particular code sample has no effect, because there is no assignment to <code>x</code> anywhere following it. But in general, the effect that it would have would be that any assignment to <code>x</code> after <code>x: int</code> must assign something that is assignable to <code>int</code>, or else there will be an invalid-assignment diagnostic. Without the <code>x: int</code>, any subsequent assignment to <code>x</code> would be allowed and we'd just happily allow the shadowing to a new inferred type (or infer the union if it's conditional.)</p>
<p>Regarding generics, let me get into that more in the design document.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-09-05 15:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-09-05 15:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-05 15:55</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:06:22 UTC
    </footer>
</body>
</html>
