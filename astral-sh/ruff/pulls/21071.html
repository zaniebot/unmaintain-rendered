<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Infer arguments of generic calls with declared type context - astral-sh/ruff #21071</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Infer arguments of generic calls with declared type context</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/21071">#21071</a>
        opened by <a href="https://github.com/ibraheemdev">@ibraheemdev</a>
        on 2025-10-25 04:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-10-25 04:52</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Resolves https://github.com/astral-sh/ty/issues/1356.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @ibraheemdev on 2025-10-25 04:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @ibraheemdev on 2025-10-25 04:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @sharkdp by @ibraheemdev on 2025-10-25 04:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @ibraheemdev on 2025-10-25 04:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @ibraheemdev on 2025-10-25 04:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-25 04:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/resources/mdtest/assignment/annotations.md</code>:513 on 2025-10-25 04:54</div>
            <div class="timeline-body"><p>This is really tricky. We infer the list argument to be <code>list[TD | None]</code> due to the annotated type of <code>T</code> being <code>TD | None</code>. I'm not sure there's a clear heuristic to filter away the <code>None</code> here (and similarly for any other type than <code>None</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-25 04:54</div>
            <div class="timeline-body"><!-- generated-comment typing_conformance_diagnostics_diff -->

<h2>Diagnostic diff on <a href="https://github.com/python/typing/tree/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance">typing conformance tests</a></h2>
<p>No changes detected when running ty on typing conformance tests ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-10-25 04:58</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<details>
<summary>Changes were detected when running on open source projects</summary>

<pre><code class="language-diff">colour (https://github.com/colour-science/colour)
- colour/recovery/otsu2018.py:1597:21: error[invalid-assignment] Method `__setitem__` of type `Unknown | (Overload[(key: SupportsIndex, value: Unknown, /) -&gt; None, (key: slice[Any, Any, Any], value: Iterable[Unknown], /) -&gt; None]) | (bound method dict[Unknown, Unknown].__setitem__(key: Unknown, value: Unknown, /) -&gt; None)` cannot be called with a key of type `Node_Otsu2018` and a value of type `Unknown | list[Unknown] | dict[Unknown, Unknown] | int` on object of type `Unknown | list[Unknown] | dict[Unknown, Unknown] | int`
- colour/recovery/otsu2018.py:1598:21: error[unsupported-operator] Operator `+=` is unsupported between objects of type `list[Unknown]` and `Literal[1]`
- colour/recovery/otsu2018.py:1598:21: error[unsupported-operator] Operator `+=` is unsupported between objects of type `dict[Unknown, Unknown]` and `Literal[1]`
- colour/recovery/otsu2018.py:1601:17: error[invalid-assignment] Method `__setitem__` of type `Unknown | (Overload[(key: SupportsIndex, value: Unknown, /) -&gt; None, (key: slice[Any, Any, Any], value: Iterable[Unknown], /) -&gt; None]) | (bound method dict[Unknown, Unknown].__setitem__(key: Unknown, value: Unknown, /) -&gt; None)` cannot be called with a key of type `Node_Otsu2018` and a value of type `int` on object of type `Unknown | list[Unknown] | dict[Unknown, Unknown] | int`
- colour/recovery/otsu2018.py:1601:54: error[invalid-argument-type] Argument to function `len` is incorrect: Expected `Sized`, found `Unknown | list[Unknown] | dict[Unknown, Unknown] | int`
- colour/recovery/otsu2018.py:1602:17: warning[possibly-missing-attribute] Attribute `append` may be missing on object of type `Unknown | list[Unknown] | dict[Unknown, Unknown] | int`
- Found 523 diagnostics
+ Found 517 diagnostics

core (https://github.com/home-assistant/core)
+ homeassistant/components/homekit/config_flow.py:503:20: warning[possibly-missing-attribute] Attribute `get` may be missing on object of type `Any | None`
+ homeassistant/components/homekit/config_flow.py:547:20: warning[possibly-missing-attribute] Attribute `get` may be missing on object of type `Any | None`
+ homeassistant/components/homekit/config_flow.py:651:20: warning[possibly-missing-attribute] Attribute `get` may be missing on object of type `Unknown | None`
+ homeassistant/components/homekit/config_flow.py:654:19: warning[possibly-missing-attribute] Attribute `get` may be missing on object of type `Unknown | None`
+ homeassistant/components/homekit/config_flow.py:655:32: warning[possibly-missing-attribute] Attribute `get` may be missing on object of type `Unknown | None`
- Found 14119 diagnostics
+ Found 14124 diagnostics

</code></pre>
</details>
No memory usage changes detected ✅

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dcreager">@dcreager</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5626 on 2025-10-29 19:03</div>
            <div class="timeline-body"><p>If I'm following the control flow correctly, this has to happen here because we haven't yet inferred a specialization in the <code>Bindings</code>, since that doesn't happen until you call <code>check_types</code>. And we need this specialization applied to the parameter type in order to have a type context to use when infering the argument types. Does that sound right?</p>
<p>My worry here is that this specialization that you're building isn't guaranteed to line up with the one that <code>check_types</code> will infer — or at least, it won't once we have the better constraint solver, where the inferred specialization can be influenced by constraints coming from e.g. other arguments.</p>
<p>Ideally we'd find a way to be able to reuse the specialization that <code>Bindings</code> is already building up for us. Should we consider moving the specialization inference step so that it happens at the end of <code>match_parameters</code>, instead of at the beginning of <code>check_types</code>? Or as an explicit third step in between the two?</p>
<p>That might be something we can queue up as follow-on work, in order to land this. But I'd like to at least think through what would be involved, since I think might add more blockers to getting the new constraint solver landed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a> reviewed on 2025-10-29 19:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ibraheemdev">@ibraheemdev</a> reviewed on 2025-10-29 20:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on <code>crates/ty_python_semantic/src/types/infer/builder.rs</code>:5626 on 2025-10-29 20:30</div>
            <div class="timeline-body"><blockquote>
<p>If I'm following the control flow correctly, this has to happen here because we haven't yet inferred a specialization in the Bindings, since that doesn't happen until you call check_types. And we need this specialization applied to the parameter type in order to have a type context to use when infering the argument types. Does that sound right?</p>
</blockquote>
<p>Yeah that's correct.</p>
<blockquote>
<p>Ideally we'd find a way to be able to reuse the specialization that Bindings is already building up for us. Should we consider moving the specialization inference step so that it happens at the end of match_parameters, instead of at the beginning of check_types? Or as an explicit third step in between the two?</p>
</blockquote>
<p>I'm not exactly sure how that would work. Constructing the complete binding specialization is only possible once we have the types of all arguments, which we want to infer using the type context — so there's a bit of a circular dependency here.</p>
<p>Consider:</p>
<pre><code class="language-py">def f[T](x: list[T], y: T) -&gt; list[T]:
    return x

def lst[T](x: T) -&gt; list[T]:
    return [x]

def _(x: int, y: int | str):
    z: list[int | str] = f(lst(x), y) # error: expected list[int | str], found list[int]
</code></pre>
<p>In order to infer a specialization for <code>f</code>, we must first infer each of its arguments. The call to <code>lst(x)</code> has no way of specializing to <code>int | str</code> except by using the type-context <code>list[int | str]</code> to infer a <em>more</em> assignable type, such that it passes <code>check_types</code> once the complete specialization is inferred. Note that without the type-context, pyright also fails to type-check, which suggests it's using the type context in a similar way to this PR.</p>
<p>The question then is, can using the extra type-context lead to a <em>less</em> assignable type (as I think you are suggesting)? I'm not sure, as the specialized return type must be assignable to annotated type of the call expression. The only issue I see is the question of how to narrow the type context such that we don't overly widen the inferred type of the call, e.g.</p>
<pre><code class="language-py">def f[T](x: list[T]) -&gt; T:
    return x[0]

def lst[T](x: T) -&gt; list[T]:
    return [x]

def _(x: int, y: int | str):
    z: int | str = f(lst(x))
    reveal_type(z) # should be int, not int | str
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-11-03 00:32</div>
            <div class="timeline-body"><p>Superceded by https://github.com/astral-sh/ruff/pull/21210.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ibraheemdev on 2025-11-03 00:32</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 16:54:19 UTC
    </footer>
</body>
</html>
