<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] more efficient UnionBuilder::add - astral-sh/ruff #13411</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] more efficient UnionBuilder::add</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13411">#13411</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2024-09-19 19:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/carljm">@carljm</a> on 2024-09-19 19:43</div>
            <div class="timeline-body"><p>Avoid quadratic time in subsumed elements when adding a super-type of existing union elements.</p>
<p>Reserve space in advance when adding multiple elements (from another union) to a union.</p>
<p>Make union elements a <code>Box&lt;[Type]&gt;</code> instead of an <code>FxOrderSet</code>; the set doesn't buy much since the rules of union uniqueness are defined in terms of supertype/subtype, not in terms of simple type identity.</p>
<p>Move sealed-boolean handling out of a separate <code>UnionBuilder::simplify</code> method and into <code>UnionBuilder::add</code>; now that <code>add</code> is iterating existing elements anyway, this is more efficient.</p>
<p>Remove <code>UnionType::contains</code>, since it's now <code>O(n)</code> and we shouldn't really need it, generally we care about subtype/supertype, not type identity. (Right now it's used for <code>Type::Unbound</code>, which shouldn't even be a type.)</p>
<p>Add support for <code>is_subtype_of</code> for the <code>object</code> type.</p>
<p>Addresses comments on https://github.com/astral-sh/ruff/pull/13401</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @carljm on 2024-09-19 19:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @carljm on 2024-09-19 19:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @carljm on 2024-09-19 19:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-19 20:07</div>
            <div class="timeline-body"><p>Could we use <code>Box&lt;[Type&lt;'db&gt;]&gt;</code> for <code>UnionType::elements</code>, since the elements of a constructed <code>UnionType</code> should be immutable?</p>
<p>Should we even have a <code>pub fn contains</code> method on <code>UnionType</code> anymore, since it's now O(n) and (per https://github.com/astral-sh/ruff/pull/13401#issuecomment-2361238572) we don't expect to need it very often/it's probably better to special-case specific types like <code>Any</code> and <code>Unknown</code> when it comes to testing containment?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-19 20:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-19 20:13</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>âœ… ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 20:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-19 20:13</div>
            <div class="timeline-body"><p>Good call! Once again, I intended to switch to <code>Box&lt;[Type]&gt;</code> and then totally forgot about it once I had everything else working. Need a better short-term TODO stack, my brain is not up to the task ðŸ˜†</p>
<p>I'll check where we use <code>contains</code>...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-19 20:15</div>
            <div class="timeline-body"><p>Our only uses of <code>contains</code> are for checking if it contains Unbound, and I don't even want Unbound to be a type at all. I'll remove the method and make those two call sites do it manually instead, for now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 20:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-19 20:33</div>
            <div class="timeline-body"><p>Ok so actually removing it is kind of difficult because the <code>elements</code> field is not pub and one of the uses is in a lint rule over in a different crate. So I just deprecated it with a TODO note that it should go away when we remove <code>Type::Unbound</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 20:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-19 20:46</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-19 20:46</div>
            <div class="timeline-body"><p>Actually never mind I can change that code to use <code>is_unbound</code> and <code>may_be_unbound</code>, and get rid of the method.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:95 on 2024-09-19 23:58</div>
            <div class="timeline-body"><p>You can simplify this a little bit -- get rid of the <code>.map()</code> call at the end:</p>
<pre><code class="language-suggestion">                        let mut elements_iter = self.elements.iter();
                        'outer: for remove_index in remove_iter.by_ref() {
                            for (index, element) in elements_iter.by_ref().enumerate() {
                                if index == *remove_index {
                                    continue 'outer;
                                }
                                retain.push(*element);
                            }
                        }
                        retain.extend(elements_iter);
</code></pre>
<p>It is also quite tempting to use <code>swap_remove</code> as @MichaReiser suggested in https://github.com/astral-sh/ruff/pull/13401#discussion_r1766580699, since <code>swap_remove</code> is O(1)...</p>
<details>
<summary>Diff using `swap_remove`</summary>

<pre><code class="language-diff">diff --git a/crates/red_knot_python_semantic/src/types/builder.rs b/crates/red_knot_python_semantic/src/types/builder.rs
index b35c76df6..c218c36d3 100644
--- a/crates/red_knot_python_semantic/src/types/builder.rs
+++ b/crates/red_knot_python_semantic/src/types/builder.rs
@@ -76,27 +76,10 @@ impl&lt;'db&gt; UnionBuilder&lt;'db&gt; {
                         to_remove.push(index);
                     }
                 }
-                match to_remove[..] {
-                    [] =&gt; self.elements.push(to_add),
-                    [index] =&gt; self.elements[index] = to_add,
-                    _ =&gt; {
-                        let mut retain =
-                            Vec::with_capacity(self.elements.len() - to_remove.len() + 1);
-                        let mut remove_iter = to_remove.iter();
-                        let mut elements_iter = self.elements.iter().enumerate();
-                        'outer: for remove_index in remove_iter.by_ref() {
-                            for (index, element) in elements_iter.by_ref() {
-                                if index == *remove_index {
-                                    continue 'outer;
-                                }
-                                retain.push(*element);
-                            }
-                        }
-                        retain.extend(elements_iter.map(|(_, element)| element));
-                        retain.push(to_add);
-                        self.elements = retain;
-                    }
+                for index in to_remove {
+                    self.elements.swap_remove(index);
                 }
+                self.elements.push(to_add);
             }
         }
</code></pre>
</details>

<p>But I think the price is perhaps too much to pay, because of course we'll use <code>UnionBuilder::add()</code> to construct (and eagerly simplify) even unions that users have provided to us in type annotations. And it just seems too confusing to display union elements to users in a completely different order to the order in which they gave us the elements.</p>
<p><em>Unless</em> we retained the <code>TextRange</code> of the original annotation, and used that to get back to the original source code for the annotation they used when constructing the diagnostic... but that could add complications, because we'd have to distinguish between user-supplied unions (which would have <code>TextRange</code>s attached to them) and red-knot-constructed unions (which would not). And storing an <code>Option&lt;TextRange&gt;</code> field on <code>UnionType</code> instances obviously wouldn't be free either.</p>
<p>It's quite a fun problem figuring out how to micro-optimise this while retaining order as best as possible! Here's another solution that uses <code>Vec::retain()</code>, which means that it operates in-place instead of allocating a new <code>Vec</code> and replacing <code>self.elements</code> with the new <code>Vec</code> (it takes its inspiration from <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.retain">the second example in the docs</a>):</p>
<details>
<summary>Alternative solution using `Vec::retain()`</summary>

<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/types/builder.rs
+++ b/crates/red_knot_python_semantic/src/types/builder.rs
@@ -25,6 +25,8 @@
 //!   * No type in an intersection can be a supertype of any other type in the intersection (just
 //!     eliminate the supertype from the intersection).
 //!   * An intersection containing two non-overlapping types should simplify to [`Type::Never`].
+use rustc_hash::FxHashSet;
+
 use crate::types::{builtins_symbol_ty, IntersectionType, Type, UnionType};
 use crate::{Db, FxOrderSet};
 
@@ -59,11 +61,11 @@ impl&lt;'db&gt; UnionBuilder&lt;'db&gt; {
                     None
                 };
                 let mut to_add = ty;
-                let mut to_remove = vec![];
+                let mut removals = UnionRemovals::default();
                 for (index, element) in self.elements.iter().enumerate() {
                     if Some(*element) == bool_pair {
                         to_add = builtins_symbol_ty(self.db, &quot;bool&quot;);
-                        to_remove.push(index);
+                        removals.push_index(index);
                         // The type we are adding is a BooleanLiteral, which doesn't have any
                         // subtypes. And we just found that the union already contained our
                         // mirror-image BooleanLiteral, so it can't also contain bool or any
@@ -73,30 +75,11 @@ impl&lt;'db&gt; UnionBuilder&lt;'db&gt; {
                     if ty.is_subtype_of(self.db, *element) {
                         return self;
                     } else if element.is_subtype_of(self.db, ty) {
-                        to_remove.push(index);
-                    }
-                }
-                match to_remove[..] {
-                    [] =&gt; self.elements.push(to_add),
-                    [index] =&gt; self.elements[index] = to_add,
-                    _ =&gt; {
-                        let mut retain =
-                            Vec::with_capacity(self.elements.len() - to_remove.len() + 1);
-                        let mut remove_iter = to_remove.iter();
-                        let mut elements_iter = self.elements.iter().enumerate();
-                        'outer: for remove_index in remove_iter.by_ref() {
-                            for (index, element) in elements_iter.by_ref() {
-                                if index == *remove_index {
-                                    continue 'outer;
-                                }
-                                retain.push(*element);
-                            }
-                        }
-                        retain.extend(elements_iter.map(|(_, element)| element));
-                        retain.push(to_add);
-                        self.elements = retain;
+                        removals.push_index(index);
                     }
                 }
+                removals.apply(&amp;mut self);
+                self.elements.push(to_add);
             }
         }
 
@@ -112,6 +95,59 @@ impl&lt;'db&gt; UnionBuilder&lt;'db&gt; {
     }
 }
 
+#[derive(Debug, Default)]
+enum UnionRemovals {
+    #[default]
+    None,
+    Single {
+        removal_index: usize,
+    },
+    Multiple {
+        removal_indices: FxHashSet&lt;usize&gt;,
+    },
+}
+
+impl UnionRemovals {
+    fn push_index(&amp;mut self, index: usize) {
+        match self {
+            Self::None =&gt; {
+                *self = Self::Single {
+                    removal_index: index,
+                }
+            }
+            Self::Single {
+                removal_index: element_index,
+            } =&gt; {
+                *self = Self::Multiple {
+                    removal_indices: FxHashSet::from_iter([*element_index, index]),
+                }
+            }
+            Self::Multiple {
+                removal_indices: element_indices,
+            } =&gt; {
+                element_indices.insert(index);
+            }
+        }
+    }
+
+    fn apply(self, union_builder: &amp;mut UnionBuilder) {
+        match self {
+            Self::None =&gt; {}
+            Self::Single { removal_index } =&gt; {
+                union_builder.elements.remove(removal_index);
+            }
+            Self::Multiple { removal_indices } =&gt; {
+                let existing_elements = &amp;mut union_builder.elements;
+                let mut should_retain = (0..existing_elements.len())
+                    .map(|element_index| !removal_indices.contains(&amp;element_index));
+                union_builder
+                    .elements
+                    .retain(|_| should_retain.next().unwrap());
+            }
+        }
+    }
+}
+
 #[derive(Clone)]
 pub(crate) struct IntersectionBuilder&lt;'db&gt; {
     // Really this builds a union-of-intersections, because we always keep our set-theoretic types
@@ -397,7 +433,7 @@ mod tests {
         assert_eq!(u0, t0);
         assert_eq!(u1, t0);
         assert_eq!(u2.expect_union().elements(&amp;db).as_ref(), &amp;[t0, t2]);
-        assert_eq!(u3.expect_union().elements(&amp;db).as_ref(), &amp;[t0, t2]);
+        assert_eq!(u3.expect_union().elements(&amp;db).as_ref(), &amp;[t2, t0]);
     }
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:331 on 2024-09-20 00:21</div>
            <div class="timeline-body"><p>you could also do this with</p>
<pre><code class="language-suggestion">        assert_eq!(**union.elements(&amp;db), [t0, t1]);
</code></pre>
<p>(etc. for all the other <code>.as_ref()</code>s you added for the <code>assert_eq!</code> calls in this file)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-09-20 00:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-20 06:31</div>
            <div class="timeline-body"><p>It would be nice if we could use <code>SmallVec</code> here.... except that we can't because of its lifetime variance bug :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1003 on 2024-09-20 06:32</div>
            <div class="timeline-body"><p>What's the motivation for removing this method? it doesn't seem necessary for the change in this PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:80 on 2024-09-20 06:43</div>
            <div class="timeline-body"><p>Nit: Some blank lines to group the relevant logic could help readability. It makes it clear to readers that a &quot;new step&quot; begins. Add blank lines before:</p>
<ul>
<li><code>let mut to_add</code></li>
<li><code>match to_remove</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:62 on 2024-09-20 06:54</div>
            <div class="timeline-body"><p>I haven't tested this but I think the simplest implementation is:</p>
<pre><code class="language-rust">                for (index, element) in self.elements.iter().enumerate() {
                    if Some(*ty) == bool_pair {
                        self.elements.push(builtins_symbol_ty(self.db, &quot;bool&quot;));
                        self.elements.swap_remove(index);

                        // The type we are adding is a BooleanLiteral, which doesn't have any
                        // subtypes. And we just found that the union already contained our
                        // mirror-image BooleanLiteral, so it can't also contain bool or any
                        // supertype of bool. Therefore, we are done.
                        return self;;
                    }

                    if ty.is_subtype_of(self.db, *element) {
                        return self;
                    }
                }

                self.elements.retain(|ty| {
                    !ty.is_subtype_of(self.db, *ty)
                });

                self.elements.push(ty);
</code></pre>
<p>It has the shortcoming that it doesn't place <code>to_add</code> into the position of a removed element and that we iterate the elements twice even if there are no elements to remove. But it avoids copying the elements into a new vector, which is roughly the same as doing a <code>vec.clone()</code></p>
<p>We can preserve the ordering by using <code>retain_mut</code>. I think this is my preferred solution.</p>
<pre><code class="language-rust">                let bool_pair = if let Type::BooleanLiteral(b) = ty {
                    Some(Type::BooleanLiteral(!b))
                } else {
                    None
                };

                for (index, element) in self.elements.iter().copied().enumerate() {
                    if Some(element) == bool_pair {
                        self.elements.push(builtins_symbol_ty(self.db, &quot;bool&quot;));
                        self.elements.swap_remove(index);

                        // The type we are adding is a BooleanLiteral, which doesn't have any
                        // subtypes. And we just found that the union already contained our
                        // mirror-image BooleanLiteral, so it can't also contain bool or any
                        // supertype of bool. Therefore, we are done.
                        return self;
                    }

                    if ty.is_subtype_of(self.db, element) {
                        return self;
                    }
                }

                let mut ty_add = Some(ty);
                self.elements.retain_mut(|element| {
                    if element.is_subtype_of(self.db, ty) {
                        if let Some(to_add) = ty_add.take() {
                            *element = to_add;
                            true
                        } else {
                            false
                        }
                    } else {
                        true
                    }
                });

                if let Some(ty_add) = ty_add {
                    self.elements.push(ty_add);
                }
</code></pre>
<p>A third version avoiding copying the vec uses retain and is similar to what Alex proposes.</p>
<pre><code class="language-rust">                let mut to_add = ty;
                let mut to_remove = vec![];

                for (index, element) in self.elements.iter().enumerate() {
                    if Some(*element) == bool_pair {
                        to_add = builtins_symbol_ty(self.db, &quot;bool&quot;);
                        to_remove.push(index);
                        // The type we are adding is a BooleanLiteral, which doesn't have any
                        // subtypes. And we just found that the union already contained our
                        // mirror-image BooleanLiteral, so it can't also contain bool or any
                        // supertype of bool. Therefore, we are done.
                        break;
                    }
                    if ty.is_subtype_of(self.db, *element) {
                        return self;
                    } else if element.is_subtype_of(self.db, ty) {
                        to_remove.push(index);
                    }
                }

                self.elements.push(to_add);
                let mut to_remove = to_remove.into_iter();
                if let Some(first_index) = to_remove.next() {
                    // Swaps `first_index` with `to_add`: O(1)
                    self.elements.swap_remove(first_index);
                }

                let mut current_index = 0;
                let mut next_to_remove_index = to_remove.next();

                if next_to_remove_index.is_some() {
                    self.elements.retain(|_ty| {
                        let retain = if Some(current_index) == next_to_remove_index {
                            next_to_remove_index = to_remove.next();
                            false
                        } else {
                            true
                        };
                        current_index += 1;
                        retain
                    })
                }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-20 07:09</div>
            <div class="timeline-body"><p>I saw that it's now necessary to do some awkward dereferencing because the salsa accessor returns <code>&amp;Box&lt;[Type&lt;'db&gt;]</code>. What I liked to do in the past is to implement my manual accessor:</p>
<pre><code class="language-rust">    #[return_ref]
	  elements_slice: Box&lt;[Type&lt;'db&gt;]&gt;

    ...


impl &lt;'db&gt; UnionType&lt;'db&gt; [
	fn elements(&amp;self, db: &amp;'db dyn Db) -&gt; &amp;'db [Type&lt;'db&gt;] {
		&amp;*self.elements_slice(db)
	}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-09-20 07:10</div>
            <div class="timeline-body"><p>Thanks for following up on this. I think there's room to simplify the implementation, although it comes with trade-offs. It's up to you which version you prefer (yours, Alex, or one proposed by myself)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-20 15:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-20 15:11</div>
            <div class="timeline-body"><blockquote>
<p>It would be nice if we could use <code>SmallVec</code> here.... except that we can't because of its lifetime variance bug</p>
</blockquote>
<p>I feel like <code>SmallVec</code> isn't that complicated, and maybe we should just implement our own version of it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-20 15:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1003 on 2024-09-20 15:13</div>
            <div class="timeline-body"><p>It's not <em>necessary</em> for the change in this PR, but it's related, because we switch from a set to a boxed array, which means <code>contains</code> is now <code>O(n)</code> instead of <code>O(1)</code>, which means we should avoid using it. And we shouldn't need it, either, because generally we should be looking at subtype/assignability, not type identity.</p>
<p>The only uses of this method are related to <code>Type::Unbound</code>, and I want to remove that from the type system entirely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-20 15:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-20 15:18</div>
            <div class="timeline-body"><p>An as efficient version as small vec is a bit involved. But let's do this as a separate PR</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-20 15:19</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1003 on 2024-09-20 15:19</div>
            <div class="timeline-body"><p>Fair. You could also mark it as deprecated and allow its usage. But it's not really important</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-20 15:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:95 on 2024-09-20 15:34</div>
            <div class="timeline-body"><p>Thanks for all the good suggestions! Still evaluating both yours and Micha's, but one note here: the initial simplification you suggest in the suggested change here doesn't work, because it causes the enumeration to start over at 0 each time we re-enter the inner loop. But this was also useful, because it made me realize the tests were inadequate; I've now added a test for subsuming multiple items at once, which fails with that change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-20 15:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/builder.rs</code>:331 on 2024-09-20 15:38</div>
            <div class="timeline-body"><p>I think I'll go with Micha's suggestion of a slice-returning accessor to eliminate the need for either of these.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-09-20 15:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:997 on 2024-09-20 15:49</div>
            <div class="timeline-body"><p>Implemented the accessor to simplify usage of union elements; thanks for the suggestion!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-20 17:22</div>
            <div class="timeline-body"><p>Thanks both for all the great suggestions!</p>
<p>I did some benchmarking to validate my performance assumptions. &quot;Removing nothing&quot; is by far the most common case, and &quot;removing one thing&quot; is the majority of the remaining cases, leaving &quot;removing multiple&quot; as a rare edge case. And I did find that de-optimizing the common cases, even in a small way (for example, double iterating the elements) caused a noticeable regression in the benchmark locally. So I want to keep the characteristic of my initial version that it prioritizes doing as little as possible in the remove-none and remove-one cases. In that same vein, I also observed that using a <code>SmallVec</code> for <code>to_remove</code> is a significant win, since it avoids allocating a heap vector in the remove-one case (an empty vec doesn't allocate, so remove-none was already ok), so I made that change.</p>
<p>All that said, I think it's definitely better to use <code>.retain</code> and avoid allocating a new vector in the remove-multiple case.</p>
<p>So the solution I ended up with is very similar in what it actually does to both of your solutions using <code>.retain</code>, and the remaining questions are about code structure and readability. I don't find it an improvement in readability to extract a new struct or use an explicit enum for zero/one/multiple cases; it's just a lot more code for the reader to absorb. And I prefer to structure it so that in the remove-one case we don't have to first push and then later <code>swap_remove</code>, we can just directly replace the element, so I kept the match over <code>to_remove</code> cardinality rather than fully using Micha's version.</p>
<p>Hopefully that all makes sense!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-09-20 17:27</div>
            <div class="timeline-body"><p>Oh, and I also added <code>is_subtype_of</code> support for <code>object</code>, because I thought I needed it in order to write a test for the remove-multiple case. I didn't actually (I could have just use two different literal types being subsumed by their common base type), but by the time I realized that I'd already added it, and it's pretty simple.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @carljm on 2024-09-20 17:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2024-09-20 17:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-09-20 17:49</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 21:30:59 UTC
    </footer>
</body>
</html>
