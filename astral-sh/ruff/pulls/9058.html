<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Split string formatting to individual nodes - astral-sh/ruff #9058</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Split string formatting to individual nodes</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/9058">#9058</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2023-12-08 20:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a></div>
            <div class="timeline-body"><p>This PR splits the string formatting code in the formatter to be handled by the respective nodes.</p>
<p>Previously, the string formatting was done through a single <code>FormatString</code> interface. Now, the nodes themselves are responsible for formatting.</p>
<p>The following changes were made:</p>
<ol>
<li>Remove <code>StringLayout::ImplicitStringConcatenationInBinaryLike</code> and inline the call to <code>FormatStringContinuation</code>. After the refactor, the binary like formatting would delegate to <code>FormatString</code> which would then delegate to <code>FormatStringContinuation</code>. This removes the intermediary steps.</li>
<li>Add formatter implementation for <code>FStringPart</code> which delegates it to the respective string literal or f-string node.</li>
<li>Add <code>ExprStringLiteralKind</code> which is either <code>String</code> or <code>Docstring</code>. If it&#x27;s a docstring variant, then the string expression would not be implicitly concatenated. This is guaranteed by the <code>DocstringStmt::try_from_expression</code> constructor.</li>
<li>Add <code>StringLiteralKind</code> which is either a <code>String</code>, <code>Docstring</code> or <code>InImplicitlyConcatenatedFString</code>. The last variant is for when the string literal is  implicitly concatenated with an f-string (<code>&quot;foo&quot; f&quot;bar {x}&quot;</code>).</li>
<li>Remove <code>FormatString</code>.</li>
<li>Extract the f-string quote detection as a standalone function which is public to the crate. This is used to detect the quote to be used for an f-string at the expression level (<code>ExprFString</code> or <code>FormatStringContinuation</code>).</li>
</ol>
Formatter ecosystem result
<p><strong>This PR</strong></p>
<p>| project        | similarity index  | total files       | changed files     |
|----------------|------------------:|------------------:|------------------:|
| cpython        |           0.75804 |              1799 |              1648 |
| django         |           0.99984 |              2772 |                34 |
| home-assistant |           0.99955 |             10596 |               214 |
| poetry         |           0.99905 |               321 |                15 |
| transformers   |           0.99967 |              2657 |               324 |
| twine          |           1.00000 |                33 |                 0 |
| typeshed       |           0.99980 |              3669 |                18 |
| warehouse      |           0.99976 |               654 |                14 |
| zulip          |           0.99958 |              1459 |                36 |</p>
<p><strong>main</strong></p>
<p>| project        | similarity index  | total files       | changed files     |
|----------------|------------------:|------------------:|------------------:|
| cpython        |           0.75804 |              1799 |              1648 |
| django         |           0.99984 |              2772 |                34 |
| home-assistant |           0.99955 |             10596 |               214 |
| poetry         |           0.99905 |               321 |                15 |
| transformers   |           0.99967 |              2657 |               324 |
| twine          |           1.00000 |                33 |                 0 |
| typeshed       |           0.99980 |              3669 |                18 |
| warehouse      |           0.99976 |               654 |                14 |
| zulip          |           0.99958 |              1459 |                36 |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2023-12-08 20:56</div>
            <div class="timeline-body">

<code>ruff-ecosystem</code> results
Formatter (stable)
<p>âœ… ecosystem check detected no format changes.</p>
Formatter (preview)
<p>âœ… ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-12 01:09</div>
            <div class="timeline-body"><p>Current dependencies on/for this PR:</p>
<ul>
<li><code>main</code><ul>
<li><strong>PR #9111</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/9111?utm_source=stack-comment-icon"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a><ul>
<li><strong>PR #9058</strong> <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/9058?utm_source=stack-comment-icon"><img src="https://static.graphite.dev/graphite-32x32-black.png" alt="Graphite"></a>  ðŸ‘ˆ</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>This <a href="https://stacking.dev/?utm_source=stack-comment">stack of pull requests</a> is managed by <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/9058?utm_source=stack-comment">Graphite</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;WIP: Initial attempt to split string formatting&quot; to &quot;Split string formatting to individual nodes&quot; by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 03:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 03:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 06:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/MichaReiser">@MichaReiser</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 06:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/konstin">@konstin</a> by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 06:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2023-12-13 06:56</div>
            <div class="timeline-body"><p>Would you mind including a comparision of the <code> ./scripts/formatter_ecosystem_checks.s</code> output between main and your PR, just to make sure that this is indeed backwards compatible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_string_literal.rs</code>:16 on 2023-12-13 07:02</div>
            <div class="timeline-body"><p>The term <code>context</code> is a bit confusing becaue it makes me think of <code>PyFormatContext</code> (which I first assumed this is). Can we give this a less generic name? Or call it <code>StringOptions</code> (see <code>FormatRuleWithOptions</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:147 on 2023-12-13 07:09</div>
            <div class="timeline-body"><p>As recommended in <code>FormatStringLiteral</code>. We can replace <code>StringContext</code> with <code>Quoting</code> when we use a <code>StringLiteralLayout</code> as the option of <code>FormatStringLiteral</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> approved on 2023-12-13 08:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/binary_like.rs</code>:398 on 2023-12-13 09:22</div>
            <div class="timeline-body"><p>It&#x27;s not immediately obvious why it formats the string without the enclosing group. I think it would help if we extend the comment saying: Call <code>FormatStringContinuation</code> directly to avoid formatting the string with the enclosing...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_f_string.rs</code>:17 on 2023-12-13 09:25</div>
            <div class="timeline-body"><p><code>with_options</code> seems to never be called on <code>ExprFString</code></p>
<pre><code>
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_string_literal.rs</code>:33 on 2023-12-13 09:29</div>
            <div class="timeline-body"><p>The naming here is a bit confusing:</p>
<ul>
<li>We&#x27;re inside the <code>ExprStringLiteral</code> (...literal)</li>
<li>But the <code>value</code> is now called <code>string_literal</code> but it is the part</li>
</ul>
<p>I think the rename that I recommended on the new AST node PR would help here as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/bytes_literal.rs</code>:13 on 2023-12-13 09:32</div>
            <div class="timeline-body"><p>Nit: You may want to inline these variables (or extract <code>f.options().quote_style(())</code>) too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/string_literal.rs</code>:11 on 2023-12-13 09:43</div>
            <div class="timeline-body"><p>Nit: I think I would limit the <code>FormatStringLiteral</code> to accept a layout which is either <code>Docstring</code> or <code>Default</code> to hide the string internals as much as possible.</p>
<p>For example, the <code>quoting</code> of <code>Docstring</code> is never used but it seems as if it is passed down.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/f_string.rs</code>:10 on 2023-12-13 09:49</div>
            <div class="timeline-body"><p>Using <code>FormatRuleWithOptions</code> here has the downside that the compiler doesn&#x27;t warn you when you forget to call <code>.with_options</code>, in which case the formatter simply assumes the <code>StringContext::default</code>.</p>
<p>I think it might be better to either set <code>context</code> to <code>Option</code> and add an assertion that throws if it is <code>None</code> or not use <code>FormatRule</code> (and <code>AsFormat</code> etc) and instead require an explicit construction of <code>FormatFString</code></p>
<pre><code>write!(f, [FormatFString { string: part, context: StringContext }])
</code></pre>
<p>It may also be useful to replace <code>StringContext</code> with quoting, because that seems to be all what is needed in here (f strings can&#x27;t be docstrings)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/f_string_part.rs</code>:23 on 2023-12-13 09:50</div>
            <div class="timeline-body"><p>The same as for <code>FormatString</code>: Consider creating <code>FormatFStringPart</code> manually instead of using <code>AsFormat</code> because passing the <code>context</code> is required. Consider passing <code>Quoting</code> directly, because the context is never needed for fstrings.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:462 on 2023-12-13 09:53</div>
            <div class="timeline-body"><p>It seems that not all these methods need to be <code>pub(crate)</code>. Please double check which ones are necessary to be visible outside of this module.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:224 on 2023-12-13 09:55</div>
            <div class="timeline-body"><p>I think it&#x27;s better to pass the context in the constructor because failing to call <code>with_context</code> uses the default context which may not use the right quotes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:195 on 2023-12-13 09:56</div>
            <div class="timeline-body"><p>I think it&#x27;s better to pass the context in the constructor because failing to call <code>with_context</code> uses the default context which may not use the right quotes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:151 on 2023-12-13 09:57</div>
            <div class="timeline-body"><p>I think all these methods can be made <code>pub(crate)</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> requested changes on 2023-12-13 10:03</div>
            <div class="timeline-body"><p>Moving the formatting into the corresponding nodes helps to untangle some of the complexity.</p>
<p>It overall looks good, but there are some places where we can reduce the complexity by limiting the option types further.</p>
<p>My main feedback is not specifically related to this PR but to the string parts refactor.</p>
<p>I continue to find it extremelly difficult to keep the different string nodes apart. because we have <code>ExprStringLiteral</code> and <code>StringLiteral</code>. I made a naming recommendation on your most recent AST refactor and I believe that implementing it could greatly help with naming (including downstream logic like the formatting code here). Doing this renaming sooner rather than later will ensure that downstream crates use the terminology consistently.</p>
<p>My other feedback related to this refactor is that I find the <code>StringLiteralValue</code> concept difficult to understand because it seems to be mainly an implementation detail. Reducing that additional concept (from the already complicated string nodes) by making <code>value</code> and the <code>StringLiteralValue</code> struct private, and moving all <code>StringLiteralValue</code> methods to <code>StringLiteralExpression</code> might help further reduce the complexity of our string nodes (at least the perceived complexity)</p>
<p>I don&#x27;t expect us to do this refactor as part of this PR but I think it will be worthwile to improve the naming of the string nodes, because I fail to understand the structure even after having looked up their definitions a couple of time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/bytes_literal.rs</code>:13 on 2023-12-13 18:16</div>
            <div class="timeline-body"><p>I&#x27;ve inlined the <code>docstring</code> call but the locator is being used in multiple locations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/string_literal.rs</code>:11 on 2023-12-13 18:20</div>
            <div class="timeline-body"><p>Good point. I thought so as well but then I realized that we need the quoting information when the literal is a part of an f-string which is implicitly concatenated. For example,</p>
<pre><code>&quot;foo&quot; f&quot;bar {x}&quot;
</code></pre>
<p>Here, the top level node is <code>ExprFString</code> which delegates the formatting to the individual parts which are <code>StringLiteral</code> (<code>&quot;foo&quot;</code>) and <code>FString</code> (<code>f&quot;bar {x}&quot;</code>). The f-string quoting logic takes place in <code>ExprFString</code> and is being passed to all the parts including <code>StringLiteral</code>.</p>
<p>I hope this clears up any doubts but if there&#x27;s any other confusion, please do ask.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/f_string_part.rs</code>:23 on 2023-12-13 18:25</div>
            <div class="timeline-body"><p>I don&#x27;t think it&#x27;ll work for <code>FormatFStringPart</code> due to it being required in <code>StringLiteral</code>. Refer <a href="https://github.com/astral-sh/ruff/pull/9058">astral-sh/ruff#9058</a>#discussion_r1425727018</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/string_literal.rs</code>:11 on 2023-12-13 18:38</div>
            <div class="timeline-body"><p>This is the main reason to introduce <code>StringContext</code> otherwise we don&#x27;t really need it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:40</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/f_string.rs</code>:10 on 2023-12-13 18:40</div>
            <div class="timeline-body"><p>This is beneficial but not completely in the way you expected mainly because of my comment above (<a href="https://github.com/astral-sh/ruff/pull/9058">astral-sh/ruff#9058</a>#discussion_r1425727018).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:224 on 2023-12-13 18:49</div>
            <div class="timeline-body"><p>There are calls to <code>FormatStringContinuation::new</code> which uses the default context. @MichaReiser Should we explicitly pass in the default context in those cases? I&#x27;m fine with either.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 18:57</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/expression/expr_string_literal.rs</code>:33 on 2023-12-13 18:57</div>
            <div class="timeline-body"><p>Yeah, I agree. I&#x27;ve started off with the renaming locally and will put up a PR today. There&#x27;s some thinking to do with the f-string side of the names.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 19:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/f_string.rs</code>:10 on 2023-12-13 19:02</div>
            <div class="timeline-body"><p>I&#x27;ve made this change and updated the <code>generate.py</code> script to ignore generating impls for <code>FString</code> node. Do you think it would be useful to move the file from <code>other/f_string.rs</code> to <code>string/f_string.rs</code> crate?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 19:10</div>
            <div class="timeline-body"><p>Thanks for the detailed review. I&#x27;ve made most of the requested changes:</p>
<ol>
<li>Rename <code>StringContext</code> to <code>StringOptions</code>, <code>with_context</code> to <code>with_options</code>.</li>
<li>Limit the visibility of various structs and methods as per it&#x27;s usage.</li>
<li>Remove <code>impl FormatRuleWithOptions for FormatExprFString</code>.</li>
<li>Remove <code>AsFormat</code> for <code>FString</code>, update <code>FormatFString</code> struct with a <code>new</code> method which requires the f-string node and the necessary quoting.</li>
</ol>
<p>Open points:</p>
<ol>
<li>Explicitly passing the <code>StringContext</code> to <code>FormatStringContinuation</code> constructor - in some cases, the call is made without the <code>with_context</code> method chain.</li>
<li>The requirement of <code>StringContext</code> mainly because the <code>StringLiteral</code> formatting requires both the quoting and layout information. The quoting comes when a string literal is part of an implicitly concatenated f-string while the layout comes when it&#x27;s a docstring.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-13 20:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/expression/expr_string_literal.rs</code>:33 on 2023-12-13 20:35</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/pull/9120</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-13 20:47</div>
            <div class="timeline-body"><blockquote>
<p>My other feedback related to this refactor is that I find the <code>StringLiteralValue</code> concept difficult to understand because it seems to be mainly an implementation detail. Reducing that additional concept (from the already complicated string nodes) by making <code>value</code> and the <code>StringLiteralValue</code> struct private, and moving all <code>StringLiteralValue</code> methods to <code>StringLiteralExpression</code> might help further reduce the complexity of our string nodes (at least the perceived complexity)</p>
</blockquote>
<p>Yeah, thanks for providing your perspective on this. With the AST rename PR, I&#x27;m able to understand why this might be so. I&#x27;ll probably do a follow-up next week to merge <code>*Value</code> and make the <code>value</code> field private.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-12-14 00:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:224 on 2023-12-14 00:22</div>
            <div class="timeline-body"><p>To me this mainly depends if the default context is guaranteed to do the right thing or if forgetting to call <code>with_context</code> may assume the wrong quotes and mess things up. In other words: Is calling <code>with_context</code> optional (<code>with_context</code> might be fine) or is it always required (constructor argument). I think we should always provide it because it can&#x27;t know the right quotes, can it?</p>
<p>Also, implicit concatenated strings can never be docstrings, right? We should then change the <code>FormatStringContinuation</code> to only take <code>quoting</code> as an option to encode this information in the types.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/binary_like.rs</code>:401 on 2023-12-14 00:37</div>
            <div class="timeline-body"><p>Is it save to omit <code>Quoting</code> here? Can <code>string_constent</code> be an <code>f-string</code> for which quotes need to be determined first and be preserved? I recommend making <code>quoting</code> a constructor argument if omitting it can lead to invalid results.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/f_string_part.rs</code>:34 on 2023-12-14 00:42</div>
            <div class="timeline-body"><p>F-string parts can never be docstrings. Only passing <code>quoting</code> encodes this invariant better</p>
<pre><code>#[derive(Default)]
pub struct FormatFStringPart {
    quoting: Quoting,
}

impl FormatRuleWithOptions&lt;FStringPart, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatFStringPart {
    type Options = Quoting;

    fn with_options(mut self, options: Self::Options) -&gt; Self {
        self.quoting = options;
        self
    }
}

impl FormatRule&lt;FStringPart, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatFStringPart {
    fn fmt(&amp;self, item: &amp;FStringPart, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
        match item {
            FStringPart::Literal(string_literal) =&gt; {
                string_literal.format().with_options(StringOptions::default().with_quoting(self.quoting)).fmt(f)
            }
            FStringPart::FString(f_string) =&gt; {
                FormatFString::new(f_string, self.quoting).fmt(f)
            }
        }
    }
}

</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/f_string_part.rs</code>:49 on 2023-12-14 00:44</div>
            <div class="timeline-body"><p>I believe calling <code>FormatFStringPart</code> should always require specifing <code>quoting</code>. If that assumption is correct, I recommend removing the <code>AsFormat</code> and <code>IntoFormat</code> implementations and require passing <code>quoting</code> as part of the constructor.</p>
<p>Or make <code>quoting</code> an <code>Option</code> and add an assertion that asserts that <code>quoting</code> is set (using <code>expect</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/other/f_string_part.rs</code>:39 on 2023-12-14 00:51</div>
            <div class="timeline-body"><p>It might be sufficient to pass <code>quoting</code> instead of <code>StringOptions</code> because FStrings can never be docstrings</p>
<pre><code>pub struct FormatFStringPart {
    quoting: Quoting,
}

impl FormatRuleWithOptions&lt;FStringPart, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatFStringPart {
    type Options = Quoting;

    fn with_options(mut self, options: Self::Options) -&gt; Self {
        self.quoting = options;
        self
    }
}

impl FormatRule&lt;FStringPart, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatFStringPart {
    fn fmt(&amp;self, item: &amp;FStringPart, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
        match item {
            FStringPart::Literal(string_literal) =&gt; {
                string_literal.format().with_options(StringOptions::default().with_quoting(self.quoting)).fmt(f)
            }
            FStringPart::FString(f_string) =&gt; {
                FormatFString::new(f_string, self.quoting).fmt(f)
            }
        }
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:203 on 2023-12-14 02:13</div>
            <div class="timeline-body"><p>We should be able to change this to <code>quoting</code> but it requires changing <code>AnyStringPart</code> too:</p>
<p>Change the <code>StringLiteral</code> and <code>FString</code> variants of <code>AnyStringPart</code> and store the string literal kind and the quoting in the variants:</p>
<pre><code>enum AnyStringPart&lt;&#x27;a&gt; {
    String {
        literal: &amp;&#x27;a ast::StringLiteral,
        kind: StringLiteralKind,
    },
    Bytes(&amp;&#x27;a ast::BytesLiteral),
    FString {
        string: &amp;&#x27;a ast::FString,
        quoting: Quoting,
    },
}
</code></pre>
<p>And then implement <code>Format</code> directly on <code>AnyStringPart</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2023-12-14 02:27</div>
            <div class="timeline-body"><p>This is looking good to me but I think it would be helpful to avoid using <code>StringOptions</code> (or remove it entirely) and instead use more specific option types. I&#x27;m saying this because I struggled hard to understand which combinations of <code>StringOptions</code> are possible in the different formatting functions.</p>
<p>I commented on the PR where I think we can narrow the options but you can also use the following diff if you want all changes applied (requires some cleanup because I didn&#x27;t always rename fields to match the type of the options).</p>
<pre><code>Index: crates/ruff_python_formatter/src/expression/expr_f_string.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_f_string.rs b/crates/ruff_python_formatter/src/expression/expr_f_string.rs
--- a/crates/ruff_python_formatter/src/expression/expr_f_string.rs	(revision Staged)
+++ b/crates/ruff_python_formatter/src/expression/expr_f_string.rs	(date 1702518874243)
@@ -9,20 +9,19 @@
     in_parentheses_only_group, NeedsParentheses, OptionalParentheses,
 };
 use crate::prelude::*;
-use crate::string::{AnyString, FormatStringContinuation, Quoting, StringOptions};
+use crate::string::{AnyString, FormatStringContinuation, Quoting};
 
 #[derive(Default)]
 pub struct FormatExprFString;
 
 impl FormatNodeRule&lt;ExprFString&gt; for FormatExprFString {
     fn fmt_fields(&amp;self, item: &amp;ExprFString, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
-        let options =
-            StringOptions::default().with_quoting(f_string_quoting(item, &amp;f.context().locator()));
+        let quoting = f_string_quoting(item, &amp;f.context().locator());
 
         match item.value.as_slice() {
-            [f_string_part] =&gt; f_string_part.format().with_options(options).fmt(f),
+            [f_string_part] =&gt; f_string_part.format().with_options(quoting).fmt(f),
             _ =&gt; in_parentheses_only_group(
-                &amp;FormatStringContinuation::new(&amp;AnyString::FString(item)).with_options(options),
+                &amp;FormatStringContinuation::new(&amp;AnyString::FString(item)).with_options(quoting),
             )
             .fmt(f),
         }
Index: crates/ruff_python_formatter/src/expression/expr_string_literal.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/expression/expr_string_literal.rs b/crates/ruff_python_formatter/src/expression/expr_string_literal.rs
--- a/crates/ruff_python_formatter/src/expression/expr_string_literal.rs	(revision Staged)
+++ b/crates/ruff_python_formatter/src/expression/expr_string_literal.rs	(date 1702519544384)
@@ -6,18 +6,37 @@
 use crate::expression::parentheses::{
     in_parentheses_only_group, NeedsParentheses, OptionalParentheses,
 };
+use crate::other::string_literal::StringLiteralKind;
 use crate::prelude::*;
-use crate::string::{
-    AnyString, FormatStringContinuation, StringOptions, StringPrefix, StringQuotes,
-};
+use crate::string::{AnyString, FormatStringContinuation, Quoting, StringPrefix, StringQuotes};
 
 #[derive(Default)]
 pub struct FormatExprStringLiteral {
-    options: StringOptions,
+    options: ExprStringLiteralKind,
+}
+
+#[derive(Default, Copy, Clone, Debug)]
+pub enum ExprStringLiteralKind {
+    #[default]
+    String,
+    Docstring,
+}
+
+impl ExprStringLiteralKind {
+    const fn string_literal_kind(self) -&gt; StringLiteralKind {
+        match self {
+            ExprStringLiteralKind::String =&gt; StringLiteralKind::String,
+            ExprStringLiteralKind::Docstring =&gt; StringLiteralKind::Docstring,
+        }
+    }
+
+    const fn is_docstring(self) -&gt; bool {
+        matches!(self, Self::Docstring)
+    }
 }
 
 impl FormatRuleWithOptions&lt;ExprStringLiteral, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatExprStringLiteral {
-    type Options = StringOptions;
+    type Options = ExprStringLiteralKind;
 
     fn with_options(mut self, options: Self::Options) -&gt; Self {
         self.options = options;
@@ -30,11 +49,15 @@
         let ExprStringLiteral { value, .. } = item;
 
         match value.as_slice() {
-            [string_literal] =&gt; string_literal.format().with_options(self.options).fmt(f),
-            _ =&gt; in_parentheses_only_group(
-                &amp;FormatStringContinuation::new(&amp;AnyString::String(item)).with_options(self.options),
-            )
-            .fmt(f),
+            [string_literal] =&gt; string_literal
+                .format()
+                .with_options(self.options.string_literal_kind())
+                .fmt(f),
+            _ =&gt; {
+                assert!(!self.options.is_docstring());
+                in_parentheses_only_group(&amp;FormatStringContinuation::new(&amp;AnyString::String(item)))
+                    .fmt(f)
+            }
         }
     }
 
Index: crates/ruff_python_formatter/src/other/f_string_part.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/other/f_string_part.rs b/crates/ruff_python_formatter/src/other/f_string_part.rs
--- a/crates/ruff_python_formatter/src/other/f_string_part.rs	(revision Staged)
+++ b/crates/ruff_python_formatter/src/other/f_string_part.rs	(date 1702519544305)
@@ -2,16 +2,17 @@
 use ruff_python_ast::FStringPart;
 
 use crate::other::f_string::FormatFString;
+use crate::other::string_literal::StringLiteralKind;
 use crate::prelude::*;
-use crate::string::StringOptions;
+use crate::string::Quoting;
 
 #[derive(Default)]
 pub struct FormatFStringPart {
-    options: StringOptions,
+    options: Quoting,
 }
 
 impl FormatRuleWithOptions&lt;FStringPart, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatFStringPart {
-    type Options = StringOptions;
+    type Options = Quoting;
 
     fn with_options(mut self, options: Self::Options) -&gt; Self {
         self.options = options;
@@ -22,12 +23,11 @@
 impl FormatRule&lt;FStringPart, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatFStringPart {
     fn fmt(&amp;self, item: &amp;FStringPart, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
         match item {
-            FStringPart::Literal(string_literal) =&gt; {
-                string_literal.format().with_options(self.options).fmt(f)
-            }
-            FStringPart::FString(f_string) =&gt; {
-                FormatFString::new(f_string, self.options.quoting()).fmt(f)
-            }
+            FStringPart::Literal(string_literal) =&gt; string_literal
+                .format()
+                .with_options(StringLiteralKind::InFString(self.options))
+                .fmt(f),
+            FStringPart::FString(f_string) =&gt; FormatFString::new(f_string, self.options).fmt(f),
         }
     }
 }
Index: crates/ruff_python_formatter/src/other/string_literal.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/other/string_literal.rs b/crates/ruff_python_formatter/src/other/string_literal.rs
--- a/crates/ruff_python_formatter/src/other/string_literal.rs	(revision Staged)
+++ b/crates/ruff_python_formatter/src/other/string_literal.rs	(date 1702519695435)
@@ -3,19 +3,40 @@
 use ruff_text_size::Ranged;
 
 use crate::prelude::*;
-use crate::string::{docstring, StringOptions, StringPart};
+use crate::string::{docstring, Quoting, StringPart};
 use crate::QuoteStyle;
 
 #[derive(Default)]
 pub struct FormatStringLiteral {
-    options: StringOptions,
+    layout: StringLiteralKind,
+}
+
+#[derive(Copy, Clone, Debug, Default)]
+pub enum StringLiteralKind {
+    #[default]
+    String,
+    Docstring,
+    InFString(Quoting),
+}
+
+impl StringLiteralKind {
+    pub(crate) const fn is_docstring(self) -&gt; bool {
+        matches!(self, StringLiteralKind::Docstring)
+    }
+
+    fn quoting(self) -&gt; Quoting {
+        match self {
+            StringLiteralKind::String | StringLiteralKind::Docstring =&gt; Quoting::CanChange,
+            StringLiteralKind::InFString(quoting) =&gt; quoting,
+        }
+    }
 }
 
 impl FormatRuleWithOptions&lt;StringLiteral, PyFormatContext&lt;&#x27;_&gt;&gt; for FormatStringLiteral {
-    type Options = StringOptions;
+    type Options = StringLiteralKind;
 
     fn with_options(mut self, options: Self::Options) -&gt; Self {
-        self.options = options;
+        self.layout = options;
         self
     }
 }
@@ -25,24 +46,24 @@
         let locator = f.context().locator();
         let parent_docstring_quote_style = f.context().docstring();
 
-        let quote_style = if self.options.is_docstring() {
+        let quote_style = match self.layout {
             // Per PEP 8 and PEP 257, always prefer double quotes for docstrings
-            QuoteStyle::Double
-        } else {
-            f.options().quote_style()
+            StringLiteralKind::Docstring =&gt; QuoteStyle::Double,
+            StringLiteralKind::String | StringLiteralKind::InFString(_) =&gt; {
+                f.options().quote_style()
+            }
         };
 
         let normalized = StringPart::from_source(item.range(), &amp;locator).normalize(
-            self.options.quoting(),
+            self.layout.quoting(),
             &amp;locator,
             quote_style,
             parent_docstring_quote_style,
         );
 
-        if self.options.is_docstring() {
-            docstring::format(&amp;normalized, f)
-        } else {
-            normalized.fmt(f)
+        match self.layout {
+            StringLiteralKind::Docstring =&gt; docstring::format(&amp;normalized, f),
+            StringLiteralKind::String | StringLiteralKind::InFString(_) =&gt; normalized.fmt(f),
         }
     }
 }
Index: crates/ruff_python_formatter/src/statement/suite.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/statement/suite.rs b/crates/ruff_python_formatter/src/statement/suite.rs
--- a/crates/ruff_python_formatter/src/statement/suite.rs	(revision Staged)
+++ b/crates/ruff_python_formatter/src/statement/suite.rs	(date 1702519544227)
@@ -9,9 +9,10 @@
     leading_comments, trailing_comments, Comments, LeadingDanglingTrailingComments,
 };
 use crate::context::{NodeLevel, TopLevelStatementPosition, WithIndentLevel, WithNodeLevel};
+use crate::expression::expr_string_literal::ExprStringLiteralKind;
+use crate::other::string_literal::StringLiteralKind;
 use crate::prelude::*;
 use crate::statement::stmt_expr::FormatStmtExpr;
-use crate::string::StringOptions;
 use crate::verbatim::{
     suppressed_node, write_suppressed_statements_starting_with_leading_comment,
     write_suppressed_statements_starting_with_trailing_comment,
@@ -609,7 +610,7 @@
                     leading_comments(node_comments.leading),
                     string_literal
                         .format()
-                        .with_options(StringOptions::docstring()),
+                        .with_options(ExprStringLiteralKind::Docstring),
                 ]
             )?;
 
Index: crates/ruff_python_formatter/src/string/mod.rs
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
&lt;+&gt;UTF-8
===================================================================
diff --git a/crates/ruff_python_formatter/src/string/mod.rs b/crates/ruff_python_formatter/src/string/mod.rs
--- a/crates/ruff_python_formatter/src/string/mod.rs	(revision Staged)
+++ b/crates/ruff_python_formatter/src/string/mod.rs	(date 1702519544492)
@@ -13,6 +13,7 @@
 use crate::comments::{leading_comments, trailing_comments};
 use crate::expression::parentheses::in_parentheses_only_soft_line_break_or_space;
 use crate::other::f_string::FormatFString;
+use crate::other::string_literal::StringLiteralKind;
 use crate::prelude::*;
 use crate::QuoteStyle;
 
@@ -47,21 +48,29 @@
         }
     }
 
-    fn parts(&amp;self) -&gt; Vec&lt;AnyStringPart&lt;&#x27;a&gt;&gt; {
+    fn parts(&amp;self, quoting: Quoting) -&gt; Vec&lt;AnyStringPart&lt;&#x27;a&gt;&gt; {
         match self {
-            Self::String(ExprStringLiteral { value, .. }) =&gt; {
-                value.iter().map(AnyStringPart::String).collect()
-            }
+            Self::String(ExprStringLiteral { value, .. }) =&gt; value
+                .iter()
+                .map(|part| AnyStringPart::String {
+                    literal: part,
+                    layout: StringLiteralKind::String,
+                })
+                .collect(),
             Self::Bytes(ExprBytesLiteral { value, .. }) =&gt; {
                 value.iter().map(AnyStringPart::Bytes).collect()
             }
             Self::FString(ExprFString { value, .. }) =&gt; value
                 .iter()
                 .map(|f_string_part| match f_string_part {
-                    ast::FStringPart::Literal(string_literal) =&gt; {
-                        AnyStringPart::String(string_literal)
-                    }
-                    ast::FStringPart::FString(f_string) =&gt; AnyStringPart::FString(f_string),
+                    ast::FStringPart::Literal(string_literal) =&gt; AnyStringPart::String {
+                        literal: string_literal,
+                        layout: StringLiteralKind::InFString(quoting),
+                    },
+                    ast::FStringPart::FString(f_string) =&gt; AnyStringPart::FString {
+                        string: f_string,
+                        quoting,
+                    },
                 })
                 .collect(),
         }
@@ -100,17 +109,23 @@
 
 #[derive(Clone, Debug)]
 enum AnyStringPart&lt;&#x27;a&gt; {
-    String(&amp;&#x27;a ast::StringLiteral),
+    String {
+        literal: &amp;&#x27;a ast::StringLiteral,
+        layout: StringLiteralKind,
+    },
     Bytes(&amp;&#x27;a ast::BytesLiteral),
-    FString(&amp;&#x27;a ast::FString),
+    FString {
+        string: &amp;&#x27;a ast::FString,
+        quoting: Quoting,
+    },
 }
 
 impl&lt;&#x27;a&gt; From&lt;&amp;AnyStringPart&lt;&#x27;a&gt;&gt; for AnyNodeRef&lt;&#x27;a&gt; {
     fn from(value: &amp;AnyStringPart&lt;&#x27;a&gt;) -&gt; Self {
         match value {
-            AnyStringPart::String(part) =&gt; AnyNodeRef::StringLiteral(part),
+            AnyStringPart::String { literal, .. } =&gt; AnyNodeRef::StringLiteral(literal),
             AnyStringPart::Bytes(part) =&gt; AnyNodeRef::BytesLiteral(part),
-            AnyStringPart::FString(part) =&gt; AnyNodeRef::FString(part),
+            AnyStringPart::FString { string, .. } =&gt; AnyNodeRef::FString(string),
         }
     }
 }
@@ -118,101 +133,49 @@
 impl Ranged for AnyStringPart&lt;&#x27;_&gt; {
     fn range(&amp;self) -&gt; TextRange {
         match self {
-            Self::String(part) =&gt; part.range(),
+            Self::String { literal, .. } =&gt; literal.range(),
             Self::Bytes(part) =&gt; part.range(),
-            Self::FString(part) =&gt; part.range(),
+            Self::FString { string, .. } =&gt; string.range(),
+        }
+    }
+}
+
+impl Format&lt;PyFormatContext&lt;&#x27;_&gt;&gt; for AnyStringPart&lt;&#x27;_&gt; {
+    fn fmt(&amp;self, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
+        match self {
+            AnyStringPart::String { literal, layout } =&gt; {
+                literal.format().with_options(*layout).fmt(f)
+            }
+            AnyStringPart::Bytes(bytes_literal) =&gt; bytes_literal.format().fmt(f),
+            AnyStringPart::FString { string, quoting } =&gt; {
+                FormatFString::new(string, *quoting).fmt(f)
+            }
         }
     }
 }
 
 #[derive(Copy, Clone, Debug, Default)]
-pub(crate) enum Quoting {
+pub enum Quoting {
     #[default]
     CanChange,
     Preserve,
 }
 
-#[derive(Default, Copy, Clone, Debug)]
-pub(crate) enum StringLayout {
-    #[default]
-    Default,
-    DocString,
-}
-
-/// Resolved options for formatting any kind of string. This can be either a string,
-/// bytes or f-string.
-#[derive(Copy, Clone, Debug, Default)]
-pub struct StringOptions {
-    quoting: Quoting,
-    layout: StringLayout,
-}
-
-impl StringOptions {
-    /// Creates a new context with the docstring layout.
-    pub(crate) fn docstring() -&gt; Self {
-        Self {
-            layout: StringLayout::DocString,
-            ..Self::default()
-        }
-    }
-
-    /// Returns a new context with the given [`Quoting`] style.
-    pub(crate) const fn with_quoting(mut self, quoting: Quoting) -&gt; Self {
-        self.quoting = quoting;
-        self
-    }
-
-    /// Returns the [`Quoting`] style to use for the string.
-    pub(crate) const fn quoting(self) -&gt; Quoting {
-        self.quoting
-    }
-
-    /// Returns `true` if the string is a docstring.
-    pub(crate) const fn is_docstring(self) -&gt; bool {
-        matches!(self.layout, StringLayout::DocString)
-    }
-}
-
-struct FormatStringPart&lt;&#x27;a&gt; {
-    part: &amp;&#x27;a AnyStringPart&lt;&#x27;a&gt;,
-    options: StringOptions,
-}
-
-impl&lt;&#x27;a&gt; FormatStringPart&lt;&#x27;a&gt; {
-    fn new(part: &amp;&#x27;a AnyStringPart&lt;&#x27;a&gt;, options: StringOptions) -&gt; Self {
-        Self { part, options }
-    }
-}
-
-impl Format&lt;PyFormatContext&lt;&#x27;_&gt;&gt; for FormatStringPart&lt;&#x27;_&gt; {
-    fn fmt(&amp;self, f: &amp;mut PyFormatter) -&gt; FormatResult&lt;()&gt; {
-        match self.part {
-            AnyStringPart::String(string_literal) =&gt; {
-                string_literal.format().with_options(self.options).fmt(f)
-            }
-            AnyStringPart::Bytes(bytes_literal) =&gt; bytes_literal.format().fmt(f),
-            AnyStringPart::FString(f_string) =&gt; {
-                FormatFString::new(f_string, self.options.quoting()).fmt(f)
-            }
-        }
-    }
-}
-
 pub(crate) struct FormatStringContinuation&lt;&#x27;a&gt; {
     string: &amp;&#x27;a AnyString&lt;&#x27;a&gt;,
-    options: StringOptions,
+    quoting: Quoting,
 }
 
 impl&lt;&#x27;a&gt; FormatStringContinuation&lt;&#x27;a&gt; {
     pub(crate) fn new(string: &amp;&#x27;a AnyString&lt;&#x27;a&gt;) -&gt; Self {
         Self {
             string,
-            options: StringOptions::default(),
+            quoting: Quoting::default(),
         }
     }
 
-    pub(crate) fn with_options(mut self, options: StringOptions) -&gt; Self {
-        self.options = options;
+    pub(crate) fn with_options(mut self, options: Quoting) -&gt; Self {
+        self.quoting = options;
         self
     }
 }
@@ -223,11 +186,11 @@
 
         let mut joiner = f.join_with(in_parentheses_only_soft_line_break_or_space());
 
-        for part in self.string.parts() {
+        for part in self.string.parts(self.quoting) {
             joiner.entry(&amp;format_args![
                 line_suffix_boundary(),
                 leading_comments(comments.leading(&amp;part)),
-                FormatStringPart::new(&amp;part, self.options),
+                part,
                 trailing_comments(comments.trailing(&amp;part))
             ]);
         }
</code></pre>
<p>I recommend taking a second look where omitting a call to <code>with_options</code> (and assuming the default) leads to invalid results and consider removing the <code>AsFormat</code> and <code>IntoFormat</code> implementations for these types (to force callers to specify all fields when cosntructing the <code>Format*</code>.</p>
<blockquote>
<p><strong>Note</strong>: It seems GitHub (reviewed with VS code) lost a few of my comments or even misplaced them. I&#x27;ll try to identify the missing ones but the patch above should include all places where we can replace <code>StringOptions</code> with more specific types (to the point where we can delete <code>StringOptions</code> all together)</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2023-12-14 02:32</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_formatter/src/expression/expr_string_literal.rs</code>:16 on 2023-12-14 02:32</div>
            <div class="timeline-body"><p>It seems the comment here went lost for some reason.</p>
<p>We could avoid using the generic <code>StringOptions</code> here by introducing an <code>ExprStringLiteralKind</code> that is either <code>String</code> or <code>Docstring</code> and do the same for <code>StringLiteral</code> but with an extra <code>InFString</code> variant. It may help future readers to better understand which invariants are possible (and from where the formattign is called).</p>
<pre><code>#[derive(Default)]
pub struct FormatExprStringLiteral {
    options: ExprStringLiteralKind,
}

#[derive(Default, Copy, Clone, Debug)]
pub enum ExprStringLiteralKind {
    #[default]
    String,
    Docstring,
}

impl ExprStringLiteralKind {
    const fn string_literal_kind(self) -&gt; StringLiteralKind {
        match self {
            ExprStringLiteralKind::String =&gt; StringLiteralKind::String,
            ExprStringLiteralKind::Docstring =&gt; StringLiteralKind::Docstring,
        }
    }

    const fn is_docstring(self) -&gt; bool {
        matches!(self, Self::Docstring)
    }
}


#[derive(Default)]
pub struct FormatStringLiteral {
    layout: StringLiteralKind,
}

#[derive(Copy, Clone, Debug, Default)]
pub enum StringLiteralKind {
    #[default]
    String,
    Docstring,
    InFString(Quoting),
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-14 17:02</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/expression/binary_like.rs</code>:401 on 2023-12-14 17:02</div>
            <div class="timeline-body"><p>This is actually a good point. I missed this, and it is indeed required to detect the quoting for f-string and pass it along. I&#x27;ll probably have to revert this change and move the quoting detection back to <code>AnyString</code> or find a different code path.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-14 18:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/expression/binary_like.rs</code>:401 on 2023-12-14 18:30</div>
            <div class="timeline-body"><p>This wasn&#x27;t too much to change. I added the <code>quoting</code> method back to <code>AnyString</code> which for an f-string will use the function <code>f_string_quoting</code> which is being used in 1 other place as well (<code>ExprFString</code>). This also means that <code>FormatStringContinuation</code> wouldn&#x27;t accept <code>Quoting</code> as an argument but rather determine it on it&#x27;s own and that&#x27;s valid as it&#x27;s a standalone expression. This keeps the simplification of binary like formatting for strings intact.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-14 18:38</div>
            <div class="timeline-body"><p>Alright, this is looking good. I&#x27;ve made the suggested changes and some more:</p>
<ol>
<li>Remove <code>StringOptions</code> and have specific options which are as suggested.</li>
<li>Custom implementation i.e., no <code>AsFormat</code> / <code>IntoFormat</code> for <code>FStringPart</code>, <code>FString</code>, and <code>StringLiteral</code> as the options for these nodes needs to be passed for every invocation (<code>with_options</code> needs to be called everytime).</li>
<li><code>FormatStringContinuation</code> doesn&#x27;t require the <code>Quoting</code> argument as it&#x27;ll detect it through <code>AnyString::quoting</code>. This is because it&#x27;s being called from binary like formatting and from each string expressions.</li>
</ol>
<p>I&#x27;ll merge this but feel free to add any further comments and I can take it up in a follow-up PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-14 18:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/string/mod.rs</code>:224 on 2023-12-14 18:38</div>
            <div class="timeline-body"><p>This is resolved because <code>FormatStringContinuation</code> determines the quoting by itself through <code>AnyString::quoting</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-14 18:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/f_string_part.rs</code>:23 on 2023-12-14 18:39</div>
            <div class="timeline-body"><p>This is resolved by updating as per recommendation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2023-12-14 18:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_formatter/src/other/string_literal.rs</code>:11 on 2023-12-14 18:39</div>
            <div class="timeline-body"><p>We&#x27;ve removed the <code>StringContext</code> and introduced narrow types for better understanding and safety.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-14 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2023-12-14 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-12-14 18:55</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 18:59:53 UTC
    </footer>
</body>
</html>
