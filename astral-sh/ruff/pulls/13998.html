<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Handle context managers in (sync) with statements - astral-sh/ruff #13998</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Handle context managers in (sync) with statements</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13998">#13998</a>
        opened by <a href="https://github.com/MichaReiser">@MichaReiser</a>
        on 2024-10-30 13:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR implements, hopefully correct, inference for the target types of with items (sync with statements only).</p>
<p>The context expression specifies a context manager and the target type must be inferred to the return type of the context manager's <code>__enter__</code> method.
That's what this PR implements.</p>
<p>The ad-hoc handling of protocols is awkward and leads to a lot of repetitive code but I decided not to spent too much time on it because
asserting that the context expression correctly implements the context manager protocol is going to change with proper protocol support.</p>
<h2>Test Plan</h2>
<p>Added tests</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @MichaReiser on 2024-10-30 13:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @MichaReiser on 2024-10-30 13:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @MichaReiser on 2024-10-30 13:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-10-30 13:58</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1014 on 2024-10-30 14:57</div>
            <div class="timeline-body"><p>nice catch :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1008 on 2024-10-30 14:59</div>
            <div class="timeline-body"><p><code>async with</code> statements use a different pair of methods entirely: <code>__aenter__</code> and <code>__aexit__</code> rather than <code>__enter__</code> and <code>__exit__</code></p>
<pre><code class="language-suggestion">        // TODO: Handle `async with` statements. For `async with` statements,
        // `__aenter__` and `__aexit__` coroutine methods are used (which must be awaited),
        // rather than synchronous `__enter__` and `__aexit__` methods
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1064 on 2024-10-30 15:04</div>
            <div class="timeline-body"><p>I don't actually know if simplification here is possible because simply checking if <code>context_manager_ty</code> is a subtype of <code>AbstractContextManager</code> won't give us the return type of the <code>__enter__</code> method. I think we do actually need to manually call the <code>__enter__</code> method somehow, and once we've done that we then <em>have</em> to manually consider the case where <code>__enter__</code> isn't actually callable... it's hard for me to see what would actually be simpler once we have generalised support for <code>typing.Protocol</code></p>
<p>Well, one thing we could do is to just check that the <code>__exit__</code> method is consistent with the <code>__exit__</code> method on <code>AbstractContextManager</code>, since <code>__exit__</code> method definitions can get pretty darn complicated. But we're not checking the call signature of <code>__exit__</code> at all right now, so this would be &quot;fending off future complexity&quot; rather than reducing any of the complexity that's already here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1031 on 2024-10-30 15:15</div>
            <div class="timeline-body"><p>PEPs are historical documents that record the rationale and discussion around a change that was made to the language. They are not guaranteed to be up-to-date; it's better to link to the language specification where possible, which is living documentation that we work to keep up-to-date. Here I'd link to:</p>
<ul>
<li>https://docs.python.org/3/library/stdtypes.html#typecontextmanager</li>
<li>https://docs.python.org/3/reference/datamodel.html#context-managers</li>
</ul>
<p>(Don't ask me why this information is split over two separate pages!)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1054 on 2024-10-30 15:16</div>
            <div class="timeline-body"><p>The detail in these error messages is fantastic! Long-term, I'm not sure we'll want all this information in one long sentence like this, but I think this is fine for now</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> had review dismissed on 2024-10-30 15:21</div>
            <div class="timeline-body"><p>Nice!</p>
<p>I'm not sure this properly handles the case where e.g. <code>__enter__</code> might or might not be defined, e.g.</p>
<pre><code class="language-py">def coinflip() -&gt; bool:
    return True

class Manager:
    if coinflip():
        def __enter__(self) -&gt; Target:
            return Target()

    def __exit__(self, *args): ...
</code></pre>
<p>I'm also not sure it's essential that we tackle that now for an initial implementation, but it could be worth at least adding a TODO around it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-30 15:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1031 on 2024-10-30 15:50</div>
            <div class="timeline-body"><p>Thanks. The PEP was the only resource I could find that is specific about the terminology. Your linked documents use that terminology but they never explain it. That's why I prefer keeping the link to the PEP</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-30 15:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1054 on 2024-10-30 15:50</div>
            <div class="timeline-body"><p>Agree</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-30 15:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1064 on 2024-10-30 15:51</div>
            <div class="timeline-body"><p>I think what would become reusable is testing if the context manager has the right shape. Once we know that, we can call <code>enter</code> (which should never fail at this point)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-30 15:51</div>
            <div class="timeline-body"><blockquote>
<p>I'm not sure this properly handles the case where e.g. <strong>enter</strong> might or might not be defined, e.g.</p>
</blockquote>
<p>Lol, python allows if statements in class bodies</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-30 16:13</div>
            <div class="timeline-body"><p>Oh, it's okay to skip implementing the logic for async <code>with</code> statements yet, and just infer <code>Todo</code> for them. But this PR introduces false positives for <code>async with</code> statements, and I don't think that's okay.</p>
<p>On this snippet:</p>
<pre><code class="language-py">class Foo:
    async def __aenter__(self):
        return &quot;foo&quot;

    async def __aexit__(self, *args):
        pass

async def foo():
    async with Foo() as x:
        reveal_type(x)
</code></pre>
<p>red-knot reports with your PR branch:</p>
<pre><code>ERROR /Users/alexw/dev/experiment/foo.py:9:16: Object of type Foo cannot be used with `with` because it doesn't implement `__enter__` and `__exit__`
ERROR /Users/alexw/dev/experiment/foo.py:10:9: `reveal_type` used without importing it; this is allowed for debugging convenience but will fail at runtime
ERROR /Users/alexw/dev/experiment/foo.py:10:9: Revealed type is `Unknown`
</code></pre>
<p>I think you might need to do something like this to avoid adding false positives for <code>async with</code> statements in this PR:</p>
<details>

<pre><code class="language-diff">--- a/crates/red_knot_python_semantic/src/semantic_index/builder.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/builder.rs
@@ -734,12 +734,12 @@ where
                     self.flow_merge(break_state);
                 }
             }
-            ast::Stmt::With(ast::StmtWith { items, body, .. }) =&gt; {
+            ast::Stmt::With(ast::StmtWith { items, body, is_async, .. }) =&gt; {
                 for item in items {
                     self.visit_expr(&amp;item.context_expr);
                     if let Some(optional_vars) = item.optional_vars.as_deref() {
                         self.add_standalone_expression(&amp;item.context_expr);
-                        self.push_assignment(item.into());
+                        self.push_assignment(CurrentAssignment::WithItem { is_async: *is_async, item });
                         self.visit_expr(optional_vars);
                         self.pop_assignment();
                     }
@@ -1011,11 +1011,12 @@ where
                                 },
                             );
                         }
-                        Some(CurrentAssignment::WithItem(with_item)) =&gt; {
+                        Some(CurrentAssignment::WithItem{is_async, item}) =&gt; {
                             self.add_definition(
                                 symbol,
                                 WithItemDefinitionNodeRef {
-                                    node: with_item,
+                                    is_async,
+                                    node: item,
                                     target: name_node,
                                 },
                             );
@@ -1232,7 +1233,10 @@ enum CurrentAssignment&lt;'a&gt; {
         node: &amp;'a ast::Comprehension,
         first: bool,
     },
-    WithItem(&amp;'a ast::WithItem),
+    WithItem {
+        is_async: bool,
+        item: &amp;'a ast::WithItem,
+    },
 }
 
 impl&lt;'a&gt; From&lt;&amp;'a ast::StmtAnnAssign&gt; for CurrentAssignment&lt;'a&gt; {
@@ -1259,12 +1263,6 @@ impl&lt;'a&gt; From&lt;&amp;'a ast::ExprNamed&gt; for CurrentAssignment&lt;'a&gt; {
     }
 }
 
-impl&lt;'a&gt; From&lt;&amp;'a ast::WithItem&gt; for CurrentAssignment&lt;'a&gt; {
-    fn from(value: &amp;'a ast::WithItem) -&gt; Self {
-        Self::WithItem(value)
-    }
-}
-
 struct CurrentMatchCase&lt;'a&gt; {
     /// The pattern that's part of the current match case.
     pattern: &amp;'a ast::Pattern,
diff --git a/crates/red_knot_python_semantic/src/semantic_index/definition.rs b/crates/red_knot_python_semantic/src/semantic_index/definition.rs
index 4da4c4e6a..f1826d1de 100644
--- a/crates/red_knot_python_semantic/src/semantic_index/definition.rs
+++ b/crates/red_knot_python_semantic/src/semantic_index/definition.rs
@@ -174,6 +174,7 @@ pub(crate) struct AssignmentDefinitionNodeRef&lt;'a&gt; {
 
 #[derive(Copy, Clone, Debug)]
 pub(crate) struct WithItemDefinitionNodeRef&lt;'a&gt; {
+    pub(crate) is_async: bool,
     pub(crate) node: &amp;'a ast::WithItem,
     pub(crate) target: &amp;'a ast::ExprName,
 }
@@ -277,8 +278,9 @@ impl DefinitionNodeRef&lt;'_&gt; {
                     DefinitionKind::ParameterWithDefault(AstNodeRef::new(parsed, parameter))
                 }
             },
-            DefinitionNodeRef::WithItem(WithItemDefinitionNodeRef { node, target }) =&gt; {
+            DefinitionNodeRef::WithItem(WithItemDefinitionNodeRef { is_async, node, target }) =&gt; {
                 DefinitionKind::WithItem(WithItemDefinitionKind {
+                    is_async,
                     node: AstNodeRef::new(parsed.clone(), node),
                     target: AstNodeRef::new(parsed, target),
                 })
@@ -329,7 +331,7 @@ impl DefinitionNodeRef&lt;'_&gt; {
                 ast::AnyParameterRef::Variadic(parameter) =&gt; parameter.into(),
                 ast::AnyParameterRef::NonVariadic(parameter) =&gt; parameter.into(),
             },
-            Self::WithItem(WithItemDefinitionNodeRef { node: _, target }) =&gt; target.into(),
+            Self::WithItem(WithItemDefinitionNodeRef { is_async: _, node: _, target }) =&gt; target.into(),
             Self::MatchPattern(MatchPatternDefinitionNodeRef { identifier, .. }) =&gt; {
                 identifier.into()
             }
@@ -532,11 +534,16 @@ pub enum AssignmentKind {
 
 #[derive(Clone, Debug)]
 pub struct WithItemDefinitionKind {
+    is_async: bool,
     node: AstNodeRef&lt;ast::WithItem&gt;,
     target: AstNodeRef&lt;ast::ExprName&gt;,
 }
 
 impl WithItemDefinitionKind {
+    pub(crate) fn is_async(&amp;self) -&gt; bool {
+        self.is_async
+    }
+
     pub(crate) fn node(&amp;self) -&gt; &amp;ast::WithItem {
         self.node.node()
     }
diff --git a/crates/red_knot_python_semantic/src/types/infer.rs b/crates/red_knot_python_semantic/src/types/infer.rs
index 9ab4cb65b..6550f2ee2 100644
--- a/crates/red_knot_python_semantic/src/types/infer.rs
+++ b/crates/red_knot_python_semantic/src/types/infer.rs
@@ -476,7 +476,12 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
                 self.infer_parameter_with_default_definition(parameter_with_default, definition);
             }
             DefinitionKind::WithItem(with_item) =&gt; {
-                self.infer_with_item_definition(with_item.target(), with_item.node(), definition);
+                self.infer_with_item_definition(
+                    with_item.is_async(),
+                    with_item.target(),
+                    with_item.node(),
+                    definition,
+                );
             }
             DefinitionKind::MatchPattern(match_pattern) =&gt; {
                 self.infer_match_pattern_definition(
@@ -999,7 +1004,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
     fn infer_with_statement(&amp;mut self, with_statement: &amp;ast::StmtWith) {
         let ast::StmtWith {
             range: _,
-            is_async: _,
+            is_async,
             items,
             body,
         } = with_statement;
@@ -1017,7 +1022,9 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
                 // Call into the context expression inference to validate that it evaluates
                 // to a valid context manager.
                 let context_expression_ty = self.infer_expression(&amp;item.context_expr);
-                self.infer_context_expression(&amp;item.context_expr, context_expression_ty);
+                if !is_async {
+                    self.infer_context_expression(&amp;item.context_expr, context_expression_ty);
+                }
                 self.infer_optional_expression(target);
             }
         }
@@ -1027,6 +1034,7 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
 
     fn infer_with_item_definition(
         &amp;mut self,
+        is_async: bool,
         target: &amp;ast::ExprName,
         with_item: &amp;ast::WithItem,
         definition: Definition&lt;'db&gt;,
@@ -1034,10 +1042,14 @@ impl&lt;'db&gt; TypeInferenceBuilder&lt;'db&gt; {
         let context_expr = self.index.expression(&amp;with_item.context_expr);
         self.extend(infer_expression_types(self.db, context_expr));
 
-        let target_ty = self.infer_context_expression(
-            &amp;with_item.context_expr,
-            self.expression_ty(&amp;with_item.context_expr),
-        );
+        let target_ty = if is_async {
+            Type::Todo
+        } else {
+            self.infer_context_expression(
+                &amp;with_item.context_expr,
+                self.expression_ty(&amp;with_item.context_expr),
+            )
+        };
 
         self.types
             .expressions
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/with.md</code>:1 on 2024-10-30 17:16</div>
            <div class="timeline-body"><p>Nit about this title, and the location of this file: with statements create Definitions, which are Bindings, but are not Declarations. (A declaration is only an annotated assignment, or an annotated function parameter, or a function or class definition.) So I think this title should be just <code>With statements</code>.</p>
<p>Regarding file location, we don't have a general directory for all kinds of definitions/bindings, so I think <code>with/</code> could be a top-level directory if/when we have multiple files to put in there; for now a top level <code>with.md</code> would be fine, I think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/with.md</code>:49 on 2024-10-30 17:17</div>
            <div class="timeline-body"><p>The diagnostic messages here and below are excellent! Super clear and informative.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:1012 on 2024-10-30 17:24</div>
            <div class="timeline-body"><p>While we're editing this comment anyway, this part isn't accurate anymore either. I think it could be edited as below. Arguably that doesn't give much information that isn't obvious, but I think it's not 100% obvious that <code>Type::call</code> means &quot;what happens if I call an object of this type&quot;, so I'd probably still favor keeping the short doc comment.</p>
<p>We could also do a much longer doc comment here or elsewhere that talks about how to actually correctly use <code>CallOutcome</code>, but that's definitely out of scope for this PR :)</p>
<pre><code class="language-suggestion">    /// Return the outcome of calling an object of this type.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-30 17:41</div>
            <div class="timeline-body"><blockquote>
<p>I'm not sure this properly handles the case where e.g. <strong>enter</strong> might or might not be defined, e.g.</p>
</blockquote>
<p>nice catch. I added a test with a todo. I want to wait with handling this until we removed unbound.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @MichaReiser on 2024-10-30 17:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1064 on 2024-10-30 17:42</div>
            <div class="timeline-body"><p>I think maybe what Alex is implying is that it could be kind of wasteful/unnecessary to check <code>__enter__</code> against the protocol, when simply calling it and seeing if the call succeeds or fails is actually sufficient. But this is a question that we can leave for later, I think the comment is reasonable as-is. We can always change our mind when actually implementing a TODO if it turns out not to make sense to to do it that way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/async_with.md</code>:6 on 2024-10-30 17:45</div>
            <div class="timeline-body"><p>nit: quite long lines here. Also, we haven't renamed it to <code>Knot</code> <em>yet</em> ;)</p>
<pre><code class="language-suggestion">The type of the target variable in a `with` statement should be the return type
from the context manager's `__aenter__` method. However, we don't support `async with`
statements yet. This test asserts that it doesn't emit any context manager-related errors.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/with.md</code>:5 on 2024-10-30 17:45</div>
            <div class="timeline-body"><pre><code class="language-suggestion">The type of the target variable in a `with` statement is the return type
from the context manager's `__enter__` method.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1064 on 2024-10-30 17:48</div>
            <div class="timeline-body"><p>whatever the case, this is a very long line ;)</p>
<pre><code class="language-suggestion">        // TODO: The checks here should be simplified to checking
        // if context manager implements the `contextlib.AbstractContextManager` protocol.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> approved on 2024-10-30 17:48</div>
            <div class="timeline-body"><p>Thanks! This LGTM now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/src/types/infer.rs</code>:1116 on 2024-10-30 17:50</div>
            <div class="timeline-body"><p>The return type here will matter to us later, because it will determine whether exceptions are suppressed by this <code>with</code> block. We could add a TODO for that but I don't think it's important that we do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2024-10-30 17:50</div>
            <div class="timeline-body"><p>This is really well done! Super clear, thorough, and well-researched.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-10-31 07:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/async_with.md</code>:6 on 2024-10-31 07:31</div>
            <div class="timeline-body"><p>I'm open to enabling markdown formatting but I otherwise prefer not to reflow text manually. This does not affect how the text is rendered</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-10-31 08:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-10-31 08:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-31 08:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-10-31 08:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/async_with.md</code>:6 on 2024-10-31 08:20</div>
            <div class="timeline-body"><blockquote>
<p>This does not affect how the text is rendered</p>
</blockquote>
<p>I know. My concern is more the ability to read and edit the code on small screens. But I agree it's not the most important issue in the world, just a nit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2024-10-31 15:10</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/red_knot_python_semantic/resources/mdtest/declaration/async_with.md</code>:6 on 2024-10-31 15:10</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ruff/pull/14020</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:07:20 UTC
    </footer>
</body>
</html>
