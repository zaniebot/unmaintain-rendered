<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[ty] Type compendium - astral-sh/ruff #18263</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[ty] Type compendium</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/18263">#18263</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-05-22 19:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-22 19:49</div>
            <div class="timeline-body"><h2>Summary</h2>
<p>Rendered version: <a href="https://github.com/astral-sh/ruff/blob/david/type-compendium/crates/ty_python_semantic/resources/mdtest/type_compendium/README.md"><strong>Type compendium</strong></a></p>
<p>This is something I wrote a few months ago, and continued to update from time to time. It was mostly written for my own education. I found a few bugs while writing it at the time (there are still one or two TODOs in the test assertions that are probably bugs). Our other tests are fairly comprehensive, but they are usually structured around a certain functionality or operation (subtyping, assignability, narrowing). The idea here was to focus on individual <em>types and their properties</em>.</p>
<p>I don't really want to waste anyone's time reviewing this when there are more important things to do, but I think that most of it is probably uncontroversial, and potentially helpful as a reference for developers or even users of ty. I always wanted to extend it further (see how the table of contents still has some missing links; and that was before we had generics, which I'd obviously also love to include there), but before it is lost and forgotten, I thought I'd push it up for visibility, in case anyone finds it interesting. I'm honestly fine with deleting this if we think that it mostly duplicates existing tests, and therefore increases long-term maintenance cost.</p>
<p>closes https://github.com/astral-sh/ty/issues/197 (added <code>JustFloat</code> and <code>JustComplex</code> to <code>ty_extensions</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @sharkdp on 2025-05-22 19:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @AlexWaygood by @sharkdp on 2025-05-22 19:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @dcreager by @sharkdp on 2025-05-22 19:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">documentation</span> added by @sharkdp on 2025-05-22 19:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">ty</span> added by @sharkdp on 2025-05-22 19:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2025-05-22 19:52</div>
            <div class="timeline-body"><!-- generated-comment mypy_primer -->

<h2><code>mypy_primer</code> results</h2>
<p>No ecosystem changes detected ✅</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-05-22 20:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/never.md</code>:116 on 2025-05-22 20:01</div>
            <div class="timeline-body"><p>this section feels like it's maybe meant to have some intersection examples in it rather than union examples ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/never.md</code>:158 on 2025-05-22 20:03</div>
            <div class="timeline-body"><p>but note that the homogeneous tuple type <code>tuple[Never, ...]</code> does have inhabitants (the empty tuple, <code>()</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-05-22 20:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-05-22 20:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/never.md</code>:141 on 2025-05-22 20:04</div>
            <div class="timeline-body"><p>nit: &quot;one inhabitant&quot; feels slightly imprecise here, because it's possible to create multiple empty lists which are not the same runtime object but would all inhabit the type <code>list[Never]</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/integer_literals.md</code>:133 on 2025-05-22 21:20</div>
            <div class="timeline-body"><p>Presumably it would be equivalent to describe these as <code>float &amp; ~int</code> and <code>complex &amp; ~float</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/none.md</code>:65 on 2025-05-22 21:36</div>
            <div class="timeline-body"><p>We could say a bit more here about the fact that using <code>None</code> (which is an instance at runtime) to spell a type is a slightly weird special case, which only works because <code>NoneType</code> is a singleton type, so the name of the singleton instance can be used interchangeably with the name of the type. (For any other type, you'd use the name of the type, that is <code>NoneType</code>.) But I also don't think it's important that we add this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:49 on 2025-05-22 21:49</div>
            <div class="timeline-body"><p>I think the empty tuple would not be a singleton even if we didn't model the possibility of tuple subclasses. There was strong consensus in https://discuss.python.org/t/should-we-specify-in-the-language-reference-that-the-empty-tuple-is-a-singleton/67957 that empty tuple being a singleton is an implementation detail of CPython, not part of the language.</p>
<p>I think disjointness of heterogenous tuple types with other instance types might be an area where we do take into account the possibility of subclasses?</p>
<p>(And it's worth noting that our current treatment of the empty tuple as <code>AlwaysFalsy</code> -- mentioned in that doc -- is inconsistent with modeling the possibility of tuple subclasses.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:69 on 2025-05-22 21:50</div>
            <div class="timeline-body"><p>Yes, it is &quot;for the same reason&quot;, but that reason is not subclassing, it's that in the case of non-empty tuples, two tuples with the same contents are not necessarily the same object, not even in CPython as an implementation detail.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:136 on 2025-05-22 21:57</div>
            <div class="timeline-body"><p>Which, we should note, is not compatible with supporting tuple subclasses, so we are currently inconsistent (though I think it requires TypeVarTuple support to demonstrate it):</p>
<pre><code class="language-py">class mytuple[*T](tuple[*T]):
    def __bool__(self) -&gt; bool:
        return choice([True, False])

def f(x: tuple[()]): ...

def g(x: mytuple[()]):
    return f(x)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:144 on 2025-05-22 21:58</div>
            <div class="timeline-body"><p>This is also incompatible with supporting subclasses.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> approved on 2025-05-22 21:59</div>
            <div class="timeline-body"><p>This is awesome! I'm sure it does overlap with existing tests in some areas, but the cost of that is not high, and I think in most cases this is superior documentation of the rationale than the overlapping test we currently have.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2025-05-22 22:08</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:136 on 2025-05-22 22:08</div>
            <div class="timeline-body"><p>I think we should just disallow users from overriding <code>__bool__</code> or <code>__len__</code> on user-defined tuple subclasses. Current type checkers are united in thinking both that <code>tuple[()]</code> is an always-falsy type and that an instance of <code>Foo</code> is an inhabitant of <code>tuple[()]</code> if <code>Foo</code> subclasses <code>tuple[()]</code>.</p>
<p>I think it follows very naturally from Liskov's original formulation of her principle that this property should be enforced for tuple subclasses:</p>
<blockquote>
<p>Subtype Requirement: Let ⁠ <code>ϕ ( x )</code>⁠ be a property provable about objects ⁠<code>x</code> of type <code>T</code>. Then ⁠ <code>ϕ ( y )</code>⁠ should be true for objects ⁠<code>y</code> of type <code>S</code> where <code>S</code> is a subtype of <code>T</code>.</p>
</blockquote>
<p>It is a property provable about objects <code>x</code> of type <code>tuple[()]</code> that they are all falsy; thus it should hold true for all subtypes of <code>tuple[()]</code> that they should also always be falsy; thus we should prevent users from overriding <code>__bool__</code> or <code>__len__</code> on such types, ensuring that users can continue to narrow such types out of unions using truthiness checks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a> reviewed on 2025-05-22 22:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/carljm">@carljm</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:136 on 2025-05-22 22:33</div>
            <div class="timeline-body"><p>It was intentional that my example above didn't subclass <code>tuple[()]</code>, but rather subclassed <code>tuple[*T]</code> -- thus the subclass also can be either empty or non-empty. Thus there is no base class for which a constant-truthiness is provable, so Liskov would not suggest any restriction on the subclass either. (I agree that it would be sensible under Liskov not to allow a subclass of <code>tuple[()]</code> to override <code>__bool__</code> to return something other than <code>False</code>.)</p>
<p>That said, I agree that if we are more restrictive than Liskov would require, and prohibit any tuple subclass from overriding <code>__bool__</code> (we don't need to worry about <code>__len__</code>, we never use it for statically known truthiness), that would allow us to continue to consider heterogenous tuple types to have known truthiness. And I agree this is probably a better pragmatic tradeoff -- subclassing tuple is rare, subclassing tuple and overriding <code>__bool__</code> even more rare -- relying on known truthiness of a heterogenous tuple much more common.</p>
<p>I would be fine if this document recorded our intention to take that route (with TODOs where we don't implement it yet.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-23 08:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/integer_literals.md</code>:133 on 2025-05-23 08:16</div>
            <div class="timeline-body"><p>Yes, they should be. <code>TypeOf[1.0]</code> is currently not equivalent to <code>Intersection[float, Not[int]]</code>, because the latter expands to <code>(float* | int) &amp; ~int = float* &amp; ~int | int &amp; ~int = float* &amp; ~int</code>, where <code>float*</code> is the bare <code>float</code> type. That should be equivalent to <code>TypeOf[1.0] = float*</code>, because <code>float* &amp; int = Never</code> (slots / lay-out conflict), and so <code>~int</code> is a supertype of <code>float*</code>, making the intersection <code>float* &amp; ~int</code> equivalent to <code>float*</code>.</p>
<p>But we can <a href="https://play.ty.dev/dc5be064-2dfc-418e-9315-0fd5a34d9dcb">currently not simplify this further</a>.</p>
<p>I moved the definitions of <code>JustFloat</code> and <code>JustComplex</code> to <code>ty_extensions</code>, as we also use them elsewhere. This was also suggested <a href="https://github.com/astral-sh/ty/issues/197#issuecomment-2859028289">here</a>. I used <code>TypeOf[1.0]</code> for now, in order not to confuse anyone with how we display the type (<code>float</code> vs <code>float &amp; ~int</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @sharkdp on 2025-05-23 09:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-23 09:34</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:136 on 2025-05-23 09:34</div>
            <div class="timeline-body"><p>Thank you! I tried to summarize the discussion in the document. Please let me know if something is inaccurate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/sharkdp">@sharkdp</a> on <code>crates/ty_python_semantic/resources/mdtest/type_compendium/tuple.md</code>:49 on 2025-05-23 09:39</div>
            <div class="timeline-body"><blockquote>
<p>I think the empty tuple would not be a singleton even if we didn't model the possibility of tuple subclasses. There was strong consensus in https://discuss.python.org/t/should-we-specify-in-the-language-reference-that-the-empty-tuple-is-a-singleton/67957 that empty tuple being a singleton is an implementation detail of CPython, not part of the language.</p>
</blockquote>
<p>Thanks, updated and added that reference.</p>
<blockquote>
<p>I think disjointness of heterogenous tuple types with other instance types might be an area where we do take into account the possibility of subclasses?</p>
</blockquote>
<p>Correct. I added a test for this.</p>
<blockquote>
<p>(And it's worth noting that our current treatment of the empty tuple as <code>AlwaysFalsy</code> -- mentioned in that doc -- is inconsistent with modeling the possibility of tuple subclasses.)</p>
</blockquote>
<p>:+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a> reviewed on 2025-05-23 09:39</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @sharkdp on 2025-05-23 09:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-05-23 09:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2025-05-23 09:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 18:51:29 UTC
    </footer>
</body>
</html>
