<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[`flake8-type-checking`] Add exemption for runtime evaluated decorator classes - astral-sh/ruff #15060</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[<code>flake8-type-checking</code>] Add exemption for runtime evaluated decorator classes</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/15060">#15060</a>
        opened by <a href="https://github.com/viccie30">@viccie30</a>
        on 2024-12-19 12:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/viccie30">@viccie30</a> on 2024-12-19 12:09</div>
            <div class="timeline-body"><!--
Thank you for contributing to Ruff! To help us out with reviewing, please consider the following:

- Does this pull request include a summary of the change? (See below.)
- Does this pull request include a descriptive title?
- Does this pull request include references to any relevant issues?
-->

<h2>Summary</h2>
<p>This PR makes ruff recognize functions decorated with methods,
like FastAPI uses to specify endpoints.</p>
<p>I've implemented the check by generalizing
<code>ruff_linter::src::rules::fastapi::rules::is_fastapi_route_call</code> to
recognize methods of specific classes used as decorators.</p>
<h2>Test Plan</h2>
<p>I have added tests by duplicating and adjusting
<code>crates/ruff_linter/resources/test/fixtures/flake8_type_checking/runtime_evaluated_decorators_{1..3}.py</code>.</p>
<!-- How was it tested? -->

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-12-19 12:16</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-12-19 12:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_linter/src/checkers/ast/annotation.rs</code>:93 on 2024-12-19 12:25</div>
            <div class="timeline-body"><p>Nit: I suggest passing the <code>flake8_type_checking</code> settings instead of passing every setting individually</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-19 12:27</div>
            <div class="timeline-body"><p>Would this address https://github.com/astral-sh/ruff/issues/13713 ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/viccie30">@viccie30</a> on 2024-12-19 12:29</div>
            <div class="timeline-body"><blockquote>
<p>Would this address #13713 ?</p>
</blockquote>
<p>I think so.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/viccie30">@viccie30</a> on <code>crates/ruff_linter/src/checkers/ast/annotation.rs</code>:93 on 2024-12-19 12:30</div>
            <div class="timeline-body"><p>I wanted to make as few changes as possible, but I can change this, of course.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/viccie30">@viccie30</a> reviewed on 2024-12-19 12:30</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-19 12:32</div>
            <div class="timeline-body"><p>Thank you. I think this makes sense.</p>
<p>@Daverball, I'd be interested in your thoughts on this change because you're the most familiar with our type-checking rules.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/viccie30">@viccie30</a> reviewed on 2024-12-19 12:55</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/viccie30">@viccie30</a> on <code>crates/ruff_linter/src/checkers/ast/annotation.rs</code>:93 on 2024-12-19 12:55</div>
            <div class="timeline-body"><p>I have changed this, and the callers, too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-19 12:57</div>
            <div class="timeline-body"><p>This looks good to me. The flake8 plugin currently does something less clever for FastAPI support, with a toggle that you have to enable if you use FastAPI, which increases false negatives in the rest of your code. This approach seems more balanced and flexible.</p>
<p>My only concern is that we probably want to add additional settings to support marker generics like <code>sqlalchemy.orm.Mapped</code>, which require some or all of the symbols to be available at runtime. I think FastAPI also has some things like that. So at that point we'd have at least five very similar options, which begs the question of whether there's maybe a better way to organize them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/viccie30">@viccie30</a> on 2024-12-19 13:19</div>
            <div class="timeline-body"><blockquote>
<p>My only concern is that we probably want to add additional settings to support marker generics like <code>sqlalchemy.orm.Mapped</code>, which require some or all of the symbols to be available at runtime. I think FastAPI also has some things like that. So at that point we'd have at least five very similar options, which begs the question of whether there's maybe a better way to organize them.</p>
</blockquote>
<p>I had throught about rolling this option into <code>runtime-evaluated-decorators</code> by adding a fallback from matching any identifier in the list literally to matching any value that is initialized by any identifier in the list, but I thought separating the two was cleaner.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-19 13:21</div>
            <div class="timeline-body"><p>The one thing this currently fails to cover is sharing your instances between modules:</p>
<pre><code class="language-python">from datetime import datetime
from mymodule import app

@app.put(&quot;/datetime&quot;)
def set_datetime(value: datetime) -&gt; None:
    pass
</code></pre>
<p>The question is if that matters, since red knot presumably will be able to handle that case in the future.</p>
<hr />
<p>But we could also support that use-case by extending <code>runtime-evaluated-decorators</code> to match if the dotted name starts the same way, rather than only when it matches exactly:</p>
<pre><code class="language-toml">[tool.ruff.lint.flake8-type-checking]
runtime-evaluated-decorators = [&quot;mymodule.app&quot;]
</code></pre>
<p>would match <code>@mymodule.app</code> but also <code>@mymodule.app.route</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/viccie30">@viccie30</a> on 2024-12-19 13:25</div>
            <div class="timeline-body"><blockquote>
<p>The one thing this currently fails to cover is sharing your instances between modules:</p>
<pre><code class="language-python">from datetime import datetime
from mymodule import app

@app.put(&quot;/datetime&quot;)
def set_datetime(value: datetime) -&gt; None:
    pass
</code></pre>
<p>The question is if that matters, since red knot presumably will be able to handle that case in the future.</p>
<p>But we could also support that use-case by extending <code>runtime-evaluated-decorators</code> to match if the dotted name starts the same way, rather than only when it matches exactly:</p>
<pre><code class="language-toml">[tool.ruff.lint.flake8-type-checking]
runtime-required-decorators = [&quot;mymodule.app&quot;]
</code></pre>
<p>would match <code>@mymodule.app</code> but also <code>@mymodule.app.route</code></p>
</blockquote>
<p>I had thought about how to add that possibility, but I could not find a clean way. If this is something you would like to see as you sketched it above, I'd be happy to add it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-19 13:52</div>
            <div class="timeline-body"><blockquote>
<p>If this is something you would like to see as you sketched it above, I'd be happy to add it.</p>
</blockquote>
<p>I think that would be enough to cover most FastAPI use-cases, so it seems like a desirable improvement to the semantics of that setting. Although it might require some documentation improvements, so people understand, that this is something they can do.</p>
<p>It might also be interesting to investigate whether we can get away with just the original setting with this change, as long as we can match the binding in the module it was defined to the fully qualified name. I.e.</p>
<p><code>mymodule/__init__.py</code></p>
<pre><code class="language-python">from fastapi import FastAPI as Api

app = Api()

@app.put(&quot;/datetime&quot;)  # matches &quot;mymodule.app&quot; because we're in `mymodule`.
def set_datetime(value: datetime) -&gt; None:
    pass
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-19 14:00</div>
            <div class="timeline-body"><p>Actually, the other use-case can already be supported by adding <code>mymodule.app.put</code> etc. although that would be quite tedious and error-prone, so maybe it makes more sense to support glob patterns, i.e. <code>mymodule.app.*</code>, rather than arbitrary sub-matches.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/viccie30">@viccie30</a> on 2024-12-19 14:11</div>
            <div class="timeline-body"><blockquote>
<p>Actually, the other use-case can already be supported by adding <code>mymodule.app.put</code> etc. although that would be quite tedious and error-prone, so maybe it makes more sense to support glob patterns, i.e. <code>mymodule.app.*</code>, rather than arbitrary sub-matches.</p>
</blockquote>
<p>Would you like me to add that to this PR or open another PR for that? And do you still want to merge this PR?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Daverball">@Daverball</a> on 2024-12-19 14:30</div>
            <div class="timeline-body"><p>I have no merging power. All I can give is my opinion.</p>
<p>I think the feature is fine the way you implemented it, but if we can support this use-case with only the existing setting by slightly changing the semantics, that would be even better, since we wouldn't need to rely on a potentially expensive <code>resolve_assignment</code> that way and can keep the configuration more simple.</p>
<p>If you feel like experimenting with the suggested approach in a separate PR, feel free. But please don't feel compelled to invest the time. I'm happy to try it myself, although I definitely won't get around to it today.</p>
<p>@MichaReiser Care to chime in, with how you would like this to move forward?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">configuration</span> added by @MichaReiser on 2024-12-30 16:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-30 17:01</div>
            <div class="timeline-body"><p>Sorry, I was out for most days last week and I also needed some time to familiarize myself with the subject.</p>
<p>Adding regex support is an option but I'm a bit hesitant of doing so because a) it requires matching on the qualified names string representation which requires allocating a <code>String</code> and most (if not all) other qualified name settings don't support it. We could consider only testing if the qualified name starts with the same segments, but this seems like a possible footgun to me which is why I think that having to list all methods might be better for now (related issue https://github.com/astral-sh/ruff/pull/15060).</p>
<p>I'm not that much concerned about <code>resolve_assignment</code>. We use it in other rules already. But I'm interested in exploring ways to avoid introducing a new option because it's not very obvious which one a user has to pick.</p>
<p>I'm probably overlooking something, but could we combine the two options and change <code>required_decorators</code> to:</p>
<pre><code class="language-rust">fn runtime_required_decorators(
    decorator_list: &amp;[Decorator],
    decorators: &amp;[String],
    semantic: &amp;SemanticModel,
) -&gt; bool {
    if decorators.is_empty() {
        return false;
    }

    decorator_list.iter().any(|decorator| {
        let callable = map_callable(&amp;decorator.expression);

        if let Expr::Attribute(ast::ExprAttribute { value, .. }) = callable {
            if let Some(qualified_name) = resolve_assignment(value, semantic) {
                return decorators.iter().any(|decorator_class| {
                    QualifiedName::from_dotted_name(decorator_class) == qualified_name
                });
            }
        }

        semantic
            .resolve_qualified_name(callable)
            .is_some_and(|qualified_name| {
                decorators
                    .iter()
                    .any(|base_class| QualifiedName::from_dotted_name(base_class) == qualified_name)
            })
    })
}
</code></pre>
<p>Or are there cases where the resolved qualified name wouldn't be unique?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/viccie30">@viccie30</a> on 2024-12-30 17:51</div>
            <div class="timeline-body"><blockquote>
<p>Or are there cases where the resolved qualified name wouldn't be unique?</p>
</blockquote>
<p>I don't think so, unless someone would want to have</p>
<pre><code class="language-python">var = Class()

@var.method
def function():
    ....
</code></pre>
<p>match and</p>
<pre><code class="language-python">var = Class()

@Class
def function():
    ....
</code></pre>
<p>not match, but I don't think that will be an issue in practice.</p>
<p>I added a new option because I thought there might be confusion otherwise, but looking at it now I think adding this to the existing check is fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-12-31 14:11</div>
            <div class="timeline-body"><p>Thank you @viccie30 for putting up this PR. @Daverball followed up on the discussion and created a PR that extends the existing option to cover class methods too. See https://github.com/astral-sh/ruff/pull/15204</p>
<p>I'll close this PR in favor of this new PR as it achieves the same end-goal but without introducing a new setting. Thanks again for PRing this change and initiating the discussion!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-12-31 14:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-12-31 14:15</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 20:42:57 UTC
    </footer>
</body>
</html>
