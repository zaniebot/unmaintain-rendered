<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[red-knot] Track root cause of why a type is inferred as `Unknown` - astral-sh/ruff #12986</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[red-knot] Track root cause of why a type is inferred as <code>Unknown</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ruff/pull/12986">#12986</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2024-08-19 11:00
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>This PR adds detailed information to our type inference so we can track exactly why a symbol has been inferred as <code>Unknown</code>. This allows us to restore the <code>unresolved-import</code> red-knot lint to the level of accuracy it had prior to https://github.com/astral-sh/ruff/commit/a9847af6e89c593dcb49023b5e88ba7f4a84a61a, because we can now distinguish between <code>Unknown</code> types that were caused by unresolved imports and other kinds of <code>Unknown</code> types. The approach is similar to <a href="https://github.com/python/mypy/blob/fe15ee69b9225f808f8ed735671b73c31ae1bed8/mypy/types.py#L187-L215">the one mypy uses</a>.</p>
<h2>Test Plan</h2>
<p>There are two ways in which this PR is tested:</p>
<ol>
<li>The assertion in the benchmark is changed: six spurious &quot;Unresolved import&quot; diagnostics go away, meaning the number of diagnostics drops from 34 to 28. The only remaining &quot;unresolved import&quot; diagnostic is emitted on <a href="https://github.com/python/cpython/blob/e077b201f49a6007ddad7c1b6e3069a037b6d952/Lib/tomllib/_parser.py#L7">this line</a>, which is because we don't understand <code>*</code> imports yet, and <code>Iterable</code> is defined in the typeshed stub for <code>collections.abc</code> <a href="https://github.com/python/typeshed/blob/937270df0c25dc56a02f7199f1943fdb7d47aa9d/stdlib/collections/abc.pyi#L1">here</a>.</li>
<li>A test is unskipped in <code>red_knot_workspace/src/lint.rs</code> asserting that a project structure (where the <code>foo</code> module does not exist) like this only triggers an &quot;unresolved import&quot; diagnostic in <code>a.py</code>, and not in <code>b.py</code>:<ul>
<li><code>/src/a.py</code>: <code>import foo as foo</code></li>
<li><code>/src/b.py</code>: <code>from a import foo</code></li>
</ul>
</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">red-knot</span> added by @AlexWaygood on 2024-08-19 11:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @carljm by @AlexWaygood on 2024-08-19 11:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @MichaReiser by @AlexWaygood on 2024-08-19 11:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 11:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:257 on 2024-08-19 11:01</div>
            <div class="timeline-body"><p>I derived <code>Ord</code> and <code>PartialOrd</code> here because the <code>Type</code> enum derives them, but I'm not sure it makes sense to do so. I don't really understand why the <code>Type</code> enum derives them in the first place.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 11:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:314 on 2024-08-19 11:03</div>
            <div class="timeline-body"><p>This covers quite a lot. If the intention is to only ever emit diagnostics after all types have been inferred, we may need to split this into several variants, so that we can emit different error messages (under different codes) for different kinds of errors. On the other hand, we could consider collecting some diagnostics as part of the <code>TypeInferenceBuilder</code>, which would mean we wouldn't need so much granularity here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-08-19 11:14</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 11:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:257 on 2024-08-19 11:38</div>
            <div class="timeline-body"><p>Yeah, me neither. I would remove <code>Ord</code> from <code>Type</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-08-19 11:40</div>
            <div class="timeline-body"><p>How does this new type work when unifying or intersecting types? Do we keep all different variants?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-19 11:48</div>
            <div class="timeline-body"><blockquote>
<p>How does this new type work when unifying or intersecting types? Do we keep all different variants?</p>
</blockquote>
<p>Good question. Currently yes, you could end up with a union such as <code>int | Unknown(UnknownTypeKind::UnresolvedImport) | Unknown(UnknownTypeKind::TypeError)</code>.</p>
<p>I suppose we should flatten them into a single <code>Unknown</code> member. But then the question becomes: what <code>kind</code> of <code>Unknown</code> should it be? Maybe <code>UnknownTypeKind::SecondOrder</code>, since it results from the union of two <code>Unknown</code> elements?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:257 on 2024-08-19 12:14</div>
            <div class="timeline-body"><p>I removed the <code>PartialOrd</code> and <code>Ord</code> implementations in https://github.com/astral-sh/ruff/pull/12986/commits/ff6b1484e9dc743da2763da0dd82864c7b347472</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-19 12:14</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-08-20 06:56</div>
            <div class="timeline-body"><p>I would love to wait with this PR to get @carljm opinion. I feel uncertain about the type's definition because there are no &quot;obvious&quot; definitions for unification and intersection (unless we make it a bit set, at least for unification).</p>
<p>It's further unclear if we still need to distinguish between the two types, now that the check for unresolved imports moves into the type checker.</p>
<p>I had a quick look at pyright and from what i understand is that it uses <code>Unknown</code> for unresolved imports but it only has a single <code>Unknown</code> type.</p>
<p>https://github.com/microsoft/pyright/blob/52a47010b9db2ad6801b4b35d987cb9f4c923c18/packages/pyright-internal/src/analyzer/typeEvaluator.ts#L18629-L18676</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-20 07:01</div>
            <div class="timeline-body"><blockquote>
<p>I would love to wait with this PR to get @carljm opinion. I feel uncertain about the type's definition because there are no &quot;obvious&quot; definitions for unification and intersection</p>
</blockquote>
<p>Agreed, I'm definitely not going to merge until we've heard Carl's thoughts here! There's no rush on this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-20 11:58</div>
            <div class="timeline-body"><blockquote>
<p>I feel uncertain about the type's definition because there are no &quot;obvious&quot; definitions for unification and intersection (unless we make it a bit set, at least for unification).</p>
</blockquote>
<p>FWIW, I think simplifying unions is inevitably going to become more complex than what we currently have, whether we go with this PR or not, because of the fact that we will want to simplify <code>Literal[True] | Literal[False]</code> to <code>Instance(builtins.bool)</code>, and similarly for other <a href="https://github.com/astral-sh/ty/issues/245">sealed types</a> such as enums.</p>
<blockquote>
<p>It's further unclear if we still need to distinguish between the two types, now that the check for unresolved imports moves into the type checker.</p>
</blockquote>
<p>Hmm, yeah, not sure. I'll try to pull out some of the improvements here into a separate PR that doesn't introduce the new <code>UnknownTypeKind</code> enum, so that we can evaluate in isolation exactly whether it improves anything for us right now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/AlexWaygood">@AlexWaygood</a> reviewed on 2024-08-21 14:28</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on <code>crates/red_knot_python_semantic/src/types.rs</code>:461 on 2024-08-21 14:28</div>
            <div class="timeline-body"><p>Following https://github.com/astral-sh/ruff/commit/ecd9e6a650ef428be67bb0e28cb0c52d27eb2895, the key benefit of this PR is now that this test can be unskipped. This improvement is also reflected in the fact that six spurious &quot;unresolved import&quot; diagnostics go away in the benchmarks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codspeed-hq[bot]">@codspeed-hq[bot]</a> on 2024-08-21 14:36</div>
            <div class="timeline-body"><h2><a href="https://codspeed.io/astral-sh/ruff/branches/alex/unknown-kind">CodSpeed Performance Report</a></h2>
<h3>Merging astral-sh/ruff#12986 will <strong>degrade performances by 5.41%</strong></h3>
<p><sub>Comparing <code>alex/unknown-kind</code> (698de48) with <code>main</code> (ecd9e6a)</sub></p>
<h3>Summary</h3>
<p><code>❌ 1</code> regressions
<code>✅ 31</code> untouched benchmarks</p>
<blockquote>
<p>:warning: <em>Please fix the performance issues or <a href="https://codspeed.io/astral-sh/ruff/branches/alex/unknown-kind">acknowledge them on CodSpeed</a>.</em></p>
</blockquote>
<h3>Benchmarks breakdown</h3>
<p>|     | Benchmark | <code>main</code> | <code>alex/unknown-kind</code> | Change |
| --- | --------- | ----------------------- | ------------------- | ------ |
| ❌ | <code>linter/default-rules[numpy/globals.py]</code> | 170.5 µs | 180.3 µs | -5.41% |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-22 01:31</div>
            <div class="timeline-body"><p>I'm open to the idea that we may need to do this eventually, but there are complexity and efficiency disadvantages to smuggling additional context through the type system this way, so I'd rather not do it until it's really clear exactly why we need it. And I don't think that's currently clear, given that the issue with the unresolved-imports check in main branch that this PR fixes is also easily fixable with a much smaller change: https://github.com/astral-sh/ruff/pull/13007</p>
<p>I don't think we should ever need this for the sake of deciding whether or not to emit a diagnostic. <code>Unknown</code> may <em>result</em> from a type error, but I don't think its existence should ever create a type error. The fact that main branch currently treats an import of any <code>Unknown</code> typed value as an error is IMO not correct, and is fixed by the change linked above.</p>
<p>I would be interested in knowing more about precisely how mypy uses its extra information about the origin of <code>Any</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-22 11:37</div>
            <div class="timeline-body"><blockquote>
<p>I don't think we should ever need this for the sake of deciding whether or not to emit a diagnostic. <code>Unknown</code> may <em>result</em> from a type error, but I don't think its existence should ever create a type error. The fact that main branch currently treats an import of any <code>Unknown</code> typed value as an error is IMO not correct, and is fixed by the change linked above.</p>
</blockquote>
<p>Thanks, I think this is correct; treating <code>Unknown</code> as a type error goes against the spirit of gradual typing. We need to catch the error before we transform the <code>Unbound</code> into <code>Unknown</code>. My mistake.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-22 13:02</div>
            <div class="timeline-body"><blockquote>
<p>I would be interested in knowing more about precisely how mypy uses its extra information about the origin of <code>Any</code>.</p>
</blockquote>
<p>Much of it seems to be used for precise diagnostics when strict mode is enabled. Mypy <code>--strict</code> enables several checks that prevent implicit <code>Any</code> types from accidentally percolating through your code. So mypy wants to be able to distinguish between <code>Any</code>s that result from missing generic arguments, unannotated variables, and objects explicitly annotated as <code>Any</code> (for example).</p>
<p>E.g. <a href="https://github.com/python/mypy/blob/fe15ee69b9225f808f8ed735671b73c31ae1bed8/mypy/checker.py#L2939-L2951">here</a> the type of <code>Any</code> is checked by the <a href="https://github.com/python/mypy/blob/fe15ee69b9225f808f8ed735671b73c31ae1bed8/mypy/typeanal.py#L2352-L2370"><code>has_any_from_unimported_type()</code></a> function in order to implement mypy's optional error code <a href="https://mypy.readthedocs.io/en/stable/error_code_list2.html#check-that-types-have-no-any-components-due-to-missing-imports-no-any-unimported"><code>[no-any-unimported]</code></a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-08-22 13:06</div>
            <div class="timeline-body"><p>I still think there's a good chance that we'll need something like this eventually, but I agree that with the fixes in astral-sh/ruff#13055, there are few immediate benefits to this right now. Thanks both!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2024-08-22 13:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-22 13:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-08-22 16:52</div>
            <div class="timeline-body"><blockquote>
<p>Much of it seems to be used for precise diagnostics when strict mode is enabled.</p>
</blockquote>
<p>Yeah, that makes sense. I agree, we'll probably need something like this for the same reason, when we want to have an Any-forbidding strict mode and emit useful diagnostics for it.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:06:06 UTC
    </footer>
</body>
</html>
