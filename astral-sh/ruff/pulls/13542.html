<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[python_ast] Make the iter_mut functions public - astral-sh/ruff #13542</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[python_ast] Make the iter_mut functions public</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/ruff/pull/13542">#13542</a>
        opened by <a href="https://github.com/ndmitchell">@ndmitchell</a>
        on 2024-09-27 19:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>I needed to use these, so expose them. I am manipulating an AST to mutate it, and can't get at the inner strings here.</p>
<h2>Test Plan</h2>
<p>CI</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-27 19:12</div>
            <div class="timeline-body"><p>The fact that this method isn't public seems intentional to me because mutating can result in an inconsistent to_str result.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-27 19:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/github-actions[bot]">@github-actions[bot]</a> on 2024-09-27 19:25</div>
            <div class="timeline-body"><!-- generated-comment ecosystem -->

<h2><code>ruff-ecosystem</code> results</h2>
<h3>Linter (stable)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Linter (preview)</h3>
<p>✅ ecosystem check detected no linter changes.</p>
<h3>Formatter (stable)</h3>
<p>✅ ecosystem check detected no format changes.</p>
<h3>Formatter (preview)</h3>
<p>✅ ecosystem check detected no format changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-27 20:31</div>
            <div class="timeline-body"><p>For my particular usage, I actually only want to mutate the ranges. Thoughts on how to do that in a safe way?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-09-27 20:31</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-09-28 10:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-28 10:29</div>
            <div class="timeline-body"><p>In fact, if I had Parser::new_starts_at exposed that would suit my needs even better. I have a string, but I know it starts halfway through a file, and what to parse that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-09-28 10:49</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-28 10:49</div>
            <div class="timeline-body"><p>And I guess this only applies to the StringLiteral one - since the others don't have a cached to_str, they could be made public?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-28 11:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-28 11:11</div>
            <div class="timeline-body"><p>The parser exposes a parse_expression_range method. I rather not expose the parser struct</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-09-28 14:29</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-28 14:29</div>
            <div class="timeline-body"><p>I need to iterate mutably over FString's for other purposes. Would you be OK exposing the iter_mut for FString and BytesLiteral? Or even just FString? (On the basis BytesLiteral could one day get a to_str, but FString never will)</p>
<p>The parse_expression_range gets a string and parses a subset of it. I instead want to parse the full string, but with an implicit offset. Currently I'm faking that by creating a string of 1000+ spaces, then the expression I care about, and using parse_expression_range. That's pretty inefficient.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-28 15:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-28 15:52</div>
            <div class="timeline-body"><p>Do you have some code that you can share. I don't understand the use case and I rather not expose iter_mut because it breaks the type's encapsulation</p>
<p>Have you considered recreating the entire ExprStringLiteral and cloning the parts?</p>
<p>For the offset. The main use case for the offsets is so that you can slice into the string but that's not what you want. Have you considered offsetting the ranges e.g when printing the errors or what's the use case for the offsets?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-09-29 19:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-29 19:43</div>
            <div class="timeline-body"><p>I am writing a Python type checker. I've already talked to some Astral folks (Carl - who we should chat with again). Two things:</p>
<ul>
<li><p>In the Python typing spec, you can have strings in place of types. E.g. <code>def f(x: &quot;list[int]&quot;):</code>. So you now have a string literal <code>list[int]</code> and want to turn it into a type, which is just an expression, so want to call <code>parse_expression</code>. But if you can't find <code>list</code> etc, you want to report exactly where you couldn't find list. You could of course shift all the ranges (but not unless you expose iter_mut) or shift them for a subset of expressions when printing (but that's super error prone - now you need to wrap every expression with its tracking offset). The easiest thing is to just parse with an implicit offset. Currently we do that by creating a really long string of spaces and using parse_expression_range. You can't just parse from the original string, as there might be things like escapes or multiple literals (which you have to pad out with spaces to get the right positions - which isn't too hard to do).</p>
</li>
<li><p>Part of our type checker goes walking through expressions to substitute them out with other expressions, to do some book keeping and make some expressions point at other places. Concretely we have <code>fn expr_visit_mut&lt;'a&gt;(x: &amp;'a mut Expr, f: impl FnMut(&amp;'a mut Expr))</code> which calls the callback on every one-step recursive function. That's a super handy generic primitive to have. But alas, FString (and only FString) doesn't expose enough pieces to get at the mutable iterators inside. Having <code>iter_mut</code> on FString would be valuable and allow such a function. We actually have <code>expr_visit_mut</code>, <code>expr_visit</code>, <code>stmt_visit_mut</code>, <code>stmt_visit</code>, <code>stmt_expr_visit_mut</code>, <code>stmt_expr_visit</code> (the last two finding the expressions inside a statement). It would be wonderful if all those were provided on the AST for free. We use them for loads of things.</p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-09-29 20:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-29 20:43</div>
            <div class="timeline-body"><p>(in all cases we'd be delighted to supply them as a PR, once we figure out the design)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dhruvmanila">@dhruvmanila</a> reviewed on 2024-09-30 13:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-30 13:22</div>
            <div class="timeline-body"><p>For (1), we do use <code>parse_expression_range</code>, you might be interested in going through https://github.com/astral-sh/ruff/blob/5118166d21784e7c78e38ea42919ba50bb2a5142/crates/ruff_python_parser/src/typing.rs which parses string type annotations. Ruff still has a bug for complex type annotations (like implicitly concatenated strings) https://github.com/astral-sh/ruff/issues/10586.</p>
<p>For (2), we have the <a href="https://github.com/astral-sh/ruff/blob/5118166d21784e7c78e38ea42919ba50bb2a5142/crates/ruff_python_ast/src/visitor/transformer.rs"><code>Transformer</code> trait</a> which will visit the nodes to allow mutation.</p>
<p>Is this useful?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> reviewed on 2024-09-30 13:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-09-30 13:52</div>
            <div class="timeline-body"><p>We are also looking into how to solve 1 for our type checker</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-10-01 12:52</div>
            <div class="timeline-body"><p>@dhruvmanila - yep, we have the identical problem, but haven't added the &quot;simple literal&quot; special case. We probably should. But then still end up with the same issue. If you had the parse_expression_at, then the special case becomes non-interesting and you can simplify the code.</p>
<p>The Transformer trait is super interesting. It's a shame that the self isn't mut - that makes accumulating in the visitor much harder. It's a shame there is no lifetime constraint, e.g. if you are walking an <code>&amp;'a Stmt</code>, you have the guarantee that all the statements you bump into have the same lifetime <code>'a</code> (I note SourceOrderVisitor has this). Can't you use this to screw with the literals in a StringLiteral, thus breaking the <code>to_str</code> cache? With those adjustments, I think we'd implement our visitors on top of your Transformer trait.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-10-01 12:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ndmitchell">@ndmitchell</a> reviewed on 2024-10-01 13:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/ndmitchell">@ndmitchell</a> on <code>crates/ruff_python_ast/src/nodes.rs</code>:1752 on 2024-10-01 13:15</div>
            <div class="timeline-body"><p>Alternatively, if you added <code>parse_expression_in_string_literal(x: &amp;StringLiteral) -&gt; Expr</code> then that would be <em>exactly</em> the primitive we both need, we could delete the slightly dubious <code>parse_expression_range</code> (is there another good reason to have this?) and you could do very clever things to deal with things like escapes only once.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2024-10-07 07:31</div>
            <div class="timeline-body"><p>I would like to wait with this PR until we decided on how to solve https://github.com/astral-sh/ruff/discussions/13499</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MichaReiser">@MichaReiser</a> approved on 2024-10-19 19:03</div>
            <div class="timeline-body"><p>This is probably fine. The AST is really just a data object and provides little to no abstraction. It's certainly a footgun but it's already possible to mutate the tree in place in the transformer.</p>
<p>We may decide to remove those accessors in the future but for now, this seems fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @MichaReiser on 2024-10-19 19:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">parser</span> added by @MichaReiser on 2024-10-19 19:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @MichaReiser on 2024-10-19 19:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @MichaReiser on 2024-10-19 19:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-21 18:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:06:44 UTC
    </footer>
</body>
</html>
