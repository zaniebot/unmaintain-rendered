```yaml
number: 15950
title: "[red-knot] Merge Markdown code blocks inside a single section"
type: pull_request
state: merged
author: sharkdp
labels:
  - testing
  - ty
assignees: []
merged: true
base: main
head: david/fix-15941
created_at: 2025-02-04T21:43:07Z
updated_at: 2025-02-05T22:12:01Z
url: https://github.com/astral-sh/ruff/pull/15950
synced_at: 2026-01-12T15:55:53Z
```

# [red-knot] Merge Markdown code blocks inside a single section

---

_@sharkdp_

## Summary

Allow for literate style in Markdown tests and merge multiple (unnamed) code blocks into a single embedded file.

closes #15941 (see ticket for a more detailed description of the general idea, or look at the exemplary changes in the Markdown files)

Note: unfortunately, this conflicts badly with #15945 by @BurntSushi. This PR is definitely low-priority, so I'm happy to resolve conflicts here once #15945 is merged.

## Test Plan

- Interactively made sure that error-lines were reported correctly in multi-snippet sections.

---

_Label `red-knot` added by @sharkdp on 2025-02-04 21:43_

---

_Label `testing` added by @sharkdp on 2025-02-05 09:56_

---

_Marked ready for review by @sharkdp on 2025-02-05 09:56_

---

_Review requested from @carljm by @sharkdp on 2025-02-05 09:56_

---

_Review requested from @MichaReiser by @sharkdp on 2025-02-05 09:56_

---

_Review requested from @AlexWaygood by @sharkdp on 2025-02-05 09:56_

---

_Review comment by @MichaReiser on `crates/red_knot_test/src/parser.rs`:168 on 2025-02-05 10:06_

It might be worth to move this comment into the `CodeBlockStructure`'s doccomment

---

_Review comment by @MichaReiser on `crates/red_knot_test/src/parser.rs`:181 on 2025-02-05 10:07_

I find the `Structure` postfix not very meaningful. Why isn't a `CodeBlock` a structure itself. 

Reading the comment, the focus here is that this structure holds the code blocks for a single file. 

How about: 

* EmbeddedFileLineIndex (has the advantage that everyone familiar with `LineIndex` immediately knows what this is)
* EmbeddedFileSourceMap (similar to the source map used for jupyter notebooks)
* FileCodeBlockLines




---

_Review comment by @MichaReiser on `crates/red_knot_test/src/parser.rs`:217 on 2025-02-05 10:07_

Nit: `Autogenerated(PySourceType)`?

---

_Review comment by @MichaReiser on `crates/red_knot_test/src/parser.rs`:286 on 2025-02-05 10:09_

Nit: I'd be surprised that `code` constructs the code when calling. Maybe rename to `to_code` or can we do the joining more eagerly when constructing `EmbeddedFile`?

---

_Review comment by @MichaReiser on `crates/red_knot_test/src/parser.rs`:623 on 2025-02-05 10:10_

Can we make those messages more useful and include some line numbers or at least test name or is this done further up in the parser?

---

_Review comment by @MichaReiser on `crates/red_knot_test/src/lib.rs`:140 on 2025-02-05 10:12_

Nit: Could we simplify this by collecting the dimensions instead of using a `Box<dyn impl Iterator>`. I suspect that the performance difference is minimal. 

---

_@MichaReiser approved on 2025-02-05 10:14_

---

_@sharkdp reviewed on 2025-02-05 11:42_

---

_Review comment by @sharkdp on `crates/red_knot_test/src/lib.rs`:140 on 2025-02-05 11:42_

I wanted to make it lazy to avoid counting line numbers for all snippets even if we never emit a test failure, but that might have been an unnecessary optimization, I agree. Will look into it.

---

_Review comment by @AlexWaygood on `crates/red_knot_test/src/lib.rs`:117 on 2025-02-05 12:12_

We could consider:
1. Adding a `full_path()` method to `EmbeddedFile` (and removing the `path_str()` method)
2. Implementing `PartialEq<str>` for `EmbeddedFilePath`

<details>
<summary>Patch</summary>

```diff
diff --git a/crates/red_knot_test/src/lib.rs b/crates/red_knot_test/src/lib.rs
index 5bd878e98..4d86d8bc3 100644
--- a/crates/red_knot_test/src/lib.rs
+++ b/crates/red_knot_test/src/lib.rs
@@ -110,11 +110,7 @@ fn run_test<'s>(db: &mut db::Db, test: &'s parser::MarkdownTest) -> Result<(), F
                 "Supported file types are: py, pyi, text"
             );
 
-            let full_path = if embedded.path_str().starts_with('/') {
-                SystemPathBuf::from(embedded.path_str())
-            } else {
-                project_root.join(embedded.path_str())
-            };
+            let full_path = embedded.full_path(&project_root);
 
             if let Some(ref typeshed_path) = custom_typeshed_path {
                 if let Ok(relative_path) = full_path.strip_prefix(typeshed_path.join("stdlib")) {
diff --git a/crates/red_knot_test/src/parser.rs b/crates/red_knot_test/src/parser.rs
index 048f09844..3e6271360 100644
--- a/crates/red_knot_test/src/parser.rs
+++ b/crates/red_knot_test/src/parser.rs
@@ -1,6 +1,7 @@
 use std::{borrow::Cow, collections::hash_map::Entry};
 
 use anyhow::bail;
+use ruff_db::system::{SystemPath, SystemPathBuf};
 use rustc_hash::FxHashMap;
 
 use ruff_index::{newtype_index, IndexVec};
@@ -232,12 +233,19 @@ impl EmbeddedFilePath<'_> {
     }
 
     fn is_allowed_explicit_path(path: &str) -> bool {
-        [
-            EmbeddedFilePath::AutogeneratedPy,
-            EmbeddedFilePath::AutogeneratedPyi,
-        ]
-        .iter()
-        .all(|autogenerated| path != autogenerated.as_str())
+        path != &EmbeddedFilePath::AutogeneratedPy && path != &EmbeddedFilePath::AutogeneratedPyi
+    }
+}
+
+impl PartialEq<str> for EmbeddedFilePath<'_> {
+    fn eq(&self, other: &str) -> bool {
+        self.as_str() == other
+    }
+}
+
+impl PartialEq<EmbeddedFilePath<'_>> for str {
+    fn eq(&self, other: &EmbeddedFilePath<'_>) -> bool {
+        self == other.as_str()
     }
 }
 
@@ -286,8 +294,13 @@ impl EmbeddedFile<'_> {
         }
     }
 
-    pub(crate) fn path_str(&self) -> &str {
-        self.path.as_str()
+    pub(crate) fn full_path(&self, project_root: &SystemPath) -> SystemPathBuf {
+        let path = self.path.as_str();
+        if path.starts_with('/') {
+            SystemPathBuf::from(path)
+        } else {
+            project_root.join(path)
+        }
     }
 
     pub(crate) fn code_block_dimensions(&self) -> impl Iterator<Item = CodeBlockDimensions> + '_ {
@@ -820,11 +833,11 @@ mod tests {
             panic!("expected two files");
         };
 
-        assert_eq!(file_1.path_str(), "mod_a.pyi");
+        assert_eq!(&file_1.path, "mod_a.pyi");
         assert_eq!(file_1.lang, "pyi");
         assert_eq!(file_1.code(), "a: int");
 
-        assert_eq!(file_2.path_str(), "mod_b.pyi");
+        assert_eq!(&file_2.path, "mod_b.pyi");
         assert_eq!(file_2.lang, "pyi");
         assert_eq!(file_2.code(), "b: str");
     }
@@ -867,11 +880,11 @@ mod tests {
             panic!("expected two files");
         };
 
-        assert_eq!(main.path_str(), "main.py");
+        assert_eq!(&main.path, "main.py");
         assert_eq!(main.lang, "py");
         assert_eq!(main.code(), "from foo import y");
 
-        assert_eq!(foo.path_str(), "foo.py");
+        assert_eq!(&foo.path, "foo.py");
         assert_eq!(foo.lang, "py");
         assert_eq!(foo.code(), "y = 2");
 
@@ -1044,7 +1057,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "foo.py");
+        assert_eq!(&file.path, "foo.py");
         assert_eq!(file.lang, "py");
         assert_eq!(file.code(), "x = 1");
     }
@@ -1164,7 +1177,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "lorem");
+        assert_eq!(&file.path, "lorem");
         assert_eq!(file.code(), "x = 1");
     }
 
@@ -1189,7 +1202,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "lorem.yaml");
+        assert_eq!(&file.path, "lorem.yaml");
         assert_eq!(file.code(), "x = 1");
     }
 
@@ -1405,7 +1418,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "foo.py");
+        assert_eq!(&file.path, "foo.py");
         assert_eq!(file.code(), "x = 1");
     }
 
@@ -1430,7 +1443,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "foo.py");
+        assert_eq!(&file.path, "foo.py");
         assert_eq!(file.code(), "x = 1");
     }
 
@@ -1454,7 +1467,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "foo.py");
+        assert_eq!(&file.path, "foo.py");
         assert_eq!(file.code(), "x = 1");
     }
 
@@ -1479,7 +1492,7 @@ mod tests {
             panic!("expected one file");
         };
 
-        assert_eq!(file.path_str(), "foo bar.py");
+        assert_eq!(&file.path, "foo bar.py");
         assert_eq!(file.code(), "x = 1");
     }
```

</details>

---

_Review comment by @AlexWaygood on `crates/red_knot_test/src/parser.rs`:154 on 2025-02-05 12:16_

Questions I'm wondering while reading through this diff for the first time:
1. I assume `CodeBlock` is meant to be an abstraction for a code block. In which case, why can't the dimensions of the code block be queried on a `CodeBlock` instance? I'm surprised there isn't a `dimensions: CodeBlockDimensions` field
2. Why is there a `backtick_offset` field on both `CodeBlock` and `CodeBlockDimensions`?

Some more docs on how these structs interrelate might be really helpful

---

_Review comment by @AlexWaygood on `crates/red_knot_test/src/parser.rs`:201 on 2025-02-05 12:16_

```suggestion
        dimensions: impl IntoIterator<Item = CodeBlockDimensions>,
    ) -> CodeBlockStructure {
        CodeBlockStructure {
            start_line_and_line_count: dimensions
                .into_iter()
                .map(|d| (md_index.line_index(d.backtick_offset).get(), d.line_count))
```

---

_@AlexWaygood reviewed on 2025-02-05 12:22_

Fantastic!

---

_@carljm approved on 2025-02-05 16:42_

I looked at the impact on the test suite and the README, and it looks fantastic to me, thank you!!

Didn't look at the code, since Alex and Micha already did, and it will likely change once conflicts with the diagnostic snapshotting PR are resolved anyway.

---

_Review comment by @sharkdp on `crates/red_knot_test/src/parser.rs`:217 on 2025-02-05 20:08_

This requires pulling in `ruff_python_ast` and handling the existence of `Ipynb`. I made the change in eaf4d41f64ab400b5058fe9b347f174e09476629. Not sure which version I prefer.

---

_@sharkdp reviewed on 2025-02-05 20:08_

---

_@sharkdp reviewed on 2025-02-05 20:09_

---

_Review comment by @sharkdp on `crates/red_knot_test/src/lib.rs`:117 on 2025-02-05 20:09_

> 1. Adding a `full_path()` method to `EmbeddedFile`

:+1: 

> 2\. Implementing `PartialEq<str>` for `EmbeddedFilePath`

I did not do that. After merging in the snapshot test changes, we now need to externally access the relative path as well. I renamed `path_str` to `relative_path`.

---

_@sharkdp reviewed on 2025-02-05 20:10_

---

_Review comment by @sharkdp on `crates/red_knot_test/src/parser.rs`:154 on 2025-02-05 20:10_

I removed all the overhead that was needed to make this work lazily. I hope the new structure is more clear.

---

_Comment by @github-actions[bot] on 2025-02-05 21:21_

<!-- generated-comment ecosystem -->
## `ruff-ecosystem` results
### Linter (stable)
✅ ecosystem check detected no linter changes.

### Linter (preview)
✅ ecosystem check detected no linter changes.

### Formatter (stable)
✅ ecosystem check detected no format changes.

### Formatter (preview)
✅ ecosystem check detected no format changes.




---

_Comment by @sharkdp on 2025-02-05 21:25_

The failure on Windows is unrelated, see https://github.com/astral-sh/ruff/pull/15981. The tests were previously passing on Windows, and I didn't change anything path-specific or similar :crossed_fingers: 

---

_Merged by @sharkdp on 2025-02-05 21:26_

---

_Closed by @sharkdp on 2025-02-05 21:26_

---

_Branch deleted on 2025-02-05 21:26_

---

_Review comment by @AlexWaygood on `crates/red_knot_test/README.md`:129 on 2025-02-05 21:52_

was this meant to be

```suggestion
## Literate style
```

?

---

_Review comment by @AlexWaygood on `crates/red_knot_test/README.md`:136 on 2025-02-05 21:52_

```suggestion
# My literate test
```

---

_Review comment by @AlexWaygood on `crates/red_knot_test/src/parser.rs`:285 on 2025-02-05 21:58_

nit

```suggestion
        let existing_code = self.code.to_mut();
        existing_code.push('\n');
        existing_code.push_str(new_code);
```

---

_@AlexWaygood reviewed on 2025-02-05 22:00_

Thank you! The final version is much easier to understand

---

_@sharkdp reviewed on 2025-02-05 22:12_

---

_Review comment by @sharkdp on `crates/red_knot_test/README.md`:129 on 2025-02-05 22:12_

Yes. Thanks. I'll fix that. Too much Python typing over the last months :-)

---
