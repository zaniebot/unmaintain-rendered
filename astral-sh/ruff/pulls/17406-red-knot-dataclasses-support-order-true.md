```yaml
number: 17406
title: "[red-knot] Dataclasses: support `order=True`"
type: pull_request
state: merged
author: sharkdp
labels:
  - ty
assignees: []
merged: true
base: main
head: david/dataclasses-pt2
created_at: 2025-04-15T09:50:59Z
updated_at: 2025-05-02T08:23:01Z
url: https://github.com/astral-sh/ruff/pull/17406
synced_at: 2026-01-10T18:57:02Z
```

# [red-knot] Dataclasses: support `order=True`

---

_Pull request opened by @sharkdp on 2025-04-15 09:50_

## Summary

Support dataclasses with `order=True`:

```py
@dataclass(order=True)
class WithOrder:
    x: int

WithOrder(1) < WithOrder(2)  # no error
```

Also adds some additional tests to `dataclasses.md`.

ticket: #16651

## Test Plan

New Markdown tests

---

_Label `red-knot` added by @sharkdp on 2025-04-15 09:50_

---

_Comment by @github-actions[bot] on 2025-04-15 09:53_

<!-- generated-comment mypy_primer -->
## `mypy_primer` results
No ecosystem changes detected âœ…


---

_Marked ready for review by @sharkdp on 2025-04-15 10:46_

---

_Review requested from @carljm by @sharkdp on 2025-04-15 10:46_

---

_Review requested from @AlexWaygood by @sharkdp on 2025-04-15 10:46_

---

_Review requested from @dcreager by @sharkdp on 2025-04-15 10:46_

---

_@sharkdp reviewed on 2025-04-15 10:50_

---

_Review comment by @sharkdp on `.github/workflows/mypy_primer.yaml`:71 on 2025-04-15 10:50_

I added a few projects with dataclass usage, some of which use `order=True`, but still no ecosystem changes. The usage of the order-methods is often hidden, e.g. by adding dataclass instances to a list which will then be sorted. We did not previously emit false positives in these cases (would rely on generics), so there are obviously no changes now.

---

_@sharkdp reviewed on 2025-04-15 13:53_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/class.rs`:850 on 2025-04-15 13:53_

@dcreager Here, I'm synthesizing a signature for autogenerated `__lt__` methods (and similar) for dataclasses. I think the `other` argument should have an annotated type of `Self`, such that instances of the dataclass can be compared with `other` instances, but not with completely unrelated types. Since we don't have `Self` yet, I tried to construct the `Type::Instance(â€¦)` type that corresponds to this `ClassLiteralType`. Would you mind taking a look at the `self.default_specialization(db)` call here to see if that looks correct?

---

_Review comment by @dcreager on `crates/red_knot_python_semantic/src/types/class.rs`:838 on 2025-04-15 13:56_

As an aside, we might consider an `impl From<Signature> for Symbol` since this pattern is starting to show up a lot

---

_Review comment by @dcreager on `crates/red_knot_python_semantic/src/types/class.rs`:850 on 2025-04-15 14:04_

I think where this might fail is when you're autogenerating `__lt__` for a generic alias (a specialized generic class) â€” you'd end up with the argument annotated with the default specialization applied, and not the specialization from the generic alias:

```py
@dataclass(order=True)
class A[T]:
    x: T

reveal_type(A[int].__lt__)  # might be: A[Any] â†’ bool 
```

`ClassLiteralType::class_member` has a `specialization` parameter, which `ClassType` uses to pass down the generic alias's specialization if there is one. That way we can apply it to the base classes in the MRO. I think the fix would be to pass that along to `ClassLiteralType::own_class_member`, and _that's_ the specialization that you would apply to `other`. (And you might want to add a new `Type::apply_optional_specialization` to make that a bit more ergonomic)

---

_@dcreager reviewed on 2025-04-15 14:05_

---

_@sharkdp reviewed on 2025-04-15 20:02_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/class.rs`:838 on 2025-04-15 20:02_

I'll note this down as a (follow up) to-do.

---

_@sharkdp reviewed on 2025-04-15 20:05_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/generics.rs`:119 on 2025-04-15 20:05_

We currently have a problem on main, where we do not consider two instances of `C[int]` to be the same: https://playknot.ruff.rs/ee8f9cb9-a73f-480a-bb2c-83b6e1bb5e89, since we were comparing Salsa IDs in `is_assignable_to`. Thank you @dcreager for helping me in tracking (heh) this down.

---

_@sharkdp reviewed on 2025-04-15 20:07_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/generics.rs`:28 on 2025-04-15 20:07_

Haven't investigated why this is necessary. Can look into getting rid of this, if we see the need.

---

_@sharkdp reviewed on 2025-04-15 20:08_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/resources/mdtest/dataclasses.md`:389 on 2025-04-15 20:08_

@AlexWaygood I already added a couple of non-`order`-related tests in this PR, so I added the test that you suggested as well.

---

_@sharkdp reviewed on 2025-04-15 20:10_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/class.rs`:844 on 2025-04-15 20:10_

This is only true for bound methods. We currently infer the wrong signature for explicit dunder calls, e.g. `MyDataclass.__lt__(left, right)`. This is a pre-existing problem with `__init__` as well. I will tackle this in a separate follow-up.

---

_@dcreager reviewed on 2025-04-15 20:14_

---

_Review comment by @dcreager on `crates/red_knot_python_semantic/src/types/generics.rs`:28 on 2025-04-15 20:14_

The auto-generated `new` constructor for an interned struct has `Borrow`-like traits for its parameters, since it's doing a hash table lookup.  Whereas `new` for a tracked struct takes in the field type directly.

---

_@sharkdp reviewed on 2025-04-15 20:22_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/slots.rs`:27 on 2025-04-15 20:22_

Not completely sure about the `None` here...

---

_@sharkdp reviewed on 2025-04-15 20:24_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/class.rs`:850 on 2025-04-15 20:24_

> I think where this might fail is when you're autogenerating __lt__ for a generic alias (a specialized generic class) â€” you'd end up with the argument annotated with the default specialization applied, and not the specialization from the generic alias:

Yes, that was exactly right. Fixed and added a test.

> And you might want to add a new `Type::apply_optional_specialization` to make that a bit more ergonomic

I wasn't sure what you were suggesting here. Which part could be made more ergonomic? The `Type::instance(self.apply_optional_specialization(db, specialization))` construction?

---

_@dcreager reviewed on 2025-04-15 20:27_

---

_Review comment by @dcreager on `crates/red_knot_python_semantic/src/types/slots.rs`:27 on 2025-04-15 20:27_

That's correct, since `base` is a class literal (so if it's a generic class, it's not specialized yet), so it can't possibly have a specialization to pass down

---

_@dcreager reviewed on 2025-04-15 20:30_

---

_Review comment by @dcreager on `crates/red_knot_python_semantic/src/types/class.rs`:850 on 2025-04-15 20:30_

> I wasn't sure what you were suggesting here. Which part could be made more ergonomic? The `Type::instance(self.apply_optional_specialization(db, specialization))` construction?

Nope, now that I see how you've done it, disregard this suggestion! Was thinking you would apply the specialization to the `Type` â€” but that doesn't work, since you need to apply the specialization first to get a `ClassType` that you can pass to `Type::instance`.

---

_Comment by @sharkdp on 2025-04-15 21:16_

I re-ran the job five times and it succeeded every single time. I also couldn't reproduce the panic locally.

![image](https://github.com/user-attachments/assets/bfcf5b5a-a838-48c3-9cbb-1a207f2df8cb)


---

_Review comment by @carljm on `.github/workflows/mypy_primer.yaml`:71 on 2025-04-16 23:46_

ðŸŽ‰ 

---

_Review comment by @carljm on `crates/red_knot_python_semantic/resources/mdtest/dataclasses.md`:108 on 2025-04-16 23:47_

Hmm, I wonder if our display for bound methods really should show both the class the method was fetched from, and the object to which its `self` is bound...

Although mypy and pyright both reveal less than we do; they just reveal this as simply `() -> str`

---

_@carljm approved on 2025-04-16 23:50_

Looks good!

---

_@sharkdp reviewed on 2025-04-17 06:58_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/resources/mdtest/dataclasses.md`:108 on 2025-04-17 06:58_

> Hmm, I wonder if our display for bound methods really should show both the class the method was fetched from, and the object to which its `self` is bound...

That sounds potentially useful. What are some cases where this would show two different types? I can imagine something like `SomeClass.some_function.__get__(OtherClass())` which should show `<bound method SomeFunction.some_function of OtherClass object>`. But there are probably more realistic scenarios where this would show up?

---

_Merged by @sharkdp on 2025-04-17 06:58_

---

_Closed by @sharkdp on 2025-04-17 06:58_

---

_Branch deleted on 2025-04-17 06:58_

---

_@carljm reviewed on 2025-04-17 13:00_

---

_Review comment by @carljm on `crates/red_knot_python_semantic/resources/mdtest/dataclasses.md`:108 on 2025-04-17 13:00_

The main case I was thinking of is simply inheritance without a method override, as in the case shown here. It's a bit confusing that even though `WithoutRepr` does not have its own `__repr__` and we are finding the `__repr__` from `object`, that we show `WithoutRepr.__repr__`, a syntax that implies a `__repr__` method defined on `WithoutRepr` class. I kind of want it to say `object.__repr__` instead, but then we would no longer be showing the type of the bound `self` object.

---

_@sharkdp reviewed on 2025-05-02 08:23_

---

_Review comment by @sharkdp on `crates/red_knot_python_semantic/src/types/class.rs`:838 on 2025-05-02 08:23_

This pattern has since vanished from our code base; removing the to-do.

---
