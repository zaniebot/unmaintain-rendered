```yaml
number: 5114
title: Maintain consistency when deserializing to JSON
type: pull_request
state: merged
author: dhruvmanila
labels: []
assignees: []
merged: true
base: main
head: dhruv/jupyter-json-consistency
created_at: 2023-06-15T07:13:54Z
updated_at: 2023-06-19T18:24:41Z
url: https://github.com/astral-sh/ruff/pull/5114
synced_at: 2026-01-12T15:55:17Z
```

# Maintain consistency when deserializing to JSON

---

_@dhruvmanila_

## Summary

Maintain consistency while deserializing Jupyter notebook to JSON. The following
changes were made:

1. Use string array to store the source value as that's the default (https://github.com/jupyter/nbformat/blob/57817204230a8f7173b8bec380e571b5d410de0d/nbformat/v4/nbjson.py#L56-L57)
2. Remove unused structs and enums
3. Reorder the keys in alphabetical order as that's the default. (https://github.com/jupyter/nbformat/blob/57817204230a8f7173b8bec380e571b5d410de0d/nbformat/v4/nbjson.py#L51)

### Side effect

Removing the `preserve_order` feature means that the order of keys in JSON output (`--format json`) will be in alphabetical order. This is because the value is represented using `serde_json::Value` which internally is a `BTreeMap`, thus sorting it as per the string key. For posterity if this turns out to be not ideal, then we could define a struct representing the JSON object and the order of struct fields will determine the order in the JSON string.

## Test Plan

Add a test case to assert the raw JSON string.

---
***Edit: Both have been fixed, keeping here for posterity***

### Still a few inconsistencies...

#### 1

`execution_count` is a required field _only_ in code cell while for others
it's not required. We use a single `Cell` struct and a `cell_type` field
instead of having structs for each cell type (`CodeCell`, `MarkdownCell`).
This means that the field `execution_count` will always be added to the JSON
string.

**What to do then?**

* We could either use a custom deserializer and check for the `cell_type`.
* Split the `Code` struct into 3 distinct types using enum:

```rust
enum CellType {
    RawCell(RawCell),
    MarkdownCell(MarkdownCell),
    CodeCell(CodeCell)
}

struct RawCell {
    ...
}

struct MarkdownCell {
    ...
}

struct CodeCell {
    ...
}
```

#### 2

For some fields, the `additionalProperties` is `true` which means there could be
unknown properties added which we've to keep while deserializing. We do this
using:

```rust
pub struct RawNotebookMetadata {
    // ... other fields

    #[serde(flatten)]
    pub other: BTreeMap<String, Value>
}
```

But, now the order won't be alphabetical. Wherever the `other` field is present,
all of the keys in it will be flattened at that position.

In the following example, the `nbconvert_exporter` and `version` keys are extra.
Now, as the `other` field in our struct is at the end, both the extra keys have
been moved to the end.

```diff
    "language_info": {
     "codemirror_mode": {
      "name": "ipython",
      "version": 3
     },
    "file_extension": ".py",
    "mimetype": "text/x-python",
    "name": "python",
-   "nbconvert_exporter": "python",
    "pygments_lexer": "ipython3",
+   "nbconvert_exporter": "python",
    "version": "3.11.3"
   }
```


---

_Comment by @dhruvmanila on 2023-06-15 07:14_

Current dependencies on/for this PR:
* main
  * **PR #5114** <a href="https://app.graphite.dev/github/pr/astral-sh/ruff/5114" target="_blank"><img src="https://static.graphite.dev/graphite-32x32.png" alt="Graphite" width="10px" height="10px"/></a>  ðŸ‘ˆ

This comment was auto-generated by [Graphite](https://app.graphite.dev/github/pr/astral-sh/ruff/5114?utm_source=stack-comment).

---

_Comment by @dhruvmanila on 2023-06-15 07:36_

Actually, we should resolve (1) as otherwise the validation fails:
```
NotebookValidationError: Additional properties are not allowed ('execution_count' was unexpected)

Failed validating 'additionalProperties' in markdown_cell:

On instance['cells'][0]:
{'cell_type': 'markdown',
 'execution_count': None,
 'id': 'f3c286e9-fa52-4440-816f-4449232f199a',
 'metadata': {},
 'source': '# Ruff Test'}
```

---

_Comment by @github-actions[bot] on 2023-06-15 07:42_

## PR Check Results
### Ecosystem
âœ… ecosystem check detected no changes.

### Benchmark
#### Linux
```
group                                      main                                   pr
-----                                      ----                                   --
formatter/large/dataset.py                 1.00      7.5Â±0.02ms     5.4 MB/sec    1.01      7.6Â±0.02ms     5.4 MB/sec
formatter/numpy/ctypeslib.py               1.00   1572.2Â±5.75Âµs    10.6 MB/sec    1.01   1583.7Â±9.09Âµs    10.5 MB/sec
formatter/numpy/globals.py                 1.00    152.3Â±0.53Âµs    19.4 MB/sec    1.00    152.5Â±1.02Âµs    19.4 MB/sec
formatter/pydantic/types.py                1.00      3.1Â±0.01ms     8.3 MB/sec    1.01      3.1Â±0.01ms     8.2 MB/sec
linter/all-rules/large/dataset.py          1.01     16.2Â±0.10ms     2.5 MB/sec    1.00     16.0Â±0.08ms     2.5 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      3.9Â±0.01ms     4.3 MB/sec    1.00      3.9Â±0.01ms     4.2 MB/sec
linter/all-rules/numpy/globals.py          1.00    493.3Â±0.97Âµs     6.0 MB/sec    1.02    502.7Â±7.38Âµs     5.9 MB/sec
linter/all-rules/pydantic/types.py         1.01      6.9Â±0.11ms     3.7 MB/sec    1.00      6.9Â±0.02ms     3.7 MB/sec
linter/default-rules/large/dataset.py      1.00      8.0Â±0.02ms     5.1 MB/sec    1.00      8.0Â±0.02ms     5.1 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00   1719.8Â±7.63Âµs     9.7 MB/sec    1.00   1726.1Â±7.83Âµs     9.6 MB/sec
linter/default-rules/numpy/globals.py      1.00    189.8Â±0.37Âµs    15.5 MB/sec    1.01    191.3Â±0.95Âµs    15.4 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.6Â±0.01ms     7.1 MB/sec    1.00      3.6Â±0.01ms     7.0 MB/sec
```

#### Windows
```
group                                      main                                    pr
-----                                      ----                                    --
formatter/large/dataset.py                 1.00      7.8Â±0.31ms     5.2 MB/sec     1.08      8.4Â±0.40ms     4.8 MB/sec
formatter/numpy/ctypeslib.py               1.00  1589.7Â±111.20Âµs    10.5 MB/sec    1.05  1676.2Â±81.96Âµs     9.9 MB/sec
formatter/numpy/globals.py                 1.00   153.7Â±11.20Âµs    19.2 MB/sec     1.02   156.1Â±11.42Âµs    18.9 MB/sec
formatter/pydantic/types.py                1.00      3.2Â±0.16ms     8.0 MB/sec     1.08      3.4Â±0.20ms     7.4 MB/sec
linter/all-rules/large/dataset.py          1.00     15.9Â±0.49ms     2.6 MB/sec     1.03     16.4Â±0.50ms     2.5 MB/sec
linter/all-rules/numpy/ctypeslib.py        1.00      4.2Â±0.17ms     4.0 MB/sec     1.00      4.2Â±0.16ms     4.0 MB/sec
linter/all-rules/numpy/globals.py          1.00   506.5Â±32.20Âµs     5.8 MB/sec     1.00   505.1Â±30.05Âµs     5.8 MB/sec
linter/all-rules/pydantic/types.py         1.00      7.1Â±0.34ms     3.6 MB/sec     1.02      7.2Â±0.32ms     3.5 MB/sec
linter/default-rules/large/dataset.py      1.00      8.3Â±0.21ms     4.9 MB/sec     1.01      8.3Â±0.26ms     4.9 MB/sec
linter/default-rules/numpy/ctypeslib.py    1.00  1767.2Â±81.47Âµs     9.4 MB/sec     1.00  1762.8Â±77.52Âµs     9.4 MB/sec
linter/default-rules/numpy/globals.py      1.00   198.9Â±11.73Âµs    14.8 MB/sec     1.00   198.2Â±12.87Âµs    14.9 MB/sec
linter/default-rules/pydantic/types.py     1.00      3.7Â±0.15ms     6.8 MB/sec     1.01      3.7Â±0.19ms     6.8 MB/sec
```
<!-- thollander/actions-comment-pull-request "PR Check Results" -->

---

_Review comment by @dhruvmanila on `crates/ruff/src/jupyter/schema.rs`:60 on 2023-06-15 07:42_

If we remove this, then we would get the following validation error:
```
NotebookValidationError: 'execution_count' is a required property

Failed validating 'required' in code_cell:

On instance['cells'][3]:
{'cell_type': 'code',
 'id': '6bced3f8-e0a4-450c-ae7c-f60ad5671ee9',
 'metadata': {},
 'outputs': ['...0 outputs...'],
 'source': 'with contextlib.suppress(ValueError):\n    print()\n'}
```

---

_@dhruvmanila reviewed on 2023-06-15 07:42_

---

_Comment by @konstin on 2023-06-15 07:58_

Re 1: My intution goes towards using an enum and `#[serde(flatten)]`, but both should do. Maybe you can put only the cell type and `execution_count` on each variant and tell serde to decide by cell type from a container attribute.

Re 2: That's a tricky problem! Maybe https://stackoverflow.com/a/67792465/3549270 would work?



---

_Comment by @konstin on 2023-06-15 11:00_

I tried the following:
* Download the jupyter notebook from https://github.com/sokrypton/ColabFold/blob/affc6e0e89ee723795ab009f51f2600d843dafb0/AlphaFold2.ipynb as AlphaFold2.ipynb
* Open it with `jupyter notebook`, save as AlphaFold2-jupyter.ipynb. This reformats the entire file because apparently jupyter has different formatting settings than google colab where the notebook was created on (so that's a case we also don't have to handle)
* `cp AlphaFold2-jupyter.ipynb AlphaFold2-jupyter-fixed.ipynb`
* `cargo run --bin ruff --features jupyter_notebook -- check --select F841 --no-cache --fix AlphaFold2-jupyter-fixed.ipynb`
* `diff AlphaFold2-jupyter.ipynb AlphaFold2-jupyter-fixed.ipynb`, which are https://gist.github.com/konstin/98e41d667a42c978bdfcb4dcea2373d6 and https://gist.github.com/konstin/a3c4950eae3634ee9417d671beb9212b
4a5
```diff
>    "execution_count": null,
14a16
>    "execution_count": null,
112c114,115
<     "\n"
---
>     "\n",
>     ""
395d397
<     "  model_name = f\"rank_{rank_num}\"\n",
476c478,479
<     "\"\"\"))\n"
---
>     "\"\"\"))\n",
>     ""
504a508
>    "execution_count": null,
610,617d613
<   "accelerator": "GPU",
<   "colab": {
<    "gpuType": "T4",
<    "include_colab_link": true,
<    "machine_shape": "hm",
<    "name": "AlphaFold2.ipynb",
<    "provenance": []
<   },
631d626
<    "nbconvert_exporter": "python",
632a628
>    "nbconvert_exporter": "python",
633a630,637
>   },
>   "accelerator": "GPU",
>   "colab": {
>    "gpuType": "T4",
>    "include_colab_link": true,
>    "machine_shape": "hm",
>    "name": "AlphaFold2.ipynb",
>    "provenance": []
```
This means the edition works correctly (nice!), we add an extra `""` at the end of list where jupyter doesn't, the `execution_count` field you mentioned and `metadata` fields get reordered. 

---

_Comment by @dhruvmanila on 2023-06-15 11:34_

> Re 2: That's a tricky problem! Maybe [stackoverflow.com/a/67792465/3549270](https://stackoverflow.com/a/67792465/3549270) would work?

I tried this, it didn't work. It just keeps the same order as defined in the struct which is the default behavior.

>  we add an extra "" at the end of list where jupyter doesn't,

Nice! Let me take a look at this.

---

_Comment by @dhruvmanila on 2023-06-15 12:46_

@konstin Do you mean something like this? (I'm not sure how to use `#[serde(flatten)]` here)

```rust
#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(tag = "cell_type")]
pub enum Cell {
    #[serde(rename = "code")]
    Code(CodeCell),
    #[serde(rename = "markdown")]
    Markdown(MarkdownCell),
    #[serde(rename = "raw")]
    Raw(RawCell),
}

#[skip_serializing_none]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct RawCell {
    pub attachments: Option<Value>,
    pub id: Option<String>,
    pub metadata: Value,
    pub source: SourceValue,
}

/// Notebook markdown cell.
#[skip_serializing_none]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct MarkdownCell {
    pub attachments: Option<Value>,
    pub id: Option<String>,
    pub metadata: Value,
    pub source: SourceValue,
}

/// Notebook code cell.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct CodeCell {
    pub execution_count: Option<i64>,
    pub id: Option<String>,
    pub metadata: Value,
    pub outputs: Vec<Value>,
    pub source: SourceValue,
}
```

---

_Review requested from @konstin by @charliermarsh on 2023-06-15 18:48_

---

_Comment by @konstin on 2023-06-15 20:55_

Like this (untested, but i've used flatten in other projects)
```rust
use serde::{Serialize, Deserialize};

#[derive(Debug, Serialize, Deserialize, Clone, PartialEq)]
#[serde(tag = "cell_type")]
pub enum Cell {
    #[serde(rename = "code")]
    Code {
        #[serde(flatten)]
        pub cell: CellInner,
        pub execution_count: Option<i64>,
    },
    #[serde(rename = "markdown")]
    Markdown {
        #[serde(flatten)]
        pub cell: CellInner,
    },
    #[serde(rename = "raw")]
    Raw {
        #[serde(flatten)]
        pub cell: CellInner,
    },
}

#[skip_serializing_none]
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub struct CellInner {
    pub attachments: Option<Value>,
    pub id: Option<String>,
    pub metadata: Value,
    pub source: SourceValue,
}
```

---

_Comment by @konstin on 2023-06-15 21:02_

Could you add a notebook saved from the web interface of `jupyter notebook` and the same notebook after running it through `ruff --fix`, and then a test that checks that the string output of `ruff --fix` matches the saved fixed notebook? This way we can both see how the differences look in the repo and have a way to ensure that we don't accidentally change the json output. I'd compare the raw text and not the parsed json because that is what people will see in their git diffs.

---

_Comment by @dhruvmanila on 2023-06-17 11:46_

I would argue to go with my implementation because:

* Using flatten will give us the same problem as mentioned in (2). The order of the fields will probably not be alphabetical.
	
	```jsonc
    {
      "cell_type": "code",  // coming from the tag
      // inner
      "id": "5e3ef98e-224c-450a-80e6-be442ad50907",
      "metadata": {
        "tags": []
      },
      "outputs": [],
      "source": [
        "import contextlib\n",
        "import random"
      ],
      // cell type specific fields
      "execution_count": 1
    }
	```
* There are other keys which has the same problem as `execution_count`
  * `outputs` is required only in code cells and not others
  * `attachments` is required only in raw and markdown cells and not the code cell

---

_Comment by @dhruvmanila on 2023-06-17 12:03_

Oh, I found the reason why the sorting wasn't working earlier. We've declared `serde_json` with `preserve_order` feature which will preserve the insertion order and that's why the sorting was not done alphabetically.

@konstin It seems like the feature was added during the initial PR to support Jupyter notebook (https://github.com/astral-sh/ruff/pull/3440/files#diff-2e9d962a08321605940b5a657135052fbcef87b5e360662bb527c96d9a615542). Any reason why this was added and can we remove it?

---

_Comment by @konstin on 2023-06-18 10:41_

> Using flatten will give us the same problem as mentioned in (2). The order of the fields will probably not be alphabetical.

That's a pity, yours is clearly the better solution then

> It seems like the feature was added during the initial PR to support Jupyter notebook (https://github.com/astral-sh/ruff/pull/3440/files#diff-2e9d962a08321605940b5a657135052fbcef87b5e360662bb527c96d9a615542). Any reason why this was added and can we remove it?

none beyond "feels useful", feel free to remove it

---

_Comment by @dhruvmanila on 2023-06-19 08:10_

## Update

* Update `Cell` schema to use tags to have independent structure for each cell type. This is to accommodate fields specific to the cell type.
* Sort the notebook fields in alphabetical order manually to allow any field order in the struct definition.
* Add a test case to assert JSON consistency (raw JSON, not parsed)
* Update output snapshots as the `preserve_order` feature got removed from `serde_json` dependency. The fields just got reordered.

### That trailing newline...

Well, the JSON string might contain a trailing newline which is handled by black: https://github.com/psf/black/blob/01b8d3d4095ebdb91d0d39012a517931625c63cb/src/black/__init__.py#L1024. Currently, we don't write the JSON string with a trailing newline. This needs to be handled.

---

_Review request for @konstin removed by @dhruvmanila on 2023-06-19 08:11_

---

_Review requested from @konstin by @dhruvmanila on 2023-06-19 08:11_

---

_Comment by @dhruvmanila on 2023-06-19 08:16_

@konstin I believe the integration test for Jupyter notebook here can be removed?

https://github.com/astral-sh/ruff/blob/4079f982f5634816808fd88c530ae848e5695f80/crates/ruff_cli/src/commands/run.rs#L190-L278

---

_Comment by @konstin on 2023-06-19 11:31_

> I believe the integration test for Jupyter notebook here can be removed?

yep feel free to remove it

---

_Review comment by @konstin on `crates/ruff/src/jupyter/schema.rs`:80 on 2023-06-19 11:37_

Could you add a comment why we need this indirection, i.e. why `sort_alphabetically` gives a sorted result where default serialization doesn't?

---

_@konstin approved on 2023-06-19 11:38_

The test looks good!

---

_Merged by @dhruvmanila on 2023-06-19 18:17_

---

_Closed by @dhruvmanila on 2023-06-19 18:17_

---

_Branch deleted on 2023-06-19 18:17_

---
