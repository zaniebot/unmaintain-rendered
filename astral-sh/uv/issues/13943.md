```yaml
number: 13943
title: Mutually exclusive sources (path dependency vs. custom registry) are not properly resolved
type: issue
state: open
author: jonded94
labels:
  - bug
assignees: []
created_at: 2025-06-10T11:22:18Z
updated_at: 2025-06-20T13:43:07Z
url: https://github.com/astral-sh/uv/issues/13943
synced_at: 2026-01-10T01:57:31Z
```

# Mutually exclusive sources (path dependency vs. custom registry) are not properly resolved

---

_Issue opened by @jonded94 on 2025-06-10 11:22_

### Summary

Hey!

Potentially this is a PEBCAC or I misunderstood that this can work in general. I basically want to replicate [this](https://github.com/idantene/poet-exclusive-groups-plugin?tab=readme-ov-file#examples) behaviour with `uv`, and I would have thought that `uv` supports this in general. 

TL;DR: Especially in a monorepo context, it can be nice to consume a package either directly through a path dependency (good for local development), while in more "prod" use cases, you potentially want to get it from git or a registry.

### My try to replicate the "poet plugin behaviour"

This is the `pyproject.toml` I came up with:
```
[project]
name = "uv-testproj"
version = "0.1.0"
description = "..."
requires-python = ">=3.13"
dependencies = []

[project.optional-dependencies]
prod = ["disco-kubernetes"]
dev = ["disco-kubernetes"]

[tool.uv]
conflicts = [
    [
      { extra = "prod" },
      { extra = "dev" },
    ],
]

[tool.uv.sources]
disco-kubernetes = [
    { index = "gitlab-proxy", marker = "extra == 'prod' and extra != 'dev'" },
    { path = "../disco-kubernetes", marker = "extra == 'dev' and extra != 'prod'" },
]

[[tool.uv.index]]
name = "gitlab-proxy"
url = "[private URL which contains a `disco-kubernetes` version]"
explicit = true
```

The `uv.lock` is almost empty:
```
version = 1
revision = 2
requires-python = ">=3.13"
conflicts = [[
    { package = "uv-testproj", extra = "dev" },
    { package = "uv-testproj", extra = "prod" },
]]

[[package]]
name = "uv-testproj"
version = "0.1.0"
source = { virtual = "." }

[package.metadata]
requires-dist = [
    { name = "disco-kubernetes", marker = "extra != 'dev' and extra == 'prod'", index = "[private URL]" },
    { name = "disco-kubernetes", marker = "extra == 'dev' and extra == 'prod'" },
    { name = "disco-kubernetes", marker = "extra == 'dev' and extra != 'prod'", directory = "../disco-kubernetes" },
]
provides-extras = ["prod", "dev"]
```

On `uv sync --extra [dev/prod]` nothing appears to be done:
```
$ uv sync --extra prod && uv run python -c "import disco.kubernetes"
Resolved 1 package in 1ms
Audited in 0.01ms
Traceback (most recent call last):
  File "<string>", line 1, in <module>
    import disco.kubernetes
ModuleNotFoundError: No module named 'disco'
```

### Sanity check to test whether using just a single extra works

To be clear, when I leave out the `dev` group entirely, everything works as expected:
`pyproject.toml`
```
[project]
name = "uv-testproj"
version = "0.1.0"
description = "..."
requires-python = ">=3.13"
dependencies = []

[project.optional-dependencies]
prod = ["disco-kubernetes"]

[tool.uv.sources]
disco-kubernetes = [
    { index = "gitlab-proxy", marker = "extra == 'prod'" },
]

[[tool.uv.index]]
name = "gitlab-proxy"
url = "[private URL]"
explicit = true
```
`uv sync`
```
$ uv sync --extra prod && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__path__)"
Resolved 25 packages in 0.45ms
Audited 24 packages in 0.01ms
['.../uv-testproj/.venv/lib/python3.13/site-packages/disco/kubernetes']
```

(Same btw., with `dev` and the path dependency)

### Platform

Linux x86_64

### Version

0.7.12

### Python version

Python 3.13

---

_Label `bug` added by @jonded94 on 2025-06-10 11:22_

---

_Comment by @charliermarsh on 2025-06-10 11:43_

You can't use extras in the `marker` like that on `tool.uv.sources` -- those are evaluated globally without providing enabled extras. Instead, set `extra = "dev"` and `extra = "prod"` on the `tool.uv.sources`.

---

_Comment by @jonded94 on 2025-06-10 13:29_

Oh! Thanks a lot, sorry, this was (as expected) just a bit of PEBCAC.

Note: I had to add the `--reinstall-package disco-kubernetes` flag in the `uv sync` commands, otherwise `uv` didn't seem to reinstall the package properly for me as soon as they are already installed with the respective other method.

---

_Closed by @jonded94 on 2025-06-10 13:29_

---

_Comment by @jonded94 on 2025-06-11 14:23_

After making this work with `extras` (but it still requires the `--reinstall-package` flag inbetween changing extras, otherwise it will actually not correctly install the "prod" version on changing extras), I think it doesn't work with _dependency groups_, unless I'm doing something wrong here.

I created a `dev` and `prod` dependency group reflecting basically the same idea:

```
[project]
name = "uv-testproj"
version = "0.1.0"
description = "..."
requires-python = ">=3.13"
dependencies = []

[dependency-groups]
prod = ["disco-kubernetes==0.6.7"]
dev = ["disco-kubernetes"]

[tool.uv]
conflicts = [
    [
      { group = "prod" },
      { group = "dev" },
    ],
]

[tool.uv.sources]
disco-kubernetes = [
    { path = "../disco-kubernetes", editable = true, group = "dev" },
    { index = "gitlab-proxy", group = "prod" },
]

[[tool.uv.index]]
name = "gitlab-proxy"
url = "[registry URL]"
explicit = true
```

Snippets from the `uv.lock` file:
```
[...]
[[package]]
name = "disco-kubernetes"
source = { editable = "../disco-kubernetes" }
[...]
[[package]]
name = "disco-kubernetes"
version = "0.6.7"
source = { registry = "[registry URL]" }
sdist = { url = "[...]/disco_kubernetes-0.6.7.tar.gz", hash = "sha256:6e84a807d6e6284e6d24916f905c6fea84b570e4427ddd37ae369b2c6807e393" }
wheels = [
    { url = "[..]/disco_kubernetes-0.6.7-py3-none-any.whl", hash = "sha256:fbbcb527e71fa98e77ed139f320ac371a5109186d1f5a9b4289c4caf82a2c002" },
]

[...]
[[package]]
name = "uv-testproj"
version = "0.1.0"
source = { virtual = "." }

[package.dev-dependencies]
dev = [
    { name = "disco-kubernetes", source = { editable = "../disco-kubernetes" } },
]
prod = [
    { name = "disco-kubernetes", version = "0.6.7", source = { registry = "[registry URL]" } },
]
```

When installing the `prod` group (and explicitly disabling `dev`), it *still* definitely installs the path-dependency version.

```
$ uv sync --no-cache --no-dev --group prod --reinstall-package disco-kubernetes && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__version__)"
Resolved 26 packages in 0.74ms
Prepared 1 package in 435ms
Uninstalled 1 package in 0.86ms
░░░░░░░░░░░░░░░░░░░░ [0/1] Installing wheels...                                                                                                                                                                                     warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.
         If the cache and target directories are on different filesystems, hardlinking may not be supported.
         If this is intentional, set `export UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.
Installed 1 package in 18ms
 - disco-kubernetes==0.6.7 (from file:///[...]/workspace/disco-kubernetes)
 + disco-kubernetes==0.6.7
Uninstalled 1 package in 1ms
Installed 1 package in 11ms
LOCAL  # <-- I hacked this in my local version to display "LOCAL" (while it should display 0.6.7 for the remote wheel version)
```

```
$ cat .venv/lib/python3.13/site-packages/disco_kubernetes-0.6.7.dist-info/direct_url.json
{"url":"file:///[..]/disco-kubernetes","dir_info":{"editable":true}}
```

---

_Reopened by @jonded94 on 2025-06-11 14:23_

---

_Comment by @jonded94 on 2025-06-20 13:43_

When using dependency groups other than `dev`, it seems to work (`prod` points to an upstream package registry, `foo` points to a local path):

```
[dependency-groups]
prod = ["disco-kubernetes==0.6.7"]
foo = ["disco-kubernetes"]

[tool.uv]
conflicts = [
    [
      { group = "prod" },
      { group = "foo" },
    ],
]

[tool.uv.sources]
disco-kubernetes = [
    { path = "../disco-kubernetes", editable = true, group = "foo" },
    { index = "gitlab-proxy", group = "foo" },
]
```

```
$ uv sync --no-cache --group foo --reinstall-package disco-kubernetes && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__version__)"
Resolved 31 packages in 0.73ms
      Built disco-kubernetes @ file:///[...]/disco-kubernetes
Prepared 1 package in 938ms
Uninstalled 1 package in 0.95ms
░░░░░░░░░░░░░░░░░░░░ [0/1] Installing wheels...
Installed 1 package in 0.33ms
 - disco-kubernetes==0.6.7
 + disco-kubernetes==0.6.7 (from file:///[...]/disco-kubernetes)
LOCAL
$ uv sync --no-cache --group prod --reinstall-package disco-kubernetes && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__version__)"
Resolved 31 packages in 0.82ms
Prepared 1 package in 192ms
Uninstalled 1 package in 0.79ms
░░░░░░░░░░░░░░░░░░░░ [0/1] Installing wheels...
Installed 1 package in 23ms
 - disco-kubernetes==0.6.7 (from file:///[...]/disco-kubernetes)
 + disco-kubernetes==0.6.7
0.6.7
```

Note though, that it *still* doesn't work without the `--reinstall-package disco-kubernetes` flag, atleast a full roundtip doesn't work:

```
# Installing `prod` version first works, the package registry version is installed
$ uv sync --no-cache --group prod && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__version__)"
Resolved 31 packages in 0.93ms
Audited 28 packages in 0.00ms
0.6.7
# Installing `foo` version works too, now the local version is installed
$ uv sync --no-cache --group foo && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__version__)"
Resolved 31 packages in 0.78ms
      Built disco-kubernetes @ file:///[...]/disco-kubernetes
Prepared 1 package in 970ms
Uninstalled 1 package in 1ms
░░░░░░░░░░░░░░░░░░░░ [0/1] Installing wheels...
Installed 1 package in 0.41ms
 - disco-kubernetes==0.6.7
 + disco-kubernetes==0.6.7 (from file:///[...]/disco-kubernetes)
LOCAL
# Installing `prod` again doesn't work, the package isn't properly reinstalled from the upstream package registry again, but it still points to the local package
$ uv sync --no-cache --group prod && uv run python -c "import disco.kubernetes; print(disco.kubernetes.__version__)"
Resolved 31 packages in 0.92ms
Audited 28 packages in 0.01ms
LOCAL
```

@charliermarsh 

Is it expected that:
- Mutually exclusive package sources through dependency groups doesn't work when one of the groups is `dev`?
- Switching between *both* dependency groups as well as extras requires an extra `--reinstall-packages [pkgname]` for each package that is part of the mutually exclusive group or extra?

If yes, is there anything I can potentially provide for easier debugging? Maybe some Dockerfile that checks out a very simple upstream package that you could try out locally?

---
