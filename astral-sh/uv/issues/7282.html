<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Make metadata caching of local projects opt-in when it is dynamic? - astral-sh/uv #7282</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Make metadata caching of local projects opt-in when it is dynamic?</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/uv/issues/7282">#7282</a>
        opened by <a href="https://github.com/sbidoul">@sbidoul</a>
        on 2024-09-11 06:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-09-11 06:15</div>
            <div class="timeline-body"><p>I regularly hit caching gotchas with projects using dynamic dependencies.</p>
<p>The last one, I think, was  <code>uv lock</code> not detecting changes even though <code>tool.uv.resinstall-package</code> was set. I had to use <code>uv lock --refresh-package</code>, and I could not set <code>tool.uv.refresh-package</code>.</p>
<p>These surprises drive my ask for e.g. https://github.com/astral-sh/uv/pull/7268
But even with that we'll still need to think about setting cache-keys in the first place.</p>
<p>I was wondering if it would make sense to cache less aggressively if any metadata is dynamic (either because the project table is absent, or <code>project.dynamic</code> is set)? Or not cache at all in ~such cases~ presence of dynamic metadata, unless cache-keys is set?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Make metadata caching opt-in when version or dependencies are dynamic?" to "Make metadata caching opt-in when metadata is dynamic?" by @sbidoul on 2024-09-11 08:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Make metadata caching opt-in when metadata is dynamic?" to "Make metadata caching opt-in when it is dynamic?" by @sbidoul on 2024-09-11 08:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Make metadata caching opt-in when it is dynamic?" to "Make metadata caching of local projects opt-in when it is dynamic?" by @sbidoul on 2024-09-11 08:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-09-11 13:23</div>
            <div class="timeline-body"><p>The breaking point for me on this was <code>uv run</code>, which becomes very hard to use with dynamic projects if we're rebuilding and reinstalling them (typically needlessly) on every command. I don't want to have different caching semantics for <code>uv run</code> vs. other commands, so I decided to shift the burden towards requiring users to explicitly mark packages that they want to &quot;always rebuild, no matter what&quot;.</p>
<p>An alternative is that we could consider adding a dedicated setting to the <code>pyproject.toml</code> like <code>tool.uv.dynamic</code> to opt a given package into this behavior (rather than having to add <code>reinstall-package</code> somewhere else).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-09-11 14:09</div>
            <div class="timeline-body"><p>Or could <code>uv run</code> warn that 'the project is being rebuilt because there is dynamic metadata, consider setting cache-keys`?</p>
<p>So it would be correct by default, with an opt-in mechanism for caching.</p>
<p>Most people, who don't use dynamic metadata, would never see the warning.
And for people using dynamic metadata that would be a friendly hint to configure their project for correct caching.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-09-11 14:22</div>
            <div class="timeline-body"><blockquote>
<p><code>tool.uv.dynamic</code></p>
</blockquote>
<p>UX-wise is it not a bit strange, since there is already <code>project.dynamic</code> ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-09-11 14:37</div>
            <div class="timeline-body"><p>And by the way, sorry to appear insistent on this. The thing is that I'm a heavy user of dynamic metadata, but not a packaging newbie, and since I regularly fall in the traps, I suspect there is some UX issue that might be important.</p>
<p>I may not have said it yet, but I hugely appreciate the fantastic work you are doing!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-09-11 15:42</div>
            <div class="timeline-body"><p>Yeah, the answer here may indeed be to have different semantics for <code>uv run</code> vs. other commands. I'm worried that it would be confusing for users, but perhaps it's more confusing as-is. (Thank you for the kind words and no worries at all. I'm not happy with the state of dynamic metadata in uv either :))</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-design</span> added by @charliermarsh on 2024-09-12 01:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @charliermarsh on 2024-09-12 01:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2844.html">astral-sh/uv#2844</a> on 2024-09-13 12:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-10-16 18:18</div>
            <div class="timeline-body"><p>As the author of #2844 which is pulled into here - I'm just frankly surprised that <code>uv run</code> has so many side effects such that it would be a blocker for decisions here. My focus is on <code>uv sync</code> and it's &quot;obvious&quot; to me that <code>uv sync</code> should reinstall packages that are installed in editable mode every single time <code>uv sync</code> is executed. That's what editable means, and how <code>pip install -e</code> has worked forever. I'm completely fine with <code>uv run</code> having different semantics here because it's simply not a command that should guarantee that everything is perfectly up to date in my mind. It's cool if it can provide some sanity checks or basic things, but <code>uv sync</code> is the &quot;one true thing that should get the env in the right state&quot; and that means that it should reinstall editable packages.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-10-16 18:21</div>
            <div class="timeline-body"><p>To extend on that previous point a little bit with some anecdotes... the current recommended solution is for me to define <code>tool.uv.cache-keys</code> on each project, and in my case that means basically a cache-key of <code>**/*</code> which is going to run into performance problems eventually for <code>uv run</code> as well so we're kind of back where we started where <code>uv run</code> is just dictating too much of the contract here imo.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-10-16 18:21</div>
            <div class="timeline-body"><p>Is it that you want <em>all</em> editables to be reinstalled every time? Or editables with dynamic metadata?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-10-16 18:22</div>
            <div class="timeline-body"><p>But in that case, why not just use <code>reinstall-package</code> for each of those packages?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-10-16 18:25</div>
            <div class="timeline-body"><p>All editable packages imo. Python doesn't offer a separation for this aspect of the problem to claim it's just metadata. The issue here is with MANIFEST.in that is compiled down at build-time into the list of assets to copy into the project, and that only is matched AFTER the build happens and all the files are generated such that MANIFEST.in can match on them.</p>
<p>In my concrete example we have a <code>webassets</code> folder living externally to the python package. We have a custom setuptools hook that will compile the assets and put them into the python package in the right location. Then we have a MANIFEST.in that says to pull those assets in as package-data. And our devs need that to happen every time they run <code>uv sync</code> after a git pull or changing the files themselves locally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-10-16 18:28</div>
            <div class="timeline-body"><p>I can do it with cache-keys to be clear but it's globbing a lot of files that 1) I have to tediously maintain and 2) could cause performance problems for things like <code>uv run</code> as those globs get too large. I'd rather a default where I didn't need cache-keys, and <code>uv run</code> did what it does today (where it can be slightly out of sync because I didn't define cache-keys) but uv sync reinstalled editable packages and always left me in a good spot.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-10-16 19:38</div>
            <div class="timeline-body"><p>I confirmed that <code>tool.uv.cache-keys</code> does work as we thought it would. It does have the downsides I mentioned above and does require each project to define how it should work with uv or the wrong thing happens. My desired behavior would be a different default. Basically if you don't define <code>tool.uv.cache-keys</code> on a project and it's editable then <code>uv sync</code> should reinstall it. If you do define <code>cache-keys</code> then that is a fast-path for uv to use.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/12038.html">astral-sh/uv#12038</a> on 2025-03-07 10:52</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:00 UTC
    </footer>
</body>
</html>
