```yaml
number: 6781
title: "Add the option to `uv add` to pin to latest version of package"
type: issue
state: closed
author: SamEdwardes
labels:
  - question
assignees: []
created_at: 2024-08-28T22:39:56Z
updated_at: 2025-10-08T11:12:38Z
url: https://github.com/astral-sh/uv/issues/6781
synced_at: 2026-01-10T01:57:15Z
```

# Add the option to `uv add` to pin to latest version of package

---

_Issue opened by @SamEdwardes on 2024-08-28 22:39_

## Current behaviour

When you run `uv add` without specifying a version constraint, it defaults to `>=` latest version. I think this is a good default.

```bash
uv init --app --python 3.12.5
uv add black

cat pyproject.toml
# [project]
# name = "example-2"
# version = "0.1.0"
# description = "Add your description here"
# readme = "README.md"
# requires-python = ">=3.12.4"
# dependencies = [
#     "black>=24.8.0",
# ]
```

## Idea

It would be helpful if there was an option to specify a different version constraint. For example:

```bash
uv add black --pin-to-latest

cat pyproject.toml
# [project]
# name = "example-2"
# version = "0.1.0"
# description = "Add your description here"
# readme = "README.md"
# requires-python = ">=3.12.4"
# dependencies = [
#     "black==24.8.0",
# ]
```

## Use case

When developing apps, I do not need to support a range of different versions. I could instead do the following:

```bash
uv add black==24.8.0
```

The only downside to the above, is that it requires me to know the latest version of black. This is easy to find, searching on PyPI. But, I find this is a common enough task I do that I would like a shorthand to install the latest version, but also pin to that specific version.


---

_Comment by @zanieb on 2024-08-28 23:05_

The lockfile is used for pinning versions: https://docs.astral.sh/uv/concepts/projects/#project-lockfile

I think it's almost always an anti-pattern to pin to the latest version in your `pyproject.toml`. Can you share more about why using the lockfile to manage pins is not ideal for your use-case?

---

_Label `question` added by @zanieb on 2024-08-28 23:05_

---

_Comment by @SamEdwardes on 2024-08-29 16:01_

Thanks for getting back to me @zanieb. Maybe I need to do some more reading on how the lockfile works, but my thinking is as follows:

- I am using uv to manage a project that is an app. I have no concern about supporting multiple versions of packages or Python.
- For example, lets pretend my app is a FastAPI app. 
- I want to tightly control the version of FastAPI I am using. When I upgrade to a new version, I want it to be really explicit, so I pin FastAPI to a specific version.
- I am less worried about the transitive dependencies of FastAPI. I will let the resolver figure out the latest versions of the packages that will work with my desired version of FastAPI.
- To achieve this, I was using a workflow like this:

```bash
# requirements.in
fastapi==0.112.2
```

- Then use pip compile to create a requirements.txt

```bash
uv pip compile requirements.in --quiet --output-file requirements.txt uv pip sync requirements.txt
```

- Now that I am using the `uv add` workflow, my intuition was to use the same approach:
    - `requirements.in` is now `pyproject.toml`
    - `requirements.txt` is now `uv.lock`

In the context of building an app (as opposed to a library) do you think it makes sense to pin top level dependencies in pyproject.toml?

---

_Comment by @zanieb on 2024-08-29 16:14_

I think even with an application, it makes sense to leave the version in the `pyproject.toml` unpinned.


There _is_ `--upgrade-package <name>` which is helpful if you want to only upgrade a single package — but that doesn't quite solve your transitive dependency use-case. I think what you're looking for is more control over how we do upgrades. For example, these don't exist, but would probably help with your use-case?

- `--no-upgrade-package <name>`
- `--upgrade-strategy <transitive | direct>`


You definitely _can_ still pin your packages in your `pyproject.toml`, but I'm not sure it makes sense for us to prioritize support for doing it automatically?

---

_Referenced in [astral-sh/uv#7019](../../astral-sh/uv/issues/7019.md) on 2024-09-04 14:04_

---

_Comment by @SamEdwardes on 2024-09-05 00:54_

Hi @zanieb thanks for the thoughtful response. I think I agree, it does not make sense for uv to add anything to the CLI at this time to automatically pin to the latest.

I think that maybe my mental model has been wrong and I am not fully Embarrassing the correct use of pyproject.toml and uv.lock.

- pyproject.toml: broad requirments
- uv.lock: exact requirements

I will try this workflow for a longer period of time and see if I run into any challenges. Thank you for your help!

---

_Closed by @SamEdwardes on 2024-09-05 00:54_

---

_Referenced in [astral-sh/uv#7176](../../astral-sh/uv/issues/7176.md) on 2024-09-07 18:41_

---

_Referenced in [astral-sh/uv#7177](../../astral-sh/uv/issues/7177.md) on 2024-09-07 18:42_

---

_Comment by @samuelhwilliams on 2024-11-20 12:18_

I think it feels slightly 'off' to have `pyproject.toml` say something like `flask>=1`, but the lockfile say `flask==3.1.0`. If that's the case, `flask==1` is probably very much _not_ a valid requirement any more. `uv add -U flask` will only upgrade `uv.lock`, and not bump the range in `pyproject.toml`. So over time, without manual management, `pyproject.toml` will gradually just be less and less in line with reality?

---

_Comment by @dudicoco on 2024-12-09 19:52_

> The lockfile is used for pinning versions: [docs.astral.sh/uv/concepts/projects#project-lockfile](https://docs.astral.sh/uv/concepts/projects/#project-lockfile)
> 
> I think it's almost always an anti-pattern to pin to the latest version in your `pyproject.toml`. Can you share more about why using the lockfile to manage pins is not ideal for your use-case?

@zanieb why is it an anti-pattern to pin the version in `pyproject.toml`?
`npm/pnpm add --save-exact` for example will pin the version in `package.json`.
These days we have renovate which can update both `pyproject.toml` and `uv.lock`, so we there's no problem with pinning the version.

In turn we get a more stable lock file which can't change without notice.
Please let me know if we can reopen this issue or if i'll should open a new issue instead.

---

_Comment by @zanieb on 2024-12-09 20:01_

>@zanieb why is it an anti-pattern to pin the version in pyproject.toml?

The project metadata is used to declare supported ranges. The lockfile is used to pin to a consistent version within that range. Using the project metadata to pin to an exact version is overly restrictive, e.g., the project won't be installable alongside other projects, the resolver can't solve for the pinned version for you, etc.

> In turn we get a more stable lock file which can't change without notice.

The lockfile already shouldn't change without notice — it'll only change if the inputs change or you pass `--upgrade`

---

_Comment by @zanieb on 2024-12-09 20:03_

> I think it feels slightly 'off' to have pyproject.toml say something like flask>=1, but the lockfile say flask==3.1.0. If that's the case, flask==1 is probably very much not a valid requirement any more. uv add -U flask will only upgrade uv.lock, and not bump the range in pyproject.toml. So over time, without manual management, pyproject.toml will gradually just be less and less in line with reality?

This is why projects should also test against the lowest supported versions of packages, e.g., with `--resolution lowest-direct`.

See https://github.com/astral-sh/uv/issues/6794 for discussion on updating the `pyproject.toml` during upgrade.

---

_Comment by @samuelhwilliams on 2024-12-09 20:23_

> The project metadata is used to declare supported ranges. The lockfile is used to pin to a consistent version within that range. Using the project metadata to pin to an exact version is overly restrictive, e.g., the project won't be installable alongside other projects, the resolver can't solve for the pinned version for you, etc.


> This is why projects should also test against the lowest supported versions of packages, e.g., with `--resolution lowest-direct`.


I think I disagree in a few places.

For libraries, it makes sense to test against lowest direct resolution/a range of dependency versions. For applications, you don't ever need to support ranges - your direct dependencies are only ever going to be one thing?

Also, for applications, the lockfile is more about pinning exact versions of transitive dependencies than it is for saying what version of direct dependencies you care about, I think.

---

_Comment by @dudicoco on 2024-12-09 22:12_

> > [<img alt="" width="16" height="16" src="https://avatars.githubusercontent.com/u/2586601?s=64&amp;u=e5c86f7ff3b859e7e183187ac2b17fd6ee32b3ab&amp;v=4">@zanieb](https://github.com/zanieb) why is it an anti-pattern to pin the version in pyproject.toml?
> 
> The project metadata is used to declare supported ranges. The lockfile is used to pin to a consistent version within that range. Using the project metadata to pin to an exact version is overly restrictive, e.g., the project won't be installable alongside other projects, the resolver can't solve for the pinned version for you, etc.
> 
> > In turn we get a more stable lock file which can't change without notice.
> 
> The lockfile already shouldn't change without notice — it'll only change if the inputs change or you pass `--upgrade`

The lockfile will change if I add/change another dependency in `pyproject.toml`, this change could bump the version and possibly break my existing dependencies.

I'm using the `pyproject.toml` for installing CLI tools via `devDependencies` (for example yamllint, ansible etc.), I want each tool to be locked to a specific version and a change to one tool's version should not change the other tools versions.

I think this is becoming more of a philosophical/opinionated discussion on how people should work with `pyproject.toml` and `uv.lock`.
Some of us prefer to lock the versions down within `pyproject.toml`, and as I've mentioned before there is a precedence to this with `npm add --save-exact`.

---

_Comment by @SamEdwardes on 2024-12-10 20:34_

> and as I've mentioned before there is a precedence to this with npm add --save-exact

I have never seen that option before with NPM. But I would like to have something similar with uv :) 

---

_Comment by @lbraglia on 2025-02-23 08:15_

I'd like to see this option as well (would become my default I guess), to ease reproducibility of scripts (say scientific area, but not only) after a lot of time passed and libraries have changed.

---

_Comment by @zanieb on 2025-02-24 15:43_

@lbraglia I'd recommend using https://docs.astral.sh/uv/reference/settings/#exclude-newer in your scripts or generating a lockfile https://docs.astral.sh/uv/guides/scripts/#locking-dependencies — pinning dependency versions won't fix your problem because transitive dependencies are not included.

---

_Comment by @lbraglia on 2025-02-25 12:13_

@zanieb Thanks, I'll definitely give `exclude-newer` a shot.

---

_Referenced in [astral-sh/uv#12789](../../astral-sh/uv/issues/12789.md) on 2025-04-09 23:00_

---

_Referenced in [MountainGod2/chaturbate_poller#614](../../MountainGod2/chaturbate_poller/pulls/614.md) on 2025-08-18 23:38_

---

_Comment by @silverwind on 2025-10-08 11:11_

> I think it's almost always an anti-pattern to pin to the latest version in your pyproject.toml

If you are not pinning a dependency in `pyproject.toml` and another package depends on your package, the version of your dependency isn't actually pinned.

I always change the `>=` dependencies that uv creates to `==` and I would really like a `save-exact` option which does this by default. It should be trivial to implement.

---

_Referenced in [astral-sh/uv#16595](../../astral-sh/uv/issues/16595.md) on 2025-11-04 18:43_

---
