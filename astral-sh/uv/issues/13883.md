```yaml
number: 13883
title: Stronger locking for parallel operations
type: issue
state: open
author: konstin
labels:
  - enhancement
  - internal
assignees: []
created_at: 2025-06-06T11:58:13Z
updated_at: 2025-11-27T22:35:32Z
url: https://github.com/astral-sh/uv/issues/13883
synced_at: 2026-01-10T01:57:31Z
```

# Stronger locking for parallel operations

---

_Issue opened by @konstin on 2025-06-06 11:58_

We need to ensure that there a no race conditions when two uv subcommands in parallel. This includes:
 * Parallel filesystem modifications in interpreters/venvs
 * TOCTOU differences between determining packages and performing changes
 * Installing as well as parallel editing of `pyproject.toml`, including TOCTOU errors with 

We already enforce these guarantees with locks for most subcommands. (Follow-up to #12751.)

The required locking generally applies to operations of the same kind, such as `uv sync`, but it can also be cross-operation, e.g. `uv pip list` could fail reading the installed packages if `uv sync` removes some mid-operation.

An exception is the cache, where we use symlinks for atomic operations to allow safe parallel modification. If we need multiple locks, e.g. `pyproject.toml` and the interpreter, we should define and document an order for the locks and use it globally to prevent deadlocks.

### Important
- [x] Ensure that `uv run` locks when syncing the envirnoment.
    `uv run` calls the same logic as `uv sync` internally, so we can use the same locking pattern
    https://github.com/astral-sh/uv/pull/14153
- [ ] Ensure that `uv version --bump` locks when syncing the environment.
- [x] Lock build directories for setuptools (https://github.com/astral-sh/uv/issues/13703)
    https://github.com/astral-sh/uv/pull/14174
- [ ] Ensure that all other subcommands already use the correct locking.
- [x] `uv cache` operations don't clash with other uv operations https://github.com/astral-sh/uv/pull/15888

### Less Important
- [ ] Determine if there are reliable testing strategies, when uv testing currently uses subprocesses.
    Integrating shuttle is not feasible with several uv processes, but maybe a script that locally runs all modifying uv subcommands in a loop in parallel and verifies that we en in a sound state?
- [ ] `uv add`, `uv remove` and `uv version --bump` should lock `pyproject.toml` before computing edits.
    The use case here is that these operations may be started by an IDE/LSP while another operation is e.g. still in its sync phase and/or may roll back in the end.
    We can likely test this by having a build we control in the sync phase.
- [ ] `uv add` and `uv remove` should not lock a global interpreter path when they're not actually going to sync anything (e.g. inline script metadata without an existing cached or locked venv)

### Nice to have
- [ ] Are there portable filesystem read-write locks to allow e.g. blocking `uv pip list` from reading while `uv sync` is editing?
- [ ] Does `uv init`/`uv venv` and venv creation in general need to lock?


---

_Label `bug` added by @konstin on 2025-06-06 11:58_

---

_Comment by @charliermarsh on 2025-06-06 12:03_

To clarify, we already lock where it's known to matter and it's considered safe to run uv concurrently, barring oversights like #13869. This issue is about improving those guarantees, and making it easier and more rigorous for us to enforce.

---

_Label `bug` removed by @charliermarsh on 2025-06-06 12:03_

---

_Label `enhancement` added by @charliermarsh on 2025-06-06 12:03_

---

_Comment by @charliermarsh on 2025-06-06 12:10_

I don't know if we should lock for read operations like `uv pip list`. Locking at the operation level is pretty coarse and I'd prefer to avoid it where we can.

---

_Referenced in [astral-sh/uv#13869](../../astral-sh/uv/pulls/13869.md) on 2025-06-06 12:16_

---

_Comment by @petamas on 2025-06-06 15:17_

@konstin 
> An exception is the cache, where we use symlinks for atomic operations to allow safe parallel modification.

@charliermarsh 
> To clarify, we already lock where it's known to matter and it's considered safe to run uv concurrently, barring oversights like https://github.com/astral-sh/uv/pull/13869.

I'm not sure how relevant it is for this issue, but I want to point out that concurrent cache writes are still not safe on Windows using `uv` 0.7.11: https://github.com/astral-sh/uv/issues/11002

---

_Comment by @leviska on 2025-06-06 18:05_

> uv run calls the same logic as uv sync internally, so we can use the same locking pattern

I just want to clarify, the language of this phrase can be misleading in a way that `run` and `sync` "use the same locking pattern" but "different locks (or something)". 
From my user perspective, they *must* be the same, because for me `uv run` is the same as `uv sync && uv just_run`, so any combination of `sync` and `run` should not race with each other. I.e., `uv sync | uv run` should block one of the commands (for the syncing part)

---

_Comment by @konstin on 2025-06-06 18:57_

The issue is written for guiding the internal development process, as a user you won't observe any of this and `uv sync` and `uv run` will work the same and lock the same, even if their implementations have slightly different code paths due to internal complexities that the subcommands are abstracting over.

The circumstances you need to hit one of those case where something fails are already rare, as we're already very defensive in our filesystem operations, for example using temp dirs and symlinks for atomic operations and we already have locks in many places (which is also why it took so long for https://github.com/astral-sh/uv/issues/12751 to surface compare to many way obscurer bugs).

---

_Label `internal` added by @zanieb on 2025-06-06 19:20_

---

_Comment by @b-phi on 2025-06-18 18:36_

I think we're also getting bit by this. Similar to this [issue](https://github.com/astral-sh/uv/issues/13870), we use uv to synchronize Python environments across large ray clusters. In our case, we mount a shared uv cache volume to all workers and run something like `uv run --all-packages --link-mode symlink` to create the environments and start our jobs. We experienced errors like 
```
Failed to install: ... Caused by: failed to remove file ... No such file or directory (os error 2)
```
And other times more serious things like missing modules after the environment has been setup
```
ModuleNotFoundError: No module named 'botocore.session'
```

---

_Comment by @konstin on 2025-06-20 07:11_

Does this happen with `--link-mode copy` too, or only with `--link-mode symlink`?

---

_Referenced in [astral-sh/uv#14153](../../astral-sh/uv/pulls/14153.md) on 2025-06-20 14:07_

---

_Comment by @b-phi on 2025-06-24 22:51_

`--link-mode copy` was prohibitively slow in our case, but I don't remember seeing such issues there. I've checked with version 0.7.14 and no longer see these issues. Thank you!

---

_Referenced in [astral-sh/uv#15888](../../astral-sh/uv/pulls/15888.md) on 2025-09-16 08:49_

---

_Referenced in [astral-sh/uv#15813](../../astral-sh/uv/issues/15813.md) on 2025-09-17 14:55_

---

_Comment by @ainthek on 2025-11-27 22:35_

On OSX, two parralel processes fail 
```
$ uv --version
uv 0.9.13 (Homebrew 2025-11-26)

```

```
uv run --verbose --project "$c/.." "$c/../main.py" "$@" 

uv run --verbose --project "$c/.." "$c/../main.py" "$@" 

```
second will fail with: ImportError: cannot import name 'packet_creator' from 'mediapipe.python' (unknown location)

This is happening when uv sync (npm run) encounters problem with 
package installation , and performs uninstall and install, in my case:
each run prints 

```
Uninstalled 1 package in 64ms
Installed 1 package in 21ms
```

This is caused by mediapipes and my OS "incompatibility". Which I ignore since it works. but those uninstalls cause second process to run (not synced) and fail (on import).




Machine:
```
ProductName:		macOS
ProductVersion:		14.6.1
BuildVersion:		23G93

Model Name: MacBook Pro
      Model Identifier: Mac15,11
      Chip: Apple M3 Max
      Total Number of Cores: 14 (10 performance and 4 efficiency)
      Memory: 96 GB
```


---
