<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Use a single python process across all steps of building a source dist - astral-sh/uv #846</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Use a single python process across all steps of building a source dist</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/uv/issues/846">#846</a>
        opened by <a href="https://github.com/konstin">@konstin</a>
        on 2024-01-09 14:21
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/konstin">@konstin</a> on 2024-01-09 14:21</div>
            <div class="timeline-body"><p>Starting python is slow (10ms on my machine), and importing a build backend is even slower. Instead, we should start a python interpreter once and keep reusing it. We avoid the startup cost and cached import are free.</p>
<p>PEP 517 says you <em>should</em> use a fresh subprocess each time, but i don't see why keeping the process running shouldn't work.</p>
<blockquote>
<p>Frontends should call each hook in a fresh subprocess, so that backends are free to change process global state (such as environment variables or the working directory). A Python library will be provided which frontends can use to easily call hooks this way.</p>
</blockquote>
<p>Ad-hoc Benchmarks:</p>
<pre><code>$ hyperfine 'python3.12 -c &quot;import sys; print(sys.version)&quot;'
Benchmark 1: python3.12 -c &quot;import sys; print(sys.version)&quot;
  Time (mean ± σ):       8.8 ms ±   3.9 ms    [User: 7.1 ms, System: 1.9 ms]
  Range (min … max):     3.8 ms …  21.8 ms    128 runs
$ hyperfine 'python -c &quot;import setuptools; print(setuptools.__version__)&quot;'
Benchmark 1: python -c &quot;import setuptools; print(setuptools.__version__)&quot;
  Time (mean ± σ):      48.9 ms ±   3.8 ms    [User: 44.3 ms, System: 4.7 ms]
  Range (min … max):    46.5 ms …  71.9 ms    40 runs
$ hyperfine 'python -c &quot;import poetry.core.masonry.api&quot;'
Benchmark 1: python -c &quot;import poetry.core.masonry.api&quot;
  Time (mean ± σ):      30.3 ms ±   2.6 ms    [User: 26.1 ms, System: 4.3 ms]
  Range (min … max):    29.0 ms …  49.2 ms    59 runs
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @konstin on 2024-01-09 14:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-01-09 14:32</div>
            <div class="timeline-body"><blockquote>
<p>but i don't see why keeping the process running shouldn't work.</p>
</blockquote>
<p>Doesn't this depend on what the hook itself is doing?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-01-09 14:35</div>
            <div class="timeline-body"><p>If the backend e.g. sets global variables and expects them to be fresh anytime a hook is called, then this would fail, but if the hooks are implemented properly i see no problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-01-09 14:51</div>
            <div class="timeline-body"><p>We could also reset the environment variables and working directory if needed.</p>
<p>I don't know if people would be good about not mutating those (or other global state).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-01-09 18:55</div>
            <div class="timeline-body"><p>Would we be using the process concurrently?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-01-09 18:55</div>
            <div class="timeline-body"><p>No, serially.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-01-09 21:51</div>
            <div class="timeline-body"><p>I'm confident in my ability to do something robust on the Python side, although I'm not sure what all the requirements are :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-01-09 22:51</div>
            <div class="timeline-body"><p>It needs an async interface you can tell it to invoke one of the <a href="https://peps.python.org/pep-0517/#build-wheel">PEP 517</a> hooks with it's respective argument(s) and get a <code>Result&lt;(return value, stderr), (stdout, stderr with backtrace)&gt;</code> on the rust side. It needs to be resilient to the child process aborting (it should retain stderr) and large amount of output (will not fit in a 64KB pipe buffer).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/861.html">astral-sh/uv#861</a> on 2024-01-09 23:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/895.html">astral-sh/uv#895</a> on 2024-01-12 04:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Use a single python process all step of building a source dist" to "Use a single python process across all steps of building a source dist" by @konstin on 2024-02-02 20:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bschoenmaeckers">@bschoenmaeckers</a> on 2024-03-18 12:37</div>
            <div class="timeline-body"><p>Is it possible to dynamically load the correct libpython.so using dlopen (or some platform variant) and run the python code in the current process?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-03-18 12:54</div>
            <div class="timeline-body"><p>Not really unfortunately. We would attach the python interpreter state to the current process (breaking isolation between builds) and we'd still pay the python initialization cost.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-03-18 14:25</div>
            <div class="timeline-body"><p>For bookkeeping I implemented this in #895 and we did not see a significant improvement.</p>
<p>Should we close this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2024-03-18 14:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-03-18 14:36</div>
            <div class="timeline-body"><p>It’s a minor optimization. It should still save ~30-50ms from source distribution building but I don’t feel strongly about doing it (and it shouldn’t be prioritized).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-03-18 14:42</div>
            <div class="timeline-body"><p>The problem is that it's costly (and technically dubious) to reset the Python modules on each call which is necessary because new packages are installed in-between calls and libraries (e.g. setuptools) have dynamic behavior depending on what is available at import-time.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:17 UTC
    </footer>
</body>
</html>
