<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`uv venv` reports using a different interpreter path than it uses - astral-sh/uv #2327</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>uv venv</code> reports using a different interpreter path than it uses</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/2327">#2327</a>
        opened by <a href="https://github.com/gschaffner">@gschaffner</a>
        on 2024-03-10 06:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/gschaffner">@gschaffner</a></div>
            <div class="timeline-body"><p>hi! if an interpreter path contains multiple symlinks, <code>uv venv</code> reports using a different interpreter path than it actually uses. e.g.:</p>
<pre><code>+ type python
python is /usr/sbin/python
+ : &#x27;it resolves to /usr/bin/python3.11 via the symlinks&#x27;
+ readlink /usr/sbin /usr/bin/python /usr/bin/python3
bin
python3
python3.11
</code></pre>
<pre><code>+ /uv venv
Using Python 3.11.8 interpreter at: /usr/sbin/python3
Creating virtualenv at: .venv
Activate with: source .venv/bin/activate
+ : &#x27;^^^ uv reports using /usr/sbin/python3 (partial symlink resolution)&#x27;
+ readlink .venv/bin/python
/usr/bin/python3.11
+ : &#x27;^^^ but actually uses /usr/bin/python3.11 (full symlink resolution)&#x27;
</code></pre>
<pre><code>+ /uv venv --python=/usr/sbin/python
Using Python 3.11.8 interpreter at: /usr/sbin/python
Creating virtualenv at: .venv
Activate with: source .venv/bin/activate
+ : &#x27;^^^ uv reports using /usr/sbin/python (no symlink resolution :) )&#x27;
+ readlink .venv/bin/python
/usr/bin/python3.11
+ : &#x27;^^^ but actually uses /usr/bin/python3.11 (full symlink resolution)&#x27;
</code></pre>
<pre><code>+ python -m venv .venv
+ readlink .venv/bin/python
/usr/sbin/python
+ : &#x27;^^^ venv uses /usr/sbin/python (no symlink resolution :) )&#x27;
</code></pre>
<pre><code>+ python -m virtualenv .venv
created virtual environment CPython3.11.8.final.0-64 in 211ms
  creator CPython3Posix(dest=/home/user/.venv, clear=False, no_vcs_ignore=False, global=False)
  seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=/home/user/.local/share/virtualenv)
    added seed packages: pip==23.3.1, setuptools==69.0.2, wheel==0.42.0
  activators BashActivator,CShellActivator,FishActivator,NushellActivator,PowerShellActivator,PythonActivator
+ readlink .venv/bin/python
/usr/sbin/python
+ : &#x27;^^^ virtualenv uses /usr/sbin/python (no symlink resolution :) )&#x27;
</code></pre>
<p>i would have expected uv to</p>
<ul>
<li><p>report using the execuable path that it actually uses</p>
</li>
<li><p>(already tracked at #1795) use the unresolved[^1] executable path, as this is what stdlib <code>venv</code> and <code>virtualenv</code> do</p>
</li>
</ul>
<p>[^1]: by unresolved here, i mean that no symlinks are resolved. the executable is however allowed to self-report resolution to a different location. for example, if</p>
<pre><code>*   `~/.pyenv/shims/python -c &#x27;import sys; print(sys.executable)` is `~/.pyenv/versions/3.12/bin/python`.

*   `~/.pyenv/versions/3.12` is a symlink to `3.12.2`.

then the venv would link to `~/.pyenv/versions/3.12/bin/python`, not `~/.pyenv/versions/3.12.2/bin/python`.</code></pre>


reproducer (click to expand)

<p><code>cargo build --target=x86_64-unknown-linux-musl --features=vendored-openssl</code> and then</p>
<pre><code>#!/usr/bin/env -S sh -c &#x27;&lt; &quot;$0&quot; podman run --rm -i -v=./target/x86_64-unknown-linux-musl/debug/uv:/uv:ro --pull=newer docker.io/archlinux/archlinux bash &quot;$@&quot;&#x27;

# /uv is version 6dcd00e03 (latest main at time of writing)

set -o errexit -o errtrace -o nounset -o pipefail
shopt -s inherit_errexit

pacman --noconfirm --quiet -Syu sudo python python-virtualenv &gt; /dev/null
useradd --create-home --groups=wheel user
echo &#x27;%wheel ALL=(ALL:ALL) NOPASSWD: ALL&#x27; &gt; /etc/sudoers.d/wheel
&lt;&lt;&#x27;EOF&#x27; sudo -u user bash
    set -o errexit -o errtrace -o nounset -o pipefail
    shopt -s inherit_errexit

    cd ~
    set -o xtrace

    type python
    : &#x27;it resolves to /usr/bin/python3.11 via the symlinks&#x27;
    readlink /usr/sbin /usr/bin/python /usr/bin/python3

    :
    /uv venv
    : &#x27;^^^ uv reports using /usr/sbin/python3 (partial symlink resolution)&#x27;
    readlink .venv/bin/python
    : &#x27;^^^ but actually uses /usr/bin/python3.11 (full symlink resolution)&#x27;
    rm .venv -r

    :
    /uv venv --python=/usr/sbin/python
    : &#x27;^^^ uv reports using /usr/sbin/python (no symlink resolution :) )&#x27;
    readlink .venv/bin/python
    : &#x27;^^^ but actually uses /usr/bin/python3.11 (full symlink resolution)&#x27;
    rm .venv -r

    :
    python -m venv .venv
    readlink .venv/bin/python
    : &#x27;^^^ venv uses /usr/sbin/python (no symlink resolution :) )&#x27;
    rm .venv -r

    :
    python -m virtualenv .venv
    readlink .venv/bin/python
    : &#x27;^^^ virtualenv uses /usr/sbin/python (no symlink resolution :) )&#x27;
EOF
</code></pre>


</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-03-10 11:14</div>
            <div class="timeline-body"><p>(I will just note that on unreleased main, virtualenv also resolves symlinks like this, though I’m undecided on what’s correct, and we’ll likely change it.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gschaffner">@gschaffner</a> on 2024-03-11 08:39</div>
            <div class="timeline-body"><p>(i came across the recent virtualenv changes but i believe they don&#x27;t change virtualenv&#x27;s behavior in the example above. IIUC the virtualenv change was to resolve symlinks in the paths it writes to <code>pyvenv.cfg</code>, but virtualenv (new or old) doesn&#x27;t resolve symlinks in the path that it symlinks <code>.venv/bin/python</code> to. e.g.:</p>
<pre><code>+ diff --side-by-side a/.venv/pyvenv.cfg b/.venv/pyvenv.cfg
home = /usr/sbin                                              | home = /usr/bin
implementation = CPython                                        implementation = CPython
version_info = 3.11.8.final.0                                   version_info = 3.11.8.final.0
virtualenv = 20.25.0                                          | virtualenv = 20.25.2.dev3+gabe2c99
include-system-site-packages = false                            include-system-site-packages = false
base-prefix = /usr                                              base-prefix = /usr
base-exec-prefix = /usr                                         base-exec-prefix = /usr
base-executable = /usr/sbin/python                            | base-executable = /usr/bin/python3.11
+ readlink a/.venv/bin/python b/.venv/bin/python
/usr/sbin/python
/usr/sbin/python
+ : &#x27;^^^ symlinks in bin are unchanged: both link to unresolved paths&#x27;
+ diff --side-by-side &lt;(a/.venv/bin/python info.py) &lt;(b/.venv/bin/python info.py)
sys._base_executable = &#x27;/usr/sbin/python3.11&#x27;                   sys._base_executable = &#x27;/usr/sbin/python3.11&#x27;
sys.executable = &#x27;/home/user/a/.venv/bin/python&#x27;              | sys.executable = &#x27;/home/user/b/.venv/bin/python&#x27;
sys.base_exec_prefix = &#x27;/usr&#x27;                                   sys.base_exec_prefix = &#x27;/usr&#x27;
sys.exec_prefix = &#x27;/home/user/a/.venv&#x27;                        | sys.exec_prefix = &#x27;/home/user/b/.venv&#x27;
sys.base_prefix = &#x27;/usr&#x27;                                        sys.base_prefix = &#x27;/usr&#x27;
sys.prefix = &#x27;/home/user/a/.venv&#x27;                             | sys.prefix = &#x27;/home/user/b/.venv&#x27;
</code></pre>
<p>venv appears to do the same as new virtualenv in this regard:</p>
<pre><code>+ readlink b/.venv/bin/python c/.venv/bin/python
/usr/sbin/python
/usr/sbin/python
+ diff --side-by-side b/.venv/pyvenv.cfg c/.venv/pyvenv.cfg
home = /usr/bin                                               | home = /usr/sbin
implementation = CPython                                      &lt;
version_info = 3.11.8.final.0                                 &lt;
virtualenv = 20.25.2.dev3+gabe2c99                            &lt;
include-system-site-packages = false                            include-system-site-packages = false
base-prefix = /usr                                            | version = 3.11.8
base-exec-prefix = /usr                                       | executable = /usr/bin/python3.11
base-executable = /usr/bin/python3.11                         | command = /usr/sbin/python -m venv /home/user/c/.venv
: &#x27;^^^ both are using resolved paths in pyvenv.cfg but unresolved for .venv/bin/python&#x27;
</code></pre>


reproducer (click to expand)

<pre><code>#!/usr/bin/env -S sh -c &#x27;&lt; &quot;$0&quot; podman run --rm -i --pull=newer docker.io/archlinux/archlinux bash &quot;$@&quot;&#x27;

set -o errexit -o errtrace -o nounset -o pipefail
shopt -s inherit_errexit

pacman --noconfirm --quiet -Syu sudo python python-pip git diffutils &gt; /dev/null
useradd --create-home --groups=wheel user
echo &#x27;%wheel ALL=(ALL:ALL) NOPASSWD: ALL&#x27; &gt; /etc/sudoers.d/wheel
&lt;&lt;&#x27;EOF&#x27; sudo -u user bash
    set -o errexit -o errtrace -o nounset -o pipefail
    shopt -s inherit_errexit

    cd ~
    set -o xtrace

    type python
    : &#x27;it resolves to /usr/bin/python3.11 via the symlinks&#x27;
    readlink /usr/sbin /usr/bin/python /usr/bin/python3

    :
    mkdir a &amp;&amp; pushd a
    sudo pip install --quiet --break-system-packages virtualenv==20.25.0
    python -m virtualenv --version
    python -m virtualenv .venv
    popd

    :
    mkdir b &amp;&amp; pushd b
    sudo pip install --quiet --break-system-packages &#x27;virtualenv @ git+https://github.com/pypa/virtualenv.git@abe2c998bf8c7593a3a3ed2c19b3ebd55675c818&#x27;
    python -m virtualenv --version
    python -m virtualenv .venv
    popd

    :
    mkdir c &amp;&amp; pushd c
    : &#x27;stdlib venv does the same as virtualenv main w.r.t. symlink resolution:&#x27;
    python -m venv .venv
    popd

    :
    &lt;&lt;&#x27;    EOF&#x27; python -c &#x27;import sys; import textwrap; print(textwrap.dedent(sys.stdin.read()))&#x27; &gt; info.py
        import sys

        print(f&quot;{sys._base_executable = }&quot;)
        print(f&quot;{sys.executable = }&quot;)
        print(f&quot;{sys.base_exec_prefix = }&quot;)
        print(f&quot;{sys.exec_prefix = }&quot;)
        print(f&quot;{sys.base_prefix = }&quot;)
        print(f&quot;{sys.prefix = }&quot;)
    EOF

    :
    readlink {a,b}/.venv/bin/python
    : &#x27;^^^ symlinks in bin are the same: unresolved&#x27;
    diff --side-by-side {a,b}/.venv/pyvenv.cfg || true
    diff --side-by-side &lt;(a/.venv/bin/python info.py) &lt;(b/.venv/bin/python info.py) || true

    :
    : &#x27;stdlib venv does the same as virtualenv main here:&#x27;
    readlink {b,c}/.venv/bin/python
    diff --side-by-side {b,c}/.venv/pyvenv.cfg || true
    diff --side-by-side &lt;(b/.venv/bin/python info.py) &lt;(c/.venv/bin/python info.py) || true
EOF
</code></pre>


<p>so, for example, with virtualenv main, #1795 still works[^1].</p>
<p>[^1]: asterisk. virtualenv main&#x27;s current behavior does technically mean that you can get</p>
<pre><code>1.  broken installs if a sdist/bdist had an odd specifier that said &quot;i support 3.12.1 but not 3.12.2&quot;.

    i lean towards practicality here and agree with <a href="https://github.com/astral-sh/uv/issues/1640">astral-sh/uv#1640</a>#issuecomment-1975245528 that a tool should allow users to do python-updates-underneath-a-venv if they want to, so long as it does not affect other users negatively.

1.  `sys.base_(exec_)?prefix` reporting paths that no longer exist.

    interestingly, this is just a (new) `virtualenv` issue—stdlib `venv` actually avoids this issue:

    ```console
    + .venv/bin/python info.py
    sys._base_executable = &#x27;/home/user/.pyenv/versions/3.12/bin/python3.12&#x27;
    sys.executable = &#x27;/home/user/.venv/bin/python&#x27;
    sys.base_exec_prefix = &#x27;/home/user/.pyenv/versions/3.12&#x27;
    sys.exec_prefix = &#x27;/home/user/.venv&#x27;
    sys.base_prefix = &#x27;/home/user/.pyenv/versions/3.12&#x27;
    sys.prefix = &#x27;/home/user/.venv&#x27;
    + .virtualenv/bin/python info.py
    sys._base_executable = &#x27;/home/user/.pyenv/versions/3.12/bin/python3.12&#x27;
    sys.executable = &#x27;/home/user/.virtualenv/bin/python&#x27;
    sys.base_exec_prefix = &#x27;/home/user/.pyenv/versions/3.12.1&#x27;
    sys.exec_prefix = &#x27;/home/user/.virtualenv&#x27;
    sys.base_prefix = &#x27;/home/user/.pyenv/versions/3.12.1&#x27;
    sys.prefix = &#x27;/home/user/.virtualenv&#x27;
    ```</code></pre>


reproducer (click to expand)

<pre><code>#!/usr/bin/env -S sh -c &#x27;&lt; &quot;$0&quot; podman run --rm -i --pull=newer docker.io/archlinux/archlinux:base-devel bash &quot;$@&quot;&#x27;

set -o errexit -o errtrace -o nounset -o pipefail
shopt -s inherit_errexit

pacman --noconfirm --quiet -Syu sudo pyenv git &gt; /dev/null
useradd --create-home --groups=wheel user
echo &#x27;%wheel ALL=(ALL:ALL) NOPASSWD: ALL&#x27; &gt; /etc/sudoers.d/wheel
&lt;&lt;&#x27;EOF&#x27; sudo -u user bash
    set -o errexit -o errtrace -o nounset -o pipefail
    shopt -s inherit_errexit

    cd ~

    eval &quot;$(pyenv init -)&quot;

    set -o xtrace

    pyenv install 3.12.1 3.12.2
    &lt;&lt;&lt; &#x27;3.12&#x27; cat &gt; ~/.pyenv/version

    ln -s 3.12.1 ~/.pyenv/versions/3.12

    type python
    pyenv which python
    pip install &#x27;virtualenv @ git+https://github.com/pypa/virtualenv.git@abe2c998bf8c7593a3a3ed2c19b3ebd55675c818&#x27;
    python -m venv .venv
    python -m virtualenv .virtualenv

    :
    &lt;&lt;&#x27;    EOF&#x27; python -c &#x27;import sys; import textwrap; print(textwrap.dedent(sys.stdin.read()))&#x27; &gt; info.py
        import sys

        print(f&quot;{sys._base_executable = }&quot;)
        print(f&quot;{sys.executable = }&quot;)
        print(f&quot;{sys.base_exec_prefix = }&quot;)
        print(f&quot;{sys.exec_prefix = }&quot;)
        print(f&quot;{sys.base_prefix = }&quot;)
        print(f&quot;{sys.prefix = }&quot;)
    EOF

    :
    rm ~/.pyenv/versions/3.12
    ln -s 3.12.2 ~/.pyenv/versions/3.12
    .venv/bin/python info.py
    .virtualenv/bin/python info.py
EOF
</code></pre>


<p>)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:30:22 UTC
    </footer>
</body>
</html>
