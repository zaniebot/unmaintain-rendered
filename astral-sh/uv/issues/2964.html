<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running uv for the second time is slower on a mounted docker volume - astral-sh/uv #2964</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Running uv for the second time is slower on a mounted docker volume</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/astral-sh/uv/issues/2964">#2964</a>
        opened by <a href="https://github.com/jaap3">@jaap3</a>
        on 2024-04-10 14:25
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/jaap3">@jaap3</a> on 2024-04-10 14:25</div>
            <div class="timeline-body"><p>I'm looking into replacing <code>pip</code> with <code>uv</code> in our development setup. We develop our projects in <code>docker</code> containers and one thing we do is (re)install all requirements when the container is (re)started. I noticed that in some cases <code>pip</code> was faster than <code>uv</code>, so I did some testing.</p>
<p>I created a test <code>requirements.txt</code> file:</p>
<pre><code class="language-requirements.txt">Django~=4.2.0
django-email-bandit~=2.0.0
djangorestframework~=3.14.0
django-filter~=23.2
leukeleu-django-checks~=1.2
leukeleu-django-gdpr~=1.4
psycopg2-binary~=2.9.6
sentry-sdk~=1.18
wagtail~=5.1.0
coverage[toml]~=7.2
pywatchman~=2.0.0
ruff~=0.3.2
</code></pre>
<p>A minimal <code>pip.sh</code>:</p>
<pre><code class="language-bash">#!/usr/bin/env bash
python -m venv ./venv/pip
source ./venv/pip/bin/activate
pip install -r requirements.txt
</code></pre>
<p>and a minimal <code>uv.sh</code>:</p>
<pre><code class="language-bash">#!/usr/bin/env bash
uv venv ./venv/uv
source ./venv/uv/bin/activate
uv pip install -r requirements.txt
</code></pre>
<p>I then started a <code>python</code> container using</p>
<pre><code>docker run --rm -itv `pwd`:/code -w /code python bash
</code></pre>
<p>This container runs Python 3.12.3 with pip 24.0.</p>
<p>I used <code>pip</code> to install <code>uv</code> at version 0.1.31</p>
<p>I then timed both scripts multiple times, to get the times for a cold (no venv/cache) and warm (existing venv/cach) install:</p>
<pre><code class="language-shell"># time ./pip.sh
...
real	0m25.336s
user	0m9.570s
sys	0m2.723s

# time ./pip.sh
...
real	0m2.013s
user	0m1.614s
sys	0m0.153s

# time ./uv.sh 
...
real	0m5.579s
user	0m2.018s
sys	0m2.426s

# time ./uv.sh
...
real	0m7.100s
user	0m0.233s
sys	0m1.833s
</code></pre>
<p>As expected, on a cold install <code>uv</code> outperforms <code>pip</code> by a wide margin. However, unexpectedly, the second install is slower (it's even slower than <code>uv</code> first run).</p>
<p>I suspected that the mounted volume had something to do with this. So I copied the scripts and requirements file to another directory in the container (one that is not mounted) and timed everything again (note that I did <em>not</em> remove the pip and uv download caches):</p>
<pre><code class="language-shell"># time ./pip.sh
...
real	0m7.413s
user	0m6.079s
sys	0m0.491s

# time ./pip.sh
...
real	0m1.627s
user	0m1.543s
sys	0m0.085s

# time ./uv.sh 
...
real	0m0.174s
user	0m0.073s
sys	0m0.270s

# time ./uv.sh
...
real	0m0.232s
user	0m0.061s
sys	0m0.319s
</code></pre>
<p>This time <code>uv</code> beats <code>pip</code> easily (however the second invocation is still somewhat slower than the initial one).</p>
<p>I'm using Docker version 25.0.3 on MacOS Sonoma 14.4.1. VirtioFS is enabled for bind mounts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @zanieb on 2024-04-10 14:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2024-04-10 15:40</div>
            <div class="timeline-body"><p>Due to bigger build images it's generally considered best practice inside docker to set pip to use no cache e.g. via <code>--no-cache-dir</code>.</p>
<p>I imagine the same would be for true for uv, e.g. via <code>--no-cache</code>.</p>
<p>Is there a particular use case you have for installing Python packages twice in a docker image?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jaap3">@jaap3</a> on 2024-04-10 17:22</div>
            <div class="timeline-body"><p>@notatallshaw this is not about baking dependencies into an image. This is about using a fairly bare bones python image to mount a project and installing it's dependencies into a venv that's also in the mounted directory.</p>
<p>Re-installing happens when the container is restarted (or recreated) when switching branches, pulling work etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/3015.html">astral-sh/uv#3015</a> on 2024-04-12 14:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-04-12 15:13</div>
            <div class="timeline-body"><p>I can't reproduce this on ubuntu, so i'm speculating for macos.</p>
<pre><code>root:/code# time ./pip.sh
real    0m17.502s
root:/code# time ./pip.sh
real    0m1.438s
root:/code# time ./uv.sh
real    0m5.285s
root:/code# time ./uv.sh
real    0m0.242s
root:/code# time ./uv.sh
real    0m0.339s
</code></pre>
<p>When uv installs a wheel, we first unpack the wheel to the cache, then use that cache to populate the venv. On macos, we clone the directory by default, on linux and windows, we hardlink by default; these are a lot faster (and space efficient) than copying the files. Should cloning/hardlinking fail, we fall back to copying all files. We were missing logging for the fallback switchover for hardlinking, i've added this in #3015, afterwards you should be able to see it with RUST_LOG=debug.</p>
<p>The cache by default is in <code>~/.cache/uv</code> inside the docker container, while the target venv is a bind mount, so hardlinking fails and we end up copying all files. It looks like this copying is slow with the macos docker fs driver, and slower than reading and unpacking a single zip archive that python does.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jaap3">@jaap3</a> on 2024-04-15 08:16</div>
            <div class="timeline-body"><p>@konstin Thanks for looking into this. I just timed everything again, but this time I used the <code>--cache-dir</code> flag for both <code>pip</code> and <code>uv</code> to put the cache on the mounted volume.</p>
<p>The time it takes for <code>pip</code> is pretty much the same.</p>
<pre><code># time ./pip.sh
real	0m24.987s

# time ./pip.sh
real	0m1.951s
</code></pre>
<p><code>uv</code> becomes slower if the cache is also on the mounted volume:</p>
<pre><code># time ./uv.sh
real	0m12.715s

# time ./uv.sh
real	0m9.178s
</code></pre>
<p>Will try this again with <code>RUST_LOG=debug</code> when the next release is out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jaap3">@jaap3</a> on 2024-04-16 08:15</div>
            <div class="timeline-body"><p>I just tried again with <code>uv 0.1.32</code> and <code>RUST_LOG=debug</code>.</p>
<p>I see a number of logs about failed hardlinks when the <code>cache-dir</code> is outside the mounted volume. I <em>don't</em> see these when the <code>cache-dir</code> is on the mounted volume, but that makes no real difference when it comes to install speed (as I noted yesterday).</p>
<p>I now also realise that the extra time it takes to do a second install is caused by <code>uv</code> removing the old <code>venv</code> before recreating it. Turns out <code>python -m venv ./var/venv</code> will just keep an existing intact, so <code>pip</code> had a major advantage there.</p>
<p>Conclusion: mounted volumes in Docker on macOS are slow and I shouldn't have assumed that <code>uv venv &lt;path&gt;</code> <code>python -m venv &lt;path&gt;</code> behaves in the same way.</p>
<p>I don't think there's anything <code>uv</code> can really do to optimise this. I did learn a bit more about how <code>uv</code> works, that I can use in our setup, so there's a silver lining ðŸ˜€.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @jaap3 on 2024-04-16 08:15</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:19 UTC
    </footer>
</body>
</html>
