```yaml
number: 14210
title: "uv build does not validate entry points in \"project.scripts\""
type: issue
state: open
author: stmlange
labels:
  - wish
assignees: []
created_at: 2025-06-23T06:06:52Z
updated_at: 2025-12-22T18:12:59Z
url: https://github.com/astral-sh/uv/issues/14210
synced_at: 2026-01-10T01:57:32Z
```

# uv build does not validate entry points in "project.scripts"

---

_Issue opened by @stmlange on 2025-06-23 06:06_

### Summary

Hello UV-Team,
first of all - thanks for the amazing uv-tool!
Maybe this is something I'm missing, but it seems that a "uv build" does not validate or verify the entry points in "project.scripts" that may be defined in a `pyproject.toml`.

Consider for example:
1) create new project using `uv init --package dummy`
2) change "project.scripts" in `pyproject.toml` to
```
[project.scripts]
dummy = "dummy:main"
dummy_one = "dummy:main_does_not_exist"
dummy_two = "dummy.example:main_does_not_exist"
```

3) Install project into venv:
```
uv build
uv venv
.venv\Scripts\activate
uv pip install dist\dummy-0.1.0-py3-none-any.whl
```

4)
Trying to use the non-existent `dummy_one` or `dummy_two` will fail:
```
λ .venv\Scripts\dummy_one
Traceback (most recent call last):
  File "<frozen runpy>", line 198, in _run_module_as_main
  File "<frozen runpy>", line 88, in _run_code
    from dummy import main_does_not_exist
ImportError: cannot import name 'main_does_not_exist' from 'dummy' 
```
and
```
λ .venv\Scripts\dummy_two
Traceback (most recent call last):
  File "<frozen runpy>", line 198, in _run_module_as_main
  File "<frozen runpy>", line 88, in _run_code
    from dummy.example import main_does_not_exist
ModuleNotFoundError: No module named 'dummy.example'
```

Goal: validate and ensure entry points can be used

### Platform

Windows

### Version

uv 0.7.2 (481d05d8d 2025-04-30)

### Python version

Python 3.13.3

---

_Label `bug` added by @stmlange on 2025-06-23 06:06_

---

_Label `bug` removed by @konstin on 2025-06-23 08:03_

---

_Label `question` added by @konstin on 2025-06-23 08:03_

---

_Comment by @konstin on 2025-06-23 08:35_

I don't think it's possible properly to validate these at build time, as it possible to set symbols dynamically at runtime, scripts need to be tested through integration tests instead.

---

_Comment by @stmlange on 2025-06-23 09:12_

Thanks for your feedback!
Yeah there might be some corner cases where people add entry scripts dynamically, but couldn't a uv build validate at least the ones that are are actually hard-coded (statically) in the pyproject.toml?


---

_Label `question` removed by @konstin on 2025-06-23 09:46_

---

_Label `wish` added by @konstin on 2025-06-23 09:46_

---

_Comment by @konstin on 2025-06-23 09:46_

For the validation, it would make more sense for the build backend such as hatchling (which includes scripts and files) to validate these than for uv to open the wheel and check it. This would only cover a part of the ways an entrypoint can be broken, so I'd rather recommend executing entrypoints as parts of the test suite, which does cover missing files and symbols and the other problems too.

---

_Comment by @paveldikov on 2025-12-22 18:12_

In the meantime, I have been able to use a type checker to implement this type of validation (currently `mypy`, but I imagine `ty` will be up to the task too).

Basically, for each entrypoint, generate a `from ... import ...` one-liner, then feed that into a type-checker with a strongly abridged set of validation rules (to stop it from getting tripped on unrelated issues, or waste a bunch of time consuming third-party modules), and then post-process any errors coming from the type checker.

IMHO: I do think this should eventually be a first-class part of a linter, preferably `ruff`, although that is currently type-unaware (and all type-aware functionality is for `ty` use only.)

See also this proposal I made for a `PROJ` set of `ruff` rules: https://github.com/astral-sh/ruff/discussions/17771

---
