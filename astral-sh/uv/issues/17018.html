<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`uv add --bounds none` and a corresponding environment variable - astral-sh/uv #17018</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>`uv add --bounds none` and a corresponding environment variable</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/17018">#17018</a>
        opened by <a href="https://github.com/jklaiho">@jklaiho</a>
        on 2025-12-07 14:42
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/jklaiho">@jklaiho</a> on 2025-12-07 14:42</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Before migrating to uv, we used pip-compile, manually adding new dependencies in <code>pyproject.toml</code> files.  Since most of our projects are Django projects, we tended to only ever add an explicit version specification for Django itself as the &quot;linchpin dependency&quot;. Every other dependency we'd just add without a specifier, then run pip-compile a couple of times to generate separate requirement files with pinned versions of everything for dev and prod. (We would use optional depencies for this in an unconventional way that nonetheless worked for us. With uv's single lock file, we've moved to dependency groups.)</p>
<p>Only in the case of problematic versions would we need to add a specifier to any other dependency. This keeps <code>pyproject.toml</code> more readable, and the presence of a version specifier on a dependency becomes a meaningful bit of information for the reader: &quot;We specifically need a version below x.y of library z, otherwise the specifier wouldn't be here. Take extra care with this one around upgrades!&quot;</p>
<p>A similar model still works with <code>uv.lock</code>, but it involves adding the dependency to <code>pyproject.toml</code> manually with no specifier and then running <code>uv lock</code>, or remembering to use <code>uv add --raw</code> each time.</p>
<p>We would really appreciate the addition of <code>uv add --bounds none</code> and, most crucially, an environment variable like <code>UV_BOUNDS</code> that would support all the <code>--bounds</code> options, enabling a default to be set. This would save us from always having to use <code>--raw</code>, an option that has wider implications than merely version specifiers anyway.</p>
<p>Additionally, <code>uv add --bounds none &quot;somepackage&lt;5.1&quot;</code> would install and pin in <code>uv.lock</code> the most recent 5.0.x version of <code>somepackage</code>, but it would still show up as <code>&quot;somepackage&quot;</code> in <code>project.dependencies</code>, just as if <code>uv add --bounds none somepackage</code> had been run when that 5.0.x version happened to be the latest version available.</p>
<p>I realize there are edge cases here to consider (e.g. what happens when using <code>--bounds none</code> on a dependency that already exists in <code>project.dependencies</code> with a version specifier), but I'm sure those can be worked out.</p>
<h3>Example</h3>
<p><code>uv add --bounds none ipython</code></p>
<p>would be equivalent to having <code>UV_BOUNDS=none</code> set somewhere, then running</p>
<p><code>uv add ipython</code></p>
<p>This would cause <code>&quot;ipython&quot;</code> to end up in <code>project.dependencies</code> with no version specifier, with the current version at the time of running the command pinned in <code>uv.lock</code>.</p>
<p><code>uv add --bounds none somepackage&lt;5.1</code> locks 5.0.x but records it as <code>&quot;somepackage&quot;</code> in <code>project.dependencies</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @jklaiho on 2025-12-07 14:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-12-08 12:21</div>
            <div class="timeline-body"><p>Adding lower bounds to dependencies can really help with resolution preventing all sorts of undesirable backtracking situations. What is the downside to having them?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jklaiho">@jklaiho</a> on 2025-12-08 13:05</div>
            <div class="timeline-body"><p>I'm not even trying to imply an actual downside to lower bounds, apart from a visually messier <code>dependencies</code> list. It's just that for years, we've had zero problems with not having version specifiers on anything but &quot;linchpin&quot; stuffâ€”except when we've actually ran into a real problem on a non-linchpin dependency being too recent. In those cases, we've typically specified an exact older version for it, re-run <code>pip-compile</code> and rebuilt our containers with the new requirements file.</p>
<p>All our existing pre-uv <code>pyproject.toml</code> files are like this, so it's also a matter of consistency across older and newer projects.</p>
<p>Dependencies listed without version specifiers are present in the Python Packaging User Guide, using them is fully valid, and the guide does not discourage their use. A <code>none</code> option to <code>--bounds</code> would seem to fit in with the existing ones, especially with the extra comfort of a hypothetical <code>UV_BOUNDS</code> environment variable. The current lack of <code>none</code> makes uv implicitly somewhat opinionated against unspecified dependencies. It's your prerogative, but I don't see them harmful in a way that would necessitate that opinion.</p>
<p>I appreciate that most people would not choose to use <code>none</code>, and I see how uv docs would not actively recommend the option and might indeed remind the user about backtracking concerns associated with it, but I think its inclusion is still a valid request.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-12-11 11:36</div>
            <div class="timeline-body"><p>We regularly get bug reports that eventually turn out to be cases where a user got a bad resolution due to missing lower bounds. Even if there is no explicit lower bound in the requirements file, there is already an implicit lower bound in the code through the symbols that are used. Not stating a bound means that choosing any version of the package is valid, even an ancient one that breaks the code that's using it; Notably there's no guarantee that the current working resolution will keep working in the future when more versions are published, due to potentially changed backtracking behavior, or even a change in the resolver's behavior. Adding lower bounds to the requirements file makes the implicit requirement explicit and prevents the packaging tool from violating that assumption.</p>
<p>The Python Packaging User Guide recommends using lower bounds as best practice (e.g., https://packaging.python.org/en/latest/discussions/install-requires-vs-requirements/#install-requires). Where it uses examples without lower bounds, we should add those missing bounds. Some of the examples may predate proper backtracking resolvers, which are mainly affected by this problem (https://pip.pypa.io/en/latest/user_guide/#changes-to-the-pip-dependency-resolver-in-20-3-2020).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jklaiho">@jklaiho</a> on 2025-12-12 14:19</div>
            <div class="timeline-body"><p>Yeah, I'm not going to argue <em>too</em> too much for what is admittedly a niche preference. Upper and exact bounds are supported and can also be footguns, and not having bounds is not always one. My assumption is that anyone actively opting to use <code>--bounds none</code>/<code>UV_BOUNDS=none</code> would know what they are doing and why, and would accept the (possibly real, possibly theoretical, depending on their situation) risk involved.</p>
<p>In a dream world that conformed to my particular aesthetic preferences I'd have two environment variables: <code>UV_BOUNDS=none</code>and <code>UV_NO_DOWNGRADES=true</code>, then just use <code>uv add</code> to get unbounded dependencies in <code>pyproject.toml</code>. If that command were ever to cause a downgrade of a dependency, the process would stop and tell me to determine how I want to resolve the situation by specifying version boundaries manually, or by opting not to use the incoming dependency at all if the version conflict was irreconcilable.</p>
<p>I think I've said all I have to say on the topic; I'll accept whatever the verdict is.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:18:06 UTC
    </footer>
</body>
</html>
