<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Configurable project virtual environment paths (e.g., for Docker) - astral-sh/uv #6669</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Configurable project virtual environment paths (e.g., for Docker)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/6669">#6669</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2024-08-27 02:45
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-27 02:45</div>
            <div class="timeline-body"><p><em>No description provided.</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @zanieb by @charliermarsh on 2024-08-27 02:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @zanieb on 2024-08-27 11:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gbdlin">@gbdlin</a> on 2024-08-27 23:50</div>
            <div class="timeline-body"><p>Currently <code>uv</code> uses <code>.venv</code> directory inside the project to store a virtualenv. This is not compatible with all usage scenarios, for example with Docker used for local development with bind mount for project directory, virtualenv will be taken from the host instead of one built inside the docker image. This causes some problems, especially when packages installed in the host system are not compatible with ones inside docker and user wants to access <code>uv</code> both from inside and outside of the docker image.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-28 00:07</div>
            <div class="timeline-body"><p>@gbdlin</p>
<blockquote>
<p>for example with Docker used for local development with bind mount for project directory, virtualenv will be taken from the host instead of one built inside the docker image</p>
</blockquote>
<p>This is solvable though https://docs.astral.sh/uv/guides/integration/docker/#developing-in-a-container</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yasserfarouk">@yasserfarouk</a> on 2024-08-28 01:39</div>
            <div class="timeline-body"><p>Even though there is a solution for this need using docker, I think it is still helpful to have a way to configure the path for creating the .venv in uv. For example, I prefer to keep all my venvs under a folder in the home directory (i.e. <code>~/.myvenvs</code> ) to avoid cluttering my project code folders with <code>.venv</code> folders which tend to increase the size of the projects folder <code>~/code/projects</code> considerably. This is useful for syncing this folder across machines which I need when working with multiple servers. There are solutions to ignore .venv folders but it would be much better if they do not exist at all.
Moreover, sometimes, it may beneficial to have multiple projects sharing the same venv when they work in conjunction for a single solution that will end up being deployed together.
Also, it seems not so difficult to add this feature anyway. The responsiblity for making sure no name-conflicts can arise can be the user's. For example, if the path already exists when uv is trying to create the venv, it can just fail.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-28 02:18</div>
            <div class="timeline-body"><p>@yasserfarouk Thanks for sharing. That's also discussed in #1495</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gbdlin">@gbdlin</a> on 2024-08-28 09:23</div>
            <div class="timeline-body"><p>@zanieb</p>
<blockquote>
<p>This is solvable though https://docs.astral.sh/uv/guides/integration/docker/#developing-in-a-container</p>
</blockquote>
<p>Unfortunately, this is a workaround not a solution, as it has some drawbacks.</p>
<p>Solution with anonymous mount for .venv directory causes a rebuild of virtualenv on first use of command with docker compose, as it fully masks the original one created inside the docker image. It is desirable to use the exact virtualenv that was included in the image to have environment as close to the production one as possible.</p>
<p>Solution with <code>watch</code> requires the newest docker compose + on some platforms has a performance penalty, as it relies on watching for file changes instead of using a native bind mount of the file system.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/terabitti">@terabitti</a> on 2024-08-28 11:15</div>
            <div class="timeline-body"><p>Correct me if I’m wrong, but <code>watch</code> is only 1-way sync. You can’t run something like <code>uv add</code> from a container. The same problem occurs when running some scripts that needs to write in to your project’s directory (for example Django’s <code>makemigrations</code> or <code>makemessages</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-28 13:12</div>
            <div class="timeline-body"><p>@gbdlin I don't think this is true</p>
<blockquote>
<p>Solution with anonymous mount for .venv directory causes a rebuild of virtualenv on first use of command with docker compose, as it fully masks the original one created inside the docker image. It is desirable to use the exact virtualenv that was included in the image to have environment as close to the production one as possible.</p>
</blockquote>
<p>It inherits the content from the image. I tested this case explicitly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-28 13:13</div>
            <div class="timeline-body"><blockquote>
<p>You can’t run something like uv add from a container. The same problem occurs when running some scripts that needs to write in to your project’s directory (for example Django’s makemigrations or makemessages).</p>
</blockquote>
<p>Interesting, good to know. I'd say a bind mount is what you're looking for then.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gbdlin">@gbdlin</a> on 2024-08-28 13:42</div>
            <div class="timeline-body"><p>@zanieb</p>
<blockquote>
<p>It inherits the content from the image. I tested this case explicitly.
With <code>watch</code> yes, with <code>volume</code> no. It will build the virtualenv again in such case, as <code>.venv</code> will be empty. It'll be fetched from the existing volume after container restarts, unless you clear volumes, but it's still a separately built environment outside of the docker build process.</p>
</blockquote>
<p>You can check it out this way: make sure all volumes for the container are cleared, build the image with <code>docker build</code> or <code>docker compose build</code>, change project requirements by removing or modifying anything in a way you can check if it's installed from the old or new file, run the container with volumes attached, without rebuilding it, check the state of <code>.venv</code> directory. If <code>uv</code> command was run before you can access the container, you'll see <code>.venv</code> with updated requirements. If it didn't run, <code>.venv</code> directory will be empty.</p>
<p>Using <code>watch</code> works well, but as terabitti mentioned, it is only done in one direction + has performance issues on some platforms.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-28 13:52</div>
            <div class="timeline-body"><p>I feel like it's this simple:</p>
<pre><code>❯ docker volume ls
DRIVER    VOLUME NAME
❯ docker run \
    --rm \
    --volume .:/app \
    --volume /app/.venv \
    --publish 8000:8000 \
    -it \
    $(docker build -q .) \
    uv sync
Resolved 28 packages in 0.97ms
Audited 27 packages in 0.12ms
</code></pre>
<p>Here I run the container with a bind mount and anonymous volume and run <code>uv sync</code>. Note there's nothing to do — all of the requirements are in the directory from the image build.</p>
<p>Similarly, you can see <code>.venv</code> is <em>not</em> empty.</p>
<pre><code>❯ docker run \
    --rm \
    --volume .:/app \
    --volume /app/.venv \
    --publish 8000:8000 \
    -it \
    $(docker build -q .) \
    ls -lah .venv
total 24K
drwxr-xr-x  4 root root 4.0K Aug 28 13:48 .
drwxr-xr-x 14 root root  448 Aug 28 13:45 ..
-rw-r--r--  1 root root    1 Aug 27 01:46 .gitignore
-rw-r--r--  1 root root   43 Aug 27 01:46 CACHEDIR.TAG
drwxr-xr-x  2 root root 4.0K Aug 28 13:48 bin
drwxr-xr-x  3 root root 4.0K Aug 28 13:48 lib
lrwxrwxrwx  1 root root    3 Aug 27 01:46 lib64 -&gt; lib
-rw-r--r--  1 root root  137 Aug 27 01:46 pyvenv.cfg
</code></pre>
<blockquote>
<p>run the container with volumes attached, without rebuilding it, check the state of .venv directory. If uv command was run before you can access the container, you'll see .venv with updated requirements. If it didn't run, .venv directory will be empty.</p>
</blockquote>
<p>If you don't rebuild the image, it won't reflect <code>pyproject.toml</code> changes in the environment until you run a <code>uv</code> command in it. That's the whole point — the virtual environment isn't mounted from the host to the container.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gbdlin">@gbdlin</a> on 2024-08-28 15:01</div>
            <div class="timeline-body"><p>My bad, you are indeed right. Looks like my understanding of anonymous volumes was wrong. Thank you!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/edmorley">@edmorley</a> on 2024-08-29 14:00</div>
            <div class="timeline-body"><p>Is this a dupe of #5229?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-29 16:36</div>
            <div class="timeline-body"><p>@edmorley sort of. If I put on my pedantic hat, this is about configuring the path of the project's virtual environment and the other one is about allowing <code>uv sync</code> to target arbitrary virtual environments and the discussion there seems to focus on using <code>VIRTUAL_ENV</code> to target the active environment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @zanieb on 2024-09-03 17:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @zanieb on 2024-09-03 17:52</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 04:47:40 UTC
    </footer>
</body>
</html>
