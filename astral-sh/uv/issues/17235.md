```yaml
number: 17235
title: "The term 'package' is problematically overloaded"
type: issue
state: open
author: amluto
labels:
  - documentation
assignees: []
created_at: 2025-12-24T14:39:12Z
updated_at: 2026-01-06T17:19:39Z
url: https://github.com/astral-sh/uv/issues/17235
synced_at: 2026-01-10T01:57:37Z
```

# The term 'package' is problematically overloaded

---

_Issue opened by @amluto on 2025-12-24 14:39_

I've been using Python for many years, but I only started doing anything involving modern Python packages recently.  And I wasted a whole bunch of time being rather confused, and I think almost all of the confusion stems from the following issue that I would argue is a substantial defect in the entire Python packaging system:

A) The noun "package" obviously means the thing that the Python language means by a package: a directory that contains `__init__.py` and that can be imported (or, because it's the modern world, a "namespace package" that does not contain `__init__.py`).  This is fairly ingrained: It's [in the tutorial](https://docs.python.org/3/tutorial/modules.html#packages), there's a mechanism called `__package__`, etc.

B) The noun "package" sometimes means a unit of Python packaging, which is, in the modern world, something that contains a `pyproject.toml`, can be uploaded to the (sigh) Python _package_ index, can be built into a wheel, etc.

The latter is variously called a "project" or a "package", and it kind of seems like the entire Python packaging community is confused as to what it's called.  And it causes a lot of confusion.  For example, it's very common for packages (A) to have underscores in their names (and the obviously can't contain hyphens), but it's also very common for projects on PyPI to have hyphens in their names, and underscores seem to be discouraged.  I wasted a bunch of time trying to figure out what the relationship was between the `name =` thing in `pyproject.toml` and the name of the package that I'm packaging.

To be fair to uv, uv inherited this mess from everything that came before.  But uv seems to be trying to make Python packaging excellent, and I think it could do better.

uv _mostly_ uses the term "project" to describe the thing that is defined by a `pyproject.toml`, but even uv's docs and the CLI itself perpetuate the problem a bit.  For example, [the project guide](https://docs.astral.sh/uv/guides/projects/#managing-dependencies) says:

> To remove a package, you can use uv remove:
> 
> 
> $ uv remove requests
> To upgrade a package, run uv lock with the --upgrade-package flag:
> 
> 
> $ uv lock --upgrade-package requests
> The --upgrade-package flag will attempt to update the specified package to the latest compatible version, while keeping the rest of the lockfile intact.

Oof.  I mostly read the uv docs while getting started in the modern world, and I don't blame myself for getting confused. After all, I was writing a new package called `lutron_integration`, but I saw that the everyone seems to name their project with hyphens, so I typed `name = "lutron-integration"`, but here are the docs effectively telling me that, if another project wanted to upgrade the _package_, they would type, well, not `uv lock --upgrade-package requests` because this thing isn't called `requests`, but what do they type?  Is it `uv lock --upgrade-package lutron_integration` (hint: doesn't work) or is it `uv lock --upgrade-package lutron-integration`?  But the _package is not and cannot be called lutron-integration_.  This gets really confusing when working with abominations like [pycryptodomex](https://pypi.org/project/pycryptodomex/), which does not contain a Python package with a name that particularly resembles "pycryptodomex".

Amusingly, my attempts to get a major LLM to explain what's going on failed -- I think they're confused too.

So here's my request to the uv team: please try to make this better.

Perhaps you could consistently call the units of packaging something other than "package."  "project" might be a good choice.  Maybe improve the docs to very clearly state that `name =` in `pyproject.toml` is the name of the _project_, which may or may not be the name of any particular package.  Workspace projects that don't contain any packages except in subprojects have names (because the existing specs require it), but maybe the docs could clarify that you need to name the _project_ even if it contains no packages.

And here's the painful part: maybe consider deprecating everything in the CLI that contains the word "package"?  Because `uv lock --upgrade-package` may or may not upgrade a package, but if it upgrades a package, that's purely a side effect of upgrading a thing that the current project depends on, and those things are not _packages_.  If I do `uv lock --upgrade-package lutron-integration`, I am upgrading my depedency and I am only indirectly upgrading the package `lutron_integration`.  Maybe it could be spelled `uv lock --upgrade-dependency` or `uv lock --upgrade-project`?

(As an aside, I assume that uv's dependency solver does not gracefully handle the case where two differently-named dependencies each provide non-namespace packages with the same name and thus provide identically-named `__init__.py` or other files.  I admit I have not tested this.)

---

_Renamed from "[DOC ISSUE *and* CLI ISSUE] The term 'package' is problematically overload" to "[DOC ISSUE *and* CLI ISSUE] The term 'package' is problematically overloaded" by @amluto on 2025-12-24 14:39_

---

_Comment by @amluto on 2025-12-25 03:08_

I found an article about this:

https://packaging.python.org/en/latest/discussions/distribution-package-vs-import-package/

If thatâ€™s the current winning terminology (which is kind of verbose, but whatever), then uv could probably improve its end with just documentation changes.

---

_Comment by @woodruffw on 2025-12-25 18:23_

Yeah, this is a place where Python's packaging terminology is unfortunately overloaded. Here is the taxonomy as I normally see it:

1. A "package" is something that Python's import machinery considers importable. In other words, _inside_ of a packaging context, a "package" is an "import package," whereas outside it's just a "package."
2. A "distribution" is a bundling of one (or more) import packages into a standard distribution container (namely an sdist or bdist). PyPUG calls this a "distribution package" for disambiguation, but _inside_ of a packaging context these also get called "packages."
3. A "project" is (roughly) a directory containing a `pyproject.toml` file. Projects _might_ contain import packages, or they could just be a collection of dependencies and scripts. Projects _might_ also be convertible into distributions, but this isn't a hard requirement either.

In other words: both (1) and (2) are "packages," just in different contexts. 

uv is in the business of managing all three of these, and users often interact with them in overlapping ways (e.g. there are lots of things that users do that are logically _project_ management, but are done towards the end of manipulating an import package or distribution).


> Is it `uv lock --upgrade-package lutron_integration` (hint: doesn't work) or is it `uv lock --upgrade-package lutron-integration`? But the _package is not and cannot be called lutron-integration_. This gets really confusing when working with abominations like [pycryptodomex](https://pypi.org/project/pycryptodomex/), which does not contain a Python package with a name that particularly resembles "pycryptodomex".

I think there are two things here:

1. `--upgrade-package lutron_integration` probably *should* work, since there are [name normalization](https://packaging.python.org/en/latest/specifications/name-normalization/#name-normalization) rules that define that as being equivalent to `lutron-integration`. There might be a good reason why we don't do that at the moment (maybe @zanieb or @konstin has opinions on that?), but in general I'd expect us to normalize/unify package names like that.
2. More generally, this is an example of uv using "package" to mean "distribution package," rather than "import package." This use is context sensitive, but consistent: "import packages" aren't something that can be upgraded, because they don't carry distribution metadata like distribution packages do.

> (As an aside, I assume that uv's dependency solver does not gracefully handle the case where two differently-named dependencies each provide non-namespace packages with the same name and thus provide identically-named __init__.py or other files. I admit I have not tested this.)

Can you provide an example of what you mean? As a rule, import package names do not affect dependency resolution whatsoever (in uv, pip, poetry, and all other Python package installs). The only package name that affects resolution/solving is the distribution package name, which can always diverge from the import package name (as you've observed with `pycryptodomex`).

(More generally, dependency resolution doesn't actually look at `__init__.py` or any source files at all! Dependency resolution only sees distribution metadata, with the nuance that sometimes distribution metadata is generated on-the-fly by a source distribution's build backend.)

Overall, I agree we can probably make this clearer in the uv documentation. We could probably do that by linking to that disambiguation page on PyPUG in more places. However, the fundamental overloading of the term "package" probably isn't something uv can address; it's baked into how all Python packaging tools use "package" context-sensitively to refer to either distributions or importable packages.

---

_Label `documentation` added by @woodruffw on 2025-12-26 15:14_

---

_Renamed from "[DOC ISSUE *and* CLI ISSUE] The term 'package' is problematically overloaded" to "The term 'package' is problematically overloaded" by @woodruffw on 2025-12-26 16:18_

---

_Comment by @woodruffw on 2025-12-26 16:18_

Triage: #8178 has some more context on terminology.

---

_Comment by @violenz on 2025-12-29 03:58_

uv is undeniably a vast improvement from everything that has come prior for python package management.It's astonishing just how good it actually is if you stop and consider the price tag on pythons technical debt.

That being said, my inability to provide a script reference such as "build" or "test" to a package but not have it coexist categorically across all workspaces is mind-blowing.




---

_Comment by @zanieb on 2025-12-29 04:40_

> There might be a good reason why we don't do that at the moment (maybe @zanieb or @konstin has opinions on that?), but in general I'd expect us to normalize/unify package names like that.

As far as I know, we immediately normalize all package names and always do comparisons with the normalized name per the spec. I can't think of a reason it wouldn't work.

> That being said, my inability to provide a script reference such as "build" or "test" to a package but not have it coexist categorically across all workspaces is mind-blowing.

Can you explain what you mean here?

> A "package" is something that Python's import machinery considers importable.

Generally, I think we should just refer to "import packages" as "modules". I don't see any value in overloading the term "package" for this purpose. Maybe there's a good reason I'm not remembering?

---

_Comment by @woodruffw on 2025-12-29 06:05_

> Generally, I think we should just refer to "import packages" as "modules". I don't see any value in overloading the term "package" for this purpose. Maybe there's a good reason I'm not remembering?

Not sure if it's a _good_ reason or not, but module is probably also a little imprecise: `foo.py` is a module but not a package, while `foo/__init__.py` is a package (and a module). 

Then there's `foo/` (with no `__init__.py`), which (I think) is a package but _not_ a module, since it's an implicit namespace package. But that's stretching my memory ðŸ˜… 

Edit: never mind, an empty directory is a module (just one that's also an implicit namespace):

```bash
mkdir notamod
PYTHONPATH=. uv run python

>>> import notamod
>>> notamod
<module 'notamod' (namespace) from ['/Users/william/tmp/notamod', '/Users/william/tmp/notamod']>
```

---

_Comment by @amluto on 2025-12-30 03:19_


> > (As an aside, I assume that uv's dependency solver does not gracefully handle the case where two differently-named dependencies each provide non-namespace packages with the same name and thus provide identically-named **init**.py or other files. I admit I have not tested this.)
> 
> Can you provide an example of what you mean? As a rule, import package names do not affect dependency resolution whatsoever (in uv, pip, poetry, and all other Python package installs). The only package name that affects resolution/solving is the distribution package name, which can always diverge from the import package name (as you've observed with `pycryptodomex`).
> 

https://github.com/amluto/pathological_python_packages

In editable mode, I don't really expect intelligent behavior, since, as far as I know, `uv` isn't contemplating the installed Python files.

But it's easy enough to force non-editable mode. Check this out somewhere, then `uv init` a brand new project outside it and `uv add` the two subprojects from pathological_python_packages manually so you end with with a consumer project like so:

```toml
[project]
...
dependencies = [
    "dist-package-1",
    "dist-package-2",
]

[tool.uv.sources]
dist-package-1 = { path = "../pathological_python_packages/packages/dist_package_1" }
dist-package-2 = { path = "../pathological_python_packages/packages/dist_package_2" }
```

Now `uv sync` (optional) then `uv run python3`.  No errors are reported.  When I tried it, package #1 won:

```
>>> import import_package
>>> import_package.hello()
'Hello from dist-package-1!'
```

I was hoping for at least a warning from `uv sync`.

For added fun, I commented out the `dist-package-1` dependency in `pyproject.toml` and did `uv run python3` and package #1 was still there?!?  Maybe I misunderstand exactly what uv run does.  So I manually did `uv sync`:

```
Resolved 2 packages in 5ms
Uninstalled 1 package in 1ms
 - dist-package-1==0.1.0 (from file:///.../pathological_python_packages/packages/dist_package_1)
```

Okay, but what actually happened?

```
>>> import import_package
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ModuleNotFoundError: No module named 'import_package'
```

Err, that's not right.  `uv sync --reinstall` forces the issue and:

```
>>> import_package.hello()
'Hello from dist-package-2!'
```

I'm not sure exactly what `uv` should do with this kind of poor input, but giving no warnings and giving weird possibly-nondeterminstic and path-dependent behavior here seems impolite.  I assume the wheel installer and uninstaller are nice modern Rust code in `uv` somewhere, and the `.dist-info` directories in `.venv` proudly announce `uv` as the `INSTALLER`.  But maybe there is literally no data structure that maps from filename to the distribution package from which it came?  But even given that this mapping does not exist, the filesystem itself should notice when `uv` tries to create `.venv/lib/python3.12/site-packages/import_package/__init__.py`.

In any case, this is a deliberately silly toy example.  But I think you can make a regrettable non-toy example:

```
uv add pycrypto # eww, ancient unmaintaned source of Crypto, but somehow uv can still install it even on arm64
uv add pycryptodome # more modern source of Crypto
```

and the result can't possibly be good.  And I can imagine innocently picking something like this up via transitive dependencies and getting quite confused as to what's going on.

---

_Comment by @konstin on 2026-01-06 17:19_

Python's definition of a package is ancient, and predates packaging and packaging tooling. The [tutorial](https://docs.python.org/3/tutorial/modules.html#packages) you mentioned was added in 1998 (https://github.com/python/cpython/commit/108943c2163193e13f0c9969cd87276083fd34a0) - That's before the first actual packaging tool, distutils, was started at the end of 1998 (https://web.archive.org/web/20240304172212/https://gerg.ca/blog/post/2013/distutils-history/). distutils was added to the Python standard library in 2000, and setuptools/easy_install were released in 2004.

We use the modern definition of "module" and "package": If you `import` it, it's a module, if you install it, it's package. Where possible, you opt for widely used, cross-ecosystem terminology that provides more clarity.

See also https://github.com/astral-sh/uv/issues/15890

---
