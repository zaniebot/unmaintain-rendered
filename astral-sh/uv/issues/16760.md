```yaml
number: 16760
title: "`uv pip install`: option to only install dependencies of a given package (without package itself)"
type: issue
state: open
author: paveldikov
labels:
  - enhancement
assignees: []
created_at: 2025-11-17T15:06:27Z
updated_at: 2025-12-06T11:31:18Z
url: https://github.com/astral-sh/uv/issues/16760
synced_at: 2026-01-10T01:57:37Z
```

# `uv pip install`: option to only install dependencies of a given package (without package itself)

---

_Issue opened by @paveldikov on 2025-11-17 15:06_

### Summary

# Use case
I am building a container image of my project. I have previously built my project into a wheel.
I am using `uv pip install` to install the wheel into my container.

Currently my process works along the lines of
```
RUN uv pip install /mnt/my-wheel.whl -c /mnt/constraints.txt
```

This creates _one layer_ with everything. I would like to separate it into _two_, in order to be able to beneift from reproducible layer builds, and ultimately deduplicate storage/data xfer on the registry end.

# Example CLI interface
The end result would look something like:
```
RUN uv pip install /mnt/my-wheel.whl --only-deps -c /mnt/constraints.txt
RUN uv pip install /mnt/my-wheel.whl --no-deps
```

# Why not {...}?
**Why not just install `constraints.txt`?** Because it also includes the dev toolchain, and other irrelevant extras.

**Why not use 'proper' lockfiles and `--no-package`?** Maturity. In the long run, I'd be using `uv pip sync` and PEP 751 lockfiles, but I need a stopgap until tooling support is at feature parity with constraints files. I'd need both `pip` and `uv` to support them pretty exhaustively for me to be able to adopt them.

This is also partly why I can't use `uv.lock` -- the format is unique to `uv` and I can't (easily) bootstrap it from `pip`.

**I _could_ use `uv pip compile` in a JIT style**: compiling wheel + constraints into a whittled-down lockfile, that I then modify out-of-band to remove the top-level package. This would work, although it would be quite an inelegant and brittle solution.

### Example

_No response_

---

_Label `enhancement` added by @paveldikov on 2025-11-17 15:06_

---

_Comment by @dwt on 2025-12-02 20:15_

I would also like this, but in the meantime I have worked around this by using `requirements.txt` files for the dependencies, and just installing that in its own layer. Not having to do that would be useful though.

The workaround of generating a dependencies file with `uv pip compile > requirements.txt` file is also valid though, as it is easily scripted.

---

_Comment by @dwt on 2025-12-02 20:20_

And now I just noticed that `uv pip install -r pyproject.toml` does exactly what we want. I think this can be closed.

---

_Comment by @paveldikov on 2025-12-03 10:03_

No, I do not think that would work for my use case -- I do not have access to the project's source code in this context. (The project has been built into a wheel a long time ago by this stage in the pipeline.)

The `uv pip compile` trick _does_ work as mentioned before, but it makes the resulting Containerfile:

1. ridiculously hard to read/troubleshoot (therefore: fragile!)
2. less efficient to execute:
    * I am now running two `uv pip {compile,install}` commands, one after the other (well, one piped into the other, but since `install` waits for `compile` to be done, it's serialised anyway)
    * ...since I am running both commands with `UV_NO_CACHE` (as is standard practice for container builds)...
    * ...this means that I now have 2x the downloads happening from the package index

(I could mitigate 2) by dropping `UV_NO_CACHE` and instead mounting a dedicated `tmpfs` cache... this would exacerbate 1) )

---

_Comment by @dwt on 2025-12-06 11:27_

So... you do have a wheel, and only want to install its dependencies? Basically like `--no-deps`, but `--only-deps`?

On the other hand, why not bring in the pyproject.toml as artifact into the docker file? It probably is way easier than getting the `pip compile` thing working.

---
