<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add option to uv export to obtain version in workspace packages - astral-sh/uv #11250</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add option to uv export to obtain version in workspace packages</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/11250">#11250</a>
        opened by <a href="https://github.com/ivan94fi">@ivan94fi</a>
        on 2025-02-05 16:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ivan94fi">@ivan94fi</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<h1>Description</h1>
<p>We have a monorepo project, which is composed of several python packages. We use uv as project manager and we use a private pypi server where our wheels are published. When creating the docker image for our product we install the packages from the private pypi server, so we need exact versions, and we would like to avoid having to mount the sources, to be sure to have the published version in the final docker image.</p>
<h1>Request</h1>
<p>We would like to obtain package versions also for workspace members whe using <code>uv export --frozen</code>, so that later we can just install the generated requirements file and get packages from the pypi server.</p>
<h1>Current situation:</h1>
<p>Command:
<code>uv export --frozen --no-hashes</code></p>
<p>Output:</p>
<pre><code>-e ./packages/company.package1
-e ./packages/company.package2
-e ./packages/company.package3
-e ./packages/company.package4
accelerate==1.1.0
annotated-types==0.7.0
anyio==4.6.2.post1
certifi==2024.8.30
charset-normalizer==3.4.0
click==8.1.7
.
.
.
</code></pre>
<h3>Example</h3>
<p>Here we use an hypothetical <code>--emit-workspace-with-versions</code> flag, to emit the workspace members as &quot;remote&quot; dependencies.</p>
<p>Command:
<code>uv export --frozen --emit-workspace-with-versions --no-hashes</code></p>
<p>Output:</p>
<pre><code>company.package1=1.3.2
company.package2==0.3.2
company.package3==1.0.0
company.package4==3.2.2
accelerate==1.1.0
annotated-types==0.7.0
anyio==4.6.2.post1
certifi==2024.8.30
charset-normalizer==3.4.0
click==8.1.7
.
.
.
</code></pre>
<p>The versions in the workspace's members here are the ones taken from the <code>pyproject.toml</code> file of each member at the time the command is run.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @ivan94fi on 2025-02-05 16:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ivan94fi">@ivan94fi</a> on 2025-02-24 13:10</div>
            <div class="timeline-body"><p>Any updates on this?</p>
<p>Thank you</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2025-03-03 21:32</div>
            <div class="timeline-body"><p>We have a similar use case, and I believe this sort of setup is very common among organizations.</p>
<p>I am curious why it seems like all workspace/monorepo examples completely ignore this use case?</p>
<p>Can you provide some insight on this, @konstin?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-03 22:03</div>
            <div class="timeline-body"><p>I think this would be reasonable to support, though I'm not sure what it would look like. Perhaps <code>--no-sources</code> should do this already?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2025-03-03 22:20</div>
            <div class="timeline-body"><blockquote>
<p>I think this would be reasonable to support, though I'm not sure what it would look like. Perhaps <code>--no-sources</code> should do this already?</p>
</blockquote>
<p>From my experience it doesn't, or if it does, I would need to know how to apply it correctly.</p>
<p>I have made a small minimalist example of the problem <a href="https://github.com/tpanum/multi-pkg-uv">here</a>. I have tried very combinations of <code>uv build</code> and <code>uv export</code> and I can't seem to get anything remotely useful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-03 23:32</div>
            <div class="timeline-body"><p>Yeah <code>--no-sources</code> does not today, that was a comment on changing that behavior instead of adding a new toggle. Sorry for the confusion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-03 23:39</div>
            <div class="timeline-body"><p>I don't quite follow why <code>uv build</code> is being used, could you talk about that a bit?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2025-03-04 07:21</div>
            <div class="timeline-body"><blockquote>
<p>I don't quite follow why <code>uv build</code> is being used, could you talk about that a bit?</p>
</blockquote>
<h2>Use case</h2>
<p>I think a very common use case for many companies is to have a set of packages that <em>can</em> be interlinked. As an example, having some sort of <code>core</code>-package which is a dependency in many downstream internal packages. Each package (both <code>core</code> and downstream packages) are intended to be published to some internal package index.</p>
<p>Having multiple interconnected packages in a single repository works <strong>fantastic locally</strong> with <code>uv</code> (both workspace and non-workspace settings, thanks to <code>uv.sources</code>). However, when you have the scenario of wanting to publish your set of changed packages, <code>uv</code> (from my experience) ignores all version information about the packages. To reference my example:</p>
<p>We have a package named <code>pkg_b</code> which depends on <code>pkg_a</code> (in the same repository -- see <a href="https://github.com/tpanum/multi-pkg-uv">my repository</a> as an example). Now I locally change some code in <code>pkg_a</code>, and locally verify <code>pkg_b</code> is working (e.g. due to <code>uv.sources</code> creating directory links and having <code>--editable</code>).</p>
<p>Now I need to publish my changes, which mean the following (<em>for simplicity assume we just bump the versions manually in respective <code>pyproject.toml</code> files</em>):</p>
<ul>
<li>A new version of <code>pkg_a</code> needs to be published with the code changes we made.</li>
<li>A new version of <code>pkg_b</code> needs to be published, that requires a new minimum version of <code>pkg_a</code>.</li>
</ul>
<p>Having this sort of workflow easily accessible I think is a core feature, because hardly anyone needs to develop packages that (i) does not need sharing, or (ii) loves extremely loose coupling. I have tried various solutions, but I have yet to find some way of doing this with <code>uv</code>, yielding the workspace feature not very useful to me.</p>
<h2>Your original question</h2>
<p>The <code>uv build</code> serves as a pre-step of checking which sort of package (and version requirements) is being built and what version requirements are set in the wheel. I believe I came across some other thread that mentioned versions in the built packages follows <code>PEP440</code> and thus only incorporate version information specified in the <code>pyproject.toml</code>.</p>
<p>I completely honor the desire to be <code>PEP</code>-compliant, but I believe it creates this paradoxical scenario where your local environment is tightly coupled, and your remote packages are (undesirable) loosely coupled. I think having some sort of feature to enable the ability to mimic the tight coupling of the local environment to remote packages is highly desirable.</p>
<h2>What I have tried</h2>
<p>Ideally I hope the feature and workflow I am describing can already be handled using <code>uv</code>. However, I have not been able to establish a feasible solution. I tried looking into <code>uv export</code> (and its various flags) but I couldn't get it to yield any version information for other packages in the same repository.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2025-03-04 08:32</div>
            <div class="timeline-body"><p>I think this issue is similar or related to these:</p>
<ul>
<li>#8949</li>
<li>#8729: @konstin provides an example in a comment of how to use <code>uv export</code>, but in my experience it does not yield any package version information in the generated requirements.txt (using <code>0.6.2</code>)</li>
<li>#9811</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-03-04 13:35</div>
            <div class="timeline-body"><p>Thank you for the example repo!</p>
<blockquote>
<p>We have a package named <code>pkg_b</code> which depends on <code>pkg_a</code> (in the same repository -- see <a href="https://github.com/tpanum/multi-pkg-uv?rgh-link-date=2025-03-04T07%3A21%3A25.000Z">my repository</a> as an example). Now I locally change some code in <code>pkg_a</code>, and locally verify <code>pkg_b</code> is working (e.g. due to <code>uv.sources</code> creating directory links and having <code>--editable</code>).</p>
<p>Now I need to publish my changes, which mean the following (<em>for simplicity assume we just bump the versions manually in respective <code>pyproject.toml</code> files</em>):</p>
<pre><code>* A new version of `pkg_a` needs to be published with the code changes we made.

* A new version of `pkg_b` needs to be published, that requires a new minimum version of `pkg_a`.</code></pre>
<p>Having this sort of workflow easily accessible I think is a core feature, because hardly anyone needs to develop packages that (i) does not need sharing, or (ii) loves extremely loose coupling. I have tried various solutions, but I have yet to find some way of doing this with <code>uv</code>, yielding the workspace feature not very useful to me.</p>
</blockquote>
<p>I'm trying to figure out the exact workflow that needs to be exposed. Would let's say we had this hypothetical workflow, would that do what you need?</p>
<pre><code>uv build --package pkg_a 
uv publish --package pkg_a
uv upgrade --package pkg_b pkg_a --lower-bound # Upgrade the lower bound for pkg_a, but only in pkg_b's pyproject.toml
uv build --package pkg_b 
uv publish --package pkg_b
</code></pre>
<p>I'm trying to figure out whether <code>uv export</code> needs to be involved here, or if this is a case of the upgrade workflow that bumps lower bounds.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ivan94fi">@ivan94fi</a> on 2025-03-04 15:49</div>
            <div class="timeline-body"><p>Hi,</p>
<p>We internally wrote a script that does exactly that: bump all the workspace packages in the right order and publish to our pypi server.</p>
<p>However export is needed at deployment time, where we need to install from a published wheel, not from sources (in the dockerfile of our product we do not want to clone the repo, we just want to use the published package at the right version from our pypi server). So we need the exact dependencies of our internal packages pinned when exporting, as it already happens for external packages.</p>
<p>Right now I am build a requirements.txt with a script by merging uv export with the versions of our packages manually parsed from uv.lock file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2025-03-06 10:07</div>
            <div class="timeline-body"><blockquote>
<p>Thank you for the example repo!
...
I'm trying to figure out the exact workflow that needs to be exposed. Would let's say we had this hypothetical workflow, would that do what you need?</p>
<pre><code>uv build --package pkg_a 
uv publish --package pkg_a
uv upgrade --package pkg_b pkg_a --lower-bound # Upgrade the lower bound for pkg_a, but only in pkg_b's pyproject.toml
uv build --package pkg_b 
uv publish --package pkg_b
</code></pre>
<p>I'm trying to figure out whether <code>uv export</code> needs to be involved here, or if this is a case of the upgrade workflow that bumps lower bounds.</p>
</blockquote>
<p>I think your series of commands are precisely what is desired, however I think the problem can be thought of more conceptually.</p>
<h2>Workspaces</h2>
<p>From my understanding workspaces in <code>uv</code> is inspired by Cargo. I am unfortunately unfamiliar with Cargo and how workspaces in Cargo work, so I am unsure about best practices and the precise design choices behind them. However, when talking <code>uv</code> workspaces, I think they are currently very limited by the fact that <strong>the coupling between packages in a typical development environment is very difficult to replicate in a package-based production environment</strong>. In essence, this is what I think this issue here tries to describe at its core.</p>
<p>I think workspaces are highly desirable in a setting where you have a set of interconnected packages where you want <em>certainty</em> and <em>robustness</em> about how they interact (which is also reflected by having a shared lockfile). As mentioned previously, you have high certainty about this in a development environment, but as soon you shift to distributing the packages (in current version of <code>uv</code>) you loose all kinds of certainty and you need to develop custom scripts to achieve some sort of certainty (as mentioned by @ivan94fi).</p>
<p>Given that workspaces are already a non-PEP initiative, I think it would be highly desirable if <code>uv</code> sought out to replicate this certainty at publish-time. So basically, the problem is:</p>
<ul>
<li>Given I want to publish all packages in my workspaces, how can I ensure that the certainty of package states in my development environment are identical to my package-based production environment?</li>
</ul>
<p>To put it a bit boldly, I think workspaces are almost irrelevant without this feature, I think the amount of issues related to this topic also indicate that it is highly desirable by the community. I think there are multiple ways of solving this problem, and which one is the most ideal in a <code>uv</code> setting, I am unsure of.</p>
<h2>Back to the question</h2>
<p>Beyond the precise series of commands, I think it would be desirable if something along those lines could be achieved automatically. Basically:</p>
<ul>
<li>Detect which packages to update, and in which order</li>
<li>Detect packages needs to update their dependencies</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fatmumuhomer">@fatmumuhomer</a> on 2025-08-20 11:59</div>
            <div class="timeline-body"><p>I just wanted to comment that the scenario described in the original issue is exactly the problem that I am trying to solve for our implementation of uv.</p>
<p>In our scenario, we have a set of interconnected packages in a monorepo and a large team of data scientists who want to work from the latest version of the source for each of those. We have those packages included as workspace packages.</p>
<p>Our deployment process installs from a private PyPi repo using an exported requirements.txt so I need those workspace packages pinned by version and not as editable source.</p>
<p>The only &quot;workaround&quot; is to update the workspace pyproject.toml at runtime when we export the requirements.txt where we comment out the workspace packages from tool.uv.sources and tool.uv.workspace. The packages are already included as dependencies in the workspace pyproject.toml. This seems to work and includes those packages pinned to a version.</p>
<p>Being able to do this via the export command automatically would be really useful!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:29:44 UTC
    </footer>
</body>
</html>
