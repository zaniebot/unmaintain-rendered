```yaml
number: 8862
title: uv run does not use env-var in .env-file
type: issue
state: closed
author: woutervh
labels:
  - question
assignees: []
created_at: 2024-11-06T11:45:17Z
updated_at: 2025-12-02T10:43:36Z
url: https://github.com/astral-sh/uv/issues/8862
synced_at: 2026-01-10T01:57:20Z
```

# uv run does not use env-var in .env-file

---

_Issue opened by @woutervh on 2024-11-06 11:45_

uv --version
uv 0.4.30 (61ed2a236 2024-11-04)


Testing .env-file support, but I can't get this to work.
Using private indexes still remains painful.

```
> cat .env
>>>UV_EXTRA_INDEX_URL="https://__token__:<TOKEN>@gitlab.com/api/v4/groups/<PROJECT_ID>/-/packages/pypi/simple"


> uv run  --with <mypackage>   --verbose --env-file .env
DEBUG uv 0.4.30 (61ed2a236 2024-11-04)
DEBUG Read environment file at: `.env`
DEBUG No project found; searching for Python interpreter
DEBUG Searching for default Python interpreter in managed installations, system path, or `py` launcher
DEBUG Searching for managed installations at `...\uv\python`
DEBUG Found managed installation `cpython-3.12.5-windows-x86_64-none`
DEBUG Found `cpython-3.12.5-windows-x86_64-none` at `....\uv\python\cpython-3.12.5-windows-x86_64-none\python.exe` (managed installations)
DEBUG Using Python 3.12.5 interpreter at: ...\uv\python\cpython-3.12.5-windows-x86_64-none\python.exe
DEBUG At least one requirement is not satisfied in the base environment: <mypackage>
DEBUG Creating ephemeral environment
DEBUG Syncing ephemeral requirements
DEBUG Caching via interpreter: `...\uv\python\cpython-3.12.5-windows-x86_64-none\python.exe`
DEBUG Using request timeout of 30s
DEBUG Solving with installed Python version: 3.12.5
DEBUG Solving with target Python version: >=3.12.5
DEBUG Adding direct dependency: <mypackage>*
DEBUG No cache entry for: https://pypi.org/simple/<mypackage>/
DEBUG No netrc file found
DEBUG Searching for a compatible version of <mypackage> (*)
DEBUG No compatible version found for: <mypackage>
  × No solution found when resolving `--with` dependencies:
  ╰─▶ Because <mypackage> was not found in the package registry and you require <mypackage>, we can conclude that your requirements are unsatisfiable.

```







---

_Comment by @zanieb on 2024-11-06 15:41_

We don't read configuration for uv itself from `.env` files, the variable are passed to the subcommand called by `uv run`

---

_Label `question` added by @zanieb on 2024-11-06 15:41_

---

_Assigned to @charliermarsh by @zanieb on 2024-11-06 15:41_

---

_Comment by @laermannjan on 2024-11-12 15:34_

Hooking on to this, since I'm also testing `.env` support and am experiencing inconsistencies. I'm not sure whether I might be misunderstanding this feature.

```bash
$ uv version
uv 0.5.1 (Homebrew 2024-11-08)
```

From the documentation and https://github.com/astral-sh/uv/pull/8263 I expected that `uv run [COMMAND]` would export the env vars from `<project_root>/.env` if that file exists and pass them to the `[COMMAND]` (I assume that this command can be any shell command).

I've created a fresh project, added a `.env` and a simple script:

```bash
uv init test

cd test

cat <<EOF > .env
FOO=bar
EOF

cat <<EOF > test.py
import os
print(os.environ.get('FOO'))
EOF
```

The steps I've taken that I had issues with

1. `uv run -- echo $FOO` displays an empty line
2. `uv run --env-file .env -- echo $FOO` displays an empty line (contrary to what the docs indicate here at https://docs.astral.sh/uv/configuration/files/#env
3. `uv run test.py` displays `None`
4. `uv run --env-file .env test.py` displays `bar` as I would have expected for all of the above

Furthermore, I tried adding a private index (which is what led me down this path) by adding to my `pyproject.toml`
```toml
dependencies = [
    "secret-project==1.2.3"
]

[[tool.uv.index]]
name = "secret-project"
url = "https://secret-project.com/simple"
```
and the credentials to my `.env`:
```bash
UV_INDEX_SECRET_PROJECT_USERNAME=myusername
UV_INDEX_SECRET_PROJECT_PASSWORD=mypassword
```

(as the previous steps created the venv I deleted it and cleaned the cache before moving on: `rm -rf .venv && uv cache clean`)

1. `uv sync` fails with a `error: Failed to prepare distributions` caused by 401 authentication error when trying to fetch `secret-project` - I would have really liked this to work out of the box, but expected this to fail due to how the `.env` support was described.
2. `uv run uv sync` and `uv run -- uv sync` both fail for the same reason as `1.`. which I didn't expect.
3. `uv run` fails for the same reason as `1.` and `2.`
4. `uv run --env-file .env` creates the venv successfully and install `secret-project` from the private index. Note that if you had run `uv run --env-file .env -- echo $UV_INDEX_SECRET_PROJECT_USERNAME` instead, it would have also successfully created the venv, but not display the env var. 


So it seems to me that the env vars aren't passed to the subprocess as described and `uv run` doesn't load `.env` by default. Also it seems I cannot install/update my deps with `uv sync` in my case, but only with the workaround of using `uv run --env-file .env` to leverage it's automatic syncing.


Additionally, I would have expected `uv sync` to respect `.env` as well. Since I am defining the index in the project's `pyproject.toml`, I would assume that most people would like to define their credentials in the `.env` along with other their tokens. Just my two cents.

Please, let me know if what I described above is actually working as intended and I'm just misusing `uv`.

---

_Comment by @charliermarsh on 2024-11-12 17:08_

Thanks for your comment. A few clarifications:

1. `uv run --env-file .env -- echo $FOO` can never work -- it's a mistake in the docs. Your shell evaluates `$FOO` there before it's passed to uv, so it's just not possible for uv to replace it in that context.
2. We don't load `.env` files by default. You must pass `--env-file`. (Do the docs say we read them by default somewhere?)
3. The `.env` file only affects the command that `uv run` runs. It doesn't affect uv itself. We may expand that in the future, but the intent in this initial implementation is that uv itself shouldn't be configured by `.env` files. So things like `UV_INDEX_SECRET_PROJECT_PASSWORD` wouldn't have any effect, but something like configuring your database port via a `PORT` variable would.

---

_Comment by @laermannjan on 2024-11-13 09:40_

Thanks for the quick response.

> We don't load .env files by default. You must pass --env-file. (Do the docs say we read them by default somewhere?)

In https://github.com/astral-sh/uv/pull/8263 which is referenced in the changelog it says:

> The behaviour is as follows:
>
> 1. uv run file.py executes file.py using the .env (if it exists).
> 2. [...]
> 3. uv run --no-env-file file.py skips reading the .env file.

The docs say:
>To disable dotenv loading (e.g., to override UV_ENV_FILE or the --env-file command-line argument), set the UV_NO_ENV_FILE environment variable to 1, or pass the--no-env-file flag to uv run.

Which I interpreted as loading is enabled by default, so I can disable it like this, but I realize I probably didn't read that sentence carefully enough.

And in the linked PR's thread there are talks about this being an opt-out feature. 

So all of this made me assume it would load `.env` files by default and I had to opt-out via `UV_NO_ENV_FILE` or `--no-env-file`. Having to specify `--env-file` or `UV_ENV_FILE` makes it opt-in, doesn't it?

-------
> The .env file only affects the command that uv run runs. It doesn't affect uv itself. We may expand that in the future, but the intent in this initial implementation is that uv itself shouldn't be configured by .env files. So things like UV_INDEX_SECRET_PROJECT_PASSWORD wouldn't have any effect, but something like configuring your database port via a PORT variable would.

Thanks for clarifying. Having read this, I still don't understand why `uv run --env-file .env -- uv sync` wouldn't work, isn't `uv sync` the command being run by `uv run` and should be affected by the `.env` loading? Or put differently, why would `uv run`'s auto-sync work, but not the one invoked by me manually in `uv run --env-file .env -- uv sync`?



---

_Comment by @charliermarsh on 2024-11-13 16:42_

Thanks @laermannjan. So I think the docs are generally correct -- #8263 initially merged with the behavior as opt-out, but we changed it to opt-in prior to releasing. I can see how it's confusing.

> Having read this, I still don't understand why `uv run --env-file .env -- uv sync` wouldn't work...

I think I _would_ expect this to work. Let me try it.


---

_Comment by @charliermarsh on 2024-11-13 16:44_

In my testing `uv run --env-file .env -- uv sync --verbose` does work as expected. I set `UV_INDEX_URL=https://test.pypi.org` in `.env`, and the verbose logging indicates that it read from the Test PyPI.

---

_Comment by @laermannjan on 2024-11-19 13:50_

Sorry for the late reply.

This does work as expected. I actually had set `UV_INDEX_SECRET_PROJECT_PASSWORD=$ANOTHER_ENV_VAR`, which caused the 401 error and made me believe the `.env` file wasn't loaded .`ANOTHER_ENV_VAR` was defined further up the `.env` file, which worked fine with other tools I had used, but apparently not with `uv`. 

My bad. Thanks for troubleshooting with me.

---

_Comment by @charliermarsh on 2024-11-19 14:04_

No prob, thanks for following up.

---

_Referenced in [astral-sh/uv#9940](../../astral-sh/uv/issues/9940.md) on 2024-12-16 22:08_

---

_Comment by @thanhlq on 2025-06-07 02:49_

For me, I got a very strange problem, when I changed variable in .env file, the uv does not reload the changed variable after a re-run i.e. uv run --env-file .env python app/api

I workarounded by: open a new terminal -> OK

The point is: the same problem if I use dotenv

---

_Comment by @zanieb on 2025-06-07 04:50_

@thanhlq sounds like the variable is set in your shell? We prefer variables in the current environment over environment files, so, e.g., if you do `export FOO=1` that will always override `FOO` defined in a `.env` file.

---

_Comment by @LazoYoung on 2025-09-01 01:37_

I'm honestly curious why uv took the opt-in approach for loading .env while Docker and others read them by default.
IMO having to run `uv run --env-file .env -- uv sync` just to sync the project with private registry doesn't look convenient at all.

---

_Comment by @charliermarsh on 2025-09-01 02:46_

I don't think it's that common for tools that can run arbitrary code to read `.env` credentials by default. Node and Deno do not, for example. Docker doesn't either -- you might be thinking of Docker Compose? Which is very different, since it's just injecting variables into a declarative build file.

---

_Comment by @quasipedia on 2025-09-25 13:09_

I'm no expert about what is common or not out there, but as a regular Joe, I find the opt-in for this feature _very_ (and I really mean: _very_, I spent 20 minutes "debugging why it did not work"!) counter-intuitive.

For one I find this pattern **completely redundant**. I posit that the possibility to load environment variables from a `.env` file is _already_ per se opt-in: no `.env` file → no env variables loaded. Having to _both_ create the file _and_ pass it to the command, is like having to tell somebody something and then having to reapeat it again 30 seconds later because they were not paying attention. Simply annoying and a waste of time.

For seconds I find it **adds user friction**. My expectation is to set-up my many projects only once and then run the same set of standardised commands (like `uv run main`) on all of them.  I do not want having to remember for each project I maintain whether or not that particular one needs a set of environment variables or not.

For thirds, if the intent is to prevent the accidental running of a series of variables meant for a different environment, I find that this patterns **adds absolutely no value**.  If for some project an opt-in strategy is really needed, a much more semantically meaningful way to do that would be to name the env file something else than `.env`.  Call your file `.env-production` instead, this way it will never be loaded by default and you'll be forced to pass it as a param when you are in production.

Just my 2¢.

---

_Comment by @ductri on 2025-11-15 20:50_

I completely agree with @quasipedia . This is a very poor design choice.
This askes users to repeatedly "activate" certain environment variables every time they resume their work on the project.
And I believe that a large number of projects need customize environment variables.

Why wouldn't we just ask users to declare these env variables once, forget about them, and run everything via the standard `uv run`?


---

_Referenced in [astral-sh/uv#16926](../../astral-sh/uv/issues/16926.md) on 2025-12-02 10:42_

---

_Comment by @zanieb on 2025-12-02 10:43_

I'm going to close this in favor of #16926 which has a bit more targeted of a topic.

---

_Closed by @zanieb on 2025-12-02 10:43_

---

_Referenced in [astral-sh/uv#16964](../../astral-sh/uv/issues/16964.md) on 2025-12-03 13:40_

---
