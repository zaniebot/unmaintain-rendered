```yaml
number: 12795
title: Does UV provide any tooling to make packaging easier in a monorepo?
type: issue
state: open
author: risky-rickman
labels:
  - enhancement
assignees: []
created_at: 2025-04-10T00:05:49Z
updated_at: 2025-12-18T15:40:16Z
url: https://github.com/astral-sh/uv/issues/12795
synced_at: 2026-01-10T01:57:29Z
```

# Does UV provide any tooling to make packaging easier in a monorepo?

---

_Issue opened by @risky-rickman on 2025-04-10 00:05_

### Question

My directory structure looks something like:

- project_a
- project_b
- shared_lib

I want to be able to package project_a and shared_lib together for a deployment. As far as i can tell the only way to do this is to either:

upload shared_lib and project_a to a package repo
create a temp directory with project_a and shared_lib, and then moving project_a's pyproject.toml into the folder root before running my build.  

I'm hesitant to commit to either of these as it feels like there must be an easier way.  I'd love to hear some opinions on how i might accomplish this.  

### Platform

_No response_

### Version

_No response_

---

_Label `question` added by @risky-rickman on 2025-04-10 00:05_

---

_Comment by @zanieb on 2025-04-10 01:15_

As in, you want `shared_lib` to be vendored into `project_a`'s source distribution or wheel?

---

_Comment by @risky-rickman on 2025-04-10 03:06_

Yes exactly!

---

_Comment by @Tremeschin on 2025-04-19 09:00_

This is more of a build backend problem than uv I reckon, it can be done with [hatchling](https://hatch.pypa.io/1.13/config/build/#packages) pretty easily:

```toml
[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatch.build.targets.wheel]
packages = [
    "shared_lib",
    "project_a",
    "project_b"
]
```

Running `uv build --wheel` creates a monorepo wheel that includes both projects and itself.

However, I'd advise against this from experience, as each subproject will miss their dist info, importlib metadata fails. Instead, list all projects in the main `[tool.uv.workspace]`, let each project match the monorepo's version in their pyproject:

```toml

[tool.hatch.version]
path = "../shared_lib/version.py"

[project]
dynamic = ["version"]
# ...
dependencies = [
    "shared_lib==1.0.0",
]
```

Then build all projects with `uv build --all`. Can get fancy with build hooks automating the version there, but I digress.



---

_Comment by @krishmas on 2025-10-15 00:43_

What if there's a very large number of packages in the workspace though? Like if there's `project_<a-z>` and `shared_lib_<a-z>`. If `project_a` depends on `shared_lib_a` via it's dependencies in `project_a`'s pyproject.toml
```
dependencies = [
    "shared_lib_a"
    ...
]

[project.scripts]
project_a = "project_a.main:app"

[build-system]
requires = ["hatchling"]
build-backend = "hatchling.build"

[tool.hatchling.build.targets.wheel]
packages = ["src/project_a"]
```

and in the workspace root pyproject.toml, both `project_a` and `shared_lib_a` are listed as such:
```
[tool.uv.sources]
project_a = { workspace = true }
shared_lib_a = { workspace = true }
```
and
```
[tool.uv.workspace]
members = [
    "projects/project_a",
    "shared_libs/shared_lib_a"
]
```
is there a command I can run so that when I `uv build` or `uv tool install` project_a, `shared_lib_a` is included as well? 

---

_Comment by @Tremeschin on 2025-10-15 00:55_

@krishmas Perhaps `uv build --all --wheel` and/or `uv sync --all-packages`, which runs on all workspace members?

For uv tool install it'll need to be on PyPI or specified as a git+ dependency for a direct repo. I personally have a common hatchling [hook](https://github.com/BrokenSource/Hook) to resolve metadata package versions if inside a local monorepo, otherwise [keep git+ dependencies](https://github.com/BrokenSource/DepthFlow/blob/6bb8d5e560b4463ae60564ff767291a8fe142817/pyproject.toml#L20-L21).

- For example `uvx --from git+https://github.com/BrokenSource/ShaderFlow --python 3.13 shaderflow basic main`, or running `uv build --all` in the monorepo and getting "vendored" versions for members packages on PyPI

Not saying it's an ideal solution, but it's been working great for me, adapt this to your needs ðŸ™‚ 

---

_Comment by @krishmas on 2025-10-15 01:21_

Got it... hm yeah I'm coming from a Go/Bazel and Rust/Cargo world where making binaries is part of the workspace manager so maybe my expectations are misaligned, but since we're explicitly defining dependencies in pyproject.toml files **and** since `uv tool install project_a` already creates a snapshot/copy of `project_a`, why can't that snapshot/copy also include the workspace dependencies (`shared_lib_a`) defined in the `pyproject.toml` instead of just including a `.pth` file that links back to the `shared_lib_a` source code?

Like if I accidentally break or delete `shared_lib_a` source code after `uv tool install`ing `project_a` when the library was working, why should my installed `project_a` tool break? ðŸ˜… Shouldn't the working `shared_lib_a` have been packaged into the tool?

---

_Referenced in [astral-sh/uv#16306](../../astral-sh/uv/issues/16306.md) on 2025-10-15 01:53_

---

_Label `question` removed by @konstin on 2025-12-18 15:39_

---

_Label `enhancement` added by @konstin on 2025-12-18 15:39_

---

_Comment by @konstin on 2025-12-18 15:40_

There's no selective bundling support in uv yet, but we want to improve the support for large workspaces with different deployment subsets.

---
