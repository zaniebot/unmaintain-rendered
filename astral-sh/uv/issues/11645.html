<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avoid unnecessary downgrades due to development dependencies - astral-sh/uv #11645</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Avoid unnecessary downgrades due to development dependencies</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/11645">#11645</a>
        opened by <a href="https://github.com/staurostriantafyllos">@staurostriantafyllos</a>
        on 2025-02-19 22:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/staurostriantafyllos">@staurostriantafyllos</a> on 2025-02-19 22:32</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Hello <strong>uv</strong> community! üëã</p>
<pre><code>Platform
macOS 15.3

Version
uv 0.6.0 (591f38c25 2025-02-14)

Python version
3.11.10
</code></pre>
<p>While experimenting with <strong>uv</strong>, I noticed that all types of dependencies are tightly coupled. For example, when adding a new dependency, uv tries to find a valid version that satisfies all constraints across all dependency types (project, development, etc.), regardless of whether the library is going to be installed in the environment.</p>
<h3>The issue</h3>
<p>If I already have a <strong>development dependency</strong> that requires <em>mylibrary&lt;=2.7.0</em> and I try to add a new project dependency that also uses <em>mylibrary</em>, uv forces the installation (downgrade) to at most <em>mylibrary==2.7.0</em>, even though the latest available version might be 2.10.6.</p>
<p>This means that in <strong>production</strong>, we may be forced to use an <strong>outdated</strong> and potentially <strong>less secure</strong> version of a library just because of a development dependency that is only meant for local development.</p>
<p>I understand the current approach focuses on performance and syncing, but in production environments where security is a priority‚Äîespecially in enterprises that undergo CVE audits‚Äîconvenience and speed alone are not enough. Developers can manually identify and resolve such versioning issues, but this adds extra work. Also, removing development dependencies from pyproject.toml and managing them separately isn‚Äôt a viable option for me (and probably not for others either üòõ)</p>
<h3>Reproduce issue</h3>
<p><strong>Initial pyproject.toml</strong></p>
<pre><code>dependencies = []

[dependency-groups]
dev = [&quot;pydantic&lt;=2.7.0&quot;]
</code></pre>
<p><strong>Running</strong> <em>uv add</em> <strong>command</strong></p>
<pre><code>uv add pydantic
</code></pre>
<p><strong>What happens:</strong></p>
<pre><code>dependencies = [
    &quot;pydantic&gt;=2.7.0&quot;,
]
</code></pre>
<p><strong>Installed versions:</strong></p>
<pre><code class="language-diff">Prepared 3 packages in 220ms
Uninstalled 1 package in 5ms
Installed 5 packages in 14ms
 annotated-types==0.7.0
+ pydantic==2.7.0
 pydantic-core==2.18.1
 typing-extensions==4.12.2
</code></pre>
<h3>Suggested solution</h3>
<p>Introduce a <em>--no-downgrade</em> option (default: warning) when adding dependencies:</p>
<ul>
<li><code>uv add mylibrary --no-downgrade warning</code> or <code>uv add mylibrary </code></li>
<li><code>uv add mylibrary --no-downgrade error</code></li>
</ul>
<p>(<em>I‚Äôm terrible at naming arguments‚Äîopen to better suggestions!</em> üòÖ)</p>
<p><strong>Expected behavior</strong></p>
<ul>
<li>Identify versions that fully satisfy project dependencies first.</li>
<li>Then try to include development dependencies.</li>
<li>If a common library (used in both project and development dependencies) requires a downgrade:<ul>
<li><strong>--no-downgrade-level warning</strong>: Show a warning explaining which libraries were downgraded and to which version, then proceed.</li>
<li><strong>--no-downgrade-level error</strong>: Show the same warning, but prevent the installation, requiring the developer to first upgrade the development dependency that caused the issue.</li>
</ul>
</li>
</ul>
<h3>Example</h3>
<p>This example uses pydantic, but it could be any library that isn‚Äôt explicitly listed in the project. If someone suggests just pinning the version, that may not work because the library could be a transitive dependency, pulled in by another package.</p>
<p><strong>Initial pyproject.toml</strong></p>
<pre><code>dependencies = []

[dependency-groups]
dev = [&quot;pydantic&lt;=2.7.0&quot;]
</code></pre>
<p><strong>Running</strong> <em>uv add</em> <strong>command in</strong> <em>warning</em> <strong>level</strong></p>
<pre><code>uv add pydantic --no-downgrade-level warning
</code></pre>
<p><strong>What happens:</strong></p>
<pre><code>dependencies = [
    &quot;pydantic&gt;=2.7.0&quot;,
]
</code></pre>
<p><strong>but</strong> a warning is also displayed, saying that pydantic could have been added at version 2.10.6 but was downgraded to 2.7.0 due to constraints from development dependencies. Ideally, the warning could also suggest the minimum version required for the development dependency to avoid the downgrade, making it even more useful.</p>
<p><strong>Running</strong> <em>uv add</em> <strong>command in</strong> <em>error</em> <strong>level</strong></p>
<pre><code>uv add pydantic --no-downgrade-level error
</code></pre>
<p><strong>What happens:</strong></p>
<p>The toml file remains unchanged and a warning is displayed, indicating that the library could have been added with pydantic version 2.10.6 in the project dependencies. However, it was restricted to 2.7.0 due to constraints from development dependencies. The developer is prompted to upgrade the development dependencies first or set <em>--no-downgrade-level</em> to <em>warning</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @staurostriantafyllos on 2025-02-19 22:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Avoid unnecessary downgrades due to development dependencies ‚Äì Add Downgrade Warning" to "Avoid unnecessary downgrades due to development dependencies" by @staurostriantafyllos on 2025-02-19 22:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-19 23:08</div>
            <div class="timeline-body"><p>It sounds loosely like you want to declare the development dependencies as conflicting with your project so we can solve their constraints independently https://docs.astral.sh/uv/concepts/projects/config/#conflicting-dependencies</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/staurostriantafyllos">@staurostriantafyllos</a> on 2025-02-20 00:05</div>
            <div class="timeline-body"><p>I‚Äôm not talking about conflicts! Conflicting dependencies are fine because they produce an explicit error that the developer can see and fix. (btw <code>tool.uv -&gt; conflicts</code> is an interesting feature for other cases)</p>
<p>The issue I‚Äôm highlighting is silent version downgrades caused by development dependencies (without any conflict). This happens when a <strong>local tool</strong> (e.g., black, mypy) imposes constraints that indirectly downgrade a <strong>project‚Äôs transitive dependencies</strong>, even though these development dependencies aren‚Äôt required in production.</p>
<p>This is problematic because:</p>
<ul>
<li>The developer isn‚Äôt notified that a downgrade occurred in a <strong>transitive</strong> dependency of <strong>project's</strong> dependencies</li>
<li>It can lead to using <strong>outdated</strong> or insecure dependencies in production due to constraints from tools that are only meant for local development.</li>
</ul>
<p>What I need is a way to ensure that uv <strong>first</strong> resolves project dependencies independently, then considers development dependencies <strong>without forcing a downgrade</strong> unless explicitly allowed. The --no-downgrade flag I suggested would help developers identify and control these cases rather than dealing with them silently.</p>
<p>If this isn‚Äôt clear, let me know‚ÄîMaybe I can provide a more detailed example to clarify the issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-20 00:16</div>
            <div class="timeline-body"><p>I'm just not quite sure what you're suggesting is feasible. Resolving packages doesn't quite work that way. I'll give this some thought though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/staurostriantafyllos">@staurostriantafyllos</a> on 2025-02-21 02:19</div>
            <div class="timeline-body"><p>Hey Zanie &amp; uv community üëã</p>
<p>Indeed, I have no idea how package resolution works, and I hope I never have to! üòÜ
It seems incredibly complex after watching some of Charlie‚Äôs presentations.</p>
<p>But I wanted to follow up with <strong>two (2) alternative solutions</strong> that might be much simpler to implement.</p>
<h3>Updates from my last messages:</h3>
<p>As I explored more about how uv works, I realized that <strong>all interfaces use the same resolver</strong> logic (i.e., uv add/remove/export/sync/lock). Initially, I thought the issue was tied to sync, so I assumed using the pip interface might solve it.</p>
<p>I tried:</p>
<pre><code>uv export --no-dev --format requirements-txt &gt; requirements.txt
uv pip install -r requirements.txt
uv pip install -e .
</code></pre>
<p>Even with --no-dev, the resolver <strong>still downgraded</strong> the library version of a project dependency.</p>
<p>This means there‚Äôs currently <strong>no option to ignore dev dependencies during resolution</strong>, which is quite concerning for production use cases.</p>
<h3>The (hacky) workaround</h3>
<p>The only way I found to work around this is:</p>
<ol>
<li>Manually empty dev dependencies in pyproject.toml:</li>
</ol>
<pre><code>[dependency-groups]
dev = []
</code></pre>
<ol start="2">
<li>Run <code>uv lock --upgrade</code></li>
<li>Rename uv.lock to uv.prod.lock</li>
<li>Commit the lockfile</li>
<li>In CI/CD during the Docker build:<ol>
<li>Rename uv.prod.lock to uv.lock</li>
<li>Run <code>uv sync --frozen</code></li>
</ol>
</li>
</ol>
<p>This works, but obviously, it‚Äôs not ideal.</p>
<h3>Proposed Solutions</h3>
<p><strong>Optional 1 : Make <code>--no-dev</code> do what it promises</strong> (Preferred option!)</p>
<ul>
<li>This flag should completely ignore dev dependencies in resolution, as if they never existed (essentially replicating step 1 of my workaround).</li>
<li>This would ensure that uv.lock only contains project dependencies.<ul>
<li>This would also resolve <a href="https://github.com/astral-sh/uv/issues/9967">issue #9967</a>.</li>
</ul>
</li>
<li><strong>Bonus</strong>: If uv identifies that dev dependencies need to be installed, it could generate a separate (hidden) .uv.lock file, which could be added to .gitignore.</li>
</ul>
<p><strong>Outcome</strong>:</p>
<pre><code>uv sync --no-dev  # Completely ignores dev dependencies
</code></pre>
<p><strong>Optional 2 : Add <code>--only-project</code> and <code>--lockfile</code> options</strong></p>
<ul>
<li>Introduce a 4th flag (<code>--only-project</code>), similar to <code>--dev</code>, <code>--only-dev</code>, and <code>--no-dev</code>.</li>
<li>This would install all non-dev dependencies needed for a project. A good aspect of adding this option as an extra is that it will not affect the existing interface.</li>
<li>Additionally, a <code>--lockfile</code> option would allow users to specify a custom lockfile name, which is already being discussed in <a href="https://github.com/astral-sh/uv/issues/6830">issue #6830</a>.</li>
</ul>
<p><strong>Outcome</strong>:</p>
<pre><code>uv lock --only-project --lockfile uv.project.lock
</code></pre>
<h3>Why this matters beyond the lab</h3>
<p>In my current company, <strong>staying up to date with dependencies is critical</strong> due to security audits and CVE compliance. Even without dev dependencies, we already face challenges managing project dependencies. If dev dependencies introduce additional overhead, it makes things much worse.</p>
<p>Of course, we do run CVE checks in CI/CD, but why should we waste time fixing issues that shouldn‚Äôt exist in the first place?</p>
<p>Sorry for the long message guys, and thanks for taking the time to consider this! I really appreciate it. üôè</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/staurostriantafyllos">@staurostriantafyllos</a> on 2025-02-24 21:48</div>
            <div class="timeline-body"><p>Hey @zanieb and @charliermarsh , just following up to see if my recent update caught your attention.</p>
<p>I proposed two alternative solutions that might make it much easier to handle silent downgrades caused by development dependencies.</p>
<p>Would love to hear your thoughts when you have a chance. Appreciate your time! Thanks</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-03-10 22:20</div>
            <div class="timeline-body"><p>I want to share two notes on this problem, in hopes of showing which capabilities uv we could extend to better avoid this problem:</p>
<p>In your proposal, you have a <code>uv.prod.lock</code> and a <code>uv.lock</code>. This looks like a case for conflicting dependencies: The requirements aren't technically conflicting, but you want to have two different versions for the same package that are selected depending on CLI arguments and can't be installed together. Despite the name &quot;conflicting dependencies&quot;, it's really more &quot;different candidates for the same package on the same platform that are installed in different scenarios because they can't be installed at the same time&quot;.</p>
<p>You mention black as an example. I share your concern that black's dependencies shouldn't influence your production dependencies' versions. Ideally, we'd isolate such tools into their own environment, such as <code>uv tool</code> does, even though this currently does not integrate with defining the black version in <code>pyproject.toml</code> (see e.g. #5903).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dgutson">@dgutson</a> on 2025-08-22 17:47</div>
            <div class="timeline-body"><p>FWIW I'm looking forward to this feature, in relation to https://github.com/pypa/pip/issues/10807 . This would be a very good additional migration reason.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:33:00 UTC
    </footer>
</body>
</html>
