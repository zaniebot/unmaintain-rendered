<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider defaulting to `~=` version_cmp instead of `&gt;=` - astral-sh/uv #6783</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Consider defaulting to `~=` version_cmp instead of `&gt;=`</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/6783">#6783</a>
        opened by <a href="https://github.com/lucaspar">@lucaspar</a>
        on 2024-08-29 00:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/lucaspar">@lucaspar</a> on 2024-08-29 00:15</div>
            <div class="timeline-body"><!--
Thank you for taking the time to report an issue! We're glad to have you involved with uv.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `uv pip sync requirements.txt`), ideally including the `--verbose` flag.
* The current uv platform.
* The current uv version (`uv --version`).
-->

<blockquote>
<p>This &quot;issue&quot; might be the intended behavior of <code>uv</code>, but I believe it should be changed.</p>
</blockquote>
<p>Currently, when adding a dependency without an explicit version constraint e.g. <code>uv add numpy</code>, <code>uv</code> adds a <code>numpy&gt;=2.1.0</code> to the <code>pyproject.toml</code> in order to track this requirement.</p>
<p>Most semver upgrades are minors and patches, so this is usually fine, but <code>&gt;=</code> can be problematic when said package introduces a new major version (e.g. 3.0.0).</p>
<p>The default behavior of Poetry, for example, is to use the <a href="https://python-poetry.org/docs/dependency-specification/">caret</a>, where <code>^2.1.0</code> is equivalent to <code>&gt;=2.1.0 &lt;3.0.0</code>, thus protecting the project from an unintended breaking upgrade.</p>
<p>The uv's specifier <code>&gt;=</code> however, will upgrade to the most recent major by default. PEP 440 introduced the <code>~=</code> &quot;<a href="https://packaging.python.org/en/latest/specifications/version-specifiers/#id5">compatible release clause</a>&quot; / tilde, which - IMO - makes more sense to serve as the default version constraint:</p>
<pre><code>~= 2.1.0
# equals to
&gt;= 2.1.0, == 2.1.*
</code></pre>
<p>Note this behavior is different from Poetry's caret notation, so, unless specified, the patch version could be safely omitted by default to allow minor upgrades, while still preventing major ones:</p>
<pre><code>~= 2.1
# equals to
&gt;= 2.1, == 2.*
</code></pre>
<p>This is a default behavior I'd like to see from <code>uv</code> to ease future project upgrades.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-29 03:33</div>
            <div class="timeline-body"><p>Now that we have an application / library split I wonder if we can use that to determine if we should add upper bounds by default. Previously, we were quite opposed to this due to its effect on the ecosystem of published packages.</p>
<p>Some prior discussion at https://github.com/astral-sh/uv/issues/5178 — I think the rest of it was private. I previously compiled some <a href="https://github.com/zanieb/poetry-relax?tab=readme-ov-file#references">references</a> on the topic though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lucaspar">@lucaspar</a> on 2024-08-29 04:18</div>
            <div class="timeline-body"><p>ha, I figured this must had already been discussed before. Reading some of that convinced me that not setting upper bounds might be the best default for libraries. Most of my projects are applications though, and I often prefer to reserve some time to handle major upgrades manually. I see good points for either option though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">projects</span> added by @zanieb on 2024-08-29 04:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @zanieb on 2024-08-29 04:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @zanieb by @zanieb on 2024-08-29 04:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/palotasb">@palotasb</a> on 2024-08-29 08:28</div>
            <div class="timeline-body"><p>I hope this is useful: https://iscinumpy.dev/post/bound-version-constraints/ It's a very detailed (and thus long...) article arguing for why the <code>&gt;=</code> default is better than <code>~=</code> for Python dependency constraints.</p>
<p>IMHO while <code>&gt;=</code> is a no-contest winner for libraries, it makes sense for applications too. Develop using the <code>&gt;=</code> constraints by default, explicitly update the lockfile regularly, test the changes, and use the lockfile when needing the stability in prod. Only add <code>~=</code>/<code>&lt;=</code> constraints when updating breaks something in practice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Zaczero">@Zaczero</a> on 2024-10-29 14:41</div>
            <div class="timeline-body"><p>Many popular packages (fastapi, httpx, ..) use 0.X.Y versioning schema which is very difficult to work with when using <code>~=</code>. I also really dislike packages that enforce upper bound by default. I sometimes find myself stuck not being upgrade to a next major release (mostly backwards compatible) because of some random dependency that decided to safeguard me against it preemptively.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/amoralesc">@amoralesc</a> on 2024-11-13 23:45</div>
            <div class="timeline-body"><p>Hey @zanieb, for users exclusively using <code>uv</code> as an application management tool, is there a way to change the default behavior of adding the lower bound specifier when <code>uv add</code> is used without a explicit constraint?</p>
<p>I like to stick with semver patch versions parity between the <code>pyproject.toml</code> and <code>uv.lock</code> files (the <code>~=</code> version specifier), and let the CI upgrade the dependencies if the tests pass. The problem I find with the default <code>&gt;=</code> version specifier is that I really can't tell which version of a package I have installed unless I manually check the lock file. If for some reason the lock file is updated for a package that introduces breaking changes, I'm forced to manually downgrade the package (from which the <code>~=</code> specifier would save me).</p>
<p>Consider for example that <a href="https://docs.astral.sh/uv/reference/versioning/#versioning">uv</a> itself introduces breaking changes when the minor version is updated. This is the case too for <a href="https://fastapi.tiangolo.com/az/deployment/versions/">FastAPI</a>.</p>
<p>A configuration option that allowed users to set the default version specifier strategy (set lower bound <code>&gt;=</code>, set strict version <code>==</code>, patch versions only <code>~=</code>, set upper bound <code>&lt;=</code>) when <code>uv add</code> is called would be really helpful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/frenata">@frenata</a> on 2024-12-26 16:43</div>
            <div class="timeline-body"><p>Yeah I'd <em>at least</em> like a way to control <code>uv</code>'s behavior here, ala <code>rye</code>'s &quot;dependency-operator&quot;<a href="https://rye.astral.sh/guide/config/#config-file"> config file</a> option.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-28 17:01</div>
            <div class="timeline-body"><p>I'm not opposed to adding an option, I think. We'll need to reach consensus as a team though. cc @konstin</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-01-03 10:09</div>
            <div class="timeline-body"><p>I usually recommend operators like <code>&gt;=2.1.0 &lt;3.0.0</code> (or <code>&gt;=0.2.1 &lt;0.3.0</code> for <code>0.x</code> versions), since they avoid code breaking when a new major version of a dependencies is released, assuming that the dependency uses somewhat semantic versioning, so an option for that would be nice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/frenata">@frenata</a> on 2025-01-03 15:46</div>
            <div class="timeline-body"><p>@konstin , I <em>think</em> that's equivalent to ~2.1. Either way, an option to make that the default would be nice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/benlindsay">@benlindsay</a> on 2025-01-05 19:35</div>
            <div class="timeline-body"><p>Confirmed. <code>&gt;=2.1.0, &lt;3.0.0</code> is equivalent to <code>~=2.1</code>, and <code>&gt;=2.1.0, &lt;2.2.0</code> would be equivalent to <code>~=2.1.0</code> <a href="https://packaging.python.org/en/latest/specifications/version-specifiers/#compatible-release">link</a>. But since <code>~=</code> is not as broadly understood as <code>&gt;, &gt;=, &lt;, &lt;=</code> operators, I'd be happy with either of those options. Or the <code>&gt;=2.1.0, ==2.*</code> variant used in the link I provided. Any of those are preferable to straight <code>&gt;=</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yakMM">@yakMM</a> on 2025-01-07 19:51</div>
            <div class="timeline-body"><p>Coming from https://github.com/astral-sh/uv/issues/10247.</p>
<p>Imo the current <code>&gt;=</code> operator is a perfect default for library. As for applications, other than being able to configure the default, adding a command line option would work as well.</p>
<p>For example PDM has the <code>--save-exact</code> option to the <code>pdm add</code> command that can be useful for some applications use cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yourcelf">@yourcelf</a> on 2025-01-10 04:07</div>
            <div class="timeline-body"><p>The &quot;compatible&quot; range specifier <code>~=</code> isn't great as a default.  While <code>~=2.1</code> is equivalent to <code>&gt;=2.1.0</code>, it is <em>not</em> equivalent to <code>&gt;=2.1.1</code>, since <code>~=2.1</code> allows <code>2.1.0</code>.  The poetry style <code>^2.1.1</code> can be expressed precisely as <code>&gt;=2.1.1, &lt;3.0.0</code>, which works, but is verbose.  The difference would be if I'm installing second library that expresses a dependency on <code>==2.1.0</code>, I will get a dependency solver error (which is desirable), instead of silently allowing a (potentially with security bugs) earlier patch version into the solution.</p>
<p>As someone coming from a long time working with poetry and <code>^</code>-style ranges, the urge I feel is the desire for a compact or canonical way to express a &quot;compatible&quot; version spec, but with a lower bound to exclude earlier buggy releases.  But if we stick strictly to <a href="https://peps.python.org/pep-0508/">PEP 508</a>, I don't think there's a way to get that without expressing both bounds explicitly.</p>
<p>So I'd advocate for a double inequality like <code>&gt;=2.1.1, &lt;3.0.0</code> as the clearest semver &quot;compatible with lower bound&quot; style.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AmmoniumX">@AmmoniumX</a> on 2025-02-24 14:52</div>
            <div class="timeline-body"><p>I think frenata's suggestion of implementing rye's &quot;dependency-operator&quot; config would satisfy every party. Keep the <code>&gt;=</code> as default, since there is good justification for having it there, but people who aren't developing public libraries should have the <em>option</em> to explicitly state they want to limit themselves to the current major version. I hope we can see something similar added to uv, as this wouldn't really change the majority's opinion of &quot;having &gt;= by default is better&quot;, but still gives other people the option to change the default behavior.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tomaszbk">@tomaszbk</a> on 2025-04-09 15:32</div>
            <div class="timeline-body"><p>Considering @Zaczero 's thought that many packages use 0.X.Y, I think the best for uv <em><strong>applications</strong></em> is to use pinned versions by default in the toml (or a cli parameter on uv init that makes every <code>uv add</code> afterward use <code>==</code> on the toml instead of <code>&gt;=</code>), and make upgrades manually for now, and using <code>uv upgrade</code> in the future, once #6794 is approved.</p>
<p>I work on some python apps and me and my team don't want to deal with multiple ranges and application versions, we want to have only one and use that one on prod.</p>
<p>pd: the <code>==</code> would not only be used for dependencies, but also for the <code>requires-python</code> field, meaning that <em><strong>application</strong></em> projects wouldn't require a <code>.python-version</code> anymore, because the exact version would be already specified in the toml.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/palotasb">@palotasb</a> on 2025-04-09 16:16</div>
            <div class="timeline-body"><blockquote>
<p>I think the best for uv applications is to use pinned versions by default in the [pyproject.]toml</p>
</blockquote>
<p>I think this is what you should use the <code>uv.lock</code> lockfile for both when developing the application and deploying it. Keep the constraints in your <code>pyproject.toml</code> relaxed, only list your direct dependencies, and don't worry about exactly specifying the minimum dependency version your app's supposed to work with. But then generate a <code>uv.lock</code> file and use it both in your development environment (make <code>uv sync --frozen</code> part of your dev env set up, include it in your readme or your onboarding training), and configure your CI to also run <code>uv sync --frozen</code>. When deploying your application also make sure it's based on <code>uv sync --frozen</code>, perhaps this is a line you need to add to your <code>Dockerfile</code>.</p>
<p>All of this ensures that everyone working on a specific commit (both your colleagues and your CI) will install the exact same version of all dependencies – no &quot;works on my machine&quot; issues. But it also enables easy upgrades. Just run <code>uv sync --upgrade</code>, and commit and push the changes to <code>uv.lock</code> to upgrade in a well-controlled way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tomaszbk">@tomaszbk</a> on 2025-04-09 19:40</div>
            <div class="timeline-body"><blockquote>
<p>don't worry about exactly specifying the minimum dependency version your app's supposed to work with</p>
</blockquote>
<p>the idea here is in case we want to do a dependency version rollback? For our application, we find it more readable to have the same dependency versions in both the pyproject.toml and uv.lock. It's much simpler to look at the pyproject.toml than having to search through a huge uv.lock to find out which dependency version we are currently using.
Again, if we were to create a library, we would definitely used <code>uv sync --frozen</code> and <code>uv sync --upgrade</code> as you mentioned, but we are making an app and we, at least, find it easier to use <code>uv remove</code> and <code>uv add</code> to upgrade packages, and replace <code>&gt;=</code> with <code>==</code> to avoid auto upgrades and avoid the need of a <code>.python-version</code> file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AmmoniumX">@AmmoniumX</a> on 2025-04-10 13:34</div>
            <div class="timeline-body"><blockquote>
<p>I think this is what you should use the uv.lock lockfile for both when developing the application and deploying it.</p>
</blockquote>
<p>This &quot;forces&quot; a dependency in uv for deployment, though. What if we just want uv for development, but still want to support an installation as simple as <code>python -m venv; pip install</code> or other tools? For this we'd want pyproject.toml to contain all necessary deployment requirements, as pyproject.toml is the &quot;universal&quot; file read by all tools</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2025-04-10 13:36</div>
            <div class="timeline-body"><blockquote>
<p>This &quot;forces&quot; a dependency in uv for end users</p>
</blockquote>
<p>Once <a href="https://peps.python.org/pep-0751/">PEP 571 lock files</a> are widely implemented then you can use that lock file format instead and it won't force a dependency on uv.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-04-10 13:38</div>
            <div class="timeline-body"><p>Yes, though note that PEP 571 lock files won't have any effect on a workflow like <code>pip install application</code>. That would still use the published metadata (not the <code>pyproject.toml</code> as suggested above, but the published package metadata).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/palotasb">@palotasb</a> on 2025-04-10 17:38</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>I think this is what you should use the uv.lock lockfile for both when developing the application and deploying it.</p>
</blockquote>
<p>This &quot;forces&quot; a dependency in uv for deployment, though. What if we just want uv for development, but still want to support an installation as simple as <code>python -m venv; pip install</code> or other tools?</p>
</blockquote>
<p>You're right, my suggestion did imply an <code>uv</code> dependency for deployment. You can sidestep this by generating a <code>requirements.txt</code> during development:</p>
<pre><code class="language-shell">uv export &gt;requirements.txt
</code></pre>
<p>And then for the deployment:</p>
<pre><code class="language-shell">python3 -m venv .venv
./.venv/bin/pip install -r requirements.txt
</code></pre>
<blockquote>
<p>For this we'd want pyproject.toml to contain all necessary deployment requirements, as pyproject.toml is the &quot;universal&quot; file read by all tools</p>
</blockquote>
<p>Having complete and pinned requirements as part of your built package's published <a href="https://packaging.python.org/en/latest/specifications/core-metadata/#requires-dist-multiple-use">core metadata</a> is the way this is generally recommended for Python. A long-standing recommendation has been to separate your minimal requirements (traditionally <code>install_requires</code> in a <code>setup.py</code>) from your requirements files (or more recently, lockfiles). The Python Packaging User Guide has a good overview on this: https://packaging.python.org/en/latest/discussions/install-requires-vs-requirements/</p>
<p>Even with PEP 751 lockfiles implemented, the recommendation will be to keep your dependencies in <code>pyproject.toml</code> and your published package metadata minimal and abstract. Don't expect <code>pip install my-application==1.0.0</code> to be reproducible, it's not intended to be.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> removed by @konstin on 2025-04-17 14:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @konstin by @konstin on 2025-04-17 14:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @zanieb by @konstin on 2025-04-17 14:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2025-05-28 13:11</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:35:09 UTC
    </footer>
</body>
</html>
