<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Apply fork markers at fork time - astral-sh/uv #6176</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Apply fork markers at fork time</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/uv/issues/6176">#6176</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2024-08-17 21:59
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-17 21:59</div>
            <div class="timeline-body"><p>It would be nice if we could find a way to apply the fork markers at fork time. As-is, we end up solving parts of the graph in a fork that are actually disjoint with the fork, if those dependencies were added prior to forking.</p>
<p>For example:</p>
<pre><code class="language-rust">let pyproject_toml = context.temp_dir.child(&quot;pyproject.toml&quot;);
pyproject_toml.write_str(
    r#&quot;
    [project]
    name = &quot;project&quot;
    version = &quot;0.1.0&quot;
    requires-python = &quot;&gt;=3.8&quot;
    dependencies = [&quot;anyio==3.7.0 ; python_version &gt; '3.10'&quot;, &quot;dep&quot;]

    [tool.uv.sources]
    dep = { path = &quot;./dep&quot; }
    &quot;#,
)?;

let dep = context.temp_dir.child(&quot;dep&quot;);
dep.child(&quot;pyproject.toml&quot;).write_str(r#&quot;
    [project]
    name = &quot;dep&quot;
    version = &quot;0.1.0&quot;
    requires-python = &quot;&gt;=3.8&quot;
    dependencies = [&quot;iniconfig &lt; 2 ; python_version &gt;= '3.10'&quot;, &quot;iniconfig &gt;= 2 ; python_version &lt; '3.10'&quot;]
&quot;#)?;
</code></pre>
<p>In this graph, we end up solving for <code>anyio</code> even in the <code>python_version &lt; '3.10'</code> fork, despite the fact that it gets discarded at the very end, when we create the <code>ResolutionGraph</code> (since, at that point, we <code>and</code> the markers, and they evaluate to <code>false</code>).</p>
<p>We roughly want this:</p>
<pre><code class="language-diff">diff --git a/crates/uv-resolver/src/resolver/mod.rs b/crates/uv-resolver/src/resolver/mod.rs
index 3bb311a00..b1d5cf3c0 100644
--- a/crates/uv-resolver/src/resolver/mod.rs
+++ b/crates/uv-resolver/src/resolver/mod.rs
@@ -2255,6 +2255,8 @@ impl ForkState {
     /// Subset the current markers with the new markers and update the python requirements fields
     /// accordingly.
     fn with_markers(mut self, markers: MarkerTree) -&gt; Self {
+        // Here, we basically need to `and` the markers of each package in the existing state with
+        // the fork markers... and throw out anything that's disjoint?
         let combined_markers = self.markers.and(markers);

         // If the fork contains a narrowed Python requirement, apply it.
</code></pre>
<p>But it seems hard to &quot;transform&quot; a PubGrub <code>State</code> in the middle of the resolution. (In other words: we'd want to <code>clone</code> the <code>State</code>, then change some information about the <code>PubGrubPackage</code> nodes, and discard any nodes that are <em>not</em> relevant for the new branch of the solve.) I don't know how we'd reflect the changes everywhere. We'd probably need to consult with @Eh2406.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">resolver</span> added by @charliermarsh on 2024-08-17 21:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by @charliermarsh on 2024-08-17 21:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-08-19 13:38</div>
            <div class="timeline-body"><p>I think this would help with some of the instability problems as well right? Because I think it would help us sync up the behavior between &quot;find a resolution without knowing the fork points up-front&quot; and &quot;find a resolution using these existing forks.&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-19 13:52</div>
            <div class="timeline-body"><p>Yeah, it should help with some of them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> removed by @zanieb on 2024-08-20 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Eh2406">@Eh2406</a> on 2024-08-26 21:33</div>
            <div class="timeline-body"><p>There's a lot of context I missing here. But fundamentally you looped me in about '&quot;transform&quot; a PubGrub <code>State</code> in the middle of the resolution'. This is not exposed in PubGrub's public API because there are lots of ways to shoot yourself in the foot mutating internal data structures. But you already roll your own resolution loop, so you have a lot more knobs available.</p>
<p>Adding <code>Incompatibilities</code> should generally be safe. Practically, there are two mutations that should be safe and easy. (Modulo never having experimented with this in practice. So not knowing where the corner cases are.)</p>
<ul>
<li>Marking some set of versions as unavailable. Perhaps this could be used to say &quot;within this fork, versions of Python older than x.y.x are no longer available&quot; or &quot;versions that require a Python incompatible with this fork are individually marked as unavailable&quot;.</li>
<li>There is a new dependency edge from some package to some range of packages.</li>
</ul>
<p>For both of these <code>unit_propagation</code> should be able to handle these new incompatibilities even if they exclude a version that has already been selected.</p>
<p>Removing an <code>Incompatibilities</code>, is much more complicated. (Practically, the inverse operations of the two above. A package becoming available, or a dependency edge no longer being required.) I have thought about this problem for a long time, but never had time to dig in and code something. The problem is that more general <code>Incompatibilities</code> may have been derived from ones that you've just removed. I think it likely that there is a linear algorithm to identify all such tainted inductions and decisions. Overall this could still be more efficient than <code>Clone</code>ing before the problematic add, because derived implications of unrelated facts do not need to be reloaded in.</p>
<p>It is also possible that these dependencies whose existence is conditional on what Python version you are using, would more accurately be modeled with more exotic forms of <code>Incompatibilities</code>. But I would definitely need more context to suggest anything tangible. Was any of that helpful?</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:21 UTC
    </footer>
</body>
</html>
