<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local + remote dependencies - astral-sh/uv #9205</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Local + remote dependencies</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/uv/issues/9205">#9205</a>
        opened by <a href="https://github.com/nunokaeru">@nunokaeru</a>
        on 2024-11-18 16:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/nunokaeru">@nunokaeru</a> on 2024-11-18 16:37</div>
            <div class="timeline-body"><p>Let's say I have a repository that has two packages, one of them depends on the other but I want to both test that dependency with it's local version and with a remote &quot;downgraded&quot; version.</p>
<pre><code>&gt; project
     &gt; src
          &gt; package-1
          &gt; package-2
</code></pre>
<pre><code>package-1/pypoject.toml

[project]
version = &quot;1.0.0&quot;

dependencies = [&quot;package-2==1.0.0&quot;]


package-2/pyproject.toml
[project]
version = &quot;1.1.0&quot;

dependencies = []
</code></pre>
<p>When I run <code>uv sync</code> in package-1, the environment will be installed with the version 1.0.0 of package-2 even though that package has been updated. Is there a way to define both local and remote dependencies and choosing at runtime which one to use. This way it's possible to ensure ABI compability between package versions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ReinforcedKnowledge">@ReinforcedKnowledge</a> on 2024-11-22 01:32</div>
            <div class="timeline-body"><p>Hi!</p>
<p>I think you can do this with the <code>--with</code> option of <code>uv run</code>, or <code>--with-requirements</code> if you have many dependencies.</p>
<p>Toy example for illustrative purposes:</p>
<pre><code>.
├── package1
│   ├── README.md
│   ├── pyproject.toml
│   ├── src
│   │   └── package1
│   │       ├── __init__.py
│   │       └── hello.py
├── package2
│   ├── README.md
│   ├── pyproject.toml
│   └── src
│       └── package2
│           ├── __init__.py
│           └── pk2_hello.py
└── remote
    └── package2
        ├── README.md
        ├── pyproject.toml
        └── src
            └── package2
                ├── __init__.py
                └── pk2_hello.py
</code></pre>
<p>The &quot;remote&quot; version of <code>package2</code> runs with version <code>0.1.0</code>. Its <code>pk2_hello.py</code> contains the following code:</p>
<pre><code class="language-python">def pk2_hello():
    print(&quot;Hello from 0.1.0&quot;)
</code></pre>
<p>The other <code>package2</code> runs with version <code>0.1.1</code> and contains the following code in its <code>pk2_hello.py</code>:</p>
<pre><code class="language-python">def pk2_hello():
    print(&quot;Hello from 0.1.0&quot;)
</code></pre>
<p>In my <code>package1</code> I do <code>uv add ../remote/package2</code>, which makes the <code>pyproject.toml</code> like:</p>
<pre><code class="language-toml">[project]
name = &quot;package1&quot;
version = &quot;0.1.0&quot;
description = &quot;Add your description here&quot;
readme = &quot;README.md&quot;
authors = [
    { name = &quot;ReinforcedKnowledge&quot;, email = myemail@gmail.com }
]
requires-python = &quot;&gt;=3.13&quot;
dependencies = [
    &quot;package2&quot;,
]

[project.scripts]
package1 = &quot;package1:main&quot;

[build-system]
requires = [&quot;hatchling&quot;]
build-backend = &quot;hatchling.build&quot;

[tool.uv.sources]
package2 = { path = &quot;../remote/package2&quot; }
</code></pre>
<p>We can verify in <code>uv.lock</code> the correct version:</p>
<pre><code>version = 1
requires-python = &quot;&gt;=3.13&quot;

[[package]]
name = &quot;package1&quot;
version = &quot;0.1.0&quot;
source = { editable = &quot;.&quot; }
dependencies = [
    { name = &quot;package2&quot; },
]

[package.metadata]
requires-dist = [{ name = &quot;package2&quot;, directory = &quot;../remote/package2&quot; }]

[[package]]
name = &quot;package2&quot;
version = &quot;0.1.0&quot;
source = { directory = &quot;../remote/package2&quot; }
</code></pre>
<p>I add this code in <code>hello.py</code>:</p>
<pre><code class="language-python">from package2.pk2_hello import pk2_hello


def pk1_hello():
    pk2_hello()


pk1_hello()
</code></pre>
<p>Doing <code>uv run src/package1/hello.py</code> echos &quot;Hello from 0.1.0&quot;.</p>
<p>So <code>package1</code> runs wells with the downgraded version of <code>package2</code>.</p>
<p>Now do this <code>uv run --with ../package2 src/package1/hello.py</code>, you should see &quot;Hello from 0.1.1&quot;</p>
<p>This creates a new ephemeral virtual environment in which it layers the new dependencies on top of the existing ones.</p>
<p>From the manual (the bold part is not in the manual)</p>
<blockquote>
<pre><code>  --with &lt;WITH&gt;</code></pre>
</blockquote>
<pre><code>      Run with the given packages installed.
      
      When used in a project, these dependencies will be layered on top of
      the project environment in a separate, ephemeral environment. These
      dependencies are allowed to conflict with those specified by the
      project.</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:24 UTC
    </footer>
</body>
</html>
