<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`tool.uv.sources` should work for indirect dependencies - astral-sh/uv #9446</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>tool.uv.sources</code> should work for indirect dependencies</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/9446">#9446</a>
        opened by <a href="https://github.com/zeevro">@zeevro</a>
        on 2024-11-26 17:35
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zeevro">@zeevro</a></div>
            <div class="timeline-body"><p>Currently (version 0.5.4), <code>uv</code> ignores <code>tool.uv.sources</code> if a package is not a direct dependency (i.e. listed in the project&#x27;s <code>pyproject.toml</code>). I think <code>tool.uv.sources</code> should apply for all dependencies.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-26 17:41</div>
            <div class="timeline-body"><p>If you&#x27;re going to define a source, you should just make it a direct dependency -- what&#x27;s the issue with that? You&#x27;re already encoding that your project depends on a certain package.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zeevro">@zeevro</a> on 2024-11-26 18:16</div>
            <div class="timeline-body"><p>If I&#x27;m using a package from a private index, and that package has further dependencies on said private index, I don&#x27;t want to have to add all of these indirect dependencies to as direct dependencies. It is a bit weird, though, since my private direct dependencies need packages from PyPI apart from the private ones, so I guess how to deal with that is also a question.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-11-26 18:20</div>
            <div class="timeline-body"><p>Sort of related <a href="https://github.com/astral-sh/uv/issues/8148">astral-sh/uv#8148</a>#issuecomment-2499547638</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-11-27 13:06</div>
            <div class="timeline-body"><p>Does it work if you make the private index first priority and pypi the second priority?</p>
<p>For applying extra information to indirect dependencies, you can use <a href="https://docs.astral.sh/uv/reference/settings/#constraint-dependencies">constraints</a>, though you may need <a href="https://github.com/astral-sh/uv/pull/9455">astral-sh/uv#9455</a> for that first.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/smackesey">@smackesey</a> on 2024-12-22 14:57</div>
            <div class="timeline-body"><p>Strong agree with this.</p>
<p>I find it very unintuitive that <code>tool.uv.sources</code> does not work for indirect dependencies. It&#x27;s also not mentioned in the <a href="https://docs.astral.sh/uv/concepts/projects/dependencies/#dependency-sources">docs</a>.</p>
<p>The main problem is that it forces you to declare second-order-plus dependencies as <code>dependencies</code> if you want to use <code>tool.uv.sources</code> for them. This is a non-standard use of <code>dependencies</code>, which typically only contains packages actually imported by your code. The situation where it is convenient to use <code>sources</code> for indirect dependencies can easily come up in monorepo development, where you have many interdependent packages.</p>
More details
<p>I work in the context of a large monorepo, <a href="https://github.com/dagster-io/dagster">Dagster</a>. We have ~100 python packages defined in the repo with various interdependencies.</p>
<p>If I am setting up a new package that pulls in some of our integration libraries, it might look like this:</p>
<pre><code>[project]
name = &quot;my_example&quot;
requires-python = &quot;&gt;=3.9,&lt;3.13&quot;
version = &quot;0.1.0&quot;
dependencies = [
    &quot;dagster&quot;,
    &quot;dagster-components[dbt]&quot;,
]
</code></pre>
<p>But remember that there are many interdependencies among packages. <code>dagster</code> has a dependency on another library named <code>dagster-pipes</code> and <code>dagster-components[dbt]</code> has a dependency on <code>dagster-dbt</code>.</p>
<p>If a user were setting up <code>my_example</code>, they wouldn&#x27;t need to specify these packages in dependencies, since they are 2nd-order dependencies that would be pulled in from PyPI like any other.</p>
<p>But in many development contexts, we want to make sure our packages resolve internal dependencies (i.e. dependencies on other dagster packages) against the versions from the same monorepo commit. So we will tack a big list of uv sources onto <code>pyproject.toml</code> like this below. Basically this acts as a pseudo-index-- the purpose is to make sure that <em>any</em> internal package is resolved against the local version of the monorepo instead of downloaded from PyPI.</p>
<pre><code>[tool.uv.sources]
dagster-test = { path = &quot;/Users/smackesey/stm/code/elementl/oss/python_modules/dagster-test&quot;, editable = true }
dagster-graphql = { path = &quot;/Users/smackesey/stm/code/elementl/oss/python_modules/dagster-graphql&quot;, editable = true }
dagster = { path = &quot;/Users/smackesey/stm/code/elementl/oss/python_modules/dagster&quot;, editable = true }
dagster-pipes = { path = &quot;/Users/smackesey/stm/code/elementl/oss/python_modules/dagster-pipes&quot;, editable = true }
dagster-webserver = { path = &quot;/Users/smackesey/stm/code/elementl/oss/python_modules/dagster-webserver&quot;, editable = true }
...
</code></pre>
<p>But, because <code>tool.uv.sources</code> does not work for indirect dependencies, we have to remember to specify any nth-order internal dependency as a direct dependency:</p>
<pre><code>[project]
name = &quot;my_example&quot;
requires-python = &quot;&gt;=3.9,&lt;3.13&quot;
version = &quot;0.1.0&quot;
dependencies = [
    &quot;dagster&quot;,
    &quot;dagster-components[dbt]&quot;,
    &quot;dagster-dbt&quot;,  # have to add this...
    &quot;dagster-pipes&quot;,  # have to add this...
]
</code></pre>
<p>So now in a dev context we have to chase down 2nd-order-plus deps and have a different package metadata than a user would have because of details of package resolution tooling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2025-01-07 19:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zmeir">@zmeir</a> on 2025-02-10 20:51</div>
            <div class="timeline-body"><p>Just adding my 2 cents here. I often have the following use-case:<br>
Package <code>c</code> depends on package <code>b</code>, which in turn depends on package <code>a</code>, but package <code>c</code> does not directly depend on <code>a</code>. Then, I want to implement something in <code>a</code> and see how it affects <code>c</code>. Being able to set <code>a</code> as an editable local path for <code>c</code> via <code>[tool.uv.sources]</code> would simplify this flow, especially since I already do the same when implementing something in <code>b</code> and testing how it affects <code>c</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zmeir">@zmeir</a> on 2025-03-06 14:01</div>
            <div class="timeline-body"><p>If this helps anyone, I found out that in most cases I can use <a href="https://docs.astral.sh/uv/concepts/resolution/#dependency-overrides">dependency override</a> for indirect dependencies.</p>
<p>One downside with this approach is that I have to specify package extras for the indirect dependency.</p>
<p>For example, let&#x27;s say my project depends on the package <code>direct</code>, and <code>direct</code> depends on <code>indirect[extra]</code>, then this should work:</p>
<pre><code>[project]
name = &quot;test-uv-override&quot;
version = &quot;0.1.0&quot;
requires-python = &quot;&gt;=3.13&quot;
dependencies = [
    &quot;direct&quot;,
]

[tool.uv]
override-dependencies = [
    &quot;indirect[extra]@file:///path/to/indirect&quot;,
]
</code></pre>
<p>Of course this will not install <code>indirect</code> as an editable package, but I use this mostly for CI so it&#x27;s less of an issue for me.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:35:47 UTC
    </footer>
</body>
</html>
