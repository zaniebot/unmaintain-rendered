<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expose package metadata in a way that can be reused by other tools - astral-sh/uv #2361</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Expose package metadata in a way that can be reused by other tools</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/uv/issues/2361">#2361</a>
        opened by <a href="https://github.com/obi1kenobi">@obi1kenobi</a>
        on 2024-03-11 19:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/obi1kenobi">@obi1kenobi</a> on 2024-03-11 19:31</div>
            <div class="timeline-body"><p><code>uv</code> has done a lot of work to ensure it can read package metadata quickly and correctly: https://twitter.com/charliermarsh/status/1767251713134653641</p>
<p>This is a surprisingly tricky thing to get right, and it would be useful to a variety of tools in the Python ecosystem beyond just <code>uv</code>. It would be lovely to be able to reuse this fine work to power other tools as well. This could either be in the form of a Rust or Python API that other tools could hook into, or by introducing a <code>uv</code> CLI command or flag (e.g. <code>uv metadata my_pkg==1.2.3</code>) that other tools could run.</p>
<p>The current recommended workaround (per <a href="https://twitter.com/charliermarsh/status/1767255769311830027">this tweet</a>) is running <code>echo &quot;foo==1.2.3&quot; | uv pip compile -</code> and reading the output requirements file. This is reasonable as a workaround, but obviously not as elegant as either a dedicated CLI item or a direct Rust or Python API for this functionality.</p>
<p>I don't expect this feature request would be any kind of immediate priority, of course. My goal is to register interest in such a feature and provide a place where interested folks can coordinate, share experiences with workarounds, and have a dependable way to find out if/when an API or CLI extension for this gets added.</p>
<p>Thanks for all the awesome work you've been doing on <code>uv</code>!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @charliermarsh on 2024-03-11 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @charliermarsh on 2024-03-11 19:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-03-11 20:00</div>
            <div class="timeline-body"><p>Could you talk a bit more about what's your use case?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/obi1kenobi">@obi1kenobi</a> on 2024-03-11 20:28</div>
            <div class="timeline-body"><p>Sure! TL;DR: I'd love a <code>cargo metadata</code> but for Python.</p>
<p>Since I know you maintain <code>maturin</code> (thank you!), you might be familiar with my tool <code>cargo-semver-checks</code>, a linter for breaking changes in Rust. It uses <code>cargo metadata</code> as one of its sources of data to check.</p>
<p>I also build and maintain some linters for Python use cases: I recently built a linter called <code>pepperlint</code> that can catch breaking changes in Python packages, and I've built other linters that can catch cases like <a href="https://www.hytradboi.com/2022/how-to-query-almost-everything">&quot;your project's Kubernetes deployment uses a Docker image whose Python version is incompatible with your project's <code>pyproject.toml</code> Python version range.&quot;</a></p>
<p>A major challenge in linters like this is getting access to ground truth data about packages: info on dependencies and ranges, supported platforms, source code location, license, etc. In Rust, <code>cargo metadata</code> easily gives us the canonical copy of all this data. In Python, there's currently no equivalent command, and there's a wide variety of ways this metadata may be structured. <code>uv</code> faces the same problem, and appears to have solved it quite well.</p>
<p>This is why a <code>uv metadata</code> command analogous to <code>cargo metadata</code> would be lovely for downstream tools. Happy to chat more or answer any follow-up questions!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:57 UTC
    </footer>
</body>
</html>
