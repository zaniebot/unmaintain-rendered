<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Check whether the interpreter currently set in `PATH` is associated with a virtual environment - astral-sh/uv #4009</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Check whether the interpreter currently set in `PATH` is associated with a virtual environment</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/4009">#4009</a>
        opened by <a href="https://github.com/dpoznik">@dpoznik</a>
        on 2024-06-04 02:36
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/dpoznik">@dpoznik</a> on 2024-06-04 02:36</div>
            <div class="timeline-body"><p>This issue is forked from #3951.</p>
<p>When I attempt to use uv in a pyenv-virtualenv, I receive an error message indicating that there are no Python interpreters found in virtual environments. Since <code>sys.prefix!=sys.base_prefix</code> within a pyenv-virtualenv, it would be nice to be able to use uv therein, without having to invoke  with <code>--python=$(which python)</code>.</p>
<pre><code>$ venv_name=uv
$ pyenv uninstall --force ${venv_name}
$ pyenv virtualenv ${venv_name}
$ pyenv shell ${venv_name}
$ pip install uv

[details omitted]

$ uv --version
uv 0.2.6 (a589ad506 2024-06-03)
$ pyenv version
uv (set by PYENV_VERSION environment variable)
$ python -c 'import sys; print(f&quot;{(sys.prefix==sys.base_prefix)=}&quot;)'
(sys.prefix==sys.base_prefix)=False
$ uv pip install --upgrade pip --verbose
DEBUG Searching for Python interpreter in virtual environments
error: No Python interpreters found in virtual environments
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">compatibility</span> added by @charliermarsh on 2024-06-04 03:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-06-04 03:17</div>
            <div class="timeline-body"><p>Thanks @dpoznik!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-06-04 13:20</div>
            <div class="timeline-body"><p>Thanks for the issue! We should definitely support this without requiring a <code>--system</code> flag workaround.</p>
<p>Do you know <em>why</em> pyenv environments do not have <code>sys.prefix == sys.base_prefix</code>? Is there a <code>pyvenv.cfg</code> in the environment it creates?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpoznik">@dpoznik</a> on 2024-06-04 17:18</div>
            <div class="timeline-body"><blockquote>
<p>We should definitely support this without requiring a <code>--system</code> flag workaround.</p>
</blockquote>
<p>Sounds great; thanks!</p>
<blockquote>
<p>Do you know <em>why</em> pyenv environments do not have <code>sys.prefix == sys.base_prefix</code>? Is there a <code>pyvenv.cfg</code> in the environment it creates?</p>
</blockquote>
<p>Yes, <a href="https://github.com/pyenv/pyenv-virtualenv">pyenv-virtualenv</a> uses <code>python -m venv</code> on the back end:</p>
<pre><code>$ cat $(pyenv root)/versions/uv/pyvenv.cfg
home = /Users/dpoznik/.pyenv/versions/3.11.3/bin
include-system-site-packages = false
version = 3.11.3
executable = /Users/dpoznik/.pyenv/versions/3.11.3/bin/python3.11
command = /Users/dpoznik/.pyenv/versions/3.11.3/bin/python3.11 -m venv /Users/dpoznik/.pyenv/versions/3.11.3/envs/uv
</code></pre>
<p>In case relevant, I have the following in my <code>.bashrc</code>:</p>
<pre><code>eval &quot;$(pyenv virtualenv-init -)&quot;
</code></pre>
<p>That configures <code>pyenv-virtualenv</code> to &quot;automatically activate/deactivate virtualenvs on entering/leaving directories which contain a <code>.python-version</code> file that contains the name of a valid virtual environment&quot;, as described <a href="https://github.com/pyenv/pyenv-virtualenv?tab=readme-ov-file#activate-virtualenv">here</a>. Aside: This is the main feature for which I'm still using <code>pyenv-virtualenv</code> rather than <code>uv venv</code>; perhaps automatic activation would make for a worthwhile feature request in a third Issue.</p>
<p>Thanks for your help!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-06-04 17:59</div>
            <div class="timeline-body"><p>Hm I'm confused that the virtual environment isn't PEP 405 compliant if it has <code>pyenv.cfg</code> created by <code>venv</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpoznik">@dpoznik</a> on 2024-06-04 18:37</div>
            <div class="timeline-body"><blockquote>
<p>I'm confused that the virtual environment isn't PEP 405 compliant if it has <code>pyenv.cfg</code> created by <code>venv</code>.</p>
</blockquote>
<p>Interesting. I'm not all that familiar with PEP 405 or with how pyenv-virtualenv sets up environments.
What does compliance entail?</p>
<p>It's definitely possible I'm missing something, but I don't think #4018 will address this issue, as <code>VIRTUAL_ENV</code> is unset when the pyenv-virtualenv is activated:</p>
<pre><code class="language-sh">$ pyenv version
uv (set by PYENV_VERSION environment variable)
$ env | grep VIRTUAL_ENV
$ 
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-06-04 18:49</div>
            <div class="timeline-body"><p>Oh sorry I think I might have misunderstood the original issue! I'll start from the top so we can make sure we're on the same page.</p>
<p><a href="https://peps.python.org/pep-0405/">PEP 405</a> stipulates</p>
<blockquote>
<p>If a pyvenv.cfg file is found either adjacent to the Python executable or one directory above it (if the executable is a symlink, it is not dereferenced), this file is scanned for lines of the form key = value. If a home key is found, this signifies that the Python binary belongs to a virtual environment, and the value of the home key is the directory containing the Python executable used to create this virtual environment.</p>
<p>In this case, prefix-finding continues as normal using the value of the home key as the effective Python binary location, which finds the prefix of the base installation. sys.base_prefix is set to this value, while sys.prefix is set to the directory containing pyvenv.cfg.</p>
</blockquote>
<p>Thus, we say a PEP 405 compliant virtual environment must have <em>inequal</em> <code>sys.prefix</code> and <code>sys.base_prefix</code> values e.g.</p>
<p>https://github.com/astral-sh/uv/blob/365ca637c77b19b3f4f1caafc58801aff45abfae/crates/uv-interpreter/src/interpreter.rs#L156-L162</p>
<p>(and in <a href="https://github.com/pypa/pip/blob/0ad4c94be74cc24874c6feb5bb3c2152c398a18e/src/pip/_internal/utils/virtualenv.py#L14-L19"><code>pip</code></a>)</p>
<p>As I understand re-reading your comments now, you <em>do</em> have a compliant virtual environment in the current interpreter, e.g. <code>python -m ...</code> will be invoked inside a virtual environment. However, we do not detect this environment.</p>
<p>We only detect virtual environments in three ways:</p>
<ul>
<li><code>.venv</code> directory in the file system hierarchy</li>
<li><code>VIRTUAL_ENV</code></li>
<li><code>CONDA_PREFIX</code></li>
</ul>
<p>We don't currently support checking if the <em>current</em> interpreter on the <code>PATH</code> is a virtual environment. I presume this is the case for you because the pyenv <code>python</code> shim invokes commands within the proper environment? We could explore adding support for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpoznik">@dpoznik</a> on 2024-06-04 19:39</div>
            <div class="timeline-body"><blockquote>
<p>Oh sorry I think I might have misunderstood the original issue! I'll start from the top so we can make sure we're on the same page.</p>
</blockquote>
<p>Cool, thanks for all the information. We are definitely on the same page now.</p>
<blockquote>
<p>As I understand re-reading your comments now, you <em>do</em> have a compliant virtual environment in the current interpreter</p>
</blockquote>
<p>Exactly:</p>
<pre><code>$ python -c 'import sys; print(f&quot;{(sys.prefix==sys.base_prefix)=}&quot;)'
(sys.prefix==sys.base_prefix)=False
</code></pre>
<blockquote>
<p>We only detect virtual environments in three ways:</p>
<ul>
<li><code>.venv</code> directory in the file system hierarchy</li>
<li><code>VIRTUAL_ENV</code></li>
<li><code>CONDA_PREFIX</code></li>
</ul>
</blockquote>
<p>Got it. That explains it, as the pyenv-virtualenv has none of these properties. Thanks for this information!</p>
<blockquote>
<p>We don't currently support checking if the <em>current</em> interpreter on the <code>PATH</code> is a virtual environment. I presume this is the case for you because the pyenv <code>python</code> shim invokes commands within the proper environment?</p>
</blockquote>
<p>Exactly.</p>
<blockquote>
<p>We could explore adding support for this.</p>
</blockquote>
<p>That would be great; thanks!</p>
<p>Now that I have a better sense of what's going on, I'll go ahead and rename the Issue.
Thanks again!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Recognize a pyenv-virtualenv as a virtual environment" to "Check whether the *current* interpreter on the `PATH` is a virtual environment" by @dpoznik on 2024-06-04 19:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Check whether the *current* interpreter on the `PATH` is a virtual environment" to "Check whether the current interpreter on the `PATH` is a virtual environment" by @dpoznik on 2024-06-04 19:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Check whether the current interpreter on the `PATH` is a virtual environment" to "Check whether the interpreter currently set in `PATH` is associated with a virtual environment" by @dpoznik on 2024-06-11 00:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dpoznik">@dpoznik</a> on 2024-11-09 00:09</div>
            <div class="timeline-body"><p>I noticed that the problem reported in this issue has been resolved. Thanks!</p>
<p>Executing the same sequence of commands as is found in the description results in an expected/successful outcome. So I will go ahead and close the issue.</p>
<pre><code class="language-sh">$ venv_name=uv
$ pyenv uninstall --force ${venv_name}
$ pyenv virtualenv ${venv_name}
$ pyenv shell ${venv_name}
$ pyv
uv (set by PYENV_VERSION environment variable)
$ pip install uv

[details omitted]

$ uv --version
uv 0.5.0 (8d665267c 2024-11-07)
$ pyenv version
uv (set by PYENV_VERSION environment variable)
$ python -c 'import sys; print(f&quot;{(sys.prefix==sys.base_prefix)=}&quot;)'
(sys.prefix==sys.base_prefix)=False
$ uv pip install --upgrade pip --verbose
DEBUG uv 0.5.0 (8d665267c 2024-11-07)
DEBUG Searching for default Python interpreter in virtual environments
DEBUG Found `cpython-3.12.7-macos-aarch64-none` at `/Users/dpoznik/.pyenv/versions/uv/bin/python` (search path)
Using Python 3.12.7 environment at .pyenv/versions/uv

[details omitted]

</code></pre>
<p>A bisection indicates that version <code>0.2.14</code> fixed the issue:</p>
<pre><code class="language-sh">[m|~]: uv pip install -U --python=$(which python) uv==0.2.13
Resolved 1 package in 577ms
Prepared 1 package in 10.23s
Uninstalled 1 package in 13ms
Installed 1 package in 7ms
 - uv==0.2.15
 + uv==0.2.13
[m|~]: uv pip install --upgrade pip
error: No Python interpreters found in virtual environments
[m|~]: uv pip install -U --python=$(which python) uv==0.2.14
Resolved 1 package in 3.69s
Downloaded 1 package in 9.28s
Uninstalled 1 package in 14ms
Installed 1 package in 7ms
 - uv==0.2.13
 + uv==0.2.14
[m|~]: uv pip install --upgrade pip
Resolved 1 package in 189ms
Audited 1 package in 0.59ms
</code></pre>
<p>But I don't see anything in the <a href="https://github.com/astral-sh/uv/releases/tag/0.2.14">release notes</a> to this effect, so maybe the improvement was incidental? Just figured I'd mention in case doing so were to lessen the chance of a regression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dpoznik on 2024-11-09 00:09</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 04:38:37 UTC
    </footer>
</body>
</html>
