<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support portable mode: config lookup relative to uv binary &amp; relocatable venv Python binaries - astral-sh/uv #15751</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support portable mode: config lookup relative to uv binary &amp; relocatable venv Python binaries</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/15751">#15751</a>
        opened by <a href="https://github.com/PowerWordTree">@PowerWordTree</a>
        on 2025-09-09 13:59
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/PowerWordTree">@PowerWordTree</a></div>
            <div class="timeline-body"><p><strong>Support portable mode: config lookup relative to uv binary &amp; relocatable venv Python binaries</strong></p>
<hr>
<p><strong>Summary</strong><br>
I’d like to propose two related features to improve uv’s portability and cross-machine usability, especially for scenarios where the installation path differs between systems (e.g., desktop on <code>E:\</code>, laptop on <code>C:\</code>, or Linux installs under <code>/opt</code>).</p>
<hr>
<p><strong>1. Config lookup relative to uv executable</strong></p>
<ul>
<li><strong>Problem:</strong> Currently, uv only loads configuration from project-level files, user-level config (<code>~/.config/uv/uv.toml</code> or <code>%APPDATA%\uv\uv.toml</code>), and system-level config. There is no way to have a portable uv installation that automatically uses a config file located in a path relative to the uv executable.</li>
<li><strong>Why it matters:</strong><ul>
<li>On Windows, portable installs on different drives/paths require manual environment variable setup or user-level config changes.</li>
<li>On Linux or other systems, when uv is installed in a non-standard location, it would be convenient to ship a default config alongside the binary without touching user/system config.</li>
</ul>
</li>
<li><strong>Proposed solution:</strong><ul>
<li>Add an additional, <strong>highest-priority config lookup</strong> step: check for a config file in a location relative to the uv executable’s directory.</li>
<li>The exact relative path should be left to the developer or distributor; uv only needs to support resolving it relative to the binary location.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>2. Relocatable venv Python binaries</strong></p>
<ul>
<li><strong>Problem:</strong> uv-created virtual environments currently inherit CPython’s default behavior of embedding absolute paths into <code>python.exe</code> (Windows) or <code>bin/python</code> (Unix) and <code>pyvenv.cfg</code>. This makes the venv non-functional if the directory is moved to a different path or drive letter.</li>
<li><strong>Why it matters:</strong><ul>
<li>Portable or synchronized environments (e.g., shared between desktop and laptop, or moved between drives) break due to hardcoded paths.</li>
<li>This is a long-standing pain point in Python’s venv mechanism, and uv could offer an opt-in improvement.</li>
</ul>
</li>
<li><strong>Proposed solution:</strong><ul>
<li>Provide an option (e.g., <code>uv venv --relocatable</code>) to create venvs with relative paths in <code>pyvenv.cfg</code> and patched launchers that resolve the interpreter location at runtime.</li>
<li>Alternatively, integrate with Python’s embeddable distribution on Windows to achieve relocatability.</li>
</ul>
</li>
</ul>
<hr>
<p><strong>Benefits</strong></p>
<ul>
<li>Enables <strong>true portable mode</strong> for uv without forcing a fixed directory structure.</li>
<li>Reduces friction for developers who sync environments across machines or drives.</li>
<li>Makes uv more attractive for offline, air-gapped, or USB-based workflows.</li>
</ul>
Example
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/PowerWordTree">@PowerWordTree</a> on 2025-09-09 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/darsor">@darsor</a> on 2025-09-15 23:37</div>
            <div class="timeline-body"><p>I&#x27;d second the need for the second point. I run into this when using devcontainers. If a virtual environment is created outside the devcontainer, it can&#x27;t be used inside the container because the workspace mount point is different than the host path.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-09-16 02:02</div>
            <div class="timeline-body"><p>Regarding (1), see <a href="https://github.com/astral-sh/uv/issues/15836">astral-sh/uv#15836</a>
Regarding (2), see <a href="https://github.com/astral-sh/uv/issues/7865">astral-sh/uv#7865</a></p>
<blockquote>
<p>I run into this when using devcontainers. If a virtual environment is created outside the devcontainer, it can&#x27;t be used inside the container because the workspace mount point is different than the host path.</p>
</blockquote>
<p>You&#x27;ll usually have other problems, e.g., the packages will be installed for a different platform. I&#x27;d recommend not mounting the virtual environment into your container.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">duplicate</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2025-09-16 02:02</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:40:18 UTC
    </footer>
</body>
</html>
