```yaml
number: 10766
title: uv init --python-preference only-managed installs system python
type: issue
state: open
author: hyperknot
labels:
  - needs-decision
  - cli
assignees: []
created_at: 2025-01-20T01:33:37Z
updated_at: 2025-04-21T20:03:55Z
url: https://github.com/astral-sh/uv/issues/10766
synced_at: 2026-01-10T01:57:24Z
```

# uv init --python-preference only-managed installs system python

---

_Issue opened by @hyperknot on 2025-01-20 01:33_

version

```
uv version
uv 0.5.21 (3478c068b 2025-01-17)
```

If I run:

```
rm -r *
uv init --python 3.13 --python-preference only-managed
uv sync
```

I expect it to only use only-managed python files, like if I manually run `uv venv` with this switch.

What is happening instead is this output:

```
Using CPython 3.13.1 interpreter at: /opt/homebrew/opt/python@3.13/bin/python3.13
Creating virtual environment at: .venv
Resolved 1 package in 13ms
Audited in 0.28ms
```

As you can see it's using the brew installed system python.

---

What works is calling `uv sync --python-preference only-managed`. 

So the bug is that `init` is not creating the necessary lines in `pyproject.toml` which would instruct the `sync` command to use only-managed environments.

I believe this should be added to `pyproject.toml`

```
[tool.uv]
python-preference = "only-managed"
```

---

_Comment by @zanieb on 2025-01-20 02:14_

Yeah, we don't persist the python preference during `uv init` — this flag is only accepted for that command because it's "global". We definitely could persist it, though I'm not entirely sure we should (there is not a precedence for this right now).

---

_Label `needs-decision` added by @zanieb on 2025-01-20 02:15_

---

_Label `cli` added by @zanieb on 2025-01-20 02:15_

---

_Comment by @hyperknot on 2025-01-20 02:24_

I mean, isn't the whole point of this section

```
[tool.uv]
python-preference = "only-managed"
```

to store this setting on a project level, before running sync? I'm just surprised that the cli parameter is there and the pyproject setting is there, it's just not being used.

So what do you recommend for this use case? Specify Python version in init and specify only-managed at sync time?

```
uv init --python 3.13
uv sync --python-preference only-managed
```

What if someone runs this sync once and later on, just runs `uv sync` without this long parameter? Wouldn't it result in a possibly broken environment?




---

_Comment by @zanieb on 2025-01-20 03:28_

>  I'm just surprised that the cli parameter is there and the pyproject setting is there, it's just not being used.

As I said, it's a global option so it's available on every command regardless of whether it is used. It is used in `uv init` to find your default interpreter, i.e., when determining the version to use in the project. It's an open question if it should be persisted.

> isn't the whole point of this section...

The main point of that setting is to be used at a user-level, not a project level as ideally it shouldn't matter per-project which interpreter distribution is used. Is there a reason you want to configure this per-project? Is it just for local use or are you intending to enforce using uv-managed interpreters for other developers?

> What if someone runs this sync once and later on, just runs uv sync without this long parameter? Wouldn't it result in a possibly broken environment?
 
It wouldn't break the environment per-say, but it could re-create it. I'm actually not sure if we will invalidate an existing environment with that option yet though — there are some open problems around this (e.g., #5144). 



---

_Comment by @zanieb on 2025-01-20 03:30_

I would recommend just explicitly creating the environment with your preference

```
uv init ...
uv venv --python-preference only-managed
uv sync
```

---

_Comment by @charliermarsh on 2025-01-20 03:39_

@zanieb -- Not sure that it should, but I guess this would also be solved (in this specific case) by `uv init` creating a virtual environment. Is that true?

---

_Comment by @hyperknot on 2025-01-20 03:43_

So my previous workflow was exactly that, using `uv venv`. I'm trying to migrate from venv to sync, as I've read here that is the recommended workflow.

So yes, this is basically exactly what I want:

```
uv init --python 3.13
uv venv --python-preference only-managed
uv sync
```

It's just not very elegant with 3 commands. I also agree that this shouldn't be a repo level settings, it should be something local to the user.





---

_Comment by @charliermarsh on 2025-01-20 03:44_

You should be able to put that in your user-level `uv.toml`: https://docs.astral.sh/uv/configuration/files/

---

_Comment by @zanieb on 2025-01-20 03:48_

> [@zanieb](https://github.com/zanieb) -- Not sure that it should, but I guess this would also be solved (in this specific case) by `uv init` creating a virtual environment. Is that true?

I believe that is correct.

---

_Comment by @hyperknot on 2025-01-20 04:06_

In that case, it'd still make a lot of sense to supply this at init time and have init create the venv.

Basically merge these two:

```
uv init --python 3.13
uv venv --python-preference only-managed
```
into one command


---

_Comment by @danra on 2025-04-21 20:03_

Similar to others in the thread, I was surprised that `uv init` didn't persist the `managed-python` preference.

> Is there a reason you want to configure this per-project? Is it just for local use or are you intending to enforce using uv-managed interpreters for other developers?

The latter, for consistency of results.

One issue we'd actually encountered was a crash which only reproduced for some of our developers when linking to the Python dylib (on macs). The crash turned out to be due to https://github.com/astral-sh/uv/issues/10598 (our binary was failing to find Python at runtime due to the Python dylib's install name being faulty). It then turned out the crash occurred when the Python 3.13.1 selected by uv was a managed one, which was the case on those macOS machines which did not have 3.13.1 installed as their system Python.

One more potential issue (but that I don't recall if we'd seen in practice) is that when doing floating-point calculations it's desirable to get the same exact results (when running on the same architecture), which I guess could not be the case due to different Python build configurations (peeking at my system vs. uv-managed Python 3.13.1, `pyconfig.h` does have some differences, as could be expected).


---
