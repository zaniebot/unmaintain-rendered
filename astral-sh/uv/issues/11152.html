<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>feature request: `uv install` - astral-sh/uv #11152</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>feature request: `uv install`</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/11152">#11152</a>
        opened by <a href="https://github.com/MilkClouds">@MilkClouds</a>
        on 2025-02-01 12:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-02-01 12:33</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>I'm ML Engineer and I frequently manage multiple ML repositories who have loosely-defined dependencies.</p>
<p>Even if I manage my project's dependency strictly, it's impossible to manage their(other many ML researcher's repo) dependency strictly. It's because their repo is their repo and not my repo.</p>
<p>So I frequently use virtual environment managed by <code>conda</code> and I manage many packages with loose dependency consideration. In <code>poetry</code>, it's possible to run <code>poetry install</code> on my own <code>conda</code> environment and install/uninstall necessary packages in once. But in <code>uv</code>, I can't find equivalent one to <code>poetry install</code>.</p>
<p>Note that it's different with <code>uv sync</code>, which uninstalled all the packages which are not explicitly represented in dependency; <code>poetry install</code> only uninstall package if package's desired version is different with installed ones.</p>
<p>Since <code>uv lock</code> generated well-defined <code>uv.lock</code>, I guess it's sufficient to make a way to install packages in <code>uv.lock</code> without strict syncing. There might be a two way: implementing <code>uv install</code> or <code>uv pip install uv.lock</code>-like thing.</p>
<h3>Example</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @MilkClouds on 2025-02-01 12:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-02-01 12:56</div>
            <div class="timeline-body"><p>I guess there's multiple way to mock my required usecases:</p>
<ol>
<li>using <code>uv pip install</code></li>
</ol>
<pre><code class="language-sh">uv pip install -r pyproject.toml
</code></pre>
<p>but notably, <code>uv pip install</code> has lacking features than <code>uv sync</code>, e.g. dependency group, workspace, ....</p>
<ol start="2">
<li>using <code>uv export</code> followed by <code>uv pip install</code></li>
</ol>
<pre><code class="language-sh">uv export -o requirements.txt # or uv pip compile pyproject.toml -o requirements.txt 
uv pip install -r requirements.txt
</code></pre>
<p>This supports dependency group/workspace since <code>uv export</code> supports <code>--package/--group</code>, but it's two-line command and is not intuitive so much.</p>
<p><strong>I want <code>uv install</code> which provides similar set of features(dependency group/workspace/...) as <code>uv sync</code>.</strong></p>
<p>poetry supports this; <code>poetry install</code> provides <code>--with</code> flag(dependency group feature) and <code>--no-root</code> flag(skip pkg itself's install).</p>
<p>I'm managing mono-repo and <code>--with</code> flag and <code>--no-root</code> flag is mandatory to <code>install</code> command for me. following is my use-cases.</p>
<pre><code class="language-sh"># at project root, install common pkg as `projects/core` and dev pkg as `ruff, pytest`. project root itself is not a pkg; so `--no-root` is needed. only `projects/*` is pkg.
poetry install --no-root --with dev
# at each sub-project, install them if necessary
cd projects/abcd
poetry install
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-02-01 13:09</div>
            <div class="timeline-body"><p>to whom require same need as me: following is a script that implements ‚Å†uv install as a temporary measure.</p>
<pre><code class="language-sh">uv() {
  if [ &quot;$1&quot; = &quot;install&quot; ]; then
    shift
    if uv export -o requirements.txt &quot;$@&quot; &gt; /dev/null; then
      uv pip install -r requirements.txt
      rm -f requirements.txt
    else
      echo &quot;Error: 'uv export' failed.&quot; &gt;&amp;2
      return 1
    fi
  else
    command uv &quot;$@&quot;
  fi
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-02-01 13:32</div>
            <div class="timeline-body"><p>implementing <code>--no-root</code> is much more complex since <code>uv</code> does not install pkg itself as default. following script works, but it's long.</p>
<pre><code class="language-sh">uv() {
  if [ &quot;$1&quot; = &quot;install&quot; ]; then
    shift
    no_root=false
    args=()
    for arg in &quot;$@&quot;; do
      if [ &quot;$arg&quot; = &quot;--no-root&quot; ]; then
        no_root=true
      else
        args+=(&quot;$arg&quot;)
      fi
    done
    if uv export -o requirements.txt &quot;${args[@]}&quot; &gt; /dev/null; then
      uv pip install -r requirements.txt
      rm -f requirements.txt
      if [ &quot;$no_root&quot; = false ]; then
        uv pip install -e .
      fi
    else
      echo &quot;Error: 'uv export' failed.&quot; &gt;&amp;2
      return 1
    fi
  else
    command uv &quot;$@&quot;
  fi
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/FishAlchemist">@FishAlchemist</a> on 2025-02-01 14:14</div>
            <div class="timeline-body"><p>Does this command meet your expectations?</p>
<pre><code class="language-bash">uv sync --inexact
</code></pre>
<pre><code>--inexact
          Do not remove extraneous packages present in the environment
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-02-01 16:51</div>
            <div class="timeline-body"><p>@FishAlchemist Excellent, but it's not enough because it <code>uv</code> only deals with <code>python-venv</code> type virtual environments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-02-01 17:14</div>
            <div class="timeline-body"><p>I found a way.</p>
<p>executing <code>uv sync</code> after <code>export UV_PROJECT_ENVIRONMENT=~/miniforge3/envs/agent</code> installs pkgs in <code>conda</code>'s virtual environment.</p>
<p>However, I think accessibility to this method is very low. If there are quite a few people with similar needs, it might be necessary to add a command like <code>uv install</code> or include it in the documentation.</p>
<p>Overall, I'm concerned about <code>uv</code>'s design of managing <code>venv</code> forcefully.</p>
<p>Compared to <code>pip</code>, package managers like <code>poetry</code> and <code>uv</code> play a good role in managing lockfiles to prevent dependency conflicts. However, the functionality of (1) &quot;managing lockfiles&quot; and (2) &quot;managing virtual environments&quot; are <strong>orthogonal</strong> functions, and having <code>uv</code>, which (1) &quot;manages lockfiles&quot;, also forcefully (2) &quot;manage virtual environments&quot;  is not a good design choice in my opinion. How to (2) &quot;manage virtual environments&quot; should be the user's choice and freedom.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-01 17:34</div>
            <div class="timeline-body"><p>As suggested above, the <code>poetry install</code> equivalent is <code>uv sync --inexact</code>. We've intentionally avoided adding a top-level <code>uv install</code> command because it seems confusing to have multiple similar top-level options and expectations about <code>install</code> semantics differ, e.g., <code>cargo install</code> installs a binary like <code>uv tool install</code>.</p>
<p>I understand you feel like managing the virtual environments should be separate, but we've also very intentionally abstracted that concept. We don't think people should need to worry about managing virtual environments. We provide lower-level interfaces (as you discussed, <code>uv export</code>, <code>uv pip</code>) allowing you to do so if that's a feature you need. We also provide the  <code>UV_PROJECT_ENVIRONMENT</code> escape hatch for targeting arbitrary environments.</p>
<p>These concepts are fundamental to uv and are very unlikely to change. It seems you just want an easier way to set <code>UV_PROJECT_ENVIRONMENT</code> or different behavior around project environment detection?</p>
<p>Closing because we won't add a <code>uv install</code> command with the described semantics.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @zanieb on 2025-02-01 17:34</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:52:48 UTC
    </footer>
</body>
</html>
