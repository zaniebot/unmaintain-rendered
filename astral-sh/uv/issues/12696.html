<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Failure to build cydifflib (Compatibility with CMake &lt; 3.5 error) - astral-sh/uv #12696</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Failure to build cydifflib (Compatibility with CMake &lt; 3.5 error)</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/12696">#12696</a>
        opened by <a href="https://github.com/jlevy">@jlevy</a>
        on 2025-04-07 02:34
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-07 02:34</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>I'm trying to track down a build issue that has appeared on recent GitHub Actions builds of a library of mine, due to errors in building the dependency <a href="https://github.com/rapidfuzz/CyDifflib">cydifflib</a>.</p>
<p>Perhaps someone can help me narrow down if it's a uv issue or something else like a cmake or scikit-build issue in certain environments.</p>
<p>The exact same build used to work with uv and Python 3.13 and GitHub's ubuntu runner but then stopped working, without any change to deps or code, so it seems linked to certain environments.  I even narrowed it down that the exact same build had passed but then failed when rerun 2 weeks later (first and second runs of <a href="https://github.com/jlevy/chopdiff/actions/runs/13886580625">this build</a>, which presumably would only be due to a newer GitHub Actions runner image or maybe uv cache interactions).</p>
<p>I've also gotten reports of this issue on macOS but can't reproduce that myself. It affects Python 3.13 but not Python 3.11 and 3.12 on my tests.</p>
<p>The error is on latest uv and latest GitHub ubuntu runner: <code>Compatibility with CMake &lt; 3.5 has been removed from CMake</code>.</p>
<p>But I've confirmed the build environment actually has cmake version 3.31.6. And <a href="https://github.com/rapidfuzz/CyDifflib/blob/main/CMakeLists.txt#L1">cydifflib's declarations</a> ask for cmake 3.12.</p>
<p>A full repro and logs of this on GitHub Actions with a minimal project (only cydifflib as a dep) is <a href="https://github.com/jlevy/test-cydifflib/actions/runs/14299332468/job/40071007310">here</a></p>
<p>Thanks so much for any pointers!</p>
<p>Edit: Note the fix of setting CMAKE_ARGS to &quot;-DCMAKE_POLICY_VERSION_MINIMUM=3.5&quot; does work as a workaround on GitHub Actions. But this is still an issue because I want users to be able to <code>uv tool install</code> my libs without issues.</p>
<pre><code>Downloaded nodejs-wheel-binaries
  × Failed to build `cydifflib==1.1.0`
  ├─▶ The build backend returned an error
  ╰─▶ Call to `setuptools.build_meta.build_wheel` failed (exit status: 1)
...
      CMake Error at CMakeLists.txt:1 (cmake_minimum_required):
        Compatibility with CMake &lt; 3.5 has been removed from CMake.

        Update the VERSION argument &lt;min&gt; value.  Or, use the &lt;min&gt;...&lt;max&gt;
      syntax
        to tell CMake that the project requires at least &lt;min&gt; but has been
      updated
        to work with policies introduced by &lt;max&gt; or earlier.

        Or, add -DCMAKE_POLICY_VERSION_MINIMUM=3.5 to try configuring anyway.

      ********************************************************************************
                      scikit-build could not get a working generator for your
      system. Aborting build.

                      Building Linux wheels for Python 3.13 requires a
      compiler (e.g gcc).
      But scikit-build does *NOT* know how to install it on ubuntu

      To build compliant wheels, consider using the manylinux system described
      in PEP-[51](https://github.com/jlevy/test-cydifflib/actions/runs/14299332468/job/40071007310#step:6:52)3.
      Get it with &quot;dockcross/manylinux-x64&quot; docker image:

        https://github.com/dockcross/dockcross#readme

      For more details, please refer to scikit-build documentation:

        http://scikit-build.readthedocs.io/en/latest/generators.html#linux
</code></pre>
<h3>Platform</h3>
<p>ubuntu-latest 3.13 (GitHub Actions current runner 2.323.0)</p>
<h3>Version</h3>
<p>v0.6.12</p>
<h3>Python version</h3>
<p>Python 3.13.2</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @jlevy on 2025-04-07 02:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shauneccles">@shauneccles</a> on 2025-04-07 08:46</div>
            <div class="timeline-body"><p>GitHub updated runner images - see https://github.com/actions/runner-images/issues/11926</p>
<p>That's likely the cause of your issues.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-07 18:00</div>
            <div class="timeline-body"><p>@shauneccles thanks! Yeah it seems likely that was the trigger. Wow there are a lot of linked workaround commits on that runner-images issue.</p>
<p>I think it's still of concern to uv, in that I want uv to &quot;just work&quot; for libs like cydifflib, and I think this could bite people in other situations too?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shauneccles">@shauneccles</a> on 2025-04-07 18:46</div>
            <div class="timeline-body"><p>This isn't a uv issue - it's a build issue outside uvs control/sphere of influence.</p>
<p>All uv can do is surface the reason the build isn't working for people to troubleshoot.</p>
<p>The reasons a build doesn't work are numerous and complex - how can uv control/manage system level things such as the installed C compiler version?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">external</span> added by @zanieb on 2025-04-08 18:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-08 18:12</div>
            <div class="timeline-body"><p>Unfortunately we can't pin or check system packages yet. https://peps.python.org/pep-0725/ pokes at this idea.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> removed by @zanieb on 2025-04-08 18:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @zanieb on 2025-04-08 18:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-08 19:32</div>
            <div class="timeline-body"><p>@zanieb thanks! Interesting. Of course this is a large issue in general, but is there any recommended approach currently when distributing packages to streamline the experience for users where there a dependency like this?</p>
<p>An enormous benefit of uv is that you can just tell someone to uv tool install your package and it &quot;just works.&quot;</p>
<p>I realize some deps can't be handled except externally. In this case the build works if you add a single env var (CMAKE_ARGS=&quot;-DCMAKE_POLICY_VERSION_MINIMUM=3.5&quot;). Seems like there could be a way to tell uv this?</p>
<p>I'm even considering adding a kind of bootstrapping process around uv that tests/inspects and suggests what to install based on the current platform, since I have a tool that expects cydifflib and a few other external deps. But that also kind of defeats the elegance of uv...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-08 19:45</div>
            <div class="timeline-body"><p>It seems like that would need to be handled in <a href="https://github.com/rapidfuzz/CyDifflib">cydifflib</a>'s build system. We could add supporting for patching environment variables while building dependencies, but that's sort of a whack-a-mole approach whereas tweaking the build system upstream would resolve the issue for everyone.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rapidfuzz/CyDifflib/issues/6.html">rapidfuzz/CyDifflib#6</a> on 2025-04-08 23:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-08 23:43</div>
            <div class="timeline-body"><p>@zanieb I've added an issue there too now, thanks. Definitely agree long term goal should always be proper fixes upstream.</p>
<p>At the same time, it's a bit ugly, but imo it'd be great if developers could do <em>something</em> in their projects (besides just giving more complex install instructions) to avoid headaches for <em>their</em> users, without waiting for upstream deps to change.</p>
<p>Fwiw another example is WeasyPrint and again the (hopefully temporary) workaround was for me to manually hack env vars for users:
https://github.com/Kozea/WeasyPrint/issues/1448
https://github.com/astral-sh/uv/issues/6971</p>
<p>So the q is not so much whether to play whack-a-mole, but whether it can be played with less effort. :) Thanks again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shauneccles">@shauneccles</a> on 2025-04-09 00:04</div>
            <div class="timeline-body"><p>Your best bet might be to using docker to manage the entire process if you're worried about managing user environments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-09 17:06</div>
            <div class="timeline-body"><p>@zanieb for what it's worth just saw a good discussion of this need <a href="https://www.reddit.com/r/Python/comments/1jv3t1e/comment/mm7dbt1/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">here on r/Python</a> as well.</p>
<p>Docker is certainly useful but doesn't apply to the use case helping downstream users/team members/etc who want to run with minimal fuss (aside from installing uv) and without Docker.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-09 17:37</div>
            <div class="timeline-body"><blockquote>
<p>At the same time, it's a bit ugly, but imo it'd be great if developers could do something in their projects (besides just giving more complex install instructions) to avoid headaches for their users, without waiting for upstream deps to change.</p>
</blockquote>
<p>To be clear, are you asking for a feature where you can configure <em>your</em> package to set a variable for a <em>dependent</em> package such that when a user installs <em>your</em> package (e.g., via <code>uv tool install &lt;name&gt;</code> ) we populate the variable?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-09 20:49</div>
            <div class="timeline-body"><p>@zanieb yes. I'm new to uv and correct me if uv already supports some other way to do this, but what I was imagining was:</p>
<p>If I am building <code>mytool</code> and it depends on <code>somelib</code>, it should be possible be to have a uv setting in <code>mytool</code>'s pyproject.toml that gives <code>mytool</code> control over what env vars are set before <code>somelib</code> is built. That way it's zero config for anyone who wants to <code>uvx mytool</code> or <code>uv tool install mytool</code>.</p>
<p>Thinking about it a little more:</p>
<ul>
<li><p>I could imagine use cases also for markers just like existing support of markers in deps (like one env var for macOS and one for Linux)</p>
</li>
<li><p>But it's much more complexity to consider this like deps transitively across all packages, e.g. it might be confusing to deal with conflicting deps (<code>a</code> depends on <code>b</code> and <code>c</code> and <code>b</code> and <code>c</code> have env vars declared to affect <code>d</code>).</p>
</li>
<li><p>So to perhaps it could simply be considered a pyproject.toml equivalent to UV_ENV_FILE and only apply at the top level of the build? This puts the responsibility of the build settings on the final tool packager but not on libs everywhere.</p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-09 21:00</div>
            <div class="timeline-body"><p>We don't want to do that because <code>somelib</code> may be a dependency of some other package (<code>foo</code>) in the dependency tree and then <code>somelib</code> could break if the configuration <code>mytool</code> sets is not compatible with the needs of <code>foo</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-09 21:35</div>
            <div class="timeline-body"><p>Yes. But if I am the packager of <code>mytool</code> I'm responsible for making it work on all its deps, just as I am responsible for testing my code for interactions after any uv.lock change.</p>
<p>My setting won't break anyone else if the env vars apply to <code>mytool</code>'s build only. It's not perfect control, but isn't  it then equivalent to if I edit my CI env setting? It's just in my toml file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-09 22:04</div>
            <div class="timeline-body"><p>There's no way to limit <code>mytool</code>'s installation such that it's not installed with other packages you don't control. What if someone does <code>uv add mytool foo</code>? What if they do <code>uv tool run --with foo mytool</code>?</p>
<p>I think if you want more control over a dependency, you should just vendor it into <code>mytool</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlevy">@jlevy</a> on 2025-04-10 19:36</div>
            <div class="timeline-body"><p>Agree it's tricky. Bear with me thinking about it a bit more as the best option isn't obvious to me.</p>
<p>Say I have <code>mytool</code> and it depends on <code>somelib</code> <em>plus</em> some build options (<code>OPT=hack1</code>) to get <code>somelib</code> to work in the context of <code>mytool</code>. Ideally, anyone can just install <code>mytool</code> and it works.</p>
<p>Now <code>yourtool</code> depends on <code>mytool</code> and <code>foo</code>. And <code>foo</code> has incompatible build options (<code>OPT=hack2</code>) for <code>somelib</code>. Ideally this would be a conflict <code>yourtool</code> would have to deal with.</p>
<p>Options (from surgical to extensive):</p>
<ol>
<li>In the <code>mytool</code> readme I tell users to set <code>OPT=hack1</code> before installation (current status quo)</li>
<li>There's a way for <code>uv tool install mytool</code> to automatically set <code>OPT=hack1</code> but this doesn't apply to builds for <code>yourtool</code> (that is what I was hoping for as it's a quick fix)</li>
<li>I fork <code>somelib</code> with build changes and alter <code>mytool</code> to depend on <code>somelib-fork</code></li>
<li>We formally declare these build options somehow so that it's apparent to uv when build options are incompatible and it tells developers</li>
<li>There's something else like a stub or hook that lets you alter/wrap a dependency via another script</li>
</ol>
<p>I do wonder if longer term something like (4) would be quite useful. It's in fact similar to functionality uv already offers in terms of identifying incompatible dependency constraints.</p>
<p>Maybe this is effectively where uv+PEP-725 is going? In a lot of ways, things like <code>CMAKE_ARGS</code> and running <code>brew install ffmpeg</code> are pretty similar. Just external OS deps with unclear implications, but still worth tracking formally.</p>
<p>Glad for any further thoughts. I'm still not sure (2) is impossible if it was basically like an env var workaround to putting something in a readme. But thinking for now (3) is my best option as that isn't blocked on uv or on upstream changes. Maybe there could be a way to make (3) less extensive and more maintainable than a full GitHub fork.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-15 20:36</div>
            <div class="timeline-body"><p>Yeah I think (4) requires upstream standardization, or uv cannot reliably detect conflicts.</p>
<p>(3) makes sense. We are interested in the idea of improving vendoring workflows like that, but it's a bit lower priority than some other pain points.</p>
<p>(2) could work, but it's a little questionable as it invalidates some base assumptions in our cache. I think in the long term, we want to special case tool installs when the package uses uv, such as adding a <code>--locked</code> option.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:33:04 UTC
    </footer>
</body>
</html>
