```yaml
number: 8878
title: "uv add and uv sync doesn't install packages in virtual env created by uv venv <custom venv name> but creates the default .venv"
type: issue
state: closed
author: amanchaudhary-95
labels:
  - question
assignees: []
created_at: 2024-11-07T05:39:00Z
updated_at: 2025-07-28T14:56:56Z
url: https://github.com/astral-sh/uv/issues/8878
synced_at: 2026-01-10T01:57:20Z
```

# uv add and uv sync doesn't install packages in virtual env created by uv venv <custom venv name> but creates the default .venv

---

_Issue opened by @amanchaudhary-95 on 2024-11-07 05:39_

<!--
Thank you for taking the time to report an issue! We're glad to have you involved with uv.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `uv pip sync requirements.txt`), ideally including the `--verbose` flag.
* The current uv platform.
* The current uv version (`uv --version`).
-->

Current uv version: uv 0.4.29 (85f9a0d0e 2024-10-30)
OS: Windows 11

I created a project using ```uv init``` and then created a venv with the name "Temp_Venv" inside that project using ```uv venv Temp_Venv```, the environment was created perfectly. After that, I activated the newly created environment and tried to add python package using ```uv add pandas```, it did not install the package in the activated environment instead it created a new environment with the name .venv and installed the package in that environment. It does the same even after setting the ```VIRTUAL_ENV=D:\Test\Test_Venv\Temp_Venv```.

### Steps to reproduce:
Step 1: Init a Project with ```uv init Test_Venv```

Step 2: Change the directory and create a venv with a custom name of 'Temp_Venv' in that project
```cd .\Test_Venv\```
```uv venv Temp_Venv```

Step 3: Activate the newly created venv
```.\Temp_Venv\Scripts\activate```

Step 4: Add a package using uv add
```uv add pandas```

It will give a warning
```warning: `VIRTUAL_ENV=Temp_Venv` does not match the project environment path `.venv` and will be ignored```
and it will create a new venv with a default name .venv and it will add the package in this .venv env and not in the activated ```Temp_Venv```

I also tried to set the ```VIRTUAL_ENV``` path but still got the same result

Screenshot: 
![image](https://github.com/user-attachments/assets/7953245d-d48a-4088-bdde-d7edd030a8d4)


---

_Comment by @nlohmann on 2024-11-07 09:26_

Same issue when using

```shell
uv venv venv
source venv/bin/activate
uv sync
```

Output of the last command:

```
warning: `VIRTUAL_ENV=venv` does not match the project environment path `.venv` and will be ignored
Using CPython 3.13.0 interpreter at: /opt/homebrew/opt/python@3.13/bin/python3.13
Creating virtual environment at: .venv
```

---

_Comment by @berislavlopac on 2024-11-07 11:01_

The documentation says that `uv` does not respect the `VIRTUAL_ENV` variable, which I find very annoying; see https://docs.astral.sh/uv/concepts/projects/#configuring-the-project-environment-path

---

_Comment by @charliermarsh on 2024-11-07 13:20_

The top-level project commands (`uv sync`, `uv lock`, `uv run`, `uv tree`, `uv export`) always use `.venv`. It's intentional and that's why you're seeing a warning to make you aware of the behavior. You can set `UV_PROJECT_ENVIRONMENT` to use something else, though it's largely intended for use in continuous integration and other environments.

---

_Label `question` added by @charliermarsh on 2024-11-07 13:20_

---

_Comment by @nlohmann on 2024-11-07 13:24_

I see. It might be intentional, but it's currently blocking the adoption of uv in a project, because all existing documentation and CI pipelines assume `venv` to be the path, and changing all this to `.venv` is too much effort. Maybe on top of the warning, a parameter to override this behavior could be helpful.

In the meantime, is there a way to set the project environment in pyproject.toml?

---

_Comment by @charliermarsh on 2024-11-07 13:28_

No, we don't expose it in the `pyproject.toml` though I'll let @zanieb comment on whether we'd add that. We're intentionally pushing to standardize on this naming scheme in these new APIs. (The `uv pip` APIs work with other environments without an issue.)


---

_Comment by @berislavlopac on 2024-11-07 13:55_

@charliermarsh I'm curious why was it decided not to honour that variable? It's a pretty standard solution, and it's a common practice to manage the environment separately from the packaging and dependency management.

---

_Comment by @charliermarsh on 2024-11-07 13:58_

We honor it in `uv pip` but not the project APIs, which is based around a more opinionated workflow. There's context on it here: https://github.com/astral-sh/uv/pull/6834.

---

_Comment by @berislavlopac on 2024-11-07 14:15_

OK, fair enough, I understand the decision. I'm not sure yet whether I agree with it, but I'll try playing with uv without an active environment and decide based on how much that affects my workflow (having to put `uv run` in front of every command is a bit annoying and goes against my muscle memory, but I can think of a few workarounds).

The only other thing I can think of might be to include a configuration option to prevent running a command if there is an activated environment (or at least to add a confirmation prompt, instead of just a warning); I'd prefer to have some control when an environment is created.

---

_Comment by @zanieb on 2024-11-07 14:28_

> No, we don't expose it in the `pyproject.toml` though I'll let @zanieb comment on whether we'd add that.

No we're not planning on adding it to the `pyproject.toml`; I don't think the project should be able to declare where the developer stores the virtual environment. We might add support in the `uv.toml` though.

> all existing documentation and CI pipelines assume venv to be the path

Why does the virtual environment need to be discoverable at a hard-coded path? Just want to try to understand the use-case.

> I'll try playing with uv without an active environment and decide based on how much that affects my workflow (having to put uv run in front of every command is a bit annoying and goes against my muscle memory, but I can think of a few workarounds).

You can definitely activate the environment still.

> and changing all this to .venv is too much effort.

Does `UV_PROJECT_ENVIRONMENT` not work for you?

---

_Comment by @berislavlopac on 2024-11-07 15:11_

> You can definitely activate the environment still.

Oh, of course; it's just that in my case a couple of uv's idiosyncracies collide with my usual setup. But as I said, I can think of a few workarounds; I'll know more when I try them.

---

_Comment by @amanchaudhary-95 on 2024-11-08 07:09_

> > No, we don't expose it in the `pyproject.toml` though I'll let @zanieb comment on whether we'd add that.
> 
> No we're not planning on adding it to the `pyproject.toml`; I don't think the project should be able to declare where the developer stores the virtual environment. We might add support in the `uv.toml` though.
> 
> > all existing documentation and CI pipelines assume venv to be the path
> 
> Why does the virtual environment need to be discoverable at a hard-coded path? Just want to try to understand the use-case.
> 
> > I'll try playing with uv without an active environment and decide based on how much that affects my workflow (having to put uv run in front of every command is a bit annoying and goes against my muscle memory, but I can think of a few workarounds).
> 
> You can definitely activate the environment still.
> 
> > and changing all this to .venv is too much effort.
> 
> Does `UV_PROJECT_ENVIRONMENT` not work for you?

Hi @zanieb, I also tried setting the ```UV_PROJECT_ENVIRONMENT``` variable as an absolute path as ```set UV_PROJECT_ENVIRONMENT=D:\Test\Test_Venv\Temp_Venv``` and as relative path as ```set UV_PROJECT_ENVIRONMENT=Temp_Venv``` but I'm still getting the same warning. Packages are added in the autocreated ```.venv``` environment
![image](https://github.com/user-attachments/assets/4bf22b6a-eb19-4197-98ed-1e5787e6364d)


---

_Comment by @nlohmann on 2024-11-08 07:17_

> > all existing documentation and CI pipelines assume venv to be the path
> 
> Why does the virtual environment need to be discoverable at a hard-coded path? Just want to try to understand the use-case.

We have a very heavy Makefile that has targets for a lot of jobs such as creating a virtual environment, execute tests, etc. That Makefile predates tools like uv and is used in multiple projects to unify the workflows. As such `venv` is hardcoded there and then also assumed as path in the CI jobs. This is not nice and I want to modernize this with tools like uv. For this, I don't want to touch too much, and it would be much easier for me to just keep the virtual environment at `venv`.

> > and changing all this to .venv is too much effort.
> 
> Does `UV_PROJECT_ENVIRONMENT` not work for you?

I don't control the developers environment variables, so I cannot assume that variable to be set. I can try to pull it into our Makefile, but rooting this to pyproject.toml would have been the easier choice.

---

_Comment by @reder2000 on 2025-01-27 18:08_

It is also really annoying because I cannot use uv add with pycharm or with different Python versions.

---

_Comment by @thomasaarholt on 2025-01-31 15:16_

@amanchaudhary-95 I get it to work by setting the `UV_PROJECT_ENVIRONMENT` env variable _equal_ to the `VIRTUAL_ENV`. The important point is that `UV_PROJECT_ENVIRONMENT` needs to be a **full path**, or I guess relative to the current directory (as `.venv` would be).

---

_Comment by @reder2000 on 2025-02-16 00:12_

pycharm just added official support for uv and it sucks because there is no way to choose where files are installed. (Poetry support sucks as well, but a bit differently)

---

_Comment by @zanieb on 2025-02-16 04:11_

We now support a `--active` flag on `uv sync`, `uv run`, etc.

(But we won't detect inactive environments with arbitrary names and won't detect active environments by default. See https://github.com/astral-sh/uv/issues/11273 for a non-CLI option)

---

_Closed by @zanieb on 2025-02-16 04:11_

---

_Comment by @Jerakin on 2025-07-28 14:56_

I want package my project with [pyinstaller](https://github.com/pyinstaller/pyinstaller), and as my project is using a [`justfile`](https://github.com/casey/just) to run other commands I want to use it for this too. However, `just` runs each command in its own shell, meaning that if I activate a venv it will not be active in the other subsequent commands, meaning that `--active` doesn't work here.

I would have hoped there was a `uv sync --with-venv myvenv`, but given this discussion I don't think this would be something that the project would like to implement.

Have anyone used justfile with uv and non-default venvs with success?


Justfile command (which doesn't work)
```
pyinstall:
  uv venv pyinstall
  pyinstall\Scripts\activate.bat
  uv sync --group build-exe
  uv run pyinstaller -y __main__.spec
```



---
