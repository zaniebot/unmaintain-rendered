```yaml
number: 11525
title: git bisect like feature for updating lock files
type: issue
state: open
author: gaborbernat
labels:
  - enhancement
  - wish
assignees: []
created_at: 2025-02-14T21:04:49Z
updated_at: 2025-02-14T22:12:10Z
url: https://github.com/astral-sh/uv/issues/11525
synced_at: 2026-01-10T01:57:26Z
```

# git bisect like feature for updating lock files

---

_Issue opened by @gaborbernat on 2025-02-14 21:04_

### Summary

Sometimes when you refresh your lock file you find out that your app/test suite broke. There's today no easy way today to quickly identify what (combination or single) dependency caused your application to break. It would be great if `uv lock --update --step-wise` would in this cases update one dependency at a time, giving the opportunity to the caller to run a test suite in between. When the test suite fails the latest change could help to quickly pinpoint to the faulty upgrade.

### Example

```
uv lock --update --step-wise --test-command 'pytest --cool'
```

---

_Label `enhancement` added by @gaborbernat on 2025-02-14 21:04_

---

_Label `wish` added by @zanieb on 2025-02-14 21:12_

---

_Comment by @gaborbernat on 2025-02-14 21:21_

From @zanieb, AI wrote a script, probably not something we can priortize in uv itself for quite some time

```python
import subprocess
import sys
import re
from typing import List, Optional


def run_command(cmd: List[str]) -> tuple[bool, str]:
    """
    Run a command and return whether it succeeded and its output.
    """
    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
        return result.returncode == 0, result.stdout + result.stderr
    except Exception as e:
        return False, str(e)


def get_top_level_packages() -> set[str]:
    """
    Parse the output of 'uv tree' to get top-level packages.
    """
    success, output = run_command(["uv", "tree"])
    if not success:
        print(f"Error running 'uv tree': {output}")
        sys.exit(1)

    packages = set()
    # Skip the project name
    for line in output.splitlines()[1:]:
        # Look for lines that start with '└──' or '├──'
        if line.strip().startswith(("└──", "├──")):
            # Extract package name and version
            match = re.search(r"[└├]── ([a-zA-Z0-9\-_]+) v", line)
            if match:
                packages.add(match.group(1))

    return packages


def update_package(package: str, post_update_cmd: Optional[List[str]]) -> bool:
    """
    Update a single package using uv lock and run post-update command if provided.
    Returns True if all operations succeeded.
    """
    print(f"\nUpdating {package}...")

    # Run uv lock --upgrade-package
    success, output = run_command(["uv", "lock", "--upgrade-package", package])
    if not success:
        print(f"Failed to update {package}:")
        print(output)
        return False

    print(f"Successfully updated {package}")

    # Run post-update command if provided
    if post_update_cmd:
        print(f"Running post-update command: {' '.join(post_update_cmd)}")
        success, output = run_command(post_update_cmd)
        if not success:
            print(f"Post-update command failed:")
            print(output)
            return False
        print("Post-update command succeeded")

    return True


def main():
    # Get post-update command from command line arguments
    post_update_cmd = sys.argv[1:] if len(sys.argv) > 1 else None

    if not post_update_cmd:
        print("Warning: No post-update command provided")
    else:
        print(f"Post-update command: {' '.join(post_update_cmd)}")

    # Get top-level packages
    packages = get_top_level_packages()
    print(f"Found {len(packages)} top-level packages: {', '.join(packages)}")

    # Update each package
    success_count = 0
    for package in packages:
        if update_package(package, post_update_cmd):
            success_count += 1
        else:
            print(f"\nStopping after failure on {package}")
            break

    # Print summary
    print(f"\nSummary: Successfully updated {success_count}/{len(packages)} packages")
    sys.exit(0 if success_count == len(packages) else 1)


if __name__ == "__main__":
    main()
```

---

_Comment by @hauntsaninja on 2025-02-14 21:56_

You can also use `--exclude-newer` to effectively bisect through time

---

_Comment by @zanieb on 2025-02-14 22:12_

Minor note that `get_top_level_packages`... does not do that — it gets indirect dependencies too but it seems vaguely correct to bump each dependency. Once we have JSON output, it'd be simpler? #411 You'd want to remove workspace members and such too.

---
