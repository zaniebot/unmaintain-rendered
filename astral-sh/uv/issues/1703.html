<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for managing Conda environments and packages - astral-sh/uv #1703</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for managing Conda environments and packages</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/1703">#1703</a>
        opened by <a href="https://github.com/matterhorn103">@matterhorn103</a>
        on 2024-02-19 16:20
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-02-19 16:20</div>
            <div class="timeline-body"><p>I'm very excited by uv and the possibilities it hints at for the future of one-stop packaging and environment management.</p>
<p>As for a vast number of scientists, though, conda is pretty much essential to many of my projects. A package manager limited to PyPI may replace pip and venv for pure Python projects for me but will always have to sit alongside conda with conda-forge.</p>
<p>I get that it's still very early days, but are there any ambitions/plans to truly turn Python packaging into a single effective ecosystem and unite the science and programming camps? Might uv in future also manage conda environments or use packages from conda-forge/other repos?</p>
<p>Or should I reign in my excitement a little?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @zanieb on 2024-02-19 16:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-02-19 16:55</div>
            <div class="timeline-body"><p>This might be out of scope for us. I'm not sure about the long-term future, but definitely in the short term. <a href="https://prefix.dev/">Prefix.dev</a> is more focused on conda integration.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-02-19 19:02</div>
            <div class="timeline-body"><p>Ok, thanks. I understand, but still a pity. A single Python management tool for both camps would be nice one day.</p>
<p>Hopefully the collaboration between you and the pixi team continues and they become complementary tools following the same standards :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/forrestfwilliams">@forrestfwilliams</a> on 2024-02-21 13:30</div>
            <div class="timeline-body"><p>Wanted to echo my support for this question as well. Many AI/ML and scientific workflows rely on Python packages that have complex C/C++ dependencies. <a href="https://pypi.org/project/GDAL/">GDAL</a> is a good example of a package that is essential for many Python applications, but installing it via Pip requires that you have already installed the GDAL C library your machine.</p>
<p>Conda-based tools generally do a good job of managing both the Python and C/C++ dependencies, which is why many scientists use this ecosystem. Unfortunately, using a package manager that cannot manage these lower-level dependencies is a non-starter for many of us.</p>
<p>Would love to see the <code>uv</code> team try to come up with their own solution for this problem sometime in the future!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sam-goodwin">@sam-goodwin</a> on 2024-04-10 23:37</div>
            <div class="timeline-body"><p>Just ran into this with a requirement to use <code>mambda</code> to use a specific version of <code>tensorflow</code> on a Mac. It would be great if UV could support conda environments.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/den-run-ai">@den-run-ai</a> on 2024-05-07 18:58</div>
            <div class="timeline-body"><p>just had an issue that uv does not work in a conda environment, but installation is ok. uv binary is missing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/marcelroed">@marcelroed</a> on 2024-08-23 00:03</div>
            <div class="timeline-body"><p>With the latest stabilizations <code>uv</code> has covered a majority of my needs for a Python packaging solution. However, the needs of Python users in the scientific space go a little further than the stated goal of being to Python what Cargo is to Rust. In scientific Python, environments are expected to include system libraries and other important packages that don't mesh well with PyPI.</p>
<p>Currently my environments require something like <code>micromamba</code> or <code>pixi</code> for system packages and binaries, and then <code>uv</code> to install PyPI packages that either can't be sourced from Conda repos, or are easier to manage in PyPI. For example, I might need to install a modern C++ compiler and some system libraries with conda before using <code>uv</code> to install the rest of my requirements. A key issue with this is that solving is not possible across this boundary, leading to environments that deteriorate over time, and the requirements for an install script that orders installs instead of just a single <code>requirements.txt</code> (or <code>environment.yml</code>) that can be solved.</p>
<p>In short, supplanting <code>pip</code> has been a brilliant beginning for <code>uv</code> to take off, but I can't see a world where scientific Python has its needs met by a solution that can only solve using packages on PyPI. Python is not Rust, and users expect an all-encompassing Python package manager to provide more than what <code>pip</code> currently does.</p>
<p>@zanieb, have there been any developments in thinking about expanding capabilities in this direction, or is this still out of scope? I'm partially served by <code>pixi</code> for my use-cases, but I still find just using <code>uv</code> from the terminal to be superior when dealing with the PyPI side of package management.</p>
<p>Thanks for the great work in this space! <code>uv</code> has been a huge boost to my morale and productivity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-23 12:42</div>
            <div class="timeline-body"><p>Thanks for the well written comment.</p>
<p>We care about scientific Python (several of us worked in that domain before Astral), but right now we're focused on polishing the project management experience and working on correctness. Hopefully we'll be able to figure out a good story for Conda integration, but it's not in the immediate scope.</p>
<blockquote>
<p>Thanks for the great work in this space! uv has been a huge boost to my morale and productivity.</p>
</blockquote>
<p>That's great to hear &lt;3</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @zanieb on 2024-08-23 12:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @zanieb on 2024-08-23 12:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shuowpro">@shuowpro</a> on 2024-09-04 00:09</div>
            <div class="timeline-body"><p>Is it possible to export a Conda environment YAML file? It already supports exporting a <code>requirements.txt</code> file, so adding support for exporting a Conda environment file shouldn't be difficult. As a temporary workaround, we can still export the environment file while using pip as the package manager.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-09-10 13:38</div>
            <div class="timeline-body"><p>@zanieb related to your response in <a href="https://github.com/astral-sh/uv/issues/6989#issuecomment-2328978747">#6989</a>:</p>
<blockquote>
<p>I think it's okay to support if it works, but I'm not sure how well it will translate since Conda has, for example, different names for some packages. We can't actually perform a resolution with Conda.</p>
</blockquote>
<p>It has felt to me for a while that the unknown correspondence between PyPI and Conda packages is the biggest thing keeping the ecosystems separate. When looking into the topic many months ago I came across Grayskull, <a href="https://github.com/conda/grayskull/issues/168">this thread discussing the exact problem</a>, and <a href="https://github.com/regro/cf-graph-countyfair/blob/master/mappings/pypi/grayskull_pypi_mapping.yaml">this bot-generated mapping effort</a>. By no means exhaustive, but I imagine some mapping like that would be a necessary starting point for Conda/PyPI interop, so figured I'd leave the links here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rosmur">@rosmur</a> on 2024-11-18 07:27</div>
            <div class="timeline-body"><p>@matterhorn103 alternatively, is there any (technical) reason to continue using anything in the conda ecosystem? I've made the decision to never install anaconda or anything related on my new MacBook and im all in on uv - its the future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-11-18 08:56</div>
            <div class="timeline-body"><p>Like you, I don't use Conda personally at all any more. But I know that colleagues do and are unlikely to be budged. Part of that is that although PyPI can now, thanks to wheels, match Conda in the historically difficult things like <code>numpy</code>, in my field at least programs are often distributed via <code>conda-forge</code> that have no Python content whatsoever and will therefore never be on PyPI.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2024-11-18 09:10</div>
            <div class="timeline-body"><p>I try to avoid <code>conda</code> in favor of <code>uv</code> whenever possible. However, certain packages have so complex external dependencies its is not always feasible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bart-maykin">@bart-maykin</a> on 2024-11-22 15:55</div>
            <div class="timeline-body"><p>There's https://github.com/nextgis/pygdal which installs without problems with pip, but uv pip fails.
<code>pip install  pygdal==3.4.1.10</code>  install fine.
<code>uv pip install  pygdal==3.4.1.10</code> gives this output: (the version is needed because of the C library version I have installed)</p>
<pre><code class="language-console">Resolved 2 packages in 5ms
error: Failed to prepare distributions
  Caused by: Failed to fetch wheel: pygdal==3.4.1.10


[stdout]
running bdist_wheel
running build
running build_py
copying ./osgeo/gnm.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/gdalnumeric.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/gdalconst.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/gdal_array.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/utils.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/gdal.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/osr.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/__init__.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
copying ./osgeo/ogr.py -&gt; build/lib.linux-x86_64-cpython-311/osgeo
running egg_info
writing pygdal.egg-info/PKG-INFO
writing dependency_links to pygdal.egg-info/dependency_links.txt
writing requirements to pygdal.egg-info/requires.txt
writing top-level names to pygdal.egg-info/top_level.txt

[stderr]
Traceback (most recent call last):
  File &quot;&lt;string&gt;&quot;, line 11, in &lt;module&gt;
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/build_meta.py&quot;, line 435, in build_wheel
    return _build(['bdist_wheel'])
           ^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/build_meta.py&quot;, line 426, in _build
    return self._build_with_temp_dir(
           ^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/build_meta.py&quot;, line 407, in _build_with_temp_dir
    self.run_setup()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/build_meta.py&quot;, line 522, in run_setup
    super().run_setup(setup_script=setup_script)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/build_meta.py&quot;, line 320, in run_setup
    exec(code, locals())
  File &quot;&lt;string&gt;&quot;, line 225, in &lt;module&gt;
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/__init__.py&quot;, line 117, in setup
    return distutils.core.setup(**attrs)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/core.py&quot;, line 183, in setup
    return run_commands(dist)
           ^^^^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/core.py&quot;, line 199, in run_commands
    dist.run_commands()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/dist.py&quot;, line 954, in run_commands
    self.run_command(cmd)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/dist.py&quot;, line 995, in run_command
    super().run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/dist.py&quot;, line 973, in run_command
    cmd_obj.run()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/bdist_wheel.py&quot;, line 381, in run
    self.run_command(&quot;build&quot;)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/cmd.py&quot;, line 316, in run_command
    self.distribution.run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/dist.py&quot;, line 995, in run_command
    super().run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/dist.py&quot;, line 973, in run_command
    cmd_obj.run()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/command/build.py&quot;, line 135, in run
    self.run_command(cmd_name)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/cmd.py&quot;, line 316, in run_command
    self.distribution.run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/dist.py&quot;, line 995, in run_command
    super().run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/dist.py&quot;, line 973, in run_command
    cmd_obj.run()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/build_py.py&quot;, line 78, in run
    self.build_package_data()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/build_py.py&quot;, line 169, in build_package_data
    for target, srcfile in self._get_package_data_output_mapping():
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/build_py.py&quot;, line 161, in _get_package_data_output_mapping
    for package, src_dir, build_dir, filenames in self.data_files:
                                                  ^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/build_py.py&quot;, line 87, in __getattr__
    self.data_files = self._get_data_files()
                      ^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/build_py.py&quot;, line 93, in _get_data_files
    self.analyze_manifest()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/build_py.py&quot;, line 191, in analyze_manifest
    self.run_command('egg_info')
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/cmd.py&quot;, line 316, in run_command
    self.distribution.run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/dist.py&quot;, line 995, in run_command
    super().run_command(command)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/dist.py&quot;, line 973, in run_command
    cmd_obj.run()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/egg_info.py&quot;, line 313, in run
    self.find_sources()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/egg_info.py&quot;, line 321, in find_sources
    mm.run()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/egg_info.py&quot;, line 544, in run
    self.add_defaults()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/egg_info.py&quot;, line 582, in add_defaults
    sdist.add_defaults(self)
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/command/sdist.py&quot;, line 109, in add_defaults
    super().add_defaults()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/command/sdist.py&quot;, line 238, in add_defaults
    self._add_defaults_ext()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/command/sdist.py&quot;, line 322, in _add_defaults_ext
    build_ext = self.get_finalized_command('build_ext')
                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/cmd.py&quot;, line 303, in get_finalized_command
    cmd_obj.ensure_finalized()
  File &quot;/home/user/.cache/uv/builds-v0/.tmpkEGGLO/lib/python3.11/site-packages/setuptools/_distutils/cmd.py&quot;, line 111, in ensure_finalized
    self.finalize_options()
  File &quot;&lt;string&gt;&quot;, line 129, in finalize_options
  File &quot;&lt;string&gt;&quot;, line 30, in get_numpy_include
AttributeError: 'dict' object has no attribute '__NUMPY_SETUP__'. Did you mean: 'get_data_files'?
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-11-22 15:57</div>
            <div class="timeline-body"><p>@bart-maykin please open a new issue, this does not seem like the right place for that problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "conda environment management" to "Add support for managing Conda environments and packages" by @zanieb on 2024-11-26 23:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tobiasdiez">@tobiasdiez</a> on 2024-11-30 06:02</div>
            <div class="timeline-body"><p>The following is a concrete proposal how initial conda support may look like in <code>uv</code>:</p>
<ul>
<li><p>Add support for <a href="https://peps.python.org/pep-0725/">PEP 725 External dependencies</a>. This allows to specify non-python dependencies in <code>pyproject.toml</code>. For example, scipy may declare</p>
<pre><code class="language-toml">[external]
build-requires = [
  &quot;virtual:compiler/c&quot;,
  &quot;virtual:compiler/cpp&quot;,
  &quot;virtual:compiler/fortran&quot;,
  &quot;pkg:generic/ninja&quot;,
  &quot;pkg:generic/pkg-config&quot;,
]
host-requires = [
  &quot;virtual:interface/blas&quot;,
  &quot;virtual:interface/lapack&quot;,
]
</code></pre>
<p>&quot;Support&quot; here would mean at least that one could add external dependencies via <code>uv add</code> and that <code>uv</code> can read these information from <code>pyproject.toml</code>. This should actually be straight-forward and not too involved.</p>
<p>At this point, the <code>pyproject.toml</code> file contains all the information to create a conda environment, including python and non-python dependencies.</p>
</li>
<li><p>Render these information as a conda environment file. For this, the python dependencies and the external dependencies need to be translated into the correct conda packages. As @matterhorn103 mentioned above, grayskull maintains such a mapping that could be reused for this purpose. Then the user can use the generated conda environments files via mamba/conda.</p>
</li>
<li><p>Bonus: Streamline the process into one command. For example, <code>uv sync</code> in an activated conda environment should also update the non-python dependencies.</p>
</li>
<li><p>End goal: Use https://github.com/conda/rattler to directly and transparently solve the conda environment, bypassing the export step completely.</p>
</li>
</ul>
<p>In https://github.com/sagemath/sage/pull/37447, I've implemented this strategy in a custom python script (not using uv at all). It works quite well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/xinyu-dev">@xinyu-dev</a> on 2024-12-02 16:35</div>
            <div class="timeline-body"><p>I also support this. There are some biology packages that are only conda installable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hoaihuongbk">@hoaihuongbk</a> on 2024-12-11 04:04</div>
            <div class="timeline-body"><p>+1000 for this support. This simplifies the operational of managing the python dependencies on a large scale.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fepegar">@fepegar</a> on 2024-12-15 23:05</div>
            <div class="timeline-body"><blockquote>
<p>Is it possible to export a Conda environment YAML file? It already supports exporting a <code>requirements.txt</code> file, so adding support for exporting a Conda environment file shouldn't be difficult. As a temporary workaround, we can still export the environment file while using pip as the package manager.</p>
</blockquote>
<p>@shuowpro, I've written <a href="https://pypi.org/project/uv2conda/"><code>uv2conda</code></a> for that. You might find it useful.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tupui">@tupui</a> on 2024-12-16 18:35</div>
            <div class="timeline-body"><p>Adding my upvote here. We are adding some recommendations to uv in SciPy's doc but we also need to still recommend things like pixi until we have a solution for Conda.</p>
<p>@charliermarsh I believe support for non Python deps is around the corner?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-16 18:52</div>
            <div class="timeline-body"><p>@tupui Happy to review those SciPy changes, if you want to ping me.</p>
<p>I don't think support for non-Python dependencies is around the corner though :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/binbjz">@binbjz</a> on 2025-01-02 02:12</div>
            <div class="timeline-body"><p>I've been using pyenv to manage python versions and miniconda and anaconda versions. I really need support for anaconda and miniconda, this is so critical.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2025-01-02 10:17</div>
            <div class="timeline-body"><p>I think Astral are aware people would really like this feature, I don't think there's need for any more &quot;me too&quot; comments, add a thumbs up to the original post. Unless you have some novel use case not already described here.</p>
<p>Also, for those who really need conda packages and/or environments, and are not already aware, pixi provides project management, like uv, and does both conda and standard Python packages: https://github.com/prefix-dev/pixi</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2025-01-02 15:00</div>
            <div class="timeline-body"><p>Thought I'd just drop a link here to raise awareness of a <a href="https://github.com/conda/conda/pull/14067">PR</a> I have open over at the conda repo which would add support for creating a conda environment from a specification in a <code>pyproject.toml</code> file.</p>
<p>I like to think that it would be a good first step towards better PyPI-conda interop and would help a little in enabling projects like <code>uv</code> to achieve this feature in future.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tupui">@tupui</a> on 2025-01-02 16:59</div>
            <div class="timeline-body"><blockquote>
<p>Thought I'd just drop a link here to raise awareness of a <a href="https://github.com/conda/conda/pull/14067">PR</a> I have open over at the conda repo which would add support for creating a conda environment from a specification in a <code>pyproject.toml</code> file.</p>
<p>I like to think that it would be a good first step towards better PyPI-conda interop and would help a little in enabling projects like <code>uv</code> to achieve this feature in future.</p>
</blockquote>
<p>Yeah that might be the most sensible way forward tbh. I hate to have a specific file for the conda env while the whole ecosystem of tools transitioned from having their custom file to using the pyproject. Everything conda could very well be defined there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-01-23 06:49</div>
            <div class="timeline-body"><p>I'm the whom wants to manage virtual environment in cross-project manner, and <code>conda</code> is the best solution fits to this. And I want to use this feature along with <code>uv</code>'s powerful other features.
I would be very happy if <code>uv</code> supports feature to manage virtual environment in cross-project manner.</p>
<p>Installing/uninstalling, or managing <code>conda</code> package with <code>uv</code> is not a instant requirement for me.</p>
<p>Sidenotes:
<code>poetry</code> supports integration with <code>conda</code>, which installs package in <code>conda</code> virtual environment if non-base environment is activated. This feature is very helpful to me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MilkClouds">@MilkClouds</a> on 2025-01-23 06:54</div>
            <div class="timeline-body"><p>Even it's not a seems-good workaround, <code>pixi</code>'s virtual environment even can be registered as <code>conda</code> environment.
https://stackoverflow.com/questions/70851048/does-it-make-sense-to-use-conda-poetry</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2025-01-25 16:51</div>
            <div class="timeline-body"><p>It would be awesome if uv could install conda packages into venvs.</p>
<p>On Windows, and likely other platforms, Anaconda bundles hundreds of <code>*.conda</code> packages in the <code>anaconda3/pkgs</code> directory and stores the interpreter at <code>anaconda3/python.exe</code>.</p>
<p>uv makes environments way faster than conda, so if one could use a directory of conda packages as a package index for uv, it would enable powerful offline workflows.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2025-01-25 17:13</div>
            <div class="timeline-body"><p>Side noteâ€¦ <code>conda init</code> modifies the user PowerShell/pwsh profiles to activate the base environment on every new shell, which is <em>extremely</em> slow. uv is already on the PATH and knows where the interpreter is, so it can fix this completely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trungleduc">@trungleduc</a> on 2025-01-26 23:13</div>
            <div class="timeline-body"><p>why do people keep using <code>conda</code> while <code>mamba</code> or <code>pixi</code> can do the same job but is way faster?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2025-01-27 00:15</div>
            <div class="timeline-body"><blockquote>
<p>why do people keep using <code>conda</code> while <code>mamba</code> or <code>pixi</code> can do the same job but is way faster?</p>
</blockquote>
<p>This is off topic, but conda now defaults to the C++ mamba resolver engine. So the speed differences aren't as nearly big as they used to be.</p>
<p>That, and some users rely on the Anaconda distribution, for, convince, licensing (uv obviously can't solve that), or other enterprise service guarantees.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-01-27 01:06</div>
            <div class="timeline-body"><blockquote>
<p>why do people keep using <code>conda</code> while <code>mamba</code> or <code>pixi</code> can do the same job but is way faster?</p>
</blockquote>
<p>Let's try to keep the conversation on-topic -- this doesn't seem relevant to uv.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Yc-Chen">@Yc-Chen</a> on 2025-02-25 17:04</div>
            <div class="timeline-body"><p>I recently changed our conda/mamba based project to using uv and it works. I already like uv more because it resolves pytorch in a more considerate way: uv distinguishes mac vs. windows/linux whereas conda doesn't.</p>
<p>So I understand the wish, but what exactly? <code>pyproject.toml</code> is already more complete than <code>environment.yml</code>, so supporting <code>environment.yml</code> is not a good idea.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/trungleduc">@trungleduc</a> on 2025-02-25 17:33</div>
            <div class="timeline-body"><blockquote>
<p>So I understand the wish, but what exactly?</p>
</blockquote>
<p>Lots of packages are available on <code>conda-forge</code> but not <code>pypi</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2025-02-25 18:50</div>
            <div class="timeline-body"><blockquote>
<p>So I understand the wish, but what exactly? <code>pyproject.toml</code> is already more complete than <code>environment.yml</code>, so supporting <code>environment.yml</code> is not a good idea.</p>
</blockquote>
<p>It's about several things, but speaking primarily from a sciences perspective I can off the top of my head come up with:</p>
<ol>
<li><strong>Package availability.</strong> As mentioned by @trungleduc, the repositories simply contain different packages and particularly scientific ones often necessitate conda. This was historically about big ones like <code>numpy</code> and <code>pytorch</code>, these days it's more about small ones with a purely scientific audience â€“ tools, programs, and libraries created and released as part of academic research, for example. In computational chemistry nothing ever seems to get put on PyPI.</li>
<li><strong>Necessity for collaboration.</strong> Many research projects and groups of researchers use conda, many researchers have a strong preference for/investment in conda and are not going to be persuaded to switch, I imagine many places have an institute-wide policy or need for conda. At the moment collaborating in such environments is impossible with <code>uv</code>.</li>
<li><strong>Backwards compatibility.</strong> Scientific Python projects are often not updated long-term, especially if they were produced in an academic environment, or are research projects full of scripts. Many have their environment specified exclusively in an <code>environment.yml</code>. So to use or replicate that work you are obliged to use a tool that understands conda, and that need is unlikely to go away.</li>
<li><strong>Continued recommendation.</strong> Tutorials or package READMEs aimed at scientists will, in my experience, exclusively recommend the use of conda and installation from <code>conda-forge</code>, which means the above are not likely to change any time soon.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mfisher87">@mfisher87</a> on 2025-02-25 19:24</div>
            <div class="timeline-body"><p>To expand on point (1), some of those packages available on conda are general purpose shared libraries that can't be installed with pypi, for example libgdal which underpins most libraries that work with raster and vector geospatial data. You can only install the GDAL python bindings with PyPI. The alternative to using conda for this is using the system package manager or Nix. Ignoring the latter, the former will only offer one version out-of-the-box, and so you would need to manually constrain your python environment to be compatible with that likely-old version. This would create a dependency between the python environment and the user's operating system choice, making it difficult to collaborate with users across operating systems. For example Windows users might use OSGeo4W, and likely get a different version of the shared library than someone installing gdal with <code>apt</code> on Ubuntu 24.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fperez">@fperez</a> on 2025-02-25 19:24</div>
            <div class="timeline-body"><p>And to expand on #1 above by @matterhorn103 and @trungleduc - the key point is that many key scientific dependencies will <em>never</em> be on PyPI b/c they have zero Python in them, yet they are used as computational engines wrapped by a Python layer. VTK or ITK are classic examples of such packages, that were a royal, spectacular pain to install prior to conda-forge offering them, but there's a lot more like it.</p>
<p>All of the other points @matterhorn103 makes above are also critical, and #3 is a big one. We've made big strides in convincing the scientific community to share their code and make it reproducible, but for now that's anchored in offering reasonable <code>environment.yml</code> files. For most scientists that's already a big ask and <em>it works</em>.  Supporting that community and thousands of legacy uses (often tied to published research) is extremely important, IMHO.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fperez">@fperez</a> on 2025-02-25 19:25</div>
            <div class="timeline-body"><p>Oops, basically repeated what @mfisher87 said ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mfisher87">@mfisher87</a> on 2025-02-25 19:26</div>
            <div class="timeline-body"><p>I saw your post come through literally the same second I submitted mine ðŸ˜†</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Yc-Chen">@Yc-Chen</a> on 2025-02-25 20:11</div>
            <div class="timeline-body"><p>Thanks to @fperez @mfisher87 @trungleduc for the explanation!</p>
<p>Just add one point for uv - and also one of the reasons I did the switch - is because the latest version of pytorch <a href="https://pytorch.org/get-started/locally/#start-locally">stopped official conda support</a> (and also image below). And I was very happy to see uv has already <a href="https://docs.astral.sh/uv/guides/integration/pytorch/">documented</a> how to install pytorch. I wonder how this will change point (2) and (4) in the future.</p>
<p><img width="809" alt="Image" src="https://github.com/user-attachments/assets/eeca49d0-a39b-4a4e-9a13-d5377ae14418" /></p>
<p>For point (1) that many packages do not exist on pypi, that's a broader problem than a package manager. It is also about a place to publish and host packages, and a <code>.conda</code> format instead of whl format. Since uv works with <code>pyproject.toml</code>, I searched a bit whether conda can be more compatible with <code>pyproject.toml</code>. And I found this <code>conda-lock</code> most relevant. Maybe that could be an idea to make a step towards:</p>
<p>https://conda.github.io/conda-lock/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tupui">@tupui</a> on 2025-02-25 20:47</div>
            <div class="timeline-body"><p>There is a proposal of a PEP to be able to express system and other dependencies in pyproject.toml. Until that happens, conda can still decide to have a specific section in the pyproject.toml to define these extra bits. It's yaml to toml ðŸ¤· there is no reason to not do that now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mfisher87">@mfisher87</a> on 2025-02-25 23:56</div>
            <div class="timeline-body"><p>https://peps.python.org/pep-0725/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Yc-Chen">@Yc-Chen</a> on 2025-02-26 08:10</div>
            <div class="timeline-body"><p>https://github.com/conda/conda/issues/12462
It has been there for &gt;1 year....</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tupui">@tupui</a> on 2025-02-26 15:49</div>
            <div class="timeline-body"><blockquote>
<p>https://github.com/conda/conda/issues/12462
It has been there for &gt;1 year....</p>
</blockquote>
<p>Yes. Still something they have to do. They are the one not in-line with the rest of the ecosystem ðŸ˜‰</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mfisher87">@mfisher87</a> on 2025-03-17 15:46</div>
            <div class="timeline-body"><p>I had a discussion about this at some point with someone very familiar with the ecosystem (I think a conda forge developer?) and they raised that <code>pyproject.toml</code> is Python-specific, and <code>conda</code> is not. Supporting <code>pyproject.toml</code> would mean they would have to treat it as an optional format and continue support for the non-python-specific format.</p>
<p>Pixi has decided that for them, supporting two formats is worth it. I'm glad they did :) But <code>pixi</code> is at a different level of abstraction (project management) than conda (environment management), so that likely made this decision easier. I don't know if <code>conda</code> developers necessarily see this as something they &quot;have to do&quot;, and I would agree with that. Right now, <code>pixi</code> is leading the charge on bringing excellent ergonomics to this space, and I'm so excited about that :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DOSull">@DOSull</a> on 2025-04-17 11:28</div>
            <div class="timeline-body"><p>Definitely would like to see this - both support for the not-pure-python packages of conda (which sounds hard), but more straightforwardly (I would think) the option to put virtual environments in some central location, like <code>/opt/uv/lib/...</code> or <code>~/.uv/envs</code> or somesuch with an associated ability to run <code>uv activate &lt;environment-name&gt;</code> from anywhere.</p>
<p>Sometimes I want to quickly try out an idea and I know that the package I need exists in some environment. In <code>conda</code> I just drop into the command line and no matter where I am in the file system <code>conda activate &lt;environment-name&gt;</code> let's me fire up python and explore. With <code>uv</code> as currently configured I have to also remember where that environment is on the file system. That's not a huge burden, but an option to have a centralised location for environments doesn't seem like a big ask.</p>
<p>Similarly a centralised location gives an IDE like vscode or whatever the ability to offer all the virtual environments installed on a machine as options if your exploring some ideas in a notebook say, not working on a particular project.</p>
<p>Finally, I know we all have giant hard drives now, but seriously... virtual environments take up a lot of space and scattering them all over every project folder when many projects will have common requirements seems like a bit of a waste of storage space!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-21 03:00</div>
            <div class="timeline-body"><blockquote>
<p>the option to put virtual environments in some central location</p>
</blockquote>
<p>You're looking for #1495</p>
<blockquote>
<p>Sometimes I want to quickly try out an idea and I know that the package I need exists in some environment. In conda I just drop into the command line and no matter where I am in the file system</p>
</blockquote>
<p>The non-environment centric way to do this is just (for example) <code>uvx --with requests,httpx python</code> â€” no need to remember the name or path of an environment.</p>
<blockquote>
<p>virtual environments take up a lot of space and scattering them all over every project folder when many projects will have common requirements seems like a bit of a waste of storage space!</p>
</blockquote>
<p>To avoid confusion here: we use hard-links and copy-on-write with a shared cache for packages, each virtual environment does not consume additional space.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DOSull">@DOSull</a> on 2025-04-21 23:46</div>
            <div class="timeline-body"><blockquote>
<p>The non-environment centric way to do this is just (for example) uvx --with requests,httpx python â€” no need to remember the name or path of an environment.</p>
</blockquote>
<p>This is really useful to know. I think I'd still like the option for some more permanent configurations accessible from a central location, but this is really nice for one of my use-cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-04-21 23:50</div>
            <div class="timeline-body"><p>@DOSull in that case, I'd recommend just creating a project in your central location then doing <code>uv run --project ~/my-central-thing python</code> (or <code>uvx --with ~/my-central-thing python</code>). Anyway, we'll add support for centralized environments eventually â€” it's just a matter of finding the time to design and implement it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ubaldot">@ubaldot</a> on 2025-05-06 17:47</div>
            <div class="timeline-body"><p>FWIW: conda is an agnostic package manager (you can e.g. install gcc, pandoc, etc.) not only for python packages. And you can install them in separate environments. Plus it really checks dependencies conflicts. Plus it aggressively check SSL stuff. I like to think it as a &quot;light docker&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2025-07-23 14:26</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/zanieb">@zanieb</a> related to your response in <a href="https://github.com/astral-sh/uv/issues/6989#issuecomment-2328978747">#6989</a>:</p>
<blockquote>
<p>I think it's okay to support if it works, but I'm not sure how well it will translate since Conda has, for example, different names for some packages. We can't actually perform a resolution with Conda.</p>
</blockquote>
<p>It has felt to me for a while that the unknown correspondence between PyPI and Conda packages is the biggest thing keeping the ecosystems separate. When looking into the topic many months ago I came across Grayskull, <a href="https://github.com/conda/grayskull/issues/168">this thread discussing the exact problem</a>, and <a href="https://github.com/regro/cf-graph-countyfair/blob/master/mappings/pypi/grayskull_pypi_mapping.yaml">this bot-generated mapping effort</a>. By no means exhaustive, but I imagine some mapping like that would be a necessary starting point for Conda/PyPI interop, so figured I'd leave the links here.</p>
</blockquote>
<p><a href="https://github.com/conda/grayskull/issues/564">This thread</a> on the grayskull repo is interesting with regards to this aspect of things.</p>
<p>Somehow I missed at the time of that comment that the Pixi team have been maintaining their own PyPI =&gt; <code>conda-forge</code> mapping using their <a href="https://github.com/prefix-dev/parselmouth"><code>parselmouth</code></a> tool. At the moment it seems to be only in that direction, with <a href="https://github.com/prefix-dev/parselmouth/pull/33">work on the inverse</a> in progress but apparently stalled. It seems that <a href="https://github.com/conda/grayskull/issues/564#issuecomment-2436849218">they'd like <code>parselmouth</code> to have it</a>, though, and for it to be a library/reference useable by the whole ecosystem.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:34:56 UTC
    </footer>
</body>
</html>
