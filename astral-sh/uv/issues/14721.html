<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Check if `python -m uv run python` REPL works with Ctrl-C on Windows - astral-sh/uv #14721</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Check if `python -m uv run python` REPL works with Ctrl-C on Windows</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/14721">#14721</a>
        opened by <a href="https://github.com/zanieb">@zanieb</a>
        on 2025-07-18 13:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-18 13:09</div>
            <div class="timeline-body"><p>If you run <code>python -m uv run python</code> to get a REPL on Windows. What happens when you use Ctrl-C?</p>
<p><em>Originally posted by @geofft in https://github.com/astral-sh/uv/issues/14715#issuecomment-3089308034</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">good first issue</span> added by @zanieb on 2025-07-18 13:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">windows</span> added by @zanieb on 2025-07-18 13:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kfsone">@kfsone</a> on 2025-07-20 03:00</div>
            <div class="timeline-body"><p>TLDR:</p>
<ul>
<li>Forward the stdio handles and the console to the child process,</li>
<li>But create the ChildProcess suspended,</li>
<li>If CreateProcess() fails, you still own the handles,</li>
<li>If CreateProcess() succeeded, you no-longer own the handles, release them and ResumeThread() the child.</li>
</ul>
<p>I recently ran into Window's variation of ctrl-c handling. Out of the box a process group is wired to send ctrl-c to the entire group in tree-descent order; the parent will get the ctrl-c first. If you're trying to emulate POSIX exec() this is a wee bit inconvenient.</p>
<p>Certainly, <code>uv run python</code> followed by a ctrl-c will result in:</p>
<p><img width="198" height="144" alt="Image" src="https://github.com/user-attachments/assets/d73fa433-bd04-43c3-9bbc-7dadcaaf1e06" /></p>
<p>and now the shell and the python instance are sharing some kind of handle so:</p>
<p><img width="247" height="329" alt="Image" src="https://github.com/user-attachments/assets/a747ce01-dcbd-4b5f-a3b2-c33ca369061b" /></p>
<p>I was dealing with this in C++ and the <a href="https://stackoverflow.com/questions/79696425/posix-exec-like-transfer-of-console-handles-to-createprocess-child">MS documentation was leading me in circles</a>.</p>
<ul>
<li>A signal handler that ignores Ctrl-Cs but still forwards breaks (so you can't get stuck),</li>
</ul>
<pre><code>// -----------------------------------------------------------------------------
//! Control C handler if we want to be authoritative rather than the child.
//
BOOL WINAPI consoleCtrlHandler(DWORD ctrlType)
{
	// If it's not an event we care about, or if the handler is not installed,
	// let the system handle it the normal way.
	if (ctrlType == CTRL_C_EVENT)
	{
		// Let Ctrl-C pass thru.
		return (TRUE);
	}
	if (ctrlType == CTRL_BREAK_EVENT)
		terminateProcess();  // &lt;- my code is using a singleton, because `exec`.

	return (FALSE);
}
</code></pre>
<p>For the process launch itself, I'm doing these things:</p>
<pre><code>	HANDLE hStdIn = GetStdHandle(STD_INPUT_HANDLE);
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	HANDLE hStdErr = GetStdHandle(STD_ERROR_HANDLE);

	// Setup process creation, explicitly forward the handles.
	STARTUPINFO si = {};
	si.cb = sizeof(si);
	si.dwFlags = STARTF_USESTDHANDLES;
	si.hStdInput = hStdIn;
	si.hStdOutput = hStdOut;
	si.hStdError = hStdErr;

	// Ensure our io activities are finished
	_flushall();

	// Create the child process in a new process group
	BOOL success = CreateProcess(
		nullptr,                    // No module name (use command line)
		const_cast&lt;char*&gt;(cmdline.c_str()),			// Command line
		nullptr,                    // Process handle not inheritable
		nullptr,                    // Thread handle not inheritable
		TRUE,                       // Set handle inheritance to TRUE
  // vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
		0 | CREATE_SUSPENDED, 		// Creation flags - normal priority
  // ^^^^^^^^^^^^^^^^^^^^^^
		nullptr,                    // Use parent's environment block
		nullptr,                    // Use parent's starting directory
		&amp;si,                        // Pointer to STARTUPINFO structure
		gProcessInfo               	// Pointer to PROCESS_INFORMATION structure
	);
</code></pre>
<p>At this point, you still have access to the <code>Console</code> and stdio descriptors, so if <code>CreateProcess</code> fails you can back out/log to the user.</p>
<p>On the other hand, if <code>CreateProcess</code> suceeded, the child process is in a suspended state, allowing you to free those handles AND the console before retiring.</p>
<pre><code>
	DWORD exitCode = 0;
	if (!success)
	{
		DWORD errorCode = GetLastError();
		char* errorMessage = nullptr;
		FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
		                 nullptr, errorCode, 0, (LPSTR)&amp;errorMessage, 0, nullptr);
		error = &quot;Failed to create process: &quot; + Base::String(errorMessage);
		LocalFree(errorMessage);
		return static_cast&lt;int&gt;(exitCode);
	}

	// Let the child determine what to do with Ctrl-C; not our responsibility any more.
	SetConsoleCtrlHandler(consoleCtrlHandler, TRUE);

	// Surrender all of the handles to prevent mux/switching of receipients
	// which can manifest as weird behavior when hitting control keys, e.g
	CloseHandle(hStdIn);
	CloseHandle(hStdOut);
	CloseHandle(hStdErr);
	// Release the layer that does input translations too
	FreeConsole();

	// Now if the thread accesses the console or stdio handles, they will appear to
	// belong to it and it be as interactive/streamed as we are.
	ResumeThread(gProcessInfo-&gt;hThread);
	CloseHandle(gProcessInfo-&gt;hThread);  // Avoid resource leak.

	// And now we just need to wait to exit.
	WaitForSingleObject(gProcessInfo-&gt;hProcess, INFINITE);
	GetExitCodeProcess(gProcessInfo-&gt;hProcess, &amp;exitCode);
	CloseHandle(gProcessInfo-&gt;hProcess);
	::exit(exitCode);
</code></pre>
<p>I'm using this for an in-house shim for wrapping uv to maintain workspace/branch-specific venvs but then launch the venv python directly because using uv doesn't otherwise do this:</p>
<p><img width="393" height="253" alt="Image" src="https://github.com/user-attachments/assets/2efcabc1-f044-409d-bcf3-8321ea4b97a0" /></p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:33:09 UTC
    </footer>
</body>
</html>
