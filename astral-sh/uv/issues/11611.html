<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support --compile-bytecode for only the installed packages - astral-sh/uv #11611</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support --compile-bytecode for only the installed packages</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/11611">#11611</a>
        opened by <a href="https://github.com/shixuan-fan">@shixuan-fan</a>
        on 2025-02-19 01:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-19 01:30</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Today when we do <code>--compiled-bytecode</code>, the entire <code>site-packages</code> folder is compiled. This is not always desirable because we have our own managed download/install pipeline and each worker handles its own install and potentially uninstalls. During our migration to uv, we found out that when uninstall happens, the other installs with --compile will fail because a path in site-packages no longer exists during the installation:</p>
<pre><code>Installed 1 package in 0.46ms
DEBUG Starting 16 bytecode compilation workers
DEBUG Released lock at `/tmp/uv-f641cf93176e3e54.lock`
error: Failed to bytecode-compile Python file in: /usr/lib/python3.11/site-packages
  Caused by: Failed to list files in `site-packages`
  Caused by: IO error for operation on /usr/lib/python3.11/site-packages/importlib_metadata-8.5.0.dist-info: No such file or directory (os error 2)
  Caused by: No such file or directory (os error 2)
</code></pre>
<p>This behavior is different from pip so an option to only compile the installed packages, which is pip-compatible, would be very helpful for our drop-in replacement! :)</p>
<h3>Example</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @shixuan-fan on 2025-02-19 01:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-19 03:39</div>
            <div class="timeline-body"><p>cc @konstin</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> removed by @konstin on 2025-02-19 08:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-mre</span> added by @konstin on 2025-02-19 08:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-19 08:48</div>
            <div class="timeline-body"><p>I haven't seen this error before, can you share commands that reproduce this problem?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-02-19 12:18</div>
            <div class="timeline-body"><p>It sounds like the issue is that they have multiple workers operating on the environment concurrently. Each worker tries to compile the entire site-packages, including packages that might be uninstalled by another worker. The ask is to only compile bytecode for relevant packages. We could also just make this robust to concurrent manipulation and treat this as non-fatal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-19 12:38</div>
            <div class="timeline-body"><p>Are those download/install commands separate from uv? We should still be holding an environment lock when bytecode compiling that prevents parallel modification.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-19 16:42</div>
            <div class="timeline-body"><p>Our use case is special because for security reasons we have to run these uv commands from a sandbox (e.g. NsJail). Each sandbox has a tmpfs mounted to their <code>/tmp</code> location. This means these uv commands cannot see each other's lock because the <code>/tmp</code> location is not shared.</p>
<p>Even if the uv commands share the <code>/tmp</code> and lock works, this does not seem efficient because ideally if these commands are installing different packages with <code>--compile-bytecode</code> flag, they should not block each other. This can be achieved by only compiling for the installed package, similar to what pip does.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-19 18:20</div>
            <div class="timeline-body"><p>Yet another reason we should be co-locating those locks, cc @charliermarsh</p>
<blockquote>
<p>this does not seem efficient because ideally if these commands are installing different packages with --compile-bytecode flag, they should not block each other</p>
</blockquote>
<p>It's not safe to install into an environment concurrently. Even if the packages are different, there can be transitive overlap. And even if there's not transitive overlap, Python packages can install into arbitrary conflicting paths in your environment.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-02-19 18:34</div>
            <div class="timeline-body"><p>Yeah, we could consider colocating the lock in the system environment. That seems reasonable (if we have write access).</p>
<p>I think it would also be fine to make these robust to deletion...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-19 18:44</div>
            <div class="timeline-body"><p>Out pipeline looks like:</p>
<pre><code>Solve (pip dry run) -&gt; a list of wheels -&gt; pipeline for wheel 1 -&gt; download -&gt; install
                                        -&gt; pipeline for wheel 2...
</code></pre>
<p>The transitive overlap is unlikely for us. We are using <code>--no-deps</code> to install each package separately, because the environment that uv runs also don't have network access so we are feeding it wheel files. The package to install is determined by a solve process which today we are still using pip because uv does not have <code>--report</code> equivalent yet.</p>
<p>The arbitrary conflicting paths is interesting, and IIRC there are some crypto libs that have this issue. I don't think there is a safe way to install it regardless how we do the install because to my best understanding it is always last-writer-win. I don't think it is the installer's responsibility to handle this not-working scenarios.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-19 18:51</div>
            <div class="timeline-body"><p>Interesting. Why not just compile bytecode at the end?</p>
<blockquote>
<p>I don't think there is a safe way to install it regardless how we do the install because to my best understanding it is always last-writer-win. I don't think it is the installer's responsibility to handle this not-working scenarios.</p>
</blockquote>
<p>It's the difference between two partially installed packages (with arbitrarily mixed overrides) and one fully installed package with another partially overridden. Unfortunately, this is something we need to consider as some packages do this intentionally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-19 19:04</div>
            <div class="timeline-body"><blockquote>
<p>Why not just compile bytecode at the end?</p>
</blockquote>
<p>Great minds think alike :-) That's what we are now considering. The pipeline install does the no-compile install, and have a final &quot;compiler&quot;.</p>
<p>Is there a uv command that compiles the entire site-packages for a given python env via <code>--python</code>? What I was considering is to do a <code>uv pip install --compile</code> on any one package that triggers the compile all. This does not seem very clean to me so trying to see if uv experts have some other suggestions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-19 19:04</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/uv/pull/11633 isn't what you asked for, but seems like it would unblock you.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-19 19:05</div>
            <div class="timeline-body"><p>We don't have a command for it no, it does seem fairly reasonable (and easy) to expose as a &quot;plumbing command&quot; though.</p>
<p>We already have a copy of it in-tree https://github.com/astral-sh/uv/blob/41cd4bee5861cdda4d826c29cd413b97638186cb/crates/uv-dev/src/compile.rs</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-19 19:06</div>
            <div class="timeline-body"><blockquote>
<p>https://github.com/astral-sh/uv/pull/11633 isn't what you asked for, but seems like it would unblock you.</p>
</blockquote>
<p>Thanks. Let me cherry-pick and test :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-20 06:06</div>
            <div class="timeline-body"><p>Unfortunately I don't think the patch helps :( I'm not a rust expert, but looks like we are doing the file existence check at the entrance of the producer, but the file can be deleted afterwards. I wonder if we need to do the following:</p>
<ul>
<li>In producer, we also allow <code>if entry.metadata()?.is_file() &amp;&amp; entry.path().extension().is_some_and(|ext| ext == &quot;py&quot;)</code> to fail with OS error. Maybe we already handle it and it's just my lack of understanding in rust.</li>
<li>Should we do the same on the consumer side? It's possible that when consumer reads the file, they no longer exists. Maybe somewhere in https://github.com/astral-sh/uv/blob/a08c2ead6d58001cccccd4a40f96b43501b985f8/crates/uv-installer/src/compile.rs#L339.</li>
</ul>
<p>I'll try to see if I could get a portable repro from linux, but it might be hard given the environment we use.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-mre</span> removed by @konstin on 2025-02-20 08:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-20 08:54</div>
            <div class="timeline-body"><blockquote>
<p>Is there a uv command that compiles the entire site-packages for a given python env via <code>--python</code>? What I was considering is to do a <code>uv pip install --compile</code> on any one package that triggers the compile all. This does not seem very clean to me so trying to see if uv experts have some other suggestions.</p>
</blockquote>
<p>Usually, the uv steps happen sequentially, and you'd add <code>--compiled-bytecode</code> to the last command, so that everything is compiled on (container) startup.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-20 14:21</div>
            <div class="timeline-body"><p>Hm I was going off this error &quot;Caused by: Failed to list files in <code>site-packages</code>&quot;</p>
<p>Was there another error?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-20 14:29</div>
            <div class="timeline-body"><p>I think you're right the <code>metadata()</code> call could fail too, though it's an even-tighter race condition. I added handling for that in https://github.com/astral-sh/uv/pull/11633/commits/860c9a2e5261887560a31a4ca8e71d43e2916070</p>
<p>I'm not sure what happens if the worker fails to compile a file. It seems like it'd ignore it</p>
<p>https://github.com/astral-sh/uv/blob/a6602ad416a922060efb3c5f19daf4977c50ace3/crates/uv-installer/src/pip_compileall.py#L61-L65</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-20 14:38</div>
            <div class="timeline-body"><p>Yeah, mirroring pip we try to compile all <code>.py</code> files while ignoring all compilation errors, the error sources should only be in the rust source where we read directories and entry metadata.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-20 19:04</div>
            <div class="timeline-body"><p>The second patch works for us (or at least works when I tested for ~10 times locally lol). Will do more CI/CD and proper testing. Thanks a lot for the quick workaround!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-20 19:27</div>
            <div class="timeline-body"><p>Thanks for giving it a test!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-02-21 21:11</div>
            <div class="timeline-body"><p>Not urgent, but do you happen to know when could we expect 0.6.3? If it is soon enough then we don't have to create our own patched version :) Based on the release cadence I observe in this repo it seems pretty frequent.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-02-21 22:24</div>
            <div class="timeline-body"><p>I’d expect we’ll release no later than Monday.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-03-14 00:40</div>
            <div class="timeline-body"><p>@shixuan-fan -- Do you think we can close this one out?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shixuan-fan">@shixuan-fan</a> on 2025-03-14 06:47</div>
            <div class="timeline-body"><p>Yes. Closing. Thanks a lot for the quick turnaround!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @shixuan-fan on 2025-03-14 06:47</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:44:19 UTC
    </footer>
</body>
</html>
