<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uv init: Project layouts, defaults and terminology - astral-sh/uv #8178</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>uv init: Project layouts, defaults and terminology</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/8178">#8178</a>
        opened by <a href="https://github.com/MikeHart85">@MikeHart85</a>
        on 2024-10-14 17:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/MikeHart85">@MikeHart85</a></div>
            <div class="timeline-body"><p>Thank you for working on this wonderful tool.</p>
<p>I&#x27;d like to suggest several changes to <code>uv init</code> arguments and defaults, with the following goals:</p>
<ul>
<li>Use consistent and established terminology</li>
<li>Options to support common usage patterns, so seasoned Python developers can have things their way</li>
<li>Defaults which guide Python newcomers towards best practices, hint at available features</li>
</ul>
<p>Much of this revolves around separating the concept of project directory structure (&quot;layout&quot; in Python) from project purpose and contents (&quot;library&quot;, &quot;application&quot;, etc), as well as disambiguating the overloaded term &quot;package&quot;. Currently these terms are conflated and inconsistent in <code>uv</code>.</p>
<p>Apologies in advance for the massive wall of text.</p>
Current behavior
<p>&quot;Application&quot; (default):</p>
<pre><code>$ uv init [--app] project-name
$ tree project-name/
project-name/
‚îú‚îÄ‚îÄ hello.py
‚îú‚îÄ‚îÄ pyproject.toml  # only [project] (builds don&#x27;t work due to misnamed hello.py)
‚îî‚îÄ‚îÄ README.md
</code></pre>
<p>&quot;Library&quot;:</p>
<pre><code>$ uv init --lib project-name
project-name/
‚îú‚îÄ‚îÄ pyproject.toml  # [project], [build-system]
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ project_name
        ‚îú‚îÄ‚îÄ __init__.py  # contains &quot;hello&quot; code
        ‚îî‚îÄ‚îÄ py.typed
</code></pre>
<p>&quot;Application Package&quot;:</p>
<pre><code>$ uv init [--app] --package project-name  # --app appears to do nothing here, in spite of docs suggesting it
project-name/
‚îú‚îÄ‚îÄ pyproject.toml  # [project], [project.scripts], [build-system]
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ project_name
        ‚îî‚îÄ‚îÄ __init__.py  # contains &quot;hello&quot; code
</code></pre>
Suggested behavior
<p>Src layout (default):</p>
<pre><code>$ uv init [--layout=src] project-name
project-name/
‚îú‚îÄ‚îÄ pyproject.toml  # [project], [project.scripts], [build-system]
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ src
    ‚îî‚îÄ‚îÄ project_name
        ‚îî‚îÄ‚îÄ __init__.py  # empty
        ‚îî‚îÄ‚îÄ example.py   # def say_hello(): print(&quot;...&quot;)
</code></pre>
<p>Flat layout:</p>
<pre><code>$ uv init --layout=flat project-name
project-name/
‚îú‚îÄ‚îÄ pyproject.toml  # [project], [project.scripts], [build-system]
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ project_name
    ‚îî‚îÄ‚îÄ __init__.py  # empty
    ‚îî‚îÄ‚îÄ example.py   # def say_hello(): print(&quot;...&quot;)
</code></pre>
<p>Single module layout:</p>
<pre><code>$ uv init --layout=single project-name
project-name/
‚îú‚îÄ‚îÄ pyproject.toml  # [project], [project.scripts], [build-system]
‚îú‚îÄ‚îÄ README.md
‚îî‚îÄ‚îÄ project_name.py  # def say_hello(): print(&quot;...&quot;) 
                     # NOTE: file name MUST be project_name.py (it replaces the package)
</code></pre>
<p>Bare / no layout:</p>
<pre><code>$ uv init --layout=&lt;bare|none&gt; project-name  # maybe pick one rather than allowing either one
project-name/
‚îú‚îÄ‚îÄ pyproject.toml  # [project]
‚îî‚îÄ‚îÄ README.md
</code></pre>
<ul>
<li>Add <code>--no-entrypoint</code> to suppress <code>[project.scripts]</code><ul>
<li>Consider adding <code>--entrypoint=name</code> to customize key name under <code>[project.scripts]</code>, defaulting to <code>project-name</code></li>
</ul>
</li>
<li>Add <code>--build-system=&lt;hatchling|...|none&gt;</code>, with <code>hatchling</code> being default, and <code>none</code> to suppress <code>[build-system]</code><ul>
<li>Consider adding <code>--no-build-system</code>, synonymous with <code>--build-system=none</code>, for symmetry</li>
<li>Remove <code>--no-package</code></li>
</ul>
</li>
<li>Add <code>--typed</code> to create a <code>py.typed</code></li>
<li>Remove <code>--package</code></li>
<li>Remove <code>--app</code>, or:<ul>
<li>Make synonymous with <code>--entrypoint=project-name</code></li>
<li>Consider generating example code to be more &quot;app-like&quot;</li>
<li>Consider <code>__main__.py</code> <a href="https://docs.python.org/3/library/__main__.html#main-py-in-python-packages">[1]</a> instead of <code>example.py</code>, but that may unnecessarily confuse newcomers</li>
</ul>
</li>
<li>Remove <code>--lib</code>, or:<ul>
<li>Make synonymous with <code>--no-entrypoint</code></li>
<li>Consider generating example code to be more &quot;lib-like&quot;</li>
<li>Consider implying <code>--typed</code> (IMO explicit <code>uv init --lib --typed</code> would be better)</li>
</ul>
</li>
</ul>
<p>I would just remove <code>--lib</code> and <code>--app</code> to keep things simple.</p>
Reasoning for suggestions
<ul>
<li>&quot;Entry point&quot; is the established term for shortcuts to functions that ultimately become commands when installed <a href="https://packaging.python.org/en/latest/specifications/entry-points/">[2]</a></li>
<li>&quot;Layout&quot; is the established term for project directory structure <a href="https://setuptools.pypa.io/en/latest/userguide/package_discovery.html#src-layout">[3]</a>, <a href="https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/">[4]</a><ul>
<li>Src layout should be default<ul>
<li>It is the most robust, avoids import conflicts, most suitable for serious projects</li>
<li>Prevents needing to restructure when project outgrows other layouts</li>
<li>Uv eliminates its main downside (very easy to get up-to-date REPL):</li>
<li><code>uv run python</code></li>
<li><code>&gt;&gt;&gt; import project_name</code></li>
</ul>
</li>
<li>Flat layout is also quite popular, and currently not available in <code>uv init</code></li>
<li>Single module (current <code>--app</code>, default) layout is the most limited<ul>
<li>It should most certainly not be the default</li>
<li>Has issues and limitations which will confuse newcomers</li>
<li>Should really only be used for single file projects, if at all</li>
<li>Currently broken for builds due to example file always being <code>hello.py</code></li>
<li>Changing file to <code>project_name.py</code> allows builds to work</li>
</ul>
</li>
<li><code>--layout=none</code> for custom layouts, notebook projects, etc</li>
</ul>
</li>
<li>Project layout is not related to whether it is an &quot;app&quot; or &quot;lib&quot;<ul>
<li>Any layout can be an application or a library</li>
<li>Project contents and usage determine whether it is an application, or library, or both</li>
<li>Not as clear cut in Python as &quot;executable&quot; vs &quot;library&quot; projects in compiled languages, shouldn&#x27;t attempt to force that pattern since it doesn&#x27;t fit</li>
<li>&quot;App&quot; and &quot;Application&quot; terms should probably be reserved for possible integration with tools like PyInstaller, cxfreeze, etc (IE, generating a self-contained binary executable for distribution)</li>
<li>A library isn&#x27;t required to have <a href="https://peps.python.org/pep-0561/">PEP 561</a> compliant <code>py.typed</code></li>
</ul>
</li>
<li>Current use of <code>--package</code> conflates it with build-system/distribution, src layout, and absence of <code>py.typed</code><ul>
<li>A &quot;package&quot; in Python is simply a directory with an <code>__init__.py</code> <a href="https://docs.python.org/3/glossary.html#term-regular-package">[5]</a></li>
<li>Ideally, the term &quot;package&quot; should not be used for anything else, to avoid confusion</li>
<li>A package doesn&#x27;t have to be distributable / have a build-system</li>
<li>Single module (IE, non-package) distributions are a thing (hence <code>--layout=single</code> with build-system)<ul>
<li>A prominent example would be <code>six</code>, which is a single module library: <a href="https://pypi.org/project/six/">PyPI</a> <a href="https://github.com/benjaminp/six">GitHub</a></li>
</ul>
</li>
</ul>
</li>
<li><code>__init__.py</code> should not contain general purpose code<ul>
<li><code>__init__.py</code> is a special purpose file, and putting arbitrary code there can easily have unintended side effects</li>
<li>Its meant for initializing packages, making symbols available at package level, <code>__all__</code>, etc <a href="https://docs.python.org/3/tutorial/modules.html#packages">[6]</a></li>
<li>Putting the hello world example there can mislead newcomers into thinking this is where all their code belongs</li>
</ul>
</li>
<li>Don&#x27;t see a reason not to include entry point and build system by default in all layouts which support it<ul>
<li>Can easily be removed / ignored / switched off if not needed</li>
<li>Default presence shows newcomers what is possible / where it belongs</li>
<li>Reduces friction when a project graduates from hobby to distribution</li>
</ul>
</li>
<li>Layouts are mutually exclusive, hence grouping them under one argument with a value<ul>
<li>Less room for confusion than having multiple differently named options, which may or may not be mixable</li>
</ul>
</li>
<li>All three layouts (src, flat, single) work with <code>uv run project-name</code> and <code>uv build</code> as shown<ul>
<li>Only <code>uv init</code> needs to change, to support generating them</li>
</ul>
</li>
</ul>
Context
<ul>
<li>Src layout used to be the default until: <a href="https://github.com/astral-sh/uv/pull/6689">astral-sh/uv#6689</a></li>
<li>&quot;App&quot;, &quot;lib&quot; and &quot;package&quot; terminology introduced around here: <a href="https://github.com/astral-sh/uv/pull/6585">astral-sh/uv#6585</a></li>
</ul>
<p>Discussion in the latter floated using &quot;distribution&quot; (ala PDM) instead of &quot;package&quot; (ala Poetry) in some contexts, but it seems &quot;package&quot; won out. I would argue &quot;distribution&quot; would have been the correct choice. As mentioned, &quot;package&quot; has a very specific meaning in Python, not strictly related to whether the project is built for distribution.</p>
<p>Thanks for considering.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Weilet">@Weilet</a> on 2024-10-24 15:10</div>
            <div class="timeline-body"><p>I think <code>uv init --layout=&lt;bare|none&gt;</code> is very useful for me when it comes to creating a Django app. I am searching for a way to initialize the project with only a <code>pyproject.toml</code>, so that I can use <code>django-admin</code> to manage my project without too much unnecessary stuff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/zanieb">@zanieb</a> by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-24 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-24 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-24 15:40</div>
            <div class="timeline-body"><p>Thanks for your thoughts! I&#x27;ll own responding to this and seeing what we can integrate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drcongo">@drcongo</a> on 2024-11-02 20:12</div>
            <div class="timeline-body"><p>I&#x27;ve only ended up in this thread because I was confused about the default behaviour here - to me it feels like <code>uv init</code> with no options should do the equivalent of <code>uv init --layout=&lt;bare|none&gt;</code> mentioned above and create nothing but a <code>pyproject.toml</code>. I can&#x27;t imagine ever needing uv to create the <code>.gitignore</code>, <code>.git/</code> and <code>hello.py</code> so for that to be the default seems kinda wild.</p>
<p>Feel free to ignore me though, I realise I&#x27;m a data point of one and maybe those do somehow make sense to other devs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/thcrt">@thcrt</a> on 2024-11-06 13:25</div>
            <div class="timeline-body"><p>I think both the options available and their documentation are somewhat confusing at present. There are multiple different decisions in determining how a project should be structured, but those decisions seem to be split between <code>uv init</code>&#x27;s sub-optimal presets and further configuration options in <code>pyproject.toml</code> that need to be set manually.</p>
<p>Often, I might want to create a standalone application, such as a Flask webapp. This doesn&#x27;t need to expose a Python API or be imported into other projects, so I would assume I don&#x27;t need a build system to turn my code into a package. I&#x27;ll probably just write a Dockerfile that will produce a container image with my dependencies installed, ready to run my code directly.</p>
<p>In terms of layout, I probably want a <a href="https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/">&#x27;flat layout&#x27;</a>, where my code is in <code>./myapp</code>. This is what Flask, for instance, <a href="https://flask.palletsprojects.com/en/stable/tutorial/layout/">recommends</a>. That&#x27;s not available from <code>uv init</code> -- I have to choose between:</p>
<ul>
<li>a &#x27;Packaged Application&#x27;
This configures a build system I don&#x27;t need and nests all my code in <code>./src/myapp</code>.</li>
<li>a &#x27;Library&#x27;
This has all the downsides of a &#x27;Packaged Application&#x27;, and also doesn&#x27;t specify a command-line entry point.</li>
<li>an &#x27;Application&#x27;
This puts my code in <code>.</code>, the project root, which will get cluttered quickly if I want to build anything bigger than a single-file script.</li>
</ul>
<p>None of these do what I want! No matter what I choose, I&#x27;ll have to move things around and change <code>pyproject.toml</code> to account for the changes.</p>
<p>This is addressed in #6460, which seems to be resolved by #6585, adding &#x27;Virtual Projects&#x27;, which don&#x27;t get built or installed as packages. But the only place this is documented is <a href="https://docs.astral.sh/uv/reference/settings/#package">under the setting that enables it</a>, where I can read a brief summary of what a virtual project <em>is</em>, but not why I might want to use one. #6585 states that a project will be treated as &#x27;virtual&#x27; merely by the lack of a <code>[build-system]</code> in <code>pyproject.toml</code>, but this isn&#x27;t documented there. The <a href="https://docs.astral.sh/uv/concepts/projects/#creating-projects">documentation on <code>uv init</code></a> doesn&#x27;t mention &#x27;virtual projects&#x27; at all.</p>
<p>A brief aside regarding &#x27;virtual projects&#x27; and <code>uv init</code>: it seems like  <code>uv init --virtual</code> creates a virtual project, but the <code>--virtual</code> flag can&#x27;t be used with <code>--package</code> (for a &#x27;Packaged Application&#x27;) or with <code>--lib</code> (for a &#x27;Library&#x27;). And <code>uv init --virtual</code> produces exactly the same result as <code>uv init</code> without the <code>--virtual</code> flag, not even adding <code>package = false</code> to <code>pyproject.toml</code>. So it&#x27;s not clear to me what the flag is supposed to do.</p>
<p>I love <code>uv</code> as a whole, but this is extremely confusing to me. Maybe I&#x27;m mistaken on some of this, and I&#x27;m doing something wrong, in which case please feel free to correct me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/junapur">@junapur</a> on 2024-11-19 04:48</div>
            <div class="timeline-body"><p>I agree. As someone migrating from Poetry to uv, uv&#x27;s project layout options were a lot harder for me to understand.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jromal">@jromal</a> on 2024-12-08 09:48</div>
            <div class="timeline-body"><blockquote>
<p>I&#x27;ve only ended up in this thread because I was confused about the default behaviour here - to me it feels like <code>uv init</code> with no options should do the equivalent of <code>uv init --layout=&lt;bare|none&gt;</code> mentioned above and create nothing but a <code>pyproject.toml</code>. I can&#x27;t imagine ever needing uv to create the <code>.gitignore</code>, <code>.git/</code> and <code>hello.py</code> so for that to be the default seems kinda wild.</p>
</blockquote>
<p>I can follow the logic for not wanting a &quot;hello.py&quot;, but I can fully understand that an example (in the terms mentioned by the request) is a good thing for most of the people. I cannot support not creating the &quot;.git&quot; and &quot;.gitignore&quot; files. All amateurs (which I count myself) should have it, but many do not know about it. Nothing serious should be done without them.</p>
<p>What we need is a revamp on the &quot;layout&quot; structure. Which is confusing. I had to test all the options to understant what is meant. With the &quot;--layout&quot; option is clear and does what people do. .</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/clbarnes">@clbarnes</a> on 2025-01-22 11:01</div>
            <div class="timeline-body"><blockquote>
<p>I can&#x27;t imagine ever needing uv to create the .gitignore, .git/ and hello.py so for that to be the default seems kinda wild.</p>
</blockquote>
<p>Counterpoint: I can&#x27;t imagine ever needing to start a python project without a <code>.gitignore</code> file, and it&#x27;s annoying to go and fetch the exact same file every time, when uv aims to be a one-stop shop. Of course, a minority of people don&#x27;t use git for version control, although a host of other dev tools respect .gitignore when it comes to ignoring files to search/ index/ include so arguably it&#x27;s useful to have even if you&#x27;re not using git.</p>
<p>I think that <code>hello.py</code>, while deleted/ renamed immediately by developers who start new projects regularly, acts as a useful marker for where your functional code should go. Between script, app, and library projects, flat or src layouts, multi-package projects etc., that may not be clear to someone less experienced, or even an experienced developer who hasn&#x27;t followed the breakneck pace of the evolution of python&#x27;s best practices in the last few years.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drcongo">@drcongo</a> on 2025-01-22 13:24</div>
            <div class="timeline-body"><p>@clbarnes Not everyone is starting a new project, nor running uv where their .gitignore, .git repo or README lives - think mono-repos, projects where uv is inside docker, projects where you&#x27;re in a git submodule etc. - in some of these cases, creating a .git repo is a positively hostile thing to do as you can suddenly end up with nested repositories being pushed and then someone (me) has to untangle it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/allenc97">@allenc97</a> on 2025-01-24 05:38</div>
            <div class="timeline-body"><p>Lots of insightful thoughts. I would also argue for project layout to be separated from rather the project is intended to be an application or a python package. In fact, it is not uncommon for python applications to also use a src layout. This is especially useful with containers as mounting all source code files is just a singular mount, or for standardized use in CI/CD.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Bunker-D">@Bunker-D</a> on 2025-01-28 21:16</div>
            <div class="timeline-body"><p>I second the idea of a more customized option for <code>uv init</code>. I would also like the option to setup a <em><strong>personal default configuration</strong></em>.</p>
<p>Additionally, it would be neat to be able to <strong>customize the starting <code>.gitignore</code></strong> (at least, setting up a <em><strong>personal default <code>.gitignore</code></strong></em>).</p>
<p>Typically, I would systematically exclude <code>.*_cache</code> (<code>.pytest_cache</code> and <code>.ruff_cache</code>) and <code>.venv</code>, and I&#x27;m pretty sure developers&#x27; needs would change based on their favorite tools.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Bunker-D">@Bunker-D</a> on 2025-01-28 21:47</div>
            <div class="timeline-body"><p>Also, while I don&#x27;t disagree with @clbarnes &#x27;s justification of <code>hello.py</code> (making me neutral about the creation of <code>hello.py</code>), I think <code>src/&lt;‚Ä¶&gt;/__init__.py</code> should not be initialized with code inside it. My big issue with this behavior is that this dummy code not visible at first sight when looking at the project. Worse than having to clean it up, devs might miss it,</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrish42">@chrish42</a> on 2025-02-11 16:25</div>
            <div class="timeline-body"><p>Also coming here because I love the <code>uv</code> experience overall... except for its package layout creation options, which I found really confusing. I wanted to create a src-layout for a library that was going to be packaged and released eventually, and by far most of my time struggling with <code>uv</code> was spent trying to figure out how to get that config.</p>
<p>The <code>--library</code>, etc. options are not great currently, because they bundle too many things together. It&#x27;s totally fine to have defaults for new users (and please do that). But if I want a src-layout for my project (whatever it is), it would be so much easier to just ask explicitly (&quot;better than implicit&quot;) for it by tacking on a <code>--layout=src</code> option to my <code>uv init</code> invocation.</p>
<p>Also, I was kind of expecting this choice of layout to be also reflected in the section for <code>uv</code> of the <code>pyproject.toml</code> file, at least, so all <code>uv</code> invocations know about it. Right now, I have a makefile whose main function is to tack on <code>uv run --project src</code> to all the commands I need to run during development.</p>
<p>For me, this is the only thing making me hesitate to recommend <code>uv</code> more broadly to my team.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-11 16:29</div>
            <div class="timeline-body"><blockquote>
<p>The --library, etc. options are not great currently, because they bundle too many things together. It&#x27;s totally fine to have defaults for new users (and please do that). But if I want a src-layout for my project (whatever it is), it would be so much easier to just ask explicitly (&quot;better than implicit&quot;) for it by tacking on a --layout=src option to my uv init invocation.</p>
</blockquote>
<p>What things did you not want?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-11 16:30</div>
            <div class="timeline-body"><blockquote>
<p>Right now, I have a makefile whose main function is to tack on uv run --project src to all the commands I need to run during development.</p>
</blockquote>
<p>I&#x27;m a little confused by this, you want to run with your working directory as <code>src/</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hunter-gatherer8">@hunter-gatherer8</a> on 2025-02-20 02:26</div>
            <div class="timeline-body"><p>How about allowing users to provide their own configuration template in some uv config directory? Or even several templates one could choose with something like <code>uv init --template=my-named-preset</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-20 03:35</div>
            <div class="timeline-body"><p>@hunter-gatherer8 please see <a href="https://github.com/astral-sh/uv/issues/9754">astral-sh/uv#9754</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ivan-kleshnin">@ivan-kleshnin</a> on 2025-02-27 11:05</div>
            <div class="timeline-body"><p>Can someone take a little time to elaborate the reasoning behind &quot;src&quot; layout for non-Pythonistas üôè</p>
<p>With &quot;flat&quot; layout:</p>
<pre><code>project_name/
  project_name/
</code></pre>
<p>we already have a folder-level isolation. It does look &quot;nested&quot; to a TypeScript-first version of me üòÑ I get that the project can have multiple packages and those packages will, supposedly, have common files under <code>project_name/src</code>. But is there any benefit for simple (and probably more frequent) <em>one-package-per-project</em> cases?</p>
<p>Quoting the article, that everyone refers to:
https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/</p>
<blockquote>
<p>The src layout requires installation of the project to be able to run its code, and the flat layout does not.</p>
</blockquote>
<p>I don&#x27;t get this point. With Poetry I had to install my library package, and it definitely has the &quot;flat&quot; layout.</p>
<blockquote>
<p>The src layout helps prevent accidental usage of the in-development copy of the code.</p>
</blockquote>
<p>This point is more clear. But it&#x27;s a &quot;protection by convention&quot;, not the strongest argument. We can still accidentally put a non-public data or code in <code>src</code>. So, again, I would like to learn pros/cons of each layout better, maybe someone can suggest another article or video?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/astrojuanlu">@astrojuanlu</a> on 2025-02-27 11:23</div>
            <div class="timeline-body"><blockquote>
<p>Can someone take a little time to elaborate the reasoning behind &quot;src&quot; layout for non-Pythonistas üôè</p>
</blockquote>
<p><code>import package_name</code> may pick up the code from your source checkout and not the installed one depending on your current working directory. src prevents this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-27 15:28</div>
            <div class="timeline-body"><p>https://hynek.me/articles/testing-packaging/ and https://blog.ionelmc.ro/2014/05/25/python-packaging/#the-structure have some discussion of the topic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/clbarnes">@clbarnes</a> on 2025-02-28 15:03</div>
            <div class="timeline-body"><blockquote>
<p>Can someone take a little time to elaborate the reasoning behind &quot;src&quot; layout for non-Pythonistas üôè</p>
</blockquote>
<p>Python was originally designed as a scripting language, more akin to bash or perl than Java. As such, it&#x27;s pretty liberal about sweeping local directories for python code to import and execute. However, there are a few different ways of executing python code and that module discovery happens differently in different execution contexts. Some tools designed with that style in mind (e.g. testing utilities) also do things under the hood to make things &quot;easier&quot;, which actually makes module discovery even more complicated.</p>
<p>As python has been used for bigger, more complicated projects, this module discovery complexity has been found to add little utility and a lot of headaches. Isolating your code in a <code>src</code> folder prevents it from being auto-discovered in most cases, which improves consistency, puts the developer in control of what is imported and how, and makes your development environment behave more similarly to your deployment environment.</p>
<p>Python as a language has changed to support bigger, more complicated projects (e.g. <code>typing</code>), as has the tooling around it (e.g. <code>uv</code>!).</p>
<p>Also it helps separate the actual module from general project-related cruft like CI configuration, scripts, infrastructure setup, docs etc..</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matthias-busch">@matthias-busch</a> on 2025-03-04 15:44</div>
            <div class="timeline-body"><p>Coming from using <code>poetry</code> I also find the <code>uv init</code> options a bit confusing and convoluted.</p>
<p>I personally would prefer the pretty simple/bareback approach of poetry&#x27;s <code>poetry new some-name</code> for a project skeleton that looks like this:</p>
<pre><code>‚ùØ tree bar-delete-later
bar-delete-later
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ bar_delete_later
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ __init__.py
‚îú‚îÄ‚îÄ pyproject.toml
‚îî‚îÄ‚îÄ tests
    ‚îî‚îÄ‚îÄ __init__.py
</code></pre>
<p>and <code>poetry new --src some-name</code> resulting in:</p>
<pre><code>‚ùØ tree foobar-delete-later
foobar-delete-later
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ pyproject.toml
‚îú‚îÄ‚îÄ src
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ foobar_delete_later
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ __init__.py
‚îî‚îÄ‚îÄ tests
    ‚îî‚îÄ‚îÄ __init__.py
</code></pre>
<p>This might be a simple case of personal preference and I totally (and welcome) uv&#x27;s intent to being as user-friendly as possible but I personally think pruning back on the options and just giving options for the src/flat layout would suffice and more straightforward.</p>
<p>I would also love to have the <code>tests</code> folder generated by default  for both approaches.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jlcheng">@jlcheng</a> on 2025-03-07 16:50</div>
            <div class="timeline-body"><p>I am grateful that this conversation is happening here. As someone who recently needed to setup a Python project, I ran into the flat vs src decision myself. In the end, I decided that I would use the src layout as my default, as well as making the choice to use <code>uv</code> as my preferred tool. But the src-vs-flat choice in Python will probably never go away and I think it won&#x27;t be easy for uv to, for the lack of a better phrase, &quot;make the <em>right</em> choice.&quot; There won&#x27;t be a perfect answer.</p>
<p>Having said that, I think simply discussing this matter in the uv documentation will go a long way to helping the community, especially people new to Python project layouts like me. Today, the uv documentation (https://docs.astral.sh/uv/concepts/projects/init/) discusses the difference between &quot;Application&quot;, &quot;Packaged Application&quot;, and &quot;Library&quot;. This page could be a good place to discuss why the uv team chose Application as the default and what the implications are (e.g., perhaps referencing https://hynek.me/articles/testing-packaging/).</p>
<p>This is akin to the practice of keeping architectural decision records (https://adr.github.io/). The goal is not to justify that the current decision to make Application the default is the right one--people will always debate such a decision. The goal is to give users context about how the decision was made <em>at the time</em>, which empowers users to better evaluate the alternatives given their own situations and future evolutions in the Python community.</p>
<p>Thanks again for considering this topic. And many thanks to @MikeHart85 for his thoughtful and intelligent proposal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-07 17:47</div>
            <div class="timeline-body"><blockquote>
<p>This page could be a good place to discuss why the uv team chose Application as the default and what the implications are (e.g., perhaps referencing https://hynek.me/articles/testing-packaging/).</p>
</blockquote>
<p>I think this is summarized in <a href="https://github.com/astral-sh/uv/issues/3957">astral-sh/uv#3957</a>#issuecomment-2657825266 ‚Äî we don&#x27;t want this to be the default longterm.</p>
<p>We intend to revisit this entire interface once our build backend is ready.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carlosferreyra">@carlosferreyra</a> on 2025-03-19 21:34</div>
            <div class="timeline-body"><p>Thank you for pointing this proposal!
I&#x27;ve been following this thread, but I&#x27;m a noob in the open source community, so a little shy to give any opinion.</p>
Proposal
<p>following with @zanieb ideas and the philosophy of uv, for becoming the cargo of python (or npm/bunof python):
Having uv as a tool for scaffolding an initial template is a must.</p>
<p>What it goes in my mind, is that you can set a basic &quot;<strong>PEP compliant version of project initialization</strong>&quot; for <code>uv init</code> (specially when it comes matching <a href="https://packaging.python.org/en/latest/specifications/">pyproject specs.</a>, and use <code>uvx</code> for anything that has to do with custom templates (including those that work with <a href="https://github.com/cookiecutter/cookiecutter">cookiecutter</a> or <a href="https://github.com/copier-org/copier">copier</a>. This follows 3 goals:</p>
<ul>
<li>keeps a clean workflow for the uv client, knowing that creating a project is a <em>one time action</em> during the lifetime of the project itself.</li>
<li>Maintain strong compliance with PEP without sacrificing out-of-the-box features from uv.</li>
<li>Make a equivalent use of what it was<code>npx create-react-app</code>|<code>npx create-expo-app</code> and would be <code>uvx create-{some-python-template}</code></li>
</ul>
<p>Also, you could use the proposal as a way to migrate from current out the box options out there in the python community, to a more <em>uv compliant</em> version of it. Benefits:</p>
<ul>
<li>Decrease of python community friction, when migrating to the uv ecosystem.</li>
<li>Leave <code>uvx</code> as an entrypoint for extended scaffolding models (i.e, even one for cloud-based or AI projects), and even using the community popular choices as a possible builtin-template for uv.</li>
</ul>
<p>An example of this was the <code>uvx migrate-to-uv</code> <a href="https://github.com/mkniewallner/migrate-to-uv">script</a> which allows to migrate from poetry to uv, but this very concept could also be applied for scaffolding templates from scratch.</p>
Possible Drawbacks
<ul>
<li>Dealing with a new set of standards when designing a new template through <code>uvx</code> and have the community to adhere to those standards</li>
<li>Increased complexity in maintaining two separate but related commands (<code>uv init</code> and <code>uvx</code>).</li>
<li>Potential confusion for new users about when to use <code>uv init</code> versus <code>uvx</code>.</li>
<li>The need for significant effort to define and maintain the &quot;PEP compliant&quot; template for <em>uv init</em>, ensuring it remains up-to-date with evolving Python standards.</li>
<li>Reliance on the community to create and maintain high-quality templates for <code>uvx</code>. If the community uptake is slow, the uvx ecosystem might lack useful options.</li>
<li>Overlap in functionality with existing tools like <code>cookiecutter</code> or <code>copier</code> might lead to fragmentation or resistance from users already comfortable with those tools.</li>
</ul>
Basic Structure
<p>The <code>uv init</code> purpose should be to set up the least amount of settings for the project, since even when you need scaffolding, you also need to keep the option for a full customization from scratch. having said that, I agree with the initial proposal of the issue, but with a small caveat: <strong>all templates, no matter if flat,lib, or package</strong> should have the <code>/src</code>  folder, since its a good widely accepted standard for the dev community, and also separates the project configuration from any project implementation <em>(even for frontend devs)</em>.</p>
Easter Egg
<p>the team could even create a dedicated package for using the <code>uvx</code> client, to build templates (<code>uvx start-project --with cookiecutter|copier|[uv]</code>)... and those templates can be selected by the uv team to comply with the uv ecosystem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tmct">@tmct</a> on 2025-04-10 11:10</div>
            <div class="timeline-body"><p>uv is a great tool for managing virtual environments, even outside of packages, so I&#x27;m wondering: should there be a template for e.g. <code>--venv</code>, which just gives you all you need to start managing a virtual environment?</p>
<pre><code>.git
.gitignore
pyproject.toml  # (with no [build-system])
.python-version
</code></pre>
<p>Currently, <code>uv init --no-readme --no-package</code> gets you close to this but creates an undesired &quot;main.py&quot;, and <code>uv init --bare</code> is good but misses .python-version, and the git files. So - potentially a <code>--no-main</code>  option, or allowing <code>--vcs git</code> etc to work with <code>--bare</code> would achieve this - but perhaps this use-case is worthy of its own template?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Spenhouet">@Spenhouet</a> on 2025-08-04 06:43</div>
            <div class="timeline-body"><p>We started using a monorepo structure and we&#x27;d still like to have &quot;apps&quot; which do not need a build system but now we have many and the flat layout used by <code>--app</code> leads to import conflicts. We&#x27;d like to have apps with a src directory, but I could not find an option to initialize this via uv.</p>
<p>It feels like <code>uv init</code> is trying to hard to think for the user and does a lot of presets/magic. Adding a <code>--layout</code> option to give the user the flexibility to choose the project structure themself would be great.
In addition a <code>--build-backend none</code> option could also help to disable adding a build-backend.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/heyitsaamir">@heyitsaamir</a> on 2025-11-20 18:06</div>
            <div class="timeline-body"><p>+1 on the whole discussion here. It&#x27;d be great if uv could support templates out of the box especially. We use cookiecutter in our project (an SDK), but telling our customers to use cookiecutter for starter templates seems ugly.</p>
<p>Another idea is, if uv doesn&#x27;t want to support this OOB, if there was a plugin system which would allow hooks like cookiecutter etc to be developed as plugins, then we could ask folks that they need to install uv with cookiecutter plugin, and then those systems could work without being included officially in uv core.</p>
<p>EDIT: I see that <a href="https://github.com/astral-sh/uv/issues/8178">astral-sh/uv#8178</a>#issuecomment-2738176730 this comment has a great suggestion using uvx!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:34:45 UTC
    </footer>
</body>
</html>
