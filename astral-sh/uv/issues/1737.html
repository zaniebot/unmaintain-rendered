<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance with large git repos - astral-sh/uv #1737</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Performance with large git repos</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/1737">#1737</a>
        opened by <a href="https://github.com/sbidoul">@sbidoul</a>
        on 2024-02-20 07:21
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sbidoul">@sbidoul</a></div>
            <div class="timeline-body"><p>Hi,</p>
<p>I found a situation where uv is significantly slower than pip: installing from a large git repo.</p>
<p>Reproducer: <code>uv -v pip install &quot;odoo @ git+https://github.com/odoo/odoo@17.0&quot;</code> (warning: this requires ~6GB disk space and a ~4GB download).</p>
<p>After the download (observed by monitoring network activity), there seems to be a pause of several minutes where it is unclear what uv is doing, even with <code>-v</code> or RUST_LOG=trace.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @konstin on 2024-02-20 11:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-02-20 14:56</div>
            <div class="timeline-body"><p>Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-02-20 15:02</div>
            <div class="timeline-body"><p>@zanieb - This may be solved by changing the default to use the Git CLI.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/serozhenka">@serozhenka</a> on 2024-02-22 21:07</div>
            <div class="timeline-body"><p>I also experience a strange pause for around 7 seconds (out of 17 for the overall install) when trying to install a private git package via a git tag and not a commit ref. As @sbidoul mentioned nothing indicates what's going on even when enabling additional verbosity.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-02-22 21:25</div>
            <div class="timeline-body"><p>@serozhenka is this on the latest version?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/serozhenka">@serozhenka</a> on 2024-02-22 21:30</div>
            <div class="timeline-body"><p>@zanieb it was 0.1.6 at the time of writing, but I have just checked on 0.1.8 and it's the same. Installation time dropped down by 3s on average, but that lag still exists.</p>
<p>upd. my bad on that, missed a single log statement, that's actually the repo subdirectory fetch itself that takes 8s. But overall it's still 1-2s slower that pip with cold cache.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-02-23 13:59</div>
            <div class="timeline-body"><p>From my part, I have noticed a solid improvement with the switch to using the git CLI.</p>
<p>In pip we use <code>git clone --filter=blob:none</code> to improve performance with large repos, but the pip git clones are transient (we only keep the resulting wheel).</p>
<p>So I think (I've not mesured rigorously) that with a cold cache, uv is slower than pip with large git repos, but when the git db cache is pre-populated, subsequent operations will be faster.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-03-18 13:56</div>
            <div class="timeline-body"><blockquote>
<p>but when the git db cache is pre-populated, subsequent operations will be faster.</p>
</blockquote>
<p>which doesn‘t apply here, right? we just care about a repo’s</p>
<ol>
<li>working directory contents (i.e. all the files)</li>
<li>git history metadata (in case <code>setuptools_scm</code> or so wants to know how many commits it has been since the last tag)</li>
</ol>
<p>both of these are being downloaded with <code>--filter=blob:none</code>, then we build, then we throw the repo away and don’t do any subsequent operations on it.</p>
<p>So uv should definitely do that, unless I’m missing something.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-03-18 13:58</div>
            <div class="timeline-body"><p>Yeah, we tried it here: https://github.com/astral-sh/uv/pull/3950. It just hasn't been done.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-06-06 12:25</div>
            <div class="timeline-body"><p>I think what we could e.g. do is treat each repo as database of sorts:</p>
<ol>
<li>if<ol>
<li>… we haven’t seen the repo before, clone the git repo into the cache using <code>--filter=blob:none</code> and the requested ref</li>
<li>… the repo is in the cache and the ref is a tag or branch or unknown commit hash, fetch the requested ref into that repo</li>
</ol>
</li>
<li>create a work tree from that repo and ref and use that to build stuff</li>
</ol>
<p>or something similar.</p>
<p>that would help with retaining info as opposed to re-cloning.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-06-06 12:58</div>
            <div class="timeline-body"><p>I think that's roughly what we do already? We maintain a Git database. The way it works is that we have a single clone of each repo, and when we need to use a commit, we fetch it into the Git database then create a <em>local</em> clone of that ref to build from. (But I don't believe it's blobless.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-06-06 13:44</div>
            <div class="timeline-body"><p>I see, then with a warm cache, subsequent VCS installs of the same repo should be fast-ish already (only new commits will be fetched on top of what was there last time), but we can still improve that initial clone to speed up the cold cache case by making the initial clone blobless. (I think creating a work tree instead of a local clone doesn’t make a huge difference, but could be a tiny bit faster and take less space)</p>
<p>I think the only use case that would be slower would be to</p>
<ol>
<li>install a package from VCS</li>
<li>then install a package from an older commit of that same VCS</li>
</ol>
<p>because the way you currently doing it, all old commits are already fetched, so this would be an almost entirely local operation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-06-06 14:02</div>
            <div class="timeline-body"><p>We've tried to make the initial clone cheaper, e.g.,</p>
<ul>
<li>https://github.com/astral-sh/uv/pull/3950</li>
<li>https://github.com/astral-sh/uv/pull/8190</li>
</ul>
<p>If you want to dig into that, feel free! It seems hard.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-10-13 07:55</div>
            <div class="timeline-body"><p>Hm, OK, so let’s talk about this. First some Git lingo that was new to me; <a href="https://git-scm.com/docs/partial-clone">partial clones make use of the “promisor remote”</a>:</p>
<blockquote>
<p>A remote that can later provide the missing objects is called a promisor remote, as it promises to send the objects when requested. […]</p>
<p>Use of partial clone requires that the user be online and the <code>origin</code> remote or other promisor remotes be available for on-demand fetching of missing objects</p>
</blockquote>
<p>in #8190, you say things don’t work and (if I understand correctly), you suspect that’s because basically</p>
<ol>
<li>you’re creating a partial clone (1) of some repo</li>
<li>you locally clone (2) that partial clone (making the <code>origin</code>/promisor remote of clone 2 point to clone 1)</li>
<li>trying to access some object in clone 2 will cause the command to abort since clone 2 has the same objects as clone 1 and Git expects the promisor remote to have all the things</li>
</ol>
<p>Did I get that right?</p>
<p>I don’t know when and why you create a clone of a clone, but depending on that, there are multiple ways to fix things, the most obvious probably being that maybe you should just set the <code>origin</code> of the clone’s clone to the actual remote origin</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:23:51 UTC
    </footer>
</body>
</html>
