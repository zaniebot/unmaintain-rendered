<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uv add should use ^ instead of &gt;= when adding dependencies to pyproject.toml - astral-sh/uv #10247</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>uv add should use ^ instead of &gt;= when adding dependencies to pyproject.toml</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/10247">#10247</a>
        opened by <a href="https://github.com/kishaningithub">@kishaningithub</a>
        on 2024-12-31 02:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kishaningithub">@kishaningithub</a></div>
            <div class="timeline-body"><p>To add / remove dependencies i use the <code>uv add</code> and <code>uv remove</code> commands and i prefer not to edit <code>pyproject.toml</code> manually.</p>
<p>When i do something like <code>uv add requests</code> i see the following addition in <code>pyproject.toml</code></p>
<pre><code class="language-toml">dependencies = [
    &quot;requests&gt;=2.32.3&quot;
]
</code></pre>
<p>The <code>&gt;=</code> looks super scary as it semantically means my project will not break even if requests releases a major version. Yes, i know there is a <code>uv.lock</code> file to ensure reproducible builds but i prefer the following when i do <code>uv add requests</code></p>
<pre><code class="language-toml">dependencies = [
    &quot;requests&gt;=2.32.3,&lt;3&quot;
]
</code></pre>
<p>I believe poetry on several other semver tools use something like <code>^2.32.3</code> which is basically the equivalent of <code>&gt;=2.32.3,&lt;3</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-31 06:13</div>
            <div class="timeline-body"><p>Loosely a duplicate of https://github.com/astral-sh/uv/issues/6783</p>
<p>There's a very strong argument for <em>not</em> including upper bounds when publishing libraries. I think in applications, an upper bound can be nice. There is further discussion linked in the referenced issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">duplicate</span> added by @zanieb on 2024-12-31 06:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kishaningithub">@kishaningithub</a> on 2024-12-31 11:50</div>
            <div class="timeline-body"><blockquote>
<p>There's a very strong argument for not including upper bounds when publishing libraries.</p>
</blockquote>
<p>@zanieb Can you point me to this? I am unable to find it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-12-31 14:27</div>
            <div class="timeline-body"><p>https://iscinumpy.dev/post/bound-version-constraints/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-31 17:18</div>
            <div class="timeline-body"><p>And more, at https://github.com/zanieb/poetry-relax?tab=readme-ov-file#references</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woutervh">@woutervh</a> on 2025-01-01 15:01</div>
            <div class="timeline-body"><p>This caret-notation, made popular by poetry, is one of the most diabolical anti-patterns in the python-world.
Dependency-hell can be a pain. A fake dependency-hell is even worse.</p>
<p>It also conflates the notions of abstract and concrete dependencies.</p>
<ul>
<li>Abstract dependencies are the toplevel direct dependencies we specify in pyproject.toml</li>
<li>concrete dependencies is the list all required packages with a concrete version-number need to create a reproducible build, aka lock-files.</li>
</ul>
<p>Also a major new release does not mean &quot;guaranteed backward incompatibility&quot;.
I've seen deployed projects break on dependencies with new major releases, minor releases, and not even rarely, patch-releases.
To check compatibililty use your own test-suite and don't rely on a vague external semantic version-number.</p>
<blockquote>
<p>The &gt;= looks super scary as it semantically means my project will not break even if requests releases a major version.</p>
</blockquote>
<p>That is not what it means.
It means that the code is <em>intended</em> to be working on newer versions, even if those version don't exist yet.
And if it doesn't work, it will be considered a bug that should be fixed.</p>
<p>But how can you test this new major release, if that packages flat-out refuses to install in your venv?
uv's capability to override package-depencies has already been a great use for me, poetry does not even have an equivalent.</p>
<p>Specifying minimum-version on the other hand, means that the code likely does to work and there is no intention to fix that.</p>
<p>Try to read it like &quot;intended to support&quot;</p>
<p>If your package uses newer language-constructs introduced in python3.10, then use</p>
<blockquote>
<p>python = &quot;&gt;3.10&quot;</p>
</blockquote>
<p>Only specify an upper bound, it you don't intend to support 3.11.</p>
<blockquote>
<p>python = &quot;&gt;3.10&lt;3.11&quot;</p>
</blockquote>
<p>If your package uses python2.7, and you don't the any intention to support python 3, use</p>
<blockquote>
<p>python = &quot;&gt;=2.7,&lt;3&quot;</p>
</blockquote>
<p>I never liked this caret notation, as the mathematical meaning is not intuitively clear:</p>
<blockquote>
<p>python = &quot;^2.7&quot;</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woutervh">@woutervh</a> on 2025-01-01 15:12</div>
            <div class="timeline-body"><p>I don't make the distinction between a python-library or a python-application, as long as there is a lock-file.
IMHO the distinction comes from not properly packaging applications.</p>
<p>For me an application is</p>
<ul>
<li>a python-package</li>
<li>config-file(s)</li>
<li>entry-point to execute/start</li>
</ul>
<p>In scripts with inline metadata, distributed without a lock-file, the upper bounds make sense.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yakMM">@yakMM</a> on 2025-01-01 16:05</div>
            <div class="timeline-body"><p>I agree the default lower bound constraint is enough for library.</p>
<p>I also think there is value in adding an option like <code>--save-exact</code> to bind the latest version (useful for applications and scripts)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @zanieb on 2025-01-06 20:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Ark-kun">@Ark-kun</a> on 2025-03-03 20:48</div>
            <div class="timeline-body"><p>I've seen many many projects around me break for all users when some backwards incompatible major version of a library is released. Pydantic released v2 and thousands of major projects and libraries broke.</p>
<p>When your library only specifies lower bound, it will eventually break for all your users. Their CI/CDs, Dockerfiles etc will be broken.</p>
<p>When people do <code>pip install some-package==1.2.3</code> or <code>uv add some-package==1.2.3</code> they expect that the package will work, not be a broken mess. Not having upper bounds guarantees the result will be a mess.</p>
<p>When package specifies only lower bound <code>dependency&gt;=1.0.0</code>, the package is claiming it is compatible with any future version which is a lie. Package versions with dependency upper bounds can live their whole life and retire without breaking the users. There is a big chance. Packages without upper bound WILL eventually break all their users. There is zero chance.</p>
<blockquote>
<p>It means that the code is intended to be working on newer versions, even if those version don't exist yet.</p>
</blockquote>
<p>No. It first and foremost means that the current version is not supported to be working on far away future versions.
It's like product warranty. Lower bound is a &quot;this version will be compatible forever&quot; claim which is most certainly a lie. Upper bound is analogous to &quot;This product version is supported for 1 year&quot; which has much higher probability of not breaking.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-03 20:57</div>
            <div class="timeline-body"><p>This has been repeatedly discussed, so I won't go into depth here. While I agree with your perspective, the reality is more complicated.</p>
<p>When <code>&gt;=</code> is used, those downstream users can add a constraint to, e.g., Pydantic, when a new version is released to resolve their problem. When <code>&lt;</code> is used, there is <em>no recourse</em> for downstream users. The package versions are considered incompatible regardless of runtime compatibility. That's it. The user can't do anything about it (unless you're using uv ðŸ¥³ which allows overwriting that incorrect package metadata).</p>
<p>Unfortunately, that's the state of things.</p>
<p>This is why lockfiles and other methods of reproducibility (like <code>exclude-newer</code>) are so important for avoiding the &quot;eventually break&quot; case you mention.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MatteoCampinoti94">@MatteoCampinoti94</a> on 2025-03-14 12:14</div>
            <div class="timeline-body"><blockquote>
<p>When &gt;= is used, those downstream users can add a constraint</p>
</blockquote>
<p>That works if you are distributing a library and the downstream users are programmers who know how to look up and fix those kind of errors, but if you are distributing an application you want it to work with as little user intervention as possible and having only a lower bound <em>guarantees</em> that the application will break eventually. Having an option to pin the version to major (<code>&gt;=x.y.z,&lt;x+1</code>), minor (<code>&gt;=x.y.z,&lt;x.y+1</code>), or patch (<code>==x.y.z</code>) would be extremely useful.</p>
<pre><code class="language-bash">uv add &lt;package&gt; --pin {major|minor|patch}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woutervh">@woutervh</a> on 2025-03-15 14:32</div>
            <div class="timeline-body"><p>@MatteoCampinoti94</p>
<blockquote>
<p>if you are distributing an application you want it to work with as little user intervention as possible and having only a lower bound guarantees that the application will break eventually.</p>
</blockquote>
<p>This will solve your use-case?</p>
<pre><code>uv sync --resolution lowest-direct
</code></pre>
<p>in pyproject.toml:</p>
<pre><code>[tool.uv]
resolution = &quot;lowest-direct&quot;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MatteoCampinoti94">@MatteoCampinoti94</a> on 2025-03-15 22:34</div>
            <div class="timeline-body"><p>@woutervh That does not do anything for distribution, uv's resolution setting only affects the lock file which is <em>not</em> part of the distributed wheel. To make sure those versions are pinned you need to either add the version spec when using <code>uv add</code> or modify the pyproject file after adding the dependencies.</p>
<p>The first method is just annoying because you have to know the version beforehand, so you'd have to check the package on pypi then run uv add. The second is not so bad but it is still annoying.</p>
<p>There is no reason for <code>uv add</code> not to have a simple way to pin the version to the current major number or minor, because that is good practice when distributing applications.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:29:06 UTC
    </footer>
</body>
</html>
