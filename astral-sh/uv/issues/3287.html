<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[perf] uv pip install resolution is slow when installing from VCS - astral-sh/uv #3287</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[perf] uv pip install resolution is slow when installing from VCS</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/3287">#3287</a>
        opened by <a href="https://github.com/baggiponte">@baggiponte</a>
        on 2024-04-27 09:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/baggiponte">@baggiponte</a></div>
            <div class="timeline-body"><p>Ciao! I am installing a library from VCS and I <em>feel</em> it should be faster.</p>
<p>The library in question is functime, a forecasting library I maintain. I installed first a version from a <a href="https://github.com/functime-org/functime/pull/181">PR I am about to merge</a>, but then I realised it's just as slow if I just install from VSC.</p>
<p>I took the install command from the official <a href="https://pip.pypa.io/en/stable/topics/vcs-support/#git"><code>pip</code> docs</a>.</p>
<pre><code class="language-bash">uv pip install --no-cache  -- &quot;functime[plot,lgb] @ git+https://github.com/functime-org/functime.git@refs/pull/181/head&quot;

 Updated https://github.com/functime-org/functime.git (7c699c2)                             
Resolved 21 packages in 37.10s
   Built functime @ git+https://github.com/functime-org/functime.git@7c699c2118c96a7799b9e2bbb077b25149beeac2
   Built lightgbm==4.3.0                                                                                                                                                                Downloaded 21 packages in 1m 49s
Installed 21 packages in 295ms
 + cloudpickle==3.0.0
 + flaml==2.1.2
 + functime==0.9.5 (from git+https://github.com/functime-org/functime.git@7c699c2118c96a7799b9e2bbb077b25149beeac2)
 + holidays==0.47
 + joblib==1.4.0
 + kaleido==0.2.1
 + lightgbm==4.3.0
 + numpy==1.26.4
 + packaging==24.0
 + pandas==2.2.2
 + plotly==5.21.0
 + polars==0.20.22
 + python-dateutil==2.9.0.post0
 + pytz==2024.1
 + scikit-learn==1.4.2
 + scipy==1.13.0
 + six==1.16.0
 + tenacity==8.2.3
 + threadpoolctl==3.4.0
 + tqdm==4.66.2
 + tzdata==2024.1
</code></pre>
<p>And how much it takes from regular git repo:</p>
<pre><code class="language-bash">uv pip install --no-cache -- &quot;functime[plot,lgb] @ git+https://github.com/functime-org/functime.git&quot;
 Updated https://github.com/functime-org/functime.git (0608c78)
Resolved 21 packages in 37.95s
   Built functime @ git+https://github.com/functime-org/functime.git@0608c78118b5defd42df73b812
   Built lightgbm==4.3.0
Downloaded 21 packages in 1m 48s
Installed 21 packages in 282ms
 + cloudpickle==3.0.0
 + flaml==2.1.2
 + functime==0.9.5 (from git+https://github.com/functime-org/functime.git@0608c78118b5defd42df73b81288e0e7b32fdb59)
 + holidays==0.47
 + joblib==1.4.0
 + kaleido==0.2.1
 + lightgbm==4.3.0
 + numpy==1.26.4
 + packaging==24.0
 + pandas==2.2.2
 + plotly==5.21.0
 + polars==0.20.22
 + python-dateutil==2.9.0.post0
 + pytz==2024.1
 + scikit-learn==1.4.2
 + scipy==1.13.0
 + six==1.16.0
 + tenacity==8.2.3
 + threadpoolctl==3.4.0
 + tqdm==4.66.2
 + tzdata==2024.1
</code></pre>
<p>As a comparison, here is much it takes form PyPI, no cache:</p>
<pre><code class="language-bash">uv pip install --no-cache -- 'functime[plot,lgb]'
Resolved 21 packages in 417ms
   Built lightgbm==4.3.0
Downloaded 21 packages in 30.98s
Installed 21 packages in 284ms
 + cloudpickle==3.0.0
 + flaml==2.1.2
 + functime==0.9.5
 + holidays==0.47
 + joblib==1.4.0
 + kaleido==0.2.1
 + lightgbm==4.3.0
 + numpy==1.26.4
 + packaging==24.0
 + pandas==2.2.2
 + plotly==5.21.0
 + polars==0.20.22
 + python-dateutil==2.9.0.post0
 + pytz==2024.1
 + scikit-learn==1.4.2
 + scipy==1.13.0
 + six==1.16.0
 + tenacity==8.2.3
 + threadpoolctl==3.4.0
 + tqdm==4.66.2
 + tzdata==2024.1
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[perf] uv pip install resolution is slow when installing from VCS (and branch) (?)" to "[perf] uv pip install resolution is slow when installing from VCS" by @baggiponte on 2024-04-27 09:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-27 11:25</div>
            <div class="timeline-body"><p>I think the problem might be that when you install from PyPI, they can serve you a wheel, which is a built artifact (since the uploader of the package uploaded wheels for it, for a bunch of platforms). But if you install from VCS, you're required to build the package from source. And building from source can be really long and expensive -- it completely depends on the package, we basically have to call out to their build method, which could involve compiling native code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-27 11:25</div>
            <div class="timeline-body"><p>And <a href="https://pypi.org/project/functime/#files"><code>functime</code></a> does ship per-platform wheels which suggests they're compiling some native code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/baggiponte">@baggiponte</a> on 2024-04-27 12:09</div>
            <div class="timeline-body"><p>Ciao Charlie, thank you very much for the prompt reply.</p>
<blockquote>
<p>And <a href="https://pypi.org/project/functime/#files">functime</a> does ship per-platform wheels which suggests they're compiling some native code.</p>
</blockquote>
<p>Yes, we have some Rust plugins for Polars!</p>
<blockquote>
<p>I think the problem might be that when you install from PyPI, they can serve you a wheel, which is a built artifact (since the uploader of the package uploaded wheels for it, for a bunch of platforms). But if you install from VCS, you're required to build the package from source. And building from source can be really long and expensive -- it completely depends on the package, we basically have to call out to their build method, which could involve compiling native code.</p>
</blockquote>
<p>Indeed! I should've been more precise, sorry. What bugged me was the resolution time:</p>
<p>From VCS:</p>
<pre><code class="language-diff">+Resolved 21 packages in 37.95s
   Built functime @ git+https://github.com/functime-org/functime.git@0608c78118b5defd42df73b812
   Built lightgbm==4.3.0
Downloaded 21 packages in 1m 48s
Installed 21 packages in 282ms
</code></pre>
<p>From PyPI:</p>
<pre><code class="language-diff">+Resolved 21 packages in 417ms
   Built lightgbm==4.3.0
Downloaded 21 packages in 30.98s
Installed 21 packages in 284ms
</code></pre>
<p>You say that in the first case it's 38s because it has to download and build the binary? Couldn't <code>uv</code> try to fetch <code>pyproject.toml</code> to perform resolution first? I guess the overall time would not change, since build would need to happen anyway.</p>
<p>Feel free to close the issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-27 12:13</div>
            <div class="timeline-body"><p>Ahh I see! Let me take a look -- we should be able to clone the repo and read the metadata without building the wheel in this case. (But we do need to clone it, we don't do selective reads (e.g., <em>just</em> checkout the <code>pyproject.toml</code>) from Git.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-27 12:15</div>
            <div class="timeline-body"><p>Mmm I think for me basically the entire time is spent cloning the repo. That's a bummer. Maybe a datapoint for @ibraheemdev when it comes to seeing if we can make clones any faster.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @charliermarsh on 2024-04-27 12:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-27 12:16</div>
            <div class="timeline-body"><p>(But I confirmed that we <em>do</em> read the metadata from <code>pyproject.toml</code>, and we <em>don't</em> build the wheel, which is good.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/baggiponte">@baggiponte</a> on 2024-04-27 15:45</div>
            <div class="timeline-body"><p>Very thorough, thanks!</p>
<blockquote>
<p>(But we do need to clone it, we don't do selective reads (e.g., just checkout the pyproject.toml) from Git.)</p>
</blockquote>
<p>Why this? I am incredibly naive on the parallelisation side of things, but if you managed to collect the list of requirements from pyproject.toml then you could parallelise the build and download/installation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-27 15:49</div>
            <div class="timeline-body"><p>If we have a Git dependency, the first step is that we need to clone the repo. Then we read the <code>pyproject.toml</code> if it exists. Perhaps in theory we could try to <em>only</em> clone <code>pyproject.toml</code> (we can't know whether it exists in advance, but we could try), I don't know if it's even possible fetch a single file from Git though. Maybe if we know it's on GitHub, we could try to add a fast path for it by downloading the file directly rather than using a Git client.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2024-04-27 20:26</div>
            <div class="timeline-body"><blockquote>
<p>Mmm I think for me basically the entire time is spent cloning the repo. That's a bummer. Maybe a datapoint for @ibraheemdev when it comes to seeing if we can make clones any faster.</p>
</blockquote>
<p>FYI pip uses blobless clones with git to make performance faster: https://github.com/pypa/pip/pull/9086. Maybe uv is already doing this, but thought I'd mention just in case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hmc-cs-mdrissi">@hmc-cs-mdrissi</a> on 2024-04-27 21:15</div>
            <div class="timeline-body"><p>Shallow clones(—depth=1) can also give nice speed up. However they have caveats as some libraries (setuptools_scm) relies on git metadata that shallow clones will not have. https://github.com/pypa/pip/issues/2432 this discusses issue more in depth. Shallow cloning if done likely needs a flag to control it to handle situations where full clone is necessary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluss">@bluss</a> on 2024-04-27 22:30</div>
            <div class="timeline-body"><p>For that particular repo (functime.git @ main), it seems to be downloading 285 MB for a regular clone and 231 MB for filter=blob:none. That's a surprisingly small difference.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2024-04-29 14:25</div>
            <div class="timeline-body"><blockquote>
<p>For that particular repo (functime.git @ main), it seems to be downloading 285 MB for a regular clone and 231 MB for filter=blob:none. That's a surprisingly small difference.</p>
</blockquote>
<p>Yeah, not sure how much performance impact this will have in general, but one advantage of enabling it is that it is well tested in pip as it has been enabled in for ~2.5 years now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-29 14:26</div>
            <div class="timeline-body"><p>(We might already be doing that, I haven’t investigated deeply and can’t quite remember.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-04-29 14:36</div>
            <div class="timeline-body"><p>I sort of think we do shallow clones already, but a bunch of our git code is vendored and adapted from elsewhere so it's a little unclear — I'd need to investigate too... regardless it sounds like that's not likely to be the root problem here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-29 14:36</div>
            <div class="timeline-body"><p>Yeah there are separate issues tracking general Git clone performance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-04-29 14:37</div>
            <div class="timeline-body"><p>I only left this open because I think there’s a possibly-interesting thing to try here where we fetch just the pyproject.toml to extract the metadata.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bschoenmaeckers">@bschoenmaeckers</a> on 2024-04-29 14:43</div>
            <div class="timeline-body"><p>I don't know if it is useful but there is something called <a href="https://git-scm.com/docs/git-sparse-checkout">sparse checkout</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samypr100">@samypr100</a> on 2024-05-01 23:02</div>
            <div class="timeline-body"><blockquote>
<p>I don't know if it is useful but there is something called <a href="https://git-scm.com/docs/git-sparse-checkout">sparse checkout</a>.</p>
</blockquote>
<p>Yes, you could use sparse checkout here effectively to speed things up quite substantially. Normally you'd do in the CLI in the following way:</p>
<ol>
<li>Clone the repo: <code>git clone --filter=blob:none --depth 1 --sparse git@github.com:functime-org/functime.git</code></li>
<li>Reapply a sparse filter to keep all the <code>pyproject.toml</code>'s inside the cloned repo: <code>git sparse-checkout set '**/pyproject.toml'</code></li>
</ol>
<p>Note the first <code>--sparse</code> is needed to keep the repo with only top-level content.
<code>--filter=blob:none</code> is still needed to keep blobs out (this is what pip does) and saves a decent amount of space.
<code>--depth=1</code> or shallow is still nice to keep as it saves a more space depending on the history size.</p>
<p>After that, you do <code>git sparse-checkout</code> to filter to keep only all the <code>pyproject.toml</code>'s in the repo (if any).</p>
<p>This recudes the clone size of functime down to
<code>Receiving objects: 100% (11/11), 15.56 KiB | 1.56 MiB/s, done.</code>
Then with the sparse checkout reduces the functime repo to virtually 3.4k since there's a single pyproject.toml.</p>
<p>I've been using a similar technique personally on very large repos at work in CI/CD for quite some time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-05-19 02:41</div>
            <div class="timeline-body"><p>I looked into this a bit and I think libgit2 doesn't support it (https://github.com/libgit2/libgit2/issues/5564).</p>
<p>I'm tempted to rethink our Git strategy a bit more holistically... Right now, we create a single copy of each repo, and then checkout commits by performing a sort of &quot;local&quot; clone into the build directory. I'm wondering if, instead, we should just have a separate clone for each commit, where that clone is a partial clone? It could in theory be less efficient if you're building from the same repo at multiple commits with overlapping blobs, but significantly faster when you're building from a single commit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-06-06 12:14</div>
            <div class="timeline-body"><p>You no longer use libgit2 anymore, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-06-06 12:19</div>
            <div class="timeline-body"><p>Correct.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-06-06 12:22</div>
            <div class="timeline-body"><p>I also don’t think that uv downloads a repo from VCS as part of resolution. If I’m right and every project downloaded from VCS is also built really all we need is probably #1737.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-06-06 12:43</div>
            <div class="timeline-body"><p>In brief, the way it works is that we have a single clone of each repo, and when we need to use a commit, we fetch it then create a <em>local</em> clone of that ref to build from. (But I don't believe it's blobless.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-06-06 12:53</div>
            <div class="timeline-body"><p>As said, this issue is about resolution, we should talk about building things in #1737.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/baggiponte">@baggiponte</a> on 2025-06-06 19:11</div>
            <div class="timeline-body"><p>Feel free to close in case you need it’s solved! :)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:24:47 UTC
    </footer>
</body>
</html>
