<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Build a wheel using pinned/resolved dependencies from `uv.lock`? - astral-sh/uv #8729</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Build a wheel using pinned/resolved dependencies from <code>uv.lock</code>?</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/8729">#8729</a>
        opened by <a href="https://github.com/rahuliyer95">@rahuliyer95</a>
        on 2024-10-31 16:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/rahuliyer95">@rahuliyer95</a></div>
            <div class="timeline-body"><p><em>(I believe this question has probably been asked before, but for some reason I am not able to find the previous issue so please feel free to direct me that issue if you are able to find it)</em></p>
<p>I am trying to build a wheel for my project, for which I simply ran</p>
<pre><code class="language-sh">$ uv build --wheel
</code></pre>
<p>Inspecting the wheel I noticed that it took the dependencies from <code>pyproject.toml</code>. Is there a way to use the pinned dependencies from the <code>uv.lock</code> file itself?</p>
<pre><code class="language-sh">$ unzip -p dist/playground-1.0.0-py3-none-any.whl playground-1.0.0.dist-info/METADATA
...
Requires-Dist: aiofiles ~=24.1
Requires-Dist: fsspec ~=2024.0
Requires-Dist: matplotlib ~=3.7
Requires-Dist: mpire[dill] ~=2.8
Requires-Dist: numpy ~=1.26
Requires-Dist: pandas ==1.5.3
Requires-Dist: pendulum ~=3.0
Requires-Dist: pyarrow ~=16.0
Requires-Dist: pyyaml ~=6.0
Requires-Dist: s3fs ~=2024.0
Requires-Dist: tqdm ~=4.0
Requires-Dist: universal-pathlib ~=0.2
Requires-Dist: uvloop ~=0.19
Requires-Dist: yarl ~=1.8
</code></pre>
<details>

<summary><code>pyproject.toml</code></summary>

<pre><code class="language-toml">[project]
name = &quot;playground&quot;
version = &quot;1.0.0&quot;
description = &quot;Playground&quot;
authors = [{ name = &quot;Rahul Iyer&quot;, email = &quot;me@rahuliyer.me&quot; }]
requires-python = &quot;&gt;=3.10&quot;
readme = &quot;README.md&quot;
dependencies = [
  &quot;aiofiles~=24.1&quot;,
  &quot;fsspec~=2024.0&quot;,
  &quot;matplotlib~=3.7&quot;,
  &quot;mpire[dill]~=2.8&quot;,
  &quot;numpy~=1.26&quot;,
  &quot;pandas==1.5.3&quot;,
  &quot;pendulum~=3.0&quot;,
  &quot;pyarrow~=16.0&quot;,
  &quot;pyyaml~=6.0&quot;,
  &quot;s3fs~=2024.0&quot;,
  &quot;tqdm~=4.0&quot;,
  &quot;universal-pathlib~=0.2&quot;,
  &quot;uvloop~=0.19&quot;,
  &quot;yarl~=1.8&quot;,
]

[tool.uv]
dev-dependencies = [
  &quot;mypy~=1.11&quot;,
  &quot;pandas-stubs~=1.5.3&quot;,
  &quot;ptpython~=3.0&quot;,
  &quot;pytest~=7.2&quot;,
  &quot;ruff~=0.4&quot;,
  &quot;types-aiofiles~=23.2&quot;,
  &quot;types-certifi~=2021.10&quot;,
  &quot;types-pyyaml~=6.0&quot;,
  &quot;types-tqdm~=4.0&quot;,
]

[tool.ruff]
exclude = [&quot;.venv&quot;]
line-length = 100
target-version = &quot;py310&quot;

[tool.ruff.format]
docstring-code-format = true
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-11-01 13:34</div>
            <div class="timeline-body"><p>I think we're somewhat unlikely to support this... The built wheel needs to use the declared project metadata, not the resolved application versions. It might also violate the spec in some sense.</p>
<p>What problem are you trying to solve? What are you looking to do with the wheel?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @charliermarsh on 2024-11-01 13:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rahuliyer95">@rahuliyer95</a> on 2024-11-01 16:33</div>
            <div class="timeline-body"><blockquote>
<p>What problem are you trying to solve?</p>
</blockquote>
<p>I'll try to explain without sharing too much internal details. Our setup for ETL jobs require us to install wheels from our internal PyPI installations (because of various limitations on support for alternatives like Docker images). When the ETL job starts the first thing it does is</p>
<pre><code class="language-sh">pip install --index &lt;internal-pypi-index-url&gt; &lt;package-name&gt;==&lt;package-version&gt;
# with above example
# pip install --index &lt;internal-pypi-index-url&gt; playground==1.0.0
</code></pre>
<p>With the above wheel it would end up resolving versions for dependencies when it's installing the wheel and it might install a different patch version than the one we tested with. To avoid this problem I was hoping that we can build the wheel from the pinned versions. Our existing setup uses <a href="https://python-poetry.org/">poetry</a> and we use the <a href="https://github.com/cloud-custodian/poetry-plugin-freeze">poetry-freeze-wheel</a> plugin to solve this problem.</p>
<blockquote>
<p>I think we're somewhat unlikely to support this... The built wheel needs to use the declared project metadata, not the resolved application versions. It might also violate the spec in some sense.</p>
</blockquote>
<p>I can totally understand the complexity of this very non-standard use-case. Unfortunately, I am not sure how many others want a behavior like this (through some CLI option maybe). I was trying to migrate from <code>poetry</code> to <code>uv</code> and this was the last blocker on the list.</p>
<p>@charliermarsh Please let me know if this explains the use-case and if any other details are needed from me. Thanks for all the amazing work you do!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-11-01 23:23</div>
            <div class="timeline-body"><p>I'd love to try to get some sort of <code>--locked</code> install concept into the standards, perhaps after we manage to standardize on a lock format.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/EternityForest">@EternityForest</a> on 2024-11-11 04:10</div>
            <div class="timeline-body"><p>This issue is also the blocker for me switching from Poetry.</p>
<p>Locked dependencies in wheels allow leaving Docker and the like out completely and making apps users can install with a single pipx command.</p>
<p>As I understand Poetry plugins do it by building the wheel, then modifying it after, so it doesn't seem like it's too hard to implement since it's basically just copying the data you already have in uv.lock, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/idan-rahamim-lendbuzz">@idan-rahamim-lendbuzz</a> on 2024-11-20 10:04</div>
            <div class="timeline-body"><p>Let me share an experience to illustrate why using pinned dependencies during the build process is crucial.</p>
<p>I maintain a package (CLI tool) called My Package, which lists aiodocker as a dependency in its pyproject.toml. The aiodocker package, in turn, specifies aiohttp with a version constraint of ^3.8 in its pyproject.toml. Since my package doesnâ€™t directly use aiohttp, itâ€™s not listed as a direct dependency.</p>
<p>In our GitHub Actions (GHA) workflows, my package is installed frequently from a private artifact. Each installation pulls the latest compatible version of aiohttp because itâ€™s a transitive dependency of aiodocker and satisfies the ^3.8 version constraint.</p>
<p>This week, a new version of aiohttp (3.11) introduced a breaking change that caused aiodocker to break. As a result, my packageâ€”despite no changes on my endâ€”broke because of this upstream issue.</p>
<p>Hereâ€™s the related issue for reference: <a href="https://github.com/aio-libs/aiodocker/issues/918">aio-libs/aiodocker#918</a>.</p>
<p>Currently i use poetry and they don't have a solution for that:
https://github.com/python-poetry/poetry/issues/2778</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/EternityForest">@EternityForest</a> on 2024-11-20 10:07</div>
            <div class="timeline-body"><p>@idan-rahamim-lendbuzz poetry does have third party plugins like https://github.com/cloud-custodian/poetry-plugin-freeze, but I'm not aware of a UV equivalent yet</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/idan-rahamim-lendbuzz">@idan-rahamim-lendbuzz</a> on 2024-11-20 10:12</div>
            <div class="timeline-body"><blockquote>
<p>@idan-rahamim-lendbuzz poetry does have third party plugins like https://github.com/cloud-custodian/poetry-plugin-freeze, but I'm not aware of a UV equivalent yet</p>
</blockquote>
<p>I can't use such plugins due to security reasons.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sadaisystems">@sadaisystems</a> on 2024-11-29 00:23</div>
            <div class="timeline-body"><p>I believe that this option would be interesting to ensure that the users get the same exact set of project dependencies that was used during the development process. Just to make sure that the experience is smooth.</p>
<p>As of now, my team uses <code>setup.py</code> in our old workflow with <code>install_requires</code> a frozen requirements.txt.</p>
<p>But the idea behind it is that we force our package to be installed with the set of dependencies that we now for sure are working.</p>
<p>Example of a bad scenario was illustrated by @rahuliyer95, and it is exactly what I'm talking about. Sometimes things just break with newer versions and it is hard to track those sometimes.</p>
<p>Though I believe that this not a best practice in general, but in corporate setting with some flows this is gold.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/snizovtsev">@snizovtsev</a> on 2024-12-20 15:32</div>
            <div class="timeline-body"><p>I found a way to work around this issue by using custom hatch plugin. The recipe has 3 ingredients:</p>
<ul>
<li>A requirement that refers to an environment variable that is expanded by Hatch during build:</li>
</ul>
<pre><code class="language-toml">[project]
dependencies = [
  &quot;hello-world == {env:UV_HELLO_WORLD_VERSION}&quot;,
]
</code></pre>
<ul>
<li>A build hook that adds the `uv.lock' file to the source distribution for use in the wheel builder:</li>
</ul>
<pre><code class="language-py">@cache
def find_workspace_root(cwd: Path | str) -&gt; Path | None:
   cwd = Path(cwd)
   if cwd == Path(cwd.root) or cwd == cwd.parent:
       return None
   elif (cwd / &quot;uv.lock&quot;).exists():
       return cwd
   return find_workspace_root(cwd.parent)


class MyBuildHook(BuildHookInterface[BuilderConfig]):
   PLUGIN_NAME = &quot;my-hook&quot;

   @override
   def initialize(self, version: str, build_data: dict[str, Any]) -&gt; None:
       if self.target_name == &quot;sdist&quot;:
           workspace_root = find_workspace_root(self.root) or self.root
           uv_lock_path = os.path.join(workspace_root, &quot;uv.lock&quot;)
           build_data[&quot;force_include&quot;][uv_lock_path] = &quot;uv.lock&quot;
</code></pre>
<ul>
<li>And finally a metadata hook that would set environment variables from the contents of <code>uv.lock</code> before interpolation happens:</li>
</ul>
<pre><code class="language-python">def load_uv_lock(root: Path | str):
    uv_lock_path = Path(root) / &quot;uv.lock&quot;
    try:
        with uv_lock_path.open(&quot;rb&quot;) as fp:
            return tomllib.load(fp)
    except:
        log.warning(&quot;Cannot load uv.lock&quot;, exc_info=True)
        return {}

class MyMetadataHook(MetadataHookInterface):
    PLUGIN_NAME = &quot;my-hook&quot;

    def update(self, metadata: dict[str, Any]) -&gt; None:
        uv_workspace_root = find_workspace_root(self.root) or self.root
        uv_lock = load_uv_lock(uv_workspace_root)
        uv_members = uv_lock.get(&quot;manifest&quot;, {}).get(&quot;members&quot;, [])
        uv_packages = uv_lock.get(&quot;package&quot;, [])
        uv_dist_packages = dict({
            p[&quot;name&quot;]: p for p in uv_packages if p[&quot;name&quot;] in uv_members
        })

        # Export environment variables with local package versions
        for name, package in uv_dist_packages.items():
            norm_name = re.sub(r&quot;[-_.]+&quot;, &quot;_&quot;, name).upper()
            version = package[&quot;version&quot;]
            var = f&quot;UV_{norm_name}_VERSION&quot;
            print(f&quot;{var}={version}&quot;)
            os.environ[var] = version
</code></pre>
<ul>
<li>To force the metadata hook to run, you may also need to add an additional dynamic field:</li>
</ul>
<pre><code class="language-toml">[project]
dynamic = [&quot;version&quot;, &quot;x-run-hook&quot;]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/edgarrmondragon">@edgarrmondragon</a> on 2025-01-18 01:43</div>
            <div class="timeline-body"><p>Perhaps something like this Poetry PoC PR could work:</p>
<ul>
<li>https://github.com/python-poetry/poetry/pull/9428</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kwaegel">@kwaegel</a> on 2025-02-12 19:10</div>
            <div class="timeline-body"><p>@edgarrmondragon I think I figured out a bash equivalent for that Poetry PoC, which adds a <code>pinned</code> dependency group, builds the package, then reverts the change. There's probably some way to write this as a <code>hatchling</code> plugin.</p>
<pre><code>#!/bin/bash
set -euo pipefail

# For safety, only run this with a clean working directory.
uv lock --check
if [ -n &quot;$(git status --porcelain)&quot; ]; then
    echo &quot;Working directory not clean.&quot;
    exit 1
fi

cp pyproject.toml pyproject.toml.bak
cp uv.lock uv.lock.bak

# Export all non-development dependency versions from uv.lock.
uv export --locked --no-dev --no-extra pinned --no-hashes --no-emit-workspace \
    --output-file pinned_requirements.txt &gt; /dev/null

# Add an optional 'pinned' group that contains the pinned dependency list.
uv add --optional pinned -r pinned_requirements.txt

# Build the package.
uv build

# Restore the original project state.
mv pyproject.toml.bak pyproject.toml
mv uv.lock.bak uv.lock
rm -f pinned_requirements.txt
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/edgarrmondragon">@edgarrmondragon</a> on 2025-02-12 20:03</div>
            <div class="timeline-body"><blockquote>
<p>There's probably some way to write this as a <code>hatchling</code> plugin.</p>
</blockquote>
<p>@kwaegel let me know what you think of https://github.com/edgarrmondragon/hatch-pinned-extra ðŸ™‚</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kwaegel">@kwaegel</a> on 2025-02-13 00:21</div>
            <div class="timeline-body"><p>Cool! That mostly seems to work, but it's giving me very slightly different results from the script-based version. I'll try to file a ticket once I figure out what's going on, but in general it seems like a better solution.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/timvink">@timvink</a> on 2025-02-15 13:04</div>
            <div class="timeline-body"><p>+1 for this.</p>
<p>My use case for something like <code>uv build --wheel --pinned</code> is databricks asset bundles, where you can include a wheel to go along with a job definition. I need exact, reproducible environments to train ML models. Of course there are workarounds, but this feature would be cleanest.</p>
<p>For reference, I would use it like this:</p>
<pre><code class="language-yaml"># databricks.yml
artifacts:
  python_package:
    type: wheel
    build: uv build --wheel --pinned
    path: .
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/EternityForest">@EternityForest</a> on 2025-02-27 02:06</div>
            <div class="timeline-body"><p>@timvink I think I'd prefer it be a setting in pyproject.toml, I can't imagine any time I would ever want to build a non-frozen wheel for a completed application, and by adding it to the metadata, unmodified build and publish commands could do the right thing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-27 09:27</div>
            <div class="timeline-body"><p>Since it hasn't been mentioned before, I want to share this workaround: You can <code>uv export</code> the lockfile and use it as constraint on installation of the wheel, e.g.</p>
<pre><code>uv export --no-emit-workspace --no-hashes -o requirements-frozen.txt
uv build
pip install -c requirements-frozen.txt dist/foo-0.1.0-py3-none-any.whl 
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dobatymo">@Dobatymo</a> on 2025-04-09 03:45</div>
            <div class="timeline-body"><p>I would also like to replace a <code>poetry-plugin-freeze</code> based workflow with <code>uv</code>. I would like to export a wheel file which uses exactly the same versions for the dependencies as the tests.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gsemet">@gsemet</a> on 2025-07-02 10:45</div>
            <div class="timeline-body"><p>So for my little story today.</p>
<p>At 11am30 this morning, <code>uv tool install mysoftware</code> worked great</p>
<p>At 11am31 it did not anymore, because someone has published on pypi a new version of its software that lifted a restriction on a another dependency, leading to an incompatibility. semver not carefully followed by anyone.</p>
<p>What i want is to be able to create 2 wheels.</p>
<pre><code class="language-hash">$ uv build mysoftware --pinned
this is my main CLI, mainly usable by `uv tool install`

$ uv build mysoftware[api]
the API version of the cli, without any frozen dependencies, used with `uv add`
</code></pre>
<p>Basically the reverse of hatch-pinned-extra</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:28:04 UTC
    </footer>
</body>
</html>
