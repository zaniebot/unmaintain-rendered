```yaml
number: 11151
title: "No solution found when resolving dependencies for split (platform_python_implementation == 'PyPy')"
type: issue
state: open
author: kdebrab
labels:
  - bug
assignees: []
created_at: 2025-02-01T11:04:48Z
updated_at: 2025-02-03T15:46:27Z
url: https://github.com/astral-sh/uv/issues/11151
synced_at: 2026-01-10T01:57:25Z
```

# No solution found when resolving dependencies for split (platform_python_implementation == 'PyPy')

---

_Issue opened by @kdebrab on 2025-02-01 11:04_

### Summary

The error 'No solution found when resolving dependencies for split (platform_python_implementation == 'PyPy')' is raised even though the marker `platform_python_implementation != 'PyPy'` is used.

### Minimal Reproducible Example

Following resolution failure *looks* like a bug to me:

Running `uv lock` (or `uv sync` or even `uv run python`) with following pyproject.toml:
```toml
[project]
name = "pythonproject"
version = "0.1.0"
requires-python = "==3.12.*"
dependencies = ["urllib3==2.3.0"]
optional-dependencies.test = [
"vcrpy==7.0.0 ; platform_python_implementation != 'PyPy'",
]
```
yields:
```
  x No solution found when resolving dependencies for split (platform_python_implementation == 'PyPy'):
  `-> Because only the following versions of urllib3{platform_python_implementation == 'PyPy'} are available:
          urllib3{platform_python_implementation == 'PyPy'}==0.3
          urllib3{platform_python_implementation == 'PyPy'}==1.0
          urllib3{platform_python_implementation == 'PyPy'}==1.0.1
          [...]
          urllib3{platform_python_implementation == 'PyPy'}==1.26.20
          urllib3{platform_python_implementation == 'PyPy'}>2
      and urllib3{platform_python_implementation == 'PyPy'}>=1.25,<=1.25.1 was yanked (reason: Broken release), we can conclude that urllib3{platform_python_implementation ==      
      'PyPy'}>=1.25,<=1.25.1 depends on urllib3<=1.24.3.
      And because vcrpy==7.0.0 depends on urllib3{platform_python_implementation == 'PyPy'}<2 and pythonproject[test] depends on vcrpy{platform_python_implementation !=
      'PyPy'}==7.0.0, we can conclude that pythonproject[test] depends on one of:
          urllib3<=1.24.3
          urllib3>=1.25.2,<=1.26.20

      And because your project depends on urllib3==2.3.0 and your project requires pythonproject[test], we can conclude that your project's requirements are unsatisfiable.
```
Note that especially `And because vcrpy==7.0.0 depends on urllib3{platform_python_implementation == 'PyPy'}<2 and pythonproject[test] depends on vcrpy{platform_python_implementation != 'PyPy'}==7.0.0` seems a conflicting statement.

### Platform

Windows 11

### Version

uv 0.5.26 (5ef3d5139 2025-01-30)

### Python version

Python 3.12.8

---

_Label `bug` added by @kdebrab on 2025-02-01 11:04_

---

_Comment by @charliermarsh on 2025-02-01 19:04_

Try adding:

```toml
[tool.uv]
environments = ["platform_python_implementation != 'PyPy'"]
```

---

_Comment by @kdebrab on 2025-02-03 09:16_

Thanks, that works for me!

However, I have the feeling that this is merely a work-around. E.g., it wouldn't be a solution if one would really want to target PyPy for the application (excluding `vcrpy`).

I would expect that if a marker excludes a certain dependency for a certain implementation, that that would propagate to its dependencies. In particular, `vcrpy{platform_python_implementation != 'PyPy'}==7.0.0` should never depend on `urllib3{platform_python_implementation == 'PyPy'}<2`

---

_Comment by @charliermarsh on 2025-02-03 15:46_

Yes it's a limitation in the resolver. If you had two dependencies, like:

```toml
[project]
name = "pythonproject"
version = "0.1.0"
requires-python = "==3.12.*"
dependencies = ["urllib3==2.3.0"]
optional-dependencies.test = [
    "vcrpy==7.0.0 ; platform_python_implementation != 'PyPy'",
    "vcrpy==6.0.0 ; platform_python_implementation == 'PyPy'",
]
```

Then we would correctly "fork" the resolution and solve for both marker values. But if there's only one value, we attempt to solve without "forking", since it's much more expensive to "fork" for every marker value that we see at any time during resolution. We've considered doing that kind of "aggressive" forking by default, but have deferred it.

---
