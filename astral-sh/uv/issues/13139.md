```yaml
number: 13139
title: Deterministically normalize wheel ZIP metadata
type: issue
state: open
author: tabbyrobin
labels:
  - enhancement
  - needs-decision
assignees: []
created_at: 2025-04-27T22:06:17Z
updated_at: 2025-05-04T20:50:27Z
url: https://github.com/astral-sh/uv/issues/13139
synced_at: 2026-01-10T01:57:30Z
```

# Deterministically normalize wheel ZIP metadata

---

_Issue opened by @tabbyrobin on 2025-04-27 22:06_

### Summary

So as to enable reproducible builds, it would be nice if the uv build frontend could deterministically normalize the ZIP metadata in wheels it outputs.

It would be ideal if this was either done by default, or easily enabled with a simple option (for example, `--deterministic` or similar).

Sources of nondeterminism in ZIP metadata include:

- Timestamps -- There may be some desirable interaction with `SOURCE_DATE_EPOCH`, if set (for example, auditwheel already does so). However, it would *also* be helpful to normalize the timestamps even if  `SOURCE_DATE_EPOCH` is not set.
- File permissions and ownership
- Ordering of ZIP entries. -- _This generally seems to already be effectively deterministic, at least with the handful of experiments I've run. I'm not sure what nondeterminism might exist depending on OS, OS variants, Python build backends, etc._
- Potentially other things

While this issue could conceivably be filed against the uv build backend, here I am intending to file it against the frontend. The idea is that a solution in the build frontend could serve as a blanket solution in a centralized tool, improving wheel reproducibility throughout the Python ecosystem. 

See also: 

- https://github.com/pyca/cryptography/issues/12811
- https://github.com/pypa/auditwheel/issues/578
- https://github.com/pypa/cibuildwheel/issues/2344

Related uv-internal issues: 

- https://github.com/astral-sh/uv/issues/10523
- https://github.com/astral-sh/uv/issues/7066

### Example

_No response_

---

_Label `enhancement` added by @tabbyrobin on 2025-04-27 22:06_

---

_Label `needs-decision` added by @konstin on 2025-04-28 08:50_

---

_Assigned to @konstin by @konstin on 2025-04-28 08:50_

---

_Unassigned @konstin by @konstin on 2025-04-28 08:50_

---

_Comment by @tabbyrobin on 2025-05-04 05:51_

I have put together some notes about deterministic Python wheels:
https://github.com/tabbyrobin/expt-repro-python-wheels/blob/main/notes-on-wheel-determinism.md

And I started a thread about the subject here, to hopefully spark discussion with various projects/the wider Python community:
https://discuss.python.org/t/best-practices-for-deterministically-normalizing-wheel-zip-metadata/90662


---

_Comment by @konstin on 2025-05-04 20:50_

With the way PEP 517 is setup, I'm not sure it falls into the scope of the uv frontend to rewrite artifacts. It's made more difficult as reproducible builds require the whole stack to support them. If there are parts in build backend or in tools used by the build backend that depend on external variables (such as the https://github.com/rust-lang/rust/issues/111540 discussed in the other thread, where the underlying compiler is the problem), the frontend has only very limited options to recover. uv generally prefers using wheel over source dists where possible, and a number of projects without wheels lacks because they need to build against the current environment (either other python packages or the system libraries).

I can however share what we did in the uv build backend to make source dist and wheel builds reproducible, or where this falls short in cross-platform situations (https://github.com/astral-sh/uv/pull/13171):

* All configuration is below the project root, configuration outside the project root can't affect archive contents.
* We set `SOURCE_DATE_EPOCH` to 0. (0 because it's easy for someone looking at the file to see that it's a dummy value).
* We use sorted file traversal to get the same order of files in zip.
* We don't preserve file permissions. The exception is the executable bit, which means that builds aren't reproducible between Unix and Windows if the repository contains a file with the executable bit
* Similarly, platform-specific file system features such as symlinks and junctions are treatly differently by Git depending on the platform, and with a different repository checkout on disk, there are different artifacts.
* The inclusion/exclusion system is designed to have the same output for source tree -> source dist -> wheel and source tree -> wheel, and we test both paths.

In maturin, we had some pull requests improving support for reproducible build that might interest you: https://github.com/PyO3/maturin/issues/1320, https://github.com/PyO3/maturin/pull/2261, https://github.com/PyO3/maturin/pull/2550

---
