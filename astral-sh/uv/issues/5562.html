<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>audit universal resolver's robustness with respect to false positives/negatives with routines like &quot;are these two marker expressions disjoint&quot; - astral-sh/uv #5562</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>audit universal resolver&#x27;s robustness with respect to false positives/negatives with routines like &quot;are these two marker expressions disjoint&quot;</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/5562">#5562</a>
        opened by <a href="https://github.com/BurntSushi">@BurntSushi</a>
        on 2024-07-29 14:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a></div>
            <div class="timeline-body"><p>Right now, the universal resolver relies on an internal routine, <code>marker::is_disjoint</code>, to report whether two marker expressions could <em>ever</em> evaluate to <code>true</code> for the same marker environment. If they can&#x27;t, then they are considered disjoint.</p>
<p>At present, we use this to determine whether to create forks between conflicting dependency specifications. For example:</p>
<pre><code>a==1.0.0 ; sys_platform == &#x27;linux&#x27;
a==2.0.0 ; sys_platform == &#x27;windows&#x27;
</code></pre>
<p>It is indeed the case that <code>sys_platform == &#x27;linux&#x27;</code> and <code>sys_platform == &#x27;windows&#x27;</code> can literally never be active for the same marker environment, and thus they are considered disjoint. This in turn &quot;allows&quot; the universal resolver to fork. (Although we are very likely going to need to allow forks even in cases of non-disjointness, as explored in #4732.)</p>
<p>But, we do use disjointness checking elsewhere. For example, when creating a fork inside the resolver, we remove any dependencies whose marker expressions are disjoint with that fork&#x27;s marker expression. This is because those dependencies can never appear in environments that use that fork. But if disjointness checking is wrong, then this could lead to incorrect results.</p>
<p>What is known is that our disjointness checking <em>is</em> wrong today. Specifically, I believe perfect disjointness checking is NP-complete. So right now, we only use heuristics. What is not quite known is whether its &quot;wrongness&quot; is limited to only false positives, limited to only false negatives, or is both. Moreover, I do not believe the callers of disjointness checking have been audited from what they are robust to. Sometimes false negatives are okay in the sense that they might just lead to not being able to produce a resolution, for example.</p>
<p>This is also somewhat shifting as mentioned via #4732, and also the work that @ibraheemdev is doing based on marker normalization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-07-29 14:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2024-07-29 20:43</div>
            <div class="timeline-body"><p>I believe we are going to end up in a place where marker satisfiability can have false positives but never false negatives, i.e. we might think a marker tree is satisfiable when it is actually not, but we never claim a marker tree is not satisfiable when it actually is. This is mostly due to the <code>in</code> operator on strings which can have interactions that are difficult to model (for example, <code>key &gt; &#x27;z&#x27; and key in &#x27;linux&#x27;</code> is not satisfiable, but that is not easy to see), but there may be other places this is possible that we have not accounted for yet so it probably a good idea to remain pessimistic.</p>
<p>Similarly, the disjointness of two markers is equivalent to asking whether their conjunction is not satisfiable, so we should account for false negatives but not false positives. i.e. it is possible that we think two markers are not disjoint when they actually are (such as <code>key &gt; &#x27;z&#x27;</code> and <code>key in &#x27;linux&#x27;</code>), but we should never claim that two markers are disjoint when there is a potential intersection.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-08-16 17:29</div>
            <div class="timeline-body"><p>I think we&#x27;re all set here with @ibraheemdev&#x27;s work in #5898.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2024-08-16 17:29</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:32:19 UTC
    </footer>
</body>
</html>
