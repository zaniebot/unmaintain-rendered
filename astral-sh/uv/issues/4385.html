<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running uv in an interactive docker container - astral-sh/uv #4385</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Running uv in an interactive docker container</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/4385">#4385</a>
        opened by <a href="https://github.com/braaannigan">@braaannigan</a>
        on 2024-06-18 15:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/braaannigan">@braaannigan</a></div>
            <div class="timeline-body"><p>Thanks for this great crate! I've been working with a recent version and trying to capture my best practices here: https://www.rhosignal.com/posts/uv-in-docker/</p>
<p>I want to highlight some issues with the more recent versions of uv when working in interactive mode in docker. The issues arise because of the way a virtual env is now required. I want to use the following dockerfile approach (as opposed to a curl installation) as it has better caching:</p>
<pre><code class="language-dockerfile">FROM ghcr.io/astral-sh/uv:0.2.12 as uv
# Choose python version here
FROM python:3.10.1-slim-buster
# Create a virtual environment with uv inside the container
RUN --mount=from=uv,source=/uv,target=./uv \
    ./uv venv /opt/venv
# We need to set this environment variable so that uv knows where
# the virtual environment is to install packages
ENV VIRTUAL_ENV=/opt/venv
# Copy the requirements file into the container
COPY requirements.txt .
# Install the packages with uv using --mount=type=cache to cache the downloaded packages
RUN --mount=type=cache,target=/root/.cache/uv \
    --mount=from=uv,source=/uv,target=./uv \
    ./uv pip install  -r requirements.txt
</code></pre>
<p>This works fine for building the image. The problem is when I want to develop in interactive mode in the container (which is my whole day basically).</p>
<ul>
<li>The first issue is that when you run the container you need to activate the virtual env every time (which is manageable but less convenient than before)</li>
<li>The second is that if I want to try out additional package installs while running in interactive mode I have neither uv nor pip available! uv isn't available because it's just a docker build layer and pip is not in the virtual env. The options here are to install pip into the virtual env or to manually install uv from curl when runnng interactively.</li>
</ul>
<p>Have I missed any other possible solutions for dealing with these issues?</p>
<p>Thanks again</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-06-18 15:19</div>
            <div class="timeline-body"><p>Thanks for sharing!</p>
<blockquote>
<p>The first issue is that when you run the container you need to activate the virtual env every time</p>
</blockquote>
<p>You could add the virtual environment's <code>bin</code> to the <code>PATH</code> then you shouldn't need to do any activation.</p>
<p>You can also use <code>--system</code> and just skip the virtual environment entirely.</p>
<blockquote>
<p>The second is that if I want to try out additional package installs while running in interactive mode I have neither uv nor pip available! uv isn't available because it's just a docker build layer and pip is not in the virtual env. The options here are to install pip into the virtual env or to manually install uv from curl when runnng interactively.</p>
</blockquote>
<p>Sounds about right. I'd opt to just keep uv around, but the alternative is to run <code>uv venv</code> with <code>--seed</code> to install <code>pip</code> or install <code>pip</code> manually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @zanieb on 2024-06-18 15:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hoechenberger">@hoechenberger</a> on 2024-06-18 18:31</div>
            <div class="timeline-body"><blockquote>
<p>You can also use --system and just skip the virtual environment entirely.</p>
</blockquote>
<p>FWIW this is what I'm doing and it works flawlessly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/braaannigan">@braaannigan</a> on 2024-06-20 10:15</div>
            <div class="timeline-body"><p>@zanieb  @hoechenberger
I've done the add-venv-to-path approach: https://www.rhosignal.com/posts/uv-in-docker/</p>
<p>Any feeling for whether there is a preference for this over the --system approach?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hoechenberger">@hoechenberger</a> on 2024-06-20 10:23</div>
            <div class="timeline-body"><p>@braaannigan In my dev containers I try to keep complexity low, and I feel like setting up a venv adds another layer of complexity. I therefore set the <code>UV_SYSTEM_PYTHON</code> env var and install things globally. No need for a venv in an isolated environment like a dev container. I can share a sample dev container config with you if you're interested!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-06-20 13:18</div>
            <div class="timeline-body"><p>I think both approaches are totally reasonable. We see a &quot;add venv to path&quot; approach more often when you don't have write access to the system.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-06-21 00:29</div>
            <div class="timeline-body"><p>I'm adding some documentation based on this discussion #4433</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kennycontreras">@kennycontreras</a> on 2024-07-12 15:45</div>
            <div class="timeline-body"><blockquote>
<p>@braaannigan I can share a sample dev container config with you if you're interested!</p>
</blockquote>
<p>Could you please share the container configuration? That would be really helpful. Thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @zanieb on 2024-08-19 17:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/braaannigan">@braaannigan</a> on 2024-08-20 08:25</div>
            <div class="timeline-body"><blockquote>
<p>@braaannigan In my dev containers I try to keep complexity low, and I feel like setting up a venv adds another layer of complexity. I therefore set the <code>UV_SYSTEM_PYTHON</code> env var and install things globally. No need for a venv in an isolated environment like a dev container. I can share a sample dev container config with you if you're interested!</p>
</blockquote>
<p>I'd like to see this as well</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hoechenberger">@hoechenberger</a> on 2024-08-21 06:16</div>
            <div class="timeline-body"><p>Hello, sorry for not getting back to you, this entirely slipped my mind. Can you please ping me again if you don't hear back from me by the end of this week? Best wishes</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:25:18 UTC
    </footer>
</body>
</html>
