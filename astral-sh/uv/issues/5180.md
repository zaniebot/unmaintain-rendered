```yaml
number: 5180
title: "Instability with preferences and forks: Lockfile changes on the second run"
type: issue
state: closed
author: konstin
labels:
  - bug
  - preview
assignees: []
created_at: 2024-07-18T09:50:16Z
updated_at: 2025-01-02T13:18:40Z
url: https://github.com/astral-sh/uv/issues/5180
synced_at: 2026-01-10T01:57:11Z
```

# Instability with preferences and forks: Lockfile changes on the second run

---

_Issue opened by @konstin on 2024-07-18 09:50_

The lockfile can change on the second `uv lock`, collapsing previously forking dependencies into a single one. I believe this due to how preferences are handled.

Minimal example:

```
[project]
name = "transformers"
version = "4.39.0.dev0"
requires-python = ">=3.9.0"
dependencies = [
  "datasets",
  "librosa",
  "onnxruntime",
]
```

```
$ rm -f uv.lock && cargo run -q lock --preview && wc -l uv.lock && cargo run -q lock --preview && wc -l uv.lock && cargo run -q lock --preview && wc -l uv.lock
Resolved 60 packages in 169ms
1462 uv.lock
Resolved 58 packages in 33ms
1375 uv.lock
Resolved 58 packages in 28ms
1375 uv.lock
```

We have 3 different forkings until it converges:

```
$ rm -f uv.lock && cargo run -q lock --preview -v 2>&1 | rg -i split
DEBUG Adding split to cover possibly incomplete markers: python_version >= '3.11' and python_version != '3.11' and python_version < '3.12'
DEBUG Splitting resolution on pandas==2.2.2 over numpy
DEBUG Pre-fork split universal took 0.007s
DEBUG Solving split python_version >= '3.12' (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version >= '3.12') resolution took 0.003s
DEBUG Solving split python_version == '3.11' (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version == '3.11') resolution took 0.001s
DEBUG Solving split python_version < '3.11' (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version < '3.11') resolution took 0.001s
DEBUG Solving split python_version < '3.12' and python_version >= '3.11' and (python_version < '3.11' or python_version > '3.11') (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version < '3.12' and python_version >= '3.11' and (python_version < '3.11' or python_version > '3.11')) resolution took 0.002s
$ cargo run -q lock --preview -v 2>&1 | rg -i split
DEBUG Adding split to cover possibly incomplete markers: python_version > '3.11' and python_version < '3.12'
DEBUG Splitting resolution on pandas==2.2.2 over numpy
DEBUG Pre-fork split universal took 0.001s
DEBUG Solving split python_version >= '3.12' (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version >= '3.12') resolution took 0.001s
DEBUG Solving split python_version <= '3.11' (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version <= '3.11') resolution took 0.001s
DEBUG Solving split python_version < '3.12' and python_version > '3.11' (requires-python: python_version >= '3.9' and python_full_version >= '3.9.0')
DEBUG Split (python_version < '3.12' and python_version > '3.11') resolution took 0.001s
$ cargo run -q lock --preview -v 2>&1 | rg -i split
DEBUG Split universal resolution took 0.002s
$ cargo run -q lock --preview -v 2>&1 | rg -i split
DEBUG Split universal resolution took 0.002s
```

I think we need #4926 (to not create duplicate dependencies in the first run) and we need to marker- or fork-tag preferences if that heuristic fails.

---

_Label `bug` added by @konstin on 2024-07-18 09:50_

---

_Label `preview` added by @konstin on 2024-07-18 09:50_

---

_Assigned to @konstin by @konstin on 2024-07-24 11:30_

---

_Comment by @konstin on 2024-07-24 11:42_

A detailed write-up on the problem can be found in https://github.com/astral-sh/packse/pull/203.

My plan to solve this is to:
- [x] Merge forks with identical resolutions so we have as few forks as possible in the end
- [x] Solve https://github.com/astral-sh/uv/issues/4926 as a follow-up so we have diverging forks less often
- [x] When we still have diverging versions, preserve the fork markers from the resolution and for packages with diverging versions in the lockfile
- [x] When resolving from an existing lockfile, start already forked into the forks from the lockfile
- [x] Change the preferences so that we only use those applicable to the current fork. When we use the preserved forks, this will be a 1-to-1 mapping, what we do otherwise TBD
- [x] Add https://github.com/astral-sh/packse/pull/203 to the test suite


---

_Referenced in [astral-sh/uv#5479](../../astral-sh/uv/pulls/5479.md) on 2024-07-26 13:05_

---

_Referenced in [astral-sh/uv#5480](../../astral-sh/uv/pulls/5480.md) on 2024-07-26 13:15_

---

_Referenced in [astral-sh/uv#5481](../../astral-sh/uv/pulls/5481.md) on 2024-07-26 13:18_

---

_Comment by @konstin on 2024-07-26 13:48_

Background reading: https://github.com/astral-sh/packse/pull/203

The root problem is that preferences can influence which fork points we get and thereby which forks we have in the eventual merge resolution.

In the worst case we could have a bistable system that flip-flops for every `uv lock` invocation: We start with preference I for lockfile I. These contain `foo==1`, and starting with `foo==1` causes us to fork on `python_version`. The two `python_version` forks both end up rejecting `foo==1` and we write lockfile II with `foo==2`. In the next `uv lock` invocation, we read preferences II from lockfile II with `foo==2`. Starting with `foo==2` causes us to fork on `sys_platform` instead. With those forks, we end up rejecting `foo==2` and write lockfile I with `foo==1` instead; we're back in the other state, switching on every `uv lock`.

The solution is to lock store the forks in the lockfile and to start the resolution with the locked forks. For simplicity and to make it easier to understand for users why there are multiple versions per package in their lockfile, for each package with multiple versions, we write write the forks a version belongs to next to the fork. When we resolve, in each fork, we will find exactly one matching preference, the one that is the result in the fork in the previous resolution. This way, we get a stable resolution.

We need to both start the resolution with the locked forks, because we may not see the same fork points again with preferences that skip over them (diverging or not), and have per-fork preferences to ensure that in each fork, we're doing the same resolution as before

---

_Renamed from "Lockfile changes on the second run" to "Instability with preferences and forks: Lockfile changes on the second run" by @konstin on 2024-07-26 15:31_

---

_Referenced in [astral-sh/uv#5441](../../astral-sh/uv/pulls/5441.md) on 2024-07-26 15:38_

---

_Referenced in [astral-sh/uv#5485](../../astral-sh/uv/pulls/5485.md) on 2024-07-26 15:54_

---

_Closed by @konstin on 2024-07-31 15:39_

---

_Closed by @konstin on 2024-07-31 15:39_

---
