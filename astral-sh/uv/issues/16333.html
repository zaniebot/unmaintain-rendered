<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Specify Python Version Resolution Rules - astral-sh/uv #16333</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Specify Python Version Resolution Rules</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/16333">#16333</a>
        opened by <a href="https://github.com/powercoconola">@powercoconola</a>
        on 2025-10-17 00:24
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/powercoconola">@powercoconola</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>When using commands like <code>uv tool install</code> or <code>uv run</code>, we should be able to specify that we want to use the lowest major Python version as specified in the <code>pyproject.toml</code>.</p>
<p>Similar to the existing <code>--resolution</code> flag and <code>UV_RESOLUTION</code> environment variable, we should add:</p>
<ul>
<li><code>--python-resolution</code> flag</li>
<li><code>UV_PYTHON_RESOLUTION</code> environment variable</li>
<li>two possible values for this flag and environment variable: <code>lowest</code> and <code>highest</code></li>
</ul>
<p>The reason for implementing this feature is similar as the reason for the <code>--resolution</code> flag from the docs:</p>
<blockquote>
<p>When publishing libraries, it is recommended to separately run tests with --resolution lowest or --resolution lowest-direct in continuous integration to ensure compatibility with the declared lower bounds.</p>
</blockquote>
<h3>Example</h3>
<p>If the <code>pyproject.toml</code> of the tool has:</p>
<pre><code class="language-pyproject.toml">[project]
requires-python = &quot;&gt;=3.12&quot;
</code></pre>
<p>Currently, <code>uv tool install &lt;tool&gt;</code> tries to use the latest available Python version (currently 3.14.0).</p>
<p>If we do <code>uv tool install &lt;tool&gt; --python-resolution lowest</code>, uv would use the latest patch version of Python 3.12. (I don't see a use-case to go to the lowest patch version)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @powercoconola on 2025-10-17 00:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-10-17 08:28</div>
            <div class="timeline-body"><p>In the resolver algorithm, the Python version influences the selected package version: If you do <code>uv tool install foo -p 3.11</code> and the latest version has <code>requires-python = &quot;&gt;=3.12&quot;</code>, we select a previous versions instead.</p>
<p>Is your use case testing in CI? For that, we recommend pinning the earliest and latest Python versions you want to test manually.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/powercoconola">@powercoconola</a> on 2025-10-17 20:19</div>
            <div class="timeline-body"><blockquote>
<p>In the resolver algorithm, the Python version influences the selected package version: If you do uv tool install foo -p 3.11 and the latest version has requires-python = &quot;&gt;=3.12&quot;, we select a previous versions instead.</p>
</blockquote>
<p>I see, then we would have to specify the version of the selected package, right? <code>uv tool install foo@latest --python-resolution lowest</code>. This way the user doesn't need to know what the <code>requires-python</code> field is because uv can figure that part out. An alternative would be: Do you know an easy way for an end-user to figure out what a package's <code>requires-python</code> value is beforehand to do it manually?</p>
<blockquote>
<p>pinning the earliest and latest Python versions you want to test manually.</p>
</blockquote>
<p>For automation's sake this would be and is tedious to do when working with many packages.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/powercoconola">@powercoconola</a> on 2025-10-17 20:29</div>
            <div class="timeline-body"><blockquote>
<p>Is your use case testing in CI?</p>
</blockquote>
<p>My usecase is that I want to install the latest version of many tools (&gt;100) and test them all at their earliest major Python <code>requires-python</code> version to validate everything is working correctly in production. The difficulty is resolving what that earliest major Python version is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-10-19 09:29</div>
            <div class="timeline-body"><p>I don't think you can do this with uv, the easiest here is a small Python script that parse out <code>requires-python</code> from <code>pyproject.toml</code> and install that version.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drammock">@drammock</a> on 2025-12-19 15:59</div>
            <div class="timeline-body"><p>Strong agree that this would be a very useful feature. It was very surprising to me that, given this <code>pyproject.toml</code> file:</p>
<pre><code class="language-toml">[build-system]
build-backend = &quot;hatchling.build&quot;
requires = [&quot;hatchling&quot;]

[project]
name = &quot;foobar&quot;
dependencies = [
  &quot;numpy &gt;= 2.0&quot;
]
version = &quot;0.1.0&quot;
requires-python = &quot;&gt;= 3.10&quot;  # ‚Üê this isn't carried through to the resulting lockfile
</code></pre>
<p>...the command:</p>
<pre><code class="language-sh">uv pip compile pyproject.toml --resolution lowest-direct --output-file pylock.toml
</code></pre>
<p>results in a lockfile specifying Python &gt;= 3.13.1 (the version that happened to be first on my path when <code>uv pip compile ...</code> was run):</p>
<pre><code class="language-toml"># This file was autogenerated by uv via the following command:
#    uv pip compile pyproject.toml --resolution lowest-direct --output-file pylock.toml
lock-version = &quot;1.0&quot;
created-by = &quot;uv&quot;
requires-python = &quot;&gt;=3.13.1&quot;

[[packages]]
name = &quot;numpy&quot;
version = &quot;2.0.0&quot;
sdist = { url = &quot;https://files.pythonhosted.org/packages/05/35/fb1ada118002df3fe91b5c3b28bc0d90f879b881a5d8f68b1f9b79c44bfe/numpy-2.0.0.tar.gz&quot;, upload-time = 2024-06-16T13:24:44Z, size = 18326228, hashes = { sha256 = &quot;cf5d1c9e6837f8af9f92b6bd3e86d513cdc11f60fd62185cc49ec7d1aba34864&quot; } }
</code></pre>
<p>Personally I think <code>--resolution lowest(-direct)</code> should affect <em>both</em> python version and package version, but I'd settle for a separate flag/envvar to control Python resolution strategy.</p>
<p>This advice:</p>
<blockquote>
<p>Is your use case testing in CI? For that, we recommend pinning the earliest and latest Python versions you want to test manually.</p>
</blockquote>
<p>is not satisfactory, I'm afraid. It is desirable that the <code>pyproject.toml</code> be the single source of truth for what the minimum viable version of Python is --- otherwise, we risk a mismatch between what we tell our users is the min version and what our CIs are actually testing.</p>
<p>Worse yet, the duplicate manual specification of lowest-viable-Python isn't even in a <code>matrix</code> or other obvious-place-to-look in the CI YAML file; it's buried in the <code>--python-version</code> flag of the <code>uv pip compile ...</code> command (making it harder to notice/find that it needs updating whenever <code>requires-python</code> gets bumped). Sure, I could manufacture a way to make it more prominent within the CI yaml file, but that's extra work / potentially confusing for future maintainers who need to edit that CI file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-12-21 14:30</div>
            <div class="timeline-body"><p>@drammock you should be using <code>uv export</code> for <code>pyproject.toml</code> sources rather than <code>uv pip compile</code>. We'll use the <code>requires-python</code> then. Though we're still going to emit a file with markers for Python versions, so it might not fulfill your use-case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drammock">@drammock</a> on 2025-12-21 17:30</div>
            <div class="timeline-body"><blockquote>
<p>you should be using <code>uv export</code> for <code>pyproject.toml</code> sources rather than <code>uv pip compile</code></p>
</blockquote>
<p>Ah wonderful! The script had originally been working from a <code>requirements.txt</code> input, when we switched it to start from pyproject I didn't think to switch the command too</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:33:11 UTC
    </footer>
</body>
</html>
