<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for cross-platform environments - astral-sh/uv #7957</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for cross-platform environments</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/7957">#7957</a>
        opened by <a href="https://github.com/freakboy3742">@freakboy3742</a>
        on 2024-10-07 03:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/freakboy3742">@freakboy3742</a> on 2024-10-07 03:56</div>
            <div class="timeline-body"><p>Python 3.13 added iOS and Android as Tier 3 supported platforms for CPython. It would be desirable to be able to use uv to develop apps for these environments.</p>
<p>However, providing this support requires that uv supports a new feature: cross-platform environments.</p>
<p>At runtime, iOS and Android behave largely as any other CPython platform would behave. However, the <em>build</em> experience is radically different, as you don't run <code>pip</code> (or any other build tooling) on the platform that will be running the code. Instead, a build machine (with an operating system different to the runtime platform) is used to package code into a distribution artefact, and that distribution artefact is then executed on the device.</p>
<p>For example, when building an iOS app, the <em>build</em> must be executed on macOS; this collects any wheels (including binary wheels compiled for the iOS platform), and collates the wheels into a form into the compiled app bundle. It must be possible to create an &quot;iOS environment&quot; on macOS, or an &quot;Android environment&quot; on macOS/Linux/Windows, and install iOS/Android binary wheels into that environment. The build machine isn't able to run any of the code that has been installed (at least, not directly; a simulator/emulator environment must be used).</p>
<h2>How to implement cross-platform environments</h2>
<p>At a bare minimum, cross-platform support requires being able to control the wheel tags that match as a part of dependency resolution. However, a more comprehensive solution would require creating an entire &quot;cross-platform&quot; virtual environment.</p>
<p><code>pip</code> has a <code>--platform</code> argument that can be used to directly control the wheel tags that match an installation request. AFAICT, there is no analog of this argument for uv at present. By passing in <code>--platform ios_13_0_arm64_iphoneos</code>, pip will install binary wheels that are compatible with execution on an ARM64 iOS device [^1].</p>
<p>[^1]: At present, pip will only match the <em>exact</em> iOS version named in the platform tag; a full solution requires an analog of macOS ABI version lookups. A <a href="https://github.com/pypa/pip/pull/12962">PR adding support for iOS package resolution is currently under review</a>; the <a href="https://github.com/pypa/packaging/pull/832">PR implementing the underlying lookup scheme</a> has already been merged.</p>
<p><a href="https://crossenv.readthedocs.io/en/latest/">Crossenv</a> recently merged <a href="https://github.com/benfogle/crossenv/pull/117">this PR</a>, providing a mechanism for creating a &quot;crossenv&quot; for iOS. This project is based on a trick with <code>site.py</code> that monkeypatches a standard virtual environment so that when code is executed in the environment, it will return <code>sys.platform</code> and <code>sysconfig</code> values that reflect the host/target environment, rather the build/source environment. When an iOS crossenv is active, invoking <code>pip</code> will download iOS-compatible wheels, rather than macOS-compatible wheels that would run on the build machine.</p>
<h2>What a cross-platform environment <em>isn't</em></h2>
<p>It's important to differentiate between a cross-platform <em>build</em> environment, and feature requests like #2408 and #7753. Those tickets are requesting the ability to run uv <em>on</em> Android - that is, a traditional Python development environment, but running on an Android device. While there are clearly people that use Android in this way, it is <em>not</em> how the vast majority of Android users interact with their devices, nor does it reflect a workflow that would allow the development of apps that could be distributed in the Google Play store (or similar).</p>
<h2>Other uses</h2>
<p>Although cross-platform build environments are a requirement for supporting iOS and Android, the generic functionality of cross-platform environments can be useful in any situation where you wish to produce a binary artefact for a platform without actually running the code for that platform is a candidate. For example, you could produce Raspberry Pi ARM64 binary wheels while on a Github Actions provided x86_64 Linux machine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-10-08 22:37</div>
            <div class="timeline-body"><p>We do support <code>--python-platform</code> which lets you create a virtual environment with wheels targeted at another platform. But it won't perform <em>cross compilation</em>, i.e., if it builds from source, you get a wheel for the current platform. Are you asking for something different here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @charliermarsh on 2024-10-08 22:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/freakboy3742">@freakboy3742</a> on 2024-10-09 00:30</div>
            <div class="timeline-body"><p>Looks like I missed the <code>--python-platform</code> option because I was looking for the exact match of <code>--platform</code>. Thanks for the pointer.</p>
<p>That flag does solves cross-platform wheel installation, which is a substantial part of the underlying problem. There's a related issue to add support for the PEP 730 iOS and PEP 738 Android tags; but I'll open that as a separate feature request.</p>
<p>The part that <code>--python-platform</code> <em>doesn't</em> solve is creating a runnable Python environment that identifies as being cross platform. This isn't about cross-compilation <em>per se</em>; but it is about providing the conditions to make cross-compilation possible. Since <code>uv</code> considers environment creation part of its domain, creating a cross-platform environment is (arguably) also part of that domain.</p>
<p>In order for PEP 517 interfaces to work, the Python install being used to construct the wheel must identify as the <em>host</em> platform - that is, <code>sys.platform</code> must return &quot;ios&quot; not &quot;darwin&quot;; <code>sysconfig.get_platform()</code> must return &quot;ios-13.0-arm64-iphoneos&quot;, not &quot;macosx-10.13-universal2&quot;; and so on. Any tools used during the build process (e.g., CMake, Meson, Cython) need to use binaries that will run on the <em>build</em> platform; but must produce binaries that are compatible with the <em>host</em> platform (either as a result of interrogating <code>sys.platform</code> et al, or as a result of some other environmental configuration).</p>
<p><a href="https://crossenv.readthedocs.io/en/latest/">Crossenv</a> is one tool that can be used to achieve this; the core of crossenv is essentially a site package hack that monkey patches <code>sys</code>, <code>sysconfig</code> et al to allow build tooling to pretend it's the host environment.</p>
<p>What I'm envisaging is a similar set of tools built into <code>uv venv</code>, so that <code>uv venv --python-platform ios_13_0_arm64_iphoneos</code> (or similar) would create a viable cross-platform environment that could be used to build iOS wheels, and where <code>uv pip install</code> would default to the same platform tag.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @zanieb on 2024-10-09 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @zanieb on 2024-10-09 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @zanieb on 2024-10-09 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-09 01:28</div>
            <div class="timeline-body"><p>This sounds cool, but I would be surprised if we had the time to build it soon. I'm curious if there's demand from more people for a feature like this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/eabase">@eabase</a> on 2025-02-25 07:57</div>
            <div class="timeline-body"><p>Also consider #11773</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rgommers">@rgommers</a> on 2025-06-02 19:08</div>
            <div class="timeline-body"><blockquote>
<p>What I'm envisaging is a similar set of tools built into <code>uv venv</code>, so that <code>uv venv --python-platform ios_13_0_arm64_iphoneos</code> (or similar) would create a viable cross-platform environment</p>
</blockquote>
<p>I think the clean solution is to start using <a href="https://peps.python.org/pep-0739/">PEP 739</a> and provide the <code>build-details.json</code> file for the Python interpreter matching the host environment installed with <code>--python-platform</code>. The PEP was only recently accepted and build backend support for it is still WIP, but it gives build tools access to the host platform and other <code>sysconfig</code>/<code>sys</code> module properties without hacks or having to run the non-native interpreter. I suspect all <code>uv venv --python-platform</code> should then be doing is install <code>build-details.json</code> in a standard location, so a cross build tool can be built on top that uses <code>uv</code> to create build and host envs and then invokes a cross build passing the location of that file to the build backend.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:35:12 UTC
    </footer>
</body>
</html>
