<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PEP517 backend: support fallback to `uv` executable? - astral-sh/uv #12389</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>PEP517 backend: support fallback to <code>uv</code> executable?</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/12389">#12389</a>
        opened by <a href="https://github.com/mgorny">@mgorny</a>
        on 2025-03-22 10:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mgorny">@mgorny</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Currently, the <code>uv_build</code> PEP517 backend supports using <code>uv-build</code> executable only. However, FWIU the backend code is fully included in <code>uv</code> itself, and FWICS it is exposed as <code>uv build-backend</code> subcommand. Would it be possible to add a fallback to the Python code, to support using <code>uv build-backend</code> when <code>uv-build</code> is not available?</p>
<p>Our use case is that since we're packaging <code>uv</code> already, we'd like to reuse this package instead of having to build a second <code>uv-build</code> executable that has a very wide overlap with it.</p>
<h3>Example</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @mgorny on 2025-03-22 10:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @konstin by @charliermarsh on 2025-03-23 13:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-03-23 13:26</div>
            <div class="timeline-body"><p>\cc @konstin</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mgorny">@mgorny</a> on 2025-03-23 13:49</div>
            <div class="timeline-body"><p>For the record, I'd be happy to make a pull request — but wanted to ask first, so I wouldn't impose.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-03-23 19:03</div>
            <div class="timeline-body"><p>It's possible to expose the build backend through uv itself and to make Python shim with the <code>uv</code> binary, too.</p>
<p>There's one caveat: For the Python packages, it's possible to install a different version of <code>uv_build</code> and <code>uv</code> in the same environment (we intentionally keep both zero-dependency, so we can't prevent this). For this reason, we want the default <code>uv_build</code> Python shim to only use build backend binary, not the <code>uv</code> binary. Would it work for you if we merge the infrastructure for the Python shim working with the <code>uv</code> binary, but the setting which binary to use is a build setting or a downstream (one line) patch?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mgorny">@mgorny</a> on 2025-03-23 19:08</div>
            <div class="timeline-body"><p>Not sure if I understand the concern. What I'm proposing is that if <code>uv-build</code> executable is not found, <code>uv</code> is used instead. Since the <code>uv-build</code> PyPI package installs both the <code>uv_build</code> Python backend and the <code>uv-build</code> executable, I don't believe the fallback would be used at all under normal circumstances — i.e. <code>uv</code> would only be used if someone deliberately removed <code>uv-build</code> executable.</p>
<p>That said, I'm happy with anything that makes our lives easier. If all it takes it a trivial patch (ideally something that could be reliably done via <code>sed</code>), I'm all for it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-23 21:46</div>
            <div class="timeline-body"><p>Does this contradict the concerns that were raised in the build backend thread about the build backend's dependencies? If we're going through the effort to make a minimal package (i.e., reduced dependencies and binary size) doesn't it make sense to package it separately?</p>
<blockquote>
<p>Would it work for you if we merge the infrastructure for the Python shim working with the uv binary, but the setting which binary to use is a build setting or a downstream (one line) patch?</p>
</blockquote>
<p>I am worried about third-party distributions of <code>uv</code> / <code>uv-build</code> behaving differently than ours — couldn't this be confusing to users?</p>
<blockquote>
<p>What I'm proposing is that if uv-build executable is not found, uv is used instead.</p>
</blockquote>
<p>Where would this be implemented? In the <code>uv_build</code> Python code? As Konsti noted, the concern here is that the <code>uv-build</code> version must match the <code>uv</code> version for this to work — or the user may not be invoking the version of the build backend they expect.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/musicinmybrain">@musicinmybrain</a> on 2025-04-04 20:19</div>
            <div class="timeline-body"><p>I just wanted to note that, in Fedora, we’ve elected to package <a href="https://src.fedoraproject.org/rpms/python-uv-build"><code>python-uv-build</code></a> as an entirely separate source package from <a href="https://src.fedoraproject.org/rpms/uv"><code>uv</code></a>. I’m happy that <code>uv</code> and <code>uv-build</code> have been designed to be relatively independent by default.</p>
<ul>
<li>This <code>python-uv-build</code> package can be quite a bit simpler than the <code>uv</code> package.</li>
<li>Separate source packages make it easier to keep track of which patches, licenses, additional sources, etc. apply to each binary package.</li>
<li>While it normally makes sense to synchronize updates of <code>uv</code> and <code>python-uv-build</code>, there will likely be times when we want to keep updating <code>uv</code> (which we primarily see as a developer tool for end users) while holding <code>python-uv-build</code> (which we primarily see as a dependency for building packages) at an older version for compatibility in stable branches.</li>
</ul>
<p>This comment is not intended to express an opinion on the merits of this proposal, and I do hope there will be some sensible way to make @mgorny’s life easier.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mgorny">@mgorny</a> on 2025-04-22 10:12</div>
            <div class="timeline-body"><p>Ah, sorry, I've missed the followup comments.</p>
<blockquote>
<p>Does this contradict the concerns that were raised in the build backend thread about the build backend's dependencies? If we're going through the effort to make a minimal package (i.e., reduced dependencies and binary size) doesn't it make sense to package it separately?</p>
</blockquote>
<p>I'd say these are different use cases. In general, if you don't have <code>uv</code> installed and don't plan on having it installed, then certainly a smaller <code>uv-build</code> executable makes sense. However, if you built <code>uv</code> already, building <code>uv-build</code> is redundant and a waste of energy.</p>
<p>On top of that, Maturin makes things difficult. <code>uv-build</code> consists of a Python module and an executable. Gentoo supports 7 Python targets right now, and this currently means building the identical <code>uv-build</code> executable 7 times. Of course, we can hack that around to have it built only once — but in the end, for me it's cleaner to have a single <code>uv</code> package that's already built as plain Rust package (i.e. without repeating the build for 7 Python versions), and an <code>uv-build</code> package that installs only Python modules.</p>
<p>That said, as I've said, there are valid use cases for this. If you're doing an isolated build, you definitely prefer building a smaller <code>uv-build</code> executable than the whole <code>uv</code>. On PowerPC, you can't even <code>pip install uv</code> anymore — after 20 minutes, the compiler runs out of address space. On the other hand, <code>uv-build</code> is still buildable out of the box. This also implies that we may elect to use <code>uv-build</code> in some cases in the future — but we still want to provide the option to avoid duplication.</p>
<blockquote>
<p>I am worried about third-party distributions of <code>uv</code> / <code>uv-build</code> behaving differently than ours — couldn't this be confusing to users?</p>
</blockquote>
<p>If I understand correctly, <code>uv build-backend</code> is supposed to work exactly the same as <code>uv-build</code>. Isn't that the case? I think it needs to be the case, if <code>uv</code> is supposed to special-case building packages that use its own backend.</p>
<blockquote>
<p>Where would this be implemented? In the <code>uv_build</code> Python code?</p>
</blockquote>
<p>Yes.</p>
<blockquote>
<p>As Konsti noted, the concern here is that the <code>uv-build</code> version must match the <code>uv</code> version for this to work — or the user may not be invoking the version of the build backend they expect.</p>
</blockquote>
<p>This is not a problem for us — we control the dependency versions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-04-22 10:19</div>
            <div class="timeline-body"><blockquote>
<p>On top of that, Maturin makes things difficult. uv-build consists of a Python module and an executable. Gentoo supports 7 Python targets right now, and this currently means building the identical uv-build executable 7 times. Of course, we can hack that around to have it built only once — but in the end, for me it's cleaner to have a single uv package that's already built as plain Rust package (i.e. without repeating the build for 7 Python versions), and an uv-build package that installs only Python modules.</p>
</blockquote>
<p>Both packages, uv and uv-build, work across all supported Python versions (<code>py3-none-*</code> wheel tag), with no need to rebuild for different Python version. Is there anything specifically where maturin makes this hard? Note that maturin is not doing much work here, we're compiling a rust executable and adding a single Python file. If building uv-build is harder than copy&amp;paste-ing the uv build configuration and replacing &quot;uv&quot; with &quot;uv-build&quot;, I'd consider this a problem in our setup.</p>
<blockquote>
<p>On PowerPC, you can't even pip install uv anymore — after 20 minutes, the compiler runs out of address space.</p>
</blockquote>
<p>If you've hit the same problem we've hit (32-bit compilers being allowed 4GB which fails to link uv), we're working around this by &quot;cross-compiling&quot; from a 64-bit host and compiler to a 32-bit target of the same OS.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mgorny">@mgorny</a> on 2025-04-22 10:36</div>
            <div class="timeline-body"><blockquote>
<p>Both packages, uv and uv-build, work across all supported Python versions (<code>py3-none-*</code> wheel tag), with no need to rebuild for different Python version. Is there anything specifically where maturin makes this hard?</p>
</blockquote>
<p>That assumes a build process where you can reuse wheels. This is not guaranteed nor required from Gentoo users.</p>
<blockquote>
<p>If building uv-build is harder than copy&amp;paste-ing the uv build configuration and replacing &quot;uv&quot; with &quot;uv-build&quot;, I'd consider this a problem in our setup.</p>
</blockquote>
<p>Building <code>uv</code> is nowhere near trivial, provided you need to meet QA concerns. It requires fetching the archive from GitHub, so that we can run tests. It requires handling all the different switches and workarounds to make <code>*-sys</code> crates actually use system dependencies. It requires building a tarball with vendored crates and keeping the license list up-to-date. Finally, it implies running the test suite.</p>
<p>I honestly don't have the energy to maintain the same thing for <code>uv-build</code>, provided it is even possible to isolate the <code>uv-build</code> parts and run their tests separately. On top of that, last I checked <code>Cargo.lock</code> includes more crates than necessary, which effectively implies we end up fetching too much. Plus, avoiding all the hassle lets us use PyPI source distributions.</p>
<blockquote>
<p>If you've hit the same problem we've hit (32-bit compilers being allowed 4GB which fails to link uv), we're working around this by &quot;cross-compiling&quot; from a 64-bit host and compiler to a 32-bit target of the same OS.</p>
</blockquote>
<p>We can't really tell Gentoo's PPC users &quot;sorry, you have to use a second machine and cross-compile to run this package&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2025-04-22 11:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2025-04-22 11:46</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:30:34 UTC
    </footer>
</body>
</html>
