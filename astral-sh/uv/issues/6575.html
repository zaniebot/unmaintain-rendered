<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>uv workspaces and namespace packages - astral-sh/uv #6575</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>uv workspaces and namespace packages</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/6575">#6575</a>
        opened by <a href="https://github.com/valentincalomme">@valentincalomme</a>
        on 2024-08-24 11:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/valentincalomme">@valentincalomme</a> on 2024-08-24 11:26</div>
            <div class="timeline-body"><blockquote>
<p>TLDR: I'm trying to build multiple packages under the same namespace using <code>uv</code> workspaces, but I'm having trouble. I would greatly appreciate it if the documentation included instructions on how to handle namespace packages.</p>
</blockquote>
<p>I've been tinkering with workspaces since they were released, but I have needed help to get what I wanted working. Here is my use case. I am building a core package called <code>cable</code>. I would also like to build a command-line interface for <code>cable</code> that should be an optional dependency of <code>cable</code>. If installed, it should be importable as <code>cable.cli</code>. I also want to build another &quot;extension&quot; called experiments.</p>
<p>Both the cli and experiments packages depend on the core <code>cable</code> code and I don't want the <code>cable</code> package to know about <code>cli</code> and <code>experiments</code> or their specific dependencies (i.e. <code>typer</code>, <code>mlflow</code>).</p>
<p>I want to use workspace to cleanly isolate the code and dependencies, but I have struggled to build the packages within my <code>cable</code> namespace.</p>
<p>Another question/thought is that I don't quite understand why all my workspace members must have their own versions. In my use case, the only version that matters is the <code>cable</code> version.</p>
<p>Am I misunderstanding how/when to use workspaces?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @zanieb on 2024-08-26 13:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @konstin by @zanieb on 2024-10-21 21:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-21 21:17</div>
            <div class="timeline-body"><p>@konstin could you take a look at this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-10-22 12:01</div>
            <div class="timeline-body"><p>Your example is a great use case for workspaces. I've create am example repo for this: https://github.com/konstin/uv-workspace-example-cable. Feel free to ask more questions here!</p>
<p>Most information should be in the readme, copied below. I've chosen not to user namespace packages but isolated packages, in my experience namespace packages cause more trouble than they solve.</p>
<hr />
<h1>uv workspace example: cable</h1>
<p>This project contains a workspace with four packages: cable, cable-experiments, cable-cli, and cable-core. cable is the main project that users install. It has extras <code>cable[cli]</code> and <code>cable[experiments]</code> that pull in cable-experiments and cable-cli respectively. <code>cable-core</code> implements shared utils.</p>
<p>Since cable is the main project, it lives in the workspace root (not all workspaces have a root, but for many project a clear root that (indirectly) depends on everything else is very convenient), while all other packages live in <code>packages</code>.</p>
<pre><code>        ---&gt; cable-cli -----------|
cable --|                         |--&gt; cable-core
        ---&gt; cable-experiments ---|
</code></pre>
<p>or with <code>uv tree</code>:</p>
<pre><code>cable v0.1.0
├── cable-cli v0.1.0 (extra: cli)
│   └── cable-core v0.1.0
└── cable-experiments v0.1.0 (extra: experiments)
    └── cable-core v0.1.0
</code></pre>
<p>When the user installs cable, they can decide if they want from a minimal installation (<code>cable</code>) to all features (<code>cable[cli,experiments]</code>).</p>
<p>The project offers an optional CLI. The script entrypoint lives in cable-cli, because there's a current limitation that scripts can't depend on extras, so cable-cli installs a <code>cable &lt;name&gt;</code> script; It's still installed through <code>cable[cli]</code>.</p>
<p>You can create this workspace structure roughly with:</p>
<pre><code class="language-shell">uv init --lib cable
cd cable/
mkdir packages
cd packages/
uv init --lib cable-core
uv init --lib cable-cli
uv init --lib cable-experiments
cd cable-cli/
uv add ../cable-core
cd ../cable-experiments/
uv add ../cable-core
cd ../..
uv add --optional cli packages/cable-cli/
uv add --optional experiments packages/cable-experiments/
uv sync --all-extras
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @konstin by @konstin on 2024-10-22 12:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/omrihar">@omrihar</a> on 2024-12-15 19:27</div>
            <div class="timeline-body"><p>This is great, and almost what I'm looking for as well. I have one question though: if I'd like to add a project to this structure that is, say, a website that depends on cable, how would I go about adding it? My use case is in the end to serve the website via a docker image that installs cable as a dependency.
Would this also fit the use case of workspaces? I do not want to add the website as a dependency or an optional dependency, because it's just a client of cable, but would like to use a monorepo structure to keep it in sync with the development of cable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-12-16 10:42</div>
            <div class="timeline-body"><p>In that case, you probably want either the website as root and cable as subfolder, or all packages in subfolders (e.g. a dedicated <code>packages</code>), while the root has no packages; The details depend on the details of your project workflows.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/omrihar">@omrihar</a> on 2024-12-18 13:37</div>
            <div class="timeline-body"><p>Thanks @konstin , I will probably have multiple websites / UIs that depend on the core package and possibly some add-ons. Would you recommend in that case to split the package to have a root library that depends on the core set of packages, then a set of packages in a subfolder <code>packages</code>, and another subfolder with a set of UIs / websites which are not packages?
I also have a question about the presence of the <code>src</code> folder. Is there an actual reason for it? After all if I have <code>folder/packages/package_name/package_name</code> why add another layer and do <code>folder/packages/package_name/src/package_name/</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-12-19 11:06</div>
            <div class="timeline-body"><p>I'd start with a flat layout where all packages are directly in <code>packages</code>.</p>
<blockquote>
<p>After all if I have folder/packages/package_name/package_name why add another layer and do folder/packages/package_name/src/package_name/?</p>
</blockquote>
<p>When you're in <code>folder/packages/package_name/</code>, this ensures that <code>import package_name</code> will import from the venv and not from <code>package_name</code>, so you're always going through the editable instead of the import depending on where you're in the package root or not, see https://packaging.python.org/en/latest/discussions/src-layout-vs-flat-layout/.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tpanum">@tpanum</a> on 2024-12-23 14:37</div>
            <div class="timeline-body"><blockquote>
<p>in my experience namespace packages cause more trouble than they solve</p>
</blockquote>
<p>Can you elaborate on, what problems they might cause, @konstin? If one were to deeply desire namespace'd packages, how would you implement them using <code>uv</code> and workspaces?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ribeirompl-soldersmith">@ribeirompl-soldersmith</a> on 2025-01-20 11:48</div>
            <div class="timeline-body"><p>I am also curious about the problems from @konstin's experience?</p>
<p>Perhaps one of the issues could be the easy mistake of keeping <code>__init__.py</code> files in the root of the package, resulting in an invalid namespace package. This is deceptive because it appears to work fine when the packages are installed normally, but this is unintended behaviour, and it does not work for editable installs as explained <a href="https://stackoverflow.com/questions/66335671/how-to-install-multiple-python-namespace-packages-in-editable-mode">here</a>.</p>
<p>Namespace packages do have the limitation of not being able to have a root-level <code>__init__.py</code> file containing some logic, as described <a href="https://stackoverflow.com/questions/77063081/does-importing-a-namespace-package-also-import-the-modules-in-the-directory">here</a>, so in some cases, isolated packages could be preferred.</p>
<p>I set up a repo containing a namespace package example setup that seems to work within a uv workspace, loosely based on the cable example above. It does, however, require changing the core's <code>__init__.py</code> file to a <code>core.py</code> file.
https://github.com/ribeirompl-soldersmith/uv-namespace-package-workspace</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-01-20 12:32</div>
            <div class="timeline-body"><p>Namespace packages can work by overriding each others files, so you get the file of the package that was installed last; One package can modify a directory also used by another package instead of isolation between them. This makes tooling around them harder, e.g. editable installs, caching, layered installation (since the namespace packages with the same &quot;root package&quot; need to be installed together) or figuring out which package is missing. My perspective is colored by being a tool author more than a library author, but i'd go for <code>importlib.metadata.entry_points</code> or something similar for plugins over interleaving mechanisms such as namespace packages.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aaaaahaaaaa">@aaaaahaaaaa</a> on 2025-02-06 17:05</div>
            <div class="timeline-body"><p>@konstin There is a point from the original question that is not being addressed in your example which is that the packages should share the same namespace name (here <code>cable</code>).</p>
<p>Which would results in the following imports:</p>
<pre><code class="language-python">import cable.core
import cable.cli
import cable.experiment
</code></pre>
<p>As opposed to:</p>
<pre><code class="language-python">import cable_core
import cable_cli
import cable_experiment
</code></pre>
<p>Changing the folder structure to reflex that (e.g. <code>cable/core</code> instead of <code>cable_core</code>) results in an error with <code>uv sync</code>:</p>
<pre><code>× Failed to build [...]
[...]
The most likely cause of this is that there is no directory that matches the name of your project (cable_core).
</code></pre>
<p>Implicit namespace names accross libs is a valid Python spec (<a href="https://peps.python.org/pep-0420/">PEP 420</a>).</p>
<p>Do you confirm this is currently not possible with UV workspaces or am I missing something?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-02-06 17:10</div>
            <div class="timeline-body"><p>I'd have to see the complete new tree and command output, but did you check that the names in <code>project.name</code> as well as <code>[tool.uv.sources]</code> match your updated structure?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aaaaahaaaaa">@aaaaahaaaaa</a> on 2025-02-06 17:19</div>
            <div class="timeline-body"><p>Well, you do need unique names under <code>[tool.uv.sources]</code>, right? So it cannot reflex the following structure:</p>
<p>If we keep the same example, the tree would be:</p>
<pre><code>├── packages
│   ├── cable-core
│       ├── pyproject.toml
│       └── src
│           └── cable
│               └── core
│                   └── __init__.py
│   └── cable-assets
│       ├── pyproject.toml
│       └── src
│           └── cable
│               └── cli
│                   └── __init__.py
├── pyproject.toml
</code></pre>
<p>Which is valid under across multiple libs based on PEP 420, if you were to install <code>cable-core</code> and <code>cable-assets</code> separately. They would share the same root namespace.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aaaaahaaaaa">@aaaaahaaaaa</a> on 2025-02-06 17:51</div>
            <div class="timeline-body"><p>Adding the following to the packages's <code>pyproject.toml</code> does solve the build issue, which makes sense.</p>
<pre><code>[tool.hatch.build.targets.wheel]
packages = [&quot;src/cable&quot;]
</code></pre>
<p>Which then allows to use a shared root namespace.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2025-03-03 03:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/majidaldo">@majidaldo</a> on 2025-04-18 22:58</div>
            <div class="timeline-body"><p>omg that was too hard! here's my <a href="https://github.com/pnnl/BIM2RDF/tree/9f315a0935127b11e8b44e96d67d5874e583df2b">example</a>.</p>
<ul>
<li>flattest possible file structure</li>
<li>all sub-package <code>__version__</code>s are the same as 'core'.</li>
<li>sucks: had to spell out deps in the main pyproject.toml instead of in its respective sub-package pyproject.toml. else, the distributable (whl) will not count them as deps of the 'core' pkg (but deps of their respective ns pkgs)</li>
<li>sucks: ...ditto for optional script def</li>
</ul>
<p>toml with references would have helped keep things in their respective locations!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/moaddib666">@moaddib666</a> on 2025-05-14 14:40</div>
            <div class="timeline-body"><blockquote>
<p>omg that was too hard! here's my <a href="https://github.com/pnnl/BIM2RDF/tree/9f315a0935127b11e8b44e96d67d5874e583df2b">example</a>.</p>
<ul>
<li>flattest possible file structure</li>
<li>all sub-package <code>__version__</code>s are the same as 'core'.</li>
<li>sucks: had to spell out deps in the main pyproject.toml instead of in its respective sub-package pyproject.toml. else, the distributable (whl) will not count them as deps of the 'core' pkg (but deps of their respective ns pkgs)</li>
<li>sucks: ...ditto for optional script def</li>
</ul>
<p>toml with references would have helped keep things in their respective locations!</p>
</blockquote>
<p>Hi @majidaldo, thanks for your example looks nice and was really helpful to me, the only thing that I've changed is versioning.</p>
<p>I'd prefer to use env instead path it every time</p>
<pre><code>[tool.hatch.version]
source = &quot;env&quot;
variable = &quot;VERSION&quot; &lt;- Your var here
</code></pre>
<p>https://hatch.pypa.io/1.13/plugins/version-source/env/#pyprojecttoml</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woutervhy">@woutervhy</a> on 2025-10-10 06:44</div>
            <div class="timeline-body"><p>I wasn't aware that uv normalizes dotted packages <code>foo.bar</code> to <code>foo-bar</code>.</p>
<p>For future reference:
Here is my demo-example:
https://github.com/libranet/demo-uv-workspace/tree/main</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/prise6">@prise6</a> on 2025-11-19 21:46</div>
            <div class="timeline-body"><blockquote>
<p>Adding the following to the packages's <code>pyproject.toml</code> does solve the build issue, which makes sense.</p>
<pre><code>[tool.hatch.build.targets.wheel]
packages = [&quot;src/cable&quot;]
</code></pre>
<p>Which then allows to use a shared root namespace.</p>
</blockquote>
<p>@aaaaahaaaaa did you manage to make it work in editable mode ?</p>
<p>I don't manage to make @konstin example work with namespace actually.</p>
<p>EDIT: forget about this comment =&gt; @woutervhy example is a good one</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:17:06 UTC
    </footer>
</body>
</html>
