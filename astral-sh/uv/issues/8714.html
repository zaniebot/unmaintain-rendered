<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FR: `uv build` accepts a dynamic &quot;package version&quot; argument - astral-sh/uv #8714</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>FR: <code>uv build</code> accepts a dynamic &quot;package version&quot; argument</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/8714">#8714</a>
        opened by <a href="https://github.com/charlesnicholson">@charlesnicholson</a>
        on 2024-10-31 01:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/charlesnicholson">@charlesnicholson</a> on 2024-10-31 01:32</div>
            <div class="timeline-body"><p>When we build &quot;official&quot; Python distribution package wheels from CI, we version the packages dynamically based on the current git tag. This is surprisingly complicated to do!</p>
<p>The <code>build</code> package doesn't support a dynamic version supplied from the command-line: https://build.pypa.io/en/stable/#python--m-build-options</p>
<p>So, we ended up using this thing: https://github.com/pypa/setuptools-scm?tab=readme-ov-file#pyprojecttoml-usage</p>
<p>Our pyproject.toml files look like this:</p>
<pre><code>[project]
name = &quot;my_company.package&quot;
dynamic = [&quot;version&quot;]
...
</code></pre>
<p>And then we have to provide the version as an environment variable to the build:</p>
<pre><code>SETUPTOOLS_SCM_PRETEND_VERSION=1.2.3 path/to/venv/bin/python -m build ...
</code></pre>
<p>It's all very roundabout and contrived; I just want to do this:</p>
<pre><code>path/to/venv/bin/python -m build --version=1.2.3 ...
</code></pre>
<p>I don't know if there's appetite in extending <code>uv build</code> to solve this with fewer packages and with a simple command-line, but it would make our lives a lot simpler, and we'd be able to ditch both the <code>build</code> and the <code>setuptools-scm</code> packages in favor of stock <code>uv</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-31 04:49</div>
            <div class="timeline-body"><p>Seems sensible, although we probably need our own build backend to support this? I presume setting the dynamic version is build backend dependent and we're unlikely to tie into their options.</p>
<p>You could also change the version statically, per the workflow in https://github.com/astral-sh/uv/issues/6298, though that's annoying because if you want the committed <code>pyproject.toml</code> to be correct you need to do it ahead of time.</p>
<p>As a simple workaround, I set the version to <code>0.0.0</code> then do <a href="https://github.com/astral-sh/packse/blob/70abfe8f64a9746452c02cb514942f879c7eaccc/.github/workflows/release.yaml#L34-L36"><code>sed -i -e &quot;s/0.0.0/${GITHUB_REF#refs/*/}/&quot; pyproject.toml</code></a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charlesnicholson">@charlesnicholson</a> on 2024-10-31 12:24</div>
            <div class="timeline-body"><p>Thanks for the response! Yeah, I landed on the same options you did, I think- in the end I chose not to do in-place modifications of the git <code>pyproject.toml</code> files b/c we can sometimes do a &quot;versioned&quot; build locally and we have to remember to git-reset all of the toml files. So for us it's &quot;better&quot; to do this Rube Goldberg silliness :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charlesnicholson">@charlesnicholson</a> on 2024-10-31 12:29</div>
            <div class="timeline-body"><p>Also, re-reading your response saying &quot;we're unlikely to tie into their options&quot;- Sorry if I wasn't clear; I would love to fully abandon this <code>setuptools-scm</code> thing; it's just totally a hack I'm using because it just happens to have an environment-variable interface to setting the version in the distribution package!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-31 19:23</div>
            <div class="timeline-body"><p>There's https://github.com/astral-sh/uv/issues/3957 to track implementation of our own build backend.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @charliermarsh on 2024-11-01 13:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/paveldikov">@paveldikov</a> on 2024-11-02 00:45</div>
            <div class="timeline-body"><p>+1 on a UX/ecosystem level. Versioning is such a fundamental build concern and it is so unfortunate that developers have to dance around it with build-backend plugins -- it's super clunky and fragile. I can similarly attest to having burnt a lot of time shimming things with <code>setuptools-scm</code> and the like. Frankly, package versioning should have been externalised to begin with.</p>
<p>Architecturally though I'm a -0.5 as this somewhat violates PEP 517. In the current standard, dynamic versioning is fully controlled by the build-backend (as regrettable as this is). And so the only way for the frontend can influence the choice of version, is if the backend is actively willing to be influenced.</p>
<p>I.e. <code>uv build --version 1.2.3</code> would <em>only</em> reliably result in a <code>1.2.3</code> version if and only if the build-backend is <code>uv</code> itself, or is similarly aware of some <code>uv</code>-specific build config API. A non-<code>uv</code>-aware backend would silently ignore this option, or even error out because it can't plug the metadata gap. This <em>may</em> be an acceptable compromise in the interim, FWIW.</p>
<p>(IMHO this problem should ultimately be solved at the PEP level)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charlesnicholson">@charlesnicholson</a> on 2024-11-02 00:50</div>
            <div class="timeline-body"><p>Agreed, after reading up more on this, a <code>uv</code> build backend seems like the only sane place for such an implementation to live.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wu-clan">@wu-clan</a> on 2024-11-03 09:15</div>
            <div class="timeline-body"><p>pdm does a great job at thisï¼šhttps://pdm-project.org/en/latest/reference/pep621/</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-11-03 15:20</div>
            <div class="timeline-body"><p>@wu-clan I don't see how that's any different than uv? That just looks like a PEP 621 reference guide.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wu-clan">@wu-clan</a> on 2024-11-03 16:28</div>
            <div class="timeline-body"><p>@zanieb Yes, if you look closely, you'll find https://backend.pdm-project.org/metadata/#dynamic-project-version, which is a very useful feature, especially for libraries</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vancromy">@vancromy</a> on 2025-05-07 11:08</div>
            <div class="timeline-body"><p>With uv_build now in preview mode and pushed into main it would be amazing to get this FR implemented. We've been using https://github.com/mtkennerly/poetry-dynamic-versioning so far (very similar to setuptools_scm and hatch-vcs) and it would be the last hurdle for us to port over to uv (which is so fast :rocket:) :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/snus-kin">@snus-kin</a> on 2025-07-03 13:29</div>
            <div class="timeline-body"><p>Not sure if there's a better place to put this comment but now that the uv build backend is stable is this issue tracked elsewhere? I'd like to use it but am stumbling over dynamic versioning, we'd previously used setuptools and a <code>version.py</code> file for this. <code>sed</code> is a possible workaround but would be nice if it was supported more officially.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/seandstewart">@seandstewart</a> on 2025-07-03 14:47</div>
            <div class="timeline-body"><p>Piling on here - a <code>--version=</code> flag would be great and is a general way to solve dynamic versions and is the only thing blocking my organization from adoption of uv's new build backend.</p>
<p>It would also be very slick to have some sort of extension like https://github.com/ofek/hatch-vcs which could do the work of pulling in the version number from VCS and injecting it into the package metadata directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-03 14:56</div>
            <div class="timeline-body"><p>Can ya'll clarify why running <code>uv version</code> before <code>uv build</code> is insufficient?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jzazo">@jzazo</a> on 2025-07-03 15:25</div>
            <div class="timeline-body"><p>I was using <a href="https://github.com/ninoseki/uv-dynamic-versioning">uv-dynamic-versioning</a> to calculate dev versions when I push to main. When I tag a version manually, then <code>uv version</code> would work, but then this has to be committed and locked prior to publishing the package (which I guess CI could do). But the dynamic solution allows to not commit anything while relying on VCS tags and works also for dev versions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/seandstewart">@seandstewart</a> on 2025-07-03 18:53</div>
            <div class="timeline-body"><p>I've done this many ways. The four main patterns I've come across or used:</p>
<p>Static version artifact, automated versioning:</p>
<ol>
<li>On merge to main, generate new version</li>
<li>Update <code>version</code> in my toml and/or the <code>__version__</code> const in the package -&gt;</li>
<li>Commit + tag the change</li>
<li>Push new commit + tag to main</li>
<li>On tag creation</li>
<li>Build distribution and upload</li>
<li>Generate Release artifact.</li>
</ol>
<p>Dynamic version from vcs, automated versioning:</p>
<ol>
<li>On merge to main, generate new version</li>
<li>Tag current commit and push</li>
<li>Build distribution and upload to registry</li>
<li>Generate Release and upload distribution artifacts.</li>
</ol>
<p>Static version artifact, manual versioning:</p>
<ol>
<li>Create Release artifact (automatically creates your tag).</li>
<li>On tag creation</li>
<li>Update the version in my toml and/or the <code>__version__</code> const in the package.</li>
<li>Commit + push the change</li>
<li>Build distribution and upload to registry</li>
<li>Update Release with distribution artifacts.</li>
</ol>
<p>Dynamic version artifact, manual versioning:</p>
<ol>
<li>Create Release artifact (automatically creates your tag).</li>
<li>On tag creation</li>
<li>Build distribution and upload to registry</li>
<li>Update Release with distribution artifacts.</li>
</ol>
<p>Removing a static version from the toml/package reduces the complexity of your CD pipeline. It also means you don't have to juggle permissions and secrets for enabling the automation to push to source control.</p>
<p>Another thing worth noted that is hinted at in the above comment - if you don't have to update the toml, then you don't have to regenerate your lock. This is really useful for code bases which may ship a container image, as it means they don't have to jump through hoops to avoid busting the container build cache just because they updated the version number of the application. Here's an example Dockerfile which demonstrates how one might dance around this issue (pulled from a real production application using poetry - org-specifics redacted):</p>
<pre><code class="language-Dockerfile">FROM python:3.12 as poetry

WORKDIR /app

ENV POETRY_VERSION=&quot;1.8.5&quot;
ENV POETRY_URL=&quot;https://install.python-poetry.org&quot;

RUN curl -sSL &quot;${POETRY_URL}&quot; | python3 -

COPY pyproject.toml pyproject.toml
COPY poetry.lock poetry.lock
RUN /root/.local/bin/poetry export --only=main -f requirements.txt -o requirements.txt

FROM python:3.12-slim as dependencies

WORKDIR /app

ENV PIP_DEFAULT_TIMEOUT=100 \
    PIP_DISABLE_PIP_VERSION_CHECK=1 \
    PIP_NO_CACHE_DIR=1 \
    PIP_PREFER_BINARY=1 \
    PIP_NO_INPUT=1

COPY --from=poetry /app/requirements.txt requirements.txt

RUN python -m venv .venv \
    &amp;&amp; .venv/bin/pip install -r requirements.txt

FROM python:3.12-slim as main

WORKDIR /app

ENV PYTHONFAULTHANDLER=1 \
    PYTHONHASHSEED=random \
    PYTHONUNBUFFERED=1 \
    PIP_DISABLE_PIP_VERSION_CHECK=1 \
    TZ=&quot;UTC&quot;

COPY --from=dependencies /app/.venv .venv
COPY schema schema
COPY src src
COPY pyproject.toml pyproject.toml
RUN .venv/bin/pip install -e .

EXPOSE 8080/tcp
ENTRYPOINT [&quot;.venv/bin/myapp&quot;]
CMD [&quot;start&quot;]
</code></pre>
<p>As you can see, you have to create a dedicated stage just to extract the dependency pins in a way which doesn't depend upon the pyproject.toml until <em>after</em> you've installed the dependencies into your build env. If the versioning were dynamic, the Dockerfile could be as little as a single stage.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cbrnr">@cbrnr</a> on 2025-07-04 06:13</div>
            <div class="timeline-body"><p>I've used the dynamic version feature with hatchling because I want to have the <code>__version__</code> attribute in a single place (e.g., <code>__init__.py</code>), and I don't want to manually sync it in another place (i.e., <code>pyproject.toml</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/snus-kin">@snus-kin</a> on 2025-07-04 08:30</div>
            <div class="timeline-body"><blockquote>
<p>Can ya'll clarify why running <code>uv version</code> before <code>uv build</code> is insufficient?</p>
</blockquote>
<p>Cheers this works better for me I think, doing something like this for the version attribute to use in code (we use this for e.g. logging)</p>
<pre><code class="language-py">import importlib.metadata

__version__ = importlib.metadata.version(&quot;my_module&quot;)
</code></pre>
<p>Worth mentioning that the service we're using for this is pretty lax around versioning anyways, probably this is less appropriate for libraries etc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-07-04 10:01</div>
            <div class="timeline-body"><blockquote>
<p>I've used the dynamic version feature with hatchling because I want to have the <code>__version__</code> attribute in a single place (e.g., <code>__init__.py</code>), and I don't want to manually sync it in another place (i.e., <code>pyproject.toml</code>).</p>
</blockquote>
<p>For this case specifically I strongly recommend the <code>importlib.metadata</code> solution that @snus-kin shared. Nowadays, <code>pyproject.toml</code> is much better suited as the canonical location of this information, where it can be discovered by tools.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/my1e5">@my1e5</a> on 2025-07-04 11:38</div>
            <div class="timeline-body"><p>@snus-kin</p>
<blockquote>
<p>now that the uv build backend is stable is this issue tracked elsewhere?</p>
</blockquote>
<p>There is</p>
<ul>
<li>https://github.com/astral-sh/uv/issues/14037</li>
<li>https://github.com/astral-sh/uv/issues/11718</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charlesnicholson">@charlesnicholson</a> on 2025-07-25 21:26</div>
            <div class="timeline-body"><p>It's a little subtle, but if this is planned to be built I'd greatly prefer a way to customize the version string instead of having uv simply grab the tag straight from git. Sometimes we want to edit or decorate the tag, like removing suffix metadata etc. Being able to pass an arbitrary (legal) version as a command-line arg or environment variable to <code>uv build</code> would be much more flexible.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 12:30:47 UTC
    </footer>
</body>
</html>
