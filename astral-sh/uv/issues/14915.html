<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>libpython and PREFIX - astral-sh/uv #14915</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>libpython and PREFIX</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/14915">#14915</a>
        opened by <a href="https://github.com/Time0o">@Time0o</a>
        on 2025-07-26 13:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Time0o">@Time0o</a></div>
            <div class="timeline-body"><h3>Question</h3>
<p>I've just come across this while trying to write a C++ program that that links against libpython and runs an embedded interpreter via Pybind11. My understanding of how this works is a bit shoddy I think so bear with me:</p>
<p>Before executing the interpreter from C++ it is possible to tell libpython where it is located e.g. by running:</p>
<pre><code class="language-C++">Py_SetPythonHome(&quot;/Users/me/.local/share/uv/python/cpython-3.11.10-macos-aarch64-none&quot;)
</code></pre>
<p>And with the version of libpython installed by uv this seems to actually be necessary. When linking against a version of libpython installed via e.g. Homebrew however it is not. I believe this is because the version installed by Homebrew was built with <code>PREFIX</code> and <code>EXEC_PREFIX</code> set to sensible values during the configure step.</p>
<p>It would be nice if Astral provided similarly compiled libraries. However, I am not sure if this is technically possible. Since they are typically downloaded to <code>$HOME/.local/share/uv</code> the correct path would have to presumable be patched into the binaries. Maybe this would be possible if instead of <code>/install</code> they were compiled with a very long placeholder path such that it could be safely replaced with the actual path padded to the same length with zeros post-download? Not sure if that could still break somehow, probably yes but it sounds at least feasible.</p>
<h3>Platform</h3>
<p>macOS</p>
<h3>Version</h3>
<p><code>uv 0.8.3 (7e78f54e7 2025-07-24)</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @Time0o on 2025-07-26 13:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-26 14:41</div>
            <div class="timeline-body"><p>cc @geofft</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/geofft">@geofft</a> on 2025-08-12 16:52</div>
            <div class="timeline-body"><p>Here's an approach to automatically set <code>PYTHONHOME</code> based on the path to the loaded libpython, based on the <a href="https://pybind11.readthedocs.io/en/stable/advanced/embedding.html">embedding example in the pybind11 docs</a>. Tested on glibc and macOS, probably works on musl too.</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt; // everything needed for embedding
#include &lt;string&gt;
#include &lt;dlfcn.h&gt;
namespace py = pybind11;

void detect_python_home(PyConfig *config) {
    Dl_info info;
    if (dladdr((void *)PyConfig_InitPythonConfig, &amp;info) == 0)
        return;
    if (info.dli_fname == nullptr)
        return;
    std::string filename(info.dli_fname);
    size_t slash = filename.rfind('/');
    if (slash == std::string::npos || slash == 0)
        return;
    slash = filename.rfind('/', slash - 1);
    if (slash == std::string::npos)
        return;
    filename.resize(slash);
    PyConfig_SetBytesString(config, &amp;config-&gt;home, filename.c_str());
}

int main() {
    PyConfig config;
    PyConfig_InitPythonConfig(&amp;config);
    // These two lines from pybind11
    config.parse_argv = 0;
    config.install_signal_handlers = 1;
    detect_python_home(&amp;config);

    py::scoped_interpreter guard{&amp;config}; // start the interpreter and keep it alive

    py::print(&quot;Hello, World!&quot;); // use the Python API
}
</code></pre>
<p>I went with the new-style initialization API, but if you need to target older Python versions you should be able to use <code>Py_SetPythonHome</code> and drop references to the <code>config</code> variable.</p>
<p>This works because, at least when using CMake, it encodes at compile time a reference to the full path where you installed the interpreter on your machine:</p>
<pre><code>$ readelf -d ./example | grep RUNPATH
 0x000000000000001d (RUNPATH)            Library runpath: [/home/ubuntu/.local/share/uv/python/cpython-3.13.5-linux-x86_64-gnu/lib]
</code></pre>
<p>This just leans on that to find the location where we picked up <code>libpython</code> and use that as <code>PYTHONHOME</code>.</p>
<p>I think it would probably be reasonable for us to do this by default.</p>
<details>
<summary>For my own reference, here's a worked example of what's mentioned in the first comment to hard-code the path:</summary>

<p>Create a project with <code>uv init</code> and cd into it.</p>
<p>Copy the <code>CMakeLists.txt</code> and <code>main.cpp</code> files from</p>
<p>Run <code>uv add pybind11[global] cmake</code>. (&quot;Global&quot; here simply means that it's installed outside of the pybind11 package where cmake looks; it's still inside of the virtualenv.)</p>
<p>Add an appropriate call at the top of main, e.g.,</p>
<pre><code class="language-c++">#include &lt;pybind11/embed.h&gt; // everything needed for embedding
namespace py = pybind11;

int main() {
    Py_SetPythonHome(L&quot;/home/ubuntu/.local/share/uv/python/cpython-3.13.5-linux-x86_64-gnu&quot;);
    py::scoped_interpreter guard{}; // start the interpreter and keep it alive

    py::print(&quot;Hello, World!&quot;); // use the Python API
}
</code></pre>
<p>Run <code>uv run cmake . &amp;&amp; uv run cmake --build .</code>, which produces a binary <code>./example</code>.</p>
</details>

</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:32:22 UTC
    </footer>
</body>
</html>
