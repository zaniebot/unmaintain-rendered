<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handling of signal exit from subprocess is incorrect - astral-sh/uv #11886</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Handling of signal exit from subprocess is incorrect</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/11886">#11886</a>
        opened by <a href="https://github.com/geofft">@geofft</a>
        on 2025-03-01 22:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a></div>
            <div class="timeline-body">Summary
<p>crates/uv/src/commands/run.rs has logic to take a <a href="https://doc.rust-lang.org/nightly/std/process/struct.ExitStatus.html"><code>std::process::ExitStatus</code></a> and convert it to an exit code as follows:</p>
<pre><code>    if let Some(code) = status.code() {
        debug!(&quot;Command exited with code: {code}&quot;);
        if let Ok(code) = u8::try_from(code) {
            Ok(ExitStatus::External(code))
        } else {
            #[allow(clippy::exit)]
            std::process::exit(code);
        }
    } else {
        #[cfg(unix)]
        {
            use std::os::unix::process::ExitStatusExt;
            debug!(&quot;Command exited with signal: {:?}&quot;, status.signal());
            // Following https://tldp.org/LDP/abs/html/exitcodes.html, a fatal signal n gets the
            // exit code 128+n
            if let Some(mapped_code) = status
                .signal()
                .and_then(|signal| u8::try_from(signal).ok())
                .and_then(|signal| 128u8.checked_add(signal))
            {
                return Ok(ExitStatus::External(mapped_code));
            }
        }
        Ok(ExitStatus::Failure)
    }
</code></pre>
<p>This is not quite correct, as the Rust docs allude to when they say, &quot;An <code>ExitStatus</code> represents every possible disposition of a process. On Unix this is the wait status. It is <em>not</em> simply an exit status (a value passed to <code>exit</code>).&quot;</p>
<p>The 128 + n behavior is the behavior of the <em>shell</em>: if a process exits with a signal, the shell will set <code>$?</code> to 128 + n. But the shell will <em>also</em> print a message indicating the signal, e.g. &quot;Segmentation fault (core dumped)&quot; or &quot;Killed&quot;. It can do this because at the OS/kernel level, the UNIX wait status is a two-byte field. There are eight bits (not seven!) for the argument to <code>exit</code> (or, equivalently, the return value of <code>main</code>), seven bits for the signal, and one bit for whether core was dumped. If the signal field is zero, then the process exited normally and the exit status field is meaningful; otherwise the signal field is meaningful. (There are a few more variants of interpreting the 16-bit exit status field if a process is stopped without exiting or continued from being stopped; they aren&#x27;t particularly relevant here, I think.)</p>
<p>In practice, this produces the bug that <code>uv run python</code> etc. differs from directly running <code>python</code> if the process terminates with a signal, because to the shell, <code>uv</code> appears to <em>exit normally with an exit code over 128</em> as opposed to exiting with a signal:</p>
<pre><code>$ cat segfault.py
import ctypes
ctypes.CDLL(&quot;&quot;).strlen(1)
$ `uv python find` segfault.py
Segmentation fault (core dumped)
$ echo $?
139
$ uv run --script segfault.py
$ echo $?
139
</code></pre>
<p>So it&#x27;s very hard for a user to tell that their process died with a segfault (or whatever other signal). Compare with this case where there is no segfault at all:</p>
<pre><code>$ cat not-segfault.py 
import sys
sys.exit(139)
$ `uv python find` not-segfault.py 
$ echo $?
139
$ uv run --script not-segfault.py 
$ echo $?
139
</code></pre>
<p>I think we should, roughly, raise that <code>debug!</code> to a normal eprintln, and print the string form (as returned by <a href="https://man7.org/linux/man-pages/man3/strsignal.3.html">strsignal(3)</a>, maybe via <a href="https://docs.rs/nix/latest/nix/sys/signal/enum.Signal.html#method.try_from"><code>nix::sys::signal::Signal</code></a>&#x27;s <code>try_from</code> and <code>as_str</code>, defaulting to <code>&quot;Signal {signal}&quot;</code> if the signal is somehow unknown) and append <code>&quot; (core dumped)&quot;</code> if <code>status.core_dumped()</code>. This would provide analogous behavior to the shell. (Or alternatively we can pass the full <code>ExitStatus</code> back to <code>main()</code> and put the signal-printing logic there, or something.)</p>
<p>It is a little unfortunate that if the user is calling from <em>not</em> a shell, they&#x27;ll get an extra line to stderr that they wouldn&#x27;t need, plus they&#x27;ll see a normal exit instead of a signal exit from <code>uv</code>. But honestly I think that&#x27;s fineâ€”I can&#x27;t think of a situation in practice where this would be terrible. The only real way to avoid this would be either to exec the target process instead of starting it as a child (I assume there&#x27;s a good reason why we don&#x27;t) or to artificially signal ourselves with the same signal (which I think would be misleading, in that it would make users try to figure out why <code>uv</code> segfaulted when it didn&#x27;t).</p>
<p>(Originally reported in Discord #help thread <a href="https://discord.com/channels/1039017663004942429/1344953548533923870/1344953548533923870">&quot;coverage segfaults, does uv swallow it ?&quot;</a>.)</p>
Platform
<p>UNIX</p>
Version
<p>HEAD (8dd079f2ad530a8e5c91822f967f0ba140e4ec0a)</p>
Python version
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/geofft">@geofft</a> on 2025-03-01 22:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-02 01:09</div>
            <div class="timeline-body"><p>cc @konstin who recently changed this to resolve <a href="https://github.com/astral-sh/uv/issues/10751">astral-sh/uv#10751</a></p>
<p>Discussion on using exec in <a href="https://github.com/astral-sh/uv/issues/3095">astral-sh/uv#3095</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">great writeup</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2025-03-02 01:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-03-03 15:14</div>
            <div class="timeline-body"><blockquote>
<p>The only real way to avoid this would be either to exec the target process instead of starting it as a child (I assume there&#x27;s a good reason why we don&#x27;t) or to artificially signal ourselves with the same signal (which I think would be misleading, in that it would make users try to figure out why uv segfaulted when it didn&#x27;t).</p>
</blockquote>
<p>Does this mean that even though we have <code>[[noreturn]] void exit(int status);</code>, there is no way to set the signal + code dumped byte ourselves on exit to get the shell handling as if we had <code>execve</code>&#x27;d?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/geofft">@geofft</a> on 2025-03-03 16:07</div>
            <div class="timeline-body"><blockquote>
<p>Does this mean that even though we have <code>[[noreturn]] void exit(int status);</code>, there is no way to set the signal + code dumped byte ourselves on exit to get the shell handling as if we had <code>execve</code>&#x27;d?</p>
</blockquote>
<p>Correct, there is no way unless you count <code>raise(SIGSEGV)</code> (i.e., <code>kill(getpid(), SIGSEGV)</code>).</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:37:34 UTC
    </footer>
</body>
</html>
