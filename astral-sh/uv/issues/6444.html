<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prefer `python` in a later PATH entry over `pythonX.Y` in an earlier entry  - astral-sh/uv #6444</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Prefer `python` in a later PATH entry over `pythonX.Y` in an earlier entry </h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/6444">#6444</a>
        opened by <a href="https://github.com/zanieb">@zanieb</a>
        on 2024-08-22 15:27
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-22 15:27</div>
            <div class="timeline-body"><p>Originally discussed at https://github.com/astral-sh/uv/issues/6348#issuecomment-2304993544</p>
<blockquote>
<p>While I don't think it's necessary for the documentation to give every detail of the discovery process, this presumes that discovery is intuitive - and IMO, defaulting to an older version of Python when there's no python command on the PATH (and hence no &quot;default Python&quot; at the command line) is not intuitive. I don't think the existence of python3.x on PATH should ever influence the decision on what the default Python version should be - by having an explicit version in the executable name, it's by definition not used as a default...</p>
</blockquote>
<p>I think the problem is we look for all valid Python executable names on the PATH one directory at a time. Instead, <code>pythonX.Y</code> should only be used if we can't find any Python executable on the PATH with the name <code>python</code> or <code>python3</code> <em>or</em> if you specifically request <code>--python X.Y</code>. This will be a little tricky to do in a performant manner, i.e., we don't want to list and parse the members of the directories on the PATH repeatedly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @zanieb on 2024-08-22 15:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">uv python</span> added by @zanieb on 2024-08-22 15:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">breaking</span> added by @zanieb on 2024-08-22 15:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-22 15:28</div>
            <div class="timeline-body"><p>Arguably a breaking change.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abitrolly">@abitrolly</a> on 2024-12-09 16:56</div>
            <div class="timeline-body"><p>For troubleshooting issues it is better to have well-defined logic:</p>
<ul>
<li>Look for <code>python</code>.</li>
<li>If not found, look for <code>python3</code>.</li>
</ul>
<p>Also, where is the performance problem here?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-09 18:28</div>
            <div class="timeline-body"><blockquote>
<p>For troubleshooting issues it is better to have well-defined logic:</p>
</blockquote>
<p>We do have well-defined logic: look for compatible Python executables in each directory on the <code>PATH</code>, in-order, taking the first match.</p>
<blockquote>
<p>Also, where is the performance problem here?</p>
</blockquote>
<p>We would need to list <em>every</em> directory on the <code>PATH</code> instead of just the first one to discover <code>python3</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abitrolly">@abitrolly</a> on 2024-12-10 05:25</div>
            <div class="timeline-body"><blockquote>
<p>We do have well-defined logic: look for compatible Python executables in each directory on the PATH, in-order, taking the first match.</p>
</blockquote>
<p>Okay, well-established may sound better. For me well established logic for shell scripts is to check <code>type python</code> (or <code>which python</code>), then <code>type python3</code>. But not <code>in each dir</code> look for <code>python</code> or <code>python3</code>.</p>
<blockquote>
<p>We would need to list every directory on the PATH instead of just the first one to discover python3.</p>
</blockquote>
<p>And what is the performance loss here? Also, how different would it be to call <code>type python</code> instead of manual search?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wtfzambo">@wtfzambo</a> on 2025-02-13 12:19</div>
            <div class="timeline-body"><p>I agree that the current system might cause unwanted behaviors. For instance, I use <code>brew</code>, which installs its own python executables when you download a formula, but <code>asdf</code> as a global package manager.</p>
<p>I want uv to use <code>asdf</code> installed python when I run <code>uv venv</code>, but instead it ends up using the brew one as they come before on the list:</p>
<pre><code class="language-bash">‚ùØ uv python list
cpython-3.14.0a4+freethreaded-macos-aarch64-none    &lt;download available&gt;
cpython-3.14.0a4-macos-aarch64-none                 &lt;download available&gt;
cpython-3.13.1+freethreaded-macos-aarch64-none      &lt;download available&gt;
cpython-3.13.1-macos-aarch64-none                   /opt/homebrew/opt/python@3.13/bin/python3.13 -&gt; ../Frameworks/Python.framework/Versions/3.13/bin/python3.13
cpython-3.13.1-macos-aarch64-none                   &lt;download available&gt;
cpython-3.12.8-macos-aarch64-none                   /opt/homebrew/opt/python@3.12/bin/python3.12 -&gt; ../Frameworks/Python.framework/Versions/3.12/bin/python3.12
cpython-3.12.8-macos-aarch64-none                   &lt;download available&gt;
cpython-3.11.11-macos-aarch64-none                  &lt;download available&gt;
cpython-3.11.10-macos-aarch64-none                  /opt/homebrew/opt/python@3.11/bin/python3.11 -&gt; ../Frameworks/Python.framework/Versions/3.11/bin/python3.11
cpython-3.11.7-macos-aarch64-none                   /Users/wtfzambo/.asdf/installs/python/3.11.7/bin/python3.11
cpython-3.11.7-macos-aarch64-none                   /Users/wtfzambo/.asdf/installs/python/3.11.7/bin/python3 -&gt; python3.11
cpython-3.11.7-macos-aarch64-none                   /Users/wtfzambo/.asdf/installs/python/3.11.7/bin/python -&gt; python3.11
...
</code></pre>
<p>The current workaround for me is to run <code>venv</code> like this</p>
<pre><code class="language-bash">uv venv --python=$(asdf where python)
</code></pre>
<p>Or alternatively, to set <code>UV_PYTHON</code> env variable. Not game breaking, but a bit inconvenient for sure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hauntsaninja">@hauntsaninja</a> on 2025-08-03 03:11</div>
            <div class="timeline-body"><p>Saw you link this issue from elsewhere, I think this could make sense! pyright prefers pythonX.Y in earlier entry and that caused confusion at work earlier this week</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:35:07 UTC
    </footer>
</body>
</html>
