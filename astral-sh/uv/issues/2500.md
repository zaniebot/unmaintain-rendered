```yaml
number: 2500
title: "`uv pip list` does not read all system packages in `sys.path` and ignores `system-site-packages`"
type: issue
state: open
author: danielhollas
labels:
  - bug
  - compatibility
assignees: []
created_at: 2024-03-17T21:18:44Z
updated_at: 2025-10-15T13:00:22Z
url: https://github.com/astral-sh/uv/issues/2500
synced_at: 2026-01-10T01:57:05Z
```

# `uv pip list` does not read all system packages in `sys.path` and ignores `system-site-packages`

---

_Issue opened by @danielhollas on 2024-03-17 21:18_

Executing `uv pip list --system` does not list any packages. Similarly for `freeze` and `show` subcommands (I did not test any others).

```console
$ uv pip list --system -vv
 uv_interpreter::find_python::find_default_python 
      0.000148s   0ms DEBUG uv_interpreter::find_python Starting interpreter discovery for default Python
      0.000319s   0ms DEBUG uv_interpreter::interpreter Cached interpreter info for Python 3.12.2, skipping probing: /usr/bin/python3
    0.000334s DEBUG uv::commands::pip_list Using Python 3.12.2 environment at /usr/bin/python3
```

OS: Fedora 39, python 3.12, amd64
uv version: 0.1.21, installed via pipx

---

_Label `compatibility` added by @charliermarsh on 2024-03-17 21:26_

---

_Comment by @charliermarsh on 2024-03-17 21:28_

Can you just confirm for me what packages should appear, and where they're located?

---

_Comment by @danielhollas on 2024-03-17 22:07_

```
‚ùØ pip show pip
Name: pip
Version: 23.2.1
Summary: The PyPA recommended tool for installing Python packages.
Home-page: https://pip.pypa.io/
Author: The pip developers
Author-email: distutils-sig@python.org
License: MIT
Location: /usr/lib/python3.12/site-packages
```

```console
$ pip list
‚ùØ pip list 
Package            Version
------------------ ---------
argcomplete        2.0.0
Beaker             1.12.1
beautifulsoup4     4.12.3
blivet             3.8.2
blivet-gui         2.5.0
blurb              1.1.0
Brlapi             0.8.5
cffi               1.15.1
cfgv               3.4.0
charset-normalizer 3.2.0
click              8.1.3
colorama           0.4.6
ConfigArgParse     1.7
configobj          5.0.8
cryptography       41.0.7
cupshelpers        1.0
dasbus             1.7
dbus-python        1.3.2
distlib            0.3.7
distro             1.8.0
dnf                4.19.0
fedora-third-party 0.10
file-magic         0.4.0
filelock           3.13.1
fros               1.1
humanize           3.13.1
identify           2.5.33
idna               3.4
iniconfig          2.0.0
langtable          0.0.65
lexid              2021.1006
libcomps           0.1.20
libdnf             0.73.0
looseversion       1.3.0
lxml               4.9.3
Mako               1.2.3
MarkupSafe         2.1.3
nftables           0.1
nodeenv            1.8.0
olefile            0.46
packaging          23.1
Paste              3.5.3
pexpect            4.8.0
pid                2.2.3
pillow             10.2.0
pip                23.2.1
pipx               1.3.3
platformdirs       4.1.0
pluggy             1.3.0
ply                3.11
productmd          1.38
psutil             5.9.5
ptyprocess         0.7.0
pwquality          1.4.5
pycairo            1.25.1
pycparser          2.20
pycrypto           2.6.1
pycups             2.0.1
pycurl             7.45.2
PyGObject          3.46.0
pykickstart        3.48
pyOpenSSL          23.2.0
pyparted           3.13.0
PySocks            1.7.1
python-augeas      1.1.0
python-dateutil    2.8.2
python-meh         0.51
pyudev             0.24.1
PyYAML             6.0.1
requests           2.28.2
requests-file      1.5.1
requests-ftp       0.3.1
rpm                4.19.1.1
ruff               0.2.2
selinux            3.5
sepolicy           3.5
setools            4.4.3
setuptools         67.7.2
simpleline         1.9.0
six                1.16.0
sos                4.6.0
soupsieve          2.5
systemd-python     235
Tempita            0.5.2
terminator         2.1.3
tuna               0.5.11
urllib3            1.26.18
userpath           1.9.1
virtualenv         20.25.0
```

(Note that pip list also list user packages in `~/.local`), which one can filter out

```console
$ pip list --user
Package        Version
-------------- ---------
blurb          1.1.0
cfgv           3.4.0
colorama       0.4.6
ConfigArgParse 1.7
distlib        0.3.7
filelock       3.13.1
identify       2.5.33
iniconfig      2.0.0
lexid          2021.1006
looseversion   1.3.0
nodeenv        1.8.0
pipx           1.3.3
platformdirs   4.1.0
pluggy         1.3.0
ruff           0.2.2
tuna           0.5.11
userpath       1.9.1
virtualenv     20.25.0
```

---

_Comment by @ChannyClaus on 2024-03-19 00:07_

i can probably look into this sometime this week (maybe weekend) unless someone else is already on it :.)

---

_Comment by @danielhollas on 2024-03-19 20:37_

So testing with uv version < 0.1.19 actually reveals the error:

```
$ uv pip list -v --system
 uv_interpreter::python_query::find_default_python 
      0.003337s   0ms DEBUG uv_interpreter::python_query Starting interpreter discovery for default Python
      0.003421s   0ms DEBUG uv_interpreter::interpreter Cached interpreter info for Python 3.12.2, skipping probing: /usr/bin/python3
    0.003433s DEBUG uv::commands::pip_list Using Python 3.12.2 environment at /usr/bin/python3
error: failed to read directory `/usr/local/lib/python3.12/site-packages`
  Caused by: No such file or directory (os error 2)
```

Directory `/usr/local/lib/python3.12/site-packages` indeed does not exist, uv should be looking into `/usr/lib/python3.12/site-packages`. LMK if I can provide more info to debug this.

So I believe this should be labeled as "bug" not "compatibility".

I believe the error is hidden in 0.1.19 above due to #2413

---

_Comment by @danielhollas on 2024-03-19 20:40_

The error appears all the way in version 0.1.12 which introduced the system flag so this does not appear to be a regression in the original implementation.

---

_Comment by @charliermarsh on 2024-03-19 20:42_

If you actually install something with `uv`, it is listed when you run `uv pip list`?

My guess is that `/usr/local/lib/python3.12/site-packages` _is_ the correct location in which to install packages, and that's where we look. But we don't look at all the entries in `sys.path`, which may include `/usr/lib/python3.12/site-packages`.

---

_Comment by @charliermarsh on 2024-03-19 20:54_

(To summarize, I think the fix here is to iterate over `sys.paths` (probably) instead of just looking at `purelib` and `platlib`.)

---

_Comment by @danielhollas on 2024-03-19 20:56_

Indeed, installing something into system packages will install it to `/usr/local/lib`

```console
$ sudo uv pip install tuna --system
Resolved 1 package in 261ms
Downloaded 1 package in 99ms
Installed 1 package in 3ms
 + tuna==0.5.11

$ uv pip list
Package Version
------- -------
tuna    0.5.11

$ uv pip show tuna
Name: tuna
Version: 0.5.11
Location: /usr/local/lib/python3.12/site-packages
Requires:
```

Here's how the site directories are configured in my Python (Fedora 39)

```python
$ python -c "import site;print(site.getsitepackages())"
['/usr/local/lib64/python3.12/site-packages', '/usr/local/lib/python3.12/site-packages', '/usr/lib64/python3.12/site-packages', '/usr/lib/python3.12/site-packages']
```

> (To summarize, I think the fix here is to iterate over sys.paths (probably) instead of just looking at purelib and platlib.)

Yep, that seems to be the case.


---

_Label `bug` added by @charliermarsh on 2024-03-19 20:57_

---

_Comment by @danielhollas on 2024-03-19 21:07_

I've just checked that installing a package that already exist in `/usr/lib` will install it to `/usr/local/lib/` but keeps the original there, so it's possible for a single package to be in multiple places and have multiple versions. So while iterating uv needs to take into account the precedence rules correctly (I guess whatever is first in the `getsitepackages` list gets to win?

---

_Comment by @charliermarsh on 2024-03-19 21:14_

I think pip would list both in that case, right?

---

_Comment by @danielhollas on 2024-03-19 21:38_

Nope, pip will (correctly imo) only show that which will be actually used when imported in the interpreter. e.g. Things installed in `/usr/local/lib` take precedence before `/usr/lib`. (I verified this).

Note that the same logic applies to stuff installed in `~/.local`. Those take precedence in the interpreter, and pip will show them instead of system packages.

---

_Comment by @charliermarsh on 2024-03-19 21:59_

I don't really agree with that decision, but good to know, thank you!

---

_Renamed from "uv pip list / freeze / show --system do not show system packages" to "uv pip list / freeze / show --system do not show system packages on Fedora" by @danielhollas on 2024-03-20 02:57_

---

_Comment by @ChannyClaus on 2024-03-23 17:38_

confirmed making the change below
```
pub fn site_packages(&self) -> impl Iterator<Item = &Path> {
        let mut paths = vec![
            self.interpreter.purelib(),
            self.interpreter.platlib(),
            Path::new(self.root()),
            // Path::new("blah")
        ];
        paths.dedup();
        paths.into_iter()
    }
```
(replace `blah` with other paths in `sys.path`, which can be built with `interpreter.prefix()`and others) fixes the issue, but having some trouble with path adjoining + borrowing, will continue to look.

---

_Comment by @charliermarsh on 2024-03-23 17:45_

We may need to return all of sys.path from get_interpreter_info to make this work as expected?

---

_Comment by @ChannyClaus on 2024-03-23 17:50_

> We may need to return all of sys.path from get_interpreter_info to make this work as expected?

oh dang, that's a very helpful pointer (i should've looked where these interpreter-specific values were coming from :.)), yah that would do it, let me try that out.

---

_Referenced in [astral-sh/uv#2636](../../astral-sh/uv/pulls/2636.md) on 2024-03-23 19:17_

---

_Comment by @ChannyClaus on 2024-04-01 03:07_

after spending a little too much effort and time i've noticed that this may have already been fixed by some other change...? (`requests`, which is installed by `pip` for system python seems to get picked up by `uv` via `--system` flag)
```
$ docker run -v $(pwd)/test.sh:/test.sh --entrypoint=bash  fedora:39 test.sh 
Package  Version  Location                                  Installer
-------- -------- ----------------------------------------- ---------
dnf      4.18.2   /usr/lib/python3.12/site-packages
libcomps 0.1.20   /usr/lib64/python3.12/site-packages
libdnf   0.72.0   /usr/lib64/python3.12/site-packages
pip      23.2.1   /usr/local/lib/python3.12/site-packages   pip
rpm      4.19.1.1 /usr/lib64/python3.12/site-packages
uv       0.1.26   /usr/local/lib64/python3.12/site-packages pip

[notice] A new release of pip is available: 23.2.1 -> 24.0
[notice] To update, run: python3 -m pip install --upgrade pip
uv 0.1.26
Package Version
------- -------
pip     23.2.1
uv      0.1.26
Package            Version
------------------ --------
certifi            2024.2.2
charset-normalizer 3.3.2
idna               3.6
pip                23.2.1
requests           2.31.0
urllib3            2.2.1
uv                 0.1.26
```
where
```
$ cat test.sh 
python3 -m ensurepip &> /dev/null
pip3 install uv &> /dev/null

pip3 list --verbose

uv --version
uv pip list --system

pip3 install requests &> /dev/null

uv pip list --system

```
@danielhollas can you take a look to see if i'm delirious or this has indeed been fixed ü¶Ä 

the change i've been working on which uses `sys.path` (thanks again charlie for that pointer!) does pick up a bit more but may be somewhat unnecessary since all packages installed by pip seem to already be picked up without it (below is the snippet _with_ the `sys.path` change, where `uv` picks up `dnf` and `libdnf`, which are not picked up with the latest version of `uv`).
```
bash-5.2# ./uv pip list --system --verbose
DEBUG Starting interpreter discovery for default Python
DEBUG Cached interpreter info for Python 3.12.1, skipping probing: /usr/bin/python3
DEBUG Using Python 3.12.1 environment at /usr/bin/python3
DEBUG Site packages: ["/usr/local/lib/python3.12/site-packages", "/usr/local/lib64/python3.12/site-packages", "/usr/lib64/python3.12/site-packages", "/usr/lib/python3.12/site-packages"]
Package Version
------- -------
dnf     4.18.2
libdnf  0.72.0
pip     23.2.1
uv      0.1.26
bash-5.2# pip3 list --verbose
Package  Version  Location                                  Installer
-------- -------- ----------------------------------------- ---------
dnf      4.18.2   /usr/lib/python3.12/site-packages
libcomps 0.1.20   /usr/lib64/python3.12/site-packages
libdnf   0.72.0   /usr/lib64/python3.12/site-packages
pip      23.2.1   /usr/local/lib/python3.12/site-packages   pip
rpm      4.19.1.1 /usr/lib64/python3.12/site-packages
uv       0.1.26   /usr/local/lib64/python3.12/site-packages pip
```


---

_Comment by @danielhollas on 2024-04-01 10:48_

@ChannyClaus thanks for the ping. I've tested with `uv` 0.1.26 and it doesn't seem to be fixed.
I am using uv installed with pipx, I wonder if that makes a difference?

---

_Comment by @ChannyClaus on 2024-04-02 04:05_

hmm it still seems to pick up the packages?
```
$  docker run -v $(pwd)/test.sh:/test.sh --entrypoint=bash  fedora:39 test.sh 
Package      Version  Location                                Installer
------------ -------- --------------------------------------- ---------
argcomplete  2.0.0    /usr/lib/python3.12/site-packages
click        8.1.3    /usr/lib/python3.12/site-packages       rpm
dnf          4.18.2   /usr/lib/python3.12/site-packages
libcomps     0.1.20   /usr/lib64/python3.12/site-packages
libdnf       0.72.0   /usr/lib64/python3.12/site-packages
packaging    23.1     /usr/lib/python3.12/site-packages       rpm
pip          23.2.1   /usr/local/lib/python3.12/site-packages pip
pipx         1.4.3    /usr/lib/python3.12/site-packages       rpm
platformdirs 3.9.1    /usr/lib/python3.12/site-packages       rpm
rpm          4.19.1.1 /usr/lib64/python3.12/site-packages
userpath     1.9.2    /usr/lib/python3.12/site-packages       rpm

[notice] A new release of pip is available: 23.2.1 -> 24.0
[notice] To update, run: python3 -m pip install --upgrade pip
uv 0.1.27
Package Version
------- -------
pip     23.2.1
Package            Version
------------------ --------
certifi            2024.2.2
charset-normalizer 3.3.2
idna               3.6
pip                23.2.1
requests           2.31.0
urllib3            2.2.1
```
where
```
$ cat test.sh 
python3 -m ensurepip &> /dev/null

yum install pipx -y &> /dev/null
pipx install uv &> /dev/null
export PATH=/root/.local/bin:$PATH

pip3 list --verbose

uv --version
uv pip list --system

pip3 install requests &> /dev/null

uv pip list --system
```
do you have more details around your setup? it would be ideal if you have a small reproducible example end-to-end

---

_Comment by @danielhollas on 2024-04-02 13:52_

Hmm, strange. I am running directly on Fedora 39, I am wondering if there are some differences between Fedora 39 Docker image and normal install. Also in your case you're running under root, not sure if that makes a difference. I'll try to dig around a bit more.

---

_Comment by @danielhollas on 2024-04-22 21:23_

I failed to make progress here due to lack of any useful logging from `uv` on this problem. My plan was to dive into the code and add some logging myself, but I could not get passed the cargo build due to some missing dependencies (apparently, building one of the openssl crates requires perl, which is not installed in Fedora by default. I could install it if it didn't bring with it a gazilion of other dependencies :sob: ).

tl;dr It would be helpful to me if somebody could add logging to print which paths uv is looking at when running `uv pip list / show/ freeze`. This would be very useful for other commands as well, see also related #2155 

---

_Comment by @ChannyClaus on 2024-04-22 21:39_

> I failed to make progress here due to lack of any useful logging from `uv` on this problem. My plan was to dive into the code and add some logging myself, but I could not get passed the cargo build due to some missing dependencies (apparently, building one of the openssl crates requires perl, which is not installed in Fedora by default. I could install it if it didn't bring with it a gazilion of other dependencies üò≠ ).
> 
> tl;dr It would be helpful to me if somebody could add logging to print which paths uv is looking at when running `uv pip list / show/ freeze`. This would be very useful for other commands as well, see also related #2155

maybe the snippet from description in https://github.com/astral-sh/uv/pull/2636#issue-2204011586 would help? (more specifically `RUN yum install pip python cmake perl rust cargo -y`)

seems like the issue linked may not be completely green-lit but if/once it's green-lit i could maybe take on it?

---

_Referenced in [astral-sh/uv#3341](../../astral-sh/uv/issues/3341.md) on 2024-05-03 15:08_

---

_Comment by @danielhollas on 2024-05-10 01:32_

Note for future self: Turns out one can install only specific perl modules, and not the whole perl metapackage. I ended up doing:

```
sudo dnf install perl-File-Copy perl-File-Compare perl-IPC-Cmd perl-FindBin
```

---

_Renamed from "uv pip list / freeze / show --system do not show system packages on Fedora" to "uv pip list / freeze / show --system do not show all system packages on Fedora" by @danielhollas on 2024-05-10 02:17_

---

_Comment by @danielhollas on 2024-05-10 02:32_

> @danielhollas can you take a look to see if i'm delirious or this has indeed been fixed ü¶Ä

@ChannyClaus to clarify, this has always worked. :-) In other words, this issue is about uv ignoring Fedora system packages that come with the Fedora installation, which are in a different directory from system packages installed by the user. (I am assuming they are doing this to prevent users from messing up the system python install).

> the change i've been working on which uses sys.path (thanks again charlie for that pointer!) does pick up a bit more but may be somewhat unnecessary since all packages installed by pip seem to already be picked up without it (below is the snippet with the sys.path change, where uv picks up dnf and libdnf, which are not picked up with the latest version of uv).

I'd still argue that uv should list all the packages that are available to the Python interpreter. 

I noticed the following help text for the `uv venv --system-site-packages`

```
 --system-site-package
   Give the virtual environment access to the system site packages directory.
          
   Unlike `pip`, when a virtual environment is created with `--system-site-packages`, 
   `uv` will _not_ take system site packages into account when running commands 
   like `uv pip list` or `uv pip install`. 
   The `--system-site-packages` flag will provide the virtual environment
   with access to the system site packages directory at runtime, 
   but it will not affect the behavior of `uv` commands.
```

This is very much the same issue as here, but from the text it is not clear whether this was a conscious design decision or just stating the current limitation. If the former I'd argue to reconsider. As an example, in HPC context, admins may provide a base Python environment with basic scientific packages (numpy et al) compiled specifically for the machine to get the best performance. In this case, it would be quite wrong for uv to ignore these packages and reinstall them inside the venv.

---

_Referenced in [astral-sh/uv#3500](../../astral-sh/uv/pulls/3500.md) on 2024-05-10 03:15_

---

_Closed by @konstin on 2024-05-10 06:41_

---

_Reopened by @konstin on 2024-05-10 07:05_

---

_Referenced in [astral-sh/uv#4434](../../astral-sh/uv/issues/4434.md) on 2024-06-21 22:14_

---

_Referenced in [astral-sh/uv#4466](../../astral-sh/uv/issues/4466.md) on 2024-06-24 14:47_

---

_Comment by @ncoghlan on 2024-06-25 17:12_

I just ran into a variant of this problem when working with layered environments that use `sitecustomize.py` to incorporate additional shared folders: when `uv` is installing into the upper environments, it fails to detect the packages that are already installed in the lower layers. (My use case is along the same lines as the HPC use case above: shared layers with big dependencies preinstalled, then smaller application environments built on top of that)

I initially thought it was working correctly because `uv pip install` is so much faster than `pip install`, but the problem became clear when archiving the upper layers slowed down dramatically (unexpectedly including additional copies of `torch` and `nvidia-cuda` in an archive is... not great).

Between `*.pth` files and `sitecustomize.py`, the only reliable way to find out what packages a Python environment can currently see installed is to ask it for its `sys.path` value and scan every entry in order, it simply isn't correct to assume that the only directories that matter are the ones where installation tools are told to put *new* components.

Running `python -m site` is a useful way of dumping the relevant `sys.path` info when investigating problems along these lines (although `python -c "import sys; print(sys.path)"` is better for programmatic use, as was done in #3500).

Using `sitecustomize.py` files to reproduce the problem should be much easier to manage in test cases than relying specifically on Linux distro Python builds that add extra directories to `sys.path`.

I don't advise trying to use `*.pth` files (even in test cases), since they have problems dealing with non-ASCII paths in Python versions prior to 3.13.

Edit: for anyone curious, the specific environment layering project referred to here is https://pypi.org/project/venvstacks/

---

_Comment by @paveldikov on 2024-08-16 16:54_

I just commented on #4466 as well, but @danielhollas and @ncoghlan's use cases resonate with me as well -- layered (and in my case, redistributable) virtual environments containing heavyweight packages such as torch and tensorflow.

Considering that #3500 is merged, is it fair to assume that a solution to this would come at essentially zero performance cost, since `sys.path` is already being evaluated as part of `get_interpreter_info`?

---

_Comment by @ChannyClaus on 2024-08-16 19:52_

> I just commented on #4466 as well, but @danielhollas and @ncoghlan's use cases resonate with me as well -- layered (and in my case, redistributable) virtual environments containing heavyweight packages such as torch and tensorflow.
> 
> Considering that #3500 is merged, is it fair to assume that a solution to this would come at essentially zero performance cost, since `sys.path` is already being evaluated as part of `get_interpreter_info`?

i think you're right about the performance bit, but the tricky part (at least based on the last time i gave this a try) is to make this change without breaking the existing tests... it's possible some of the breaking tests need to be changed but it's quite risky to make changes to tests especially when it's not obviously correct to do so; additionally, this particular issue seemed to be less pressing / critical compared to some other reported issues.

---

_Comment by @paveldikov on 2024-08-20 23:07_

With regards to the test suite -- could this be as simple as changing the test fixture(s) to create the venvs with `system_site_packages = false`?

(otherwise I definitely see how this can make tests brittle -- if not even non-portable -- assuming that the contents of the interpreter-wide `site-packages` is globally consistent is probably unrealistic to begin with?)

---

_Comment by @zanieb on 2024-08-20 23:42_

>  assuming that the contents of the interpreter-wide site-packages is globally consistent is probably unrealistic...

Yeah we can't do this.. we'd need to have a fake system interpreter available in the test context. We'd probably only have a small subset of test cases include handling packages in the "system" interpreter ‚Äî the rest would be fully isolated. This is more likely to cause problems in the test suite when run by downstream packagers rather than here where we have full control over the CI environment.

---

_Comment by @ncoghlan on 2024-08-27 10:18_

For the test suite, I'd recommend testing the `sitecustomize.py` case rather than the `system-site-packages` case:

1. Create a pair of regular (isolated) virtual environments (called "A" and "B" below)
2. In environment B, inject a `sitecustomize.py` file into `site-packages` that uses `site.addsitedir` to integrate the `site-packages` folder from environment A into environment B
3. Write the test cases to manipulate environment B ensuring that:
  * `list`/`show`/`freeze` can see the packages in both environments 
  * if an installation request or dependency is already satisfied in environment A, it doesn't get installed into B
  * if a package is upgraded in environment B, it is installed into B *without* attempting to uninstall it from A
  * attempting to remove a package that is only present in A via environment B fails (<-- I haven't actually checked how `pip uninstall` handles this case, but refusing to uninstall seems preferable no matter what `pip` does) 

If that works as described, a venv with system-site-packages enabled should also work (without the hassle of trying to make tests that enable system-site-packages portable across different Python installations).

---

_Comment by @sbidoul on 2024-09-14 12:40_

I hit this today as I wanted to prepare a demo using uv for an upcoming talk.

My use case is using a ubuntu:jammy / python 3.10 based docker image having heavy dependencies pre-installed in the system python.

I was hoping to create a `--system-site-packages` venv and start from there but it does not work as uv does not detect system packages from that venv (whereas pip does).

```
/app $ .venv/bin/python
Python 3.10.12 (main, Jul 29 2024, 16:56:48) [GCC 11.4.0] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import sys
>>> sys.path
['', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/app/.venv/lib/python3.10/site-packages', '/usr/local/lib/python3.10/dist-packages', '/usr/lib/python3/dist-packages', '/usr/lib/python3.10/dist-packages']
>>> import sysconfig
>>> sysconfig.get_paths()
{'stdlib': '/usr/lib/python3.10', 'platstdlib': '/app/.venv/lib/python3.10', 'purelib': '/app/.venv/lib/python3.10/site-packages', 'platlib': '/app/.venv/lib/python3.10/site-packages', 'include': '/usr/include/python3.10', 'platinclude': '/usr/include/python3.10', 'scripts': '/app/.venv/bin', 'data': '/app/.venv'}
>>> 

/app $ uv pip list
Package   Version Editable project location
--------- ------- -------------------------
myproject 1.0     /app
pip       24.2

/app $ .venv/bin/python -m pip list
... long list of packages from /usr/lib/python3/dist-packages
```


---

_Comment by @paveldikov on 2024-09-17 10:17_

> (at least based on the last time i gave this a try)

@ChannyClaus do you happen to have a draft PR/commit ref handy for this? If you have the logic side of the change ready to go, I'd be more than happy to give the test suite a whirl :-)

---

_Comment by @ChannyClaus on 2024-09-17 13:33_

> > (at least based on the last time i gave this a try)
> 
> @ChannyClaus do you happen to have a draft PR/commit ref handy for this? If you have the logic side of the change ready to go, I'd be more than happy to give the test suite a whirl :-)

things may have changed significantly since this was months ago but the main change necessary was https://github.com/astral-sh/uv/pull/2636/files#diff-f29dcb297374a7babe6be50ec410d36c52cb44c6e9ec5183b4b7d0b96229bd94R94-R109 i believe üåµ 

---

_Comment by @mansenfranzen on 2024-10-10 10:46_

I can confirm that this issue also exists on Databricks Runtime Images that are based on Ubuntu. The `uv pip freeze --python=<path-to-python-bin>` only displays few packages while `pip freeze` shows all available packages for the same python executable.

---

_Referenced in [astral-sh/uv#9174](../../astral-sh/uv/issues/9174.md) on 2024-11-18 00:39_

---

_Referenced in [astral-sh/uv#9849](../../astral-sh/uv/pulls/9849.md) on 2024-12-12 19:14_

---

_Referenced in [astral-sh/uv#11392](../../astral-sh/uv/issues/11392.md) on 2025-02-10 17:34_

---

_Renamed from "uv pip list / freeze / show --system do not show all system packages on Fedora" to "`uv pip` does not read all system packages (e.g., in `uv pip list --system` or virtual environments with `system-site-packages`)" by @zanieb on 2025-02-10 17:52_

---

_Referenced in [astral-sh/uv#11601](../../astral-sh/uv/pulls/11601.md) on 2025-02-18 15:43_

---

_Referenced in [astral-sh/uv#11622](../../astral-sh/uv/pulls/11622.md) on 2025-02-19 15:21_

---

_Referenced in [astral-sh/uv#11670](../../astral-sh/uv/pulls/11670.md) on 2025-03-05 17:04_

---

_Referenced in [astral-sh/uv#12800](../../astral-sh/uv/issues/12800.md) on 2025-04-10 11:07_

---

_Referenced in [astral-sh/uv#2038](../../astral-sh/uv/issues/2038.md) on 2025-04-15 09:15_

---

_Referenced in [lmstudio-ai/venvstacks#146](../../lmstudio-ai/venvstacks/issues/146.md) on 2025-04-28 14:21_

---

_Referenced in [lmstudio-ai/venvstacks#144](../../lmstudio-ai/venvstacks/issues/144.md) on 2025-05-07 05:49_

---

_Comment by @ncoghlan on 2025-08-15 14:15_

@konstin Given the difficulties with solving this issue in a systemic way that you're happy with, might it be feasible to instead provide an opt-in command line flag (something like `--skip-installed`) specifically for `uv pip install`?

At least for `venvstacks`, the environments are write-only (manipulating them post installation isn't supported), so a solution that *only* considers the external paths at installation time, and solely for the purpose of building a list of packages that don't need to be installed (but have an implied version pin to their already installed version) would be entirely sufficient for my use case.

So given `uv pip install --skip-installed -r requirements.txt` the full path would be used to get the list of version pins for already installed components, failing the installation if something needed a newer or older version. `uninstall` and `sync` wouldn't need to support the new flag at all.

---

_Comment by @konstin on 2025-08-19 11:43_

For venvstack, is the tool running uv or the user? In the case of the tool running it, is it possible to hack this using `uv pip freeze` as constraints during resolution and with as elimination-overrides during installation (setting a `sys_platform == "never"` or `python_version < "0"` marker on all the packages that are already installed and passing them as overrides file during installation so that the packages are skipped).

---

_Comment by @danielhollas on 2025-08-19 11:54_

`uv pip freeze` might not be best for this, since as the OP describes it might not correctly pick all of the packages in the (layered) environments. `pip freeze` would be safer I guess.

---

_Comment by @konstin on 2025-08-19 12:00_

Fwiw, I like the idea of implementing a more limited support that considers system packages or layered packages as read-only first, limited to specific paths instead of full `sys.path`, failing if they don't match the requirements in the user environments. It should be possible to start with this and add full support later if we figure it out.

---

_Comment by @paveldikov on 2025-08-19 12:12_

The allure of full `sys.path` evaluation is that you won't have to duplicate the very many [gory implementation details](https://docs.python.org/3/library/sys_path_init.html) of the calculation + order of precedence. If you were to _only_ support `system-site-packages` it is probably easy to hack it as a one-off, but as soon as you add support for:

* `.pth` files
* `sitecustomize.py`

it can get messy very quickly as you will have to accurately anticipate what the interpreter thinks in all of the edge cases.

---

_Comment by @danielhollas on 2025-08-19 12:19_

> Fwiw, I like the idea of implementing a more limited support that considers system packages or 

I was just about to write a comment saying exactly this, thanks! Looking at the open PRs that tried to implement this (thanks so much to @pradyunsg for kicking things off in #9849 and you for pushing further in #11670), one could avoid some of the complexity by:

- focus on support for `uv pip` commands. `uv sync` et al don't seem to be a good fit for the kind of workflows mentioned here anyway --- when you have a lockfile with exact versions, you'd end up reinstalling most packages anyway, right?
- focus on read-only operations (`uv pip list` et al) or 'additive' operations (`uv pip install`) that can layer things on top, i.e. don't try to support 'uninstall'  (as you already said)

I noticed that small part of #11670 has been merged already in #15121, yay! :-) 

---

_Comment by @konstin on 2025-08-19 13:06_

> The allure of full `sys.path` evaluation is that you won't have to duplicate the very many [gory implementation details](https://docs.python.org/3/library/sys_path_init.html) of the calculation + order of precedence. If you were to _only_ support `system-site-packages` it is probably easy to hack it as a one-off, but as soon as you add support for:
> 
>     * `.pth` files
> 
>     * `sitecustomize.py`
> 
> 
> it can get messy very quickly as you will have to accurately anticipate what the interpreter thinks in all of the edge cases.

The interactions between installing packages into `sys.path` and those packages installing `.pth` files and that change `sys.path` is one of the aspects that made https://github.com/astral-sh/uv/pull/11670 so tricky.

---

_Comment by @ncoghlan on 2025-08-19 18:42_

More context on the `venvstacks` use case:

* `venvstacks` runs `uv pip compile` and `pip install` internally as environment build tools. It's the latter I'd like to replace with `uv pip install` so I'm only dealing with one package cache and one package index config
* `venvstacks` has the full sys path defined (as it is responsible for setting up `sitecustomize.py` appropriately)
* `venvstacks` already uses the full requirements for the lower layers as constraints when locking, so it could definitely supply those when installing as well (potentially with adjustments to the file contents)

It hadn't occurred to me to try turning the constraints files into override files at installation time, so I'll definitely explore that option. If it works, inferring the relevant overrides could be a viable implementation strategy for a `uv` provided `--skip-installed` option.


---

_Comment by @pradyunsg on 2025-08-19 23:05_

Being limited to specific explicitly-provided paths would be fine for my use case as well.

My [motivating case](https://cfp.packaging-con.org/2023/talk/939VED/) ends up being the desire to add a particular path to the package to the installed distributions search path for uv. We're basically providing a "system" site-packages with some built-internally packages that are installed there (which won't be available on the package index) -- we currently inform pip of these packages by adding a `.pth` file pointing to that directory (which we add conditionally, based on whether a user needs those built-internally packages).

---

_Comment by @konstin on 2025-08-20 21:19_

Can you say more about how you add that `.pth` file?

`.pth` files are tricky because they can be created by package installation, and `sys.path` is tricky because we don't know where the entries are from and they can be changed by the flag Python gets invoked with (including the flag we pass when launching our interpreter probing script). Maybe we need to recursively read `.pth` files in uv ourselves and compute the system site packages location instead of looking at `sys.path` at all?

---

_Comment by @ncoghlan on 2025-08-21 12:28_

One advantage of an opt-in flag would be that it provides a way for the caller to say "If I'm playing games with `sys.path` that are too complicated for `uv` to follow, that's on me, so go ahead and trust the preinstall snapshot of what's already installed anywhere on `sys.path`"

Another way to go would be to have `--skip-installed` take the path-or-paths where the already installed packages should be ignored (that seems like a recipe for weird inconsistencies between the configured `sys.path` and the `--skip-installed` parameter value though, so I don't like that idea as much).

---

_Referenced in [astral-sh/uv#4422](../../astral-sh/uv/issues/4422.md) on 2025-08-22 14:12_

---

_Comment by @ncoghlan on 2025-08-25 15:21_

https://github.com/lmstudio-ai/venvstacks/pull/249 confirms that turning the lower layer constraints into overrides with a never-matched platform environment marker solves the problem well enough for `venvstacks` to switch over to it.

That suggests the following potential shape for an opt-in approach in `uv`:

* `uv pip freeze --all-installed` to list all installed packages, not just those in the target installation folder
* `uv pip install --skip-installed` to treat already installed packages as overrides that don't need to be modified

(although given that `uv pip freeze` is intrinsically a read-only operation, maybe it doesn't need the opt-in flag to report all installed packages?)

---

_Referenced in [astral-sh/uv#15692](../../astral-sh/uv/issues/15692.md) on 2025-09-05 09:29_

---

_Comment by @pradyunsg on 2025-09-09 00:47_

> Can you say more about how you add that `.pth` file?

It's added to the virtualenv's site-packages directory, after the creation of the virtualenv but before performing the installation.

The logic is something like:

```py
create_venv(location)
if extra_path_to_include is not None:
    add_pth_to_site_packages(location, extra_path_to_include)
install_packages(requirements)
```

With only the final call being plumbed through to a `uv pip install` invocation.

---

_Comment by @emanueleaina on 2025-09-11 09:59_

For what is worth my use-case is to use the pre-built psycopg2 from the distribution as re-building it does not seem to be worth the effort.

Before installing any actual package from PyPI my venv is:

```
(venv) $ pip list -v   
Package  Version Location                               Installer
-------- ------- -------------------------------------- ---------
pip      25.1.1  /opt/venv/lib/python3.13/site-packages pip
psycopg2 2.9.10  /usr/lib/python3/dist-packages

(venv) $ uv pip list -v
DEBUG uv 0.7.22
DEBUG Searching for default Python interpreter in virtual environments or search path
DEBUG Found `cpython-3.13.5-linux-x86_64-gnu` at `/opt/venv/bin/python3` (active virtual environment)
Using Python 3.13.5 environment at: 
Package Version
------- -------
pip     25.1.1
```

I will keep using `pip` for now, but I'd love to move to `uv` if possible.

---

_Referenced in [astral-sh/uv#16122](../../astral-sh/uv/issues/16122.md) on 2025-10-06 08:48_

---

_Comment by @ncoghlan on 2025-10-09 17:28_

@konstin I unfortunately just learned that the very helpful `--overrides` workaround you suggested above *doesn't* work when using `pylock.toml` as the lock export format (that's also when I picked up that the error message for that case wasn't previously correct: https://github.com/astral-sh/uv/pull/16211).

I was able to switch to a different workaround for my specific use case, though (adding  a `sys_platform == "from_lower_layer"` clause to the marker fields for the affected packages when emitting the lock files in the first place).

Edit: update to reflect changes since I first posted the comment.

---

_Renamed from "`uv pip` does not read all system packages (e.g., in `uv pip list --system` or virtual environments with `system-site-packages`)" to "`uv pip list` does not read all system packages in `sys.path` and ignores `system-site-packages`" by @konstin on 2025-10-15 13:00_

---

_Referenced in [astral-sh/uv#16220](../../astral-sh/uv/issues/16220.md) on 2025-10-15 13:00_

---

_Referenced in [astral-sh/uv#9452](../../astral-sh/uv/issues/9452.md) on 2025-10-15 13:00_

---

_Referenced in [astral-sh/uv#16541](../../astral-sh/uv/issues/16541.md) on 2025-11-03 02:35_

---
