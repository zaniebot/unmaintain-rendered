```yaml
number: 14746
title: "`uv tool install --in` to add packages to an existing tool environment"
type: issue
state: open
author: mgaitan
labels:
  - enhancement
assignees: []
created_at: 2025-07-19T14:00:39Z
updated_at: 2025-10-08T21:29:38Z
url: https://github.com/astral-sh/uv/issues/14746
synced_at: 2026-01-10T01:57:33Z
```

# `uv tool install --in` to add packages to an existing tool environment

---

_Issue opened by @mgaitan on 2025-07-19 14:00_


When using `uv tool`, it's great that we can install tools in an isolated virtual environment with a single command. For example

```
uv tool install llm
```

And it's also possible to install a tool with some plugins as "extras" right away:

```
uv tool install --with llm-tr llm
```

This works perfectly for fresh installs. However, it's not clear how to **add a plugin or extra package later**, into the same environment where the main tool was installed.

For example, if I’ve already installed `llm` (another frequent case is `jupyter`), and now I want to install `llm-tr` into the same environment, there’s no direct way to do that with `uv tool`.

For the particular case of  `llm`, it provides a workaround via its own plugin installation command:

```
llm install llm-tr
```

This works because `llm` internally calls `pip install` using its own Python runtime. But this is not a general solution, and it relies on `pip`, which I’d like to avoid when using `uv`.

### Proposal

I'm wondering if we could allow commands like this:

```
uv tool install --in llm llm-tr
```

This would install `llm-tr` inside the existing environment where `llm` was installed.

It could also work for upgrading or uninstalling:

```
uv tool upgrade --in llm llm-tr
uv tool uninstall --in llm llm-tr
```

This would let users manage plugins or extensions of a tool cleanly, without exposing internal paths or relying on tool-specific behaviors.



---

_Label `enhancement` added by @mgaitan on 2025-07-19 14:00_

---

_Comment by @pygarap on 2025-07-22 22:08_

@mgaitan That's a great idea!
I think it would be more convenient to use the 'add' keyword:
```
>> uv tool install "ipython[matplotlib]"
>> uv tool add ipython --with "rich[jupyter]"
>> uv tool add ipython --with "jupyter-ai-magics[all]"
```

---

_Comment by @zanieb on 2025-07-22 22:17_

It's sort of by-design that this isn't allowed, e.g., this was previously discussed at https://github.com/astral-sh/uv/issues/7312

https://github.com/astral-sh/uv/issues/12533 might be a better path forward for this use-case?

---

_Comment by @pygarap on 2025-07-22 22:39_

@zanieb I believe the "pipx inject" functionality will be very useful for uv. Often, when using a tool, you may want to install additional dependencies later on. In such cases, it's preferable to add only the specific dependencies you need at that moment, rather than reinstalling everything from scratch.

#12533 is a very good improvement, but it's not going to add the ability of "pipx inject".

---

_Comment by @zanieb on 2025-07-23 00:09_

The concept of injecting dependencies into an existing environment is against our design goal of having declarative environments. That's why it's not a part of the interface, and that's why a declarative interface and backend for tools feels like the solution. It's plausible something similar to what you want could come after #12533, but I'm wary of adding imperative interfaces before there's a user-facing declarative backend for that information.

---

_Referenced in [astral-sh/uv#15330](../../astral-sh/uv/issues/15330.md) on 2025-08-19 20:49_

---

_Comment by @Arcitec on 2025-09-19 20:31_

The tools should be advertising proper `extras` for their extra dependencies, instead of forcing you to manually inject extras via `--with`. So contact upstreams, contribute pull requests to them.

Then you can just do:

```
uv tool install "yt-dlp[default,curl-cffi,secretstorage]"
```

Or whatever combination of extras you want. And uv always remembers this during `uv tool upgrade` actions.

---

_Comment by @slacksystem on 2025-10-08 21:26_

Hi I'm coming here after needing to modify the environment of a tool I've installed a while ago, and, not remembering packages I'd originally installed to the environment, just did a new install wtih `uv tool install --with <new package>` and ended up removing the old ones. I totally respect the design of having decalarative installs, but is there a way to look at an installed tool and see what packages I included in the original `--with ____` in my original install, not including dependencies of the executable and dependencies of the original "with" packages  that weren't explicit in the install. That way I can just do `uv tool install --with <new package> --with <old package> <tool>` and everything works out fine. Is there currently a way to do that and if  not is this something that might be an alternate solution?

---

_Comment by @zanieb on 2025-10-08 21:29_

Yeah you can do `uv tool list --show-with`

---
