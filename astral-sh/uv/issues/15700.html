<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Changing python package source files in venv changes cached uv files too - astral-sh/uv #15700</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Changing python package source files in venv changes cached uv files too</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/15700">#15700</a>
        opened by <a href="https://github.com/S-Erik">@S-Erik</a>
        on 2025-09-05 10:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/S-Erik">@S-Erik</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<h3>Commands I ran:</h3>
<p>Clear cache to start from a clean slate:</p>
<pre><code class="language-bash">uv cache clean
</code></pre>
<p>Create new python virtual environment (the used python version should not be important here, tested with 3.11 and 3.12):</p>
<pre><code class="language-bash">python3.12 -m venv .venv &amp;&amp; source .venv/bin/activate
</code></pre>
<p>Use uv to pip install a package. Here we use my-mini-package since it has no dependencies and just one function.</p>
<pre><code class="language-bash">uv pip install my-mini-package==0.1.0
</code></pre>
<p>Find and go to cache directory of uv (location printed when we executed <code>uv cache clean</code>). On linux:</p>
<pre><code class="language-bash">cd ~/.cache/uv/
</code></pre>
<p>Find cache folder containing my_mini_package:</p>
<pre><code class="language-bash">find . -type d -name &quot;my_mini_package&quot;
</code></pre>
<p>This outputs something like:</p>
<pre><code class="language-bash">./archive-v0/G3V8NCb0ZBzfavnefTMRX/my_mini_package
</code></pre>
<p>Go to that folder:</p>
<pre><code class="language-bash">cd ./archive-v0/G3V8NCb0ZBzfavnefTMRX/my_mini_package
</code></pre>
<p>show content of single_function.py:</p>
<pre><code>cat single_function.py
</code></pre>
<p>This outputs:</p>
<pre><code class="language-python">def greet(name: str) -&gt; str:
    &quot;&quot;&quot;Returns a greeting message.&quot;&quot;&quot;
    return f&quot;Hello, {name}!&quot;
</code></pre>
<p>Now let's go to the code of my_mini_package in the virtual environment created earlier:</p>
<pre><code class="language-bash">cd .venv/lib/python3.12/site-packages/my_mini_package
</code></pre>
<p>Let's edit the file <code>single_function.py</code> and change line</p>
<pre><code class="language-python">return f&quot;Hello, {name}!&quot;
</code></pre>
<p>to</p>
<pre><code class="language-python">return f&quot;Hello, {name}! (changed)&quot;
</code></pre>
<p>and save the file.</p>
<p>If we now take a look at the cached version of my_mini_package (<code>~/.cache/uv/archive-v0/G3V8NCb0ZBzfavnefTMRX/my_mini_package/single_function.py</code>), we see that this change was also applied to the cached version of <code>single_function.py</code>.</p>
<p>Now, if we would create a new virtual environment (could be anywhere on the same machine with the same user) and install my_mini_package with uv in the same version (<code>uv pip install my-mini-package==0.1.0</code>), we use the <strong>changed</strong> cached version of my_mini_package with the changed line in <code>single_function.py</code>. This can result in wierd scenarios where we expect the original behaviour of the package but actually use a changed version.
I think that changing a source file of an installed package in a virtual environment can sometimes be useful for testing purposes where you want to check how your code reacts when you change some code in an installed package. But that this results in the case that this change gets installed when you install the same package in a totally new enviornment, is very unexpected and not at all intuitive for me.</p>
<p>Clearing the cache with <code>uv cache clean</code> or installing packages with <code>uv pip install --no-cache &lt;package-name&gt;</code> removes the cached changes or does not use the cache for installation, respectively.</p>
<p>For me, this would mean that I need to clear the cache everytime (also possible by setting environment variable UV_NO_CACHE) or installing unchached packages everytime, because maybe I have changed a package somewhere and I cannot remember.</p>
<p>Is this intended behaviour? How are the files of the installed packages in the venv-folder linked to the cached files in the uv cache folder? I couldn't find any symbolic links on the related folders.</p>
<h3>Versions</h3>
<p><code>uv --version</code>:</p>
<pre><code class="language-bash">uv 0.8.15
</code></pre>
<p>Python version: tested with 3.11 and 3.12.</p>
<p><code>cat /etc/os-release</code>:</p>
<pre><code class="language-bash">PRETTY_NAME=&quot;Ubuntu 22.04.5 LTS&quot;
NAME=&quot;Ubuntu&quot;
VERSION_ID=&quot;22.04&quot;
VERSION=&quot;22.04.5 LTS (Jammy Jellyfish)&quot;
VERSION_CODENAME=jammy
ID=ubuntu
ID_LIKE=debian
HOME_URL=&quot;https://www.ubuntu.com/&quot;
SUPPORT_URL=&quot;https://help.ubuntu.com/&quot;
BUG_REPORT_URL=&quot;https://bugs.launchpad.net/ubuntu/&quot;
PRIVACY_POLICY_URL=&quot;https://www.ubuntu.com/legal/terms-and-policies/privacy-policy&quot;
UBUNTU_CODENAME=jammy
</code></pre>
<h3>Platform</h3>
<p>Ubuntu 22.04.5 amd64</p>
<h3>Version</h3>
<p>uv 0.8.15</p>
<h3>Python version</h3>
<p>Python 3.11 and Python 3.12</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @S-Erik on 2025-09-05 10:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-09-05 11:59</div>
            <div class="timeline-body"><p>It's not intended, it's rather an unfortunate side-effect of hard-linking. We don't want to duplicate files for each venvs, that's both slow and takes a lot of disk space. The ideal solution for that are copy-on-write file systems: We tell the operating system to create something that looks like a copy, but use the same on disk, until either file is edited: Only then do we actually copy the file and change one copy. This is supported on MacOS with <code>--copy-mode clone</code> which reflinks through <code>clonefileat</code>. On Windows and Linux, there is no or no consistent support for this, so we use hardlinking on these platforms instead.</p>
<p>You can switch to copying files instead by using <code>--link-mode copy</code>, with the drawbacks to slow installation and larger on-disk size. An alternative workflow is <code>git clone</code>ing the dependency and installing it with <code>uv pip install -e</code>, to get an editable install of the dependency that can be freely edited.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> removed by @konstin on 2025-09-05 11:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @konstin on 2025-09-05 11:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/S-Erik">@S-Erik</a> on 2025-09-05 13:52</div>
            <div class="timeline-body"><p>I understand the cause now. Thanks for your swift answer.
But I am not sure if I understand your suggestions. I found that <code>uv run --link-mode copy</code> is a valid command but needs a command or script to be invoked with. Are you suggesting using <code>uv run --link-mode copy pip install ...</code>?
Currently, I think that setting the <code>UV_LINK_MODE</code> environment variable to <code>copy</code> might be easier, wouldn't it?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-09-05 15:14</div>
            <div class="timeline-body"><blockquote>
<p>Currently, I think that setting the <code>UV_LINK_MODE</code> environment variable to <code>copy</code> might be easier, wouldn't it?</p>
</blockquote>
<p>Yes, that works.</p>
<p>For comprehensiveness, if you want to run it in a manual command, you can do <code>uv sync --link-mode copy</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-09-06 02:39</div>
            <div class="timeline-body"><p>(Using <code>--link-mode=copy</code> has downsides, though. It's slower, and it requires more disk space, since you're now storing a separate copy of each file every time you install a package. Personally, I'd recommend sticking to the default link mode, and then using <code>uv cache clean my_mini_package</code> or similar as needed.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @charliermarsh on 2025-09-06 02:39</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:32:49 UTC
    </footer>
</body>
</html>
