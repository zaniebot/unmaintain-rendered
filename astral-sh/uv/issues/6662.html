<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>support installing uv to the project using a wrapper script - astral-sh/uv #6662</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>support installing uv to the project using a wrapper script</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/6662">#6662</a>
        opened by <a href="https://github.com/DetachHead">@DetachHead</a>
        on 2024-08-26 23:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/DetachHead">@DetachHead</a> on 2024-08-26 23:15</div>
            <div class="timeline-body"><p>re-raising https://github.com/astral-sh/rye/issues/944 here now that uv has many of rye's features:</p>
<p>tools like <a href="https://pyprojectx.github.io/">pyprojectx</a> and <a href="https://docs.gradle.org/current/userguide/gradle_wrapper.html">gradle</a> support being installed and run with a wrapper script, which is a script in the project root that gets committed which allows anybody to start working on your repo even if they don't have uv installed.</p>
<p>the script could be called <code>uw</code> (uv wrapper) or something, and users can run <code>./uw sync</code> which will automatically install uv to the project and then run the <code>sync</code> command</p>
<p>this also allows you to pin the uv version in your project</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @zanieb on 2024-08-27 01:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-08-27 01:49</div>
            <div class="timeline-body"><p>Sort of related to #6533</p>
<p>I'm honestly kind of into this. It's not on the immediate roadmap though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2024-09-19 01:05</div>
            <div class="timeline-body"><p>Yeah a wrapper script that lives in the root of the project would be really awesome.</p>
<p>https://github.com/astral-sh/uv/issues/6505 is also a cool idea. I know that binaries are frowned upon in git but I would make an exception for a cross platform/APE <code>uv</code> binary in my project root.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluetech">@bluetech</a> on 2025-02-10 08:55</div>
            <div class="timeline-body"><p>It's important that the wrapper script be able to:</p>
<ul>
<li>Install a specific version of uv</li>
<li>Installs uv for the project only, e.g. to a <code>.uv/</code> directory in the project</li>
</ul>
<p>This can help solve the boostrap problem for users with these requirements:</p>
<ul>
<li>Multiple projects</li>
<li>Each project pins the uv version for consistency across devs/CI/deployment</li>
<li>Projects are independent and may have differing uv pins</li>
</ul>
<p>Current solutions I can think of are:</p>
<ul>
<li>What I use: Nix flakes + direnv. Sort of heavy weight for pure Python projects.</li>
<li><code>pipx</code> or <code>python -m venv .venv &amp;&amp; .venv/bin/pip install uv==0.5.29</code> etc. Requires Python to already be available.</li>
<li>Commit uv binary: bloats the repo, architecture specific. Not very nice.</li>
<li>Write own wrapper script: possible, but would be nice if uv provides it.</li>
</ul>
<p>(Would love to hear other solutions)</p>
<p>The installer script already allows to specify a version, checks preconditions and detects OS/architecture. If it could be made to install to a project directory instead of $HOME, and exec uv, that's pretty close. It will need to read some file to know which uv version to download (in Gradle projects that's <code>gradle/wrapper/gradle-wrapper.properties</code>).</p>
<blockquote>
<p>the script could be called uw (uv wrapper) or something</p>
</blockquote>
<p>I would call it <code>uvw</code> following the <code>gradlew</code> precedent.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-02-10 09:17</div>
            <div class="timeline-body"><blockquote>
<p>(Would love to hear other solutions)</p>
</blockquote>
<p>the solution i'm using for now is <a href="https://pyprojectx.github.io/">pyprojectx</a>. i mentioned it in the OP but i didn't really make it clear that it can be used to manage your uv installation.</p>
<pre><code class="language-toml"># pyproject.toml

[tool.pyprojectx]
main = [&quot;uv&quot;]
</code></pre>
<p>then once you <a href="https://pyprojectx.github.io/#installation">install pyprojectx to your project root</a> you can run <code>./pw --lock</code> to generate a pyprojectx lockfile and <code>./pw uv sync</code> which also automatically installs uv to your project. then just commit the <code>pw</code> and <code>pw.bat</code> wrapper scripts</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluetech">@bluetech</a> on 2025-02-10 09:28</div>
            <div class="timeline-body"><p>I didn't know about pyprojectx, it looks nice. It does seem to require that Python is already installed which I hope to avoid. Basically the request is for uv to subsume pyprojectx like it did every other Python packaging tool :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cliebBS">@cliebBS</a> on 2025-02-20 14:47</div>
            <div class="timeline-body"><p>I actually like the way that <code>sbt</code> handles this more than Gradle's approach.  <code>sbt</code> reads a <code>build.properties</code> file in the project and, if the SBT version in that file differs from its current version, it downloads the version specified in <code>build.properties</code> and runs that version instead.  This removes the hacky wrapper scripts that need to be checked into every repo and that prevent the tooling from working in any subdirectory within the project.  Instead, you just have a global <code>sbt</code> installation that can manage multiple versions of itself.</p>
<p>I feel like <code>uv</code> could build upon it's currently existing Python installation management (<code>uv python install/list/uninstall</code>) to also manage multiple versions of itself outside the context of the current project, and then utilize an <code>exec</code> call to replace itself with the correct version when necessary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bluetech">@bluetech</a> on 2025-02-20 15:43</div>
            <div class="timeline-body"><blockquote>
<p>you just have a global sbt installation that can manage multiple versions of itself.</p>
</blockquote>
<p>But how do you get the global <code>sbt</code> to all team members? That's the problem that a wrapper script solves.</p>
<p>If I were to list a set of dream &quot;requirements&quot; for a wrapper script:</p>
<ul>
<li>It should be reasonably small in size (not a big file).</li>
<li>It should be reasonably readable/auditable in plain text (not binary).</li>
<li>It should be something that's committed to git repos.</li>
<li>It should read the required uv version from some file, ideally pyproject.toml but most likely another file that is simple to parse.</li>
<li>It should be able to verify the uv binaries it downloads using hashes committed to the repo.</li>
<li>It should have minimal system dependencies/requirements.</li>
<li>It should be able to bootstrap on Linux/Windows/Mac.</li>
<li>It should not add noticeable overhead when the needed uv is already available.</li>
</ul>
<p>I realize that it's not likely possible to achieve all of these at the same time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cliebBS">@cliebBS</a> on 2025-02-20 16:21</div>
            <div class="timeline-body"><p>You get it to team members by having them install whatever version of uv they like (that's new enough to have this feature) via the official install script, pipx, or any other supported install method, just like you would have them get Python for their systems already.  This approach removes the need for any wrapper script to be committed to any repo, since uv replaces it.  The uv version can be baked into <code>pyproject.toml</code>, and when it isn't set the system uv just runs normally like it does today.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-02-20 21:55</div>
            <div class="timeline-body"><blockquote>
<p>You get it to team members by having them install whatever version of uv they like (that's new enough to have this feature) via the official install script, pipx, or any other supported install method</p>
</blockquote>
<p>this means we need to worry about the user having both a version of python installed <strong>and</strong> a version of uv.</p>
<p>i much prefer the wrapper script approach. it's so convenient to not have to worry about whether somebody already has a version of the tool installed or not. the only benefit to not having a wrapper script is that one less file is committed, but i don't really see how thats an issue?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cliebBS">@cliebBS</a> on 2025-02-21 15:07</div>
            <div class="timeline-body"><p>Except they don't need a version of Python installed at all.  Installing uv doesn't require Python as a pre-requisite when using the official installer script (and your proposed <code>uvw</code> wrapper would most likely be building on top of the official installation script), just curl/wget and a smattering of standard Linux/bash commands.</p>
<p>The problem with the wrapper script is that:</p>
<ol>
<li>It needs to be added to <em>every</em> repo that uses uv (in a microservices setup, this could be 10s to 100s of repos)</li>
<li>It forces you to run all uv/uvx commands directly from the root of the project, even though uv/uvx is capable of being run from any place within the directory hierarchy of a project</li>
<li>It requires a second script to be checked in to support uvx (and additional scripts if, in the future, additional global executables are added to the uv distribution)</li>
<li>There is no good way to assess the version of the script for when you inevitably need to update it</li>
</ol>
<p>My proposal, however:</p>
<ol>
<li>Requires no modification to repos beyond registering the desired uv version in pyproject.toml (which is already required for any potential solution)</li>
<li>uv/uvx commands can be run from anywhere inside your project (or even outside the project with the <code>--directory</code> parameter), just like you would if you aren't pinning your uv version (ie, requires no change to normal user behavior or end-user documentation)</li>
<li>Allows future additional global executables to be added (like <code>uvx</code>) without requiring any changes to repos</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-02-21 20:38</div>
            <div class="timeline-body"><blockquote>
<p>Except they don't need a version of Python installed at all. Installing uv doesn't require Python as a pre-requisite when using the official installer script</p>
</blockquote>
<p>i'm not a fan of using install scripts to install anything globally because if it fails it leaves you with a half installed version of the tool that's difficult to find and remove. for this reason whenever i install a tool globally, i refuse to do it unless it either comes from a package manager or has an installer. so with uv, that means my only option is to install it from pypi, which means i already need a version of python installed.</p>
<p>i like the idea of a project level wrapper script because whenever there's an issue you can easily delete the version that was installed to the project and re-run it. this is what i've been doing with pyprojectx for a while now and it's made working with python projects so much less painful. i remember having to deal with corrupted installations of poetry and other tools that it's made me never want to install something globally ever again unless i absolutely need to, especially if it comes from an install script.</p>
<blockquote>
<p>The problem with the wrapper script is that:</p>
<ol>
<li>It needs to be added to <em>every</em> repo that uses uv (in a microservices setup, this could be 10s to 100s of repos)</li>
</ol>
</blockquote>
<p>it's not like you'd be forced to use the wrapper script, and there would be a command you can use to create and update it which would make it easier to manage.</p>
<blockquote>
<ol start="2">
<li>It forces you to run all uv/uvx commands directly from the root of the project, even though uv/uvx is capable of being run from any place within the directory hierarchy of a project</li>
<li>It requires a second script to be checked in to support uvx (and additional scripts if, in the future, additional global executables are added to the uv distribution)</li>
</ol>
</blockquote>
<p>i guess this depends on how exactly the wrapper script is implemented. if it works like pyprojectx this isn't an issue because it installs its tools to a location in the project root that can be &quot;activated&quot; similar to a venv but it can also be added to your <code>PATH</code>. in my projects i can configure vscode to do this automatically:</p>
<pre><code class="language-jsonc">// .vscode/settings.json
{
    &quot;terminal.integrated.env.windows&quot;: {
      &quot;PATH&quot;: &quot;${workspaceFolder}/.pyprojectx/main;${env:PATH}&quot;
    },
    &quot;terminal.integrated.env.osx&quot;: {
      &quot;PATH&quot;: &quot;${workspaceFolder}/.pyprojectx/main:${env:PATH}&quot;
    },
    &quot;terminal.integrated.env.linux&quot;: {
      &quot;PATH&quot;: &quot;${workspaceFolder}/.pyprojectx/main:${env:PATH}&quot;
    }
}
</code></pre>
<p>this way the user only has to run uv through the wrapper script once, then once its installed to the project they can run uv commands the usual way and forget about the wrapper script.</p>
<p>also, i've never used uvx before but <a href="https://docs.astral.sh/uv/guides/tools/#running-tools">it sounds like a command you wouldn't use in a project anyway</a> if you care about pinning project dependencies</p>
<blockquote>
<ol start="4">
<li>There is no good way to assess the version of the script for when you inevitably need to update it</li>
</ol>
</blockquote>
<p>i don't see why you couldn't just check the version with a <code>--version</code> argument and update it with a separate command that just replaces the wrapper script with the new version. this is also how pyprojectx works</p>
<blockquote>
<p>My proposal, however:</p>
<ol>
<li>Requires no modification to repos beyond registering the desired uv version in pyproject.toml (which is already required for any potential solution)</li>
</ol>
</blockquote>
<p>i realise this is mostly personal preference, but i am a huge advocate of the wrapper script approach because it's made my life much easier and i think it would be great if uv supported it officially. but i realize not everyone wants to manage their projects this way which is why this feature would be fully optional</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cliebBS">@cliebBS</a> on 2025-02-21 21:44</div>
            <div class="timeline-body"><p>While I don't have any experience with pyprojectx, I have worked with <code>gradlew</code> in the past and it was nowhere near as automatic as <code>sbt</code> makes things.  With <code>sbt</code>, you can't run the wrong version of <code>sbt</code> because it will always load the correct version based on your project settings, regardless of what version you have installed globally.</p>
<p>As for not liking magic <code>curl | sh</code> installation methods, I 100% agree with you.  However, in uv's case, it's at least available in homebrew already, though I can't speak for Linux or Windows package managers.  When it's not available there, you can always go to the GitHub releases page for the uv project and download the binaries for your OS+arch and unzip them on your path.  The tarballs only contain two files, one each for <code>uv</code> and <code>uvx</code>, so it's pretty hard to mess up an installation by hand, and once you have things installed, you're one <code>uv self update</code> away from the latest version.</p>
<p>Having <code>uv</code> emit the wrapper script is certainly a nice improvement over where Gradle used to be where you needed to download <code>gradlew</code> separate from the main Gradle distribution.  Maybe, if we went with that solution, we could have uv emit a warning if the <code>uvw</code> script was out-of-date or didn't match the current version of uv.  I would still prefer to manage all of my versions from <code>pyproject.toml</code>, though, so having the <code>uvw</code> version be separate kind of goes against that wish.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-02-22 03:30</div>
            <div class="timeline-body"><blockquote>
<p>I have worked with <code>gradlew</code> in the past and it was nowhere near as automatic as <code>sbt</code> makes things. With <code>sbt</code>, you can't run the wrong version of <code>sbt</code> because it will always load the correct version based on your project settings, regardless of what version you have installed globally.</p>
</blockquote>
<p>i'm no historian, but for as long as I have used gradle, the gradle version is specified in the <code>gradle/wrapper/gradle-wrapper.properties</code> file. and that is always automatically downloaded and used when you run <code>gradlew</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cliebBS">@cliebBS</a> on 2025-02-24 15:03</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>I have worked with <code>gradlew</code> in the past and it was nowhere near as automatic as <code>sbt</code> makes things. With <code>sbt</code>, you can't run the wrong version of <code>sbt</code> because it will always load the correct version based on your project settings, regardless of what version you have installed globally.</p>
</blockquote>
<p>i'm no historian, but for as long as I have used gradle, the gradle version is specified in the <code>gradle/wrapper/gradle-wrapper.properties</code> file. and that is always automatically downloaded and used when you run <code>gradlew</code></p>
</blockquote>
<p>Sorry, I was unclear what I meant.  I wasn't saying that the version of Gradle being requested by the wrapper wasn't specified anywhere, what I meant is that the <code>gradlew</code> script is itself a versionable artifact that lacks any easy way to keep up to date or to check if it is up to date.</p>
<p>Poetry shows why it important to have this file versioned:  A couple of years ago, Poetry changed the install script quite drastically (I think it was with version 1.2.0), and newer versions of Poetry stopped being installable with the older version of the install script.  There's nothing stopping uv from wanting to change its install process in the future, including to address a security issue.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 03:52:35 UTC
    </footer>
</body>
</html>
