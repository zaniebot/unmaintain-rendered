```yaml
number: 4238
title: "`uv pip compile --resolution lowest-direct` treats transitive dependencies of file dependencies as direct."
type: issue
state: open
author: patrick-kidger
labels: []
assignees: []
created_at: 2024-06-11T16:27:08Z
updated_at: 2024-06-11T19:22:24Z
url: https://github.com/astral-sh/uv/issues/4238
synced_at: 2026-01-12T15:58:48Z
```

# `uv pip compile --resolution lowest-direct` treats transitive dependencies of file dependencies as direct.

---

_@patrick-kidger_

**MWE**:

Lead with the bit that's interesting! After a bit of head-scratching it turned out to be quite simple:

```
# one/pyproject.toml
[project]
name = "one"
version = "0.0.1"
dependencies = ["two @ file://${PROJECT_ROOT}/../two"]

# two/pyproject.toml
[project]
name = "two"
version = "0.0.1"
dependencies = ["typing_extensions>=4.5.0"]
```
then
```
one❯ uv pip compile pyproject.toml --resolution lowest-direct                
Resolved 2 packages in 86ms
# This file was autogenerated by uv via the following command:
#    uv pip compile pyproject.toml --resolution lowest-direct
two @ file://${PROJECT_ROOT}/../two
    # via one (pyproject.toml)
typing-extensions==4.5.0
    # via two
```

**Expected behaviour**: to get `typing-extensions==4.12.2` (at time of writing).

**Versions**: I've reproduced this with `uv` at `HEAD`, `0.2.10`, `0.2.4`, `0.1.34`.

**Other variations**:
The same bug also occurs in all of the following scenarios:
1. When expressed on the command line:
```
one❯ printf 'two @ file://${PROJECT_ROOT}/../two' | uv pip compile - --resolution lowest-direct
```
2. When expressed editably (side note, this one is our actual use-case).
```
one❯ printf '-e file://${PROJECT_ROOT}/../two' | uv pip compile - --resolution lowest-direct
```
3. When not using `PROJECT_ROOT`:
```
one❯ printf '-e file:///absolute/path/to/two' | uv pip compile - --resolution lowest-direct
```

(FWIW we found this problem as the resulting `requirements.txt` files go on to be used as `constraints` in one of our later build steps.)

---

_Comment by @notatallshaw-gts on 2024-06-11 16:49_

I also encountered this same behavior yesterday, specifically in the context of "3.", and while surprised I personally found it useful, so wasn't sure if it was intentional or not.

If I have a local package I am passing into the requirement, uv can only see one version of it, so it made sense to me it would look for the lowest direct dependencies of that package, and was a better test for my environment.

But it is surprising, and not the behavior I would expect from the description.

---

_Comment by @charliermarsh on 2024-06-11 16:58_

Yeah this is intentional -- we consider anything local to be first-party, i.e., conceptually part of your local workspace.

---

_Comment by @charliermarsh on 2024-06-11 16:59_

Is this a real problem or undesirable behavior in your use-case, or just something that needs to be better-documented? (I'm not fully convinced that we should change it but open-minded of course.)

---

_Comment by @patrick-kidger on 2024-06-11 18:28_

At least for us it's undesirable behaviour! What's going on is that we have several libraries that depend on each other. Most of the time we express this as a git/PyPI dependency. But during local development, if making a cross-cutting change, then we switch that into an editable dependency.

So
(a) ideally such dependencies would behave the same as normal git/PyPI dependencies, as they're still conceptually separate libraries;
(b) if I've grokked this correctly then I think the nature of our dependency resolution actually changes, if we happen to run `uv compile` whilst the editable dependency is in place?

---

_Comment by @charliermarsh on 2024-06-11 18:39_

Yeah, if you run with `--resolution lowest-direct`, then what's considered "direct" will change if you switch from using a Git dependency to a local dependency, because one is considered direct and the other is not.

I mean, the weird thing is, given:

```
# one/pyproject.toml
[project]
name = "one"
version = "0.0.1"
dependencies = ["typing-extensions"]
```

And then `uv pip install ./one`, `typing-extensions` isn't technically a direct dependency either -- it's a transitive dependency, the direct dependency is `one @ file:///path/to/tone`. But intuitively it should be treated as a direct dependency, right?  Similarly, given `uv pip install ./one` vs. `uv pip install "one @ git+https://...`, we treat `typing-extensions` as direct in the first case but not in the second case, so switching the source does again change what's considered direct. Separate from whether this should be applied transitively as it is now, do you think both of those decisions are correct?


---

_Comment by @patrick-kidger on 2024-06-11 19:00_

> But intuitively it should be treated as a direct dependency, right?

I don't think so -- at least subjectively by own intuition! :D

Like you say, these are transitive dependencies, I don't have a mental model that differs from that.

> Similarly, given `uv pip install ./one` vs. `uv pip install "one @ git+https://...`, we treat typing-extensions as direct in the first case but not in the second case, so switching the source does again change what's considered direct.

Likewise, this doesn't fit my intution either. I don't expect where a dependency is located to affect anything whatsoever. (Beyond the possible need to make a network request.)

---

_Comment by @notatallshaw-gts on 2024-06-11 19:22_

I would say that yesterday I arrived at the same mental model as @charliermarsh.

The local projects are projects that I own, so while these local project direct dependencies are transitive of the requirements I feed to uv, they are still the direct dependencies of _my_ projects, which is more useful to my use case at least.

CC @potiuk, is airflow's CI use of lowest-direct referring to local files? A change in behavior here could break your setup.

---
