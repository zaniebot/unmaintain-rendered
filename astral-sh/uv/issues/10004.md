```yaml
number: 10004
title: How can I override a uv install (via uv sync) with an editable package that will stay up to date in running docker container
type: issue
state: open
author: adiberk
labels:
  - question
  - needs-mre
assignees: []
created_at: 2024-12-18T15:32:08Z
updated_at: 2024-12-18T20:35:45Z
url: https://github.com/astral-sh/uv/issues/10004
synced_at: 2026-01-10T01:57:23Z
```

# How can I override a uv install (via uv sync) with an editable package that will stay up to date in running docker container

---

_Issue opened by @adiberk on 2024-12-18 15:32_

I want to build my docker container as I normally do and then on run, install an editable version of a local package so that I can make sure to that I can update the package mid session and reflect those changes in the running container

However, this doesn't seem to be working

In my dockerfile I have this code
```
WORKDIR /virtualenv
COPY pyproject.toml uv.lock ./
RUN --mount=type=ssh \
    if [ "$ENV" = "unittest" ]; then \
    echo 'Installing UT' && uv sync --extra ut --frozen --no-install-project; \
    elif [ "$ENV" = "dev" ]; then \
    echo 'Installing DEV' && uv sync --extra dev --frozen --no-install-project; \
    else \
    echo 'Installing REG' && uv sync --frozen --no-install-project; \
    fi
# create /app directory and chown to to node user or else it will be owned by root
WORKDIR /app
COPY --exclude=**/.* --exclude=*.lock --exclude=*.toml . /app

ENV VIRTUAL_ENV=/virtualenv/.venv
ENV PATH="/virtualenv/.venv/bin:$PATH"
ENV PYTHONHASHSEED=0
```
When I run my compose I try this
`uv pip install -e /py-authorization /our-common --config-settings editable_mode=strict  && python -m debugpy --listen 0.0.0.0:10001 -m gunicorn -c python:config --bind=0.0.0.0:7680 place:app --log-level=debug --reload`

While this does make sure my running container gets the latest local code from "our-common" it is not updating after I edit that code


I believe when we originally used "pip" for this, there were no issues (though at the time we were using the "system" python and not creating a virtual env

Note: I know we can add the local path as a resource, but that the path isn't accessible in the docker build step. We make it accessible via mounting it.  Which is why I do it in the docker-compose run command

---

_Comment by @charliermarsh on 2024-12-18 17:16_

Have you confirmed that everything is using the same virtual environment? How did you confirm that the code is "not updating"?

---

_Label `question` added by @charliermarsh on 2024-12-18 17:29_

---

_Comment by @adiberk on 2024-12-18 17:38_

> Have you confirmed that everything is using the same virtual environment? How did you confirm that the code is "not updating"?

@charliermarsh 
I am not sure how to confirm that everything is using the same virtual environment
- If I run "which python" in my docker-compose command I do see the path to the virtual env python `/virtualenv/.venv/bin/python`

But I did add print statement in the local package while my service was running. The statement still wasn't getting hit. I have to restart (and rerun that uv install command)

Also, if I debug and enter the local package, I can see it isn't showing latest data

Note the original library is installed in pyproject as a resource via git ssh (but then I run uv install on service start to override the library)

---

_Renamed from "How can I override a uv install with an editable package that will stay up to date on edits" to "How can I override a uv install (via uv sync) with an editable package that will stay up to date in running docker container" by @adiberk on 2024-12-18 18:08_

---

_Comment by @adiberk on 2024-12-18 20:04_

@charliermarsh I actually decided to try installing uv using the system python instead of a virtual env in the dockerfile. After this if I run `pip install -e` etc. it worked as expected. And I could see that package changes are reflected in the running docker service

So I think I know the issue
`which python` shows the path to virtual env
BUT
`which pip` shows path to `/usr/local/bin/pip` which I guess is ultimately the issue here.  How can I make sure pip is correct without manually reactivating the env in the run compose command? (it seems it already is active based on the which python command)

---

_Comment by @zanieb on 2024-12-18 20:22_

It sounds like you want to add pip as a dependency of your project? Or do `uv pip install pip` so it's available in the environment?

Your example uses `uv pip` not `pip` though.

---

_Comment by @adiberk on 2024-12-18 20:27_

Right - so I have been trying to get it to work with `uv pip` and not just `pip`
But it seems it is not working with `uv pip` so I tried with regular pip and system python install just to be sure it works as expected.

I guess my question now is how can I get the same functionality using `uv pip`

---

_Comment by @zanieb on 2024-12-18 20:29_

If you install it with regular pip it seems like it'd be outside the virtual environment though?

---

_Comment by @adiberk on 2024-12-18 20:31_

Agreed which is why I only did that when I installed the packages using the system python in docker and **not** a virtual env. This helped me verify that it might be some sort of issue with the virtual env and using `uv pip install -e` in the run compose command.

---

_Comment by @zanieb on 2024-12-18 20:35_

I see. Sorry I didn't fully understand your previous comment.

I think we'll need a complete minimal example to help here.

---

_Label `needs-mre` added by @zanieb on 2024-12-18 20:35_

---
