<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature Request: Interactive Dependency Conflict Resolution Assistant - astral-sh/uv #16647</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Feature Request: Interactive Dependency Conflict Resolution Assistant</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/16647">#16647</a>
        opened by <a href="https://github.com/cherchyk">@cherchyk</a>
        on 2025-11-09 02:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/cherchyk">@cherchyk</a></div>
            <div class="timeline-body">Feature Request: Interactive Dependency Conflict Resolution Assistant
Summary
<p>Add an interactive conflict resolution assistant that helps developers understand and resolve dependency conflicts when <code>uv lock</code> or <code>uv add</code> fails, leveraging uv&#x27;s speed to explore the solution space and suggest concrete fixes.</p>
Motivation
The Problem
<p>Dependency resolution failures are one of the most frustrating experiences in Python development:</p>
<pre><code>$ uv add django==5.0
  Ã— No solution found when resolving dependencies:
  â•°â”€â–¶ Because myproject depends on django==5.0 and django==5.0 depends on sqlparse&gt;=0.3.1,
      we can conclude that myproject depends on sqlparse&gt;=0.3.1.
      And because myproject depends on some-legacy-package==1.0 and some-legacy-package==1.0
      depends on sqlparse&lt;0.3, we can conclude that myproject&#x27;s requirements are unsatisfiable.
</code></pre>
<p><strong>Current developer experience:</strong></p>
<ol>
<li>Read cryptic error messages</li>
<li>Manually investigate which package versions are compatible</li>
<li>Trial-and-error: try different versions, run <code>uv lock</code> again, repeat</li>
<li>Give up and either pin old versions or abandon the upgrade</li>
<li>Time wasted: 15 minutes to 2+ hours</li>
</ol>
<p><strong>Why this is a critical pain point:</strong></p>
<ul>
<li><strong>Common</strong>: Happens during every major dependency upgrade</li>
<li><strong>Frustrating</strong>: Requires deep understanding of dependency trees</li>
<li><strong>Time-consuming</strong>: Manual exploration of version compatibility</li>
<li><strong>Error-prone</strong>: Easy to make suboptimal choices</li>
<li><strong>Blocks innovation</strong>: Developers avoid upgrades to prevent conflicts</li>
</ul>
Why Current Solutions Fall Short
<ol>
<li><strong>pip</strong>: Gives up immediately with unclear error messages</li>
<li><strong>poetry</strong>: Shows conflict but no suggestions for resolution</li>
<li><strong>Manual tools</strong> (pipdeptree, etc.): Require separate analysis</li>
<li><strong>Stack Overflow</strong>: Generic advice, not specific to your dependency tree</li>
</ol>
Proposed Solution
Core Feature: Interactive Conflict Resolution
<p>When dependency resolution fails, automatically analyze the conflict and present actionable solutions:</p>
<pre><code>$ uv add django==5.0

  Ã— Dependency conflict detected

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“¦ Conflict Analysis
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Root cause: Incompatible sqlparse version requirements

  django 5.0 requires sqlparse &gt;=0.3.1
       â†“
  âš ï¸  CONFLICT
       â†“
  legacy-parser 1.0 requires sqlparse &lt;0.3

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’¡ 3 Solutions Found (analyzed in 47ms)
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Downgrade Django (Recommended)
   uv add django&gt;=4.2,&lt;5.0

   âœ“ Keeps all existing dependencies
   âœ“ django 4.2 is LTS (supported until April 2026)
   âœ“ Compatible with sqlparse 0.2.4

2. Upgrade legacy-parser
   uv add legacy-parser&gt;=2.0

   âš  legacy-parser 2.0 released 6 months ago
   âš  Breaking changes in API (see changelog)
   âœ“ Compatible with sqlparse 0.3.1+

3. Remove legacy-parser (if unused)
   uv remove legacy-parser

   âš  Used by: scripts/data_processor.py
   ğŸ’¡ Alternative: Use built-in ast module

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Apply solution? [1-3, m for more details, q to quit]: _
</code></pre>
Key Capabilities
<ol>
<li><strong>Instant conflict analysis</strong> - Leverage uv&#x27;s speed to explore solution space in &lt;100ms</li>
<li><strong>Root cause identification</strong> - Show exactly which packages are in conflict and why</li>
<li><strong>Multiple solution paths</strong> - Present 3-5 concrete solutions ranked by recommendation</li>
<li><strong>Impact analysis</strong> - Show what changes with each solution</li>
<li><strong>Interactive application</strong> - Apply fixes with a single keypress</li>
<li><strong>Learning mode</strong> - Explain why conflicts happen (optional <code>--explain</code> flag)</li>
</ol>
User Interaction Flow
Basic Mode (Default)
<pre><code>$ uv add package-with-conflict

  Ã— Conflict detected

ğŸ’¡ Quick fix available:
   Downgrade package-a from 3.0 to 2.8

Apply? [y/n/m for more options]: m

[Shows full interactive menu with 3-5 solutions]

Choose [1-5] or &#x27;a&#x27; to analyze impact: 2

ğŸ“Š Impact Analysis for Solution 2:
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Changes:
  â¬† package-a: 2.5 â†’ 3.0
  â¬† shared-dep: 1.0 â†’ 2.1 (required by package-a 3.0)
  â¬‡ legacy-tool: 5.0 â†’ 4.8 (conflicts with shared-dep 2.1)

Risk assessment: LOW
  âœ“ All packages actively maintained
  âš  legacy-tool downgrade (2 versions back)

Apply this solution? [y/n]: y

âœ“ Resolved! Lock file updated.
</code></pre>
Expert Mode
<pre><code>$ uv add package --resolve-conflicts --explain

[Shows detailed PubGrub algorithm steps]
[Explains version incompatibilities]
[Shows full dependency tree with conflicts highlighted]
</code></pre>
Automated Mode (for CI)
<pre><code>$ uv add package --resolve-conflicts=auto --prefer=minimal-changes

âœ“ Auto-resolved using minimal-changes strategy
  Changed: package-a 3.0 â†’ 2.8

âš  Review changes in uv.lock before committing
</code></pre>
Technical Approach
How It Works
<ol>
<li><strong>Detect conflict</strong> - PubGrub resolver fails with incompatibility report</li>
<li><strong>Analyze solution space</strong> - Use uv&#x27;s resolver to test alternative version combinations</li>
<li><strong>Rank solutions</strong> - Score based on:<ul>
<li>Number of packages changed</li>
<li>Recency of versions (prefer newer when safe)</li>
<li>Severity of changes (major vs minor downgrades)</li>
<li>Package maintenance status</li>
<li>Community adoption metrics</li>
</ul>
</li>
<li><strong>Present interactively</strong> - Show top 3-5 solutions with clear tradeoffs</li>
<li><strong>Apply solution</strong> - Update <code>pyproject.toml</code> and/or <code>uv.lock</code></li>
</ol>
Implementation Strategy
<ol>
<li><strong>Extend existing resolver</strong> - Build on uv&#x27;s PubGrub implementation</li>
<li><strong>Solution exploration</strong> - When resolution fails:<ul>
<li>Identify conflicting requirements</li>
<li>Generate alternative version constraints</li>
<li>Re-run resolver for each alternative</li>
<li>Cache results for performance</li>
</ul>
</li>
<li><strong>Ranking algorithm</strong>:<pre><code>fn score_solution(solution: &amp;Solution) -&gt; u32 {
    let mut score = 100;
    score -= solution.major_downgrades * 30;
    score -= solution.minor_downgrades * 10;
    score -= solution.packages_changed * 5;
    score += solution.uses_latest_versions * 10;
    score
}
</code></pre>
</li>
<li><strong>Interactive UI</strong> - Use existing <code>uv-console</code> for rich terminal output</li>
<li><strong>CLI integration</strong> - New flags:<ul>
<li><code>--resolve-conflicts</code> (auto-enable on failure)</li>
<li><code>--resolve-conflicts=auto</code> (pick best solution)</li>
<li><code>--resolve-conflicts=interactive</code> (show menu)</li>
<li><code>--prefer=minimal-changes|latest|conservative</code></li>
</ul>
</li>
</ol>
Data Sources
<ul>
<li><strong>Version metadata</strong>: PyPI JSON API (already used by uv)</li>
<li><strong>Dependency graph</strong>: uv&#x27;s resolver output</li>
<li><strong>Package health</strong>: PyPI release dates (optional enhancement)</li>
<li><strong>No external services required</strong> - Everything from existing data</li>
</ul>
Proposed Code Structure
<pre><code>crates/
  uv-resolver/
    src/
      conflict_analyzer.rs   # Analyze conflicts from resolver output
      solution_finder.rs     # Generate alternative solutions
      solution_ranker.rs     # Score and rank solutions

  uv-cli/
    src/
      commands/
        resolve_conflicts.rs # Interactive conflict resolution UI
</code></pre>
Benefits
For Developers
<ul>
<li><strong>Save time</strong>: 15min-2hr â†’ 30 seconds to resolve conflicts</li>
<li><strong>Learn faster</strong>: Understand why conflicts happen</li>
<li><strong>Make better decisions</strong>: See tradeoffs clearly</li>
<li><strong>Confidence</strong>: Know the impact before applying changes</li>
</ul>
For Teams
<ul>
<li><strong>Standardize resolution strategy</strong>: Use <code>--prefer=conservative</code> in CI</li>
<li><strong>Reduce bike-shedding</strong>: Clear data-driven recommendations</li>
<li><strong>Faster upgrades</strong>: Less friction upgrading dependencies</li>
<li><strong>Better documentation</strong>: Solution explanations serve as upgrade notes</li>
</ul>
For the Python Ecosystem
<ul>
<li><strong>Encourage upgrades</strong>: Remove friction from staying up-to-date</li>
<li><strong>Reduce version fragmentation</strong>: Easier to move ecosystem forward</li>
<li><strong>Better error messages</strong>: Educational, not just errors</li>
<li><strong>Unique to Python</strong>: No other Python tool offers this</li>
</ul>
Differentiation
<p>| Feature | pip | poetry | pdm | conda | uv + this feature |
|---------|-----|--------|-----|-------|-------------------|
| Detect conflicts | âœ… | âœ… | âœ… | âœ… | âœ… |
| Explain conflicts | âŒ | âš ï¸ (basic) | âš ï¸ (basic) | âŒ | âœ… |
| Suggest solutions | âŒ | âŒ | âŒ | âŒ | âœ… |
| Interactive resolution | âŒ | âŒ | âŒ | âŒ | âœ… |
| Solution comparison | âŒ | âŒ | âŒ | âŒ | âœ… |
| Speed | Slow | Slow | Medium | Slow | <strong>Instant (&lt;100ms)</strong> |</p>
<p><strong>Key advantage</strong>: uv&#x27;s speed makes exploring multiple solutions practical - other tools are too slow to do this interactively.</p>
Prior Art
Similar Features in Other Ecosystems
<ol>
<li><strong>cargo</strong> (Rust) - Shows helpful conflict messages but no interactive resolution</li>
<li><strong>npm/yarn</strong> - Suggests <code>--force</code> or <code>--legacy-peer-deps</code> (not helpful)</li>
<li><strong>bundler</strong> (Ruby) - Good error messages but no solution suggestions</li>
<li><strong>apt</strong> (Linux) - Suggests conflicting packages but manual resolution</li>
</ol>
<p><strong>None offer interactive solution exploration with ranked alternatives.</strong></p>
Academic Background
<ul>
<li><strong>PubGrub algorithm</strong> already identifies conflicts precisely</li>
<li>Version SAT solvers can find satisfying assignments</li>
<li>uv&#x27;s speed makes exhaustive search of solution space practical</li>
</ul>
Implementation Effort
<p><strong>Estimated scope</strong>: Medium feature (smaller than full audit system)</p>
<ul>
<li><strong>Conflict analysis</strong>: ~3-5 days (parse PubGrub output)</li>
<li><strong>Solution finder</strong>: ~1 week (test alternative constraints)</li>
<li><strong>Ranking algorithm</strong>: ~3-5 days (scoring system)</li>
<li><strong>Interactive UI</strong>: ~1 week (terminal UI with prompts)</li>
<li><strong>CLI integration</strong>: ~3-5 days (flags, options, config)</li>
<li><strong>Testing</strong>: ~1 week (conflict scenarios, edge cases)</li>
<li><strong>Documentation</strong>: ~3-5 days (guides, examples)</li>
</ul>
<p><strong>Total</strong>: ~3-4 weeks for MVP</p>
Phases
<p><strong>Phase 1 (MVP)</strong>:</p>
<ul>
<li>Detect conflicts</li>
<li>Suggest 1-3 simple solutions (downgrade X, upgrade Y, remove Z)</li>
<li>Interactive prompt to apply</li>
</ul>
<p><strong>Phase 2</strong>:</p>
<ul>
<li>Full solution ranking</li>
<li>Impact analysis</li>
<li>Multiple resolution strategies</li>
</ul>
<p><strong>Phase 3</strong>:</p>
<ul>
<li>Explain mode</li>
<li>Learning features</li>
<li>Advanced conflict visualization</li>
</ul>
Open Questions
<ol>
<li><strong>Default behavior</strong>: Auto-enable on conflict or require flag?</li>
<li><strong>Solution limit</strong>: Show top 3, 5, or all valid solutions?</li>
<li><strong>Ranking weights</strong>: How to balance recency vs stability?</li>
<li><strong>CI mode</strong>: Default strategy for non-interactive environments?</li>
<li><strong>Conflict visualization</strong>: Text-based tree or optional graph output?</li>
<li><strong>Solution caching</strong>: Cache explored solutions across runs?</li>
</ol>
Alternative Approaches
<p>If interactive resolution is too complex initially, simpler alternatives:</p>
Option A: Just Explain Conflicts Better
<ul>
<li>Parse PubGrub output into human-readable explanations</li>
<li>Show dependency chain that led to conflict</li>
<li>No solution suggestions</li>
</ul>
Option B: Single Best Solution
<ul>
<li>Skip interactive menu</li>
<li>Just suggest the single best fix</li>
<li>Add <code>--apply</code> flag to accept automatically</li>
</ul>
Option C: Config-Based Strategies
<ul>
<li>Define resolution strategy in <code>uv.toml</code></li>
<li>Auto-apply based on strategy (no interaction needed)</li>
</ul>
Real-World Use Cases
Use Case 1: Upgrading Django
<pre><code>Current: Django 3.2 (LTS ending)
Want: Django 4.2 (current LTS)
Conflict: 12 packages incompatible

Without this feature: 2-4 hours of manual work
With this feature: 2 minutes (review + apply solution)
</code></pre>
Use Case 2: Adding ML Library
<pre><code>uv add torch
Conflict: numpy version requirements clash

Solution suggested: Update scipy 1.9 â†’ 1.11 (compatible numpy range)
Time saved: 30 minutes of investigation
</code></pre>
Use Case 3: Monorepo Workspace
<pre><code>Workspace package A updated, breaks package B
Interactive mode shows: which workspace members affected
Suggests: version bounds to maintain compatibility
</code></pre>
Success Metrics
<p>If implemented, success would look like:</p>
<ul>
<li><strong>Time to resolution</strong>: &lt;5 minutes for 80% of conflicts (vs 30+ min currently)</li>
<li><strong>User satisfaction</strong>: Reduced complaints about dependency hell</li>
<li><strong>Adoption</strong>: Feature used in majority of conflict scenarios</li>
<li><strong>Education</strong>: Users learn about their dependency trees</li>
</ul>
Why This Feature Matters
<p>Dependency conflicts are a <strong>fundamental problem</strong> in package management, not a nice-to-have feature. They:</p>
<ul>
<li>Block security updates</li>
<li>Prevent framework upgrades</li>
<li>Waste developer time</li>
<li>Create technical debt</li>
<li>Discourage keeping dependencies current</li>
</ul>
<p>This feature would position uv as not just <strong>faster</strong>, but <strong>smarter</strong> - helping developers make informed decisions instead of leaving them stuck.</p>
Next Steps
<p>I&#x27;m eager to implement this feature and would take full ownership of:</p>
<ol>
<li>Creating detailed technical design document</li>
<li>Implementing the conflict analyzer and solution finder</li>
<li>Building the interactive UI</li>
<li>Writing comprehensive tests for various conflict scenarios</li>
<li>Creating documentation and examples</li>
<li>Iterating based on code review feedback</li>
</ol>
<p>This feature would make uv the first Python package manager to <strong>actively help solve conflicts</strong> rather than just reporting them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cherchyk">@cherchyk</a> on 2025-11-09 02:52</div>
            <div class="timeline-body"><p>To clarify my intent: I want to implement this feature myself and contribute it to uv.</p>
<p>I&#x27;m offering to:</p>
<ul>
<li>Take full ownership of the implementation</li>
<li>Create the detailed technical design</li>
<li>Implement the conflict analyzer, solution finder, and interactive UI</li>
<li>Write comprehensive tests covering various conflict scenarios</li>
<li>Provide documentation and usage examples</li>
<li>Iterate based on code review and community feedback</li>
</ul>
<p>I believe this feature addresses a fundamental pain point in Python dependency management, and I&#x27;m committed to delivering a high-quality implementation. I&#x27;m ready to start work once we align on the approach and scope.</p>
<p>Looking forward to your feedback on whether this aligns with uv&#x27;s roadmap!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-11-09 02:59</div>
            <div class="timeline-body"><p>Can you please disclose how much, if any, of this issue was written using an LLM?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cherchyk">@cherchyk</a> on 2025-11-09 23:46</div>
            <div class="timeline-body"><p>Is there a &quot;humans only&quot; policy I missed in the contributing guidelines? ğŸ˜„</p>
<p>The feature idea is mine, the commitment to implement is mine, and the PR will be mine. Happy to let the code speak for itself when we get there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-11-10 14:38</div>
            <div class="timeline-body"><p>There&#x27;s not a humans only policy, but the issue description is extremely verbose and hard to engage with.</p>
<p>You&#x27;re welcome to try to write some code for this, I&#x27;d start with a proof-of-concept deriving a possible fix from an error tree. It seems <em>very</em> hard to do well though, and I think it&#x27;s quite unlikely we&#x27;ll accept a contribution here. If the pull request is clearly authored by an LLM, we will not review it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2025-11-10 14:38</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:40:57 UTC
    </footer>
</body>
</html>
