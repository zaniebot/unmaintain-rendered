<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ability to select libc in a multi-libc environment - astral-sh/uv #14262</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Ability to select libc in a multi-libc environment</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/14262">#14262</a>
        opened by <a href="https://github.com/nathanscain">@nathanscain</a>
        on 2025-06-25 15:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/nathanscain">@nathanscain</a></div>
            <div class="timeline-body">Problem Statement
<p>I am needing to support modern python installations within a manylinux2010 environment which runs an incompatible gnu libc version for python-build-standalone cpython builds. I can install musl libc alongside the existing machine configuration without affecting existing critical workflows, and uv is able to link python-build-standalone against this musl libc when explicitly handed the full version description (ie: cpython-3.13.5-linux-x86_64-musl). However, as the core system utilities use a gnu libc, uv will select gnu python builds by default (ie: a request for 3.13 results in attempting – and failing – to run cpython-3.13.5-linux-x86_64-gnu) even when running the musl build of uv.</p>
Objective
<p>I need some means by which to inform uv of the libc that should be used for python version selection. This could take a few forms, and I don’t hold much preference for any 1 way over another if distributing the fix to users is not overly complex. Some options:</p>
Option A: Configuration Setting
<p>The most straight forward option would be a configuration setting which I can set in the global <code>/etc/uv/uv.toml</code> file to direct the section of the ld path used to determine the libc variant and version. This could either be direct (dynamic-linker = “/lib/ld-musl-x86_64.so.1”), simplified (libc-variant = “musl”), or a mixture of the 2 (keyed as something like “libc” and allowing “gnu” or “musl” options to shortcut to the default dynamic location for the current arch or allow a full path to a specific ld shared object). This can be paired with an environment variable; however, that is less applicable in my situation is distributing environment variables is less straight-forward than updating a system-wide configuration file.</p>
Option B: Updated Preferences
<p>This option gets at the oddity (in my option) of having the static musl build of uv select a gnu libc. Perhaps this was the objective, but I would expect the platform of the uv binary to influence the libc selection given that uv and pbs share the same minimum gnu libc requirements (as far as I am aware). This is much less direct than the first option, but perhaps more intuitive. If I am running a musl build of uv, I would expect to exhaust all options to link against musl for python (including the default ld location) before trying to like against gnu. If I wanted to link against gnu, the gnu build of uv is available with the inverse preference.</p>
Combining Options
<p>The above options are not mutually exclusive. The first is non-breaking and could be implemented immediately without issue. The second is potentially breaking and could wait till the next major version. These could be worked separately if both ideas pass muster; however, I only require one or the other (with my only preference being the one that solves my issue the fastest).</p>
Environment
<ul>
<li>uv version: 0.7.12 (latest approved for company use – 0.7.15 has no changes to libc detection)</li>
<li>os version: manylinux2010 environment + musl 1.2.5 (representative)</li>
<li>command: any command resulting in searching for a python version to use (ex: <code>uvx python@3.13</code>)</li>
</ul>
Reproduction
<ul>
<li>container: <code>quay.io/pypa/manylinux2010_x86_64:latest</code></li>
<li>download: https://musl.libc.org/releases/musl-1.2.5.tar.gz</li>
<li>untar and apply security patches for CVE-2025-26519: https://www.openwall.com/lists/musl/2025/02/13/1/1 https://www.openwall.com/lists/musl/2025/02/13/1/2</li>
<li>build and install musl libc: <code>./configure &amp;&amp; make &amp;&amp; make install</code></li>
<li>download and install x64 MUSL Linux build of uv: https://github.com/astral-sh/uv/releases/download/0.7.12/uv-x86_64-unknown-linux-musl.tar.gz</li>
<li>show that uv auto selects glibc: <code>uv python list</code></li>
<li>show that uv can use musl python build if explicitly told: <code>uvx --python cpython-3.13.5-linux-x86_64-musl python</code></li>
</ul>
References
<p>Current libc selection logic: https://github.com/astral-sh/uv/blob/4ed9c5791ba9d5c304aae14b920d612af26dc2d3/crates/uv-python/src/libc.rs#L60</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-06-25 20:48</div>
            <div class="timeline-body"><blockquote>
<p>the oddity (in my option) of having the static musl build of uv select a gnu libc</p>
</blockquote>
<p>I&#x27;m somewhat new to this topic, but I think a relevant detail to highlight is that there are sort of <em>three</em> different types of binaries, from the perspective of <code>libc</code> selection:</p>
<ul>
<li>dynamically linked to glibc</li>
<li>statically linked to musl</li>
<li>dynamically linked to musl</li>
</ul>
<p>Usually folks who target musl do that so they can statically link the whole binary. However, while static binaries don&#x27;t need to load dynamics libraries on startup (&quot;implicit&quot; linking), they also <em>cannot</em> load dynamic libraries at runtime (&quot;explicit&quot; linking, e.g. <code>dlopen</code>). It turns out that CPython is architected around explicit linking, and so our standalone musl builds dynamically link musl. That means they require <code>/lib/ld-musl-x86_64.so.1</code>, which exists on musl-based distros like Alpine but not (by default) on glibc-based distros. So it doesn&#x27;t generally follow from &quot;<code>uv</code> is targeting musl&quot; that we can run musl flavors of standalone Python. It <em>would</em> follow from &quot;<code>uv</code> is dynamically loading musl&quot;, but as far as I know almost no one builds <code>uv</code> that way?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nathanscain">@nathanscain</a> on 2025-06-25 22:19</div>
            <div class="timeline-body"><p>Yes, I agree mostly with that. uv being statically linked makes perfect sense and is where musl shines.</p>
<p>The oddity I was getting at was that, if I made the choice to install musl uv (even if statically linked) instead of the gnu version, I&#x27;d expect to favor the musl python builds (which are dynamically linked) assuming the required ld could be found. The idea was mostly &quot;implicit configuration&quot; since the gnu uv and gnu python build standalone have the same glibc minimum version afaik, so if someone (a) went through the trouble of installing the non-default musl build and (b) has an incompatible gnu libc, then it probably means they are wanting to using musl python builds to get around the gnu libc being too old. In which case, it should be verified in advance that the musl ld so exists.</p>
<p>I&#x27;m okay with that dropping out of this issue is if you&#x27;d rather avoid behavior differences by platform target in the built binaries. It was behavior I found surprising, but I could definitely see others finding uv selecting different Python platforms for different platform builds surprising if they came at it from a different angle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nathanscain">@nathanscain</a> on 2025-06-27 20:48</div>
            <div class="timeline-body"><p>@charliermarsh @zanieb @konstin</p>
<p>Sorry - forgot to tag this story when I created it.</p>
<p>Not sure if it would be an enhancement or bugfix by your standards, but I don&#x27;t have a straight-forward way to tell uv to use a particular libc variant that I know of</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-06-27 22:02</div>
            <div class="timeline-body"><blockquote>
<p>if I made the choice to install musl uv (even if statically linked) instead of the gnu version, I&#x27;d expect to favor the musl python builds (which are dynamically linked) assuming the required ld could be found</p>
</blockquote>
<p>I think this seems reasonable. I think the problems are</p>
<ol>
<li>Historically, we didn&#x27;t have functioning musl builds of Python, so we never preferred using them</li>
<li>We use static musl builds of uv in Docker, and it&#x27;s installed in images where it&#x27;s very <em>common</em> for people to still prefer GNU libc Python builds, which is contrary to your point (a) that someone went through some trouble to get this specific build of uv</li>
</ol>
<p>I think what Jack says is along the same lines as (2)</p>
<blockquote>
<p>It would follow from &quot;uv is dynamically loading musl&quot;, but as far as I know almost no one builds uv that way?</p>
</blockquote>
<p>I think these are only really arguments against &quot;Option B&quot; though, and even then I think there&#x27;s probably <em>some</em> way we can improve the default behavior — I&#x27;m just not sure yet.</p>
<p>Adding a way to bypass our libc detection and request a different target seems reasonable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-06-27 22:02</div>
            <div class="timeline-body"><p>(As a bit of an aside: please don&#x27;t ping a bunch of the team)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nathanscain">@nathanscain</a> on 2025-06-27 22:10</div>
            <div class="timeline-body"><p>(Sorry about that - will remember for the future)</p>
<p>Yes, I think that makes sense with the distroless uv container images using static musl. I hadn&#x27;t considered that.</p>
<p>As for the bypass setting approach then, how hard would it be to add something like that? I had initially looked at it but the file isn&#x27;t currently accessing configuration, and I wasn&#x27;t sure how to go about adding that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-06-27 23:15</div>
            <div class="timeline-body"><p>It&#x27;d be trivial to add a clause to <code>Libc::from_env</code> that reads an environment variable, e.g., <code>UV_LIBC</code>?</p>
<p>https://github.com/astral-sh/uv/blob/f9d3f24728d34e73cb0b01570ffd389dd2c1f92f/crates/uv-python/src/platform.rs#L77</p>
<p>Propagating a configuration file value would indeed be more work, I&#x27;m not sure how much of a pain it&#x27;d be to thread through — we don&#x27;t infer other parts of the platform from configuration files so probably not fun.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-07-01 12:18</div>
            <div class="timeline-body"><blockquote>
<p>I am needing to support modern python installations within a manylinux2010 environment which runs an incompatible gnu libc version for python-build-standalone cpython builds.</p>
</blockquote>
<p>Can you expand on why you have that requirement? Why are you not using a modern, supported distribution?</p>
<p>uv infers the libc from the Python interpreter you give, so if you explicitly request a musl in <code>uv python install</code> or with <code>-p</code>, uv respects that selection no matter how the host looks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nathanscain">@nathanscain</a> on 2025-07-01 13:06</div>
            <div class="timeline-body"><p>Sure - we operate and maintain a number of legacy systems for various critical purposes (sorry to be vague). Work is ongoing to upgrade these, but they are delicate systems that some are wary about touching at all. The process has been slower than I&#x27;d prefer, but that is generally out of my control and musl provides a path to install modern software alongside the existing configuration without driving a significant, immediate cost of migration - allowing a phased approach to the transition. As unfortunate as this reality is, I don&#x27;t believe we are alone in this regard.</p>
<p>Yes - I am able to install musl builds on these machines if I am explicit (ref: last reproduction step above); however, it would be a different interface for users we will need to train as the majority of systems will just need <code>uv python install 3.13</code>. Installing (and more importantly, selecting throughout the day) musl requires the much longer and more error-prone <code>uv python install cpython-3.13.5-linux-x86_64-musl</code> as I don&#x27;t believe I can just indicate the platform without also providing the flavor, patch revision, os, and arch. Ideally, the same command we train users to use on other systems works transparently for users.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-16 13:52</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:39:10 UTC
    </footer>
</body>
</html>
