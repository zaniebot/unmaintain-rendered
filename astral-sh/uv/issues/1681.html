<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support `pip wheel` subcommand - astral-sh/uv #1681</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support `pip wheel` subcommand</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/uv/issues/1681">#1681</a>
        opened by <a href="https://github.com/kvelicka">@kvelicka</a>
        on 2024-02-19 08:42
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/kvelicka">@kvelicka</a> on 2024-02-19 08:42</div>
            <div class="timeline-body"><p>I've been trying <code>uv</code> on work projects to assess its coverage and suitability of being a full <code>pip</code>/<code>pip-tools</code> replacement for us. One of the features of pip that we use is <code>pip wheel</code>, which seems to not be supported by <code>uv</code> currently and I couln't find an open ticket discussing it, so I'm making one here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-02-19 17:42</div>
            <div class="timeline-body"><p>We have all the plumbing to do this, I'm not sure where it fits on our roadmap though.</p>
<p>I'm curious how this would relate to</p>
<ul>
<li>#1510</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2024-02-19 17:51</div>
            <div class="timeline-body"><p>Pip would prefer to remove the <code>wheel</code> subcommand AFIAK, and has refused adding a matching <code>sdist</code> command. I think <code>uv build --wheel</code> (along with <code>uv build --sdist</code> and <code>uv build</code>, which builds both) would be better than adding <code>uv pip wheel</code>.</p>
<p><code>pip wheel</code> does one thing differently, by the way - it includes any wheels it also <em>builds</em> (but not just downloads), while <code>build --wheel</code> only gives you the wheel you asked for. But most of the time that's actually a bug (trying to upload wheels you don't own), and <code>pip download</code> is there if you want to actually get existing files from PyPI (not in uv yet though).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-02-19 18:16</div>
            <div class="timeline-body"><p>Thanks for the additional context. I wonder what we can provide for people who want to generate wheels for all their dependencies though. It makes sense for pre-building and sharing when they aren't distributed by the original package.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @zanieb on 2024-02-19 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">compatibility</span> added by @zanieb on 2024-02-19 18:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-02-21 17:07</div>
            <div class="timeline-body"><blockquote>
<p>I wonder what we can provide for people who want to generate wheels for all their dependencies though. It makes sense for pre-building and sharing when they aren't distributed by the original package.</p>
</blockquote>
<p>I echo this. <code>pip wheel</code> is useful to download and build all parts of an app for deployment. For instance in a multi-stage Dockerfile it is common to have a fat build stage with all build tools to create the wheels, then a slim stage which only installs the wheels built in the previous stage.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1760.html">astral-sh/uv#1760</a> on 2024-02-21 17:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2024-02-21 18:08</div>
            <div class="timeline-body"><p>But it doesn‚Äôt actually put wheels in the wheelhouse if there‚Äôs already a built wheel, IIRC? Pip download will get everything you need then you can loop over any SDists and build them if you need them?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-02-21 18:21</div>
            <div class="timeline-body"><blockquote>
<p>But it doesn‚Äôt actually put wheels in the wheelhouse if there‚Äôs already a built wheel, IIRC?</p>
</blockquote>
<p>@henryiii I'm not entirely sure what you mean with that?</p>
<blockquote>
<p>Pip download will get everything you need then you can loop over any SDists and build them if you need them?</p>
</blockquote>
<p>Sure. <code>pip wheel</code> is convenient because it does exactly that for you.</p>
<p>Actually <code>pip wheel</code> is quite easy to implement and maintain because, it basically does everything <code>pip install</code> does except it stores the wheels (whether they are downloaded or built locally) into a directory instead of unpacking them in site-packages. I'd argue it is simpler than <code>pip download</code>, from my experience with that part of the pip code base.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-02-21 18:29</div>
            <div class="timeline-body"><p>That said, <code>build</code>, <code>wheel</code> and <code>download</code> are all useful, they are for different use cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2024-02-21 18:34</div>
            <div class="timeline-body"><blockquote>
<p>because it does exactly that for you ... whether they are downloaded or built locally</p>
</blockquote>
<p>That's the problem, it does not store wheels that are downloaded. So if you depend on <code>numpy</code>, you will not get a <code>numpy</code> wheel in your wheelhouse <em>unless</em> there is no <code>numpy</code> wheel for that platform. This causes <code>twine wheelhouse/*</code> to work until you build on a platform without numpy wheels, then it crashes because you can't push <code>numpy</code> to PyPI. We have to work around that in <code>cibuildwheel</code>, as well as all the other builders that have an option to use <code>pip wheel</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sbidoul">@sbidoul</a> on 2024-02-21 18:57</div>
            <div class="timeline-body"><blockquote>
<p>That's the problem, it does not store wheels that are downloaded. So if you depend on numpy, you will not get a numpy wheel in your wheelhouse unless there is no numpy wheel for that platform.</p>
</blockquote>
<p>That's strange. It is not my understanding of how <code>pip wheel</code> works. I use it daily and it always stores a wheel for each top level requirement and all their dependencies, whether dependent wheels exist in the index (in which case it will download them to the wheelhouse) or not (in which case it will download the sdists, build them and store the resulting wheels in the wheelhouse).</p>
<p>Now if the purpose is uploading wheels to an index, I'd use <code>build -w</code>, or <code>pip wheel --no-deps</code>, which are more or less equivalent?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2024-02-21 20:13</div>
            <div class="timeline-body"><p>I‚Äôll investigate, maybe it changed or there‚Äôs an another reason it was behaving like that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/akx">@akx</a> on 2024-03-27 13:05</div>
            <div class="timeline-body"><p>I'd like an <code>uv pip wheel</code> sort of command; it's very useful for multi-stage Docker image builds where you might need e.g. the full Python dev kit to build wheels, and then want to just use those cached wheels in a subsequent stage, √° la</p>
<pre><code>FROM python:3.12 AS requirements
COPY requirements.txt /wheels/requirements.txt
RUN cd /wheels &amp;&amp; pip wheel --no-cache-dir -r requirements.txt

FROM python:3.12-slim AS runtime
RUN --mount=type=cache,ro,from=requirements,source=/wheels,target=/wheels pip install --no-cache-dir --no-index --find-links /wheels /wheels/*.whl
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/potiuk">@potiuk</a> on 2024-03-27 13:26</div>
            <div class="timeline-body"><blockquote>
<p>I'd like an uv pip wheel sort of command; it's very useful for multi-stage Docker image builds where you might need e.g. the full Python dev kit to build wheels, and then want to just use those cached wheels in a subsequent stage, √° la</p>
</blockquote>
<p>Small comment on that one (I do not contest the need for pip wheel of course just explaining how we are doing it in Airflow). I found that you can do quite a bit better than that by just copying the whole <code>venv</code> installed in the &quot;build stage&quot;. If you keep it in the same location, this will work out of the box as well.</p>
<p>Smthing like:</p>
<pre><code>FROM python:3.12 AS requirements
COPY requirements.txt /requirements.txt
RUN python -m venv /home/user/.venv &amp;&amp; /home/user/.ven/bin/python -m pip install -r /requirements.txt

FROM python:3.12-slim AS runtime
COPY --from=requirements ~/home/user/.venv /home/user/.venv
</code></pre>
<p>That saves the hassle of running <code>pip/uv install</code> twice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-04-05 05:57</div>
            <div class="timeline-body"><p>Just to second this issue, my pipeline is dependent on the recursive nature of <code>pip wheel</code> to download all dependencies into a wheelhouse which we can then install offline. Using <code>pip download</code> is possible but would require another loop to build wheels for everything into a proper wheelhouse and I'd really be looking for the <code>uv</code> equivalent to support the full cycle directly from requirements file -&gt; wheelhouse.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pradyunsg">@pradyunsg</a> on 2024-04-06 15:14</div>
            <div class="timeline-body"><p>I tend to think of <code>pip wheel</code> as being useful for multiple roles:</p>
<ul>
<li>&quot;give me a bunch of wheels&quot; by default.</li>
<li>&quot;give me a wheel for this package&quot; via an opt-in (<code>--no-deps</code>).</li>
</ul>
<p>The default is <em>not</em> the most common operation during development, and the functional behaviour provided by <code>pypa/build</code> is better suited to the right behaviours during package development workflows. Ideally, these two should be under a logically different commands in uv.</p>
<p>None the less, my two cents would be that this shim should not be provided and uv should instead focus on its own dedicated CLI outside of the pip namespace; keeping these two &quot;consumer&quot; and &quot;publisher&quot; pieces separated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vigneshmanick">@vigneshmanick</a> on 2024-04-11 07:45</div>
            <div class="timeline-body"><p>To second this issue, In our usecase we build the wheel once (<code>pip wheel . -w dist</code>)and store it as an artifact which is then used by subsequent pipelines.  This helps us to ensure that the production and ci environments are consistent and also helps to manually check the wheel contents without having to resort to additional commands.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3065.html">astral-sh/uv#3065</a> on 2024-04-16 16:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3163.html">astral-sh/uv#3163</a> on 2024-04-23 16:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6323.html">astral-sh/uv#6323</a> on 2024-08-21 23:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @charliermarsh by @charliermarsh on 2024-08-31 16:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @charliermarsh by @charliermarsh on 2024-08-31 18:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/7148.html">astral-sh/uv#7148</a> on 2024-09-06 23:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-09-06 23:48</div>
            <div class="timeline-body"><p>FWIW I added a concrete example of how I use pip wheel to https://github.com/astral-sh/uv/issues/7148 if it's helpful in motivating this feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2024-09-06 23:51</div>
            <div class="timeline-body"><p>The command <code>uv build</code> now exists, does this not cover this requirement?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-09-07 00:00</div>
            <div class="timeline-body"><p>The issue is that the new command doesn‚Äôt build the dependencies. Neither the local dependencies in the workspace nor the remote dependencies from the package index.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pex-tool/pex/pulls/2512.html">pex-tool/pex#2512</a> on 2024-09-13 19:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pex-tool/pex/issues/2371.html">pex-tool/pex#2371</a> on 2024-09-13 19:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Ralith">@Ralith</a> on 2024-09-16 05:40</div>
            <div class="timeline-body"><p>This would be useful for packaging Blender extensions, which need their dependencies bundled as wheels in a subdirectory: https://docs.blender.org/manual/en/dev/advanced/extensions/python_wheels.html</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/7811.html">astral-sh/uv#7811</a> on 2024-09-30 15:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sliva0">@sliva0</a> on 2024-10-02 15:16</div>
            <div class="timeline-body"><p>This issue is essential to adopt <code>uv</code> in a project I'm working on to make reproducible offline installations possible, and it doesn't seem to move forward. Is there a way I can contribute to working on this as a rust novice?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/7995.html">astral-sh/uv#7995</a> on 2024-10-08 05:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../blakeblackshear/frigate/pulls/14759.html">blakeblackshear/frigate#14759</a> on 2024-11-03 20:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../blakeblackshear/frigate/issues/14757.html">blakeblackshear/frigate#14757</a> on 2024-11-05 13:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../unioslo/mreg/pulls/553.html">unioslo/mreg#553</a> on 2024-11-10 10:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2024-11-15 19:55</div>
            <div class="timeline-body"><p>This issue has become a blocker for hardened python images, as we use want to use uv in a build step to and then copy over the dependencies into a venv we can't overwrite (Iron Bank images as a concrete example https://repo1.dso.mil/dsop/opensource/python/python313)</p>
<p>Similar to other people, I'd like to build reproducible wheels in an environment with dev dependencies (cmake), as the hardened images don't have anything to work with. My workaround has been using uv export to generate a requirements.txt, then pull an ubi9 image to build the wheels, and then load them into the required venv, but this, as you can imagine, is not fun.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-11-15 20:50</div>
            <div class="timeline-body"><p>Building on my earlier comments, I'll expand slightly with a concrete workaround.</p>
<p>I'm hacking around the lack of this feature right now by using a combination of <code>uv export</code> and <code>pip</code>. A reminder that the workspace itself is a bunch of independent packages with their own build backend etc that can be built using other build tools like <code>pip wheel</code>, <code>python -m build</code>, or <code>uv build</code> so you can pick things apart and build them as needed without uv commands. For example:</p>
<pre><code>uv export --no-hashes --locked --format requirements-txt &gt; requirements.txt
grep -v '^-e ' requirements.txt &gt; requirements.remote.txt

# build all remote wheels
pip wheel -w wheels --find-links wheels -r requirements.remote.txt

# build all local packages to wheels
uv build --all-packages --wheel -o wheels
</code></pre>
<p>You can expand this further, for example I'm doing similar things for other dependency groups independently, or build requirements first,, and I'm not actually using <code>uv build</code> directly because I'm caching the local wheels based on git commits since <code>uv build</code> does not cache things well to avoid rebuilding 20 packages if only 1 changed.</p>
<p>The goal of something like this ticket is that we could just directly use uv build like this <code>uv build --all-packages --wheel -o wheels</code> and tack on another flag like <code>--recursively-build-all-deps</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2024-11-15 20:56</div>
            <div class="timeline-body"><blockquote>
<p>pip wheel -w wheels --find-links wheels -r requirements.remote.txt</p>
</blockquote>
<p>You can also add <code>--no-deps</code> here to save pip from reading and resolving dependencies, since you already have fully resolved the dependencies with uv.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2024-11-17 14:47</div>
            <div class="timeline-body"><p>I've started working on this, please let me know if anyone else is. Most of the plumbing is already there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-11-17 16:32</div>
            <div class="timeline-body"><p>I should note it‚Äôd be nice if there was an option to build only the dependencies and not the local packages - and specifically only the dependencies that aren‚Äôt in the target destination already similar to how <code>--find-links</code> works. :-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2024-11-17 17:14</div>
            <div class="timeline-body"><blockquote>
<p>I should note it‚Äôd be nice if there was an option to build only the dependencies and not the local packages - and specifically only the dependencies that aren‚Äôt in the target destination already similar to how <code>--find-links</code> works. :-)</p>
</blockquote>
<p>I'll need to think about the right way to do this, but my general design idea is:</p>
<p><code>uv build</code>: build wheels (already exists)
<code>uv build --all-packages</code>: build wheels for all workspace packages (already exists)
<code>uv build --with-deps</code>: build wheels + dependencies
<code>uv build --all-packages --with-deps</code>: build wheels + dependencies for all workspace packages
<code>uv pip wheel</code>: same as <code>uv build --with-deps</code>, provided as shim</p>
<p>I'm not sure what's the best way to support installing <strong>only</strong> dependencies.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Tremeschin">@Tremeschin</a> on 2024-11-17 19:11</div>
            <div class="timeline-body"><p>@abhiaagarwal These new proposed options looks great! I may have a novel use case for them btw üòÑ</p>
<p>Basically, since it would download and build a fully reproducible offline installation talked previously, we can side-load all wheels on a pyapp binary (I have a fork for it) for a simpler solution on entirely offline executables :)</p>
<p>My two cents; It would also be nice if we could specify <code>--platform {windows,linux,macos} --arch {x86_64,arm64}</code> etc. for getting cross platform files, and also support for <code>uv pip download</code> (as <code>uv download</code>?) for individual/outlier packages like pytorch and its many flavors, but this might be out of this issue's scope or complex to implement haha</p>
<p>Looking forward for progress on this! üëçüèª</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/T-256">@T-256</a> on 2024-11-17 20:55</div>
            <div class="timeline-body"><blockquote>
<p>I've started working on this, please let me know if anyone else is. Most of the plumbing is already there.</p>
</blockquote>
<p>Hey, it's great to hear that, there are some of my thoughts about combined version of <code>pip wheel</code> and <code>pip download</code>:
https://github.com/astral-sh/uv/issues/3163#issuecomment-2481505055</p>
<blockquote>
<p>I'm not sure what's the best way to support installing <strong>only</strong> dependencies.</p>
</blockquote>
<p>As mentioned in examples in there, I think it could be solved by index filtering (May need to have extra index configuration in <code>pyproject.toml</code> to explicitly split them.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2024-11-17 20:55</div>
            <div class="timeline-body"><p>@Tremeschin yeah, that's the thing, pip install / wheel / download are all expressions of the same base concept, except doing slightly different things (ie. wheel is just download, except it also builds if it can't pull a wheel directly from the index).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2024-11-17 20:58</div>
            <div class="timeline-body"><p>@T-256 you read my mind, I was also thinking of the exact nomenclature of <code>uv collect</code>, because <code>uv pip download/wheel</code> can be implemented using the exact same logic in <code>uv build</code> except for the actual building part. Since uv uses its cache first, the act of &quot;downloading a wheel&quot; is already abstracted away (we just need to query the cache for the wheel, it'll download it if it doesn't exist, and then actually package it as a .whl).</p>
<p>It also ties in to a higher-level abstraction of the cache itself, ie <code>uv cache populate</code> or something of that sort</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-11-21 22:25</div>
            <div class="timeline-body"><blockquote>
<p>I'm not sure what's the best way to support installing only dependencies.</p>
</blockquote>
<p>I'd request a <code>--only-deps</code> option on both <code>uv export</code> and on <code>uv build</code>. It would trigger the flow to exclude anything that is local and only build things that it'd normally have to get from an index. With <code>uv export</code> the rendered lock files wouldn't contain the local packages. With <code>uv build</code> it would not build the local packages, just the external things they depend on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2024-11-21 22:57</div>
            <div class="timeline-body"><p>You have to build local packages to get the dependency list, though? You can shortcut it in the case of a PEP 621 package without dependencies in the dynamic array, and some backends let you shortcut the build with the get metadata hook, but sometimes you have to build the package to get the deps.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmerickel">@mmerickel</a> on 2024-11-21 23:12</div>
            <div class="timeline-body"><p>That dependency information is already in the lock file but otherwise yes you would need to build/discard it to get the metadata if you didn't have a lock file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/edwardpeek-crown-public">@edwardpeek-crown-public</a> on 2024-11-21 23:37</div>
            <div class="timeline-body"><p>FWIW our use case for <code>pip wheel</code> and dependencies we already know what the dependencies we want are, so just run <code>pip wheel --no-deps $DEPENDENCY</code> for each of them.</p>
<p>You can get a such a list already using <code>[uv] pip compile -e $PROJECT_DIR</code> so full <code>--only-deps</code> functionality might not be needed for an MVP implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../skypilot-org/skypilot/issues/4428.html">skypilot-org/skypilot#4428</a> on 2024-12-02 23:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Spindel">@Spindel</a> on 2024-12-03 16:45</div>
            <div class="timeline-body"><p>I've got multiple uses of &quot;pip wheel&quot;,  one of them is as many others, artifacts for a build or multi-stage pipeline,  where we also separate dev dependencies (linters, etc)  from real deps, so we can always use the same for child pipelines. Sometimes these end up in a kind of &quot;dev container&quot; that's used as a base, in order to prevent updated packages in repositories from causing new fun issues.</p>
<p>The other case is to make sure our internal repo has cached binary builds of certain projects for non x86_64 platforms,  fex. lxml, cryptography, etc.</p>
<p>So, for that reason, being able to download or build both <code>--dev</code> and normal deps is needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kimvais">@kimvais</a> on 2024-12-17 08:52</div>
            <div class="timeline-body"><blockquote>
<p><code>pip wheel</code> does one thing differently, by the way - it includes any wheels it also <em>builds</em> (but not just downloads), while <code>build --wheel</code> only gives you the wheel you asked for. But most of the time that's actually a bug (trying to upload wheels you don't own), and <code>pip download</code> is there if you want to actually get existing files from PyPI (not in uv yet though).</p>
</blockquote>
<p>Actually, including wheels you don't &quot;own&quot; is desirable for several use cases, namely for private PyPI-like repositories (e.g. Google Artifact registry, AWS CodeArtifact et al.) at least:</p>
<ol>
<li>Security. If you can publish all the dependencies in your private repo, there is not even a theoretical code injection via PyPI vulnerability as you can use <code>--index-url</code> instead of <code>--extra-index-url</code>. Consider package &quot;companyname-foobar-security<code>- if you use</code>--extra-index-url` and someone guesses the package name and pushes the package with that name and most satisfactory version number -&gt; RCE.</li>
<li>Faster build times when you had to version lock a dependency, or the binary wheel isn't available for your runtime and arch combination for some other reason and each <code>uv pip install</code> needs to rebuild the package from sdist.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ion-elgreco">@ion-elgreco</a> on 2025-01-17 09:33</div>
            <div class="timeline-body"><p>@abhiaagarwal hey! Did you make any progress on this? :D</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2025-01-17 11:53</div>
            <div class="timeline-body"><p>@ion-elgreco I had, and then we managed to solve the problem without the use of <code>pip wheel</code> so it became less of a priority.</p>
<p>I can publish a WIP branch once I rebase on main, if that would be useful for you?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Skillossus">@Skillossus</a> on 2025-02-06 14:53</div>
            <div class="timeline-body"><p>@abhiaagarwal really curious as well if you have a tl;dr of how you accomplished this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../winpython/winpython/issues/1481.html">winpython/winpython#1481</a> on 2025-02-13 18:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/omer54463">@omer54463</a> on 2025-02-14 20:50</div>
            <div class="timeline-body"><p>Is anyone working on this feature? I could really use it.
My current solution is to install pip, which works but isn't ideal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2025-02-15 22:57</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> really curious as well if you have a tl;dr of how you accomplished this.</p>
</blockquote>
<p>Haven't had cycles to rebase recently, but the general idea is you can pull directly from uv's wheel cache using the same logic as the sync command, just into a directory rather than a venv. This is also how pip download can be naturally supported.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ajanitshimanga">@ajanitshimanga</a> on 2025-03-06 01:10</div>
            <div class="timeline-body"><p>Is this being worked on currently? I am considering adopting uv as the dependency manager of choice for my application but found a post mentioning that, &quot;uv doesn't generate wheels, so my quest is: UV unusable for 2-stage docker image building&quot; (<a href="https://medium.com/@gnetkov/start-using-uv-python-package-manager-for-better-dependency-management-183e7e428760">medium link</a>) and would I have to work around UV by using requirements.txt or pip directly. Additionally, how difficult is this to implement, is this something a new contributor can pick up?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/detlefla">@detlefla</a> on 2025-03-11 21:33</div>
            <div class="timeline-body"><p>I'd also love to see some functionality like this in uv. I'm still using <code>pip wheel</code> for this (which has to be run by uv again so that it picks up the right Python interpreter ‚Äì not a good fit for a uv-based workflow) for deployments on webservers which shouldn't have compilers and dev tools / libs installed.</p>
<p>It would be even better if <code>uv sync</code> had an option for dropping a wheel into a directory for each installed package, making sure that this wheel and the hash in uv.lock agree. Then the wheels and the lock file could be copied over to the server and safely synced into a venv there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/12475.html">astral-sh/uv#12475</a> on 2025-03-26 03:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2025-03-26 12:11</div>
            <div class="timeline-body"><p>I opened a draft MR for this, after looking through uv's cache at work on a whim and realizing uv's cache internal archive format is entirely identical to a wheel (validated with <code>diff -r -q</code> between uv/pip wheel) and you can just zip the archive to create a &quot;wheel&quot;. It's kind of an open question whether this is correct behavior / something that I should rely on, because from a design perspective, it means that uv is tied to the implementation of its cache resembling a wheel, which <em>feels</em> bad.</p>
<p>That being said, treating <code>uv pip wheel</code> as another part of <code>uv pip install</code>, since <code>uv pip install</code> also downloads dependencies / builds them is the right approach. It's now the question of how given a prefilled cache, we turn that into wheels.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/henryiii">@henryiii</a> on 2025-03-26 16:25</div>
            <div class="timeline-body"><blockquote>
<p>uv doesn't generate wheels</p>
</blockquote>
<p>Reminder, <code>uv build --wheel</code> absolutely does generate wheels. It just doesn't save wheels for your dependencies too. I think these are the common needs, ordered by how commonly they are needed:</p>
<ul>
<li>The end wheel only. That's <code>uv build --wheel</code>. Good for uploading to PyPI. If you just want to download an existing wheel, <code>pip download numpy</code> is identical to <code>pip wheel numpy</code> (no uv equivalent for that one).</li>
<li>All dependencies too. That's <code>pip download</code> (no uv equivalent). Good for making your own index (including for tests).</li>
<li>All dependencies + build wheels for SDist-only dependencies (no uv equivalent). Good for making your own index on a specific platform.</li>
</ul>
<p>I believe <code>pip wheel</code> used to not save wheels for things that were already wheels on PyPI, but it looks like modern versions do save all dependency wheels. I think <code>pip wheel</code> then is identical to <code>pip download</code>, then running <code>uv build --wheel</code> on every SDist, then deleting all the SDists.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/abhiaagarwal">@abhiaagarwal</a> on 2025-03-26 16:42</div>
            <div class="timeline-body"><p><code>uv build --wheel</code> doesn't technically generate wheels. What does generate wheels is the build backend, which uv calls (via the build frontend). That's kind of the problem here, uv has the unzip wheel =&gt; store in cache, but it doesn't have the reverse. I found that by zipping their cache you get a wheel that is hash-equivalent to the indexed wheel.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../ansys/actions/pulls/754.html">ansys/actions#754</a> on 2025-04-02 15:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../BrokenSource/Pyaket/issues/2.html">BrokenSource/Pyaket#2</a> on 2025-04-18 17:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/waynew">@waynew</a> on 2025-04-25 21:03</div>
            <div class="timeline-body"><p>I thought that I had posted it but I can't find it in here -- <code>uvx pip download . -d dist</code> actually works for me so far ü§∑</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BradyAJohnston">@BradyAJohnston</a> on 2025-04-26 01:53</div>
            <div class="timeline-body"><p>@waynew that's just using <code>uv</code> to run the actual <code>pip</code> module, rather than <code>uv</code>'s submodule (equivalent to running <code>python -m pip download</code>). People are wanting to actually use <code>uv</code> for the download which is much faster for dependency resolution &amp; downloading, rather than just running vanilla <code>pip</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/waynew">@waynew</a> on 2025-04-28 12:52</div>
            <div class="timeline-body"><p>Ah - yes; apparently I forgot to include that bit. It's definitely just a workaround -- mainly it avoids the scenario where your platform doesn't like installing <code>pip</code>.</p>
<p>Though... now I wonder if there's a <code>pip download</code> that could use <code>uv</code>'s cache until <code>uv</code> gets their own <code>pip download</code> equivalent.</p>
<p>Anyway -- entirely ‚ûï üíØ  on uv having a baked-in command. For anyone who still needs to download deps, but also wants to use <code>uv</code>s workflow and not have to have <code>pip</code> installed as a dependency of their project, or has a platform that doesn't like you having pip... hopefully that helps!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw">@notatallshaw</a> on 2025-04-28 13:44</div>
            <div class="timeline-body"><p>@BradyAJohnston @waynew the problem is the cache, uv caches installed packages, but pip caches distributions.</p>
<p>At the moment it's not clear to me, without a cache redesign, that uv would be faster than pip, when cache is available pip can simply copy the files, but uv either needs to try and recreate the wheels (it can't recreate sdists) or redownload them. When cache isn't available the scenario tends to be dominated by IO, uv downloads concurrently but this doesn't always help and in some edge cases slows things down.</p>
<p>Maybe uv would be better suited by coming up with its own solution to your use case rather than copying pip. For example having a command that creates one zip file, or a zip file per package, of the relevant uv cached packages, and uv can be pointed to that file and extract them from there.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/waynew">@waynew</a> on 2025-04-28 14:09</div>
            <div class="timeline-body"><p>I wouldn't claim to have a comprehensive scenario of folks' <code>uv</code> usage, and while <a href="https://hynek.me/articles/docker-uv/">I'd love a slightly different flow</a> currently I'm limited to using <code>uv</code> pretty much only in my development environment. And my target deploy environment has extremely limited capabilities. If I want <code>.whl</code>s over there I have to <code>rsync</code> from the dev environment. So I use <code>pip download</code> to pull all the wheels that I can sync over to the dev/staging/prod environments.</p>
<p>Not sure how this fits in with uv's caching model, but it's my current approach that works!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/edwardpeek-crown-public">@edwardpeek-crown-public</a> on 2025-04-29 00:35</div>
            <div class="timeline-body"><p>Our workflow would benefit from the caching being shared across:</p>
<ul>
<li><code>uv pip compile</code> - for filtering pinned CI + runtime deps down to just runtime deps</li>
<li><code>uv pip sync</code> - for installing all pinned deps into a CI venv</li>
<li><code>pip wheel</code> (or uv alternative) - for bundling runtime deps so they can be efficiently offline installed into arbitrary venvs</li>
</ul>
<p>In the past we've seen a lot of time wasted by these steps individually repeating expensive builds of packages including native code (eg. numpy, uwsgi), which is why a common cache between all three is helpful. Right now there's no way to avoid steps 1 &amp; 3 doing redundant work</p>
<p>Step 3 could hypothetically be replaced by hacking something out of <code>uv venv --relocatable</code>, but we'd prefer to use standard packaging (ie. wheels) rather than reworking it all around uv-exclusive functionality.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/14384.html">astral-sh/uv#14384</a> on 2025-07-02 13:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pex-tool/pex/pulls/2803.html">pex-tool/pex#2803</a> on 2025-07-02 18:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../Nitrokey/pynitrokey/issues/610.html">Nitrokey/pynitrokey#610</a> on 2025-07-15 16:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../aspect-build/rules_py/pulls/544.html">aspect-build/rules_py#544</a> on 2025-09-22 03:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/akaszynski">@akaszynski</a> on 2025-10-29 15:17</div>
            <div class="timeline-body"><blockquote>
<p>I thought that I had posted it but I can't find it in here -- <code>uvx pip download . -d dist</code> actually works for me so far ü§∑</p>
</blockquote>
<p>This would be perfect, except it doesn't support the <code>--python-platform</code> flag.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/noonedeadpunk">@noonedeadpunk</a> on 2025-11-07 11:57</div>
            <div class="timeline-body"><p>+1 to the discussion. We are also missing equivalent of <code>pip wheel --requirement</code> to download/build wheels for third-party packages as part of software deployment process, when we wanna to prepare a local cache based of constraints, which will be served later during installation.</p>
<p>But we don't have a python project to build from, rather a list of requirements.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../sandialabs/sceptre-bennu/pulls/44.html">sandialabs/sceptre-bennu#44</a> on 2025-11-24 21:13</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:56 UTC
    </footer>
</body>
</html>
