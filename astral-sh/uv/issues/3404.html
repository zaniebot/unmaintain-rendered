<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workspace support - astral-sh/uv #3404</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Workspace support</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/3404">#3404</a>
        opened by <a href="https://github.com/konstin">@konstin</a>
        on 2024-05-06 13:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/konstin">@konstin</a> on 2024-05-06 13:48</div>
            <div class="timeline-body"><p>Workspaces are a feature aimed at supporting multiple packages in the same repository. It makes large projects easier to manage by splitting them into smaller packages with independent dependencies. They handle editable installs and publishing automatically.</p>
<p>They are a commonly supported feature in other ecosystems, see the <a href="https://gist.github.com/konstin/3dce73923cd4e963a580c1a17e27fdf6">Review of large projects on github</a> and <a href="https://gist.github.com/konstin/ec2e7f6cd351c7123b22b1f4c32a5691">Review of packaging tools</a>. Our implementation will be modeled after cargo and rye.</p>
<h2>Usage</h2>
<p>There a two main usage patterns: A root package and helpers, and the flat workspace.</p>
<p>Root package and helpers:</p>
<pre><code>albatross
├── packages
│   ├── provider_a
│   │   ├── pyproject.toml
│   │   └── src
│   │       └── provider_a
│   │           ├── __init__.py
│   │           └── foo.py
│   └── provider_b
│       ├── pyproject.toml
│       └── src
│           └── provider_b
│               ├── __init__.py
│               └── bar.py
├── pyproject.toml
├── README.md
├── uv.lock
└── src
    └── albatross
        └── main.py
</code></pre>
<p>Flat workspace</p>
<pre><code>albatross
├── packages
│   ├── albatross
│   │   ├── pyproject.toml
│   │   └── src
│   │       └── albatross
│   │           ├── __init__.py
│   │           └── foo.py
│   ├── provider_a
│   │   ├── pyproject.toml
│   │   └── src
│   │       └── provider_a
│   │           ├── __init__.py
│   │           └── foo.py
│   └── provider_b
│       ├── pyproject.toml
│       └── src
│           └── provider_b
│               ├── __init__.py
│               └── bar.py
├── pyproject.toml
├── README.md
└── uv.lock

</code></pre>
<h2>Structure</h2>
<p>A workspace consists of a <em>workspace root</em> and <em>members</em> in the workspace.</p>
<p>The <em>workspace root</em> is a directory with a <code>pyproject.toml</code>, all members need to be below that directory. The workspace root defines <em>members</em> and <em>exclusions</em>. All packages below it must either be a member or excluded. The workspace root can be a package itself or it is a <em>virtual manifest</em>.</p>
<p>Each member is a directory with a <code>pyproject.toml</code> that contains a <code>[project]</code> section. Each member is a python package, with a name, a version and dependencies. Workspace members can depend on other workspace members. You can consider the workspace another package source or index, similar to <code>--find-links</code>.</p>
<h2>Workspace discovery</h2>
<p>Currently in the <code>uv pip</code> interface, you have to explicitly provide the input files to use for dependencies. In the post-pip interface, uv will be based around workspaces with packages. For that, we need to find the relevant <code>pyproject.toml</code> files.</p>
<ul>
<li>Go from the current directory up until we find a <code>pyproject.toml</code>. This is the current package.</li>
<li>If the package <code>pyproject.toml</code> contains a <code>tool.uv.workspace</code> section, it’s also the workspace root.</li>
<li>If not, go up again until we find a <code>pyproject.toml</code><ul>
<li>If it exists and contains a <code>tool.uv.workspace</code> section:<ul>
<li>If we’re in the <code>members</code>, it’s the workspace root.</li>
<li>If we’re in the <code>excludes</code>, the package pyproject.toml is implicitly the workspace root, don’t go any further up.</li>
<li>If we’re in neither, error, that’s not allowed.</li>
</ul>
</li>
<li>If it does not exist (we end up at the filesystem root), the package <code>pyproject.toml</code> is implicitly the workspace root (like cargo)</li>
<li>If it exists, but does not contain a <code>tool.uv.workspace</code>, ignore, our package in the data or test files of some other package.</li>
</ul>
</li>
<li>Check: Go up further and check that there isn’t another invalid workspace root above ours that includes us.</li>
<li>Walk through the directories in the <code>members</code> and collect all other workspace member packages</li>
<li>Check: Between our workspace root and either member package directory, there isn’t any other stray <code>pyproject.toml</code></li>
<li>Collect all entrypoint/scripts from the entire workspace, so we can run them no matter in which directory we are.</li>
<li>Lower the requirements of our target package using the information about the available workspace packages. By default, a required workspace package is installed as editable.</li>
</ul>
<h2>Features beyond MVP</h2>
<ul>
<li>[ ] Support mixing editables and non-editables in workspaces. Would be mostly solved by https://github.com/astral-sh/uv/issues/3733</li>
<li>[ ] Proper support for depending on packages in other workspaces. The basic structure is there, but i'm sure i'll find bugs when writing proper tests.</li>
<li>[ ] Validate design on a large, popular open source project (ping me if you're interested)</li>
<li>[ ] Integration with bluejay lockfiles. Requires https://github.com/astral-sh/uv/issues/3700</li>
<li>[ ] Support selecting the current package while in the workspace root, like <code>cargo run -p</code>.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by @konstin on 2024-05-06 13:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hauntsaninja">@hauntsaninja</a> on 2024-05-06 22:57</div>
            <div class="timeline-body"><p>In our monorepo at work we have a fairly flexible layout, with more nesting / categorisation of projects. The rules we have for package discovery is that a) name in pyproject.toml must match folder name (limiting how much we have to read pyproject.toml files to do anything), b) a package cannot have another package inside it (limiting how much directory walking we need to do).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-05-17 17:47</div>
            <div class="timeline-body"><p>cc @potiuk regarding if this would work in Airflow</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/potiuk">@potiuk</a> on 2024-05-20 02:18</div>
            <div class="timeline-body"><blockquote>
<p>cc @potiuk regarding if this would work in Airflow</p>
</blockquote>
<p>Generally yes. There are of course some details - particularly about optionality of those providers.</p>
<ol>
<li>What we really would need in this case are those use cases:</li>
</ol>
<p>a) power user (or CI) needs to install &quot;albatross&quot; package and all &quot;providers&quot; together and be able to hack on them together.</p>
<p>b) provider contributor (or CI) should be able to install one (or few, or all) of the &quot;providers&quot; separately in editable mode - but wiith the &quot;albatross&quot;  package installed from PyPi, or URL rather than from sources. this should allow for example to run the tests for main version of &quot;provider_a&quot; against past released version of &quot;albatross&quot; (or specifig tag / branch of &quot;albatross&quot;)</p>
<p>c) albatross contributor should be able to install in editable mode just &quot;albatross&quot; and do not care about all other &quot;providers&quot;</p>
<ol start="2">
<li>Also an important use for airflow is that the providers <strong>might</strong> share the same top-level Python package with the main project, so part of their package structure is overlapping:</li>
</ol>
<pre><code>albatross
├── packages
│   ├── provider_a
│   │   ├── pyproject.toml
│   │   └── src
│   │       └── albatross
│   │           └── providers
│   │                └── provider_a
│   │                   ├── __init__.py
│   │                   └── foo.py
│   └── provider_b
│       ├── pyproject.toml
│       └── src
│   │       └── albatross
│   │           └── providers
│   │                └── provider_b
│   │                   ├── __init__.py
│   │                   └── foo.py
│├── pyproject.toml
├── README.md
├── uv.lock
└── src
    └── albatross
        └── main.py
</code></pre>
<p>I guess that will make things quite a bit difficult - because that means that when you do smth like thatin proivder_a:</p>
<p><code>from albatross.providers.provider_b import foo</code></p>
<p>It should import foo from provider b.</p>
<ol start="3">
<li>Another important thing is that this should nicely work with IDEs (free PyCharm for sure). The free PyCharm has limitation to only be able to have one &quot;project&quot; - no modules within project so you will not be able to open and hack together on provider_a and _b  or provider_a and albatross (which is very useful to be able to edit both.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2024-05-28 07:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 05:34:08 UTC
    </footer>
</body>
</html>
