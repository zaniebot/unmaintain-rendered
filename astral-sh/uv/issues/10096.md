```yaml
number: 10096
title: "Allow environment variables expansion in `pyproject.toml`"
type: issue
state: open
author: ShaiAvr
labels:
  - configuration
  - needs-decision
assignees: []
created_at: 2024-12-22T15:58:22Z
updated_at: 2025-11-12T12:52:27Z
url: https://github.com/astral-sh/uv/issues/10096
synced_at: 2026-01-10T01:57:23Z
```

# Allow environment variables expansion in `pyproject.toml`

---

_Issue opened by @ShaiAvr on 2024-12-22 15:58_

A feature I'd really like to see implemented is the ability to expand environment variables in the `pyproject.toml` file. My use-case is as follows: I am working on a library to simplify my work on other projects. In the future, I'd like to publish the library to PyPi. When I work on my projects, however, I want to use my library as a local editable dependency so I can quickly make changes and see them applied. So I have an example project with the following `pyproject.toml`:
```toml
[project]
name = "demo"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "my-lib",
]

[tool.uv.sources]
my-lib = { path = "/path/to/my/library/my-lib", editable = true }
```
The problem is I am using an absolute path for my library, so I need to modify it if I work on multiple computers, and it's not something I'd want to push to GitHub. A better solution would be to have an environment variable that defines the location of the library on my local machine: `MY_LIB_PATH="/path/to/my/library/my-lib"`. That way, I can define the environment variable as necessary on different machines and my `pyproject.toml` file will simply use this variable:
```toml
[project]
name = "demo"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.12"
dependencies = [
    "my-lib",
]

[tool.uv.sources]
my-lib = { path = "${MY_LIB_PATH}", editable = true }
```
This isn't possible at the moment, and I think expanding environment variables in the `pyproject.toml` file could solve my use case and other similar use cases.

---

_Comment by @woutervh on 2024-12-23 13:26_

I would reference a local symlink  src/my-lib  --> /absolute/path/to/my-lib




---

_Comment by @ShaiAvr on 2024-12-24 21:55_

@woutervh I donâ€™t think a symbolic link should be uploaded to git. The contents of the link wonâ€™t be portable.

---

_Label `configuration` added by @charliermarsh on 2024-12-26 14:32_

---

_Comment by @charliermarsh on 2024-12-26 14:33_

Similar (but not identical) to #5734.

---

_Label `needs-decision` added by @charliermarsh on 2024-12-26 14:33_

---

_Comment by @dpnova on 2025-01-08 05:15_

would love to be able to do something like this:

```toml
[tool.uv.sources]
foo = { git = "https://${GITHUB_TOKEN}@github.com/fooco/foo.git" }
```

edit: just saw the other discussion - perhaps more relevant than here

---

_Referenced in [astral-sh/uv#5734](../../astral-sh/uv/issues/5734.md) on 2025-01-08 05:21_

---

_Comment by @kwaegel on 2025-01-09 20:04_

I would also find this useful.

Context: I have a CMake projects that generates Python Protobuf bindings in an out-of-source build tree, copies over a templated `pyproject.toml` file, and builds a wheel.

Separately, several other Python projects needs to consume the bindings package, but there is no reliable way to use relative paths as the build tree is not under the source tree (typical for CMake projects).

My current options are:
* Copy the generated bindings directly into each project that needs to consume them via Makefile or something.
* Copy the generated bindings back into the source tree as part of the build process, so they're in a stable location.

---

_Comment by @coneillpj on 2025-05-30 13:47_

+1

---

_Comment by @Tremeschin on 2025-09-04 01:15_

@dpnova For private repositories it might be better to have a global `.gitconfig` redirect and keep the package source untouched as `https://github.com/fooco/foo.git`, e.g. with SSH:

```ini
# ~/.gitconfig
[url "ssh://git@github.com/"]
insteadOf = https://github.com/
```

This way after I add the key in my agent `ssh-add /path/key` in a login, any git operation uses ssh authentication. For sure it would work with `[url "https://<TOKEN>@github.com/"]`, which gives whoever is cloning authentication _options_

Minor side effect (or bonus), the origin url will contain the `ssh://` or `<token>@` part, ssh is safe because of the agent, but the token would be fully visible with `git remote get-url origin` (I guess it's no better than env vars anyway..)

---

_Comment by @dpnova on 2025-09-04 01:41_

@Tremeschin that's a good idea - luckily I only have to worry about our devs and a github action. I'm pushing to have the lib opensourced anyway :D (sadly, structural engineering, otherwise I'd have asked you to check it out)

btw the main discussion on this seems to be over [here](https://github.com/astral-sh/uv/issues/5734) 

---

_Comment by @Tremeschin on 2025-09-04 02:21_

No prob @dpnova, I randomly ended up here while searching for other stuff, and knew this alt approach for your comment with many upvotes that could help others - I'm not for the original issue, but indeed it could be useful at times ðŸ™‚

<hr>

Anyhow, I feel like [workspaces](https://docs.astral.sh/uv/concepts/projects/workspaces/#workspace-layouts) are what OP needs, that's a monorepo structure even if repos weakly depend on each other.

I currently have `[tool.uv.workspace] members = ["meta/*"]` in my pyproject and use `git clone (url) meta/(project)` instead of submodules for off-branch work. A symlink works here too, where `meta/(project) => /abs/path/project`

This main repository often contains the shared library, but it can be a virtual/bare project that just includes symlinks to members to centralize a venv and `[project.scripts]`. Local setup gets trickier with decoupled projects ofc needing manual setup per system (Windows needs developer mode for non-admin symlinks also..)

Just saying that workspaces solves path dependencies altogether, managing envs or truly decoupled won't play well :)

---

_Comment by @imLew on 2025-11-12 08:00_

I would also like to see the original suggestion added. Unpublished dependencies and different directory layouts across systems are not going to go away anytime soon. Environment variables are already a commonly used way to deal with the differences between systems and for paths in `pyproject.toml` they would offer a simple and flexible solution.

I also want to say that, while workspaces might solve this problem, the suggestion is still worth implementing as it solves the problem with much less friction. "Put all your stuff in a mono repo" is not a good solution to "I want to use some code from another local repo".

---

_Comment by @vitschwilk on 2025-11-12 08:33_

While I think using envs in the pyproject.toml is a nice thing, an alternative solution to the "I want to use some code from another local repo"-problem from @imLew would be sources-groups as described in https://github.com/astral-sh/uv/issues/7945.


---

_Comment by @imLew on 2025-11-12 10:26_

Thanks @vitschwilk, but unless I'm missing something this solves the problem only for local dependencies that can be found at a fixed relative path. My "another local repo" was meant as "another local repo that lives in different locations on different machine", sorry, that could have been clearer.

FWIW I worked around my problem (different relative paths to same dep on different machines) by using a private github repo (with a deploy key) as a source (though any bare repo that's reachable from all machines would work).

---

_Comment by @vitschwilk on 2025-11-12 12:52_

No, not really *only* for local dependencies. You could also use a source-group that would link to a github based install... so not local. 
But I agree, you could not define a $PATH_TO_MY_REPOS variable and just use it always. But you could have a variable setup.


---
