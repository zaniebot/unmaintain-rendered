<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Suggestion: `uv bundle`, `uv build --release` or similar to create a contained executable a la pyinstaller, py2exe - astral-sh/uv #5802</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Suggestion: `uv bundle`, `uv build --release` or similar to create a contained executable a la pyinstaller, py2exe</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/astral-sh/uv/issues/5802">#5802</a>
        opened by <a href="https://github.com/matterhorn103">@matterhorn103</a>
        on 2024-08-05 23:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-08-05 23:26</div>
            <div class="timeline-body"><p>I regularly use pyinstaller for a project, and the frequency of questions about it - or the task more generally of &quot;compiling&quot; an executable for distribution - around the web indicates to me that it's widely popular.</p>
<p>It would be incredibly cool if uv offered a <code>uv bundle</code> command (or whatever name) that essentially did what pyinstaller does and bundles together everything to afford an executable that contains the dependencies and interpreter and can be distributed to users as-is. And I think this falls into the realm of what things a &quot;Cargo for Python&quot; might be expected to be able to do.</p>
<p>I assume that pyinstaller, py2exe etc. are complex projects and implementing such functionality would be not trivial in the slightest, so I would have thought it would be a case of using <code>pyinstaller</code> itself in the background like the way that build backends are used.</p>
<p>Presumably there will one day be a <code>uv build</code> command but I assume that will be similar to <code>rye build</code> in that it will create an sdist or wheel. Maybe there could be a <code>uv build --executable</code> option, or <code>uv build --release</code> (by analogy to <code>cargo build --release</code>)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Suggestion: `uv bundle` or similar to create a contained executable a la pyinstaller, py2exe" to "Suggestion: `uv bundle`, `uv build --release` or similar to create a contained executable a la pyinstaller, py2exe" by @matterhorn103 on 2024-08-05 23:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-08-06 00:08</div>
            <div class="timeline-body"><p>Some relevant links that I'm adding to keep track of them for myself as much as anyone else:</p>
<ul>
<li>It seems someone <a href="https://github.com/astral-sh/rye/issues/325">asked for the same in Rye</a> previously</li>
<li>ofek's <a href="https://github.com/ofek/pyapp">PyApp</a> and Gregory Szorc's (indygreg) now-dead <a href="https://github.com/indygreg/PyOxidizer">PyOxidizer</a> are other, more modern executable generators that I didn't know about until now; both seem simpler than pyinstaller, and both are written in Rust</li>
<li>Gregory Szorc once did a <a href="https://pyoxidizer.readthedocs.io/en/stable/pyoxidizer_comparisons.html">comparison</a> of the various alternatives to PyOxidizer</li>
<li>One missing from that list, presumably because it's not generally applicable, is the <a href="https://doc.qt.io/qtforpython-6/deployment/deployment-pyside6-deploy.html"><code>pyside6-deploy</code> tool</a>, but it uses Nuitka in the background in any case</li>
<li>Hatch seems to have implemented essentially this functionality, as part of a <a href="https://hatch.pypa.io/latest/plugins/builder/binary/">Hatch plugin</a> that uses PyApp, and it is invoked there by having &quot;binary&quot; as a build target</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @zanieb on 2024-08-06 00:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2024-08-06 09:51</div>
            <div class="timeline-body"><p>To add‚Ä¶ despite its popularity, <code>pyinstaller</code> suffers from slowness because has to unzip all the dependencies and the interpreter when the executable is launched. It offers users the option to display a splash image to distract them from the perceived slowness.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2024-08-06 10:03</div>
            <div class="timeline-body"><p>Python to Rust transpilation would be pretty cool and there‚Äôs at least one project out there working on this:</p>
<ul>
<li><a href="https://github.com/konchunas/pyrs">pyrs</a></li>
</ul>
<p>Imagine writing idiomatic Python, transpiling it to Rust and compiling a native executable. My mind would be blown.</p>
<p>I don‚Äôt know how one could gracefully handle dependencies though. A lot of Python libs incorporate C extensions. Dealing with those would be extremely difficult, but there‚Äôs a DARPA program called <a href="https://www.darpa.mil/program/translating-all-c-to-rust">TRACTOR</a> working on that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/paveldikov">@paveldikov</a> on 2024-08-06 14:47</div>
            <div class="timeline-body"><p>An equivalent of <code>pyinstaller</code> that actually understands standard <code>pyproject.toml</code>-driven projects and console/GUI script entrypoints (instead of being fixated on script development, and overcompensating with its dependency detection magic) would be huge.</p>
<p>(somewhat related: #5653)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/my1e5">@my1e5</a> on 2024-08-07 09:42</div>
            <div class="timeline-body"><p>I want to give a mention to <a href="https://github.com/Nuitka/Nuitka">Nuitka</a> which is serving me well. It's as straightforward as running</p>
<pre><code>uv add --dev nuitka
</code></pre>
<pre><code>uv run python -m nuitka --standalone src/main.py
</code></pre>
<p>which spits out an executable.</p>
<p>It's not really the right tool to be including with uv, it is essentially an alternate Python interpreter which compiles Python to C. But it's very easy to add and has worked well for me. And my experience with the developers has been very good. They were quick to add support for Rye when I encountered bugs - https://github.com/Nuitka/Nuitka/issues/2933</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-08-21 07:17</div>
            <div class="timeline-body"><p>@my1e5 why do you say that Nuitka would be unsuitable for inclusion with uv?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6533.html">astral-sh/uv#6533</a> on 2024-08-23 16:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/my1e5">@my1e5</a> on 2024-08-27 09:39</div>
            <div class="timeline-body"><p>@matterhorn103, I guess what I mean is that Nuitka is perhaps quite an opinionated way of packaging your Python code into an executable - as it is essentially an alternate Python interpreter which compiles Python to C. Whereas tools like Pyinstaller are more like a bundler - taking the Python interpreter, Python files and dependencies and packaging them into an executable. This is definitely more straightforward than the Nuitka approach, but it does make the Pyinstaller executable very easy to un-package and see the underlying source code (see https://github.com/extremecoders-re/pyinstxtractor). Which might be a caveat needed when including certain 'executable creators' within uv - you need to make users aware that their exe can easily be un-packaged.</p>
<p>In terms of licensing, Nuitka is MIT licensed. But it does also have a commercial tier - which may or may not complicate matters if Astral were to want to bundle it with uv, I don't know.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-09-03 23:23</div>
            <div class="timeline-body"><p>I think this is a duplicate of https://github.com/astral-sh/uv/issues/2799, though there's more discussion here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pex-tool/pex/issues/2371.html">pex-tool/pex#2371</a> on 2024-09-04 00:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/martimlobao">@martimlobao</a> on 2024-09-04 09:18</div>
            <div class="timeline-body"><p>Also want to call out pex, a tool for generating .pex files (Python EXecutable) which are self-contained zipped executable Python environments containing sources, requirements, and dependencies.</p>
<p>https://github.com/pex-tool/pex</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jbvsmo">@jbvsmo</a> on 2024-10-05 21:15</div>
            <div class="timeline-body"><p>I am interested in a solution like this. I think the bundler should be somewhat coupled with <code>uv run</code> since you want to turn any entry point into an executable.</p>
<p>Example</p>
<pre><code class="language-bash">$ uv init --script foo.py
$ uv add requests --script foo.py
$ uv run foo.py
Hello from foo.py!
</code></pre>
<p>Then you could make an executable which is composed of</p>
<ol>
<li>bootstrap code to download uv if needed and run it</li>
<li>target code</li>
<li>uv executable <strong>(optional)</strong></li>
<li>python executable <strong>(optional from <code>uv python</code>)</strong></li>
<li>populated venv <strong>(optional)</strong></li>
</ol>
<pre><code class="language-bash">$ uv bundle foo.py -o foo --include-uv --include-python --include-dependencies
$ ./foo 
Hello from foo.py!
</code></pre>
<p>This above would be a self contained binary (roughly 30MB as uv is ~12MB and python ~17MB).</p>
<p>If downloading stuff on the fly is ok, the bootstrap code would just download uv, then uv would download python, install dependencies and run all during 1st execution.</p>
<p>It should also be possible to create binaries cross platform since uv supports install/sync with <code>--python-platform</code></p>
<pre><code class="language-bash">$ uv bundle foo.py -o foo.exe --python-platform windows
</code></pre>
<p><em>In a 2nd iteration</em>, it would be nice to be have installers such as to create .dmg (mac) or an .exe windows installer file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/7419.html">astral-sh/uv#7419</a> on 2024-10-08 01:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dbrtly">@dbrtly</a> on 2024-10-18 23:43</div>
            <div class="timeline-body"><p>what if the command was <code>uv run ruff --output-file ruff.uvx</code>
with the -o/--output agument as an indicator to create the binary file rather than execute this tool right now.
and when an output file is specified, then include python by default</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/stefanondisponibile">@stefanondisponibile</a> on 2024-10-20 17:46</div>
            <div class="timeline-body"><p>I love this idea and @jbvsmo proposal for CLI usage.</p>
<p>I am a bit confused on the best choice for the bundling &quot;backend&quot; though, I see different options on the table and I'm not sure, how would you choose one over the other? Should maybe <code>uv</code> propose some protocol for each library to support bundling via <code>uv</code>?</p>
<p>This feature would be great also for bundling pyspark apps (thinking about pex support mentioned by @martimlobao here)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../Tobi-De/fujin/issues/16.html">Tobi-De/fujin#16</a> on 2024-11-02 22:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AKuederle">@AKuederle</a> on 2024-11-28 13:08</div>
            <div class="timeline-body"><p>I think the bootstrap option mentioned by @jbvsmo is almost achievable with the existing uv options.</p>
<p>You could do the following:</p>
<p>Within your project folder have a script (written in the scrippting language supported by your operating system) that does the following:</p>
<ol>
<li>Unmanaged installation of uv (https://docs.astral.sh/uv/configuration/installer/#unmanaged-installations) can be used to just get the uv executable in a subdir of the project folder.</li>
<li>Setup the cache dir to be inside your project folder (https://docs.astral.sh/uv/concepts/cache/#cache-directory)</li>
<li>Then install Python</li>
<li>Install project deps</li>
<li>Use uv run to execute a script within the project enviroment. The easiest option would be to just &quot;run&quot; the package using a <code>__main__.py</code> within the project</li>
</ol>
<p>Step 1 could of course be skipped, if the uv executable is already recognized within the specified subdir. And step 3-5 are basically what happens when you run uvx. So maybe this is actually a 2 line script.</p>
<p>The great thing is that this script would be project independent! So someone just would need to write a script for each operating system and you could throw these scripts in your project folder.</p>
<p>Then you just need to distribute this project folder and have people execute the script corresponding to their operating system.</p>
<p>This process could then of course be wrapped further by an installer, but seems relatively straight forward to at least address the cases of &quot;Please provide an exe&quot;.</p>
<p>PS: If instead of creating a shell script to run the steps above, you use the darkmagic of <a href="https://github.com/jart/cosmopolitan?tab=readme-ov-file">cosmopolitan</a> you could even create a single binary that dropped into a python package project anywhere makes it run by &quot;double-clicking&quot; the file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jromal">@jromal</a> on 2024-12-04 11:43</div>
            <div class="timeline-body"><p>For me as a short term solution it would be enough to have <code>uv run</code> with some options.</p>
<p>For example I have done a program (as module) using PySide6.
I can do <code>uv run -m my_module</code> from the folder above the module and it works. Fast, efficient, impressive.
But there are two things that can help as an intermediate solution before a <code>uv bundle</code>.</p>
<ul>
<li>Read a compressed file for the full project: <code>uv run --source my_file.zip</code></li>
<li>Allow an option to hide or close the terminal for qt programs: <code>uv run --source my_file.zip --no-terminal</code></li>
</ul>
<p>With this solution I could distribute on Windows the files with &quot;Inno Setup&quot;, adding <code>uv.exe</code>, the zip file, and maybe a &quot;.bat&quot; file with a logo to execute the <code>uv -run</code> command.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/johnthagen">@johnthagen</a> on 2024-12-05 03:05</div>
            <div class="timeline-body"><p>As much as I like Pyinstaller (to me it's best of current options), one other thing that it suffers from is that anti-virus vendors are <em>always</em> flagging generic Pyinstaller binaries as malware. This is (at least in part, I think) because Pyinstaller uses the same bootloader binary for all built applications, thus if someone bundles malware with Pyinstaller version X, all other users who bundle legitimate applications using Pyinstaller X can get flagged as malware too. I've seen this hit AV software across both Windows and Linux over the years. Not sure I have any ideas on how Astral could improve <em>that</em> issue, but wanted to bring it up as a current (very annoying) real world challenge.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/10019.html">astral-sh/uv#10019</a> on 2024-12-19 04:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/10452.html">astral-sh/uv#10452</a> on 2025-01-10 04:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ceejatec">@ceejatec</a> on 2025-01-10 10:49</div>
            <div class="timeline-body"><p>It's not exactly the same thing, but I've suggested a relatively simple feature to <code>uv</code> that would solve at least a subset of the requirements of delivering a single downloadable executable for a Python program: #10465</p>
<p>Basically it would let <code>uv</code> serve as a limited runtime-only alternative to PyApp.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jromal">@jromal</a> on 2025-01-10 12:40</div>
            <div class="timeline-body"><p>Thanks for your request and for commenting here.</p>
<p>For me the final tool would be a third party tool, part of uv (for Windows, uv.exe, uvx.exe and the new one, let's call it <code>uvd.exe</code>).</p>
<p>And that third tool should be <code>PyOxidizer</code>. I do not know if you know it. But the single python binaries that Astral uses are a &quot;byproduct&quot; of PyOxidizer. A project from Gregory Szorc (indygreg on GitHub). It is a rust tool for byilding executables including a full python run time environment. Gregory had no time for any of the projects. The python binaries are now generated by Astral. PyOxidizer is not maintained since many months. I considered it as a future better alternative to Pyinstaller or Nuitka or ...</p>
<p>Maybe we could get a simple tool and a complex one with all the hooks for the different packages. Maybe could also have different license models to allow Astral to capitalize the investment. But should be continued as a natural evolution of uv.</p>
<p>But as a you say a wrapper of uvx would do it.</p>
<p>Let's wait and see.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Nardol">@Nardol</a> on 2025-01-10 13:21</div>
            <div class="timeline-body"><p>Unfortunately https://github.com/indygreg/PyOxidizer only support Python up to 3.10 as specified in the latest stable documentation, except that it looks promising. Latest commit is two months old but you say it is not maintained again?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/paul-gauthier">@paul-gauthier</a> on 2025-01-17 20:10</div>
            <div class="timeline-body"><p>I would also be interested in more direct support for using uv as an &quot;installer&quot; for python CLI tools.</p>
<p>I've been using uv in novel ways for this purpose already. I recently wrote a bit about these approaches. Leaving the link here in case folks find it interesting or helpful:</p>
<p>https://aider.chat/2025/01/15/uv.html</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/thewh1teagle">@thewh1teagle</a> on 2025-01-27 02:02</div>
            <div class="timeline-body"><p>It will be useful if uv add <code>compile</code> command like in bun.js which will produce self contained executable.
The only important thing is NOT to work like pyinstaller and extract the contents but somehow load the interpreter into the memory, and tell cpython to run the bundled script directly from the memory.
Just like bun.js / nodejs does.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/davidlanouette">@davidlanouette</a> on 2025-02-10 20:00</div>
            <div class="timeline-body"><p>It's worth noting that it looks like PyOxidizer has been taken over ty Astral-sh - in the form of <a href="https://github.com/astral-sh/python-build-standalone">python-build-standalone</a>.</p>
<p>So, this issue can likely be closed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-10 20:06</div>
            <div class="timeline-body"><p>No, we don't own PyOxidizer ‚Äî we're just maintaining the standalone Python distributions. These ideas are separate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/davidlanouette">@davidlanouette</a> on 2025-02-10 20:12</div>
            <div class="timeline-body"><p>Interesting.  That's not how I interpreted the <a href="https://astral.sh/blog/python-build-standalone">blog post</a></p>
<blockquote>
<p>TL;DR: On 2024-12-17, we'll be taking stewardship of <a href="https://github.com/indygreg/python-build-standalone">python-build-standalone</a>, <a href="https://gregoryszorc.com/">Gregory Szorc's</a> foundational project for building and installing portable Python distributions. You can read Gregory's own announcement <a href="https://gregoryszorc.com/blog/2024/12/03/transferring-python-build-standalone-stewardship-to-astral/">here</a>.</p>
</blockquote>
<p>But, it does explain why the releases seem to only contain python distributions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-10 21:07</div>
            <div class="timeline-body"><p>Yes we are the owners of <code>python-build-standalone</code>, but not PyOxidizer  ‚Äî that's built on <em>top</em> of the standalone distributions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jdegenstein">@jdegenstein</a> on 2025-02-14 23:14</div>
            <div class="timeline-body"><p>This is a bit off topic, but I had a related discussion on discord about this topic and thought I would share A solution to MY problem that could be relevant to others. I feel that <code>python-build-standalone</code> has huge potential QoL improvements for the python package management ecosystem because it (finally) seems to attempt to address the local vs. global installation &quot;problem&quot;.</p>
<p>My problem statement: create a zipped folder with standalone python, standalone packages and their dependencies that I can distribute to other users (&quot;download, unzip and run&quot;). Non-goals: a single executable -- for me a folder containing lots of subdirectories/files is fine but an obvious &quot;entry point&quot; is desirable. Obviously the result will be OS and CPU type specific.</p>
<p>Steps I followed:</p>
<ol>
<li>Download relevant https://github.com/astral-sh/python-build-standalone/releases and unzip</li>
<li>chdir to python subdir</li>
<li>execute e.g. <code>python.exe -m pip install uv</code> (there is no specific need to use uv by the way)</li>
<li>execute e.g. <code>python.exe -m uv pip install &lt;somepackage&gt;</code></li>
<li>for my application I created <code>somepackage.bat</code> (one directory &quot;up&quot;) containing <code>call python/python.exe -m &lt;somepackage&gt;</code>. Obviously shell scripts would be useful on other platforms, and I am sure there are other solutions as well.</li>
<li>zip the parent folder and distribute to others with same OS and CPU type</li>
</ol>
<p>The reason I like this solution is multifold (1) uses standard package installation methods (2) everything (?) is local to the folder (3) no e.g. pyinstaller-hooks-contrib to maintain. Are there downsides to this approach? Probably, but in my quick testing did not run across any issues -- it &quot;just worked&quot;. This is contrast to my prior experiences with nuitka and pyinstaller which work perfectly for projects with pure python dependencies, but can require more &quot;handholding&quot; when that is not the case.</p>
<p>Finally back to the topic of this post -- this would be very nice if supported by uv directly in some form.</p>
<p>p.s. thanks to @geofft for their help</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jromal">@jromal</a> on 2025-02-15 08:10</div>
            <div class="timeline-body"><p>The creator of the standalone python (Gregor Szorc) did it for his tool PyOxidizer. A rust substitute of pyinstaller or Nuitka.</p>
<p>I am repeating when I can that Astral should take it and finish it. Gregor (indygreg) has no time and his work was really good. Just unfinished. But he did one of the biggest changes in python. The standalone python. Do not let his work disappear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dbrtly">@dbrtly</a> on 2025-02-15 08:28</div>
            <div class="timeline-body"><p>@jdegenstein it sounds like you want to do <code>uv tool install my_app</code> but have it work even if uv is not installed on the client machine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-02-15 13:45</div>
            <div class="timeline-body"><p>(@jromal -- incase you haven't seen, we did assume stewardship of python-build-standalone: https://github.com/astral-sh/python-build-standalone)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2025-02-15 16:46</div>
            <div class="timeline-body"><p>Since I originally created this issue it's been very popular, and it's also seen many comments offering suggestions.</p>
<p>Naturally it is always a bit presumptuous to attempt to speak on behalf of a diverse and anonymous group, so maybe I'll be contradicted here, but I reckon that the vast majority of those who have voted for this issue or chimed in are united in hoping for something defined <em>not</em> by its technical implementation but by key <em>behaviour</em> ‚Äì something that is:</p>
<ul>
<li>a single executable (or appears to be)</li>
<li>easy-to-use by non-technical users i.e. it it looks and behaves like an application generally does</li>
<li>easily distributed through sharing the executable itself i.e. it is fairly self-contained and portable (maybe cross-OS, maybe not)</li>
<li>not less performant than running the original Python code with a normal interpreter</li>
</ul>
<p>This is essentially about being able to take a Python program on our machines and give it to non-programmers, right? It could be achieved with a variety of technical solutions, as shown by the slew of existing tools, and by people's contributions in this thread.</p>
<p>I kind of want to clarify that while many people have been advocating for a wide variety of things, this issue as originally written wasn't advocating for a particular technical solution or requesting anything beyond that listed above.</p>
<p>Going by past form, no doubt any <code>uv</code> implementation would be an excellent one.</p>
<p>(In the original post I suggested that maybe it would use <code>pyinstaller</code> in the background, but that was mostly because it seemed to me a bit rude to ask the team to write a whole new thing from scratch at a time when they were still getting core functionality up and running.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tjnd89">@tjnd89</a> on 2025-02-15 17:45</div>
            <div class="timeline-body"><p>@matterhorn103 FWIW, this is exactly my use case. I'm building a an &quot;app&quot; for non-programmers. I use uv with hatch to build the distributions. I have a custom hatch build script that kicks off pyinstaller to build the &quot;executable&quot;. In my case, I'm using the &quot;one_dir&quot; option because along with the exectuable I have to ship various data files that are needed. One thing I ran into is that running pyinstaller standalone from the command line worked great. My custom build script that issued the same command line arguments was failing to find all the dependencies because of uv's build isolation. I had to set</p>
<pre><code>[tool.uv]
no-build-isolation = true
</code></pre>
<p>and then it all worked well. Here's the snippets of relevant code.</p>
<p>hatch_build.py</p>
<pre><code>import subprocess

from hatchling.builders.hooks.plugin.interface import BuildHookInterface


class CustomHook(BuildHookInterface):
    &quot;&quot;&quot;USed to kick off Pyinstaller as part of a standard uv build.
    &quot;&quot;&quot;
    def initialize(self, version, build_data):
        cmd_options = ['pyinstaller',
                       '--noconfirm',
                       # add your command line options here
                       'blah.py'   # your script you are wrapping.
                       ]

        subprocess.run(cmd_options, check=False)
</code></pre>
<p>pyproject.toml</p>
<pre><code>[tool.hatch.build.targets.sdist.hooks.custom]
    dependencies = [&quot;pyinstaller&quot;]
</code></pre>
<p>This should get you what want I think.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/11540.html">astral-sh/uv#11540</a> on 2025-02-16 00:19</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jdegenstein">@jdegenstein</a> on 2025-02-16 02:51</div>
            <div class="timeline-body"><p>@dbrtly Yes, that is correct -- in my experience with developing apps for new python users or python beginners as soon as the phrase &quot;virtual environment&quot; is uttered about half of the potential users will just give up (again my stated goal for my users is &quot;download (my app), unzip and run&quot;). Single executables are nice, as are installation wizards, but that introduces another layer of OS specific considerations that are not worth it for me (yet).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dbrtly">@dbrtly</a> on 2025-02-17 09:45</div>
            <div class="timeline-body"><p>It seems that you gave to draw the line somewhere and make an assumption about pre-requisites on the target machine: git? Is user local admin? Is the user sophisticated enough to use a cli tool at all? Is pyinstaller available? Is uv available?</p>
<p>You could go a long way with something like this:</p>
<pre><code># install uv and put it on path
uv tool install my_app \
  --default-index https://custom.pkg.dev/index 
</code></pre>
<p>Am curious about what specific features you can see potential for uv to improve on for this user experience.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../cbrnr/mnelab/issues/294.html">cbrnr/mnelab#294</a> on 2025-02-19 15:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/11746.html">astral-sh/uv#11746</a> on 2025-02-25 02:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/11777.html">astral-sh/uv#11777</a> on 2025-02-25 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2025-02-25 14:11</div>
            <div class="timeline-body"><p>I posted some ideas over in #11746 about what I think a <code>uv layout</code> command might look like.</p>
<p><code>uv bundle</code> would be distinct from <code>uv layout</code> and both would be valuable to developers.</p>
<p>From <a href="https://github.com/astral-sh/uv/issues/11746#issuecomment-2681843706">my comment</a>:</p>
<blockquote>
<p>I think the intent of <code>uv bundle</code> is to be able to combine an app, its dependencies, and Python for non-developer end users. It would produce an executable binary, likely having a GUI or CLI. This would enable devs to distribute their apps without relying on users to know what uv, Python, PyPI, or virtual environments are.</p>
<p>The intent of <code>uv layout</code> (<a href="https://learn.microsoft.com/en-us/visualstudio/install/create-an-offline-installation-of-visual-studio?view=vs-2022#step-2---create-a-local-layout">inspiration</a>) is to be able to combine uv, packages, and Python for developers. It would produce a directory, likely having a <code>uv.toml</code> to configure uv to work with that directory layout when invoked. This would enable devs to create projects without relying on an internet connection.</p>
<p>Both of these commands would be valuable to developers, with <code>uv bundle</code> artifacts targeted at users and <code>uv layout</code> artifacts targeted at developers. Both commands could read a <code>pyproject.toml</code> to produce the desired artifact for the current platform by default, or take any number of <code>--platform &lt;target-triple&gt;</code> options (or <code>--platform all</code>) to produce artifacts for different platforms.</p>
</blockquote>
<p><code>uv compile</code> could also be good idea, distinct from both <code>uv bundle</code> and <code>uv layout</code>. It would be similar to <code>uv bundle</code>, but it might produce an artifact more akin to that of <code>nuitka</code> rather than <code>pyinstaller</code> and would be much more complicated to generalize and implement.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2025-02-25 20:36</div>
            <div class="timeline-body"><p>Summary of some of the ideas mentioned. The command names are flexible but I'm just using these for now to tell them apart üôÇ</p>
<p>| Command | Use-case | Behavior | Similar to | Implementation(s) | Issue(s) |
| --- | --- | --- | --- | --- | --- |
| <code>uv bundle</code> | Create a portable executable for users | Outputs a platform-specific executable or <a href="https://justine.lol/ape.html">APE</a> <strong>with embeddings</strong>  such as Python interpreter and package dependencies | <a href="https://github.com/pyinstaller/pyinstaller">pyinstaller</a>, <a href="https://github.com/ofek/pyapp">pyapp</a>, <a href="https://github.com/indygreg/PyOxidizer">pyoxy</a> | On-disk execution (slower?), <a href="https://en.wikipedia.org/wiki/In-memory_processing">in-memory execution</a> (faster?) | #5802 |
| <code>uv compile</code> | Create a portable executable for users | Outputs a platform-specific executable or <a href="https://justine.lol/ape.html">APE</a> <strong>without embeddings</strong> | <a href="https://github.com/Nuitka/Nuitka">Nuitka</a>, <a href="https://wasmer.io/posts/py2wasm-a-python-to-wasm-compiler">py2wasm</a> | Compilation/transpilation | #5802 |
| <code>uv layout</code> | Create a portable Python distribution for developers | Outputs a directory that contains platform-specific uv, Python interpreter, and wheels | <a href="https://winpython.github.io/#overview">WinPython</a>, <a href="https://docs.anaconda.com/anaconda/release-notes/">Anaconda</a>, <a href="https://github.com/ActiveState/cli">ActiveState</a> | <code>fs::create_dir</code> | #11746 |</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/paveldikov">@paveldikov</a> on 2025-02-26 11:24</div>
            <div class="timeline-body"><p>@chrisrodrigue <code>uv layout</code> can be approximated by stitching together <code>uv venv --relocatable</code> with <code>uv python download</code> + a launcher script that rewrites <code>pyvenv.cfg</code> (because the base interpreter definition is not portable -- you can specify relative paths but those are implicitly relative to the current working directory)</p>
<p>I have done this for a proof-of-concept and, whilst clunky, it definitely does work. In fact, by repackaging its output into something like an RPM/DEB/Choco/pick-your-favourite-OS-package-manager -- or a self-extracting executable -- you end up with a passable (though non-optimised) <code>uv bundle</code> too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../mathesar-foundation/mathesar/issues/4303.html">mathesar-foundation/mathesar#4303</a> on 2025-03-05 13:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2025-03-06 11:35</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> <code>uv layout</code> can be approximated by stitching together <code>uv venv --relocatable</code> with <code>uv python download</code> + a launcher script that rewrites <code>pyvenv.cfg</code> (because the base interpreter definition is not portable -- you can specify relative paths but those are implicitly relative to the current working directory)</p>
<p>I have done this for a proof-of-concept and, whilst clunky, it definitely does work. In fact, by repackaging its output into something like an RPM/DEB/Choco/pick-your-favourite-OS-package-manager -- or a self-extracting executable -- you end up with a passable (though non-optimised) <code>uv bundle</code> too.</p>
</blockquote>
<p>Interesting, thanks @paveldikov. <code>uv python download</code> doesn‚Äôt appear in the <a href="https://docs.astral.sh/uv/reference/cli/#uv-python">docs</a>, but I‚Äôll try experimenting with it today.</p>
<p>An open question I have about venvs‚Ä¶ how can one install packages from one venv into another? AFAIK, there is no way to do this because you need wheels to do real installation into a venv.</p>
<p>You could add the source environment to PATH and make new venvs with <code>--system-site-packages</code> to use packages from the source environment, but there are downsides:</p>
<ul>
<li><code>--system-site-packages</code> is an all or nothing approach. You get all packages regardless of whether you need all of them.</li>
<li>System site packages aren‚Äôt installed to the venv, so you can‚Äôt pack up your project to share.</li>
<li>All bets are off with the tooling. You need to manually check that any dependencies in <code>pyproject.toml</code> are in the source environment you‚Äôre using, which adds toil.</li>
</ul>
<p>These reasons are why I advocate for using wheels with layouts. However, venvs may be better for bundles since they compress better. The checksum of the bundle executable should be good enough for attestation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2025-03-06 15:52</div>
            <div class="timeline-body"><p>I tried running <code>uv pip download</code> and <code>uv python download</code> to manually create a layout that can be bundled/packed/archived, but alas, neither of these commands exist.</p>
<p>First, you will want <code>uv</code>:</p>
<pre><code>curl -LSsf uv.zip https://github.com/astral-sh/uv/releases/download/0.6.4/uv-x86_64-pc-windows-msvc.zip | tar -x
</code></pre>
<p>To grab wheels in lieu of <code>uv pip download</code>:</p>
<pre><code>python -m pip download -r requirements.txt -d pypackages
</code></pre>
<p>To grab the interpreter in lieu of <code>uv python download</code>:</p>
<pre><code>curl -LSsf https://github.com/astral-sh/python-build-standalone/releases/download/20250212/cpython-3.13.2+20250212-x86_64-pc-windows-msvc-install_only_stripped.tar.gz | tar -x
</code></pre>
<p>Configuring this <code>uv</code> to use <code>python</code> and <code>pypackages</code> is the real bounty üòÅ</p>
<p>I feel like a <code>uv.toml</code> adjacent to the executable would be appropriate for configuration, to set this <code>python</code> directory for the interpreter and <code>pypackages</code> directory as an index. Another setting to add <code>uv</code> to the system PATH on invocation would be sweet. A no setup, offline, portable Python distro that you can use as batteries for Python development anywhere offline on your target platform, or wrap up into an executable to share with others.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/paveldikov">@paveldikov</a> on 2025-03-06 19:04</div>
            <div class="timeline-body"><p>Sorry -- it's <code>uv python install</code>... some poetic licence is necessary when citing commands off by heart üôÉ</p>
<p>It will give you a known-good relocatable python site.  You can then manipulate that as you please, e.g. by further relocating it to sit inside of a relocatable venv. And then manipulate <code>pyvenv.cfg</code> accordingly.</p>
<p>p.s. and on posix, re-point the venv's <code>bin/python*</code> symlinks accordingly, e.g. to <code>../interpreter/bin/$1</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/12033.html">astral-sh/uv#12033</a> on 2025-03-07 07:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrismatix">@chrismatix</a> on 2025-03-07 13:13</div>
            <div class="timeline-body"><blockquote>
<p>@martimlobao Also want to call out pex, a tool for generating .pex files (Python EXecutable) which are self-contained zipped executable Python environments containing sources, requirements, and dependencies.
https://github.com/pex-tool/pex</p>
</blockquote>
<p>To anyone who was looking into this option: I put together a recipe repository for bundling uv workspaces by compiling their dependencies using <code>uv pip compile</code> and then using that lock file to build an executable with <code>pex</code>: https://github.com/chrismatix/uv-pex-monorepo</p>
<p>If you check it out, please let me know about any edge cases it does not accommodate!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Lauszus">@Lauszus</a> on 2025-03-07 14:52</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p><a href="https://github.com/martimlobao">@martimlobao</a> Also want to call out pex, a tool for generating .pex files (Python EXecutable) which are self-contained zipped executable Python environments containing sources, requirements, and dependencies.
https://github.com/pex-tool/pex</p>
</blockquote>
<p>To anyone who was looking into this option: I put together a recipe repository for bundling uv workspaces by compiling their dependencies using <code>uv pip compile</code> and then using that lock file to build an executable with <code>pex</code>: https://github.com/chrismatix/uv-pex-monorepo</p>
<p>If you check it out, please let me know about any edge cases it does not accommodate!</p>
</blockquote>
<p>Nice. I'm using something similar in production. Hopefully pex would support uv.lock directly someday.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../flexcompute/tidy3d/issues/2322.html">flexcompute/tidy3d#2322</a> on 2025-03-18 09:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../denwii/Area_Calculator_Osu/pulls/7.html">denwii/Area_Calculator_Osu#7</a> on 2025-03-21 18:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/luigi311">@luigi311</a> on 2025-03-25 20:01</div>
            <div class="timeline-body"><p>Great ideas guys. I went with something similar on my project. <code>uv build</code> which generates a whl file i then used pex on that whl and then finally used fpm to generate a deb for me to distribute. Hopefully something built into uv comes that makes this more simple but for now this works without complicating my source files with duplicate files that need to be manged. Can find my initial implementation here https://github.com/luigi311/immich_upload_daemon/blob/d1ec12c369ab4192e0ba88653010e4a0968e6e26/.github/workflows/build.yml</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/13503.html">astral-sh/uv#13503</a> on 2025-05-17 10:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TanixLu">@TanixLu</a> on 2025-06-03 17:48</div>
            <div class="timeline-body"><p>@AKuederle My thoughts align closely with yours: create a bootstrap-style APE that downloads <code>uv</code>, installs Python, fetches dependencies, and executes the source code. I've already implemented this in a package called <a href="https://github.com/TanixLu/pyfuze">pyfuze</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/blais">@blais</a> on 2025-06-03 19:18</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/AKuederle">@AKuederle</a> My thoughts align closely with yours: create a bootstrap-style APE that downloads <code>uv</code>, installs Python, fetches dependencies, and executes the source code. I've already implemented this in a package called <a href="https://github.com/TanixLu/pyfuze">pyfuze</a>.</p>
</blockquote>
<p>I don't think this is what's needed; this requires internet access and (correct me if I'm wrong) doesn't build binaries.
What's needed:</p>
<ul>
<li>pre-build all the binaries</li>
<li>compute the transitive closure of all desired packages</li>
<li>include them all in some archive format</li>
<li>make it possible to import from the archive format</li>
<li>create a stub at the front of it to make it runnable
The idea is that the package should be runnable without a python install and without having to install stuff from the internet (so it can be run at scale on the cloud / in a VPC)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/TanixLu">@TanixLu</a> on 2025-06-04 02:58</div>
            <div class="timeline-body"><blockquote>
<ul>
<li>The idea is that the package should be runnable without a python install and without having to install stuff from the internet (so it can be run at scale on the cloud / in a VPC)</li>
</ul>
</blockquote>
<p>This is a trade-off. If everything is prepared in advance instead of being downloaded online, the compressed package will be large in size, and cross-platform compatibility will become problematic. This undermines the advantages of APE's cross-platform capability and uv's fast dependency downloading. For users without programming experience, having a single file that runs on all platforms is incredibly convenient. If pre-prepared cross-platform uv, Python, and dependencies are required, and APE selects them at runtime based on the operating system, the package would be even larger.</p>
<p>With the current version of <a href="https://github.com/TanixLu/pyfuze">pyfuze</a>, you could run it once on a specific platform and then recompress it into a package, eliminating the need for an internet connection. However, the trade-off is that the application becomes platform-specific and larger in size. Perhaps I should add appropriate options to pyfuze, allowing users to opt to pre-download dependencies.</p>
<p>Additionally, I noticed that <a href="https://github.com/jart/cosmopolitan/issues/166">APE-is-also-a-ZIP</a>. I wonder if it could be made self-extracting, which would be even more convenient.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/blais">@blais</a> on 2025-06-04 05:12</div>
            <div class="timeline-body"><p>No. The trade-off defines a completely different feature ask. I think you have an uncommon definition for the meaning of &quot;bundling.&quot;</p>
<p>There's a lot of prior art on this. See Bazel &quot;par&quot; files and XAR files and a bunch of other packagers for Python. The ability to run an <em>isolated</em> package without any network access is the key feature of &quot;bundling,&quot; the isolation is the feature that allows reliable execution on a variety of hosts. Especially for cron jobs. In a private cluster with tight security you cannot rely on uv fetching resources available on the internet, resources that can change between invocations, or even uv's own behavior to change. I would argue that even if you pinned down the version of uv itself in the zip file you're possbly liable to see failures. Bundles are basically single-application lightweight docker containers, where you don't have docker or you don't want its limitations (e.g., mount/network isolation) -- you just want to run the program from a single file as if it were an a single executable file, with no dependencies.</p>
<p>The bundling that you provide in pyfuze is minimal (I just read your code). It's a wrapper that copies the script and a few files configuring the dependencies for uv to do the heavy lifting. I think its usefulness is limited; call it &quot;lightweight bundling&quot; perhaps. Except for the uv install bit (which really ought to be done once per host), a regular Python program with a main file that has a <code>#!/usr/bin/env -S uv run --script</code> hash-bang does most of what pyfuze provides IMHO.</p>
<p>These are two separate sets of problems. &quot;Bundling&quot; is the former.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/14727.html">astral-sh/uv#14727</a> on 2025-07-18 16:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/14838.html">astral-sh/uv#14838</a> on 2025-07-23 08:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kskarthik">@kskarthik</a> on 2025-07-23 09:16</div>
            <div class="timeline-body"><p>This feature would be a great addition to the python ecosystem!</p>
<p>Deno &amp; Bun implemented it for the node ecosystem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/parkan">@parkan</a> on 2025-08-21 13:59</div>
            <div class="timeline-body"><p>being able to ditch all the glue code needed by pyinstaller would be <em>amazing</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kishaningithub">@kishaningithub</a> on 2025-08-21 16:21</div>
            <div class="timeline-body"><p>Pyapp can also be considered an option for creating statically linked binaries</p>
<p>https://www.infoworld.com/article/4030697/pyapp-an-easy-way-to-package-python-apps-as-executables.html</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/parkan">@parkan</a> on 2025-09-06 15:44</div>
            <div class="timeline-body"><blockquote>
<p>Pyapp can also be considered an option for creating statically linked binaries</p>
<p>https://www.infoworld.com/article/4030697/pyapp-an-easy-way-to-package-python-apps-as-executables.html</p>
</blockquote>
<p>this is looks great and appears to natively (though optionally) use <code>uv</code> in the build chain https://ofek.dev/pyapp/latest/runtime/</p>
<p>will definitely try this out!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/15836.html">astral-sh/uv#15836</a> on 2025-09-14 14:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../elastic/rally/pulls/1981.html">elastic/rally#1981</a> on 2025-10-09 08:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alekssamos">@alekssamos</a> on 2025-10-16 19:42</div>
            <div class="timeline-body"><p>I made an sfx file using winrar. Set the options to show nothing, hide everything, and accept the defaults. Execute after installation <code>uv run app.py</code>. And it worked.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/16905.html">astral-sh/uv#16905</a> on 2025-12-16 14:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/metaist">@metaist</a> on 2025-12-24 06:12</div>
            <div class="timeline-body"><p>Took me a while to rewrite the whole thing to use <code>uv</code>, but if you add an appropriate <code>[project.scripts]</code> to your <code>pyproject.toml</code> then you can do:</p>
<p>uvx cosmofy bundle</p>
<p>And it'll produce a single Cosmopolitan Python for each entry point using uv. You can also do <code>--script</code> to bundle up a single script with its inline dependencies. There are <a href="https://github.com/metaist/cosmofy#limitations">some limitations</a>, but it's a start.</p>
<p>See: https://github.com/metaist/cosmofy</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/inoa-jboliveira">@inoa-jboliveira</a> on 2025-12-26 13:17</div>
            <div class="timeline-body"><p>Hi @metaist I'm interested in your solution, and might give it a try. One thing I noticed is that you seem to be <a href="https://github.com/metaist/cosmofy/blob/815ee899788b3e062a014960c35901b9181d1ea1/src/cosmofy/bundle.py#L38">hosting a python binary yourself</a> instead of using uv to download it which would manage correctly the arch and OS.</p>
<p>Having this is also not auditable and some places would not accept such file. Is there any attestation where it comes from?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/metaist">@metaist</a> on 2025-12-26 13:47</div>
            <div class="timeline-body"><blockquote>
<p>Hi <a href="https://github.com/metaist">@metaist</a> I'm interested in your solution, and might give it a try. One thing I noticed is that you seem to be <a href="https://github.com/metaist/cosmofy/blob/815ee899788b3e062a014960c35901b9181d1ea1/src/cosmofy/bundle.py#L38">hosting a python binary yourself</a> instead of using uv to download it which would manage correctly the arch and OS.</p>
<p>Having this is also not auditable and some places would not accept such file. Is there any attestation where it comes from?</p>
</blockquote>
<p>Thanks @inoa-jboliveira!</p>
<ol>
<li><p>The whole point of <a href="https://ahgamut.github.io/2021/07/13/ape-python/"><strong>Cosmopolitan</strong> Python</a> is that it doesn't depend on arch and OS. It's a single binary file that is actually a very clever zip that runs on all the OSes without changes. Part of the reason I wanted to build this is so that I don't have to rebuild different binaries for every OS. It's just one binary. Note that <a href="https://github.com/metaist/cosmofy/blob/815ee899788b3e062a014960c35901b9181d1ea1/src/cosmofy/bundle.py#L227">I do use <code>uv</code> to build a temporary venv</a> of your project (or script) which captures all the dependencies properly on the OS you happen to be on and then I bundle them into the Cosmopolitan Python executable.</p>
</li>
<li><p>The point about audits/attestation is valid and strong; this is one of the limitations of the current approach (see https://github.com/metaist/cosmofy/issues/44). I'm currently using the python binary built and hosted by Justine Tunney (@jart) through <a href="https://github.com/ahgamut/superconfigure">superconfigure</a> by @ahgamut. Every single version of python has to be rebuilt to be a Cosmopolitan Python (superconfigure has lots of patch files to convert the paths and make other adjustments) and right now they're only up to 3.12.3. A longer-term goal I have is to make a dedicated repo (superconfigure builds lots of binaries besides python) for tracking all the changes and having a single attestable build per python version similar to how uv used and then took over <a href="https://github.com/astral-sh/python-build-standalone"><code>python-build-standalone</code></a>.</p>
</li>
<li><p>This is also why you can override the default Cosmopolitan Python URL through <code>COSMOFY_PYTHON_URL</code>  or <code>--python-url</code> to point at a Cosmopolitan Python binary that you've verified or self-host.</p>
</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/inoa-jboliveira">@inoa-jboliveira</a> on 2025-12-26 15:44</div>
            <div class="timeline-body"><blockquote>
<pre><code> [**Cosmopolitan** Python](https://ahgamut.github.io/2021/07/13/ape-python/)</code></pre>
</blockquote>
<p>I had no idea what this is and still I'm kinda intrigued (being nerdsniped here). At the same time, this is not what I'm looking for right now as it will not support C/Rust compiled libraries.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/metaist">@metaist</a> on 2025-12-26 18:33</div>
            <div class="timeline-body"><p>Yes, it's kinda wild that with the right combinations of magic numbers this is possible.</p>
<p>C extensions is also on my future list: https://github.com/metaist/cosmofy/issues/94</p>
<p>In theory, anything that can be compiled with libc can be recompiled with cosmopolitan libc, but in practice it takes some work.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:34:59 UTC
    </footer>
</body>
</html>
