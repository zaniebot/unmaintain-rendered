```yaml
number: 8935
title: AWS Lambda Docker example
type: issue
state: closed
author: tonymaynard97
labels:
  - documentation
assignees: []
created_at: 2024-11-08T12:32:20Z
updated_at: 2025-12-11T10:04:35Z
url: https://github.com/astral-sh/uv/issues/8935
synced_at: 2026-01-10T01:57:20Z
```

# AWS Lambda Docker example

---

_Issue opened by @tonymaynard97 on 2024-11-08 12:32_

<!--
Thank you for taking the time to report an issue! We're glad to have you involved with uv.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `uv pip sync requirements.txt`), ideally including the `--verbose` flag.
* The current uv platform.
* The current uv version (`uv --version`).
-->
I was wondering if there were any examples on how to use UV with the prebuilt AWS lambda python base images? Using the https://docs.astral.sh/uv/guides/integration/docker/ as reference but I seem to get into a state where the lambda does not have access to the imports. 

I thought there wasn't a need to update PYTHONPATH as this would point to the default used by the lambda.
Dockerfile
```
FROM public.ecr.aws/lambda/python:3.13
ARG ACCESS_TOKEN

# Install uv
COPY --from=ghcr.io/astral-sh/uv:latest /uv /uvx /bin/

# Enable bytecode compilation
ENV UV_COMPILE_BYTECODE=1
ENV UV_LINK_MODE=copy


# Copy pyproject.toml and uv.lock to the working directory
COPY pyproject.toml uv.lock ${LAMBDA_TASK_ROOT}

# Install dependencies using uv
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --frozen --no-install-project --no-dev

# Copy the rest of the application code
COPY . ${LAMBDA_TASK_ROOT}

WORKDIR ${LAMBDA_TASK_ROOT}
# Install the project itself
RUN --mount=type=cache,target=/root/.cache/uv \
    uv sync --frozen --no-dev

RUN python -c "import aws_lambda_typing; print('aws_lambda_typing is installed')"

CMD ["lambda.lambda_handler"]
```

lambda.py
```
from aws_lambda_typing import context as ctx
from aws_lambda_typing import events
import logging


def lambda_handler(event: events.APIGatewayProxyEventV1, context: ctx.Context):
    # def lambda_handler(event, context):
    logging.info("RUNNING")
    return {"statusCode": 200, "body": "Ok"}
```
Command is correct as when I remove the types I get a 200. 

pyproject.toml
```
[project]
name = "test"
version = "0.1.0"
description = "Add your description here"
readme = "README.md"
requires-python = ">=3.11.9"
dependencies = [
    "aws-lambda-typing==2.17.0",
]

---

_Label `documentation` added by @charliermarsh on 2024-11-09 02:21_

---

_Comment by @charliermarsh on 2024-11-09 02:21_

This is a good question -- @zanieb, do you think it's worth having a guide for Lambda?

---

_Comment by @zanieb on 2024-11-11 14:49_

Yeah I think so. The packaging situation for Lambda is pretty weird though, it might be hard for us to write. It'll probably be pretty stable, as least.

---

_Comment by @sertainly on 2024-11-20 10:26_

I was just trying to get this to work and for me, the `--system` flag was the important part.

For me it's always helpful to have a minimal working example, something along the lines of:

Dockerfile:

```docker
FROM public.ecr.aws/lambda/python:3.12

# Copy python code and the pyproject.toml
COPY ./aws/lambdas ${LAMBDA_TASK_ROOT}/lambdas
COPY ./pyproject.toml ./pyproject.toml

# Install uv
RUN pip install uv
# The --system flag points uv to use the python expected by AWS
RUN uv pip install . --system
```

I hope this already helps. If I can/should provide more context, please let me know ðŸ˜Š 


---

_Comment by @fitz-vivodyne on 2024-11-20 17:33_

Also currently trying to figure out how to get `uv sync` to work in an AWS lambda container (`public.ecr.aws/lambda/python:3.13-arm64` for me though)

Trying some variations of `ENV UV_PROJECT_ENVIRONMENT="/var/lang/bin"` (no luck)

---

_Comment by @fitz-vivodyne on 2024-11-20 17:42_

Here's my latest attempt which appears to work:


```docker
# syntax=docker/dockerfile:1

# We don't need `uv` in the final image, so we'll just mount the binary
# See https://docs.astral.sh/uv/guides/integration/docker/
FROM ghcr.io/astral-sh/uv:0.5.2 AS uv

FROM public.ecr.aws/lambda/python:3.13-arm64

# Enable bytecode compilation
ENV UV_COMPILE_BYTECODE=1
# Copy from the cache instead of linking since it's a mounted volume
ENV UV_LINK_MODE=copy

# Install dependencies
RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=secret,id=UV_INDEX,env=UV_INDEX \
    uv export --format=requirements-txt --frozen -o requirements.txt && \
    uv pip install -r requirements.txt --system && \
    rm requirements.txt

# copy app source
COPY src ${LAMBDA_TASK_ROOT}/src
RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=secret,id=UV_INDEX,env=UV_INDEX \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    uv sync --frozen
```

---

_Comment by @doron98 on 2024-11-27 10:18_

Same comment as in this issue #9350 including path dependencies is tricky. In this case maybe more here I think we would like to generate a requirement file without the path dependencies and the ability to copy them in our bundle dir before building our docker image https://github.com/sst/sst/pull/5132

---

_Comment by @zanieb on 2024-11-27 15:26_

@doron98 there's `uv export --no-emit-workspace` for that, and you can `--no-emit-package` other specific path dependencies.

---

_Comment by @doron98 on 2024-11-27 18:56_

Yes it is exactly what is has been done in this pr https://github.com/sst/sst/pull/5132, we force the user to use workspace and when exporting with the `--no-emit-workspace` option we are able to get the requirements files with all third party dependencies. Now what it lacks it's to bring ('copy paste') the local dependency inside the build directory. There is no easy way to do it. What is has been done in the pr is `uv buid --sdist --all` that build all local packages, then we extract all builded packages and copy paste them next to the handler. I was hoping there would be cleaner way to it, because this has the huge drawback of adding local dependency that our handler may not depends.

---

_Comment by @tibbe on 2024-12-20 13:28_

I would very much appreciate an example that includes (editable) path dependencies. We have a large monorepo with several applications and thus we don't use workspaces (because there's not once set of consistent package versions that work across all applications). Currently I'm doing

```Dockerfile
# We don't need `uv` in the final image, so we'll just mount the binary
# See https://docs.astral.sh/uv/guides/integration/docker/
FROM ghcr.io/astral-sh/uv:0.5.2 AS uv

FROM public.ecr.aws/lambda/python:3.11 AS builder
ARG TARGETPLATFORM

ENV UV_COMPILE_BYTECODE=1
ENV UV_LINK_MODE=copy

WORKDIR ${LAMBDA_TASK_ROOT}

COPY core core
COPY db db
COPY backend/pyproject.toml backend/uv.lock ./backend/

WORKDIR ${LAMBDA_TASK_ROOT}/backend

RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    uv export --frozen --no-emit-project --no-hashes --no-dev -o requirements.txt --no-editable && \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}" --system

WORKDIR ${LAMBDA_TASK_ROOT}/backend

COPY backend/app ./app

FROM public.ecr.aws/lambda/python:3.11

WORKDIR ${LAMBDA_TASK_ROOT}

COPY --from=builder ${LAMBDA_TASK_ROOT} ./

CMD [ "app.api.main.handler" ]
```

I suspect that this part

```Dockerfile
COPY core core
COPY db db
```

isn't the best way to achieve this.

---

_Assigned to @charliermarsh by @charliermarsh on 2025-01-02 14:52_

---

_Referenced in [astral-sh/uv#10278](../../astral-sh/uv/pulls/10278.md) on 2025-01-02 18:07_

---

_Comment by @charliermarsh on 2025-01-02 19:02_

I put something together here: https://github.com/astral-sh/uv/pull/10278

---

_Closed by @charliermarsh on 2025-01-07 18:50_

---

_Closed by @charliermarsh on 2025-01-07 18:50_

---

_Comment by @adri1wald on 2025-01-13 00:36_

Trying to wrap my head around the scenario where you have multiple apps:

```toml
[project]
name = "monorepo"
version = "0.1.0"
description = "Monorepo"
readme = "README.md"

requires-python = ">=3.13"
dependencies = []

[dependency-groups]
dev = [
    "ruff~=0.9.1",
    "pytest~=8.3.3",
    "pytest-xdist~=3.6.1",
    "pyright>=1.1.391",
]

[tool.uv.workspace]
members = [
    "apps/example-app",
    "apps/example-app-2",
    "libs-py/*",
]
```

This is the direction I'm trying, but it's not working:

```dockerfile
ARG PATH_TO_ROOT=../..
ARG APP=example-app

#*---------- uv ----------

FROM ghcr.io/astral-sh/uv:0.5.18 AS uv

#*---------- builder ----------
FROM public.ecr.aws/lambda/python:3.13 AS builder

ARG PATH_TO_ROOT
ARG APP

# Enable bytecode compilation, to improve cold-start performance.
ENV UV_COMPILE_BYTECODE=1
# Disable installer metadata, to create a deterministic layer.
ENV UV_NO_INSTALLER_METADATA=1
# Enable copy mode to support bind mount caching.
ENV UV_LINK_MODE=copy


RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=${PATH_TO_ROOT}/uv.lock,target=uv.lock \
    --mount=type=bind,source=${PATH_TO_ROOT}/pyproject.toml,target=pyproject.toml \
    uv export --frozen --no-emit-workspace --no-dev --no-editable -o requirements.txt && \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}"

RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=${PATH_TO_ROOT}/uv.lock,target=uv.lock \
    --mount=type=bind,source=${PATH_TO_ROOT}/pyproject.toml,target=pyproject.toml \
    # pull in libs-py, our shared libraries
    --mount=type=bind,source=${PATH_TO_ROOT}/libs-py,target=libs-py \
    # pull in the app's pyproject.toml
    --mount=type=bind,source=${PATH_TO_ROOT}/apps/$APP/pyproject.toml,target=apps/$APP/pyproject.toml \
    # not sure why needed
    touch apps/$APP/README.md && \
    # fails but i don't want to copy in the app code until after installing libs-py deps
    uv export --package $APP --frozen --no-dev --no-editable -o requirements.txt && \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}"

# ...
```

I tried adding `--no-emit-package $APP` but this caused none of the **local** deps to be included. Any ideas @charliermarsh ?

---

_Comment by @JuR-0 on 2025-04-28 08:57_

Hey @tibbe, in the end did you manage to build a docker with local dependencies without having to copy all of your source code (and thus invalidate the layer for each changes) ?

---

_Comment by @tibbe on 2025-05-02 14:11_

> Hey [@tibbe](https://github.com/tibbe), in the end did you manage to build a docker with local dependencies without having to copy all of your source code (and thus invalidate the layer for each changes) ?

Unfortunately not. You can avoid copying the sources just for the main project/executable but all the local libraries need to be copied before the initial `uv sync`/`uv pip install` and thus invalidate the layer.

I think we need some new functionality in uv to make this work.

---

_Comment by @jusexton on 2025-12-11 10:04_

@adri1wald I have a very similar setup. Something like
```
project
|_pyproject.toml <-- doesnt have all the dependencies needed
|_packages
   |__app. <-- fastapi app
   |__lib1
   |__libx
```
I've given [the docs associated with this issue](https://docs.astral.sh/uv/guides/integration/aws-lambda/#workspace-support) a good read and have something similar to your dockerfile but no luck. When running the image it can never find the library.

```dockerfile
FROM ghcr.io/astral-sh/uv:0.9.17 AS uv
FROM public.ecr.aws/lambda/python:3.13 AS builder

ENV UV_COMPILE_BYTECODE=1
ENV UV_NO_INSTALLER_METADATA=1
ENV UV_LINK_MODE=copy

RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    uv export --frozen --package app --no-emit-workspace --no-dev --no-editable -o requirements.txt && \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}"

RUN --mount=from=uv,source=/uv,target=/bin/uv \
    --mount=type=cache,target=/root/.cache/uv \
    --mount=type=bind,source=uv.lock,target=uv.lock \
    --mount=type=bind,source=pyproject.toml,target=pyproject.toml \
    --mount=type=bind,source=packages/lib1 target=lib1 \
    uv export --frozen --no-dev --no-editable -o requirements.txt && \
    uv pip install -r requirements.txt --target "${LAMBDA_TASK_ROOT}"

FROM public.ecr.aws/lambda/python:3.13

COPY --from=builder ${LAMBDA_TASK_ROOT} ${LAMBDA_TASK_ROOT}
COPY ./packages/app/app ${LAMBDA_TASK_ROOT}/app

CMD ["app.main.handler"]
```

---
