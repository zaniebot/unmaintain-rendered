<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Should `uvx` use a project dependency if available? - astral-sh/uv #7186</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Should <code>uvx</code> use a project dependency if available?</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/7186">#7186</a>
        opened by <a href="https://github.com/zanieb">@zanieb</a>
        on 2024-09-08 13:22
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a></div>
            <div class="timeline-body"><p>Right now, <code>uvx</code> will run in an isolated environment even if the target tool is installed in the current project. For example, <code>uvx ruff</code> will not use the version of Ruff declared in the project (e.g., with <code>uv add ruff==0.3.0</code>). If we're in a project, it might make sense to respect the version there instead of ignoring it?</p>
<p>This may be a reasonable way to support defining tools in projects until we design and implement &quot;project-level tool definitions&quot; per #3560.</p>
<p>Related:</p>
<ul>
<li>https://github.com/astral-sh/uv/issues/6377</li>
<li>https://github.com/astral-sh/uv/issues/5903#issuecomment-2336546258</li>
<li>#3560</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">uv tool</span> added by @zanieb on 2024-09-08 13:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @zanieb on 2024-09-08 13:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/helderco">@helderco</a> on 2024-09-08 14:29</div>
            <div class="timeline-body"><p>My preference is to reserve <code>uvx</code> for stuff in <code>.venv/bin</code> (like npx) since <code>uv tool install ruff</code> can create symlinks for the tool's binaries in a place that can be added to the <code>$PATH</code> (like pipx) and run with simply <code>ruff</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-09-08 14:44</div>
            <div class="timeline-body"><blockquote>
<p>My preference would be to use uv tool run, but place symlinks for the tools in a directory that can be added to the $PATH</p>
</blockquote>
<p>Isn't this just <code>uv tool install</code>?</p>
<blockquote>
<p>That way, I could install ruff globally with uv tool install ruff, run it with just ruff check, and use uvx for stuff in .venv/bin (like npx with node_modules/bin).</p>
</blockquote>
<p>Except <code>npx</code> will also run arbitrary versions without installing them, right? I'm not sure I follow.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/helderco">@helderco</a> on 2024-09-08 15:06</div>
            <div class="timeline-body"><p>Sorry, I'm on my phone so I can't try things. Reworded my previous comment right after posting.</p>
<p>Didn't know npx could run commands without installing. I don't personally use it now but did a few years ago, when npx came out it was used just for easily running installed binaries in the project.</p>
<p>For global installations I rather use the <code>$PATH</code>. I do use <code>uv run</code> a lot and would prefer uvx be used to shorten that. As for running without installing, could uvx try these in turn?</p>
<ul>
<li>in .venv</li>
<li>in tools dir</li>
<li>isolated</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-09-08 17:06</div>
            <div class="timeline-body"><p>Yep that's the suggestion this issue tracks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/inoa-jboliveira">@inoa-jboliveira</a> on 2024-09-08 17:07</div>
            <div class="timeline-body"><p>Currently <code>uvx</code> is really just a shorthand for <code>uv tool run</code> but it could be a more intelligent command using context.</p>
<p>Meaning it will either call <code>uv run</code> or <code>uv tool run</code> as necessary. And if you actually mean one or the other, you could force it by using the explicit form. If you bake &quot;run&quot; inside &quot;tool run&quot;, you lose this ability.</p>
<p>I don't know if that is feasible as these commands have different options. My original suggestion was to have a 3rd command but I am seeing it as more confusing to the end user than a smarter <code>uvx</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-09-08 17:10</div>
            <div class="timeline-body"><p>The idea here is that <code>uv tool run</code> would check the project for the dependency too. You'd use <code>--no-project</code> to ignore the project dependency declaration. I don't think <code>uvx</code> will ever have different semantics than <code>uv tool run</code> (it'd be too confusing).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matterhorn103">@matterhorn103</a> on 2024-10-17 08:32</div>
            <div class="timeline-body"><p>This actually seems to be two different questions, no?</p>
<ol>
<li>Should <code>uv tool run ruff</code> use the version of <code>ruff</code> installed in the project, if there is one, rather than the global/tools version?</li>
<li>If <code>uv tool run ruff</code> uses a project version of <code>ruff,</code> should it be run in the project environment or in an isolated one?</li>
</ol>
<p>Because so far as I can see (with my limited knowledge of the problem) it would be theoretically possible to do 1 but not 2, no? I.e. reuse the installed wheel but still run it in an isolated environment?</p>
<p>While I'm here, my feedback would be that this seems to me on the face of it not such a great idea. The whole &quot;tool&quot; interface is already a little challenging for newcomers conceptually (was for me, anyway). Assuming that both 1) and 2) are being proposed, this proposal would muddy the waters and make it even more confusing, as the behaviour of <code>uv tool run</code> would vary, and it might not always be clear what is being invoked. Learning and teaching becomes harder as it is no longer possible to break it down as &quot;<code>uv tool</code> uses global/isolated packages and environments and <code>uv run</code> uses local/project packages and environments&quot;.</p>
<p>Sometimes it makes a big difference whether a tool-like package runs in an environment or not (e.g. <code>pyinstaller</code>), and then the clear delineation of the two behaviours is useful and crucial.</p>
<p>If anything I would say that <code>uvx</code> having different behaviour to <code>uv tool run</code> is <em>less</em> confusing than having <em>uv tool run</em> show context-dependent behaviour. But both are a little confusing.</p>
<p>If using the project dependency with <code>uv tool run</code> was implemented, I think it'd be much more user-friendly if it was off by default and turned on with e.g. <code>--use-project</code> rather than the other way round.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/inoa-jboliveira">@inoa-jboliveira</a> on 2024-12-13 17:30</div>
            <div class="timeline-body"><p>I've been using uv run lately to have tools available in the current env of a project without having it installed as a dependency. Tools such as ones that are useful once in a blue moon such as checking for licenses of libs:</p>
<pre><code>uv run --with pip-licenses -- pip-licenses
</code></pre>
<p>This is what I would hope for uvx to be when running inside a project. Notice this must run in the project env to find the libraries.</p>
<p>Reading the docs: <a href="https://docs.astral.sh/uv/concepts/tools/#relationship-to-uv-run">Relationship to uv run</a></p>
<p>For uv run to behave like uvx, it would require <code>--no-project</code> and replace (optional) <code>--from</code> with <code>--with</code>.</p>
<p>So why can't uvx just have a <code>--project</code> flag and a <code>UVX_PROJECT=true</code> env var which would behave like <code>uv run</code>?</p>
<p>This would be very easy to implement and save us a lot of keystrokes and mental gymnastics to remember the usage.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alxmrs">@alxmrs</a> on 2025-02-04 23:15</div>
            <div class="timeline-body"><p>Hey! I'm trying to use <code>uv</code> as my everything dev tool in Python from here on out, and I find <code>uvx</code> / <code>uv run</code> to be really confusing. Specifically, I want to use <code>pytype</code> as a type checker for my project. This tool performs &quot;transitive&quot; type inference (for lack of a better term), meaning it infers types based on my projects code + all of its underlying dependencies.</p>
<p>In short, I would expect to be able to run:</p>
<pre><code class="language-shell">uvx pytype **/*.py
</code></pre>
<p>But instead, I have to run:</p>
<pre><code class="language-shell">uv run --all-extras pytype **/*.py
</code></pre>
<p>Because the isolated environment in the former case doesn't have the full context of the project, and thus throws import related errors.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-04 23:40</div>
            <div class="timeline-body"><p>Hm. At the very least, it seems like <code>uvx</code> could layer the tool environment on top of the project environment? That might fix that use-case, cc @charliermarsh (who has the context on our environment layering impl)</p>
<p>edit: This would be somewhat complicated because then we'd need to sync the project too? But the idea of project-level tools suggests this is okay / <code>--no-project</code> or <code>--isolated</code> can opt-out?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alxmrs">@alxmrs</a> on 2025-02-05 01:52</div>
            <div class="timeline-body"><p>Hey there, thanks for quickly replying. I think I may have spoken too soon. Whereas I was experiencing the issue in my description yesterday when using the <code>uv</code> Github Action, things are working properly now for me in my local environment. I was confused; I am experiencing an unrelated import error related to <code>pytype</code>, something like this: https://github.com/google/pytype/issues/455. That lead me to believe that isolation was the culprit. The following</p>
<pre><code class="language-shell">uvx pytype **/*.py
</code></pre>
<p>does in fact work as intended! My apologies -- I'm still doing my best to learn how to use <code>uv</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aliwo">@aliwo</a> on 2025-02-13 00:06</div>
            <div class="timeline-body"><p>I want this feature!
I use different mypy versions for different project. And I don't want to always specify the exact version everytime I run mypy</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/JakkuSakura">@JakkuSakura</a> on 2025-02-25 09:00</div>
            <div class="timeline-body"><p>I just tested pyright. If I run uvx, it doesn't use my enviornment and reports many dependencies are missing. I have to activate my venv first</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mstarodub">@mstarodub</a> on 2025-02-25 22:06</div>
            <div class="timeline-body"><blockquote>
<p>Hm. At the very least, it seems like <code>uvx</code> could layer the tool environment on top of the project environment? That might fix that use-case, cc <a href="https://github.com/charliermarsh">@charliermarsh</a> (who has the context on our environment layering impl)</p>
<p>edit: This would be somewhat complicated because then we'd need to sync the project too? But the idea of project-level tools suggests this is okay / <code>--no-project</code> or <code>--isolated</code> can opt-out?</p>
</blockquote>
<p>Surprised this isnâ€™t already possible, running an ipython repl in a uv project seems to require <code>uv add ipython</code>, which seems unnecessary as it's a dev dep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-25 22:34</div>
            <div class="timeline-body"><p><code>uv run --with ipython ipython</code> works fine, you don't need to add it as a dependency. <code>uvx</code> is just sugar to avoid an explicit <code>--with</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Winand">@Winand</a> on 2025-04-08 08:33</div>
            <div class="timeline-body"><blockquote>
<p><code>uv run --with ipython ipython</code> works fine, you don't need to add it as a dependency.</p>
</blockquote>
<p>maybe <code>uv run</code> could implicitly add <code>--with</code> if a tool is not installed in the environment? Like <code>uv run ipython</code> or <code>uv run ptpython</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dedebenui">@dedebenui</a> on 2025-05-22 08:50</div>
            <div class="timeline-body"><p>Adding my two cents, I like the present state of things:</p>
<ul>
<li><code>uvx</code> never messes with the current project, if one exists</li>
<li><code>uv add --dev ruff==0.9.1</code> (say you want a specific version for that project), combined with <code>uv run ruff</code> lets me run tools in the context of my project</li>
</ul>
<p>And indeed, if I want to run a one-off command in my project's environment, <code>uv run --with</code> is there.  I think the value of shaving a few characters off a command is minimal. I do agree however that <code>uv run --with ipython ipython</code> is a bit redundant but I would be wary of adding new syntax and/or implicit behavior. It's already the case that if you <code>uv tool install ipython</code>, you can <code>uv run ipython</code> inside a project, even if <code>ipython</code> is nowhere in <code>pyproject.toml</code>, and it will run in your <code>.venv</code> with access to your project's dependencies. I think this is good enough and intuitive.</p>
<p>I like <code>uvx</code> exactly because I can confidently run it anywhere and know that it's always running the same tool. Making <code>uvx</code> behave differently whether it is run in a project or not would require the dev to know which one is desired, at which point they can bother knowing which command to run.</p>
<blockquote>
<p>Hm. At the very least, it seems like <code>uvx</code> could layer the tool environment on top of the project environment? That might fix that use-case, cc <a href="https://github.com/charliermarsh">@charliermarsh</a> (who has the context on our environment layering impl)</p>
</blockquote>
<p>I've add bad experiences with conflicting packages in the past, for example with both PySide and PyQT in the same environment. I think that layering environments, even when resolving dependencies correctly, would lead to that kind of problems. Is there any instance of &quot;layering&quot; environments elsewhere?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/EonesDespero">@EonesDespero</a> on 2025-06-14 20:17</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p><code>uv run --with ipython ipython</code> works fine, you don't need to add it as a dependency.</p>
</blockquote>
<p>maybe <code>uv run</code> could implicitly add <code>--with</code> if a tool is not installed in the environment? Like <code>uv run ipython</code> or <code>uv run ptpython</code>.</p>
</blockquote>
<p>Depending on what you mean, this could be a fine idea or a terrible idea, in my opinion.
If I misunderstood your comment, please, then correct me.</p>
<p>I am personally against of any tool installing things on its own without permission or opt-in.
The problem is that uv run is the main way to</p>
<p>I think that trying to provide too much sugar is bad. If people really need to run the same command constantly, they are better off creating an alias for their shell. Otherwise uv will end up bloated and confusing.
I am against, but I wouldn't worry about a new syntax like &quot;uvxw&quot; that is uv run tool --with,
but I think that making it the default behaviour is a very bad idea.
IMO, uv run ... should be the smart equivalent to python ..., and not take decisions for you unless you explicitly say it.</p>
<p>Alternatively, uv run --tool ipython could be short hand for uv run tool --with ipython ipython (I predict many people searching the difference between uv tool run and uv run --tool, so maybe another name is better)</p>
<p>But again, I think that users creating an alias uvw='uv tool run --with' should suffice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/absynce">@absynce</a> on 2025-09-11 19:33</div>
            <div class="timeline-body"><p>Intent: Sharing my experience as a data point, and to help anyone else who finds themself here with a similar confusion. No expectations.</p>
<p>Experience:
As someone coming from a world with Node, this confused me because I cargo-culted my prior assumptions about how <a href="https://docs.npmjs.com/cli/v8/commands/npx">npx</a> works. ðŸ˜Š</p>
<p>After reading through the docs, I understand the difference. Now I use <code>uv run</code> to have it pick up the version from <code>pyproject.toml</code>. If I had read more carefully, I would've seen the note in https://docs.astral.sh/uv/guides/tools/#running-tools</p>
<blockquote>
<p>If you are running a tool in a <a href="https://docs.astral.sh/uv/concepts/projects/">project</a> and the tool requires that your project is installed, e.g., when using pytest or mypy, you'll want to use <a href="https://docs.astral.sh/uv/guides/projects/#running-commands">uv run</a> instead of uvx. Otherwise, the tool will be run in a virtual environment that is isolated from your project.</p>
<p>If your project has a flat structure, e.g., instead of using a src directory for modules, the project itself does not need to be installed and uvx is fine. In this case, using uv run is only beneficial if you want to pin the version of the tool in the project's dependencies.</p>
</blockquote>
<p>I know Python handles packages differently from Node, but Python's package/dependency handling still confuses me sometimes. But, it sounds like it might be possible to have <code>uvx</code> behave somewhat similarly to <code>npx</code>. <code>ruff</code> and <code>ty</code> are prime examples of tools I want to lock the version for per project. At this point, I don't have a preference whether they are isolated from the project's other dependencies.</p>
<p>I thought I could do:</p>
<pre><code class="language-shell">uv add --dev ty
uvx ty # This might run a different version from what's specified in `pyproject.toml`.
</code></pre>
<p>Instead, I need to do:</p>
<pre><code class="language-shell">uv add --dev ty
uv run ty # Always runs the version in `pyproject.toml`.
</code></pre>
<p>So, yes, to me, Zanie's suggestion makes sense:</p>
<blockquote>
<p>If we're in a project, it might make sense to respect the version there instead of ignoring it?</p>
</blockquote>
<p>Hope it helps!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/galah92">@galah92</a> on 2025-09-15 12:21</div>
            <div class="timeline-body"><p>I got a similar incentive: running <code>ruff</code>/<code>ty</code> for neovim LSP. I currently do:</p>
<pre><code class="language-lua">vim.lsp.config['ruff'] = {
  cmd = { 'uv', 'run', 'ruff', 'server' },
  filetypes = { 'python' },
  root_markers = { 'pyproject.toml', 'ruff.toml', '.ruff.toml', '.git' },
  settings = {},
}

vim.lsp.config['ty'] = {
  cmd = { 'uv', 'run', 'ty', 'server' },
  filetypes = { 'python' },
  root_markers = { 'pyproject.toml', 'ty.toml', '.git' },
  settings = {},
}
</code></pre>
<p>Which forces me to install them to the project (a good thing!).</p>
<p>However, it would be helpful to either:</p>
<ol>
<li>Add a flag to this comment to run the global tool in case it isn't installed as part of the project.</li>
<li>As the issue suggest: make <code>uvx</code> run the local tool in case it is installed.</li>
</ol>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:26:58 UTC
    </footer>
</body>
</html>
