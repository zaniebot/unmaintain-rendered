<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Development dependency group support - astral-sh/uv #5632</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Development dependency group support</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/5632">#5632</a>
        opened by <a href="https://github.com/zanieb">@zanieb</a>
        on 2024-07-30 20:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/zanieb">@zanieb</a> on 2024-07-30 20:19</div>
            <div class="timeline-body"><p>This is a tracking issue for the general idea of putting development dependencies into named groups for partial installs.</p>
<p>In part, we're waiting to see where <a href="https://peps.python.org/pep-0735/">PEP 735</a> goes, which</p>
<blockquote>
<p>... specifies a mechanism for storing package requirements in pyproject.toml files such that they are not included in any built distribution of the project.</p>
<p>This is suitable for creating named groups of dependencies, similar to requirements.txt files, which launchers, IDEs, and other tools can find and identify by name.</p>
<p>The feature defined here is referred to as “Dependency Groups”.</p>
</blockquote>
<p>Related:</p>
<ul>
<li>https://github.com/astral-sh/uv/issues/5278#issuecomment-2242053901</li>
<li>https://github.com/astral-sh/uv/issues/3560#issuecomment-2258919283</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-07-30 20:24</div>
            <div class="timeline-body"><p>@mishamsk regarding</p>
<blockquote>
<p>are there any particular plans for PEP 735 functionality? Like for example &quot;we'll wait for PEP 735 to be accepted and will not tackle the case until it is pending&quot;, or maybe &quot;we may get to it sooner o despite PEP 735 status but not earlier than X months from now&quot;</p>
</blockquote>
<p>We may tackle this behavior before PEP 735 is finalized, but we are not going to include this in our upcoming stable release (in the next couple months). In the meantime, we want to:</p>
<ol>
<li>Learn more about use-cases, e.g. people say they need dependency groups for install speed but that it's largely less of a problem with uv's improved performance</li>
<li>Explore how this would work with uv's CLI</li>
<li>Plan for transition to PEP 735's spec if it looks like it will be accepted</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-design</span> added by @zanieb on 2024-07-30 20:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @zanieb on 2024-07-30 20:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2024-07-30 22:07</div>
            <div class="timeline-body"><p>@zanieb thanks.</p>
<blockquote>
<p>Learn more about use-cases, e.g. people say they need dependency groups for install speed but that it's largely less of a problem with uv's improved performance</p>
</blockquote>
<p>I can elaborate a bit on my use case assuming this is the right place:</p>
<h3>So first a rough setup we have for context:</h3>
<ul>
<li>A Commerical enterprise app (so no publishing to PyPi, no public Github Actions)</li>
<li>Running on a hosted Gitlab</li>
<li>we use tox to with a goal of allowing reproducible results on a local developer machine and CI. I.e. CI literally does <code>poetry install --only &quot;tox&quot;</code> and then <code>poetry run tox</code>. The rest is handled within tox environments.</li>
<li>We have test, pre-commit, mypy &amp; docs tox environments. Each try to install the minimum number of packages necessary to run</li>
<li>In poetry we have dips group roughly matching tox envs + <code>tox</code> group (just three deps there) and a <code>build</code> group. The build one should not be confused with the regular python build backend. In our case build is running nuitka</li>
</ul>
<h3>Group requirements</h3>
<ul>
<li>The &quot;speed&quot; is indeed one of the main driving decisions behind trying to only install what's necessary. But this is not the only reason</li>
<li>Some group dependencies may be incompatible with the project dependencies.<ul>
<li>We have at least one such case with <code>requests</code> which we locked and haven't yet updated, but all dev/test tools did, which cause trouble.</li>
<li>TBH poetry doesn't handle this properly as well and we had to apply a workaround eventually...</li>
<li>Also, for this specific case, I wanted to use uv's overrides, so uv is already better ;-)</li>
<li>But, you can check poetry discussions, this is one of the most requested features (independent locking and install of Dep groups) - this is a very real use case when some development dependency has conflict with the project one</li>
</ul>
</li>
<li>You may want to make sure that some packages are not installed in some context(s). E.g. nuitka picks up packages by running python and figuring out what's importable. I am not confident enough that it won't accidentally bundle something I do not want (or a version I do not want). This may be more of a paranoia, but making sure that nothing not directly relevant to the task at hand is installed is nice. In my case with nuitka it means the project dependencies and nuitka and nothing else<ul>
<li>Another more realistic example that we had are integration tests. We are doing e2e test that execute a compiled binary. The tests are the same python files and are executed by pytest, but we wanted to be DEAD sure that the project is not executed from source. But if we have to install it alongside test dependencies and tools, this is not easy</li>
</ul>
</li>
</ul>
<p>I think this is it... I'll add more if I remember something.</p>
<p>Sorry for a long read</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-07-30 22:15</div>
            <div class="timeline-body"><p>Thanks for the context!</p>
<blockquote>
<p>Some group dependencies may be incompatible with the project dependencies</p>
</blockquote>
<p>You highlight this already, but this is a problem in Poetry because it solves for <em>all</em> groups at once and does not allow incompatibilities. This is a problem for us too! If we allow incompatible groups, we have to solve for <em>all possible combinations of the groups</em> to create a lockfile for the project. We're hoping this case is addressed by project-level tools or perhaps in PEP 735.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mishamsk">@mishamsk</a> on 2024-07-30 23:13</div>
            <div class="timeline-body"><p>yes, at least in my case, this is essentially about project-level tools. E.g., I have the latest ruff system wide, but lock different versions for specific projects.</p>
<p>From the vantage point of this use cases, it may make sense to have all the groups in their own isolated environments. I know that project-level tools are out of scope for now, but I can imagine a simple solution where &quot;project-level tool&quot; is just telling uv that a specific version of a tool should be used inside this specific project. Then it will work similar to how pyenv/asdf/mise/rye etc handle python itself - shims/path manipulation. No local secondary .venv's for tools, no cross compilation of dependencies etc.</p>
<p>But others may come up with other use cases. Poetry threads related to groups are numerous and very long!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/chrisrodrigue">@chrisrodrigue</a> on 2024-08-03 19:43</div>
            <div class="timeline-body"><p>I think basic support for development dependency groups and scripts could replace other popular environment management/command running tools like <code>hatch</code> and <code>tox</code> for use cases like @mishamsk’s.</p>
<p>These features would provide a good way to organize dependencies, modularize CI/CD pipelines, and standardize common commands/aliases among teammates and CI/CD by centralizing them in <code>pyproject.toml</code>.</p>
<h1>Example</h1>
<h2><code>pyproject.toml</code></h2>
<pre><code class="language-toml">[tool.uv.dev-dependencies]
check = [
  &quot;codespell&gt;=2.3.0&quot;, 
  &quot;mypy&gt;=1.11.1&quot;, 
  &quot;pre-commit&gt;=3.8.0&quot;, 
  &quot;ruff&gt;=0.5.6&quot;,
]
test = [
  &quot;pytest&gt;=8.3.2&quot;,
  &quot;pytest-cov&gt;=5.0.0&quot;,
  &quot;pytest-mock&gt;=3.14.0&quot;,
]
doc = [
  &quot;mkdocs&gt;=1.6.0&quot;,
  &quot;mkdocs-material&gt;=9.5.31&quot;,
  &quot;mkdocstrings[python]&gt;=0.25.2&quot;,
]
release = [
  &quot;commitizen&gt;=3.28.0&quot;,
  &quot;cyclonedx-bom&gt;=4.5.0&quot;,
]

[tool.uv.commands]
check = [&quot;codespell .&quot;, &quot;ruff check .&quot;, &quot;ruff format .&quot;, &quot;mypy .&quot;]
test = &quot;pytest&quot;
doc = &quot;mkdocs serve&quot;
cov = &quot;pytest --cov --cov-report term-missing --cov-report xml --cov-report html&quot;
hooks = &quot;pre-commit run --all-files&quot;
sbom = &quot;cyclonedx-py environment .venv --outfile sbom.json --output-format json&quot;
clean = &quot;git clean -fdx&quot;
</code></pre>
<h2>CLI Usage</h2>
<h3>Dependency groups</h3>
<pre><code>uv add -g test pytest // add pytest to “test” dev dependency group
uv sync -dg test // only install deps and test deps to .venv
uv sync -dog test -g doc // deps, optional deps, test/doc deps
uv sync // install all deps, optional deps, and dev deps
</code></pre>
<h3>Command running</h3>
<pre><code>uv check // or uv run check
uv doc
uv clean
</code></pre>
<h2>CI/CD Usage</h2>
<pre><code class="language-yaml">jobs:
  check:
    name: &quot;check&quot;
    runs-on: alpine-latest
    steps:
       - name: &quot;Prepare environment&quot;
         run: uv sync -dg check
       - name: &quot;Spell check&quot;
         run: uv run codespell .
       - name: &quot;Static analysis&quot;
         run: uv run ruff check .
       - name: &quot;Type check&quot;
         run: uv run mypy .
  test:
    name: &quot;test&quot;
    runs-on: alpine-latest
    steps:
      - name: &quot;Prepare environment&quot;
        run: uv sync -dg test
      - name: &quot;Code coverage&quot;
        run: uv cov --run unit
      - name: &quot;Integration tests&quot;
        run: uv test --run integration
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lewoudar">@lewoudar</a> on 2024-08-21 06:50</div>
            <div class="timeline-body"><p>Hi everyone, I have a workflow almost similar to @chrisrodrigue, so I really hope this feature will be added. It will help poetry (or pdm) users like me to switch to uv.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/schlamar">@schlamar</a> on 2024-08-22 18:13</div>
            <div class="timeline-body"><p>I think one important use case when talking about replacing tox or hatch wasn't explicitly mentioned yet. The possibility to target multiple python versions. When you develop libraries instead of applications you want to support a wide range of Python versions and define test environment for various Python versions.</p>
<p>Another use case would be targeting different versions of a library. For example when you are developing a pytest plugin you want to test this against various versions of pytest.</p>
<p>These use cases should be considered when uv is providing a feature for multiple development environments.</p>
<p>See for example matrix documentation from hatch: https://hatch.pypa.io/1.12/environment/#matrix</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/schlamar">@schlamar</a> on 2024-08-22 18:22</div>
            <div class="timeline-body"><p>Here are two real world tox configurations covering these use cases.</p>
<p>https://github.com/pallets/flask/blob/main/tox.ini
https://github.com/pytest-dev/pytest-django/blob/main/tox.ini</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Samoed">@Samoed</a> on 2024-08-23 16:07</div>
            <div class="timeline-body"><p>PDM support this and have some use cases examples (I have similar use cases) https://pdm-project.org/latest/usage/dependency/#add-development-only-dependencies</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sebastian-correa">@sebastian-correa</a> on 2024-09-07 17:43</div>
            <div class="timeline-body"><p>Our usecase for dependency groups is &quot;distribution&quot;.</p>
<p>We develop in a bigish application with many components in a single package. For example, imagine the package is <code>package</code> and inside we have <code>component_a</code>, <code>component_b</code> and <code>models</code>, which itself has 2 components inside (2 <code>.py</code> files).</p>
<p>These components are executed by running some Docker images we generate (one per component). These docker images install <code>package</code> but only install the dependency groups related to each component. For example, say <code>component_a</code> needs to interact with a cloud provider, a database and uses a specific framework but <code>component_b</code> doesn't need any of these. In that scenario, we do <code>poetry install --sync --only main --only cloud_provider --only database --only framework_and_related_deps</code>. This makes Docker builds faster and also results in smaller images.</p>
<p>In that same vein, some GitHub Actions only need some dependency groups to run, which makes the venv cache recovery faster (because resulting venvs are smaller).</p>
<p>I recognize that this compartmentalization is a bit horrible as it needs human knowledge of which sub-packages use which dependency groups, and only works because the packages imported when executing <code>component_a/entrypoint.py</code> are some of them (and not all), but it's been working for us to reduce Docker image sizes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gotmax23">@gotmax23</a> on 2024-09-16 21:38</div>
            <div class="timeline-body"><p>I like to have separation of concerns so I know which development dependencies are used for what, and for test sessions in nox (typing, linting, pytest unit tests), I don't want to have extra dependencies that a user won't have if they just install the package in a clean environment impact the results or have tests that only pass because of extra transitive dependencies pulled in by other development tools.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mmlynarik">@mmlynarik</a> on 2024-09-18 09:09</div>
            <div class="timeline-body"><blockquote>
<p>Our usecase for dependency groups is &quot;distribution&quot;.</p>
<p>We develop in a bigish application with many components in a single package. For example, imagine the package is <code>package</code> and inside we have <code>component_a</code>, <code>component_b</code> and <code>models</code>, which itself has 2 components inside (2 <code>.py</code> files).</p>
<p>These components are executed by running some Docker images we generate (one per component). These docker images install <code>package</code> but only install the dependency groups related to each component. For example, say <code>component_a</code> needs to interact with a cloud provider, a database and uses a specific framework but <code>component_b</code> doesn't need any of these. In that scenario, we do <code>poetry install --sync --only main --only cloud_provider --only database --only framework_and_related_deps</code>. This makes Docker builds faster and also results in smaller images.</p>
</blockquote>
<p>I totally agree with this distribution problem description and add one vote in favor of this use case that imho justifies the need for dependency groups in corporate setup.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/michelkok">@michelkok</a> on 2024-10-10 07:24</div>
            <div class="timeline-body"><p>Another usecase is for part of the Machine Learning community where GPU dependencies should only be installed at training time, but during inference can be handled by the much smaller CPU dependencies.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jankatins">@jankatins</a> on 2024-10-15 21:54</div>
            <div class="timeline-body"><p>Seems this is now tracked in https://github.com/astral-sh/uv/issues/8090 so either this or the new issue could be closed as duplicate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @zanieb on 2024-10-25 18:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-25 20:15</div>
            <div class="timeline-body"><p>As of <a href="https://github.com/astral-sh/uv/releases/tag/0.4.27">0.4.27</a> we support this. See #8272.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 04:38:39 UTC
    </footer>
</body>
</html>
