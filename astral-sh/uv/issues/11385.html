<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Write `--no-cache`'s temporary cache into venv not /tmp to allow use of hardlinks in more cases - astral-sh/uv #11385</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Write <code>--no-cache</code>&#x27;s temporary cache into venv not /tmp to allow use of hardlinks in more cases</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/11385">#11385</a>
        opened by <a href="https://github.com/edmorley">@edmorley</a>
        on 2025-02-10 14:13
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/edmorley">@edmorley</a></div>
            <div class="timeline-body">Summary
<p>For our use case (<a href="https://github.com/heroku/heroku-buildpack-python/issues/1616">heroku/heroku-buildpack-python#1616</a> / <a href="https://github.com/heroku/buildpacks-python/issues/248">heroku/buildpacks-python#248</a>) it&#x27;s preferable for us to cache <code>site-packages</code> between builds, instead of uv&#x27;s cache.</p>
<p>As such, we don&#x27;t need/want uv&#x27;s cache to be persisted.</p>
<p>As mentioned in the docs uv always needs a cache, so when using its <code>--no-cache</code> option a cache is still written, but into a temporary directory:
https://docs.astral.sh/uv/concepts/cache/#cache-directory</p>
<p>Currently (uv 0.5.29) this temporary cache is written into the system temp dir:
https://github.com/astral-sh/uv/blob/cbb94e40b391dc6376498710fb025ddc7a1b4385/crates/uv-cache/src/cli.rs#L44-L45
https://github.com/astral-sh/uv/blob/cbb94e40b391dc6376498710fb025ddc7a1b4385/crates/uv-cache/src/lib.rs#L152-L160</p>
<p>However, in some environments (including several of ours) <code>/tmp</code> is on a different device/mount than the environment into which packages are being installed. (In our case a Kubernetes pod, with sub-path mounts mounted at <code>/app</code>, <code>/tmp</code> and <code>/home</code> etc over the read-only container image).</p>
<p>Since hardlinks can&#x27;t be made cross-device/mount, this then unsurprisingly results in:</p>
<pre><code>warning: Failed to hardlink files; falling back to full copy. This may lead to degraded performance.
       If the cache and target directories are on different filesystems, hardlinking may not be supported.
       If this is intentional, set `export UV_LINK_MODE=copy` or use `--link-mode=copy` to suppress this warning.
</code></pre>
<p>We could work around this by using <code>--cache-dir &lt;some path on the same mount as site-packages&gt;</code>, however:</p>
<ul>
<li><code>--cache-dir</code> is (understandably) ignored when using <code>--no-cache</code> (side note: perhaps those options should be marked as conflicting, at least when both are specified as CLI args, rather than env vars?). And without <code>--no-cache</code> we then have to perform manual clean-up ourselves.</li>
<li>It requires us to calculate a custom <code>--cache-dir</code> based on the location of <code>site-packages</code> (which can vary between our environments and end user configuration)</li>
</ul>
<p>...both of which seems like extra work that uv should be handling for us when we use <code>--no-cache</code>?</p>
<p>It seems that if <code>--no-cache</code> instead defaulted to co-locating the temporary cache inside the venv (and/or the environment specified by <code>UV_PROJECT_ENVIRONMENT</code>), then it would be much more likely that hardlinks would work, and uv would give the best performance out of the box in more environments?</p>
Example
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/edmorley">@edmorley</a> on 2025-02-10 14:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-10 15:41</div>
            <div class="timeline-body"><p>Seems reasonable to co-locate these, cc @charliermarsh</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-02-11 00:14</div>
            <div class="timeline-body"><p>That seems reasonable. (It&#x27;s a little bit of an annoying change since we initialize the cache &quot;far away&quot; from where we discover the virtual environment.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-11 00:29</div>
            <div class="timeline-body"><p>I guess there&#x27;s like..</p>
<pre><code>diff --git a/crates/uv-cache/src/lib.rs b/crates/uv-cache/src/lib.rs
index 4049d3f4b..706f0f3c3 100644
--- a/crates/uv-cache/src/lib.rs
+++ b/crates/uv-cache/src/lib.rs
@@ -159,6 +159,27 @@ impl Cache {
         })
     }
 
+    /// If the cache is temporary, relocate it to a temporary directory within the given base.
+    pub fn relocate_temp(self, base: &amp;PathBuf) -&gt; Result&lt;Self, io::Error&gt; {
+        let Some(temp) = self.temp_dir else {
+            return Ok(self);
+        };
+        let new_temp = tempfile::tempdir_in(base)?;
+        for child in fs_err::read_dir(temp.path())? {
+            let child = child?;
+            let path = child.path();
+            if let Some(name) = path.file_name() {
+                let new_path = new_temp.path().join(name);
+                fs_err::rename(path, &amp;new_path)?;
+            }
+        }
+        Ok(Self {
+            root: new_temp.path().to_path_buf(),
+            refresh: self.refresh,
+            temp_dir: Some(Arc::new(new_temp)),
+        })
+    }
+
     /// Set the [`Refresh`] policy for the cache.
     #[must_use]
     pub fn with_refresh(self, refresh: Refresh) -&gt; Self {
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-11 00:29</div>
            <div class="timeline-body"><p>(I wish you could construct a <code>TempDir</code> from an existing path)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/rahulnht">@rahulnht</a> on 2025-02-13 09:08</div>
            <div class="timeline-body"><p>Another usecase, where having cache defaultdir in venv is useful, is while running uv inside docker (with non-root privileges). /var (or other temp) directories are not r/w by default with standard user, and to avoid privilege escalation just for creating a cache, we&#x27;re currently setting  <code>UV_CACHE_DIR=./.cache</code> as a workaround.</p>
<p>Would be nice to have this in the same space as venv to avoid such workarounds</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shaneikennedy">@shaneikennedy</a> on 2025-02-13 12:46</div>
            <div class="timeline-body"><p>I drafted something here, it&#x27;s a naive approach but I think it solves everyone&#x27;s problems here and doesn&#x27;t couple the virtualenv implementation with the cache implementation. Let me know what you think üëç <a href="https://github.com/astral-sh/uv/pull/11477">Make the cache dir wherever uv is called from when --no-cache specified #11477</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/daniel-albuschat">@daniel-albuschat</a> on 2025-06-24 12:26</div>
            <div class="timeline-body"><p>Please also consider read-only filesystems when implementing this. It is a security best practice to run your containers with read-only root filesystems. We already made an exclusion to this for <code>uv</code> to the <code>/tmp/</code> directory, which we mount into a per-instance empty directory, and set <code>UV_CACHE_DIR</code> to something in <code>/tmp/</code>. We didn&#x27;t need this for <code>poetry</code> or <code>pipenv</code>.</p>
<p>It seems that the latest version of <code>uv</code> already tries to write something in <code>./.venv/</code> as of very recently, which, btw., made our production services break, because <code>pwd</code> is read-only. üò¢</p>
<p>Thanks!
Daniel</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-06-24 13:27</div>
            <div class="timeline-body"><p>@daniel-albuschat -- In that case, what if we wrote the file locks to a configurable directory, like <code>UV_LOCK_DIR</code>? Would that solve your problem?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/daniel-albuschat">@daniel-albuschat</a> on 2025-06-24 14:09</div>
            <div class="timeline-body"><p>@charliermarsh Yes, that would definitely help. Even more helpful would be one variable that could be used as a root for everything that uv writes to, so that if <code>UV_CACHE_DIR</code> and the theoretical <code>UV_LOCK_DIR</code> (and potentially other directories/places) were not set, they would default to e.g. <code>${UV_TEMP_DIR}/uv-lock</code> AND <code>${UV_TEMP_DIR}/uv-cache</code>, respectively. Or something similar. Having one variable would be future-proof.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/coretl">@coretl</a> on 2025-06-30 15:58</div>
            <div class="timeline-body"><p>I found this ticket while trying to make a <code>devcontainer.json</code> that uses uv, and I wanted to comment with my attempt (and failure) to keep hard link mode when <code>.venv</code> is a volume mount.</p>
<p>I followed the docs:
https://docs.astral.sh/uv/guides/integration/docker/#developing-in-a-container</p>
<p>Which led me to:</p>
<pre><code>    // Mount the venv as a volume so it doesn&#x27;t exist outside the container
    &quot;mounts&quot;: [
        {
            &quot;target&quot;: &quot;/workspaces/${localWorkspaceFolderBasename}/.venv&quot;,
            &quot;type&quot;: &quot;volume&quot;
        }
    ],
</code></pre>
<p>but then had to change <code>UV_LINK_MODE=copy</code> to silence the warnings as per the docs.</p>
<p>I wondered if I could keep the hard link mode if I set <code>UV_CACHE_DIR=&quot;/workspaces/${localWorkspaceFolderBasename}/.venv/uv_cache&quot;</code>, but that gives an error:</p>
<pre><code>error: Project virtual environment directory `/workspaces/project/.venv` cannot be used because it is not a valid Python environment (no Python executable was found)
</code></pre>
<p>and inspecting <code>.venv</code> I only see a <code>uv_cache</code> directory within it.</p>
<p>I would like to add my vote for being to colocate the venv and the cache in the same volume for devcontainer purposes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-06-30 16:02</div>
            <div class="timeline-body"><p>I think in that case you&#x27;d want</p>
<pre><code>    &quot;mounts&quot;: [
        {
            &quot;target&quot;: &quot;/workspaces/${localWorkspaceFolderBasename}/.uv&quot;,
            &quot;type&quot;: &quot;volume&quot;
        }
    ],
</code></pre>
<pre><code>UV_CACHE_DIR=/workspaces/${localWorkspaceFolderBasename}/.uv/cache
UV_PROJECT_ENVIRONMENT=/workspaces/${localWorkspaceFolderBasename}/.uv/env
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/coretl">@coretl</a> on 2025-07-01 16:09</div>
            <div class="timeline-body"><p>Thank you, that works.</p>
<p>However I am starting to think that doing a volume mount of the project env won&#x27;t work for me as I use the same devcontainer to mount an entire directory of python projects in, and would like to be able to <code>uv sync</code> any one of these. I&#x27;m debating using a <code>UV_CACHE_DIR</code> that is a volume mount, then <code>.venv</code> for each project would be on the host, but using <code>UV_LINK_MODE=symlink</code> so the venv would only work within the container. Initial attempts seem like this would work, although I don&#x27;t know if there are any performance concerns with using <code>UV_LINK_MODE=symlink</code>. I&#x27;ll do some more testing.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:37:12 UTC
    </footer>
</body>
</html>
