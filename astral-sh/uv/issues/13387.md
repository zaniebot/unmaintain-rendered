```yaml
number: 13387
title: Is there a way for one extra to include another extra?
type: issue
state: closed
author: nikhilweee
labels:
  - question
assignees: []
created_at: 2025-05-11T17:38:50Z
updated_at: 2025-05-15T02:40:21Z
url: https://github.com/astral-sh/uv/issues/13387
synced_at: 2026-01-10T01:57:30Z
```

# Is there a way for one extra to include another extra?

---

_Issue opened by @nikhilweee on 2025-05-11 17:38_

### Question

**Background**
Extras in `[project.optional-dependencies]` are flat lists of requirements, so as I understand currently there is no way for one extra to include another.

```toml
[project.optional-dependencies]
dev  = ["pytest","flake8"]
docs = ["sphinx","mkdocs"]
# no syntax for docs to include dev
```


By contrast, `[dependency-groups]` does support [native inclusion](https://packaging.python.org/en/latest/specifications/dependency-groups/#dependency-group-include):
```toml
[dependency-groups]
dev  = ["pytest","flake8"]
docs = ["sphinx","mkdocs"]
docs = [
    "sphinx",
    "mkdocs",
    {include-group = "dev"}, # native inclusion
]
```

**Question**
Does `uv` currently support, or plan to support a way for one `extra` to include other extras?  If not, what’s the recommended way to avoid copy‑&‑paste beyond installing multiple extras (e.g. `uv sync --extra dev --extra docs`)? 

I understand that it might not be easy to change the existing spec for `[project.optional-dependencies]` to match `[dependency-groups]` since that would involve raising a PEP, but I wonder if it's worth adding something in `[tool.uv]` since `uv` has full control over that table.


### Platform

Linux 5.15.167.4-microsoft-standard-WSL2 x86_64 GNU/Linux

### Version

uv 0.7.3

---

_Label `question` added by @nikhilweee on 2025-05-11 17:38_

---

_Comment by @charliermarsh on 2025-05-11 18:01_

Yes:

```toml
[project]
name = "foo"
version = "0.1.0"
dependencies = []

[project.optional-dependencies]
dev = [
    "foo[docs]",
]
docs = [
    "sphinx>=8.2.3",
]
```

---

_Comment by @nikhilweee on 2025-05-11 19:46_

That's interesting, I was under the impression that uv would try to fetch the published package from pypi (and fail if not found) rather than look in the local pyproject. This makes me wonder, how does uv know where to fetch a dependency from?

```toml
[project]
name = "foo"
version = "0.1.0"
dependencies = []

[project.optional-dependencies]
dev = [
    "foo[docs]",
    "pandas[excel]", 
]
docs = [
    "sphinx>=8.2.3",
]
```

Is it as simple as looking for the dependency in the local pyproject and fallback to pypi (or the relevant source)? 

---

_Comment by @charliermarsh on 2025-05-15 02:40_

When looking at a package, if it references a package of the same name, it's assumed to be "itself"; so above, `foo[docs]` is known to be equal to the "current package" since the "current package" is `foo`.

---

_Closed by @charliermarsh on 2025-05-15 02:40_

---
