<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Running out of memory with uv pip install - astral-sh/uv #7004</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Running out of memory with uv pip install</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/issues/7004">#7004</a>
        opened by <a href="https://github.com/atti92">@atti92</a>
        on 2024-09-04 10:39
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/atti92">@atti92</a> on 2024-09-04 10:39</div>
            <div class="timeline-body"><p>We are using uv inside CI/CD, and we are constantly hitting Memory kills by the kubernetes executor.
We don't really want to increase the memory requests to high because it's not needed outside of uv install and it's costly.
We were trying to set concurrency limits, but that didn't really help.</p>
<p>The memory usage seems to increase to high levels, when we have many-many dependencies, and might also increase with the number of extra-indexes.</p>
<p>I'm primarily asking if there is a way to limit memory usage of uv?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-09-04 13:17</div>
            <div class="timeline-body"><p>I think the best way to limit memory would be to limit the number of concurrent builds. Did that not work?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @charliermarsh on 2024-09-04 13:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/atti92">@atti92</a> on 2024-09-04 13:37</div>
            <div class="timeline-body"><p>Even setting all 3 concurrency options to 1 results in almost the same memory spike. Also I think we primarily use pre-built packages.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @zanieb on 2024-10-21 21:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @zanieb on 2024-10-21 21:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-21 21:41</div>
            <div class="timeline-body"><p>Do you have more details on the memory consumption and a reproduction we could use?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-mre</span> added by @zanieb on 2024-10-21 21:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/atti92">@atti92</a> on 2024-10-22 09:03</div>
            <div class="timeline-body"><p>Hi, thanks for looking into this.</p>
<p>I will try to put together a publicly available repro, but we are using multiple internal indexes and that might make the problem worse. For now I've run a local install with a bunch of public+internal dependencies, while measuring max memory with <code>/bin/time -v</code>. These measurements don't seem to justify the kubernetes memory kills (much lower than the limits), but give a baseline comparison between installs.</p>
<p>Excluding internal dependencies:</p>
<p><strong>Default configuration</strong>
htop snippet during running:
<img src="https://github.com/user-attachments/assets/07e18208-edd5-446d-80cc-feda2ae07f59" alt="image" /></p>
<pre><code>Command being timed: &quot;uv pip install --index-strategy first-match --no-cache --reinstall -r requirements.txt&quot;
	User time (seconds): 1.67
	System time (seconds): 2.33
	Percent of CPU this job got: 51%
	Maximum resident set size (kbytes): **115544**
	Minor (reclaiming a frame) page faults: 29839
	Voluntary context switches: 123439
	Involuntary context switches: 479
	File system outputs: 646184
</code></pre>
<p>After adding a secondary public pypi mirror index (anything should work) `--extra-index-url https://mirrors.sustech.edu.cn/pypi/web/simple</p>
<pre><code>Command being timed: &quot;uv pip install --no-cache --reinstall --extra-index-url https://mirrors.sustech.edu.cn/pypi/web/simple -r requirements.txt&quot;
	User time (seconds): 3.33
	System time (seconds): 3.55
	Percent of CPU this job got: 39%
	Maximum resident set size (kbytes): **121448**
	Minor (reclaiming a frame) page faults: 52101
	Voluntary context switches: 150218
	Involuntary context switches: 937
	File system outputs: 670448
</code></pre>
<p><strong>Adding --index-strategy:</strong></p>
<pre><code>Command being timed: &quot;uv pip install --no-cache --reinstall --index-strategy unsafe-first-match --extra-index-url https://mirrors.sustech.edu.cn/pypi/web/simple -r requirements.txt&quot;
	User time (seconds): 3.73
	System time (seconds): 3.86
	Percent of CPU this job got: 36%
	Maximum resident set size (kbytes): **169200**
	Minor (reclaiming a frame) page faults: 64064
	Voluntary context switches: 152854
	Involuntary context switches: 1171
	File system outputs: 738080
</code></pre>
<p><strong>Adding concurrency limits to 1:</strong>  (makes it really slow.
This reduces the memory use a bit.
<img src="https://github.com/user-attachments/assets/4aaa4d57-c1bf-41ee-b8ff-faf7f1e0bc19" alt="image" /></p>
<pre><code>export UV_CONCURRENT_DOWNLOADS=1 
export UV_CONCURRENT_BUILDS=1 
export UV_CONCURRENT_INSTALLS=1
Command being timed: &quot;uv pip install --no-cache --reinstall --extra-index-url https://mirrors.sustech.edu.cn/pypi/web/simple -r requirements.txt&quot;
	User time (seconds): 3.57
	System time (seconds): 3.49
	Percent of CPU this job got: 5%
	Maximum resident set size (kbytes): **108892**
	Minor (reclaiming a frame) page faults: 48392
	Voluntary context switches: 158458
	Involuntary context switches: 652
	File system outputs: 670448
</code></pre>
<p>Most of the memory usage seems to add up during the resolution phase. During download the memory usage creeps higher without sign of a reduction. Adding our local indexes and even more dependencies the memory usage goes up by another 100MB.
using <code>--index-strategy</code> other than the default seems to increase memory usage with each extra index url added.
Running the install locally results in a 280MB total resident memory, although this usually gets killed by kubernetes with a 1GB limit. (does it add up each thread individually?).</p>
<p>Used requirements.txt file for the public tests:</p>
<pre><code>click&gt;=7.0
tabulate&gt;=0.8.9
pyyaml&gt;=6.0
cryptography&gt;=42.0.1
packaging&gt;=21.3
python-keycloak~=4.3.0
azure-identity~=1.17.1
msgraph-sdk~=1.5.4
msal~=1.30.0
dataclasses_json&gt;=0.5.7
semver&gt;=2.13.0
urllib3&gt;=2.0.7
rich-click&gt;=1.7.0
durationpy&gt;=0.7
inquirerpy==0.3.4
pytest&gt;=6.2.5
pytest-cov
pytest-mock&gt;=3.6.1
responses&gt;=0.15.0
respx&gt;=0.21.1
requests-mock&gt;=1.9.3
twill
mkdocs&gt;1.2.4
mkdocs-material
mkdocs-material-extensions
pymdown-extensions
mkdocs-click
</code></pre>
<p>This is our uv config file in CI/CD:</p>
<pre><code>$ cat ${UV_CONFIG_FILE}
concurrent-builds = 1
concurrent-downloads = 2
concurrent-installs = 2
[pip]
python = &quot;python3&quot;
prerelease = &quot;allow&quot;
index-strategy = &quot;unsafe-first-match&quot;
link-mode = &quot;copy&quot;
extra-index-url = [
  &quot;REDACTED&quot;,
  &quot;REDACTED&quot;,
]
</code></pre>
<p>And also environment variables are set to those same settings (including UV_EXTRA_INDEX_URL)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-10-22 11:23</div>
            <div class="timeline-body"><p>So from your screenshots it looks like we're consuming ~3 GB of virtual memory and when you limit concurrency it goes down to ~500 MB? I think we care more about the physical amounts though (RES), which look like 96 MB and 93 MB respectively. That doesn't seem particularly low, but I'm not sure it's unreasonable. In your failure cases, it looks like we're consuming around 100-150 MB?</p>
<blockquote>
<p>using --index-strategy other than the default seems to increase memory usage with each extra index url added.</p>
</blockquote>
<p>This makes sense, we need to store details about the available packages in more indexes.</p>
<p>I wonder if we should add a special limit to the prefetch job, maybe we'd check less package versions then. Or maybe we can free some versions from our mapping early?</p>
<blockquote>
<p>(does it add up each thread individually?).</p>
</blockquote>
<p>All the threads should be sharing memory.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/atti92">@atti92</a> on 2024-10-22 13:39</div>
            <div class="timeline-body"><p>During local testing RES reached <code>280MB</code>, while the same script gets killed in kubernetes around 50% of the time with 1GB limits.
No idea why.</p>
<p>It would be nice if you could reduce the memory footprint or just add some optional hard limits to memory usage / dynamic free during runtime.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BugsBuggy">@BugsBuggy</a> on 2025-02-27 12:19</div>
            <div class="timeline-body"><p>@atti92 did you find a workaround for this issue?</p>
<p>Installing the requirements with uv worked just fine for me. However, calling
<code>uv pip install --no-deps .</code>
results in an OOM in our Kubernetes environment.</p>
<p>I already tried to set these env variables but that did not help:</p>
<pre><code>UV_CONCURRENT_INSTALLS=1
UV_CONCURRENT_BUILDS=1
UV_CONCURRENT_DOWNLOADS=1
UV_NO_CACHE=true
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/atti92">@atti92</a> on 2025-02-27 12:24</div>
            <div class="timeline-body"><p>@BugsBuggy No I haven't It still regularly OOMs, we increased requests limits to 2Gi</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BugsBuggy">@BugsBuggy</a> on 2025-02-27 13:16</div>
            <div class="timeline-body"><p>@zanieb In addition to the settings above tried different things like <code>UV_SYSTEM_PYTHON=true</code> to use the global Python instead of a venv to keep memory low. I also tried to clear the cache (https://docs.astral.sh/uv/concepts/cache/#clearing-the-cache).  Nevertheless the Pod fails with an OOM.</p>
<p>This is still the most likely reason and also explains why none of my attempts helped:</p>
<blockquote>
<p>[...] we need to store details about the available packages in more indexes.&quot;</p>
</blockquote>
<p>Can you consider a CI mode (e.g. via an env variable) or some other settings that would enable uv to run with lower memory and indeed check less package versions?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-02-27 14:49</div>
            <div class="timeline-body"><p>We can look into it, but unless we have a strong understanding of what's driving memory usage we don't know if there will be an easy lever to reduce it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/15279.html">astral-sh/uv#15279</a> on 2025-08-14 13:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alisonatwork">@alisonatwork</a> on 2025-08-18 08:50</div>
            <div class="timeline-body"><p>Following up here instead of on HN so it doesn't get lost...</p>
<blockquote>
<p>We run on-prem k8s and do the pip install stage in a 2CPU/4GB Gitlab runner, which feels like it should be sufficient for the uv:python3.12-bookworm image. We have about 100 deps that aside from numpy/pandas/pyarrow are pretty lightweight. No GPU stuff. I tried 2CPU/8GB runners but it still OOMed occasionally so didn't seem worth using up those resources for the normal case. I don't know enough about the uv internals to understand why it's so expensive, but it feels counter-intuitive because the whole venv is &quot;only&quot; around 500MB.</p>
</blockquote>
<p>I haven't yet tried running with concurrency limits because it isn't yet annoying enough for us to bother tweaking settings. Because the OOMs are &quot;random&quot; it's also hard for us to be certain if any given change would improve things without doing a bunch of testing, which we don't really have time for right now.</p>
<p>It would be easier to give concurrency limits a try if there is a sense of exactly which step might be the expensive one. One would hope that concurrent-downloads is not expensive since presumably most of the time is spent waiting for the OS to do i/o and then just writing a fixed size buffer to disk, but perhaps that depend on the size of the buffer and how often they are flushed. Not sure if Rust has a zero-copy i/o path? My suspicion is that concurrent-builds could be risky in a worst case scenario, but most of our deps have wheels so there isn't much to compile. concurrent-installs? Doesn't feel like much. What would you recommend trying first?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-08-18 22:23</div>
            <div class="timeline-body"><p>@alisonatwork can you share a reproduction of the requirements you're using? I started hacking on some coverage in CI at #15279 and can could use a low limit to try to determine what's going on.</p>
<p>cc @konstin regarding which concurrency limit is a good place to start with.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alisonatwork">@alisonatwork</a> on 2025-08-19 03:39</div>
            <div class="timeline-body"><p>@zanieb I'll have to confer with my boss if it's okay to share a full requirements.txt from one of our projects in a public forum, but you can probably get a good chunk of the way there if you pip freeze a venv with the latest aiohttp, boto3, celery, confluent-kafka, cryptography, pandas, pyarrow, sqlalchemy and various other usual suspects.</p>
<p>I spent about a half hour digging through the uv source code today to try get a handle on what knob to tweak. Bear in mind I don't have any experience with Rust so can't speak to its particular quirks.</p>
<p>I focused on the downloader simply because that is the part of the code with the biggest default concurrency (50).</p>
<p>The flow seems to start at <code>uv-installer/src/preparer.rs:get_wheel</code> which enqueues a download/unzip/build task on - I guess - a thread pool of size 50. If Rust threads have 2MB stack then that's 100MB out of the box, assuming the total number of deps &gt;= 50.</p>
<p>Then it seem to split to <code>uv-distribution/src/distribution_database.rs:get_wheel</code> which will pick between download with streaming unzip, or fallback to direct download to tmp file (copy through <code>tokio::io::BufWriter</code> with default 8kb bufsize).</p>
<p>In any case it will eventually route through to <code>uv-extract/src/stream.rs:unzip</code> which read through a <code>futures::io::BufReader</code> with 128kb bufsize and write through a <code>tokio::io::BufWriter</code> with up to 1MB bufsize. So potentially for very large zip entries we might have another 50x1 = 50MB here (assuming these buffers are heap-allocated). I'm not sure if behind the scenes the entire entry is kept in memory in order for <code>compute_hash</code> to work, but let's assume that it is, then maybe also worst case scenario you have one whole file in memory before moving on to the next entry. For Python source the file sizes are trivial, but for deps which include data blobs or compiled binaries it can get hideous, e.g. some of the shared objects in pyarrow which are &gt;= 20MB. Let's be kind and say 10MB worst case, so 50x10 = 500MB.</p>
<p>All this added together still seems like less than a gig of memory usage. So although it does seem possible that the download concurrency is the biggest opportunity for improvement, it still feels like somewhere in the pipeline memory is being wasted. What I will try on our current CI builds is reduce the download concurrency to 20, see if that make a difference.</p>
<p>Update after adjusting the concurrency and adding some logging:</p>
<pre><code>$ uv run --show-settings | grep -A4 concurrency
    concurrency: Concurrency {
        downloads: 20,
        builds: 8,
        installs: 8,
    },
</code></pre>
<p>Seems that our 2-core runner is being over-estimated by Rust's <code>std::thread::available_parallelism</code>, which isn't going to help matters. I will reset downloads to 50 and restrict the builds to 2 instead. We only have a handful of libraries that require a build step, but just to make sure we are working from a standard baseline.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-08-19 08:27</div>
            <div class="timeline-body"><p>Thanks you for this thorough investigation!</p>
<p>My main question would be when the OOM happens, is it in the prepare phase or in the install phase? You can builds and when the prepare phase is done in the regular logs, with the verbose logs showing when each package starts and ends.</p>
<pre><code>$ uv pip install pandas
Resolved 6 packages in 58ms
      Built pandas==2.3.1
Prepared 2 packages in 42.21s
Installed 6 packages in 8ms
 + numpy==2.3.2
 + pandas==2.3.1
 + python-dateutil==2.9.0.post0
 + pytz==2025.2
 + six==1.17.0
 + tzdata==2025.2
</code></pre>
<p>For changing the parallelism, the key variables are <a href="https://docs.astral.sh/uv/reference/environment/#uv_concurrent_downloads">UV_CONCURRENT_DOWNLOADS</a>, <a href="https://docs.astral.sh/uv/reference/environment/#uv_concurrent_installs">UV_CONCURRENT_INSTALLS</a> and <a href="https://docs.astral.sh/uv/reference/environment/#uv_concurrent_builds">UV_CONCURRENT_BUILDS</a>.</p>
<p>I wonder if it's the builds that cause the OOM? Compilers, especially when building the final release artifact can take a lot of memory (uv's own release build has a peak RSS of &gt;4GB). This would explain how we could OOM on an 8GB machine.</p>
<p>We use two different kinds of parallelism: async with tokio and threadpools with rayon. tokio usually only spawns a handful of actual threads, though the futures themselves can grow large, we try to use future boxing to keep their size in bounds. The download and prepare phase mainly uses tokio, while the rayon threadpool is used mainly in the installation phase.</p>
<p>We're using 4MB stacks due to issues with large futures in debug builds. However, in the rayon thread pool with its 50 workers we runs only sync code without excessively deep call stacks, so we can reduce this to 2MB again (or even 1MB) if it turns out to be the culprit. We've been liberal with using large buffered readers and writers everywhere (unbuffered reads and writes are slow), if that's the problem we can audit for duplicate or overly large buffers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alisonatwork">@alisonatwork</a> on 2025-08-19 09:33</div>
            <div class="timeline-body"><p>The build hypothesis seems like a good one! I've looked back through the last 10-15 OOMed builds and they start off something like this:</p>
<pre><code>$ uv pip install -r ci-requirements.txt
Resolved 139 packages in 1.96s
Downloading pip (1.7MiB)
Downloading pyarrow (40.8MiB)
Downloading confluent-kafka (3.7MiB)
...
   Building mysqlclient==2.2.7
...
</code></pre>
<p>Note I am leaving out a bunch of packages, but the point is around ~20 downloads and ~5 builds down the chain, we get the OOM. We aren't building any heavyweight stuff, but even just those handful of small deps without a wheel might indeed blow out the RAM when several are happening in parallel.</p>
<p>Earlier today I switched UV_CONCURRENT_BUILDS and UV_CONCURRENT_INSTALLS both to 2 in one of our projects, to match the logical cores available to the runner. It's not immediately clear from the logs how those settings have impacted the behavior, because the output still prints <code>Building packagename==x.y.z</code> for ~5 packages in a row. Looking at the code in <code>uv-distribution/src/source/mod.rs</code> it seems like the <code>on_build_start</code> events (which write the log) are fired before the tasks are created rather than when they start work (in <code>uv-dispatch/src/lib.rs:direct_build</code>), so seems like the <code>Building packagename</code> log is not as useful as the <code>Built packagename==x.y.z</code> log that happens <code>on_build_complete</code>. Previous to the change we were getting a couple of <code>Built packagename==x.y.z</code> logs emitted right up against one another, but now there are usually more <code>Downloading</code> logs in between, so that does imply that the concurrency is spacing the tasks out a bit better, although with async processing we'll need a bunch more builds to confirm.</p>
<p>I'll let you know if we see another OOM with the new setting. Thanks for the quick response and additional context!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alisonatwork">@alisonatwork</a> on 2025-08-29 04:05</div>
            <div class="timeline-body"><p>Just to follow up on this: in the last 10 days we continued to see OOMs during the initial download/build phase of <code>uv pip install</code> in 10-20% of our pipelines. We reduced the UV_CONCURRENT_BUILDS to 1 and the OOMs are still happening. Next attempt is to leave the concurrent builds at 1 and try reducing UV_CONCURRENT_DOWNLOADS to 20. I hope our experience doesn't echo that of @BugsBuggy who even with everything set to 1 still got OOMKilled.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-08-29 08:28</div>
            <div class="timeline-body"><p>If you turn on verbose mode (<code>-v</code> or even <code>-vv</code>) can you see any patterns whether there's a specific package/command involved? Are you building any particularly large packages?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/shg-rtx">@shg-rtx</a> on 2025-10-24 07:28</div>
            <div class="timeline-body"><p>I initially ran into the OOM issue while running in WSL but it seemed like my WSL install was broken, after a complete reinstall it worked again. I was able to reproduce it with the following commands:</p>
<pre><code>uv init --bare 
uv add numpy==1.26.4
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alisonatwork">@alisonatwork</a> on 2025-11-11 09:32</div>
            <div class="timeline-body"><p>Another update on this: since our last configuration change, we have not seen this issue again. So what finally worked for our project was:</p>
<pre><code>UV_CONCURRENT_BUILDS=1
UV_CONCURRENT_DOWNLOADS=20
</code></pre>
<p>That said, we always build with the latest and greatest version of <code>uv</code>, so it's also possible that sometime in the versions &gt;= 0.8.14 things have improved with regard to memory usage.</p>
<p>I don't have a lot more information to go on at this point, and we don't really have bandwidth to set up a dedicated load test which keep hammering installs with verbose logging turned on to see if there is a pattern to when it fails. But in general it does seem like an issue of &quot;bad luck&quot; during concurrent downloads and builds, perhaps combined with resource constraints on the k8s cluster causing nodes to more aggressively OOM kill.</p>
<p>I still feel like the system itself should keep a better check on how much memory it is using and not depend on the user to randomly change concurrency settings around and hope for the best, but I'm not sure if that's easily possible in Rust. Maybe a safer option would be to pick less aggressive defaults - at least when it detects it's running in a containerized environment - since from the user side it still seems to run installs acceptably fast. I would say it's less annoying for someone to set up a CI pipeline which has slow builds that can be sped up by adjusting the concurrency than for them to have out-of-the-box fast builds that randomly fail.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-11-12 18:06</div>
            <div class="timeline-body"><p>If the builds are the issue, it seems ~impossible for us to account for that. We're building arbitrary third-party packages, they can choose to use as much memory as they want at any given moment, unfortunately.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:30:39 UTC
    </footer>
</body>
</html>
