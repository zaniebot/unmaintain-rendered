<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`uv` as a system Python provider - astral-sh/uv #13507</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>uv</code> as a system Python provider</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/issues/13507">#13507</a>
        opened by <a href="https://github.com/Andrej730">@Andrej730</a>
        on 2025-05-17 12:52
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Andrej730">@Andrej730</a></div>
            <div class="timeline-body">Question
<p>Is it possible to use <code>uv</code> to provide globally available (<em>system</em>?) python? Or it&#x27;s out of scope for <code>uv</code> (e.g. <code>uv</code> is focused on project package management <em>only</em>) and I should install Python from elsewhere?</p>
<p>I mean I can use  <code>uv python install 3.11 --preview</code> to make it globally available as <code>python3.11</code> (or even <code>--default</code> for <code>python</code>), but it&#x27;s not very useful as global Python as <code>uv pip install</code> works only for venvs.</p>
<p>To understand my pov - I wanted to try to switch to <code>uv</code> completely, but most of the scripts on the system are using simple <code>python xxx.py</code> to run, so they do need system installed dependencies and since <code>uv pip install xxx --system</code> won&#x27;t work on <code>uv python install</code> installations as they&#x27;re <em>managed</em>. And it seems the only way to make it work is to have two Python instances of the same version installed (one from <code>uv</code>, one from elsewhere).</p>
<p>If it would be possible, it would help users transition to <code>uv</code> more seamlessly.</p>
Platform
<p>Windows 11</p>
Version
<p>uv 0.7.5 (9d1a14e1f 2025-05-16)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/Andrej730">@Andrej730</a> on 2025-05-17 12:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/eegli">@eegli</a> on 2025-05-18 15:27</div>
            <div class="timeline-body"><p>If you really need a &quot;system-wide&quot; like environment and cannot use inline dependencies in scripts, is there anything that goes against creating a dedicated virtual environment somewhere and then using this globally? One could activate the virtual env on shell startup and make the &quot;system&quot; python available in the path.</p>
<pre><code># initial setup, needs to be run once
mkdir uv-global &amp;&amp; cd uv-global
uv venv --python 3.13

# adjust shell and paths for Windows if needed
echo &quot;export PATH=\&quot;$(realpath .venv/bin):\$PATH\&quot;&quot; &gt;&gt; ~/.bashrc
echo &quot;source \&quot;$(realpath .venv/bin/activate)\&quot;&quot; &gt;&gt; ~/.bashrc

# initialize
source ~/.bashrc
</code></pre>
<p>For managing packages, you&#x27;ll have to cd to <code>uv-global</code> and do <code>uv pip install xyz</code>:</p>
<pre><code>cd uv-global
uv pip install polars
</code></pre>
<p>Finally, your new global env should be good to go:</p>
<p><code>python -c &quot;import polars; print(polars.__version__)&quot;</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2025-05-19 07:54</div>
            <div class="timeline-body"><p>For your use case, there is inline script metadata and <code>uv run script.py</code>, which will install the dependencies with your script. We intentionally avoid having a single big global environment with packages for multiple scripts and instead support per-script isolated environments and tool installations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Andrej730">@Andrej730</a> on 2025-05-19 19:32</div>
            <div class="timeline-body"><blockquote>
<p>For your use case, there is inline script metadata and <code>uv run script.py</code>, which will install the dependencies with your script. We intentionally avoid having a single big global environment with packages for multiple scripts and instead support per-script isolated environments and tool installations.</p>
</blockquote>
<p>I understand, but the transition to this workflow is hard and sometimes is not very reasonable.</p>
<blockquote>
<p>If you really need a &quot;system-wide&quot; like environment and cannot use inline dependencies in scripts, is there anything that goes against creating a dedicated virtual environment somewhere and then using this globally? One could activate the virtual env on shell startup and make the &quot;system&quot; python available in the path.</p>
</blockquote>
<p>That&#x27;s an interesting approach, it&#x27;s cleaner then <code>uv pip install xxxx --system --break-system-packages</code> I&#x27;ve currently taken for global dependencies.</p>
<p>Not sure how reliable this would be on Unix, but on Windows it&#x27;s very hard to convince system to always activate venv before anything it does. So I&#x27;ve taken a different approach -  I&#x27;ve created &quot;system venv&quot;, then added &#x27;systemvenv.pth&#x27; file with contents &#x27;L:\Software\uv\systemvenv.venv\Lib\site-packages&#x27; to my system python&#x27;s folder &#x27;cpython-3.11.12-windows-x86_64-none\Lib\site-packages. At first I thought about referencing this venv site-packages in <code>PYTHONPATH</code>, but that may conflict with other Python instances at some point,</p>
<p>And I&#x27;ve also defined <code>pip.bat</code> as a shim for using <code>pip</code>:</p>
<pre><code>uv pip %* --directory L:\Software\uv\systemvenv
</code></pre>
<p>So I can use <code>pip install xxx</code> / <code>pip uninstall xxx</code> to access &quot;system&quot; environment.</p>
<p>The one caveat I&#x27;ve currently met that I cannot use <code>pip install -r pyproject.toml</code> anymore, since <code>--directory L:\Software\uv\systemvenv</code> basically does <code>cd L:\Software\uv\systemvenv</code> before command execution, so it&#x27;s looking for &#x27;pyproject.toml&#x27; in &#x27;L:\Software\uv\systemvenv&#x27;. The workaround is to provide absolute path <code>pip install -r L:\xxx\yyy\pyproject.toml</code>.</p>
<p>I&#x27;ve tried to use <code>--project</code> like below, but I guess because of the presense of pyproject.toml it starts to looking for venv in the current directory, so <code>--directory</code> is the best option for now for this shim.</p>
<pre><code>:: error: No virtual environment found; run `uv venv` to create an environment, or pass `--system` to install into a non-virtual environment
uv pip install -r pyproject.toml --project L:\Software\uv\systemvenv
</code></pre>
<p>Update. A note for anyone stumbling upon this, <code>.pth</code> can significantly slowdown Python startup time and adding <code>L:\Software\uv\systemvenv\.venv\Scripts</code> to PATH turned to to work much better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-05-20 13:28</div>
            <div class="timeline-body"><p>Yeah, it is intentional that we don&#x27;t support using these as system Pythons.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-05-20 13:28</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:38:41 UTC
    </footer>
</body>
</html>
