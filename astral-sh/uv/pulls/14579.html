<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement an auto-import proof-of-concept - astral-sh/uv #14579</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement an auto-import proof-of-concept</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/pull/14579">#14579</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2025-07-12 18:58
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>I don't know if this will ship but I wanted to try it. You can now run <code>uv add --script /path/to/script.py --auto</code> to automatically populate the PEP 723 tag with the inferred script dependencies.</p>
<p>For now, this uses the module name-to-package name mapping provided by <a href="https://github.com/bndr/pipreqs/blob/2ac9e731c69dee31470cccd23c6b503a4a161778/pipreqs/mapping">pipreqs</a> since it was the simplest thing to prototype, but I think it's plausible that there are more robust mappings out there. For example:</p>
<ul>
<li>Replit ships a generated mapping in <a href="https://github.com/replit/upm/blob/main/internal/backends/python/pkgs.json">UPM</a> which also includes download counts.</li>
<li>Marimo ships one <a href="https://github.com/marimo-team/marimo/blob/7c5cd6fc2701186c45fcc4b4c4f4536ada14ea8f/marimo/_runtime/packages/module_name_to_pypi_name.py#L7">here</a>.</li>
<li>The Conda ecosystem has something <a href="https://github.com/regro/cf-graph-countyfair/blob/33709efce8b81e349202b607859ed73bc206afda/mappings/pypi/name_mapping.json">here</a> that's also generated, but it's partly focused on mapping Conda to PyPI names (and it omits <code>sklearn</code>, perhaps as a result?).</li>
</ul>
<p>We could also generate our own, or provide our own server to perform this resolution.</p>
<p>The other major consideration here is that pulling in the Ruff parser does add some weight to the binary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">no-build</span> added by @charliermarsh on 2025-07-12 18:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">no-test</span> added by @charliermarsh on 2025-07-12 18:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-07-12 23:08</div>
            <div class="timeline-body"><p>I believe this adds ~1.4MB to the release binary before compression:</p>
<pre><code>❯ du main
71328	main

❯ du auto-import
74264	auto-import
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/geofft">@geofft</a> on 2025-07-13 03:41</div>
            <div class="timeline-body"><p>Weird idea: what if this is part of Ruff instead of uv? I would guess that this uses more code from Ruff than from uv. I think all you need out of uv is the ability to parse existing requirements in pyproject.toml format to determine if there's already a requirement that provides the dependency you want, which shouldn't require very much parsing since you don't actually need to make sense of any version constraints or markers that you see, and and the ability to edit TOML. You don't actually need any packaging/environment stuff beyond what's being vendored from pipreqs, I think.</p>
<p>And conceptually this could be a <code>ruff check --fix --select RUFnnn</code>. (Bonus points if astral-sh/ruff#10457 happens and one thing that the RUFnnn fix can do is add itself to the inline metadata block if not present. :) )</p>
<p>One argument is that the way it edits a file seems a little more like what I expect out of Ruff than out of uv. While <code>uv add --script</code> exists, it's pretty straightforward and deterministic about what it does. For tools like Ruff and Black where they might surprise me, I'm used to using <code>--diff</code> etc. confirm what they do. Ruff already has those options and uv does not. Also you can roll this into <code>ruff check --watch</code> and the LSP to automatically add the dependency when you add the import statement.</p>
<p>One possible argument for keeping it in uv is that presumably the same logic makes sense for actual pyproject.toml files. (Though it still seems useful to have an LSP in that scenario....) You could also imagine wanting this for interactive Python sessions or notebooks where yo'd actually want to install the package, hm.</p>
<p>Another argument for keeping it in uv: what if you're importing something that's provided by some other PyPI package or a local package, but the import name happens to have a different hit in the database? uv can instantiate the environment and go look at it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/geofft">@geofft</a> on 2025-07-15 19:30</div>
            <div class="timeline-body"><p>Also just wanted to drop a link to the recently-drafted <a href="https://peps.python.org/pep-0794/">PEP 794 – Import Name Metadata</a> which is relevant to this problem space. It adds two core metadata fields, <code>Import-Name</code> for importable names uniquely provided by the dist, and <code>Import-Namespace</code> for importable names that can also be provided by other non-conflicting dists. An example from the PEP:</p>
<pre><code class="language-toml">[project]
import-names = [&quot;azure.mgmt.search&quot;]
import-namespaces = [&quot;azure&quot;, &quot;azure.mgmt&quot;]
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:43:56 UTC
    </footer>
</body>
</html>
