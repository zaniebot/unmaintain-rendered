<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Detect x86_64 microarchitecture variant automatically - astral-sh/uv #9788</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Detect x86_64 microarchitecture variant automatically</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/pull/9788">#9788</a>
        opened by <a href="https://github.com/zanieb">@zanieb</a>
        on 2024-12-10 21:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a></div>
            <div class="timeline-body"><p>e.g., on my test machine</p>
<pre><code>‚ùØ cargo run -- python install 3.12
Installed Python 3.12.8 in 3.65s
 + cpython-3.12.8-linux-x86_64_v3-gnu
</code></pre>
<p>Note this is split into two commits:</p>
<ul>
<li><a href="https://github.com/astral-sh/uv/pull/9788/commits/c0f146cc905a9dc93582c9f03bf9b4eaf3c9f426">c0f146c</a>: which adds detection</li>
<li><a href="https://github.com/astral-sh/uv/pull/9788/commits/5d78bf2fedc8af65327f48be882268acf7d565f0">5d78bf2</a>: which improves behaviors and compatibility between architecture variants</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-10 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a> reviewed on 2024-12-10 21:04</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zanieb">@zanieb</a> on <code>crates/uv-python/src/platform.rs</code>:160 on 2024-12-10 21:04</div>
            <div class="timeline-body"><p>tbh no clue if we should check for all of these or not</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw-gts">@notatallshaw-gts</a> on 2024-12-10 22:13</div>
            <div class="timeline-body"><p>While mostly I would want uv to automatically detect which microarchitecture variant to grab, I have a concern here related to docker images, specifically if uv is used to install Python in the dockerfile, what happens when the build machine and execution machine support different instruction sets?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-10 22:18</div>
            <div class="timeline-body"><blockquote>
<p>I have a concern here related to docker images, specifically if uv is used to install Python in the dockerfile, what happens when the build machine and execution machine support different instruction sets?</p>
</blockquote>
<p>I think it&#x27;s fair to say the build machine will need to be on the same (or an older) microarchitecture than your execution machine. Do you think that&#x27;s unreasonable?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw-gts">@notatallshaw-gts</a> on 2024-12-10 22:20</div>
            <div class="timeline-body"><blockquote>
<p>I think it&#x27;s fair to say the build machine will need to be on the same (or an older) microarchitecture than your execution machine. Do you think that&#x27;s unreasonable?</p>
</blockquote>
<p>Only in the sense it&#x27;s not something I have to think about right now, and without being familiar with this I&#x27;m not sure it would be easy to diagnose when a failure happened?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-10 22:21</div>
            <div class="timeline-body"><blockquote>
<p>Only in the sense it&#x27;s not something I have to think about right now, and without being familiar with this I&#x27;m not sure it would be easy to diagnose when a failure happened?</p>
</blockquote>
<p>Yeah the interpreter would probably just crash at runtime, or, if you use uv as your entry point, it would be &quot;missing&quot;</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/notatallshaw-gts">@notatallshaw-gts</a> on 2024-12-10 22:22</div>
            <div class="timeline-body"><p>Maybe this is already an issue with other tools that are installed into docker images, and it&#x27;s not that common to face, and people who do face this problem are familiar with the symptom and cause. I just never thought about it before now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/danielhollas">@danielhollas</a> on 2024-12-11 13:45</div>
            <div class="timeline-body"><blockquote>
<p>Maybe this is already an issue with other tools that are installed into docker images, and it&#x27;s not that common to face, and people who do face this problem are familiar with the symptom and cause. I just never thought about it before now.</p>
</blockquote>
<p>I don&#x27;t think this is a common issue right now, and you raised a very valid concern. For pre-built binary artifacts, for example most Linux distros AFAIK use conservative microarchitecture and don&#x27;t do any runtime detection.</p>
<p>There has been some discussion about this in Fedora but the proposal to bump microarchutecture has been withdrawn?</p>
<p>https://discussion.fedoraproject.org/t/will-future-releases-require-x86-64-v3/131200/6</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drmikehenry">@drmikehenry</a> on 2024-12-28 12:06</div>
            <div class="timeline-body"><p>Assuming this feature is eventually implemented, it would be helpful to have a way to disable CPU microarchitecture detection to retain the current behavior that v1 is used by default.  This would make it possible for folks who are mirroring <code>python-build-standalone</code> to continue to mirror only the v1 binaries rather than the whole set of microarchitectures, reducing both space and time requirements for mirroring.  Developers might also prefer to use the same Python executables across an entire team for consistency.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-12-28 17:18</div>
            <div class="timeline-body"><p>@drmikehenry thanks for the feedback!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/uwu-420">@uwu-420</a> reviewed on 2025-03-01 18:25</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/uwu-420">@uwu-420</a> on <code>crates/uv-python/src/platform.rs</code>:160 on 2025-03-01 18:25</div>
            <div class="timeline-body"><p>All those checks are necessary I think.</p>
<p>I&#x27;d even go further and do it similar to https://github.com/HenrikBengtsson/x86-64-level (fyi, it takes the values from <code>/proc/cpuinfo</code> so the names slightly differ)</p>
<pre><code>determine_cpu_version() {
    ## x86-64-v0 (can this happen?)
    level=0
    
    ## x86-64-v1
    has_cpu_flags lm cmov cx8 fpu fxsr mmx syscall sse2 || return 0
    level=1

    ## x86-64-v2
    has_cpu_flags cx16 lahf_lm popcnt sse4_1 sse4_2 ssse3 || return 0
    level=2
    
    ## x86-64-v3
    has_cpu_flags avx avx2 bmi1 bmi2 f16c fma abm movbe xsave || return 0
    level=3

    ## x86-64-v4
    has_cpu_flags avx512f avx512bw avx512cd avx512dq avx512vl || return 0
    level=4
}
</code></pre>
<p>I think going bottom-up like this is more robust although not really necessary in practice I guess. A CPU supporting AVX512 will support AVX2 üòÉ Unless someone is running uv in a crazy emulated environment. Nevertheless, it could be a good idea to comment that each level is a superset of the level below and that in practice it&#x27;s okay to check top-down instead of bottom-up.</p>
<p>But that <code>abm</code> feature is confusing me, I couldn&#x27;t find it directly mentioned in these sources</p>
<ul>
<li>https://en.wikipedia.org/wiki/X86-64#Microarchitecture_levels</li>
<li>https://gitlab.com/x86-psABIs/x86-64-ABI/-/blob/master/x86-64-ABI/low-level-sys-info.tex</li>
<li>https://clang.llvm.org/docs/UsersManual.html#x86</li>
</ul>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:49:46 UTC
    </footer>
</body>
</html>
