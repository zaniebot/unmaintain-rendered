<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fix race condition with pyx token refreshing - astral-sh/uv #17483</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Fix race condition with pyx token refreshing</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/pull/17483">#17483</a>
        opened by <a href="https://github.com/zsol">@zsol</a>
        on 2026-01-15 14:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsol">@zsol</a></div>
            <div class="timeline-body">Summary
<p>This PR fixes a race condition when refreshing pyx tokens in uv.</p>
<p>It&#x27;s mostly plagiarized from #17479, but drops the debouncing bits. The logic for refreshing now looks like:</p>
<ol>
<li>if the passed token is fresh enough, return it</li>
<li>acquire a lock</li>
<li>read the token from the cache and use that if <em>that</em>&#x27;s fresh enough (releasing the lock and returning)</li>
<li>do the refresh dance</li>
<li>write back the refreshed token to the cache</li>
<li>release the lock and return the refreshed token</li>
</ol>
Test Plan
<p>Using this script with concurrency=300 no longer produces failures:</p>
<pre><code>#!/usr/bin/env python3
&quot;&quot;&quot;Request pyx auth tokens from uv in concurrent attempts.&quot;&quot;&quot;

import argparse
import asyncio


async def get_auth_token(
    index: int, uv_binary: str
) -&gt; tuple[int, str | None, str | None]:
    &quot;&quot;&quot;Request an auth token from uv.&quot;&quot;&quot;
    proc = await asyncio.create_subprocess_exec(
        uv_binary,
        &quot;auth&quot;,
        &quot;helper&quot;,
        &quot;--preview-features&quot;,
        &quot;auth-helper&quot;,
        &quot;--protocol&quot;,
        &quot;bazel&quot;,
        &quot;get&quot;,
        stdin=asyncio.subprocess.PIPE,
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE,
    )
    input_json = b&#x27;{&quot;uri&quot;: &quot;https://api.pyx.dev/&quot;}&#x27;
    stdout, stderr = await proc.communicate(input=input_json)

    if proc.returncode == 0:
        return (index, stdout.decode().strip(), None)
    else:
        return (index, None, stderr.decode().strip())


async def main(invocations: int, uv_binary: str) -&gt; None:
    &quot;&quot;&quot;Run n concurrent auth token requests.&quot;&quot;&quot;
    print(f&quot;Starting {invocations} concurrent auth token requests...&quot;)

    tasks = [get_auth_token(i, uv_binary) for i in range(invocations)]
    results = await asyncio.gather(*tasks)

    successes = 0
    failures = 0

    for index, token, error in results:
        if token:
            successes += 1
            # Only print first few characters of token for privacy.
            print(f&quot;[{index:3d}] Success: {token[:5]}...&quot;)
        else:
            failures += 1
            print(f&quot;[{index:3d}] Failed: {error}&quot;)

    print(f&quot;\nResults: {successes} successes, {failures} failures&quot;)


if __name__ == &quot;__main__&quot;:
    parser = argparse.ArgumentParser(
        description=&quot;Request PyX auth tokens from uv in concurrent attempts&quot;
    )
    parser.add_argument(
        &quot;-n&quot;,
        &quot;--invocations&quot;,
        type=int,
        default=100,
        help=&quot;Number of concurrent requests (default: 100)&quot;,
    )
    parser.add_argument(
        &quot;--uv&quot;,
        default=&quot;uv&quot;,
        help=&quot;Path to uv binary (default: uv)&quot;,
    )
    args = parser.parse_args()
    asyncio.run(main(args.invocations, args.uv))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Help rustfmt a little (#17004)&quot; to &quot;Fix race condition with pyx token refreshing&quot; by <a href="https://github.com/zsol">@zsol</a> on 2026-01-15 14:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsol">@zsol</a> reviewed on 2026-01-15 14:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsol">@zsol</a> on <code>crates/uv-auth/src/pyx.rs</code>:466 on 2026-01-15 14:44</div>
            <div class="timeline-body"><p>This seems a bit weird. We&#x27;re only locking for a specific token, but <code>read()</code> can read &quot;outside of the scope&quot; of that lock. Should we just lock the entire subdirectory?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/zsol">@zsol</a> on 2026-01-15 16:43</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:55:15 UTC
    </footer>
</body>
</html>
