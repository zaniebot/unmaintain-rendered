<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merge identical forks - astral-sh/uv #5405</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Merge identical forks</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/uv/pull/5405">#5405</a>
        opened by <a href="https://github.com/konstin">@konstin</a>
        on 2024-07-24 12:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a></div>
            <div class="timeline-body"><p>Consider these requirements from pylint 3.2.5:</p>
<pre><code>Requires-Dist: dill &gt;=0.3.6 ; python_version &gt;= &quot;3.11&quot;
Requires-Dist: dill &gt;=0.3.7 ; python_version &gt;= &quot;3.12&quot;
</code></pre>
<p>We will split on the python version, but then we may pick a version of <code>dill</code> that&#x27;s <code>&gt;=0.3.7</code> in both branches and also have an otherwise identical resolution in both forks. In this case, we merge both forks and store only their conjoined markers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">preview</span> added by <a href="https://github.com/konstin">@konstin</a> on 2024-07-24 12:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/BurntSushi">@BurntSushi</a> by <a href="https://github.com/konstin">@konstin</a> on 2024-07-24 12:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2024-07-24 12:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/uv-resolver/src/resolver/mod.rs</code>:2465 on 2024-07-24 12:16</div>
            <div class="timeline-body"><p>That method gets removed upstack</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/uv-resolver/src/resolver/mod.rs</code>:414 on 2024-07-24 13:13</div>
            <div class="timeline-body"><p>I buy this, but two thoughts come to mind.</p>
<p>Firstly, is it possible for more than one duplicate resolution to exist at any given point in time? If so, this would I believe only find one of them. But, I do not think this is case, since this is run for every resolution before it is &quot;saved.&quot; So it should never be the case that more than one duplicate resolution appears.</p>
<p>Secondly, this is doing an exhaustive search over all existing resolutions to find a possible duplicate. And I suspect that the <code>Resolution::same_graph</code> routine is itself not especially cheap. I think this ends up being quadratic in the number of forks (which are themselves exponential in the number of dependencies I think? or possibly in the depth in the dependency tree). I don&#x27;t have a good feel for how big of an issue that is in practice. Do we have a sense of what the common case is? I would guess the common case is that there aren&#x27;t any duplicates. So perhaps we can optimize for that path. (To be clear, I don&#x27;t mean to suggest that be done in this PR.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> approved on 2024-07-24 13:13</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/konstin">@konstin</a> reviewed on 2024-07-25 09:54</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/konstin">@konstin</a> on <code>crates/uv-resolver/src/resolver/mod.rs</code>:414 on 2024-07-25 09:54</div>
            <div class="timeline-body"><blockquote>
<p>Firstly, is it possible for more than one duplicate resolution to exist at any given point in time? If so, this would I believe only find one of them. But, I do not think this is case, since this is run for every resolution before it is &quot;saved.&quot; So it should never be the case that more than one duplicate resolution appears.</p>
</blockquote>
<p>We fork every time we see conflicting markers, but in many of those cases the requirements themselves are not conflicting (say <code>numpy &gt;= 1.16</code> for one and <code>numpy &gt;= 1.19</code> for the other). When forking, we can&#x27;t yet know whether we&#x27;ll find a compatible <code>numpy</code> for both of. I&#x27;ve also seen cases where we end up rejecting the package version we forked on in both branches, removing the conflicting requirements. By copying over preferences from previous forks, we try to coerce two forks to resolving the same package version. Basically, our strategy is to fork often to avoid failing on avoidable conflicts, but still having a solution with as few divergences as possibles.</p>
<p>Re perf: I agree that this is potentially costly, but i think we have to do this to get desirable resolution. We have some short-cuts that we get from std that makes this cheaper: When two forks have a different number of packages, the check is a single <code>usize</code> comparison. We also usually have a small number of forks (and the more specific a fork is, the more likely it is we skip future fork points because we&#x27;re already more specific), so i see this more as a fixed cost of maybe 10^2/2=50 checks. There are of course pathological cases, for those i think we just have to be a bit slow here avoid redundant forks in the lockfile.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/konstin">@konstin</a> on 2024-07-25 09:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/konstin">@konstin</a> on 2024-07-25 09:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-07-25 09:54</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:46:50 UTC
    </footer>
</body>
</html>
