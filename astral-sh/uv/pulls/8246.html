<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Don't prefetch unreachable packages - astral-sh/uv #8246</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Don't prefetch unreachable packages</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/uv/pull/8246">#8246</a>
        opened by <a href="https://github.com/konstin">@konstin</a>
        on 2024-10-16 09:09
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Pull request opened by <a href="https://github.com/konstin">@konstin</a> on 2024-10-16 09:09</div>
            <div class="timeline-body"><p>When batch prefetching we can fetch versions we know that are incompatible. In the following example, we were prefetching sentry-kafka-schemas below version 1.50.0.</p>
<pre><code>python-rapidjson&lt;=1.20,&gt;=1.4
sentry-kafka-schemas&lt;=0.1.113,&gt;=0.1.50
</code></pre>
<p>Using a new pubgrub interface from https://github.com/astral-sh/pubgrub/pull/32, we can avoid those prefetches by asking for incompatibilities that won't change anymore (those with root).</p>
<p>main:</p>
<p><img src="https://github.com/user-attachments/assets/c8475069-856e-4072-a688-0bb426e32160" alt="image" /></p>
<p>branch:</p>
<p><img src="https://github.com/user-attachments/assets/0b0da8e0-2f09-4137-a2c9-2af0cd706be5" alt="image" /></p>
<p>For the tested case, the performance impact was negligible.</p>
<p>Draft since it depends on #8245 and then another pubgrub update.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">enhancement</span> added by @konstin on 2024-10-16 09:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">resolver</span> added by @konstin on 2024-10-16 09:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-10-16 12:20</div>
            <div class="timeline-body"><p>Wow, that's amazing!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-10-16 12:20</div>
            <div class="timeline-body"><p>We might need to check... two levels. Because in the context of a workspace, the root depends on the members, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-10-16 12:30</div>
            <div class="timeline-body"><p>That's why we're asking pubgrub instead of using the uv logic: If we have <code>root -&gt; workspace_member</code> and <code>workspace_member -&gt; foo&gt;=1.50</code>, then pubgrub should be able to infer a derivation <code>root -&gt; foo&gt;=1.50</code>, or put differently, see that <code>foo&gt;=1.50</code> is still at decision level 1. Theoretically, this should be able to even infer bounds for non-workspace transitive dependencies.</p>
<p>I haven't tested through the details, but I still want to go ahead since it solves my real world test case and the pubgrub derivations are the right place to improve if we find more complex cases later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @konstin on 2024-10-17 09:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @charliermarsh by @konstin on 2024-10-17 09:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mpizenberg">@mpizenberg</a> on 2024-10-17 12:00</div>
            <div class="timeline-body"><p>Indeed, any incompatibility with a single solution could be transitively added to the set of unchangable facts.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a> approved on 2024-10-17 13:35</div>
            <div class="timeline-body"><p>Cool!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @zanieb on 2024-10-17 13:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by @konstin on 2024-10-18 11:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @konstin on 2024-10-18 11:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-10-18 11:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Eh2406">@Eh2406</a> on 2024-10-21 22:00</div>
            <div class="timeline-body"><p>PubGrub theoretically could do either optimization discussed here. But I doubt that in practice it does. (Well, not until backtracking hits forcing some generalizations.)</p>
<p>I suspect that it will start out with a chain:</p>
<ul>
<li>decision level 0: <code>Root</code> is needed</li>
<li>decision level 1: <code>Root</code> need <code>workspace_member</code></li>
<li>decision level 2: <code>workspace_member</code> needs <code>bar</code></li>
</ul>
<p>Making the information about <code>bar</code> unavailable for this optimization. In some sense PubGrub is correct, perhaps there is a different version of <code>workspace_member</code> that doesn't depend on <code>bar</code>.</p>
<p>If this becomes a problem I can see 2 directions for solving it:</p>
<ul>
<li>Teach PubGrub to identify singleton requirements. When a singleton is identified, selecting a version for that requirement does not bump the decision level. Alternatively, load in the dependencies for that version before &quot;activating&quot; the version. This should squash it all into dependency level 0.</li>
<li>In your solver loop keep track of the decision level when the first non-workspace_member was activated. Next change <code>unchanging_term_for_package</code> to be more like <code>term_for_package_as_of(&amp;P, decision level)</code>, so that you can provide your own decision level that represents <code>unchanging</code> given your external knowledge.</li>
</ul>
<p>Mostly leaving notes here while it's fresh in my mind, so that if there's a problem in the future we remember what the next steps are.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/konstin">@konstin</a> on 2024-10-22 11:02</div>
            <div class="timeline-body"><blockquote>
<p>Teach PubGrub to identify singleton requirements.</p>
</blockquote>
<p>This would be great, because we have two kinds of singleton requirements, URL requirements and <code>==</code> requirements, with which we can shortcut package and version selection in pubgrub.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 13:02:01 UTC
    </footer>
</body>
</html>
