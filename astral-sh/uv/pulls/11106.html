<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Use docker cache mounts for apt, pip and cargo - astral-sh/uv #11106</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Use docker cache mounts for apt, pip and cargo</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/pull/11106">#11106</a>
        opened by <a href="https://github.com/mjpieters">@mjpieters</a>
        on 2025-01-30 18:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mjpieters">@mjpieters</a></div>
            <div class="timeline-body"><p>The cache mounts are cached using standard github actions cache when building in the CI pipeline.</p>
<p>Note that the build stage no longer contains the whole source tree, these are instead mounted into the build container when building to avoid invalidating cached build container layers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mjpieters">@mjpieters</a> on <code>.github/workflows/build-docker.yml</code>:43 on 2025-01-30 18:06</div>
            <div class="timeline-body"><p>Same as for #8685, inserted to unblock running this job in my PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mjpieters">@mjpieters</a> reviewed on 2025-01-30 18:06</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @mjpieters on 2025-01-30 18:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-01-30 18:38</div>
            <div class="timeline-body"><p>Is this just for Docker image build performance?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-01-30 18:39</div>
            <div class="timeline-body"><p>See also, previous discussion at https://github.com/astral-sh/uv/pull/3372</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mjpieters">@mjpieters</a> on <code>.github/workflows/build-docker.yml</code>:103 on 2025-01-30 18:43</div>
            <div class="timeline-body"><p>You <em>could</em> drop the crates directory from the hash key and so reuse the cargo cache even when source code files change. This would give you incremental builds.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mjpieters">@mjpieters</a> reviewed on 2025-01-30 18:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a> reviewed on 2025-01-30 18:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zanieb">@zanieb</a> on <code>.github/workflows/build-docker.yml</code>:103 on 2025-01-30 18:52</div>
            <div class="timeline-body"><p>I'm not sure we <em>want</em> incremental builds in the release pipeline. A clean build seems like a good property, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mjpieters">@mjpieters</a> on 2025-01-30 18:57</div>
            <div class="timeline-body"><blockquote>
<p>Is this just for Docker image build performance?</p>
</blockquote>
<p>Yes, both locally and CI workflows. I had completely missed the other PR ü§¶ so thanks for the reference! I'll review the discussion and see if this needs closing or updating or if I change the merge target to that PR.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-01-30 18:59</div>
            <div class="timeline-body"><p>I think that one might have been a little more aggressive about refactoring. I'm more liable to just accept cache mounts. The big caveat there is probably captured by https://github.com/astral-sh/uv/pull/3372#issuecomment-2116475873 with the notable update that we're now using Depot runners in our org! So... we could set up Depot for Docker builds.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mjpieters">@mjpieters</a> on 2025-01-30 19:22</div>
            <div class="timeline-body"><p>Yeah, the author of that pr clearly has a lot of rust-in-docker build knowledge, more than I have.</p>
<p>Bottom line is that this PR makes an incremental change with the aim of improving build time here in the GH pipeline. If you are moving the build to a different platform however then there is not much value in merging this one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/mjpieters">@mjpieters</a> reviewed on 2025-01-30 19:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/mjpieters">@mjpieters</a> on <code>.github/workflows/build-docker.yml</code>:103 on 2025-01-30 19:35</div>
            <div class="timeline-body"><p>That's why I picked this config, but I just wanted to point out the option.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-01-31 03:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>Dockerfile</code>:1 on 2025-01-31 03:18</div>
            <div class="timeline-body"><p>~~Note, I would see https://github.com/astral-sh/uv/pull/3372 for context as to why some of these changes haven't been done.~~</p>
<p>(edit: woops, hadn't seen this was already mentioned https://github.com/astral-sh/uv/pull/11106#issuecomment-2625288136)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mjpieters">@mjpieters</a> on 2025-01-31 11:28</div>
            <div class="timeline-body"><p>Heads-up: something is wrong with the way the key for the cargo cache is being calculated; when I update the head sha of my PR (<code>git commit --amend --no-edit &amp;&amp; git push --force</code>) to trigger a rebuild, the cache key has changed from the previous build, which means that <code>hashFiles('Dockerfile', 'crates/**', 'Cargo.toml', 'Cargo.lock')</code> picks up run-unique files that should not be there.</p>
<p>I'll have to debug this and so there will be a few temporary changes to figure out what is going on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mjpieters">@mjpieters</a> on 2025-01-31 12:46</div>
            <div class="timeline-body"><blockquote>
<p>Heads-up: something is wrong with the way the key for the cargo cache is being calculated; when I update the head sha of my PR (<code>git commit --amend --no-edit &amp;&amp; git push --force</code>) to trigger a rebuild, the cache key has changed from the previous build, which means that <code>hashFiles('Dockerfile', 'crates/**', 'Cargo.toml', 'Cargo.lock')</code> picks up run-unique files that should not be there.</p>
<p>I'll have to debug this and so there will be a few temporary changes to figure out what is going on.</p>
</blockquote>
<p>Never mind, it was just me jumping to conclusions. Every time I've triggered a new build there have been new commits on main and the since PR workflows run against a merge commit <code>crates/**</code> really has changed since the last run. ü§¶</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mjpieters">@mjpieters</a> on 2025-01-31 15:52</div>
            <div class="timeline-body"><p>I've now refactored the cache mounts to be simpler and (hopefully) more effective in the Github pipeline</p>
<p>All in-docker build tool caches now live in a single <code>/buildkit-cache</code> directory. This includes the global caches for cargo, rustup, pip, zig and cargo-zigbuild. This is keyed <em>just</em> on the Dockerfile hash, because these can trivially be re-used even if the Cargo.lock file changes.</p>
<p>The <code>/root/target</code> cache mount is no longer cached or restored in the GitHub pipeline, but it is still hugely helpful when building the docker container locally as it massively speeds up incremental builds in that case. Propagating the cache to the Github action cache was not effective however because when you have the exact same Cargo.lock, Cargo.toml and <code>crates</code> file tree then Github has also cached that specific Docker layer already, meaning that the whole build step is cached.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mjpieters">@mjpieters</a> on 2025-01-31 22:16</div>
            <div class="timeline-body"><p>I forced a push and this does make the build faster, by about 90-120 seconds. Compare the times for the latest release:</p>
<ul>
<li><p>release:</p>
<ul>
<li><a href="https://github.com/astral-sh/uv/actions/runs/13061715804/job/36446006635">amd64 build</a>: 12m 38s</li>
<li><a href="https://github.com/astral-sh/uv/actions/runs/13061715804/job/36446007253">arm64 build</a>: 13m 57s</li>
</ul>
</li>
<li><p>this PR:</p>
<ul>
<li><a href="https://github.com/astral-sh/uv/actions/runs/13081435856/job/36505668471">amd64 build</a>: 11m 4s (Œî 1m 34s faster)</li>
<li><a href="https://github.com/astral-sh/uv/actions/runs/13081435856/job/36505668726">arm64 build</a>: 11m 50s (Œî 2m 7s faster)</li>
</ul>
</li>
</ul>
<p>I've since pushed another small update to add a <code>rustup self update</code> to use the cached version of rustup when available, instead of re-downloading and having to silence rustup from complaining about the cached cargo and rust toolchain.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:50 on 2025-04-29 00:01</div>
            <div class="timeline-body"><p>Since no toolchain is installed at this point, the <code>--target</code> option seems redundant?</p>
<pre><code>bash: rustup: command not found
info: downloading installer
info: profile set to 'minimal'
info: default host triple is x86_64-unknown-linux-gnu
info: skipping toolchain installation
warn: ignoring requested target: x86_64-unknown-linux-musl
</code></pre>
<p>Also, due to the copied <code>rust-toolchain.toml</code>, <code>--profile minimal</code> is ignored too. You could patch it <a href="https://github.com/astral-sh/uv/pull/3372/files#r1590191580">like I did in my PR</a> since we don't need the extra components that'd otherwise be brought in (<em><code>share/doc/rust/html</code> is 600MB for example</em>). Granted this is going into a cache mount for you, it's less noticeable but contributes towards CI cache storage?</p>
<hr />
<p>Given that you're using the same <code>tool-caches</code> and the image uses a <code>FROM</code> with platform constraint tied to the native build host arch rather than the target, you might as well keep the shared layers between <code>TARGETPLATFORM</code> images the same here? (<em><strong>EDIT:</strong> I just noticed compared to my PR your rust toolchain is stored in a cache mount, thus layer sharing won't improve much here</em>)</p>
<p>To do that, shift the earlier <code>ARG TARGETPLATFORM</code> block below this rustup one, and explicitly install both musl AMD64 + ARM64 targets. In fact, since the only usage for <code>TARGETPLATFORM</code> will be in that final <code>RUN</code>, you can completely avoid <code>rust_target.txt</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:64 on 2025-04-29 00:17</div>
            <div class="timeline-body"><p>Adjusted <code>RUN</code> content that makes the earlier <code>ARG TARGETPLATFORM</code> block redundant (<em>so ARM64 + AMD64 builds only diverge common image layers at this point of the build instead</em>).</p>
<pre><code class="language-Dockerfile">ARG TARGETPLATFORM
RUN \
  # Use bind mounts to access Cargo config, lock, and sources; without needing to
  # copy them into a build layer (avoids bloating the docker build layer cache):
  --mount=type=bind,source=crates,target=crates \
  --mount=type=bind,source=Cargo.toml,target=Cargo.toml \
  --mount=type=bind,source=Cargo.lock,target=Cargo.lock \
  # Add cache mounts to speed up builds:
  --mount=type=cache,target=${HOME}/target/ \
  --mount=type=cache,target=/buildkit-cache,id=&quot;tool-caches&quot; \
  &lt;&lt;HEREDOC
  # Handle platform differences like mapping target arch to naming convention used by cargo targets:
  # https://en.wikipedia.org/wiki/X86-64#Industry_naming_conventions
  case &quot;${TARGETPLATFORM}&quot; in
    ( 'linux/amd64' )
      export CARGO_BUILD_TARGET='x86_64-unknown-linux-musl'
      ;;
    ( 'linux/arm64' )
      export CARGO_BUILD_TARGET='aarch64-unknown-linux-musl'
      export JEMALLOC_SYS_WITH_LG_PAGE=16
      ;;
    ( * )
      echo &quot;ERROR: Unsupported target platform: '${TARGETPLATFORM}'&quot;
      return 1
      ;;
  esac

  cargo zigbuild --release --bin uv --bin uvx --target &quot;${CARGO_BUILD_TARGET}&quot;
  cp &quot;target/${CARGO_BUILD_TARGET}/release/uv&quot; /uv
  cp &quot;target/${CARGO_BUILD_TARGET}/release/uvx&quot; /uvx
HEREDOC
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:44 on 2025-04-29 04:43</div>
            <div class="timeline-body"><p>This <code>RUN</code> does not play well with concurrent writers when that <code>tool-caches</code> cache mount is used. Causing builds to fail:</p>
<pre><code>1.499 info: downloading component 'cargo'
1.790 error: component download failed for cargo-x86_64-unknown-linux-gnu: could not rename downloaded file from '/buildkit-cache/rustup/downloads/c5c1590f7e9246ad9f4f97cfe26ffa92707b52a769726596a9ef81565ebd908b.partial' to '/buildkit-cache/rustup/downloads/c5c1590f7e9246ad9f4f97cfe26ffa92707b52a769726596a9ef81565ebd908b': No such file or directory (os error 2)
</code></pre>
<p>While cargo might manage lock files to avoid this type of scenario, you need to be mindful of cache mount usage when it's not compatible with the default <code>sharing=shared</code> mount option.</p>
<pre><code class="language-bash"># When using a Buildx container driver:
docker buildx create --name=container --driver=docker-container --use --bootstrap

# You can now build for multiple platforms concurrently:
docker buildx build --builder=container --platform=linux/arm64,linux/amd64 --tag localhost/uv .
</code></pre>
<p>To prevent this problem use <code>sharing=locked</code> to block another build from writing to the same cache mount id. That or running two separate build commands to build one platform at a time.</p>
<hr />
<p>While on the topic of cache mounts. It's a non-issue for CI of a project where you only build a single <code>Dockerfile</code> your project maintains.</p>
<p>However on user systems, AFAIK if that <code>id</code> is used in another project <code>Dockerfile</code>, it also shares that cache. Sometimes that's a non-issue, but be mindful of accidentally mixing/sharing with other projects that shouldn't share a cache mount due to concerns like invalidating each others storage, or like seen here conflicting write access, or with <code>sharing=locked</code> blocking a build of another project.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:44 on 2025-04-29 05:57</div>
            <div class="timeline-body"><pre><code class="language-suggestion">RUN \
  --mount=type=cache,target=/buildkit-cache,id=&quot;tool-caches&quot;,sharing=locked \
</code></pre>
<p><strong>EDIT:</strong> As per feedback in the next comment, I'm really not sure about the toolchain being stored in a cache mount as a good idea? Rather then apply this fix it may be better to just avoid the cache mount entirely (<em>you'd then have the ability to build the <code>build</code> stage and shell into it to troubleshoot building if need be too, actually maybe not due to <code>CARGO_HOME</code> if you need zigbuild</em>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:50 on 2025-04-29 05:58</div>
            <div class="timeline-body"><pre><code class="language-suggestion">  &lt;&lt;HEREDOC
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --profile minimal -- default-toolchain none

  echo 'targets = [ &quot;aarch64-unknown-linux-musl&quot;, &quot;x86_64-unknown-linux-musl&quot; ]' &gt;&gt; rust-toolchain.toml
  rustup toolchain install
HEREDOC
</code></pre>
<hr />
<p><strong>NOTE:</strong> In my older PR I also set <code>profile</code> to <code>minimal</code> as well:</p>
<pre><code>echo 'profile = &quot;minimal&quot;' &gt;&gt; rust-toolchain.toml
</code></pre>
<p>This is required if you run another <code>rustup</code> command like <code>rustup target add</code>, but with the newer <code>rustup toolchain install</code> command, it actually respects the <code>--profile minimal</code> originally set as a fallback.</p>
<p><code>rustup toolchain install</code> is <a href="https://github.com/rust-lang/rustup/pull/3983#issuecomment-2275736111">intended to be the proper approach</a> (<em><a href="https://blog.rust-lang.org/2025/03/02/Rustup-1.28.0/">requires Rustup 1.28.0+</a>, released in March 2025</em>) to installing the toolchain from <code>rust-toolchain.toml</code>, rather than implicitly installing when using other rustup commands. So this should help justify preferring the switch üëç</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:44 on 2025-04-29 06:42</div>
            <div class="timeline-body"><p>I am not sure about why the rust toolchain is stored in a cache mount, while Zig and other toolchains are left in the image layers? To pair an update of <code>rust-toolchain.toml</code> bumping the toolchain to trigger <code>rustup self update</code>?</p>
<p>The <code>COPY</code> for <code>rust-toolchain.toml</code> would invalidate the <code>RUN</code> layer, so it would be updated just the same no?</p>
<ul>
<li>I could understand if you were sharing this cache mount with other <code>Dockerfile</code> without common base layer sharing, but if those projects were configured with different toolchains they likewise accumulate in cache storage? (<em>which is more prone to GC than an actively used layer</em>) Cleaning up unused layers is probably preferable, cache should really be used for actual cache (<em>I think it's possible for a cache mount to clear between <code>RUN</code>, not ideal for a toolchain</em>).</li>
<li>The other possibility being for CI image caching and wanting to minimize storage.<ul>
<li>The bulk of your build time with this <code>Dockerfile</code> is with the actual cargo build later on, so pulling from a CI cache blob or from the remote source (rustup, package manager, etc) are not likely to be that much faster. Regardless you're configuring persistence in CI via cache mounts, is that beneficial vs standard caching of image layers?</li>
<li>If you lose CI time to the large cache import/export delays (eg: due to de/compression), it may be faster to just not cache that portion of the image at all and do a clean build of it. Cache only what's helpful.</li>
</ul>
</li>
</ul>
<p>You will however benefit from the cache mount when building multiple targets separately (<em>rather than multiple <code>cargo build</code> in the same <code>RUN</code></em>):</p>
<ul>
<li>This is only because of the earlier <code>ARG TARGETPLATFORM</code> introducing a divergence in layer cache (<em>1.3GB + 1.4GB to support without cache mount but actual diff is approx 200MB only</em>).</li>
<li>Since both targets build from the same build host arch, there's no concern about conflict there with the cache mount either üëç</li>
<li>It should be rare for earlier layer cache invalidation to really matter, but that'd be a win for cache mounts. Personally I prefer the immutable/predictable layer content vs accumulating cache mount that if I'm not mistaken can be cleared during build between layers (<em>as cache is intended to be disposable</em>).</li>
</ul>
<p>That concern is easily fixed as per my suggestion for avoiding divergence at this point. Both targets added are 354MB combined. Total layer weight with minimal profile is 930MB (<em>instead of 1.6GB</em>), be that layer cache or a cache mount.</p>
<hr />
<p><strong>Breakdown:</strong></p>
<pre><code class="language-bash"># Build (without `tool-caches` cache mount):
docker buildx build --builder=container --platform=linux/amd64 --tag localhost/uv --load .

# Inspect:
docker run --rm -it -v /var/run/docker.sock:/var/run/docker.sock ghcr.io/wagoodman/dive:latest localhost/uv
</code></pre>
<p><strong>Sizes (bolded is within a cache mount):</strong></p>
<ul>
<li><strong>1.6GB</strong> (<em>930MB minimal profile</em>) =&gt; Rustup toolchain <code>/buildkit-cache/rustup</code> (<em>also adds 19MB to sibling dir <code>cargo/</code></em>):<ul>
<li><code>lib/rustlib/aarch64-unknown-linux-musl/lib</code> (135MB) / <code>lib/rustlib/x86_64-unknown-linux-musl/lib</code> (219MB)</li>
<li><code>lib/rustlib/x86_64-unknown-linux-gnu/bin</code> (18MB) + <code>lib/rustlib/x86_64-unknown-linux-gnu/lib</code> (158MB)</li>
<li><code>lib/libLLVM.so.19.1-rust-1.86.0-stable</code> (174MB) + <code>lib/librustc_driver-ea2439778c0a32ac.so</code> (141MB)</li>
</ul>
</li>
<li><strong>85MB</strong> =&gt; Pip cache <code>/buildkit-cache/pip/http-v2</code></li>
<li><strong>258MB</strong> =&gt; Apt cache <code>/var/cache/apt</code> (220MB) + <code>/var/lib/apt</code> (48MB)</li>
<li>310MB =&gt; Zig toolchain at <code>/root/.venv/lib/python3.12/site-packages/ziglang</code></li>
<li>527MB =&gt; Base image (78MB) + 13MB (python venv setup) + <code>/usr</code> (<em>base package layer adds 436MB</em>)</li>
</ul>
<p><strong>Image build time:</strong></p>
<p>On a budget VPS (<em>Fedora 42 at Vultr, 1vCPU + 2GB RAM with 3GB more via zram swap</em>):</p>
<ul>
<li><code>apt</code> layer built within 37s</li>
<li><code>cargo-zigbuild</code> install 12s</li>
<li><code>rustup</code> setup 32s</li>
<li><code>cargo</code> release build (x86_64), <strong>2 hours 25 minutes</strong>.</li>
</ul>
<p>The build took excessively long presumably due to single CPU and quite possibly RAM, I didn't investigate that too extensively. Changing from <code>lto=&quot;fat&quot;</code> to <code>lto=&quot;thin&quot;</code> brought that build time down to <strong>43 minutes</strong>, at the expense of being 25% larger (40MB =&gt; 50MB).</p>
<p>You're getting much better results reported for the build, but the bulk of the time is down to the actual build. I'd avoid wasting CI cache store (<em>causing evictions sooner than necessary for cache items that are actually helpful</em>) on the rust toolchain, saving a minute at best is not worth better using the cache to optimize the build time (<em>requires <a href="https://doc.rust-lang.org/cargo/reference/build-cache.html#shared-cache"><code>sccache</code></a> IIRC to be decent but is not without quirks</em>).</p>
<p>That said you can use the cache mounts in CI and not upload/restore them for minimizing the image layers cache, but presently there is very little benefit in caching image layers at all? You could instead just focus on the cache mount(s) for the <code>cargo</code> build itself.</p>
<p>The <code>cargo</code> target cache is 1GB alone when building this project, but <a href="https://github.com/astral-sh/uv/pull/11106#issuecomment-2837804391">as mentioned</a> it's a bit of a hassle to actually leverage for the CI.</p>
<hr />
<h3>After a build</h3>
<p>For reference, the cargo and zig caches are decent in size, but a good portion of the cargo one isn't relevant, nor is the zigbuild cache mount worthwhile?</p>
<pre><code class="language-console"># Cargo:
$ du -shx /buildkit-cache/cargo
298M    /buildkit-cache/cargo
# Bulk is from registry dir:
$ /buildkit-cache/cargo/registry/
217M    /buildkit-cache/cargo/registry/src
33M     /buildkit-cache/cargo/registry/cache
26M     /buildkit-cache/cargo/registry/index
275M    /buildkit-cache/cargo/registry/

# Zig:
du -shx /buildkit-cache/zig
164M    /buildkit-cache/zig

# Zigbuild:
# Nothing worthwhile to cache? (plus it created another folder for itself):
du -shx /buildkit-cache/cargo-zigbuild/cargo-zigbuild/0.20.0
24K     /buildkit-cache/cargo-zigbuild/cargo-zigbuild/0.20.0

# Rustup for reference (before optimization):
$ du -hx --max-depth=1 /buildkit-cache/rustup
4.0K    /buildkit-cache/rustup/tmp
1.5G    /buildkit-cache/rustup/toolchains
8.0K    /buildkit-cache/rustup/update-hashes
4.0K    /buildkit-cache/rustup/downloads
1.5G    /buildkit-cache/rustup
# This was built without minimal profile applied + only x86_64 musl target:
$ du -hx --max-depth=1 /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu
20K     /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu/etc
1.4M    /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu/libexec
728M    /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu/share
73M     /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu/bin
679M    /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu/lib
1.5G    /buildkit-cache/rustup/toolchains/1.86-x86_64-unknown-linux-gnu
</code></pre>
<p>As per <a href="https://github.com/astral-sh/uv/pull/3372/files#r1590189557">my PR attempt</a>, the bulk of the cargo cache mount there is from data that is quick to generate/compute at build time, thus not worth persisting. I used two separate tmpfs cache mounts to filter those out:</p>
<pre><code class="language-Dockerfile">  # These are redundant as they're easily reconstructed from cache above. Use TMPFS mounts to exclude from cache mounts:
  # TMPFS mount is a better choice than `rm -rf` command (which is risky on a cache mount that is shared across concurrent builds).
  --mount=type=tmpfs,target=&quot;${CARGO_HOME}/registry/src&quot; \
  --mount=type=tmpfs,target=&quot;${CARGO_HOME}/git/checkouts&quot; \
</code></pre>
<p>Only relevant if storage of the cache mount is a concern, which it may be for CI limits to keep tame, otherwise is overkill :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/polarathene">@polarathene</a> on <code>Dockerfile</code>:50 on 2025-04-29 07:06</div>
            <div class="timeline-body"><p>Minor improvement from <a href="https://github.com/astral-sh/uv/pull/3372">my rejected PR</a> was to fail early, such as with pipelines with <code>curl ... | sh ...</code>.</p>
<p>You'd add this <code>SHELL</code> instruction at the top of the file:</p>
<pre><code class="language-Dockerfile">FROM --platform=$BUILDPLATFORM ubuntu AS build
# Configure the shell to exit early if any command fails, or when referencing unset variables.
# Additionally `-x` outputs each command run, this is helpful for troubleshooting failures.
SHELL [&quot;/bin/bash&quot;, &quot;-eux&quot;, &quot;-o&quot;, &quot;pipefail&quot;, &quot;-c&quot;]
</code></pre>
<p>I had some build failures when building the image locally, for <code>RUN</code> with multiple chains of commands, <code>+x</code> would have been a bit useful. Took a while for me to realize the issue with <code>rustup</code> I encountered was only reproducible with a cache mount being accessed concurrently üòì</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/polarathene">@polarathene</a> on 2025-04-29 07:36</div>
            <div class="timeline-body"><p>Hello üëã I only just got notified about this alternative PR to mine when mine was rejected üòì</p>
<blockquote>
<p>The <code>/root/target</code> cache mount is no longer cached or restored in the GitHub pipeline, but it is still hugely helpful when building the docker container locally as it massively speeds up incremental builds in that case. Propagating the cache to the Github action cache was not effective</p>
</blockquote>
<p>The target cache last I recall does not work well with CI systems due to cargo relying on mtime for cache invalidation IIRC. Might have been related to source files mtime, so git checkouts (<em>which don't include mtime in commits</em>) would be a mismatch to the target cache each time, preventing cache re-use.</p>
<p>There was talk about that upstream to be handled differently but last I heard this had not changed ü§î (if it has awesome).</p>
<p>So it may only be beneficial to local builds, not for the GHA runners. Any build layer skipping when there is no changes is different, that's due to Docker layer cache, if the inputs haven't changed and there is a cache layer mapping for that it'll be used, otherwise invalidated.</p>
<p>So your cache mount just never got used in that scenario in the first place, and with/without that cache mount you'd find that on Github due to the caveat with cargo that target cache won't be used, hence why it seems ineffective always vs locally üòÖ</p>
<p>You could look into <code>sscache</code> to workaround the issue in the meantime, but IIRC there are some caveats there to be aware of where cache may accidentally be used (<em>unless something has changed since I last read about that issue</em>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/polarathene">@polarathene</a> reviewed on 2025-04-29 08:21</div>
            <div class="timeline-body"><p>My full review feedback is a bit verbose, but unless you need more details, here's a TLDR and summary of each concern in the feedback comments :)</p>
<ul>
<li>[ ] Rustup cache mount is not compatible for concurrent builds unless you <strong>lock it's access</strong>.<ul>
<li>Alternatively (preferably) <strong>don't store the toolchain in a cache mount</strong> (<em>where it can be evicted, breaking future builds</em>), but without a minor refactor this will waste 1.4GB of disk when building both targets.</li>
</ul>
</li>
<li>[ ] Use <code>rustup toolchain install</code> and install both targets (<em>+135 MB weight for an AMD64 image to support ARM64 target</em>).<ul>
<li>This will also respect <code>--profile minimal</code> saving 600MB+, so it'll still use less disk overall.</li>
</ul>
</li>
<li>[ ] Optionally improve troubleshooting build failures via setting <code>SHELL</code>.</li>
</ul>
<p>Great to see your PR adopt the action support to persist cache mounts too btw üòé</p>
<hr />
<p>The below snippets use HereDoc syntax as it's arguably far better to grok/maintain, feel free to keep in the existing format instead for a better diff to assist review (<em>HereDoc syntax could always be added as a follow-up PR</em>).</p>
<h2>Installing toolchain via <code>rustup</code> with concurrent builds</h2>
<p>I don't think you should use a cache mount for <code>rustup</code>, the toolchain + target(s) it installs at least should not be part of the cache mount. Keep them in the image like you do with <code>zig</code> and <code>gcc</code>.</p>
<p>If you do keep it with a cache mount, there is a not so obvious failure when doing concurrent platform builds that both want to write to the same location at once as they install their own copy of the toolchain. To prevent that you'd need <code>,sharing=locked</code> on the cache mount options.</p>
<p>I'd personally just cache it in a layer and let updates to <code>rust-toolchain.toml</code> invalidate it:</p>
<pre><code class="language-Dockerfile">RUN \
  &lt;&lt;HEREDOC
  curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --profile minimal -- default-toolchain none

  echo 'targets = [ &quot;aarch64-unknown-linux-musl&quot;, &quot;x86_64-unknown-linux-musl&quot; ]' &gt;&gt; rust-toolchain.toml
  rustup toolchain install
HEREDOC
</code></pre>
<p>If you're concerned about prior layers invalidating that, you could use a separate stage to minimize that concern and <code>COPY --link</code> the <code>RUSTUP_HOME</code> and any other necessary changes.</p>
<hr />
<h2>Removing <code>RUSTUP_HOME</code> from cache mount can bloat disk usage by 1.4GB</h2>
<p>If you remove the cache mount for rustup, you will encounter another concern where disk usage for both AMD64 + ARM64 platforms diverges from the earlier <code>ARG TARGETPLATFORM</code> + <code>RUN</code>.</p>
<p>Those two instructions can be removed so that the image only diverges by platform for the <code>RUN</code> that actually builds <code>uv</code>, all that changes is that instead of <code>rust_target.txt</code> an ENV is used (<em><code>CARGO_BUILD_TARGET</code>, an actual cargo ENV</em>) to store the build target. That's handled by updating the already existing switch-case statement.</p>
<p>Here's what that looks like:</p>
<pre><code class="language-Dockerfile">ARG TARGETPLATFORM
RUN \
  # Use bind mounts to access Cargo config, lock, and sources; without needing to
  # copy them into a build layer (avoids bloating the docker build layer cache):
  --mount=type=bind,source=crates,target=crates \
  --mount=type=bind,source=Cargo.toml,target=Cargo.toml \
  --mount=type=bind,source=Cargo.lock,target=Cargo.lock \
  # Add cache mounts to speed up builds:
  --mount=type=cache,target=${HOME}/target/ \
  --mount=type=cache,target=/buildkit-cache,id=&quot;tool-caches&quot; \
  &lt;&lt;HEREDOC
  # Handle platform differences like mapping target arch to naming convention used by cargo targets:
  # https://en.wikipedia.org/wiki/X86-64#Industry_naming_conventions
  case &quot;${TARGETPLATFORM}&quot; in
    ( 'linux/amd64' )
      export CARGO_BUILD_TARGET='x86_64-unknown-linux-musl'
      ;;
    ( 'linux/arm64' )
      export CARGO_BUILD_TARGET='aarch64-unknown-linux-musl'
      export JEMALLOC_SYS_WITH_LG_PAGE=16
      ;;
    ( * )
      echo &quot;ERROR: Unsupported target platform: '${TARGETPLATFORM}'&quot;
      return 1
      ;;
  esac

  cargo zigbuild --release --bin uv --bin uvx --target &quot;${CARGO_BUILD_TARGET}&quot;
  cp &quot;target/${CARGO_BUILD_TARGET}/release/uv&quot; /uv
  cp &quot;target/${CARGO_BUILD_TARGET}/release/uvx&quot; /uvx
HEREDOC
</code></pre>
<hr />
<h2>Better troubleshooting with <code>SHELL</code></h2>
<p>Final note, an optional improvement that improves troubleshooting when stuff breaks, is to add this <code>SHELL</code> instruction to the top of the <code>Dockerfile</code>:</p>
<pre><code class="language-Dockerfile">FROM --platform=$BUILDPLATFORM ubuntu AS build
# Configure the shell to exit early if any command fails, or when referencing unset variables.
# Additionally `-x` outputs each command run, this is helpful for troubleshooting failures.
SHELL [&quot;/bin/bash&quot;, &quot;-eux&quot;, &quot;-o&quot;, &quot;pipefail&quot;, &quot;-c&quot;]
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:41:47 UTC
    </footer>
</body>
</html>
