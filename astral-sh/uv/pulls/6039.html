<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>allow manylinux compatibility override via `_manylinux` module. - astral-sh/uv #6039</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>allow manylinux compatibility override via <code>_manylinux</code> module.</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/uv/pull/6039">#6039</a>
        opened by <a href="https://github.com/ChannyClaus">@ChannyClaus</a>
        on 2024-08-12 17:35
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ChannyClaus">@ChannyClaus</a></div>
            <div class="timeline-body">Summary
<p>resolves <a href="https://github.com/astral-sh/uv/issues/5915">astral-sh/uv#5915</a>, not entirely sure if <code>manylinux_compatible</code> should be a separate field in the JSON returned by the interpreter or there&#x27;s some way to use the existing <code>platform</code> for it.</p>
Test Plan
<p>ran the below</p>
<pre><code>rm -rf .venv
target/debug/uv venv
# commenting out the line below triggers the change..
# target/debug/uv pip install no-manylinux
target/debug/uv pip install cryptography --no-cache
</code></pre>
<p>is there an easy way to add this into the existing snapshot-based test suite? looking around to see if there&#x27;s a way that doesn&#x27;t involve something implementation-dependent like mocks.</p>
<p>~update: i think the output does differ between these two, so probably we can use that.~ i lied - that &quot;building...&quot; output seems to be discarded.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Converted to draft by <a href="https://github.com/ChannyClaus">@ChannyClaus</a> on 2024-08-12 17:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by <a href="https://github.com/ChannyClaus">@ChannyClaus</a> on 2024-08-12 20:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/charliermarsh">@charliermarsh</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-15 03:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-15 03:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">compatibility</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-15 03:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-15 03:20</div>
            <div class="timeline-body"><p>Thanks! I can own reviewing this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-16 02:08</div>
            <div class="timeline-body"><p>Hmm, looking at the source... I think this might be slightly more complicated. We don&#x27;t just need to check what manylinux compatibility for the current glibc version. We also need to check compatibility for every <em>prior</em> manylinux version... Notice that in pip, they do:</p>
<pre><code>def platform_tags(archs: Sequence[str]) -&gt; Iterator[str]:
    &quot;&quot;&quot;Generate manylinux tags compatible to the current platform.

    :param archs: Sequence of compatible architectures.
        The first one shall be the closest to the actual architecture and be the part of
        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.
        The ``linux_`` prefix is assumed as a prerequisite for the current platform to
        be manylinux-compatible.

    :returns: An iterator of compatible manylinux tags.
    &quot;&quot;&quot;
    if not _have_compatible_abi(sys.executable, archs):
        return
    # Oldest glibc to be supported regardless of architecture is (2, 17).
    too_old_glibc2 = _GLibCVersion(2, 16)
    if set(archs) &amp; {&quot;x86_64&quot;, &quot;i686&quot;}:
        # On x86/i686 also oldest glibc to be supported is (2, 5).
        too_old_glibc2 = _GLibCVersion(2, 4)
    current_glibc = _GLibCVersion(*_get_glibc_version())
    glibc_max_list = [current_glibc]
    # We can assume compatibility across glibc major versions.
    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636
    #
    # Build a list of maximum glibc versions so that we can
    # output the canonical list of all glibc from current_glibc
    # down to too_old_glibc2, including all intermediary versions.
    for glibc_major in range(current_glibc.major - 1, 1, -1):
        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]
        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))
    for arch in archs:
        for glibc_max in glibc_max_list:
            if glibc_max.major == too_old_glibc2.major:
                min_minor = too_old_glibc2.minor
            else:
                # For other glibc major versions oldest supported is (x, 0).
                min_minor = -1
            for glibc_minor in range(glibc_max.minor, min_minor, -1):
                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)
                tag = &quot;manylinux_{}_{}&quot;.format(*glibc_version)
                if _is_compatible(arch, glibc_version):
                    yield f&quot;{tag}_{arch}&quot;
                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.
                if glibc_version in _LEGACY_MANYLINUX_MAP:
                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]
                    if _is_compatible(arch, glibc_version):
                        yield f&quot;{legacy_tag}_{arch}&quot;
</code></pre>
<p>So they&#x27;re testing <code>_is_compatible</code> against all versions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-16 02:09</div>
            <div class="timeline-body"><p>Maybe we should just settle for testing the current manylinux version though. Otherwise we&#x27;ll have to test a <em>bunch</em> of versions and pass that around.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-16 02:11</div>
            <div class="timeline-body"><p>It seems more common that people use blanket implementations anyway:</p>
<pre><code>def manylinux_compatible(*_, **__):  # PEP 600
    return False
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-16 02:12</div>
            <div class="timeline-body"><p>The alternative is that we iterate over all glibc versions up to and including the current, call <code>_is_compatible</code>, and then pass back a dictionary.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-16 02:12</div>
            <div class="timeline-body"><p>What do you think @konstin?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ChannyClaus">@ChannyClaus</a> on 2024-08-16 13:27</div>
            <div class="timeline-body"><blockquote>
<p>Hmm, looking at the source... I think this might be slightly more complicated. We don&#x27;t just need to check what manylinux compatibility for the current glibc version. We also need to check compatibility for every <em>prior</em> manylinux version... Notice that in pip, they do:</p>
<pre><code>def platform_tags(archs: Sequence[str]) -&gt; Iterator[str]:
    &quot;&quot;&quot;Generate manylinux tags compatible to the current platform.

    :param archs: Sequence of compatible architectures.
        The first one shall be the closest to the actual architecture and be the part of
        platform tag after the ``linux_`` prefix, e.g. ``x86_64``.
        The ``linux_`` prefix is assumed as a prerequisite for the current platform to
        be manylinux-compatible.

    :returns: An iterator of compatible manylinux tags.
    &quot;&quot;&quot;
    if not _have_compatible_abi(sys.executable, archs):
        return
    # Oldest glibc to be supported regardless of architecture is (2, 17).
    too_old_glibc2 = _GLibCVersion(2, 16)
    if set(archs) &amp; {&quot;x86_64&quot;, &quot;i686&quot;}:
        # On x86/i686 also oldest glibc to be supported is (2, 5).
        too_old_glibc2 = _GLibCVersion(2, 4)
    current_glibc = _GLibCVersion(*_get_glibc_version())
    glibc_max_list = [current_glibc]
    # We can assume compatibility across glibc major versions.
    # https://sourceware.org/bugzilla/show_bug.cgi?id=24636
    #
    # Build a list of maximum glibc versions so that we can
    # output the canonical list of all glibc from current_glibc
    # down to too_old_glibc2, including all intermediary versions.
    for glibc_major in range(current_glibc.major - 1, 1, -1):
        glibc_minor = _LAST_GLIBC_MINOR[glibc_major]
        glibc_max_list.append(_GLibCVersion(glibc_major, glibc_minor))
    for arch in archs:
        for glibc_max in glibc_max_list:
            if glibc_max.major == too_old_glibc2.major:
                min_minor = too_old_glibc2.minor
            else:
                # For other glibc major versions oldest supported is (x, 0).
                min_minor = -1
            for glibc_minor in range(glibc_max.minor, min_minor, -1):
                glibc_version = _GLibCVersion(glibc_max.major, glibc_minor)
                tag = &quot;manylinux_{}_{}&quot;.format(*glibc_version)
                if _is_compatible(arch, glibc_version):
                    yield f&quot;{tag}_{arch}&quot;
                # Handle the legacy manylinux1, manylinux2010, manylinux2014 tags.
                if glibc_version in _LEGACY_MANYLINUX_MAP:
                    legacy_tag = _LEGACY_MANYLINUX_MAP[glibc_version]
                    if _is_compatible(arch, glibc_version):
                        yield f&quot;{legacy_tag}_{arch}&quot;
</code></pre>
<p>So they&#x27;re testing <code>_is_compatible</code> against all versions.</p>
</blockquote>
<p>ah, probably should&#x27;ve looked there as well - i can implement the equivalent logic if y&#x27;all decide that to be the way to go ðŸŒµ</p>
<p>for what it&#x27;s worth i do think what you point out in <a href="https://github.com/astral-sh/uv/pull/6039">astral-sh/uv#6039</a>#issuecomment-2292605485 is probably true ðŸ˜…</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-20 23:56</div>
            <div class="timeline-body"><p>I think we should just document it and move forward as-is.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> approved on 2024-08-21 01:38</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-21 01:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2024-08-21 01:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2024-08-21 01:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:47:21 UTC
    </footer>
</body>
</html>
