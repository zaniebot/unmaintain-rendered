<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Remove regular expressions for package name normalization - astral-sh/uv #614</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Remove regular expressions for package name normalization</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/uv/pull/614">#614</a>
        opened by <a href="https://github.com/charliermarsh">@charliermarsh</a>
        on 2023-12-12 05:41
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a></div>
            <div class="timeline-body"><p>Very random but the hand-written version is about 3-4x faster (benchmarked in a standalone repo).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-12 05:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-12-12 05:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/puffin-normalize/src/lib.rs</code>:23 on 2023-12-12 05:47</div>
            <div class="timeline-body"><p>I looked at changing this to return <code>Cow</code>, so that we could avoid iterating over the characters twice for the <code>validate_and_normalize_owned</code> case, but it ended up being slower. I guess more branches?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-12 05:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-12 05:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Branch deleted on 2023-12-12 05:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-12 14:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-normalize/src/lib.rs</code>:26 on 2023-12-12 14:18</div>
            <div class="timeline-body"><p>You should be able to iterate over bytes here, since your case analysis is limited to ASCII characters below. That would let you avoid doing UTF-8 decoding. (Which is what <code>chars()</code> is doing.)</p>
<p>Same thing for <code>is_normalized</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-12 14:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-normalize/src/lib.rs</code>:23 on 2023-12-12 14:21</div>
            <div class="timeline-body"><p>Plausibly. My prior is that a <code>Cow</code> would probably be faster here, but I could see it not making much of a difference (or perhaps being slower) if most names didn&#x27;t need normalization. If most do, then you&#x27;re doing two passes for most names.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-12-12 14:33</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/puffin-normalize/src/lib.rs</code>:26 on 2023-12-12 14:33</div>
            <div class="timeline-body"><p>Dumb question, what happens if <code>name</code> <em>does</em> contain a UTF-8 character in that case?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-12-12 14:35</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/puffin-normalize/src/lib.rs</code>:23 on 2023-12-12 14:35</div>
            <div class="timeline-body"><p>Maybe I&#x27;ll try again. How would you typically structure this? Make <code>normalized</code> an <code>Option</code>, and initialize it with the preceding contents as soon as you see a mismatching character?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-12 14:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-normalize/src/lib.rs</code>:26 on 2023-12-12 14:43</div>
            <div class="timeline-body"><p>Behavior will remain unchanged. You&#x27;ll hit the same error case.</p>
<p>The key here is that UTF-8 was specifically designed to be ASCII compatible. That means that any time you see an ASCII byte in valid UTF-8, it&#x27;s guaranteed to correspond to the equivalent ASCII codepoint. Since here you don&#x27;t actually care about anything other than ASCII, you can just look at the bytes directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/charliermarsh">@charliermarsh</a> reviewed on 2023-12-12 14:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on <code>crates/puffin-normalize/src/lib.rs</code>:26 on 2023-12-12 14:45</div>
            <div class="timeline-body"><p>But what if the string contains a multi-byte character?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-normalize/src/lib.rs</code>:23 on 2023-12-12 14:45</div>
            <div class="timeline-body"><p>I think so yeah, that&#x27;s where I&#x27;d start.</p>
<p>But definitely keep the bigger picture in mind here. Are most names being normalized? If not, it might not help much.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-12 14:45</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-12 14:47</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-normalize/src/lib.rs</code>:26 on 2023-12-12 14:47</div>
            <div class="timeline-body"><p>There is no UTF-8 encoding of any Unicode scalar value where any of its code units is equivalent to an ASCII byte. So you&#x27;ll just trip your error case. Same as what happens in your code today if I&#x27;m reading it right.</p>
<p>This might help: https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=a632ee5d0aa0adb2a154da5475aa3882</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2023-12-12 14:50</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-normalize/src/lib.rs</code>:26 on 2023-12-12 14:50</div>
            <div class="timeline-body"><p>The fact that you return an <code>InvalidNameError</code> upon seeing <em>anything</em> that doesn&#x27;t match <code>[-_.0-9A-Za-z]</code> is what makes the optimization work. The error case doesn&#x27;t care about <em>what</em> you see, only that it isn&#x27;t <code>[-_.0-9A-Za-z]</code>. Since <code>[-_.0-9A-Za-z]</code> is all ASCII, the byte version of that class and the codepoint version of that class are precisely equivalent. So in the current code, the error case triggers when you see a <em>codepoint</em> outside of <code>[-_.0-9A-Za-z]</code>. But in the byte version, the error case will trigger when you see a UTF-8 code unit that isn&#x27;t in <code>[-_.0-9A-Za-z]</code>. The error cases are precisely equivalent because UTF-8 is ASCII compatible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-12 16:52</div>
            <div class="timeline-body"><p>For posterity: I rewrote this to use <code>Cow</code>.</p>
<pre><code>pub(crate) fn cow(
    name: &amp;str,
) -&gt; Result&lt;Cow&lt;str&gt;&gt; {
    let mut normalized: Option&lt;String&gt; = None;

    let mut last = None;
    for (i, char) in name.bytes().enumerate() {
        match char {
            b&#x27;A&#x27;..=b&#x27;Z&#x27; =&gt; {
                if let Some(normalized) = normalized.as_mut() {
                    normalized.push(char.to_ascii_lowercase() as char);
                } else {
                    let mut string = String::with_capacity(name.len());
                    string.push_str(&amp;name[..i]);
                    string.push(char.to_ascii_lowercase() as char);
                    normalized = Some(string);
                }
            }
            b&#x27;a&#x27;..=b&#x27;z&#x27; | b&#x27;0&#x27;..=b&#x27;9&#x27; =&gt; {
                if let Some(normalized) = normalized.as_mut() {
                    normalized.push(char as char);
                }
            }
            b&#x27;-&#x27; =&gt; {
                match last {
                    // Names can&#x27;t start with punctuation.
                    None =&gt; return Err(anyhow::anyhow!(name.to_string())),
                    Some(b&#x27;-&#x27;) =&gt; {
                        // Runs of `-` are normalized to a single `-`.
                        if normalized.is_none() {
                            let mut string = String::with_capacity(name.len());
                            string.push_str(&amp;name[..i]);
                            normalized = Some(string);
                        }
                    }
                    Some(_) =&gt; {
                        if let Some(normalized) = normalized.as_mut() {
                            normalized.push(&#x27;-&#x27;);
                        }
                    },
                }
            }
            b&#x27;_&#x27; | b&#x27;.&#x27; =&gt; {
                match last {
                    // Names can&#x27;t start with punctuation.
                    None =&gt; return Err(anyhow::anyhow!(name.to_string())),
                    Some(b&#x27;-&#x27;) | Some(b&#x27;_&#x27;) | Some(b&#x27;.&#x27;) =&gt; {
                        if normalized.is_none() {
                            let mut string = String::with_capacity(name.len());
                            string.push_str(&amp;name[..i]);
                            normalized = Some(string);
                        }
                    }
                    Some(_) =&gt; {
                        if let Some(normalized) = normalized.as_mut() {
                            normalized.push(&#x27;-&#x27;);
                        } else {
                            let mut string = String::with_capacity(name.len());
                            string.push_str(&amp;name[..i]);
                            string.push(&#x27;-&#x27;);
                            normalized = Some(string);
                        }
                    }
                }
            }
            _ =&gt; return Err(anyhow::anyhow!(name.to_string())),
        }
        last = Some(char);
    }

    // Names can&#x27;t end with punctuation.
    if matches!(last, Some(b&#x27;-&#x27;) | Some(b&#x27;_&#x27;) | Some(b&#x27;.&#x27;)) {
        return Err(anyhow::anyhow!(name.to_string()));
    }

    if let Some(normalized) = normalized {
        Ok(Cow::Owned(normalized))
    } else {
        Ok(Cow::Borrowed(name))
    }
}
</code></pre>
<p>It&#x27;s much faster in the event that there is no normalization, but a touch slower in other cases. However, importantly, it&#x27;s also not much of an optimization in practice because we always convert the <code>str</code> to a <code>String</code> after calling this, so it doesn&#x27;t <em>actually</em> save us an allocation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-12-12 16:58</div>
            <div class="timeline-body"><p>It still does save a second pass over the name though? Although perhaps that&#x27;s marginal here, and especially so if most names are already normalized.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-12 17:06</div>
            <div class="timeline-body"><p>In my criterion benchmark, interestingly, the version where we need to normalize an owned string ends up being <em>slower</em> than doing two passes... E.g., given <code>&quot;meine_stadt_transformers&quot;.to_string()</code>, it&#x27;s 83ns vs. 77ns for the Cow-based version vs. the two-pass version. Why could that be...?</p>
<p>Do you think this variant is easier to understand and maintain? Perhaps I&#x27;ll commit it anyway.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2023-12-12 17:12</div>
            <div class="timeline-body"><p>I&#x27;m not sure at a glance honestly. I think I&#x27;d have to investigate. The branches and the beefier code could definitely be having an impact.</p>
<blockquote>
<p>Do you think this variant is easier to understand and maintain? Perhaps I&#x27;ll commit it anyway.</p>
</blockquote>
<p>I like what&#x27;s on <code>main</code> right now better than the <code>Cow</code> stuff.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2023-12-12 17:18</div>
            <div class="timeline-body"><p>Sounds good, moving on :) Thank you!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:42:53 UTC
    </footer>
</body>
</html>
