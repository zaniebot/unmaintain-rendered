<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test uv+PyPI Trusted Publishing on Gitlab - astral-sh/uv #17443</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Test uv+PyPI Trusted Publishing on Gitlab</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/uv/pull/17443">#17443</a>
        opened by <a href="https://github.com/woodruffw">@woodruffw</a>
        on 2026-01-13 19:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>~~WIP.~~</p>
<p>The basic idea here is to invoke a Gitlab Pipeline via GitHub. That pipeline generates an OIDC token which it saves as an artifact, which the GitHub workflow can then read. We then use that OIDC token to impersonate the identity of the Gitlab Pipeline for Trusted Publishing purposes.</p>
<p>Guinea pig project: https://test.pypi.org/project/astral-test-pypi-trusted-publishing-gitlab/</p>
<p>See #17438 for motivating context.</p>
<h2>Test Plan</h2>
<p>Implement the above within <code>test_publish.py</code> and <code>ci.yml</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @woodruffw by @woodruffw on 2026-01-13 19:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-13 22:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>scripts/publish/test_publish.py</code>:1 on 2026-01-13 22:11</div>
            <div class="timeline-body"><p>Apologies for the churn in this file -- I realized that I was having trouble tracking the state through the different sub-tests, so what I've done is add a &quot;plan&quot; abstraction that pre-plans some test state. We can then pass that state around consistently via a <code>Plan</code> object rather than sharing it piecemeal.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-13 22:11</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>scripts/publish/test_publish.py</code>:244 on 2026-01-13 22:11</div>
            <div class="timeline-body"><p>This is the main operative change ðŸ™‚</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-13 22:15</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>scripts/publish/test_publish.py</code>:562 on 2026-01-13 22:15</div>
            <div class="timeline-body"><p>Flagging: the nuance here is that GitLab, unlike GitHub and other TP providers, doesn't have an &quot;active&quot; OIDC source: the runner gets a single OIDC credential at startup. As a result of that PyPI (and pyx) consider the OIDC credential &quot;spent&quot; after its first use, meaning that our duplicate/conflict/etc. tests all fail for an unrelated reason (the index is rejecting our credential as reused).</p>
<p>There's no great way around this, it's seemingly an architectural limitation of GitLab. But the good news is that it won't affect typical user workflows, it only dings us here because we're intentionally re-using an OIDC credential across separate <code>uv publish</code> invocations ðŸ™‚</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-13 22:16</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>scripts/publish/test_publish.py</code>:562 on 2026-01-13 22:16</div>
            <div class="timeline-body"><p>(This is true for the other tests below as well.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-13 22:18</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>.github/workflows/ci.yml</code>:259 on 2026-01-13 22:18</div>
            <div class="timeline-body"><p>Flagging: this adds ~30s of sync runtime to the publishing tests, since this action needs to block while the Gitlab pipeline completes. That's not ideal, but the silver lining is that it'll be amortized as we add more Gitlab publishing tests (e.g. for pyx too), since we can use the same pipeline invocation to generate multiple ID tokens.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Marked ready for review by @woodruffw on 2026-01-13 22:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @zanieb by @woodruffw on 2026-01-13 22:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @konstin by @woodruffw on 2026-01-13 22:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from @zsol by @woodruffw on 2026-01-13 22:19</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">internal</span> added by @woodruffw on 2026-01-13 23:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>.github/workflows/ci.yml</code>:259 on 2026-01-13 23:22</div>
            <div class="timeline-body"><p>(Also noting that I reviewed this action's source. I considered trying to open-code this with GitLab's <code>glab</code> CLI instead, but this seemed simpler. We could always switch to that instead, though.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-13 23:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsol">@zsol</a> reviewed on 2026-01-14 08:20</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zsol">@zsol</a> on <code>scripts/publish/test_publish.py</code>:562 on 2026-01-14 08:20</div>
            <div class="timeline-body"><p>Would this mean that two subsequent uv publish commands in the same job in a user's workflow fail the same way? If so, that's quite a severe limitation</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsol">@zsol</a> approved on 2026-01-14 08:24</div>
            <div class="timeline-body"><p>This looks ok to me, but maybe it would be <em>slightly</em> better if we would have a separate, parallel job for the non-github trusted publishing tests, so if they do fail at the point of getting the oidc token the rest of the tests would still run</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/woodruffw">@woodruffw</a> reviewed on 2026-01-14 12:52</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/woodruffw">@woodruffw</a> on <code>scripts/publish/test_publish.py</code>:562 on 2026-01-14 12:52</div>
            <div class="timeline-body"><p>Yep, exactly. There's ways we could potentially work around that within uv itself (e.g. we could stash the minted credential for reuse between invocations), but the limitation on OIDC token reuse is architectural/inside PyPI.</p>
<p>In practice this doesn't generally bite users because all they do is a single <code>uv publish</code> invocation, plus must CI providers don't have this limitation (GitHub and all the others can acquire additional OIDC creds at runtime.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/woodruffw">@woodruffw</a> on 2026-01-14 13:17</div>
            <div class="timeline-body"><blockquote>
<p>so if they do fail at the point of getting the oidc token the rest of the tests would still run</p>
</blockquote>
<p>Yeah, I was thinking about either sharding this across jobs with a matrix <em>or</em> changing it to use a more &quot;traditional&quot; pytest setup, so that we could run the entire suite without failing fast. I can look at that with a follow up.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-14 13:34:49 UTC
    </footer>
</body>
</html>
