<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add an exception handler on Windows - astral-sh/uv #14582</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add an exception handler on Windows</h1>

    <div class="meta">
        <span class="state-icon state-merged"></span>
        <a href="https://github.com/astral-sh/uv/pull/14582">#14582</a>
        opened by <a href="https://github.com/geofft">@geofft</a>
        on 2025-07-13 02:49
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a></div>
            <div class="timeline-body"><p>We&#x27;ve seen a few cases of uv.exe exiting with an exception code as its exit status and no user-visible output (#14563 in the field, and #13812 in CI). It seems that recent versions of Windows no longer show dialog boxes on access violations (what UNIX calls segfaults) or similar errors. Something is probably sent to Windows Error Reporting, and we can maybe sign up to get the crashes from Microsoft, but the user experience of seeing uv exit with no output is poor, both for end users and during development. While it&#x27;s possible to opt out of this behavior or set up a debugger, this isn&#x27;t the default configuration. (See https://superuser.com/q/1246626 for some pointers.)</p>
<p>In order to get some output on a crash, we need to install our own default handler for unhandled exceptions (or call all our code inside a Structured Exception Handling __try/__catch block, which is complicated on Rust). This is the moral equivalent of a segfault handler on Windows; the kernel creates a new stack frame and passes arguments to it with some processor state.</p>
<p>This commit adds a relatively simple exception handler that leans on Rust&#x27;s own backtrace implementation and also displays some minimal information from the exception itself. This should be enough info to communicate that something went wrong and let us collect enough information to attempt to debug. There are also a handful of (non-Rust) open-source libraries for this like Breakpad and Crashpad (both from Google) and crashrpt.</p>
<p>The approach here, of using SetUnhandledExceptionFilter, seems to be the standard one taken by other such libraries. Crashpad also seems to try to use a newer mechanism for an out-of-tree DLL to report the crash: https://issues.chromium.org/issues/42310037
If we have serious problems with memory corruption, it might be worth adopting some third-party library that has already implemented this approach. (In general, the docs of other crash reporting libraries are worth skimming to understand how these things ought to work.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/zanieb">@zanieb</a> by <a href="https://github.com/geofft">@geofft</a> on 2025-07-13 02:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">windows</span> added by <a href="https://github.com/geofft">@geofft</a> on 2025-07-13 02:49</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/geofft">@geofft</a> on 2025-07-13 02:59</div>
            <div class="timeline-body"><p>I tested this by forcing a segfault:</p>
<pre><code>diff --git a/crates/uv-client/src/base_client.rs b/crates/uv-client/src/base_client.rs
index 9ddc30e75..45fe0e4e5 100644
--- a/crates/uv-client/src/base_client.rs
+++ b/crates/uv-client/src/base_client.rs
@@ -266,6 +266,7 @@ impl&lt;&#x27;a&gt; BaseClientBuilder&lt;&#x27;a&gt; {
     }

     pub fn build(&amp;self) -&gt; BaseClient {
+        unsafe {(1 as *mut i32).write(1);}
         // Create user agent.
         let mut user_agent_string = format!(&quot;uv/{}&quot;, version());

</code></pre>
<p>Without this patch, it exits quietly:</p>
<pre><code>C:\Users\Administrator\uv&gt;target\debug\uv run python

C:\Users\Administrator\uv&gt;echo %errorlevel%
-1073741819
</code></pre>
<p>With the patch I get a relatively short error, and <code>RUST_BACKTRACE=1</code> gets me a register dump and backtrace:</p>
<pre><code>C:\Users\Administrator\uv&gt;target\debug\uv run python
error: unhandled exception in uv, please report a bug:
code 0xC0000005 at address 0x7ff662e5d03b
EXCEPTION_ACCESS_VIOLATION writing              0x1
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace

C:\Users\Administrator\uv&gt;set RUST_BACKTRACE=1

C:\Users\Administrator\uv&gt;target\debug\uv run python
error: unhandled exception in uv, please report a bug:
code 0xC0000005 at address 0x7ff662e5d03b
EXCEPTION_ACCESS_VIOLATION writing              0x1
rax=0000000000000001 rbx=0000000000000000 rcx=0000027d822a8298
rdx=0000027d822a61a8 rsx=0000027d800208f0 rdi=0000000000000000
rsp=000000b975ed3a90 rbp=000000b975ed3b10  r8=0000000000000028
 r9=0000000000000040 r10=00007ff660ec0000 r11=00007ff66433bb11
r12=0000000000000000 r13=0000000000000000 r14=0000000000000000
r15=0000000000000000 rip=00007ff662e5d03b eflags=0000000000010206
stack backtrace:
   0:     0x7ff664206b3e - std::backtrace_rs::backtrace::win64::trace
                               at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc/library\std\src\..\..\backtrace\src\backtrace\win64.rs:85
   1:     0x7ff664206b3e - std::backtrace_rs::backtrace::trace_unsynchronized
                               at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc/library\std\src\..\..\backtrace\src\backtrace\mod.rs:66
   2:     0x7ff664206b3e - std::backtrace::Backtrace::create
                               at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc/library\std\src\backtrace.rs:331
   3:     0x7ff664206847 - std::backtrace::Backtrace::capture
                               at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc/library\std\src\backtrace.rs:296
   4:     0x7ff661c16792 - uv::windows_exception::unhandled_exception_filter
                               at C:\Users\Administrator\uv\crates\uv\src\windows_exception.rs:109
   5:     0x7ffc9aa8fb4d - UnhandledExceptionFilter
   6:     0x7ffc9d308595 - memset
   7:     0x7ffc9d2eec46 - _C_specific_handler
   8:     0x7ffc9d3043bf - _chkstk
   9:     0x7ffc9d29186e - RtlVirtualUnwind2
  10:     0x7ffc9d3033ae - KiUserExceptionDispatcher
  11:     0x7ff662e5d03b - core::ptr::write
                               at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc\library\core\src\ptr\mod.rs:1655
  12:     0x7ff662e5d03b - core::ptr::mut_ptr::impl$0::write
                               at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc\library\core\src\ptr\mut_ptr.rs:1509
  13:     0x7ff662e5d03b - uv_client::base_client::BaseClientBuilder::build
                               at C:\Users\Administrator\uv\crates\uv-client\src\base_client.rs:269
  14:     0x7ff6619bb991 - uv_python::installation::impl$0::fetch::async_fn$0
                               at C:\Users\Administrator\uv\crates\uv-python\src\installation.rs:230
</code></pre>
<p>Very much open to tweaking the output format.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/BurntSushi">@BurntSushi</a> by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-13 13:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/Gankra">@Gankra</a> by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-13 13:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Review requested from <a href="https://github.com/samypr100">@samypr100</a> by <a href="https://github.com/zanieb">@zanieb</a> on 2025-07-13 13:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-07-13 20:41</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>crates/uv/src/windows_exception.rs</code>:97 on 2025-07-13 20:41</div>
            <div class="timeline-body"><pre><code>                    eprintln!(&quot;EXCEPTION_STACK_OVERFLOW&quot;);
</code></pre>
<p>Fixes failing <code>typo</code> job in CI</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>crates/uv/src/windows_exception.rs</code>:11 on 2025-07-13 20:44</div>
            <div class="timeline-body"><pre><code>#![allow(unsafe_code)]
#![allow(clippy::print_stderr)]
</code></pre>
<p>Will help pass clippy failing CI job for windows</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-07-13 20:44</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-07-13 21:00</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>crates/uv/src/windows_exception.rs</code>:121 on 2025-07-13 21:00</div>
            <div class="timeline-body"><p>Is there a reason we&#x27;d prefer EXCEPTION_CONTINUE_SEARCH (0) over EXCEPTION_EXECUTE_HANDLER (1)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-07-13 21:01</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>crates/uv/src/windows_exception.rs</code>:56 on 2025-07-13 21:01</div>
            <div class="timeline-body"><p>aarch64 toolchain seems to think accessing <code>c.Anonymous.Anonymous</code> is unsafe</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:121 on 2025-07-14 02:44</div>
            <div class="timeline-body"><p>I don&#x27;t totally understand the difference in behavior here when we&#x27;re talking about an unhandled exception filter of which there is only one (as opposed to a vectored exception handler, SEH, etc. where there might actually be a next thing to call). My vague sense is that this alerts a debugger (as a &quot;second chance exception&quot;) instead of crashing the process, which seems good?</p>
<p>(Some things I am reading on the internet, e.g., <a href="https://billdemirkapi.me/abusing-exceptions-for-code-execution-part-2/">this</a>, and the relevant WINE source, make me think that under the hood the only thing that exists is SEH / unwinding, and something very low level sets up a SEH catch block around <code>main</code> that calls some global function pointer and all that <code>SetUnhandledExceptionFilter</code> does is update that pointer.)</p>
<p>In practice I did this because Google Crashpad returns EXCEPTION_CONTINUE_SEARCH, not EXCEPTION_EXECUTE_HANDLER.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a> reviewed on 2025-07-14 04:53</div>
            <div class="timeline-body"><p>Here&#x27;s something a little interesting: on i686, we don&#x27;t get a proper backtrace. I wonder if the exception handler is called on a different stack or something.</p>
<pre><code>C:\Users\Administrator\uv&gt;cargo build --target i686-pc-windows-msvc -p uv
C:\Users\Administrator\uv&gt;target\i686-pc-windows-msvc\debug\uv run python
error: unhandled exception in uv, please report a bug:
code 0xC0000005 at address 0x2e119b7
EXCEPTION_ACCESS_VIOLATION writing 0x1
eax=00000001 ebx=0effc208 ecx=0ef48ab0 edx=07030fb0 esi=0ef44a80 edi=0effc0a4
eip=02e119b7 ebp=0ef44ec8 esp=0ef44a80 eflags=00010202
stack backtrace:
   0:  0x41e265e - std::backtrace::Backtrace::capture
                       at /rustc/6b00bc3880198600130e1cf62b8f8a93494488cc/library\std\src\backtrace.rs:296
   1:  0x1a052e1 - uv::windows_exception::unhandled_exception_filter
                       at C:\Users\Administrator\uv\crates\uv\src\windows_exception.rs:112
   2: 0x75a354b2 - UnhandledExceptionFilter
   3: 0x779c7fdf - RtlGetFullPathName_UEx
   4: 0x779c7f1b - RtlGetFullPathName_UEx
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-07-14 05:03</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>crates/uv/src/windows_exception.rs</code>:121 on 2025-07-14 05:03</div>
            <div class="timeline-body"><p>üëç Makes sense if the goal is to delegate to a possible outer SE handler (if any exists) and not treat this filter as the final handler. If we wanted to do filter chaining we&#x27;d need to keep the prev filter reference alive and loaded so this is probably good enough.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/geofft">@geofft</a> on 2025-07-14 12:46</div>
            <div class="timeline-body"><p>Re that last comment, presumably we can unwind from the provided <code>eip</code> in the context structure, but I don&#x27;t immediately see either backtrace-rs or libunwind having support for this, so we&#x27;ll need to reach for another unwinder, at which point there&#x27;s a really good question about why there already a good third-party crate to do this sort of thing (or really why it isn&#x27;t in <code>std</code>). Maybe there is and I missed it? Maybe I should spin this out into its own crate?</p>
<p>Also - do we support Windows builds on platforms other than x86, x86-64, and aarch64? Right now the code will fail to compile, but I can add a dummy implementation that doesn&#x27;t print registers on other platforms. We do seem to handle unknown Windows arches in uv-trampoline-builder, for instance. On the other hand I&#x27;m pretty sure that <code>Windows/Win32/System/Diagnostics/Debug/mod.rs</code> itself will fail to compile on other platforms because there&#x27;s no definition for <code>struct CONTEXT</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/samypr100">@samypr100</a> on 2025-07-14 13:08</div>
            <div class="timeline-body"><blockquote>
<p>Also - do we support Windows builds on platforms other than x86, x86-64, and aarch64?</p>
</blockquote>
<p>At least not to my knowledge</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a> reviewed on 2025-07-14 13:58</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:121 on 2025-07-14 13:58</div>
            <div class="timeline-body"><p>Yeah, philosophically I want to treat this as something that does an informative print of information while the program is on its way to crashing, not a handler in the sense of something that claims full responsibility for the exception.</p>
<p>I suppose we could store the return value from <code>SetUnhandledExceptionFilter</code> with the pointer to the old filter and call it ourselves, but that feels complicated. There&#x27;s also apparently the problem that <a href="http://www.nynaeve.net/?p=43">the old filter might have come from a now-unloaded DLL</a> and because there&#x27;s no explicit unregistration API you have no idea whether that pointer is still valid. Alternatively maybe we should use <code>AddVectoredExceptionHandler</code> which does seem to do a registration/unregistration API with a list of handlers? Or we could do this with an actual SEH try-except handler of our own on the stack (which we don&#x27;t have to do in Rust if that&#x27;s hard, I bet we can write a tiny C program to forward to calling <code>uv::main()</code>).</p>
<p>I am trying so hard not to look at the leaked NT source code to figure out what all of this <em>actually</em> does because there&#x27;s somehow not a lot of documentation, either from MS or from other people. As a data point, <a href="https://github.com/reactos/reactos/blob/0.4.15-release/dll/win32/kernel32/client/except.c#L352-L358">on ReactOS</a> (which is reverse-engineered from NT and tries to be compatible with it), returning <code>EXCEPTION_EXECUTE_HANDLER</code> from your custom filter will skip over code in <code>UnhandledExceptionFilter</code> to print a stack trace (custom to ReactOS, not present in NT), show the dialog box (the thing NT apparently no longer does unless you enable it), and start a debugger (present in NT). And indeed <code>UnhandledExceptionFilter</code> is called from a big SEH try/except around calling the start address for <a href="https://github.com/reactos/reactos/blob/0.4.15-release/dll/win32/kernel32/client/proc.c#L465">the main process</a> or <a href="https://github.com/reactos/reactos/blob/0.4.15-release/dll/win32/kernel32/client/thread.c">thread</a>, and if you return early from it, the process will just terminate without any of those other niceties.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2025-07-14 14:19</div>
            <div class="timeline-body"><p>FWIW for a rust crate, there is https://github.com/EmbarkStudios/crash-handling/tree/main/crash-handler</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a> approved on 2025-07-14 14:21</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2025-07-14 14:32</div>
            <div class="timeline-body"><p>Some context on the state of the art of crash-reporting (you do not need to implement this, just infodumping): You want to spawn two processes: a parent &quot;crash monitor&quot; and a child (your actual app). When the child crashes the parent is signalled to scrape info from the child, generate a minidump, and then sends the minidump to the developer&#x27;s servers. In this past we had a process analyze itself but &quot;i just segfaulted, time to do a bunch of complex logic and networking&quot; is uhhh dubious.</p>
<p>Because shipping two binaries is weird, it&#x27;s typically to just have a single binary that spawns a second copy of itself.</p>
<p>Minidumps, by virtue of containing the memory of stacks, may contain PII so generally you then process the minidump serverside to produce an anonamized summary (error code, stacktrace, system info...).</p>
<p>All of this is a ton of work and infra which is why I tell people &quot;yeah just use sentry.io&quot; which in fact uses minidump tooling written in rust. However funnily enough (at least a few years ago) their offerings for rust were basically just a panic hook because a rust app segfaulting was so rare! Hopefully since then they&#x27;ve added segfault handling. But anyway us rolling our own here just so the user gets a vaguely useful diagnostic is Fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Merged by <a href="https://github.com/geofft">@geofft</a> on 2025-07-14 14:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/geofft">@geofft</a> on 2025-07-14 14:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Gankra">@Gankra</a> reviewed on 2025-07-14 14:43</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/Gankra">@Gankra</a> on <code>crates/uv/src/windows_exception.rs</code>:45 on 2025-07-14 14:43</div>
            <div class="timeline-body"><p>rsx is paired with rsi here</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/uv/src/windows_exception.rs</code>:79 on 2025-07-14 14:44</div>
            <div class="timeline-body"><p>Also, <code>eprintln!</code> will try to acquire a lock. If that lock is held by some other part of the code (which doesn&#x27;t seem that unlikely to me) when this handler is executed, then presumably this will deadlock. (IDK if acquiring locks is async-signal-safe on Windows either.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-07-14 14:49</div>
            <div class="timeline-body"><p>I think it would be good to try and fix printing so that we don&#x27;t go through <code>eprintln!</code>, but this otherwise LGTM. (Noting that I don&#x27;t really have a lot of Windows experience, so my review isn&#x27;t worth much.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:79 on 2025-07-14 15:02</div>
            <div class="timeline-body"><p>Yeah, the lock is the thing I was thinking of re async-signal-safety (which isn&#x27;t exactly a phrase used on Windows, but the concept is exactly the same because you get called in a new stack frame at some arbitrary point when an exception happens) and I do expect that to be a risk. I don&#x27;t see a lockless/async-signal-safe way to print stuff in <code>std</code>, the console APIs looked more complicated than I wanted to deal with (you gotta get a handle, do encoding, etc.), and I sort of assume that Windows&#x27; implementation of POSIX <code>write</code> isn&#x27;t actually async-signal-safe.</p>
<p>FWIW I went with <code>eprintln!</code> because we&#x27;re using <code>anstream::eprintln!</code> elsewhere for printing messages, which I assume wraps it and takes out the same lock. (It just doesn&#x27;t trigger the Clippy lint.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:45 on 2025-07-14 15:04</div>
            <div class="timeline-body"><p>oops, I&#x27;ll fix this if I fix something else to save the CI (&quot;rsx&quot; is not a register anyway)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a> reviewed on 2025-07-14 15:09</div>
            <div class="timeline-body"><p>Thanks for the context @Gankra! Also recording here the link you sent me to https://github.com/rust-minidump/minidump-pipeline so I don&#x27;t lose it, both of these answer my question of &quot;how are you supposed to do this in Rust.&quot;</p>
<p>It does seem to me like if we want to do something more complicated we should go with one of the third-party SaaS options, either some vendor that specializes in this sort of reporting or signing up for Microsoft&#x27;s own Windows Error Reporting thing. Adding an out-of-process handler for <code>uv.exe</code> seems complicated and not something we should do by default given that we&#x27;ve seen a single-digit number of segfaults and we care about startup performance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-07-14 15:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/uv/src/windows_exception.rs</code>:79 on 2025-07-14 15:22</div>
            <div class="timeline-body"><p>I think you can use <a href="https://doc.rust-lang.org/std/os/windows/io/trait.AsRawHandle.html"><code>AsRawHandle</code></a> on the result of <a href="https://doc.rust-lang.org/std/io/fn.stderr.html"><code>std::io::stderr</code></a>, and then <a href="https://doc.rust-lang.org/std/os/windows/io/trait.FromRawHandle.html"><code>FromRawHandle</code></a> to create a <code>File</code>. Then you should be able to <code>write</code> to that. That won&#x27;t acquire any locks.</p>
<p>I do not know if the underlying syscall (<code>WriteConsoleW</code>) is async-signal-safe on Windows, but this will at least avoid the possible deadlock that can occur by using <code>eprintln!</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a> reviewed on 2025-07-14 15:51</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:79 on 2025-07-14 15:51</div>
            <div class="timeline-body"><p>Okay, hm, that looks easier than what https://github.com/rust-lang/rust/blob/master/library/std/src/sys/stdio/windows.rs and https://github.com/rust-lang/rust/blob/master/library/std/src/sys/pal/windows/handle.rs are doing (which I think is the code behind the <code>stderr</code> lock). There are two implementations there:</p>
<ul>
<li>If stderr is a console that either uses a non-UTF-8 code page or is on Windows 7, then it writes UTF-16 with <code>WriteConsoleW</code>. There&#x27;s some handling for incomplete/invalid UTF-8 which wouldn&#x27;t apply since we only need to write <code>str</code>s. But I&#x27;m surprised at the code calling Windows API function <code>MultiByteToWideChar</code> instead of e.g. <code>str::encode_utf16()</code>, is that necessary?</li>
<li>If stderr is either not a console, or the console uses the UTF-8 code page (and we&#x27;re not on Windows 7), then we write bytes with <code>FromRawHandle</code> + <code>write</code>, which calls <code>NtWriteFile</code> (I got a little scared by the thing it does to <code>WaitForSingleObject</code> but I missed that this function is public API and we wouldn&#x27;t have to reimplement it).</li>
</ul>
<p>It seems like we have to have both implementations, in that <code>WriteConsole</code> won&#x27;t work if stderr is redirected to a file and writing UTF-8 won&#x27;t work if stderr is a non-UTF-8-code-page console. But it doesn&#x27;t seem as bad as I was afraid of.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2025-07-14 15:59</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/uv/src/windows_exception.rs</code>:79 on 2025-07-14 15:59</div>
            <div class="timeline-body"><p>Ah yeah, I think I&#x27;m wrong. Because writing to <code>File</code> won&#x27;t call <code>WriteConsole</code>. So yeah, I think if it&#x27;s a console, we&#x27;d have to do our own Windows FFI stuff. But otherwise we should be able to just get a <code>File</code> and write to it like normal.</p>
<p>As for <code>MultiByteToWideChar</code>, it looks like we used to use <code>str::encode_utf16</code>, but it <a href="https://github.com/rust-lang/rust/pull/107110">was switched due to performance</a>. I don&#x27;t think we&#x27;ll care about perf here, so using <code>str::encode_utf16</code> seems fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/samypr100">@samypr100</a> on <code>crates/uv/src/windows_exception.rs</code>:45 on 2025-07-14 17:12</div>
            <div class="timeline-body"><p>Was this meant to be fixed? (noticed it still there in main)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/samypr100">@samypr100</a> reviewed on 2025-07-14 17:12</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:45 on 2025-07-14 23:26</div>
            <div class="timeline-body"><p>Intentionally not yet to save the CI, but #14619 fixes this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/geofft">@geofft</a> on <code>crates/uv/src/windows_exception.rs</code>:79 on 2025-07-14 23:26</div>
            <div class="timeline-body"><p>Took a stab at this in #14619. Style feedback is more than welcome.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/geofft">@geofft</a> reviewed on 2025-07-14 23:27</div>
            <div class="timeline-body"></div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:53:05 UTC
    </footer>
</body>
</html>
