<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Use daemon to run Python build hooks - astral-sh/uv #895</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Use daemon to run Python build hooks</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/uv/pull/895">#895</a>
        opened by <a href="https://github.com/zanieb">@zanieb</a>
        on 2024-01-12 04:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a></div>
            <div class="timeline-body"><p>Closes <a href="https://github.com/astral-sh/puffin/issues/846">astral-sh/puffin#846</a></p>
<p>Spawns a single Python process per source distribution build instead of one per build backend hook we call. The Python process is a custom script providing PEP 517 / 660 build hook RPC. We use simple newline terminated messages to communicate between the parent Rust process and the child Python process. Since standard out is reserved for this communication, we redirect all output from the build backend during hook calls into a separate temporary file. The file path is sent from the Python daemon to the Rust parent so it can recover the hook&#x27;s output for display on failure.</p>
<p>There&#x27;s a great deal of complexity in this implementation which mostly arises from:</p>
<ul>
<li>Proper management the daemon process on the Rust side, e.g. non-blocking and no zombie processes</li>
<li>Redirection of file streams, error capturing, and reloading of modules on the Python side</li>
</ul>
<p>The goal here is to improve performance by avoiding the 10ms overhead of invoking a Python process on each hook call. When running a daemon, we only pay the 10ms overhead cost once and subsequent hook calls should have &lt;1ms of overhead. However, we can only use a daemon for a single build since it needs to be running in the correct virtual environment. Consequently, we only make 2-3 hook calls per daemon so there&#x27;s a small limit to the total reduction in overhead we can see in practice. We could explore passing the virtual environment via RPC and &quot;hot loading&quot; it per build; then we could re-use the daemon for many more builds and hook calls.</p>
<p>Additionally, <a href="https://github.com/astral-sh/puffin/issues/846">astral-sh/puffin#846</a> notes that build backend imports are slow. Without a daemon, we must pay the cost of importing the build backend on each hook call. The initial daemon implementation cached imports to reduce this overhead as much as possible. However, since we add packages to the build environment <em>after</em> the daemon is started it is actually <em>not</em> safe to cache imports. In practice, the daemon needed to <em>force</em> all modules to be reloaded on each hook call for builds to succeed. Perhaps we could limit the effect of this by adding a special command to reset modules and only do so after the parent changes the build environment. Regardless, this adds significant complexity to the implementation and may be brittle in the real world.</p>
<p>Rough benchmarks e.g. running <code>pip sync</code> with <code>flask==3.0.0</code> and the <code>--no-binary</code> flag (#956) to force source distribution builds show no clear improvement. Of course, we could spend time optimizing the Rust side of this implementation (the Python side is already relatively optimized) but I&#x27;m not sure if it&#x27;s worth going deeper into at this time.</p>
<p>In implementing this, there are <em>some</em> gains beyond performance. For example, we now have much more detailed error types for failures in hooks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Initial commit of daemon for running Python build hooks&quot; to &quot;Use daemon to run Python build hooks&quot; by <a href="https://github.com/zanieb">@zanieb</a> on 2024-01-12 04:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a> reviewed on 2024-01-17 20:07</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zanieb">@zanieb</a> on <code>crates/puffin-build/src/daemon.rs</code>:352 on 2024-01-17 20:07</div>
            <div class="timeline-body"><p>These have file paths and we should create async background tasks to read from these streams so we can report stdout and stderr from the hook on failure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2024-01-18 17:16</div>
            <div class="timeline-body"><p>Example benchmarks</p>
<p>Install <code>flask==3.0.0</code></p>
<pre><code>$ hyperfine --min-runs 20 \
    --command-name branch \
    --command-name baseline \
    &#x27;./target/release/branch pip install flask==3.0.0 --no-binary --reinstall --no-cache&#x27; \
    &#x27;./target/release/baseline pip install flask==3.0.0 --no-binary --reinstall --no-cache&#x27;


Benchmark 1: branch
  Time (mean ± σ):      3.663 s ±  0.075 s    [User: 3.616 s, System: 1.900 s]
  Range (min … max):    3.535 s …  3.833 s    20 runs
 
Benchmark 2: baseline
  Time (mean ± σ):      3.895 s ±  0.637 s    [User: 3.822 s, System: 1.948 s]
  Range (min … max):    3.586 s …  6.389 s    20 runs
 
  Warning: Statistical outliers were detected. Consider re-running this benchmark on a quiet system without any interferences from other programs. It might help to use the &#x27;--warmup&#x27; or &#x27;--prepare&#x27; options.
 
Summary
  branch ran
    1.06 ± 0.18 times faster than baseline
</code></pre>
<p>Install a scenario that uses hatchling to build a trivial package</p>
<pre><code>$ hyperfine --min-runs 20 \
    --command-name branch \
    --command-name baseline \
    &#x27;./target/release/branch pip install a-614d801c==1.0.0 --extra-index-url https://test.pypi.org/simple/ --no-binary --reinstall --no-cache&#x27; \
    &#x27;./target/release/baseline pip install a-614d801c==1.0.0 --extra-index-url https://test.pypi.org/simple/ --no-binary --reinstall --no-cache&#x27;

Benchmark 1: branch
  Time (mean ± σ):      5.218 s ±  0.229 s    [User: 4.849 s, System: 1.871 s]
  Range (min … max):    4.997 s …  5.966 s    20 runs
 
Benchmark 2: baseline
  Time (mean ± σ):      5.649 s ±  0.231 s    [User: 5.446 s, System: 2.080 s]
  Range (min … max):    5.336 s …  6.094 s    20 runs
 
Summary
  branch ran
    1.08 ± 0.06 times faster than baseline
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/zanieb">@zanieb</a> on 2024-01-19 17:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-build/src/daemon.rs</code>:96 on 2024-01-29 19:55</div>
            <div class="timeline-body"><p>In the above, I see a lot of <code>unwrap()</code> that looks related to input from the daemon response. I suspect those should be converted to errors? (Since we own the daemon though, you might insist that invalid responses from the daemon should provoke a panic in this program. Which is maybe fine... But a comment indicating that would be good hah. And I do see other error types being used for invalid input.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-build/src/daemon.rs</code>:13 on 2024-01-29 19:58</div>
            <div class="timeline-body"><p>Separate from the question of whether to merge imports together, I would at least say it&#x27;s very common to group imports: std, then external crates and finally crate internal. But I think std is mixed with external crates above, and crate internal imports are mixed with other external crate imports here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on <code>crates/puffin-build/src/daemon.rs</code>:321 on 2024-01-29 20:01</div>
            <div class="timeline-body"><p>I think this could be a <code>&amp;[&amp;str]</code>. And then the <code>commands.append(&amp;mut args);</code> call below could be changed to <code>commands.extend_from_slice(args);</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/BurntSushi">@BurntSushi</a> reviewed on 2024-01-29 20:03</div>
            <div class="timeline-body"><p>Nice! I did a quick review of the Rust code in this PR, and I think at a high level everything looks pretty good to me. I think my only high level objection/concern would be the use of async I/O for something like this, but in this context, given that puffin uses async elsewhere, it probably makes sense to do it for this too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zanieb">@zanieb</a> reviewed on 2024-01-29 21:22</div>
            <div class="timeline-body"></div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Review comment by <a href="https://github.com/zanieb">@zanieb</a> on <code>crates/puffin-build/src/daemon.rs</code>:96 on 2024-01-29 21:22</div>
            <div class="timeline-body"><p>Almost all of the unwraps are just WIP artifacts</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:43:10 UTC
    </footer>
</body>
</html>
