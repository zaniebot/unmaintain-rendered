```yaml
number: 1172
title: Eagerly turning a bound method into a callable leads to wrong signature
type: issue
state: open
author: sharkdp
labels:
  - bug
  - calls
  - attribute access
assignees: []
created_at: 2025-09-11T17:46:58Z
updated_at: 2026-01-09T02:50:21Z
url: https://github.com/astral-sh/ty/issues/1172
synced_at: 2026-01-10T01:56:40Z
```

# Eagerly turning a bound method into a callable leads to wrong signature

---

_Issue opened by @sharkdp on 2025-09-11 17:46_

This is very similar to #1169, but since we've talked about this example a few times over the last days, here is our current handling of it:

```py
from typing import Self, Callable

class Base:
    def method(self, other: Self) -> bool:
        return True

class Derived(Base):
    pass

# This call succeeds, as it should (with a method-scoped `Self` typevar)
Derived().method(Base())

# However, this reveals `Derived.method(other: Derived) -> bool`,
# which seems to contradict the successful call right above
reveal_type(Derived().method)

# Similarly, this assignment should not lead to an error, but currently does:
callable: Callable[[Base], bool] = Derived().method
```

https://play.ty.dev/8410eba7-30ab-44f8-8b1c-15fa00937b27

---

_Label `bug` added by @sharkdp on 2025-09-11 17:46_

---

_Label `calls` added by @sharkdp on 2025-09-11 17:46_

---

_Label `attribute access` added by @sharkdp on 2025-09-11 17:46_

---

_Assigned to @sharkdp by @sharkdp on 2025-09-11 17:47_

---

_Comment by @sharkdp on 2025-09-11 17:53_

The solution to this and #1169 will be the same: to not bind `self` eagerly when turning a bound method object into a `Callable` type. Instead, we're planning to do the binding of `self` lazily, keeping track of the bound instance type on `CallableSignature`.

---

_Comment by @sharkdp on 2025-09-12 07:55_

And here is another related problem:
```py
from __future__ import annotations
from typing import Callable

class A: ...
class B: ...

class C[T]:
    x: T

    def only_for_int(self: C[int], x: A) -> B:
        return B()

callable1: Callable[[A], B] = C[int]().only_for_int

callable2: Callable[[A], B] = C[str]().only_for_int  # this should be an error, but currently is not
```

---

_Unassigned @sharkdp by @sharkdp on 2025-09-30 07:58_

---

_Added to milestone `Stable` by @carljm on 2026-01-09 02:50_

---
