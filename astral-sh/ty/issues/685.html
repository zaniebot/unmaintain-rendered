<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incomplete narrowing with terminal statement inside nested `if`s - astral-sh/ty #685</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Incomplete narrowing with terminal statement inside nested <code>if</code>s</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/685">#685</a>
        opened by <a href="https://github.com/abhijeetbodas2001">@abhijeetbodas2001</a>
        on 2025-06-19 22:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/abhijeetbodas2001">@abhijeetbodas2001</a></div>
            <div class="timeline-body">Summary
<p>Consider this example:</p>
<pre><code>def _(val: int | None):
  if val is None:
    if True:
      return

  reveal_type(val) # revealed: int | None, should be just `int`
</code></pre>
<p>We expect that <code>val</code> should be narrowed to just <code>int</code> at the end. That is also what <code>pyright</code> and <code>mypy</code> do.</p>
<p>However, for that to happen, we currently depend on the branch with the <code>val is None</code> narrowing constraint <em>not</em> being merged into the main flow.</p>
<p>The decision to not merge is taken only when the body of the outer <code>if</code> has a reachability of <code>ALWAYS_FALSE</code> <em>at the time of building the semantic index</em>, as explained in the code below:</p>
<p>https://github.com/astral-sh/ruff/blob/ce0a32aadb16c9e2aea74013b5f0e105c2737253/crates/ty_python_semantic/src/semantic_index/use_def.rs#L956-L970</p>
<pre><code>    pub(super) fn merge(&amp;mut self, snapshot: FlowSnapshot) {
        // As an optimization, if we know statically that either of the snapshots is always
        // unreachable, we can leave it out of the merged result entirely. Note that we cannot
        // perform any type inference at this point, so this is largely limited to unreachability
        // via terminal statements. If a flow&#x27;s reachability depends on an expression in the code,
        // we will include the flow in the merged result; the reachability constraints of its
        // bindings will include this reachability condition, so that later during type inference,
        // we can determine whether any particular binding is non-visible due to unreachability.
        if snapshot.reachability == ScopedReachabilityConstraintId::ALWAYS_FALSE {
            return;
        }
        if self.reachability == ScopedReachabilityConstraintId::ALWAYS_FALSE {
            self.restore(snapshot);
            return;
        }
</code></pre>
<p>Which basically means, that the body of the outer <code>if</code> needs to have a bare terminal statement, for <code>None</code> to be removed from <code>val</code>&#x27;s initial type of <code>int | None</code>.</p>
<p>But in the above case, the terminal statement here, <code>return</code>, itself has a reachability constraint of <code>True</code>. In fact, in place of <code>True</code> any expression which statically evaluates to a truthy value will result in incomplete narrowing like above. But because we do not have access to type information at the time of building the semantic index, we cannot decide <em>not</em> to merge for such scenarios.</p>
<p>This issue also affects the <code>ReturnsNever</code> constraints that we use for handling calls like <code>sys.exit()</code> --  <a href="https://github.com/astral-sh/ruff/blob/main/crates/ty_python_semantic/resources/mdtest/terminal_statements.md#type-narrowing">see this TODO in the tests</a>.</p>
<p>To correctly narrow down <code>val</code>&#x27;s type during type inference phase, one way could be the following:
During semantic index building, whenever we encounter a terminal statement, before marking the branch as unreachable, take the current reachability, negate it, and add the result as a narrowing constraint to the currently tracked bindings.
That way, during type inference, the inferred type of <code>val</code> would be the one which does not allow any terminal statements to be hit.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Incomplete narrowing with terminal statement nested inside multiple `if`s&quot; to &quot;Incomplete narrowing with terminal statement inside nested `if`s&quot; by <a href="https://github.com/abhijeetbodas2001">@abhijeetbodas2001</a> on 2025-06-19 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">narrowing</span> added by <a href="https://github.com/carljm">@carljm</a> on 2025-06-19 22:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">control flow</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-23 11:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;GA&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-07-23 22:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dedebenui">@dedebenui</a> on 2025-11-16 14:30</div>
            <div class="timeline-body"><p>I&#x27;ve encountered something similar, but I&#x27;m not sure if it stems from the same problem or not. Let me know if I should open another issue.</p>
<pre><code>from typing import reveal_type


def compute_properties(peak_power: float | None = None, energy: float | None = None) -&gt; float:
    if peak_power is None and energy is None:
        raise ValueError(&quot;please provide either peak power or energy&quot;)
    ... 
    if peak_power is None:
        reveal_type(energy)  # int | float | None
        peak_power = energy / 2

    return peak_power
</code></pre>
<p>Ty says that <code>energy</code> in <code>energy / 2</code> could still be <code>None</code> and therefore it&#x27;s not safe to <code>/ 2</code>, but logically, <code>energy</code> is <code>not None</code> in that case. Of course I can rewrite this with nested <code>if</code>s, but I prefer the clarity of short-circuiting at the start of the function rather than 2 levels of <code>if</code> deep.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-11-17 15:42</div>
            <div class="timeline-body"><p>@dedebenui That&#x27;s a different issue, and it&#x27;s expected behavior; all other type checkers (mypy, pyright, pyrefly) give the same result as ty there. After the initial two lines we cannot conclude anything about the type of <code>peak_power</code> or <code>energy</code>, because we don&#x27;t know which one of them is not-None. After <code>if peak_power is None</code> in principle we can know that <code>energy</code> must therefore not be <code>None</code>, but this requires tracking an implication relationship between the type of <code>peak_power</code> and the type of <code>energy</code> (or internally rearranging the control flow using a technique called &quot;splitting and merging&quot;), which is a level of control-flow analysis that no Python type checker currently does.</p>
<p>I wouldn&#x27;t rule out the possibility that someday we might like to tackle this, so you&#x27;re welcome to file an issue for it, but it&#x27;s not likely to make it onto the roadmap in the short or medium term.</p>
<p>One alternative workaround to rearranging control flow is just to use <code>assert energy is not None</code> to inform the type checker of what you already know to be true.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-11 19:51</div>
            <div class="timeline-body"><p>Discussed this with @sharkdp this morning and decided that this really is the same issue as #690, so closing as duplicate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2025-12-11 19:51</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:24:53 UTC
    </footer>
</body>
</html>
