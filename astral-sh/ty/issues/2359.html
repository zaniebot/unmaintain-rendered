<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No bidirectional inference for inferring the parameter types of `lambda` functions - astral-sh/ty #2359</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>No bidirectional inference for inferring the parameter types of <code>lambda</code> functions</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2359">#2359</a>
        opened by <a href="https://github.com/hyperkai">@hyperkai</a>
        on 2026-01-06 09:32
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/hyperkai">@hyperkai</a></div>
            <div class="timeline-body">Summary
<p>*Memo:</p>
<ul>
<li>ty check</li>
<li>ty 0.0.7</li>
<li>Python 3.14.0</li>
</ul>
<p>Using the type alias created by the <a href="https://docs.python.org/3/reference/simple_stmts.html#the-type-statement">type statement</a> with <code>**P</code>, ty doesn&#x27;t work properly, giving no error for <code>v2</code> as shown below:</p>
<p>*Memo:</p>
<ul>
<li>mypy, pyright and pyrefly work properly, giving error for <code>v2</code>.</li>
</ul>
<pre><code>from collections.abc import Callable

type TA[**P] = Callable[P, None]

lam: TA[int] = lambda x: print(x)

v1: TA[int] = lam # No error
v2: TA[str] = lam # No error
</code></pre>
Version
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 09:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type aliases</span> added by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 09:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Using the type alias created by the type statement with `**P`, ty doesn&#x27;t work properly&quot; to &quot;PEP-695 type aliases generic over ParamSpecs are not supported &quot; by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 09:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type aliases</span> removed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 12:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;PEP-695 type aliases generic over ParamSpecs are not supported &quot; to &quot;No bidirectional inference for inferring the parameter types of `lambda` functions&quot; by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 12:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 12:56</div>
            <div class="timeline-body"><p>Thanks for the report! This actually doesn&#x27;t seem to have anything to do with type aliases, but it has everything to do with lambdas.</p>
<p>We can see that if we use a function defined using a <code>def</code> statement, ty has the behaviour you&#x27;d expect here:</p>
<pre><code>from collections.abc import Callable

type TA[**P] = Callable[P, None]

lam: TA[int] = lambda x: print(x)
reveal_type(lam)  # (x) -&gt; Unknown
v1: TA[int] = lam # No error
v2: TA[str] = lam # No error

def f(x: int, /) -&gt; None: pass

not_lam: TA[int] = f
reveal_type(not_lam)  # def f(x: int, /) -&gt; None
v3: TA[int] = not_lam
v4: TA[str] = not_lam  # error, as expected
</code></pre>
<p>What&#x27;s happening is that for your <code>lambda</code> case, we don&#x27;t yet use the annotated type of the variable (or any other type context) to inform how we should infer the type of a <code>lambda</code>&#x27;s parameter types. This means that the inferred type of the <code>lam</code> variable is <code>(x) -&gt; Unknown</code> despite the explicit type annotation of <code>TA[int]</code>. We allow an object with type <code>(x) -&gt; Unknown</code> to be assigned to the variable annotated with <code>TA[int]</code>, because <code>(x) -&gt; Unknown</code> is assignable to the type <code>Callable[[int], None]</code>, but that doesn&#x27;t alter our locally inferred type for the <code>lam</code> variable.</p>
<p>Since type aliases generic over paramspecs seem to be working fine if you use a function defined via a <code>def</code> statement, this seems to be just a duplicate of #181</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 12:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-06 16:53</div>
            <div class="timeline-body"><p>I think for the specific OP example, #136 would be sufficient even without any bidirectional typing of lambdas. With that change we&#x27;d just respect the annotated <code>TA[int]</code> type, and it wouldn&#x27;t matter what we infer for the lambda in this case (beyond that we infer something assignable to <code>TA[int]</code>, which we already do).</p>
<p>But I think it&#x27;s more common for lambdas to be used &quot;inline&quot;, without this kind of explicitly annotated assignment to a callable type, so #181 is also important -- just not necessary for this example.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 17:16</div>
            <div class="timeline-body"><blockquote>
<p>I think for the specific OP example, <a href="https://github.com/astral-sh/ty/issues/136">#136</a> would be sufficient even without any bidirectional typing of lambdas. With that change we&#x27;d just respect the annotated <code>TA[int]</code> type, and it wouldn&#x27;t matter what we infer for the lambda in this case (beyond that we infer something assignable to <code>TA[int]</code>, which we already do).</p>
</blockquote>
<p>Yes, either change would fix this, of course</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:58 UTC
    </footer>
</body>
</html>
