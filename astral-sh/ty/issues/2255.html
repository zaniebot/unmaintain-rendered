<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Self should be equivalent to bound typevar, but only Self causes Liskov violation - astral-sh/ty #2255</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Self should be equivalent to bound typevar, but only Self causes Liskov violation</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/2255">#2255</a>
        opened by <a href="https://github.com/kamalfarahani">@kamalfarahani</a>
        on 2025-12-29 08:03
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/kamalfarahani">@kamalfarahani</a></div>
            <div class="timeline-body"><h3>Question</h3>
<p>I am experimenting with <code>typing.Self</code> (introduced in <a href="https://peps.python.org/pep-0673/">PEP 673</a>) to define a <code>Monoid</code> interface. According to the PEP, <code>Self</code> can be used to annotate parameters that expect instances of the current class.</p>
<p>However, when I attempt to narrow the type of the parameter in a subclass, my type checker <code>ty</code>  flags an error.</p>
<pre><code class="language-python">class Monoid(ABC):
    @abstractmethod
    def op(self, other: Self) -&gt; Self:
        raise NotImplementedError()


class IntAdditionMonoid(Monoid):
    def __init__(self, value: int):
        self.value = value

    def op(self, other: IntAdditionMonoid) -&gt; Self:
        return IntAdditionMonoid(
            self.value + other.value,
        )
</code></pre>
<p>from what I understand from this <a href="https://peps.python.org/pep-0673/">PEP</a>:</p>
<blockquote>
<p>Another use for Self is to annotate parameters that expect instances of the current class</p>
</blockquote>
<p>If the PEP states that <code>Self</code> represents the &quot;current class,&quot; why am I unable to replace the <code>Self</code> annotation with the concrete class name in the subclass implementation?</p>
<h3>Version</h3>
<p>ty 0.0.7</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @kamalfarahani on 2025-12-29 08:03</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kamalfarahani">@kamalfarahani</a> on 2025-12-29 08:32</div>
            <div class="timeline-body"><p>Another observation is that in the PEP 673 it's noted that the <code>Self</code> behavior should be the same as the following code:</p>
<pre><code class="language-python">M = TypeVar(
    &quot;M&quot;,
    bound=&quot;Monoid&quot;,
)


class Monoid(ABC):
    @abstractmethod
    def op(self: M, other: M) -&gt; M:
        raise NotImplementedError()


class IntAdditionMonoid(Monoid):
    def __init__(self, value: int):
        self.value = value

    def op(self, other: IntAdditionMonoid) -&gt; IntAdditionMonoid:
        return IntAdditionMonoid(
            self.value + other.value,
        )
</code></pre>
<p>But with this implementation, <code>ty</code> won't yell at me, isn't it inconsistent behavior?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-29 11:02</div>
            <div class="timeline-body"><p>Pyrefly seems to be the only type checker that accepts this but I'm not sure why (I'm not a typing expert myself). All other type checkers (Pyright, mypy) reject this program.  I also couldn't find any test resembling your example in our extensive <a href="https://github.com/astral-sh/ruff/blob/e42cdf84957b178dc7e37aed0f2b1f4d5f0c272a/crates/ty_python_semantic/resources/mdtest/liskov.md#L4">liskov test suite</a>. I'm sorry that I don't know the answer to this but someone more knowledgable than I in Pythoon typing will get back to you, once they're back from their PTO. Happy holidays.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @MichaReiser on 2025-12-29 11:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-29 19:00</div>
            <div class="timeline-body"><blockquote>
<p>Pyrefly seems to be the only type checker that accepts this but I'm not sure why (I'm not a typing expert myself). All other type checkers (Pyright, mypy) reject this program. I also couldn't find any test resembling your example in our extensive <a href="https://github.com/astral-sh/ruff/blob/e42cdf84957b178dc7e37aed0f2b1f4d5f0c272a/crates/ty_python_semantic/resources/mdtest/liskov.md#L4">liskov test suite</a>. I'm sorry that I don't know the answer to this but someone more knowledgable than I in Pythoon typing will get back to you, once they're back from their PTO. Happy holidays.</p>
</blockquote>
<p>Mypy does reject the program as written in the above snippet, but not because of a Liskov violation. It (correctly) complains that <code>IntAdditionMonoid.op</code> returns <code>IntAdditionMonoid</code> when it's annotated as returning <code>Self</code>, but there's no Liskov diagnostic.</p>
<p>If we change the snippet slightly to the following, ty and pyright issue a Liskov diagnostic (and only a Liskov diagnostic), but mypy and pyrefly do not:</p>
<pre><code class="language-py">from __future__ import annotations
from abc import ABC, abstractmethod
from typing import Self

class Monoid(ABC):
    @abstractmethod
    def op(self, other: Self) -&gt; Self:
        raise NotImplementedError()


class IntAdditionMonoid(Monoid):
    def __init__(self, value: int):
        self.value = value

    def op(self, other: IntAdditionMonoid) -&gt; Self:
        return self.__class__(
            self.value + other.value,
        )
</code></pre>
<p>I think mypy/pyrefly are correct here, and ty/pyright are incorrect. This seems to me like it's a sound override; I don't think this breaks the Liskov Substitution Principle. The underlying bug is probably somewhere in <code>Signature::has_relation_to_impl</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @AlexWaygood on 2025-12-29 19:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @AlexWaygood on 2025-12-29 19:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Why this case is violation of Liskov Substitution Principle" to "Overriding a `foo: Self` parameter with `foo: <current class>` in a subclass should not be flagged as a Liskov violation" by @AlexWaygood on 2025-12-29 19:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-29 19:09</div>
            <div class="timeline-body"><p>It looks to me like mypy and pyrefly are both OK with both versions (with <code>Self</code> and with <code>M</code>). Pyright errors on both versions. I agree that the two versions should be consistent (and I'm not sure why they diverge for us currently, since we literally implement <code>Self</code> as a bounded typevar.)</p>
<p>I think that this is not a safe override, though, and both versions <em>should</em> error. (That is, pyright is correct, mypy and pyrefly are wrong.) Imagine we also have <code>class StrAdditionMonoid(Monoid)</code>, defined similarly to <code>IntAdditionMonoid</code>. Now we have a function <code>def op(m1: Monoid, m2: Monoid): m1.op(m2)</code>. If we allow this override, then the call <code>m1.op(m2)</code> is unsound if <code>m1</code> is an <code>IntAdditionMonoid</code> and <code>m2</code> is a <code>StrAdditionMonoid</code> -- we will end up calling <code>IntAdditionMonoid.op</code> method with arguments that violate its annotations.</p>
<p>For the same reason, annotating <code>other: Self</code> on a subclass method is also unsound!</p>
<p>Covariant typing of binary operators is a known problematic case; it can't be done soundly. <code>IntAdditionMonoid</code> cannot restrict its <code>other</code> argument to be an <code>IntAdditionMonoid</code> (excluding other subclasses of <code>Monoid</code>) without breaking Liskov.</p>
<p>(EDIT: I wrote my comment before seeing Alex's comment -- and I had tested the top snippet with <code>-&gt; IntAdditionMonoid</code> on the subclass override, not the version with <code>-&gt; Self</code> as written -- because I actually copied and modified the second snippet.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Overriding a `foo: Self` parameter with `foo: <current class>` in a subclass should not be flagged as a Liskov violation" to "Self should be equivalent to bound typevar, but only Self causes Liskov violation" by @carljm on 2025-12-29 19:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-29 19:15</div>
            <div class="timeline-body"><p>Re-titled the issue, since I think the diagnostic on the Self version is correct -- the only mystery/bug here is why the explicit-TypeVar version does not behave the same as the Self version.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-12-29 19:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-29 19:27</div>
            <div class="timeline-body"><p>@carljm thanks -- agreed! This is indeed unsound:</p>
<pre><code class="language-pycon">% python                                           
Python 3.13.1 (main, Jan  3 2025, 12:04:03) [Clang 15.0.0 (clang-1500.3.9.4)] on darwin
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.
&gt;&gt;&gt; from __future__ import annotations
... from abc import ABC, abstractmethod
... from typing import Self
... 
... class Monoid(ABC):
...     @abstractmethod
...     def op(self, other: Self) -&gt; Self:
...         raise NotImplementedError()
... 
... class StrAdditionMonoid(Monoid):
...     def __init__(self, value: str):
...         self.value = value
... 
...     def op(self, other: StrAdditionMonoid) -&gt; Self:
...         return self.__class__(
...             self.value + other.value,
...         )
... 
... class IntAdditionMonoid(Monoid):
...     def __init__(self, value: int):
...         self.value = value
... 
...     def op(self, other: IntAdditionMonoid) -&gt; Self:
...         return self.__class__(
...             self.value + other.value,
...         )
... 
... def monoid_op(a: Monoid, b: Monoid):
...     a.op(b)
... 
... def unsound(a: IntAdditionMonoid, b: StrAdditionMonoid):
...     monoid_op(a, b)
...     
&gt;&gt;&gt; unsound(IntAdditionMonoid(42), StrAdditionMonoid(&quot;42&quot;))
Traceback (most recent call last):
  File &quot;&lt;python-input-1&gt;&quot;, line 1, in &lt;module&gt;
    unsound(IntAdditionMonoid(42), StrAdditionMonoid(&quot;42&quot;))
    ~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File &quot;&lt;python-input-0&gt;&quot;, line 32, in unsound
    monoid_op(a, b)
    ~~~~~~~~~^^^^^^
  File &quot;&lt;python-input-0&gt;&quot;, line 29, in monoid_op
    a.op(b)
    ~~~~^^^
  File &quot;&lt;python-input-0&gt;&quot;, line 25, in op
    self.value + other.value,
    ~~~~~~~~~~~^~~~~~~~~~~~~
TypeError: unsupported operand type(s) for +: 'int' and 'str'
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kamalfarahani">@kamalfarahani</a> on 2025-12-29 21:45</div>
            <div class="timeline-body"><p>@carljm</p>
<blockquote>
<p>I think that this is not a safe override, though, and both versions <em>should</em> error. (That is, pyright is correct, mypy and pyrefly are wrong.)</p>
</blockquote>
<p>Based on the specifications in <strong>PEP 673</strong>, I believe <code>mypy</code> and <code>pyrefly</code> are correctly implementing the standard, while <code>ty</code> and <code>pyright</code> appear to be in error. My reasoning centers on how <code>Self</code> constrains the relationship between parameters within a class hierarchy.</p>
<h3>1. The Equivalence of <code>Self</code></h3>
<p>According to the PEP, the use of <code>Self</code> in a method signature is effectively syntactic sugar for a generic type variable bound to the enclosing class. Therefore, this definition:</p>
<pre><code class="language-python">class Monoid(ABC):
    @abstractmethod
    def op(self, other: Self) -&gt; Self:
        ...

</code></pre>
<p>Is semantically equivalent to using a type variable  bound to <code>Monoid</code>:</p>
<pre><code class="language-python">class Monoid(ABC):
    @abstractmethod
    def op[M: Monoid](self: M, other: M) -&gt; M:
        ...

</code></pre>
<h3>2. Type Consistency Requirements</h3>
<p>The critical takeaway from this equivalence is that <code>self</code> and <code>other</code> must be of the <strong>exact same type</strong> . In a concrete implementation, this means <code>type(self)</code> must be identical to <code>type(other)</code>.</p>
<h3>3. Implications for Heterogeneous Types</h3>
<p>If we accept the logic above, the following function should fail type checking:</p>
<pre><code class="language-python">def monoid_op(a: Monoid, b: Monoid):
    a.op(b)  # Should raise a type error

</code></pre>
<p><strong>Reasoning:</strong> The type checker cannot guarantee that <code>a</code> and <code>b</code> are the same subtype of <code>Monoid</code>. For example, if <code>IntegerMonoid</code> and <code>StringMonoid</code> both inherit from <code>Monoid</code>, passing a string monoid to an integer monoid's <code>op</code> method would violate the <code>Self</code> constraint.</p>
<p>Since <code>a</code> and <code>b</code> are typed only as the base <code>Monoid</code>, their specific subclasses are unknown and potentially incompatible, making the call to <code>a.op(b)</code> type-unsafe.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-29 21:59</div>
            <div class="timeline-body"><blockquote>
<p>The critical takeaway from this equivalence is that <code>self</code> and <code>other</code> must be of the <strong>exact same type</strong> . In a concrete implementation, this means <code>type(self)</code> must be identical to <code>type(other)</code>.</p>
</blockquote>
<p>No, this is not how generic functions work. The requirement is simply that <code>M</code> must solve to some type which satisfies all constraints. Pyright and mypy both allow this code, as they should:</p>
<pre><code class="language-py">class A:
    pass

class B(A):
    pass

class C(A):
    pass

def func[T: A](x: T, y: T) -&gt; T:
    ...

reveal_type(func(B(), C()))
</code></pre>
<p>Pyright solves the type variable to <code>B | C</code>; mypy solves it to <code>A</code>. Both are valid solutions.</p>
<p>The exception is constrained typevars (e.g. <code>[T: (A, B)]</code>), which are unusual, in that they list a specific set of types, and the typevar must solve to exactly one of those types. But that's not relevant here, since there is no constrained type variable.</p>
<blockquote>
<p>If we accept the logic above, the following function should fail type checking:</p>
<p>def monoid_op(a: Monoid, b: Monoid):
a.op(b)  # Should raise a type error</p>
</blockquote>
<p>Yes, this is a good illustration of why we cannot, and should not, accept the (incorrect) requirement that a typevar must solve to the precise concrete type of every argument. Requiring type checkers to reject all generic calls with multiple arguments mapping to the same type variable if they cannot prove same-origin for all of those arguments, would be a massive change to the Python type system resulting in tons of false positives.</p>
<p>Mypy and pyrefly do not implement the interpretation of generics you are proposing; they would not error on the <code>a.op(b)</code> call either. They just choose to allow some forms of unsound overrides of generic methods.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kamalfarahani">@kamalfarahani</a> on 2026-01-01 10:39</div>
            <div class="timeline-body"><p>@carljm</p>
<p>I've come across an interesting case: how is <code>Self</code> handled when used in a protocol? Based on the logic, the code below should trigger a type error, but surprisingly, neither <code>mypy</code> nor <code>pyright</code> or <code>ty</code> flag it. Whatâ€™s the reasoning behind this?</p>
<pre><code class="language-python">from __future__ import annotations

from typing import Protocol, Self


class Semigroup(Protocol):
    def op(
        self: Self,
        other: Self,
    ) -&gt; Self: ...


class IntSum:
    def __init__(self, value: int):
        self.value = value

    def op(self, other: IntSum) -&gt; IntSum:
        return IntSum(
            self.value + other.value,
        )


class StringConcat:
    def __init__(self, value: str):
        self.value = value

    def op(self, other: StringConcat) -&gt; StringConcat:
        return StringConcat(
            self.value + other.value,
        )


def combine_semi[T: Semigroup](
    a: T,
    b: T,
) -&gt; T:
    return a.op(b)


x = combine_semi(
    IntSum(1),
    StringConcat(&quot;hello&quot;),
)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kamalfarahani">@kamalfarahani</a> on 2026-01-02 18:35</div>
            <div class="timeline-body"><blockquote>
<p>Covariant typing of binary operators is a known problematic case; it can't be done soundly. <code>IntAdditionMonoid</code> cannot restrict its <code>other</code> argument to be an <code>IntAdditionMonoid</code> (excluding other subclasses of <code>Monoid</code>) without breaking Liskov.</p>
</blockquote>
<p>As a solution for above problem I proposed the following addition to python typing which I think is related to the problems we discussed here:
https://github.com/python/typing/discussions/2143</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-04 21:39</div>
            <div class="timeline-body"><p>@kamalfarahani I agree with you, I think that type checkers (including ty) are behaving wrongly here: neither <code>IntSum</code> nor <code>StringConcat</code> should be considered to implement the <code>Semigroup</code> protocol in your example. This seems like a separate issue, so I opened #2323 to track it. Thanks!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:21:36 UTC
    </footer>
</body>
</html>
