<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expected `Iterable[Buffer]` when using `map(str, ...)` - astral-sh/ty #2087</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Expected `Iterable[Buffer]` when using `map(str, ...)`</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2087">#2087</a>
        opened by <a href="https://github.com/karlicoss">@karlicoss</a>
        on 2025-12-18 20:18
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/karlicoss">@karlicoss</a> on 2025-12-18 20:18</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>playground link: https://play.ty.dev/eab57770-64e1-44c8-940a-561b4340e9af</p>
<p>Consider the following program</p>
<pre><code class="language-py">from typing import Sequence, reveal_type

def test(command: Sequence[str]) -&gt; None:
    if isinstance(command, list):
        reveal_type(command)
        print(list(map(str, command)))

test(['echo', 'hello'])
</code></pre>
<p>This works in runtime, however since 0.0.3, ty is reporting a type error</p>
<pre><code>$ uv run --with ty==0.0.3 -m ty check test.py 
info[revealed-type]: Revealed type
 --&gt; test.py:5:21
  |
3 | def test(command: Sequence[str]) -&gt; None:
4 |     if isinstance(command, list):
5 |         reveal_type(command)
  |                     ^^^^^^^ `Sequence[str] &amp; Top[list[Unknown]]`
6 |         print(list(map(str, command)))
  |

error[invalid-argument-type]: Argument to function `__new__` is incorrect
 --&gt; test.py:6:29
  |
4 |     if isinstance(command, list):
5 |         reveal_type(command)
6 |         print(list(map(str, command)))
  |                             ^^^^^^^ Expected `Iterable[Buffer]`, found `Sequence[str] &amp; Top[list[Unknown]]`
7 |
8 | test(['echo', 'hello'])
  |
info: Matching overload defined here
    --&gt; stdlib/builtins.pyi:3839:13
     |
3837 |     else:
3838 |         @overload
3839 |         def __new__(cls, func: Callable[[_T1], _S], iterable: Iterable[_T1], /) -&gt; Self: ...
     |             ^^^^^^^                                 ----------------------- Parameter declared here
3840 |         @overload
3841 |         def __new__(cls, func: Callable[[_T1, _T2], _S], iterable: Iterable[_T1], iter2: Iterable[_T2], /) -&gt; Self: ...
     |
info: Non-matching overloads for function `__new__`:
info:   (cls, func: (_T1@__new__, _T2@__new__, /) -&gt; _S@map, iterable: Iterable[_T1@__new__], iter2: Iterable[_T2@__new__], /) -&gt; Self@__new__
info:   (cls, func: (_T1@__new__, _T2@__new__, _T3@__new__, /) -&gt; _S@map, iterable: Iterable[_T1@__new__], iter2: Iterable[_T2@__new__], iter3: Iterable[_T3@__new__], /) -&gt; Self@__new__
info:   (cls, func: (_T1@__new__, _T2@__new__, _T3@__new__, _T4@__new__, /) -&gt; _S@map, iterable: Iterable[_T1@__new__], iter2: Iterable[_T2@__new__], iter3: Iterable[_T3@__new__], iter4: Iterable[_T4@__new__], /) -&gt; Self@__new__
info:   (cls, func: (_T1@__new__, _T2@__new__, _T3@__new__, _T4@__new__, _T5@__new__, /) -&gt; _S@map, iterable: Iterable[_T1@__new__], iter2: Iterable[_T2@__new__], iter3: Iterable[_T3@__new__], iter4: Iterable[_T4@__new__], iter5: Iterable[_T5@__new__], /) -&gt; Self@__new__
info:   (cls, func: (...) -&gt; _S@map, iterable: Iterable[Any], iter2: Iterable[Any], iter3: Iterable[Any], iter4: Iterable[Any], iter5: Iterable[Any], iter6: Iterable[Any], /, *iterables: Iterable[Any]) -&gt; Self@__new__
info: rule `invalid-argument-type` is enabled by default

Found 2 diagnostics
</code></pre>
<p>This only started happening in 0.0.3; 0.0.2 works without type error. Interesting enough, on 0.0.2 <code>reveal_type</code> still shows <code>Sequence[str] &amp; Top[list[Unknown]]</code>, so felt like possible typeshed change? But doesn't look like there've been any recent typeshed syncs, so not sure what to make of it! https://github.com/astral-sh/ruff/commits/main/</p>
<p>Funny enough, if we change to <code>isinstance(command, list[str])</code>, this type checks in <code>0.0.3</code></p>
<pre><code>4 |     if isinstance(command, list[str]):
5 |         reveal_type(command)
  |                     ^^^^^^^ `Sequence[str]`
</code></pre>
<p>However</p>
<ul>
<li>it's not allowed in runtime: <code>TypeError: isinstance() argument 2 cannot be a parameterized generic</code></li>
<li>the inferred type isn't correct, should be <code>list[str]</code>? (I guess this is irrelevant since ideally ty would flag this as invalid in runtime anyway)</li>
</ul>
<p>Apologies if it's an existing issue, didn't really manage to find anything similar, and encountered independently in two separate projects, so figured worth reporting so people can find it in search.</p>
<h3>Version</h3>
<p>ty 0.0.3/latest master</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 20:30</div>
            <div class="timeline-body"><p>Thanks for the report!</p>
<p>(BTW I'm seeing the same behavior on this snippet from ty 0.0.2 and 0.0.3, so I can't replicate your result that it passes on 0.0.2.)</p>
<p>This is intentional (and correct) behavior from ty; the behavior of other type checkers is unsound here and allows effectively bypassing variance entirely. It &quot;works at runtime&quot; in the case of the particular call you are making, but consider:</p>
<pre><code class="language-py">def takes_sequence_of_int(x: Sequence[int]):
    if isinstance(x, list):
        # ty errors on the next line; if we narrowed to `list[int]`, we'd consider it ok
        x.append(99)

my_bools: list[bool] = [True, False]
# this is valid: `list[bool]` is assignable to `Sequence[int]`
takes_sequence_of_int(my_bools)
# now we have `[True, False, 99]` and the type checker thinks it is still `list[bool]`
</code></pre>
<p>What the type <code>Sequence[int] &amp; Top[list[Unknown]]</code> is telling you is simply that a <code>Sequence[int]</code> which is a list at runtime is not necessarily a <code>list[int]</code>, it could be a <code>list[bool]</code>, or a list of any other subtype of <code>int</code>.</p>
<blockquote>
<p>Funny enough, if we change to <code>isinstance(command, list[str])</code>, this type checks in <code>0.0.3</code></p>
</blockquote>
<p>Yes, we should error on that, thank you! Filed https://github.com/astral-sh/ty/issues/2088</p>
<p>Closing this issue as &quot;not planned&quot; since ty is working as intended here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-12-18 20:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/karlicoss">@karlicoss</a> on 2025-12-18 21:04</div>
            <div class="timeline-body"><blockquote>
<p>This is intentional (and correct) behavior from ty</p>
</blockquote>
<p>Ah thanks @carljm your explanation makes sense. I tried rewriting original code to avoid <code>isinstance(..., list)</code> checks, since in my original case I was using it covariantly/read only anyway, so I rewrote</p>
<pre><code class="language-py">from typing import Sequence, reveal_type

def test(command: Sequence[str] | str) -&gt; str:
    reveal_type(command)
    if isinstance(command, str):
        return command
    else:
        reveal_type(command)
        parts = list(map(str, command))
        return ' '.join(parts)

print(test('echo hello'))
print(test(['echo', 'hello']))
</code></pre>
<p>However it still failed:</p>
<pre><code>error[invalid-argument-type]: Argument to function `__new__` is incorrect
  --&gt; test.py:9:31
   |
 7 |     else:
 8 |         reveal_type(command)
 9 |         parts = list(map(str, command))
   |                               ^^^^^^^ Expected `Iterable[Buffer]`, found `Sequence[str] &amp; ~str`
10 |         return ' '.join(parts)
   |
</code></pre>
<p>This one is different, right? I thought maybe it had to do with the fact that <code>Sequence[str] | str = Sequence[str]</code> (which is a bit of a special case in python), but replacing <code>str</code> with other type still results in similar issue.</p>
<p>It seems to work if I replace <code>command: list[str] | str</code>, so perhaps it's a case of https://github.com/astral-sh/ty/issues/1714, not sure.</p>
<blockquote>
<p>(BTW I'm seeing the same behavior on this snippet from ty 0.0.2 and 0.0.3, so I can't replicate your result that it passes on 0.0.2.)</p>
</blockquote>
<p>Hmm sorry, not sure what was going on with <code>0.0.2</code> during local testing -- retried from scratch with <code>uvx ty==0.0.2 check test.py</code> and it failed as you say.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 22:02</div>
            <div class="timeline-body"><p>Thanks for the follow up! That one definitely looks like a bug; it seems like we are not handling intersections correctly somehow when checking for compatibility with a protocol. I filed https://github.com/astral-sh/ty/issues/2091 to track this.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:54:35 UTC
    </footer>
</body>
</html>
