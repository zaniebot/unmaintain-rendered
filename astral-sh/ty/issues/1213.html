<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>infer type of parameter from decorator - astral-sh/ty #1213</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>infer type of parameter from decorator</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1213">#1213</a>
        opened by <a href="https://github.com/KotlinIsland">@KotlinIsland</a>
        on 2025-09-20 06:43
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/KotlinIsland">@KotlinIsland</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<pre><code class="language-py">from typing import Callable

def deco(fn: Callable[[int], None]) -&gt; None: ...

@deco
def f(i):
    reveal_type(i)  # Unknown
</code></pre>
<p>here i would expect <code>int</code></p>
<h3>Version</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-09-22 07:24</div>
            <div class="timeline-body"><p>Thank you for reporting this.</p>
<p>This looks like something that is rather hard to implement, but has limited practical benefit? It also seems like no other type checker supports this?</p>
<p>I'm not even sure if it's necessarily correct? Even if we see the application of the decorator to the function as a constraint on its parameters, it should only impose a <code>type(i) :&gt; int</code> subtyping constraint? So the type of <code>i</code> could be <code>int</code>, but it could also be a supertype of <code>int</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by @sharkdp on 2025-09-22 07:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-22 08:18</div>
            <div class="timeline-body"><blockquote>
<p>I'm not even sure if it's necessarily correct</p>
</blockquote>
<p>it is, this construct is identical to:</p>
<pre><code class="language-py">deco(lambda i: reveal_type(i))
</code></pre>
<p>and in this case it is quite clear to see that <code>i</code> should be <code>int</code></p>
<blockquote>
<p>This looks like something that is rather hard to implement</p>
</blockquote>
<p>i can't imagine it would be any harder to implement that the above case with a <code>lambda</code></p>
<blockquote>
<p>It also seems like no other type checker supports this?</p>
</blockquote>
<p>yes, noone else supports it, but i think this is a really slick feature</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-09-22 09:44</div>
            <div class="timeline-body"><blockquote>
<p>it is, this construct is identical to:</p>
<p>deco(lambda i: reveal_type(i))</p>
</blockquote>
<p>I don't see how this transformation addresses my comment regarding subtyping?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-22 10:02</div>
            <div class="timeline-body"><p>yes, your analysis is correct. it could be <code>int</code> or a super type of <code>int</code></p>
<p>these same rules would apply to any <code>Callable</code>:</p>
<pre><code class="language-py">class C:
    def __call__(self, i: object) -&gt; None: ...
deco(C())
</code></pre>
<p>what i have meant is: this should be a single point of constraint solving that mirrors the same semantics observed with a lambda, or any callable</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-09-22 11:11</div>
            <div class="timeline-body"><blockquote>
<p>yes, your analysis is correct. it could be <code>int</code> or a super type of <code>int</code></p>
</blockquote>
<p>In this case, the original request does not seem viable to me. I guess we could infer <code>object</code>, but that wouldn't be any more helpful than <code>Unknown</code>.</p>
<p>I will close this for now. Let me know if I'm missing something (I didn't get why the discussion around function vs lambda vs custom callable is even relevant here).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-09-22 11:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-22 13:31</div>
            <div class="timeline-body"><p>i really don't understand your position</p>
<p>if the decorator is typed as accepting <code>(int) -&gt; None</code>, then the value of <code>i</code> will <strong>always</strong> be <code>int</code> or lower. i don't understand your comment about inferring <code>object</code></p>
<p>would you infer <code>object</code> here?</p>
<pre><code class="language-py">def f(fn: Callable[[int], None]): ...

f(lambda i: print(i))
</code></pre>
<p>does that make sense?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-09-22 14:30</div>
            <div class="timeline-body"><blockquote>
<p>if the decorator is typed as accepting <code>(int) -&gt; None</code>, then the value of <code>i</code> will <strong>always</strong> be <code>int</code> or lower</p>
</blockquote>
<p>No, that was my point. The type of <code>i</code> could be <code>int</code> or <em>larger</em> (a supertype of <code>int</code>). There is nothing wrong with your original example if the function would assume <code>i</code> to be of type <code>object</code>. You could still apply an <code>(int) -&gt; None</code> decorator to it. This is fine:</p>
<pre><code class="language-py">from typing import Callable

def deco(fn: Callable[[int], None]): ...

@deco
def f1(i: int) -&gt; None:
    reveal_type(i)  # int

@deco
def f2(i: object) -&gt; None:
    reveal_type(i)  # object
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-22 14:52</div>
            <div class="timeline-body"><p>you could choose to annotate it with <code>object</code>, but what bearing does that have on the function?</p>
<p>could you explain why a user would ever want to annotate <code>i</code> as <code>object</code></p>
<p>it's comparable to inferring <code>[1]</code> as <code>list[object]</code> because it's the widest type</p>
<p>actually, it's not like that, that would be ergonomic to certain use cases. but i can't see any case where it would beneficially affect the types to use <code>object</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-22 16:18</div>
            <div class="timeline-body"><p>what you are suggesting is akin to:</p>
<pre><code class="language-py">from typing import Callable

class A[T]:
    def __init__(self, t: T):


A(1) # infer A[Unknown] or A[object] because the type parameter wasn't specified

def deco(fn: Callable[[int], None]): ...

class C[T]:
    def __call__(self, t: T) -&gt; None: ...


def deco(fn: Callable[[int], None]): ...

deco(C()) # C inferred as C[Unknown] because the type var wasn't specified 
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-22 20:04</div>
            <div class="timeline-body"><p>It's not about whether a user would want to explicitly annotate with <code>object</code>, it's just unsound (aka wrong) to assume that <code>i</code> (if un-annotated) must be <code>int</code> inside the body of <code>f</code>. The same is true whether <code>f</code> is a function or a lambda. Because <code>(object) -&gt; None</code> is a subtype of <code>(int) -&gt; None</code>, so the fact that <code>f</code> must be a subtype of <code>(int) -&gt; None</code> does not tell us that <code>i</code> must be <code>int</code>; <code>f</code> could just as well have the type <code>(object) -&gt; None</code>.</p>
<p>Here is a demonstration of the unsoundness. <code>i</code> will be <code>str</code> here at runtime. Where would you expect a type error in this example?</p>
<pre><code class="language-py">from typing import Callable

def deco(fn: Callable[[int], None]): ...

@deco
def f(i):
    reveal_type(i)  # Unknown

f(&quot;foo&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-22 23:04</div>
            <div class="timeline-body"><p>@carljm i think there has been a grave misunderstanding</p>
<p>in my case the decorator doesn't return the function</p>
<pre><code class="language-py">from typing import Callable

def deco(fn: Callable[[int], None]) -&gt; None:
    fn(1)

@deco
def f(i):
    reveal_type(i)  # int

deco(lambda i: reveal_type(i))
</code></pre>
<p>i guess this was an oversight on my behalf, i am too acustomed to unannotated equals <code>-&gt; None</code>, this is why i kept saying it is identical to the lambda form</p>
<p>i hope this clears up any confusion, i've updated the op</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-22 23:54</div>
            <div class="timeline-body"><p>Hmm, I think it is true that if we assume the function/lambda can only ever be called via the callable type it is assigned to, then the parameter types of that callable type are in fact upper bounds on the types it can receive as arguments.</p>
<p>I think this assumption can be made for a lambda passed as callback to an annotated callback type.</p>
<p>It seems a bit trickier to establish the conditions under which the assumption is safe in the OP example with a decorator.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-23 01:57</div>
            <div class="timeline-body"><blockquote>
<p>It seems a bit trickier to establish the conditions under which the assumption is safe in the OP example with a decorator.</p>
</blockquote>
<p>could you explain why that is? as a decorator is just &quot;syntatic sugar&quot; for calling the decorator and passing a function, then assigning the result to a variable with the name of the function. so to my analysis they are purely equal</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-23 02:03</div>
            <div class="timeline-body"><p>Actually I think you're right that they are equivalent if decorator syntax is used -- once the function is passed into the decorator, although it could have &quot;originally been&quot; of type <code>(object) -&gt; None</code> in principle, from that point on in practice it can never be called except &quot;through&quot; the type <code>(int) -&gt; None</code>, which means it can only ever receive an <code>int</code> argument.</p>
<p>I'll reopen this, though I think it will be higher priority to do it for lambdas than for decorated functions, since you can't annotate the lambda.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @carljm on 2025-09-23 02:03</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:20:40 UTC
    </footer>
</body>
</html>
