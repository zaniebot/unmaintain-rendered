<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incomplete equivalence of `*args, **kwargs` signature to `...` signature - astral-sh/ty #902</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Incomplete equivalence of `*args, **kwargs` signature to `...` signature</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/902">#902</a>
        opened by <a href="https://github.com/github-actions">@github-actions</a>
        on 2025-07-27 12:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/github-actions">@github-actions</a> on 2025-07-27 12:06</div>
            <div class="timeline-body"><p>All four reveal-types at the end of <a href="https://play.ty.dev/b545bd7a-0c30-45ae-8006-f94c6c23dd4d">this example</a> should reveal <code>Literal[True]</code>:</p>
<pre><code class="language-py">from typing import Callable, reveal_type
from ty_extensions import Intersection, Unknown, CallableTypeOf, Not, is_assignable_to

def f(*n1, **n2) -&gt; None: ...

type A = Not[Callable[..., None]]
type B = Not[CallableTypeOf[f]]

def g(a: A, b: B):
    reveal_type(a)
    reveal_type(b)

reveal_type(is_assignable_to(A, A | B))  # revealed: Literal[True]
reveal_type(is_assignable_to(A, B | A))  # revealed: Literal[False]
reveal_type(is_assignable_to(B, A | B))  # revealed: Literal[False]
reveal_type(is_assignable_to(B, B | A))  # revealed: Literal[True]
</code></pre>
<p>Originally revealed by property tests in this run: https://github.com/astral-sh/ty/actions/runs/16550887703</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @github-actions[bot] on 2025-07-27 12:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type properties</span> added by @github-actions[bot] on 2025-07-27 12:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-27 12:19</div>
            <div class="timeline-body"><pre><code> failures:

---- types::property_tests::stable::all_type_pairs_are_assignable_to_their_union stdout ----

thread 'types::property_tests::stable::all_type_pairs_are_assignable_to_their_union' panicked at /home/runner/.cargo/registry/src/index.crates.io-1949cf8c6b5b557f/quickcheck-1.0.3/src/tester.rs:165:28:
[quickcheck] TEST FAILED. Arguments: (Intersection { pos: [], neg: [Callable { params: GradualForm, returns: None }] }, Intersection { pos: [], neg: [Callable { params: List([Param { kind: Variadic, name: Some(Name(&quot;n1&quot;)), annotated_ty: None, default_ty: None }, Param { kind: KeywordVariadic, name: Some(Name(&quot;n2&quot;)), annotated_ty: None, default_ty: None }]), returns: None }] })
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-27 12:29</div>
            <div class="timeline-body"><p>I tried to reproduce this in the playground, but could not:</p>
<pre><code class="language-py">from typing import Callable, reveal_type
from ty_extensions import Intersection, Unknown, CallableTypeOf, Not, is_assignable_to

def f(*n1, **n2): ...

type A = Not[Callable[..., Unknown]]
type B = Not[CallableTypeOf[f]]

reveal_type(is_assignable_to(A, A | B))
reveal_type(is_assignable_to(A, B | A))
reveal_type(is_assignable_to(B, A | B))
reveal_type(is_assignable_to(B, B | A))
</code></pre>
<p>All four <code>reveal_type</code> calls there reveal <code>Literal[True]</code>. https://play.ty.dev/424c52ef-3442-4c45-8ffd-6e0b703860f4</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jelle-openai">@jelle-openai</a> on 2025-07-28 15:00</div>
            <div class="timeline-body"><p>Is the issue that ty simplifies a type of the form <code>(*n1, **n2) -&gt; Any</code> into <code>(...) -&gt; Any</code>? The property test result seems to indicate it's using a form with explicit arguments. The two types should be equivalent but maybe you're not consistently simplifying from one to the other.</p>
<p>(Obligatory plug: pycroscope has a <code>dump_value()</code> <a href="https://github.com/JelleZijlstra/pycroscope/blob/0d19236e4eda771175170a6b165b0e9f6a211d19/pycroscope/value.py#L363">function</a> that is like <code>reveal_type()</code> but prints out a more internal-style representation for the object. That can be useful in debugging exactly what the internal type representation is.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-07-28 15:06</div>
            <div class="timeline-body"><blockquote>
<p>(Obligatory plug: pycroscope has a <code>dump_value()</code> <a href="https://github.com/JelleZijlstra/pycroscope/blob/0d19236e4eda771175170a6b165b0e9f6a211d19/pycroscope/value.py#L363">function</a> that is like <code>reveal_type()</code> but prints out a more internal-style representation for the object. That can be useful in debugging exactly what the internal type representation is.)</p>
</blockquote>
<p>yes, I was wishing for this feature just yesterday while working on https://github.com/astral-sh/ty/issues/889 :-) It could be coming soon...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-07-29 08:24</div>
            <div class="timeline-body"><p>I also longed for something like <code>ty_extensions.reveal_type_debug</code> (or similar) a lot of times. I think it should be possible to implement this &quot;safely&quot; now <a href="https://github.com/astral-sh/ruff/pull/19400">with Doug's recent chances</a>.</p>
<p>Somewhat related: I was thinking about separating the functions in <code>ty_extensions</code> into &quot;potentially user facing&quot; and &quot;definitely internal&quot;. We might eventually expose something like <code>Intersection</code>, <code>Not</code> or <code>static_assert</code> to users. But <code>reveal_type_debug</code> should definitely be in the latter category, as the output should not be relied upon. Maybe it makes sense to have <code>ty_extensions</code> and <code>ty_extensions.internal</code> or similar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-05 02:39</div>
            <div class="timeline-body"><p>@AlexWaygood 's attempted repro differs from the property test failure in using <code>Unknown</code> instead of <code>None</code> as the return types. If I use <code>None</code>, the issue repros: https://play.ty.dev/a2a25c59-6813-4b54-9398-2e6130716b5c</p>
<pre><code class="language-py">from typing import Callable, reveal_type
from ty_extensions import Intersection, Unknown, CallableTypeOf, Not, is_assignable_to

def f(*n1, **n2) -&gt; None: ...

type A = Not[Callable[..., None]]
type B = Not[CallableTypeOf[f]]

def g(a: A, b: B):
    reveal_type(a)
    reveal_type(b)

reveal_type(is_assignable_to(A, A | B))  # revealed: Literal[True]
reveal_type(is_assignable_to(A, B | A))  # revealed: Literal[False]
reveal_type(is_assignable_to(B, A | B))  # revealed: Literal[False]
reveal_type(is_assignable_to(B, B | A))  # revealed: Literal[True]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @carljm on 2025-08-05 02:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Daily property test run failed on Sun Jul 27 2025" to "Incomplete equivalence of `*args, **kwargs` signature to `...` signature" by @carljm on 2025-08-05 02:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-05 06:58</div>
            <div class="timeline-body"><p>Oh, I was probably getting confused between Rust <code>None</code> and Python <code>None</code> again</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/GDYendell">@GDYendell</a> on 2025-09-07 17:49</div>
            <div class="timeline-body"><p>I have been investigating this and I am quite confused. This isn't testing equivalence of <code>*args, **kwargs</code> signature with <code>...</code> signature. It is just testing that the elements of a union are always assignable to the union. It doesn't matter what the types are. The use of <code>Not</code> in the types also seems irrelevant. This simplified version demonstrates the issue described by the title:</p>
<pre><code class="language-py">from typing import Callable, reveal_type
from ty_extensions import CallableTypeOf, is_assignable_to

def f(*n1, **n2) -&gt; None: ...

type A = Callable[..., None]
type B = CallableTypeOf[f]

reveal_type(is_assignable_to(A, B))  # revealed: Literal[True]
reveal_type(is_assignable_to(B, A))  # revealed: Literal[True]
</code></pre>
<p>However, I have just updated to main and now this also works (<a href="https://play.ty.dev/a2a25c59-6813-4b54-9398-2e6130716b5c">playground</a>), as do the two original playground links.</p>
<p>I think the union issue was fixed between 5th August and 16th August (where my dev branch was based) and the function signature issue was fixed between 16th August and now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-08 19:22</div>
            <div class="timeline-body"><p>@GDYendell Thanks for the investigation!</p>
<p>We do generally support that any element of a union is assignable to the union; when we have failures in that invariant, it means that we've implemented <em>subtyping</em> incorrectly (as opposed to assignability), because we use subtyping to simplify unions. So we might simplify the union <code>A | B</code> incorrectly to <code>A</code> (based on thinking that <code>B</code> is a subtype of <code>A</code>), and then find that <code>B</code> is not assignable to <code>A</code>. So I don't think there was any generalized &quot;union issue&quot; fixed here, but some issue specifically related to subtyping between <code>...</code> and <code>*a, **kw</code> callables.</p>
<p>In any case, happy to close this on the basis that we seem to have fixed all the examples shown here!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-09-08 19:22</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:20 UTC
    </footer>
</body>
</html>
