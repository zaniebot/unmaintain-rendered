<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Give submodules precedence over module-level `__getattr__` - astral-sh/ty #1053</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Give submodules precedence over module-level `__getattr__`</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/1053">#1053</a>
        opened by <a href="https://github.com/Avasam">@Avasam</a>
        on 2025-08-19 16:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/Avasam">@Avasam</a> on 2025-08-19 16:31</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Sorry if duplicate of a more generalized issue, the error is kinda precise and I couldn't find an equivalent issue already open.</p>
<p>Take the following MRO:</p>
<pre><code class="language-py">from typing import reveal_type
from PySide6 import QtCore, QtWidgets

reveal_type(QtCore)
reveal_type(QtWidgets)
reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
reveal_type(QtWidgets.QFileDialog)
</code></pre>
<p><code>uvx --with PySide6 ty check</code> (PySide6@6.9.1 as of writing this)</p>
<p>Results:</p>
<pre><code>WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
Checking ------------------------------------------------------------ 1/1 files
info[revealed-type]: Revealed type
 --&gt; example.py:4:13
  |
2 | from PySide6 import QtCore, QtWidgets
3 |
4 | reveal_type(QtCore)
  |             ^^^^^^ `list[str]`
5 | reveal_type(QtWidgets)
6 | reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
  |

info[revealed-type]: Revealed type
 --&gt; example.py:5:13
  |
4 | reveal_type(QtCore)
5 | reveal_type(QtWidgets)
  |             ^^^^^^^^^ `list[str]`
6 | reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
7 | reveal_type(QtWidgets.QFileDialog)
  |

error[unresolved-attribute]: Type `list[str]` has no attribute `Qt`
 --&gt; example.py:6:13
  |
4 | reveal_type(QtCore)
5 | reveal_type(QtWidgets)
6 | reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
  |             ^^^^^^^^^
7 | reveal_type(QtWidgets.QFileDialog)
  |
info: rule `unresolved-attribute` is enabled by default

info[revealed-type]: Revealed type
 --&gt; example.py:6:13
  |
4 | reveal_type(QtCore)
5 | reveal_type(QtWidgets)
6 | reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
  |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `Unknown`
7 | reveal_type(QtWidgets.QFileDialog)
  |

error[unresolved-attribute]: Type `list[str]` has no attribute `QFileDialog`
 --&gt; example.py:7:13
  |
5 | reveal_type(QtWidgets)
6 | reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
7 | reveal_type(QtWidgets.QFileDialog)
  |             ^^^^^^^^^^^^^^^^^^^^^
  |
info: rule `unresolved-attribute` is enabled by default

info[revealed-type]: Revealed type
 --&gt; example.py:7:13
  |
5 | reveal_type(QtWidgets)
6 | reveal_type(QtCore.Qt.WindowType.FramelessWindowHint)
7 | reveal_type(QtWidgets.QFileDialog)
  |             ^^^^^^^^^^^^^^^^^^^^^ `Unknown`
  |

Found 6 diagnostics
</code></pre>
<h3>Version</h3>
<p>ty 0.0.1-alpha.18 (d697cc092 2025-08-14) AND ty 0.0.1-alpha.19 (e9cb838b3 2025-08-19)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "PySide6 modules are seen as `list[str]`" to "PySide6 modules are seen as `list[str]` since Alpha 18" by @Avasam on 2025-08-19 16:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "PySide6 modules are seen as `list[str]` since Alpha 18" to "PySide6 modules are seen as `list[str]` since alpha.18" by @Avasam on 2025-08-19 16:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">runtime semantics</span> added by @carljm on 2025-08-19 17:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @carljm on 2025-08-19 17:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "PySide6 modules are seen as `list[str]` since alpha.18" to "Consider giving submodules precedence over module-level `__getattr__`?" by @carljm on 2025-08-19 17:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-19 17:22</div>
            <div class="timeline-body"><p>Thanks for the report!</p>
<p>The problem here is that PySide6 has an <code>__init__.py</code> that <a href="https://github.com/pyside/pyside-setup/blob/dev/sources/pyside6/PySide6/__init__.py.in#L122">has a module-level <code>__getattr__</code> function which is annotated to return <code>list[str]</code></a>, and it doesn't have any explicit import of its submodules. In that situation the <code>__getattr__</code> takes precedence over looking for submodules, and we model that runtime precedence accurately. (We also model accurately that if the <code>__init__.py</code> itself explicitly imports the submodule, that does take precedence over the module <code>__getattr__</code>.)</p>
<p>(We added support for module-level <code>__getattr__</code> in ty alpha.18.)</p>
<p>Pyright and mypy both appear to model the precedence here in a way that doesn't match runtime -- they always prefer a submodule over a module <code>__getattr__</code>. This will lead them to incorrect inference in some cases, but perhaps this is an intentional divergence from the runtime semantics? I'm not sure.</p>
<p>The reason this works at runtime for PySide6 is that their module <code>__getattr__</code> only returns for the name <code>__all__</code>, and otherwise raises <code>AttributeError</code>, causing the import system to fall back to looking for a submodule. But there's no (standardized, specified) way to annotate the <code>__getattr__</code> to tell us that it raises <code>AttributeError</code> for all but a certain set of names.</p>
<p>One possible solution here would be for PySide6 to provide a top level <code>__init__.pyi</code> that would omit the <code>__getattr__</code>, since it has no value for type checkers and is just a runtime optimization for lazy <code>__all__</code>.</p>
<p>Another possible solution would be to reach consensus (on discuss.python.org) for adding language to the typing spec establishing a semantics for <code>__getattr__</code> where the key/name argument can be annotated with a more limited union of literal string types to communicate &quot;this <code>__getattr__</code> method will raise AttributeError on any argument other than these&quot;. Then PySide6 could annotate its <code>__getattr__</code> with an argument type of <code>Literal[&quot;__all__&quot;]</code>, and we would ignore the <code>__getattr__</code> for any other name. (In fact we already implement these semantics, but neither mypy nor pyright do.) I think this is pretty reasonable: an argument annotation does communicate &quot;I will raise if you call me with an argument type outside my annotated one.&quot;</p>
<p>I'll leave this issue open for now, to collect feedback on whether it will be important for us to follow mypy and pyright in their divergence from the runtime semantics of module-level <code>__getattr__</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-08-19 19:31</div>
            <div class="timeline-body"><p>Thanks a lot for the full analysis! I'm not too surprised the PySide6 stubs themselves are cause for issue, they have their own custom type-stubs generator, and I often had to raise issues for incorrectness in their stubs, or ask for improvements.</p>
<p>In this case it might be a harder sell because of how both mypy an pyright, two well-established type checkers, handle their stubs. The new kid on the block (ty) is the one that doesn't work.</p>
<p>Hopefully a consensus can be reached !</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-19 19:43</div>
            <div class="timeline-body"><blockquote>
<p>One possible solution here would be for PySide6 to provide a top level <code>__init__.pyi</code> that would omit the <code>__getattr__</code>, since it has no value for type checkers and is just a runtime optimization for lazy <code>__all__</code>.</p>
</blockquote>
<p>I think it probably doesn't need quite such an invasive solution? This would probably fix the issue, I think:</p>
<pre><code class="language-diff">- def __getattr__(name: str) -&gt; list[str]:
-     if name == &quot;__all__&quot;:
-         global __all__
-         __all__ = _find_all_qt_modules()
-         return __all__
-     raise AttributeError(f&quot;module '{__name__}' has no attribute '{name}' :)&quot;)
+ TYPE_CHECKING = False
+
+ if not TYPE_CHECKING:
+     def __getattr__(name: str) -&gt; list[str]:
+         if name == &quot;__all__&quot;:
+             global __all__
+             __all__ = _find_all_qt_modules()
+             return __all__
+         raise AttributeError(f&quot;module '{__name__}' has no attribute '{name}' :)&quot;)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-10 17:17</div>
            <div class="timeline-body"><p>I think we should just follow mypy and pyright here -- this issue isn't worth the incompatibility. The only case in which the mypy/pyright approach gives incorrect results is if someone is intentionally shadowing a submodule with a package <code>__getattr__</code>, and if there's a good use case for doing this, it doesn't seem to have come up yet.</p>
<p>I think it makes sense to assume that an argument incompatible with the annotated parameter type of <code>__getattr__</code> will result in <code>AttributeError</code>, so I'm glad we support that -- and in an ideal world, I believe that's how this scenario should be handled. But without a clearer use case and real-world demand, I think it will be hard to convince mypy and pyright that they should also support that, and then convince real-world users of package <code>__getattr__</code> to annotate their <code>__getattr__</code> functions that way. And we have more important things to focus on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Consider giving submodules precedence over module-level `__getattr__`?" to "Give submodules precedence over module-level `__getattr__`" by @carljm on 2025-09-10 17:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "GA" by @carljm on 2025-09-10 17:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/saucoide">@saucoide</a> on 2025-10-28 12:35</div>
            <div class="timeline-body"><p>another realworld example, in <code>anyio</code> this was recently added to handle warnings for typo</p>
<p>https://github.com/agronholm/anyio/pull/938</p>
<pre><code class="language-python"># __init__.py
# ...
def __getattr__(attr: str) -&gt; type[BrokenWorkerInterpreter]:
    &quot;&quot;&quot;Support deprecated aliases.&quot;&quot;&quot;
    if attr == &quot;BrokenWorkerIntepreter&quot;:
        import warnings

        warnings.warn(
            &quot;The 'BrokenWorkerIntepreter' alias is deprecated, use 'BrokenWorkerInterpreter' instead.&quot;,
            DeprecationWarning,
            stacklevel=2,
        )
        return BrokenWorkerInterpreter

    raise AttributeError(f&quot;module {__name__!r} has no attribute {attr!r}&quot;)
</code></pre>
<p>making submodules type like a <code>BrokenWorkerInterpreter</code></p>
<pre><code class="language-python">from anyio import to_thread
to_thread.current_default_thread_limiter()  # Type `type[BrokenWorkerInterpreter]` has no attribute `current_default_thread_limiter`
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Avasam">@Avasam</a> on 2025-11-03 01:05</div>
            <div class="timeline-body"><blockquote>
<p>But there's no (standardized, specified) way to annotate the <code>__getattr__</code> to tell us that it raises <code>AttributeError</code> for all but a certain set of names.</p>
</blockquote>
<p>I would imagine combining <code>overload</code> and <code>Literal</code> like the following to make sense, but yeah, not supported by any type-checker that I know of:</p>
<pre><code class="language-py">@overload
def __getattr__(name: Literal[&quot;foo&quot;]) -&gt; str: ...
@overload
def __getattr__(name: Literal[&quot;bar&quot;]) -&gt; int: ...
# No matching overloads means you fall back as if `__getattr__` raises `AttributeError`
</code></pre>
<p>if the above was accepted/standardized, you could do the following:</p>
<p>The PySide example could be annotated using:</p>
<pre><code class="language-py">def __getattr__(name: Literal[&quot;__all__&quot;]) -&gt; list[str]:
</code></pre>
<p>@saucoide 's anyio as:</p>
<pre><code class="language-py">def __getattr__(name: Literal[&quot;BrokenWorkerIntepreter&quot;]) -&gt; type[BrokenWorkerInterpreter]:
</code></pre>
<hr />
<p>This also wouldn't work because it should just get simplified back to the original signature (and I don't think special-casing <code>__getattr__</code> for this is a good idea):</p>
<pre><code class="language-py">def __getattr__(name: str) -&gt; NoReturn | list[str]:
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-11-03 20:24</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:25 UTC
    </footer>
</body>
</html>
