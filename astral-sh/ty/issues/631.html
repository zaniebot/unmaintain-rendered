<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>one thread can spend a long time chasing a dependency trail - astral-sh/ty #631</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>one thread can spend a long time chasing a dependency trail</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/631">#631</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-06-11 01:20
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>Observed running ty on large codebases: our current parallelism model splits work among threads at the granularity of &quot;checking a file&quot;, where &quot;a file&quot; is a file the user has requested be checked.</p>
<p>In a case where there are many third-party dependencies, or many first-party files that were excluded from checking, the task of &quot;check one file&quot; can potentially encompass a very deep traversal of a large chain of dependency modules, causing one thread to become very busy for a long time while other threads sit idle.</p>
<p>Ideally, we would avoid this scenario. One possibility is that semantic indexing collects dependency modules and names depended on from those modules, and these also become part of a task list that we distribute to threads that would otherwise be idle.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by <a href="https://github.com/carljm">@carljm</a> on 2025-06-11 01:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-11 05:23</div>
            <div class="timeline-body"><blockquote>
<p>Ideally, we would avoid this scenario. One possibility is that semantic indexing collects dependency modules and names depended on from those modules, and these also become part of a task list that we distribute to threads that would otherwise be idle.</p>
</blockquote>
<p>We could explore this for first-party files because it&#x27;s very likely that we need to analyze all of them. But doing this for third-party files is in direct conflict with our lazy approach of only doing as much work as is absolutely necessary. Parsing and indexing those dependencies might be entirely unnecessary if the first-party code doesn&#x27;t use any of the transitively imported code.</p>
<p>We also have the problem where many threads block on a single thread because they all have a shared dependency (or participate in one massive cycle). The problem here is that all threads are blocked and spawning of more work won&#x27;t help, because all except one thread are blocked. This would require some form of yield support in salsa where blocked threads can yield to take on new work but I suspect that this could very easily result in dead-locks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-06-11 18:39</div>
            <div class="timeline-body"><blockquote>
<p>But doing this for third-party files is in direct conflict with our lazy approach of only doing as much work as is absolutely necessary. Parsing and indexing those dependencies might be entirely unnecessary if the first-party code doesn&#x27;t use any of the transitively imported code.</p>
</blockquote>
<p>Agreed, that&#x27;s why I suggested collecting specific dependency modules and names actually used from those modules, when we are doing semantic indexing of the code we are going to check. I didn&#x27;t suggest just blindly inferring types in all not-to-be-checked modules that exist on disk.</p>
<p>I guess this will still only give us one &quot;dependency layer&quot; of improved parallelism. Because we can&#x27;t do this &quot;collect from semantic indexing&quot; on a not-to-be-checked file, without risking doing a bunch of work on unused dependencies. So we won&#x27;t find transitive deps this way. I guess this one extra layer of parallelism is still better than the status quo -- could help a lot in some cases, less in others.</p>
<blockquote>
<p>We also have the problem where many threads block on a single thread because they all have a shared dependency (or participate in one massive cycle). The problem here is that all threads are blocked and spawning of more work won&#x27;t help, because all except one thread are blocked. This would require some form of yield support in salsa where blocked threads can yield to take on new work but I suspect that this could very easily result in dead-locks.</p>
</blockquote>
<p>Makes sense. I&#x27;m curious how often in practice we see the latter (all threads busy but blocked on another thread) vs the former (all threads but one idle, one thread doing a deep crawl through dependencies.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-19 08:23</div>
            <div class="timeline-body"><p>Another thing I played with is spawning a task per scope in <code>check_types</code>. This helps a lot for projects like discord.py where a single file takes very long to type check as it enables more work-stealing. However this requires removing salsa caching from <code>check_file_impl</code> which seems bad for incrementality, because Salsa doesn&#x27;t support multithreaded tasks in queries today, i</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:24:49 UTC
    </footer>
</body>
</html>
