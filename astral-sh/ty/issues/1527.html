<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`unresolved-reference` fires when a name is declared but not bound - astral-sh/ty #1527</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1><code>unresolved-reference</code> fires when a name is declared but not bound</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/1527">#1527</a>
        opened by <a href="https://github.com/winterqt">@winterqt</a>
        on 2025-11-11 21:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/winterqt">@winterqt</a></div>
            <div class="timeline-body">Summary
<p>In Nixpkgs, we construct a file that looks like this for type checking our test scripts:</p>
<pre><code># This file contains type hints that can be prepended to Nix test scripts so they can be type
# checked.

from test_driver.debug import DebugAbstract
from test_driver.driver import Driver
from test_driver.vlan import VLan
from test_driver.machine import Machine
from test_driver.logger import AbstractLogger
from typing import Callable, Iterator, ContextManager, Optional, List, Dict, Any, Union
from typing_extensions import Protocol
from pathlib import Path
from unittest import TestCase


class RetryProtocol(Protocol):
    def __call__(self, fn: Callable, timeout: int = 900) -&gt; None:
        raise Exception(&quot;This is just type information for the Nix test driver&quot;)


class PollingConditionProtocol(Protocol):
    def __call__(
        self,
        fun_: Optional[Callable] = None,
        *,
        seconds_interval: float = 2.0,
        description: Optional[str] = None,
    ) -&gt; Union[Callable[[Callable], ContextManager], ContextManager]:
        raise Exception(&quot;This is just type information for the Nix test driver&quot;)


class CreateMachineProtocol(Protocol):
    def __call__(
        self,
        start_command: str | dict,
        *,
        name: Optional[str] = None,
        keep_vm_state: bool = False,
    ) -&gt; Machine:
        raise Exception(&quot;This is just type information for the Nix test driver&quot;)


start_all: Callable[[], None]
subtest: Callable[[str], ContextManager[None]]
retry: RetryProtocol
test_script: Callable[[], None]
machines: List[Machine]
vlans: List[VLan]
driver: Driver
log: AbstractLogger
create_machine: CreateMachineProtocol
run_tests: Callable[[], None]
join_all: Callable[[], None]
serial_stdout_off: Callable[[], None]
serial_stdout_on: Callable[[], None]
polling_condition: PollingConditionProtocol
debug: DebugAbstract
t: TestCase
installer: Machine; target: Machine;
vlan1: VLan;


installer.start()

installer.wait_for_unit(&quot;multi-user.target&quot;)

with subtest(&quot;Assert readiness of login prompt&quot;):
    installer.succeed(&quot;echo hello&quot;)

with subtest(&quot;Wait for hard disks to appear in /dev&quot;):
    installer.succeed(&quot;udevadm settle&quot;)

installer.succeed(
    &quot;flock /dev/vda parted --script /dev/vda -- mklabel msdos&quot;
    + &quot; mkpart primary linux-swap 1M 1024M&quot;
    + &quot; mkpart primary ext2 1024M -1s&quot;,
    &quot;udevadm settle&quot;,
    &quot;mkswap /dev/vda1 -L swap&quot;,
    &quot;swapon -L swap&quot;,
    &quot;mkfs.ext3 -L nixos /dev/vda2&quot;,
    &quot;mount LABEL=nixos /mnt&quot;,
)


with subtest(&quot;Create the NixOS configuration&quot;):
    installer.succeed(&quot;nixos-generate-config  --root /mnt&quot;)
    installer.succeed(&quot;cat /mnt/etc/nixos/hardware-configuration.nix &gt;&amp;2&quot;)
    installer.copy_from_host(
        &quot;/nix/store/xd6h8yqhic3ccvjmchl6q51jj7alms53-configuration.nix&quot;,
        &quot;/mnt/etc/nixos/configuration.nix&quot;,
    )
    installer.copy_from_host(&quot;/nix/store/347hvs3r67gw1l8b768j4gc2m1kk0y1c-secret&quot;, &quot;/mnt/etc/nixos/secret&quot;)





with subtest(&quot;Perform the installation&quot;):
    installer.succeed(&quot;nixos-install &lt; /dev/null &gt;&amp;2&quot;)

with subtest(&quot;Do it again to make sure it&#x27;s idempotent&quot;):
    installer.succeed(&quot;nixos-install &lt; /dev/null &gt;&amp;2&quot;)

with subtest(&quot;Check that we can build things in nixos-enter&quot;):
    installer.succeed(
        &quot;&quot;&quot;
        nixos-enter -- nix-build --option substitute false -E &#x27;derivation {
            name = &quot;t&quot;;
            builder = &quot;/bin/sh&quot;;
            args = [&quot;-c&quot; &quot;echo nixos-enter build &gt; $out&quot;];
            system = builtins.currentSystem;
            preferLocalBuild = true;
        }&#x27;
        &quot;&quot;&quot;
    )



with subtest(&quot;Shutdown system after installation&quot;):
    installer.succeed(&quot;umount -R /mnt&quot;)
    installer.succeed(&quot;sync&quot;)
    installer.shutdown()

# We&#x27;re actually the same machine, just booting differently this time.
target.state_dir = installer.state_dir

# Now see if we can boot the installation.

target.start()

target.wait_for_unit(&quot;multi-user.target&quot;)


with subtest(&quot;Assert that /boot get mounted&quot;):
    target.wait_for_unit(&quot;local-fs.target&quot;)
    target.succeed(&quot;test -e /boot/grub&quot;)

with subtest(&quot;Check whether /root has correct permissions&quot;):
    assert &quot;700&quot; in target.succeed(&quot;stat -c &#x27;%a&#x27; /root&quot;)

with subtest(&quot;Assert swap device got activated&quot;):
    # uncomment once https://bugs.freedesktop.org/show_bug.cgi?id=86930 is resolved
    target.wait_for_unit(&quot;swap.target&quot;)
    target.succeed(&quot;cat /proc/swaps | grep -q /dev&quot;)

with subtest(&quot;Check that the store is in good shape&quot;):
    target.succeed(&quot;nix-store --verify --check-contents &gt;&amp;2&quot;)

with subtest(&quot;Check whether the channel works&quot;):
    target.succeed(&quot;nix-env -iA nixos.procps &gt;&amp;2&quot;)
    assert &quot;.nix-profile&quot; in target.succeed(&quot;type -tP ps | tee /dev/stderr&quot;)

with subtest(
    &quot;Check that the daemon works, and that non-root users can run builds &quot;
    &quot;(this will build a new profile generation through the daemon)&quot;
):
    target.succeed(&quot;su alice -l -c &#x27;nix-env -iA nixos.procps&#x27; &gt;&amp;2&quot;)

with subtest(&quot;Configure system with writable Nix store on next boot&quot;):
    # we&#x27;re not using copy_from_host here because the installer image
    # doesn&#x27;t know about the host-guest sharing mechanism.
    target.copy_from_host_via_shell(
        &quot;/nix/store/a2a0bplj5mknpv92d71wvihjhhlsb0n1-configuration.nix&quot;,
        &quot;/etc/nixos/configuration.nix&quot;,
    )

with subtest(&quot;Check whether nixos-rebuild works&quot;):
    target.succeed(&quot;nixos-rebuild switch &gt;&amp;2&quot;)

with subtest(&quot;Test nixos-option&quot;):
    kernel_modules = target.succeed(&quot;nixos-option boot.initrd.kernelModules&quot;)
    assert &quot;virtio_console&quot; in kernel_modules
    assert &quot;list of modules&quot; in kernel_modules
    assert &quot;qemu-guest.nix&quot; in kernel_modules

target.shutdown()

# Check whether a writable store build works

target.start()

target.wait_for_unit(&quot;multi-user.target&quot;)


# we&#x27;re not using copy_from_host here because the installer image
# doesn&#x27;t know about the host-guest sharing mechanism.
target.copy_from_host_via_shell(
    &quot;/nix/store/qxm4wkdk5868nalqiasqm2k3k44gdk41-configuration.nix&quot;,
    &quot;/etc/nixos/configuration.nix&quot;,
)
target.succeed(&quot;nixos-rebuild boot &gt;&amp;2&quot;)
target.shutdown()

# And just to be sure, check that the target still boots after &quot;nixos-rebuild switch&quot;.

target.start()

target.wait_for_unit(&quot;multi-user.target&quot;)

target.wait_for_unit(&quot;network.target&quot;)

# Sanity check, is it the configuration.nix we generated?
hostname = target.succeed(&quot;hostname&quot;).strip()
assert hostname == &quot;thatworked&quot;

target.shutdown()

# Tests for validating clone configuration entries in grub menu
</code></pre>
<p>When experimenting with migrating from mypy to ty, I run into the following issue (<a href="https://play.ty.dev/14c4c40c-36c7-43df-a1cc-ab3895d29f8c">playground</a>):</p>
<pre><code>error[unresolved-reference]: Name `installer` used when not defined
  --&gt; testScriptWithTypes.py:62:1
   |
62 | installer.start()
   | ^^^^^^^^^
63 |
64 | installer.wait_for_unit(&quot;multi-user.target&quot;)
   |
info: rule `unresolved-reference` is enabled by default
</code></pre>
<p>Perfectly understandable if this is expected behavior, but given the divergence from mypy, figured I&#x27;d file anyways.</p>
Version
<p>ty 0.0.1-alpha.26</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-11-11 22:40</div>
            <div class="timeline-body"><p>Thanks for the report. Yeah, it looks like we are the only type checker that does this. I think we should probably just trust the declaration in these cases. Or at least make this a separate rule that can be turned off.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;`unresolved-reference` fires when only a type definition is present&quot; to &quot;`unresolved-reference` fires when enclosing scope has a declaration but no bindings&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-11-11 22:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;GA&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-11-11 22:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-12 07:24</div>
            <div class="timeline-body"><blockquote>
<p>Thanks for the report. Yeah, it looks like we are the only type checker that does this. I think we should probably just trust the declaration in these cases. Or at least make this a separate rule that can be turned off.</p>
</blockquote>
<p>I&#x27;d expect this to trigger a <code>possibly-unresolved-attribute</code> or <code>unresolved-attribute</code> error instead as the variable is clearly defined, it&#x27;s just that it is never bound. I believe TypeScript outright disallowes <code>a: int</code> in strict mode without an assignment (or when it can&#x27;t prove that the variable is assigned in all code paths). Instead, you&#x27;d have to write it as <code>a: int | None</code> if the variable is only sometimes initialized. Which makes sense to me and has prevented many bugs in code that I&#x27;ve written.</p>
<p>Note, that ty doesn&#x27;t raise an error if the file is a <code>pyi</code> file (which, obviously, doesn&#x27;t work for this use case but seems more correct to me)</p>
<p>https://play.ty.dev/2106b7b7-f822-490f-9da8-4ef2fbe9605f</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-11-12 08:07</div>
            <div class="timeline-body"><blockquote>
<p>it looks like we are the only type checker that does this</p>
</blockquote>
<p>Are we? Pyright <a href="https://pyright-play.net/?code=M4LgBMAuBOBQAO0CWA7SAKYBKWQ">reports <code>&quot;s&quot; is unbound (reportUnboundVariable)</code></a> and pyrefly reports <a href="https://pyrefly.org/sandbox/?project=N4IgZglgNgpgziAXKOBDAdgEwEYHsAeAdAA4CeSIciABHAC4BOAOusQxOnQBRwCULIADQgArnWhwS5RCADE1AKrioEOqWpgR6AMbjc6OCxaYYYDbgYBbVHQD66EZewwGXfDQ51e1ALQA%2BWkZEFmpQ6gYYOhEGdA0mEAA5R2cGGmB8AF94gWEyCLAoUkI6XEsoCnkABVJ8wtoMHAJqbX1IAHNomwh9QhZ5AGUYGGoACzo6YioAeim800LCCzapmHQpzFxtOCmW9HbOvTXzBmpUADdUaFRsWGbWiA6GLv1qXGJDyRYyOhH9HzOXHBurEALzUeIAZkIAEYAEzZdAgDLCVC6CAAgBi0BgFDQWDwRDISKAA"><code>s</code> is uninitialized [unbound-name]</a>. Or which specific code were you testing?</p>
<p>The code is clearly wrong (the variables are declared, but not bound) so I don&#x27;t see why we should change anything here? It seems reasonable to me that if you want to convince the type checker that something exists which clearly doesn&#x27;t, that you would have to go out of your way to do so, like maybe using <code>installer: Machine = cast(Machine, ...)</code> or similar.</p>
<blockquote>
<p>I&#x27;d expect this to trigger a <code>possibly-unresolved-attribute</code> or <code>unresolved-attribute</code> error instead</p>
</blockquote>
<p>Why? Both <code>s</code> in the toy example as well as <code>installer</code> in the original example are symbols that have been declared, but not bound. So IMO, even just accessing that object should trigger the error, not the attribute access that comes later. I agree that we should maybe split the rule, though. To distinguish between <code>unresolved-reference</code> (not declared, not bound) and <code>unbound-reference</code> (declared, but never bound). This would provide an alternative solution here (ignore <code>unbound-reference</code> across the whole file).</p>
<blockquote>
<p>Instead, you&#x27;d have to write it as <code>a: int | None</code> if the variable is only sometimes initialized. Which makes sense to me and has prevented many bugs in code that I&#x27;ve written.</p>
</blockquote>
<p>That would also be possible in Python, you would just have to set it to <code>None</code> explicitly. And then you would also <a href="https://play.ty.dev/78b0e6ee-8b82-47aa-be16-c3128c6d8688">get <code>unresolved-attribute</code> errors</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-11-12 15:12</div>
            <div class="timeline-body"><p>I should have been clearer in my comment; I was making a distinction in my mind between two different scenarios, which I didn&#x27;t clarify (except subtly in my edit to the issue title). And I didn&#x27;t look carefully enough at the OP code sample to realize that it contains examples of both scenarios.</p>
<p>Other type checkers distinguish between same-scope use of a name and lazy-nested-scope use of a name. The case I tested is</p>
<pre><code>s: str
def f():
    reveal_type(s)
</code></pre>
<p>Where all three of pyright, mypy, and pyrefly reveal <code>str</code> with no error.</p>
<p>I don&#x27;t think we should change anything in the same-scope scenario that you tested. That&#x27;s code running eagerly in sequence; using an uninitialized value should be an error.</p>
<p>I think there&#x27;s a stronger argument for not erroring in a lookup from a lazy scope. In this case, the annotation may be a declaration that &quot;I will set this name in this scope before the function is called, via some external source the type checker cannot see&quot;, and I think it&#x27;s reasonable to trust that declaration, and the fact that all existing type-checkers do so is strong signal.</p>
<p>But since the OP code sample contains uses of the non-initialized names both in module scope and in nested functions, making the change I was suggesting would still not allow this script to type-check. I agree that for this script, the <code>cast</code> trick you suggest seems like the best option.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-11-12 18:20</div>
            <div class="timeline-body"><p>Uh, and somehow in all of that I <em>also</em> managed to miss the fact that we <a href="https://play.ty.dev/4300c635-1708-49fb-8ca2-5fd03e76f273">already</a> match mypy/pyright/pyrefly in not erroring on declared-only names in enclosing scopes. Sorry everyone for the unnecessary noise.</p>
<p>I think this should just be closed as &quot;not planned&quot;. Thanks for the report, but we don&#x27;t intend to match mypy&#x27;s laxness in this scenario.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2025-11-12 18:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;`unresolved-reference` fires when enclosing scope has a declaration but no bindings&quot; to &quot;`unresolved-reference` fires when a name is declared but not bound&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-11-12 18:21</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:25:57 UTC
    </footer>
</body>
</html>
