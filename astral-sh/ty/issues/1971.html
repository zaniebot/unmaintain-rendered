<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider assuming that untyped decorators pass through the signature unchanged - astral-sh/ty #1971</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Consider assuming that untyped decorators pass through the signature unchanged</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1971">#1971</a>
        opened by <a href="https://github.com/afonsotrepa">@afonsotrepa</a>
        on 2025-12-17 02:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/afonsotrepa">@afonsotrepa</a></div>
            <div class="timeline-body">Summary
<p>I ran into this problem where ty wouldn&#x27;t catch a mistyped return type but pyright would. Narrowed it down to a decorator I&#x27;m using.
Sorry if this is a known issue (a quick search didn&#x27;t find another open issue for this) or limitation.</p>
Example
<pre><code>def deco(_):
    def inner(func):
        return func
    return inner


@deco(0)
def f() -&gt; str:
    return &quot;&quot;


def g() -&gt; float:
    return f()
</code></pre>
<p>Expected to get &quot;error[invalid-return-type]&quot; (which is indeed what we see if we remove the decorator) but instead got all checks passing.</p>
Version
<p>0.0.2</p>
<p>P.S.: Still loving ty and ruff, keep up the good work!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;ty fails to infer return type through untyped decorator factories&quot; to &quot;Failure to infer return type through untyped decorator factory&quot; by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-17 02:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;Stable&quot; by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 08:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 08:53</div>
            <div class="timeline-body"><p>Thank you for reporting this.</p>
<p>We currently don&#x27;t support return type inference yet (which is why the return type of <code>deco</code> is just <code>Unknown</code>), but plan to add it soon. See #128 for details.</p>
<p>Note: It&#x27;s actually not completely clear to me how other type checkers handle this case. It seems to me like we would have to infer a generic <code>âˆ€ T. Callable[[T], T]</code> type for <code>inner</code> here (and, in effect, for the return type of <code>deco</code>)? But pyright simply infers the type of <code>deco</code> as <code>(_: Unknown) -&gt; ((func: Unknown) -&gt; Unknown)</code>. So it looks like it might use additional heuristics (something like: &quot;if the return type of a decorator is Unknown, just pretend it acts like an identity operation&quot;)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 08:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">calls</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 08:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 08:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:30</div>
            <div class="timeline-body"><p>Yes, I think I remember some discussion of this. At least pyright (maybe some other type checkers too) do make the assumption that an untyped decorator doesn&#x27;t change the signature. I&#x27;m not sold on this idea, though I can see why it&#x27;s attractive.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:31</div>
            <div class="timeline-body"><p>I&#x27;m not sure this is really blocked by #128, since I don&#x27;t think #128 will solve it, nor is necessary to &quot;solve&quot; it in the way that other type checkers do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Failure to infer return type through untyped decorator factory&quot; to &quot;Consider assuming that untyped decorators pass through the signature unchanged&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> removed by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-18 01:34</div>
            <div class="timeline-body"><p>Actually this issue is still present if we type hint the decorator (and this was my original issue, I was just trying to create a minimalist example but clearly cut too much out, sorry):</p>
<pre><code>from collections.abc import Callable

def deco[**P, R](_: object) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:
    def inner(func: Callable[P, R]) -&gt; Callable[P, R]:
        return func
    return inner


@deco(0)
def f() -&gt; str:
    return &quot;&quot;


def g() -&gt; float:
    return f()
</code></pre>
<p>Same deal, ty (0.0.2) says all checks passed while pyright (1.1.407) correctly detects a &quot;reportReturnType&quot; (Type &quot;str&quot; is not assignable to return type &quot;float&quot;)  error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 15:48</div>
            <div class="timeline-body"><p>@afonsotrepa Thanks for the example! It looks like that is a different limitation: <a href="https://github.com/astral-sh/ty/issues/1136">astral-sh/ty#1136</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 15:58</div>
            <div class="timeline-body"><p>@afonsotrepa note also that this version works in all type checkers (including ty) today, because it doesn&#x27;t rely on the special-cased heuristic in #1136:</p>
<pre><code>from typing import Callable, Protocol

class Identity(Protocol):
    def __call__[**P, R](self, fn: Callable[P, R], /) -&gt; Callable[P, R]: ...

def deco(_: object) -&gt; Identity:
    def inner[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]:
        return func
    return inner

@deco(0)
def f() -&gt; str:
    return &quot;&quot;


def g() -&gt; float:
    return f()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-18 17:19</div>
            <div class="timeline-body"><p>@carljm your Identity class fixed my issue, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 21:53</div>
            <div class="timeline-body"><p>We could also do this in a way that is LSP-specific, by implementing some form of &quot;best-guess types&quot; that we won&#x27;t use to emit type diagnostics, but will use for LSP purposes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-18 23:02</div>
            <div class="timeline-body"><p>@carljm sorry for another &quot;off-topic&quot; comment but I found your Identity class was not working for generic functions when using functools.wraps, so instead I&#x27;m now using:</p>
<pre><code>def deco[**P, R](_: object) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:

    def dec(func: Callable[P, R]) -&gt; Callable[P, R]:

        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:
                return func(*args, **kwargs)

        return wrapper

    return dec
</code></pre>
<p>This works with ty and pyright and successfully catches invalid return types, even for functions with generics. Hopefully this will be useful for someone else too.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:28 UTC
    </footer>
</body>
</html>
