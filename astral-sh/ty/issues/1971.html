<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider assuming that untyped decorators pass through the signature unchanged - astral-sh/ty #1971</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Consider assuming that untyped decorators pass through the signature unchanged</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1971">#1971</a>
        opened by <a href="https://github.com/afonsotrepa">@afonsotrepa</a>
        on 2025-12-17 02:19
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-17 02:19</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>I ran into this problem where ty wouldn't catch a mistyped return type but pyright would. Narrowed it down to a decorator I'm using.
Sorry if this is a known issue (a quick search didn't find another open issue for this) or limitation.</p>
<h3>Example</h3>
<pre><code class="language-Python">def deco(_):
    def inner(func):
        return func
    return inner


@deco(0)
def f() -&gt; str:
    return &quot;&quot;


def g() -&gt; float:
    return f()
</code></pre>
<p>Expected to get &quot;error[invalid-return-type]&quot; (which is indeed what we see if we remove the decorator) but instead got all checks passing.</p>
<h3>Version</h3>
<p>0.0.2</p>
<p>P.S.: Still loving ty and ruff, keep up the good work!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "ty fails to infer return type through untyped decorator factories" to "Failure to infer return type through untyped decorator factory" by @afonsotrepa on 2025-12-17 02:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @sharkdp on 2025-12-17 08:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 08:53</div>
            <div class="timeline-body"><p>Thank you for reporting this.</p>
<p>We currently don't support return type inference yet (which is why the return type of <code>deco</code> is just <code>Unknown</code>), but plan to add it soon. See #128 for details.</p>
<p>Note: It's actually not completely clear to me how other type checkers handle this case. It seems to me like we would have to infer a generic <code>âˆ€ T. Callable[[T], T]</code> type for <code>inner</code> here (and, in effect, for the return type of <code>deco</code>)? But pyright simply infers the type of <code>deco</code> as <code>(_: Unknown) -&gt; ((func: Unknown) -&gt; Unknown)</code>. So it looks like it might use additional heuristics (something like: &quot;if the return type of a decorator is Unknown, just pretend it acts like an identity operation&quot;)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @sharkdp on 2025-12-17 08:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">calls</span> added by @sharkdp on 2025-12-17 08:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type-inference</span> added by @sharkdp on 2025-12-17 08:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:30</div>
            <div class="timeline-body"><p>Yes, I think I remember some discussion of this. At least pyright (maybe some other type checkers too) do make the assumption that an untyped decorator doesn't change the signature. I'm not sold on this idea, though I can see why it's attractive.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 00:31</div>
            <div class="timeline-body"><p>I'm not sure this is really blocked by #128, since I don't think #128 will solve it, nor is necessary to &quot;solve&quot; it in the way that other type checkers do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Failure to infer return type through untyped decorator factory" to "Consider assuming that untyped decorators pass through the signature unchanged" by @carljm on 2025-12-18 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @carljm on 2025-12-18 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> removed by @carljm on 2025-12-18 00:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-18 01:34</div>
            <div class="timeline-body"><p>Actually this issue is still present if we type hint the decorator (and this was my original issue, I was just trying to create a minimalist example but clearly cut too much out, sorry):</p>
<pre><code class="language-Python">from collections.abc import Callable

def deco[**P, R](_: object) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:
    def inner(func: Callable[P, R]) -&gt; Callable[P, R]:
        return func
    return inner


@deco(0)
def f() -&gt; str:
    return &quot;&quot;


def g() -&gt; float:
    return f()
</code></pre>
<p>Same deal, ty (0.0.2) says all checks passed while pyright (1.1.407) correctly detects a &quot;reportReturnType&quot; (Type &quot;str&quot; is not assignable to return type &quot;float&quot;)  error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 15:48</div>
            <div class="timeline-body"><p>@afonsotrepa Thanks for the example! It looks like that is a different limitation: https://github.com/astral-sh/ty/issues/1136</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 15:58</div>
            <div class="timeline-body"><p>@afonsotrepa note also that this version works in all type checkers (including ty) today, because it doesn't rely on the special-cased heuristic in #1136:</p>
<pre><code class="language-py">from typing import Callable, Protocol

class Identity(Protocol):
    def __call__[**P, R](self, fn: Callable[P, R], /) -&gt; Callable[P, R]: ...

def deco(_: object) -&gt; Identity:
    def inner[**P, R](func: Callable[P, R]) -&gt; Callable[P, R]:
        return func
    return inner

@deco(0)
def f() -&gt; str:
    return &quot;&quot;


def g() -&gt; float:
    return f()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-18 17:19</div>
            <div class="timeline-body"><p>@carljm your Identity class fixed my issue, thanks!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-18 21:53</div>
            <div class="timeline-body"><p>We could also do this in a way that is LSP-specific, by implementing some form of &quot;best-guess types&quot; that we won't use to emit type diagnostics, but will use for LSP purposes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/afonsotrepa">@afonsotrepa</a> on 2025-12-18 23:02</div>
            <div class="timeline-body"><p>@carljm sorry for another &quot;off-topic&quot; comment but I found your Identity class was not working for generic functions when using functools.wraps, so instead I'm now using:</p>
<pre><code class="language-Python">def deco[**P, R](_: object) -&gt; Callable[[Callable[P, R]], Callable[P, R]]:

    def dec(func: Callable[P, R]) -&gt; Callable[P, R]:

        @functools.wraps(func)
        def wrapper(*args: P.args, **kwargs: P.kwargs) -&gt; R:
                return func(*args, **kwargs)

        return wrapper

    return dec
</code></pre>
<p>This works with ty and pyright and successfully catches invalid return types, even for functions with generics. Hopefully this will be useful for someone else too.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:54:35 UTC
    </footer>
</body>
</html>
