<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incomplete assignability implementation between two `Callable` types where one `Callable` type has `*args: Any, **kwargs: Any` - astral-sh/ty #1257</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Incomplete assignability implementation between two <code>Callable</code> types where one <code>Callable</code> type has <code>*args: Any, **kwargs: Any</code></h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1257">#1257</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-09-25 15:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-09-25 15:54</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>The typing spec <a href="https://typing.python.org/en/latest/spec/callables.html#meaning-of-in-callable">states</a>:</p>
<blockquote>
<p>If the input signature in a function definition includes both a <code>*args</code> and <code>**kwargs</code> parameter and both are typed as <code>Any</code> (explicitly or implicitly because it has no annotation), a type checker should treat this as the equivalent of <code>...</code>. Any other parameters in the signature are unaffected and are retained as part of the signature</p>
</blockquote>
<p>And we can see that in the conformance test suite, <a href="https://github.com/python/typing/blob/d4f39b27a4a47aac8b6d4019e1b0b5b3156fabdc/conformance/tests/callables_annotation.py#L157">this test</a> asserts that <code>Proto7</code> should be understood as being assignable to <code>Proto6</code>: although the signature of <code>Proto7</code> is less permissive than the signature of <code>Proto6</code>, <code>Proto6</code> has a gradual signature due to the presence of <code>*args: Any</code> and <code>**kwargs: Any</code> in the signature, so the normal rules do not apply. The definitions of <code>Proto6</code> and <code>Proto7</code> in this test are:</p>
<pre><code class="language-py">from typing import Protocol, Any

class Proto6(Protocol):
    def __call__(self, a: int, /, *args: Any, k: str, **kwargs: Any) -&gt; None: ...

class Proto7(Protocol):
    def __call__(self, a: float, /, b: int, *, k: str, m: str) -&gt; None: ...
</code></pre>
<p>Note that both <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=7356c7d052605729aa815aa7c84ceea4">mypy</a> and <a href="https://pyrefly.org/sandbox/?project=N4IgZglgNgpgziAXKOBDAdgEwEYHsAeAdAA4CeS4ATrgLYAEALqcROgOZ0Q3G6UN0AFag1wBjXFAA0dAILpSAHXRLRUVHDiDhuAGwAKIbhHioASkRK6Vuphhg6AfQejUUKE71wYUMNNSJOdAZpAHppACpUSjY4ALlSaQBrALgGSgjwxIB3KJi4%2BVM6AFoAPjoAOVx0GADCOqUVNQ0tI1wAdgNtE3NLa1t7Jxc3Dy8fPwCwKFxUYLowumwA1lnwpJS06Rp1ykLSiqqaujrCBqw7OjA9YjaAwxE2yR70azpcRIBGd9vtHToAXjo1ysAGI6AB5ADSShAkhAAFcGNA4CRyIgQKCAKqIqAQJgXOHoUSIqpwU79C68GgzBzoOE0bAwSh6fBLIK7MqpSgWZ7WSgwBhwyjPMAKEDlOkMrl0YD4AC%2BouhsthqCJEAAbjAAGLQGAUNBYPBEMggWVAA&amp;version=3.12">pyrefly</a> also appear to fail this test currently; only <a href="https://pyright-play.net/?pyrightVersion=1.1.405&amp;strict=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAK4MYAxmADYA0UAginALABQLpFAhgM5eHFgA2ABREwJchQCUALhZR5UACYBTYFAD660hwoVNQrsorAaHaZhQwaAehoAqDiDRdz9ODQDW5rjBD27HgDujs6uDJJQALQAfFAAcmAoyuYAdGksbJw8fGJgAOwi-BIycgoqaprauvqGxqbmwBRgHFZQtlAARuaorXae3r40EAMgETHxiclQaSkZzOVQwEIIeeaiJHklzApQYB4AjPtr-AJQALxQK-IAxFAA8gDSLEA">pyright</a> currently passes this test.</p>
<p>A version of this failing test for ty that doesn't involve protocols would be:</p>
<pre><code class="language-py">from typing import Any
from ty_extensions import CallableTypeOf, is_assignable_to, static_assert

def f(*args: Any, a: int, **kwargs: Any): ...
def g(fwomp: int, /, a: int, *, bar: str, baz: str): ...

static_assert(is_assignable_to(CallableTypeOf[g], CallableTypeOf[f]))
</code></pre>
<p>https://play.ty.dev/4f422ed6-1725-4230-b803-a62325e218f6</p>
<h3>Version</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">calls</span> added by @AlexWaygood on 2025-09-25 15:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type properties</span> added by @AlexWaygood on 2025-09-25 15:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-25 16:06</div>
            <div class="timeline-body"><p>I think our current implementation only treats a function as having a &quot;gradual signature&quot; if it has <code>*args: Any, **kwargs: Any</code> as its <em>only</em> parameters. I didn't actually realize that functions with <code>*args: Any, **kwargs: Any</code> and other parameters as well were also supposed to be treated specially.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-09-25 16:07</div>
            <div class="timeline-body"><blockquote>
<p>I didn't actually realize that functions with <code>*args: Any, **kwargs: Any</code> and other parameters as well were also supposed to be treated specially.</p>
</blockquote>
<p>No, neither did I. It's quite surprising to me TBH, but it's what the spec says, and it's what the conformance test suite enforces (the above test starts failing on https://github.com/astral-sh/ruff/pull/20368)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/erictraut">@erictraut</a> on 2025-09-25 17:11</div>
            <div class="timeline-body"><blockquote>
<p>It's quite surprising to me TBH</p>
</blockquote>
<p>When we were working on that part of the spec, we wanted to ensure that any callable signature that could be described using the <code>Callable</code> special form could also be described using a callback protocol. With the <code>Callable</code> special form, it's possible to express <code>Callable[Concatenate[int, ...], None]</code> which describes a callable with a position-only <code>int</code> parameter plus a gradual form for additional parameters. If you want to express the same signature using a callback protocol, you can use <code>def __call__(self, x: int, /, *args: Any, **kwargs: Any) -&gt; None: ...</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-09-25 17:22</div>
            <div class="timeline-body"><p>Thanks @erictraut, that makes a lot of sense!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2026-01-09 02:58</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:40:41 UTC
    </footer>
</body>
</html>
