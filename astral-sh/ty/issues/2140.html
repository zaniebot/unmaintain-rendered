<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>assume in narrowing that tuple subclasses don't override `__eq__` - astral-sh/ty #2140</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>assume in narrowing that tuple subclasses don&#x27;t override <code>__eq__</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2140">#2140</a>
        opened by <a href="https://github.com/dsfaccini">@dsfaccini</a>
        on 2025-12-21 04:34
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dsfaccini">@dsfaccini</a></div>
            <div class="timeline-body">Summary
<p>Ty does not narrow a <code>Literal</code>/tuple union when assigning to a wider <code>Literal</code> union.</p>
<p>Playground link: https://play.ty.dev/f8ecb06d-124e-4921-a082-9038c1302ed2</p>
Repro (self-contained)
<p><code>ty_repro_literal.py</code>:</p>
<pre><code>from typing import Literal

def demo(x: Literal[&#x27;none&#x27;, &#x27;auto&#x27;, &#x27;required&#x27;] | tuple[list[str], Literal[&#x27;auto&#x27;, &#x27;required&#x27;]]):
    y: Literal[&#x27;none&#x27;, &#x27;required&#x27;, &#x27;auto&#x27;] | int | None
    if x in (&#x27;auto&#x27;, &#x27;required&#x27;):
        y = x
    elif x == &#x27;none&#x27;:
        y = &#x27;none&#x27;
    elif isinstance(x, tuple):
        y = &#x27;auto&#x27;
    else:
        y = None
    return y
</code></pre>
<p>Run:</p>
<pre><code>uvx ty check ty_repro_literal.py
</code></pre>
Actual result
<pre><code>error[invalid-assignment]: Object of type `Literal[&quot;auto&quot;, &quot;required&quot;] | tuple[list[str], Literal[&quot;auto&quot;, &quot;required&quot;]]` is not assignable to `Literal[&quot;none&quot;, &quot;required&quot;, &quot;auto&quot;] | int | None`
 --&gt; ty_repro_literal.py:6:9
</code></pre>
Expected result
<p>No diagnostic: in the <code>x in (&#x27;auto&#x27;, &#x27;required&#x27;)</code> branch, <code>x</code> is narrowed to <code>Literal[&#x27;auto&#x27;, &#x27;required&#x27;]</code>, which is assignable to <code>Literal[&#x27;none&#x27;, &#x27;required&#x27;, &#x27;auto&#x27;] | int | None</code>.</p>
Notes
<p>Occurs on <code>ty 0.0.4</code> via <code>uvx ty check</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">narrowing</span> added by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-21 05:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/charliermarsh">@charliermarsh</a> by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-12-21 13:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 18:05</div>
            <div class="timeline-body"><p>Thanks for the report!</p>
<p>ty is working as designed in this case, and is in fact highlighting a hole in the logic of your code.</p>
<p>The type <code>tuple</code> includes subclasses of the built-in tuple, and such subclasses are free to arbitrarily override <code>__eq__</code> in such a way that they would compare equal to the string &quot;auto&quot; or the string &quot;required&quot;, thus passing the <code>if x in (&#x27;auto&#x27;, &#x27;required&#x27;)</code> check. Thus if we add a <code>reveal_type(x)</code> inside the first <code>if</code> body, we can see that ty narrows away the possibility of <code>Literal[&#x27;none&#x27;]</code>, but it does not narrow away the possibility of the tuple type, and this leads to the error on assigning to <code>y</code>.</p>
<p>Adding an <code>isinstance(x, str)</code> condition to that first <code>if</code> test closes this hole, and the error goes away.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 18:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-22 18:09</div>
            <div class="timeline-body"><blockquote>
<p>The type <code>tuple</code> includes subclasses of the built-in tuple, and such subclasses are free to arbitrarily override <code>__eq__</code></p>
</blockquote>
<p>Though I think we&#x27;re planning to ban <code>__eq__</code> overrides (and overrides of other comparison methods) on tuple subclasses, or many of the <code>Literal</code> types we infer for tuple comparisons aren&#x27;t sound?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-22 19:10</div>
            <div class="timeline-body"><p>I think that ban would mean that the requested narrowing here would in fact be sound. Even though <code>tuple[list[str], Literal[&quot;auto&quot;, &quot;required&quot;]]</code> is not a single-valued type (due to the <code>list[str]</code> element), if we &quot;know&quot; that <code>tuple.__eq__</code> was not overridden on any subclass of <code>tuple</code> then we can be confident that an object with that type will never compare equal to an object of type <code>Literal[&quot;auto&quot;]</code> or an object of type <code>Literal[&quot;required&quot;]</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 19:51</div>
            <div class="timeline-body"><p>Yep, agreed. I remembered discussion of banning <code>__bool__</code> and <code>__len__</code> on tuple subclasses (in #215 and #560); I&#x27;m not finding explicit discussion of banning <code>__eq__</code> also, but I think you&#x27;re right that we do other narrowing that&#x27;s only valid if we do.</p>
<p>So I&#x27;ll reopen this (and review Charlie&#x27;s PR!). Also created #2171 to explicitly track our intention re tuple subclasses. I thought maybe we had an issue for this already, but I couldn&#x27;t find one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 19:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;ty literal narrowing: invalid-assignment after Literal branch test&quot; to &quot;assume in narrowing that tuple subclasses don&#x27;t override `__eq__`&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 19:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/charliermarsh">@charliermarsh</a> on 2025-12-22 20:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dsfaccini">@dsfaccini</a> on 2025-12-22 22:07</div>
            <div class="timeline-body"><p>thank you all for checking this out</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:41 UTC
    </footer>
</body>
</html>
