<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enforce the Liskov Substitution Principle for non-methods - astral-sh/ty #2158</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Enforce the Liskov Substitution Principle for non-methods</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/2158">#2158</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-12-22 13:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-22 13:54</div>
            <div class="timeline-body"><p>We have implemented a basic version of the Liskov Substitution Principle to cover cases where methods are incompatibly overridden in subclasses. We also need to implement separate diagnostics to cover properties incompatibly overridden in subclasses, and mutable attributes incompatibly overridden in subclasses.</p>
<p>The reason why these are planned as separate diagnostics is because a large amount of code in the ecosystem unsoundly overrides mutable attributes covariantly, e.g.</p>
<pre><code class="language-py">class A:
    x: int

class B(A):
    x: bool
</code></pre>
<p>Partly this is because mypy allowed this for years -- and still does, unless users explicitly opt into the <code>mutable-override</code> error code. Implementing these as separate diagnostics to our existing <code>invalid-method-override</code> diagnostic will therefore allow users to switch the mutable-attribute-override rule off specifically if it causes a large number of diagnostics on their code.</p>
<hr />
<p>Sub-tasks (many of these may share a common implementation):</p>
<ul>
<li><p>[ ] Enforce Liskov for property types: this should cause us to emit a diagnostic:</p>
<pre><code class="language-py">class A:
    @property
    def f(self) -&gt; int:
        return 42

class B(A):
    @property
    def f(self) -&gt; str:  ❌ Superclass returns `int`, subclass returns `str`, `str` is not a subtype of `int`
        return &quot;42&quot;
</code></pre>
</li>
<li><p>[ ] Enforce that a writable attribute cannot be overridden with a read-only property:</p>
<pre><code class="language-py">class A:
    x: int

class B(A):
    @property
    def x(self) -&gt; int:  ❌ Superclass attribute is writable, subclass attribute is read-only
        return 42
</code></pre>
<p>and</p>
<pre><code class="language-py">class A:
    @property
    def x(self) -&gt; int:
        return 42

    @x.setter
    def x(self, value: int) -&gt; None: ...

class B(A):
    @property
    def x(self) -&gt; int:  ❌ Superclass attribute is writable, subclass attribute is read-only
        return 42
</code></pre>
</li>
<li><p>[ ] Enforce Liskov for attribute types:</p>
<pre><code class="language-py">class A:
    x: int

class B(A):
    x: bool  ❌ Type of `x` attribute is invariant because it is mutable
</code></pre>
</li>
<li><p>[ ] Enforce that a non-<code>Final</code> attribute cannot be overridden with a <code>Final</code> one</p>
<pre><code class="language-py">from typing import Final

class A:
    x: int

class B(A):
    x: Final[int]  ❌ Superclass attribute is writable, subclass attribute is read-only
</code></pre>
</li>
<li><p>[ ] Enforce that a non-<code>ClassVar</code> attribute cannot be overridden with a <code>ClassVar</code> attribute:</p>
<pre><code class="language-py">from typing import ClassVar

class A:
    x: int

class B(A):
    x: ClassVar[int]  ❌ Superclass attribute is writable on instances, subclass attribute is not
</code></pre>
</li>
<li><p>[ ] Enforce that a <code>ClassVar</code> attribute cannot be overridden with an implicit instance attribute, since <code>ClassVar</code>s can be mutated on the class object itself but implicit instance attributes cannot:</p>
<pre><code class="language-py">from typing import ClassVar

class A:
    x: ClassVar[int]

class B(A):
    def __init__(self):
        self.x: int  ❌ Superclass attribute is writable on the class object, subclass attribute is not
</code></pre>
</li>
<li><p>[ ] Enforce that a non-<code>ReadOnly</code> <code>TypedDict</code> field cannot be overridden with a <code>ReadOnly</code> <code>TypedDict</code> field:</p>
<pre><code class="language-py">from typing import TypedDict, ReadOnly

class A(TypedDict):
    x: int

class B(A):
    x: ReadOnly[int]  ❌ Superclass field is writable, subclass attribute is read-only
</code></pre>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @AlexWaygood by @AlexWaygood on 2025-12-22 13:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">typing semantics</span> added by @AlexWaygood on 2025-12-22 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @AlexWaygood on 2025-12-22 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/beauxq">@beauxq</a> on 2025-12-22 14:07</div>
            <div class="timeline-body"><p>I think it's an important checklist item to check multiple levels of subclasses, not just one base class and one subclass -
because mypy and pyright each get things wrong in different places here:</p>
<pre><code class="language-python">from typing import ClassVar, reveal_type

class B:
    x: ClassVar[int | str] = 0

class C(B):
    x = &quot;random&quot;

class D(C):
    x = 1  # mypy complains when it shouldn't

class E(D):
    x = b&quot;x&quot;  # pyright doesn't complain when it should


def foo(b: type[B]) -&gt; None:
    x = b.x
    reveal_type(x)
    if isinstance(x, str):
        print(x + &quot;y&quot;)
    else:
        reveal_type(x)
        print(x + 3)


foo(E)
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:53:03 UTC
    </footer>
</body>
</html>
