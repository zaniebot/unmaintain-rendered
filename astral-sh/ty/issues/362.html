<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Excessive runtime for large unions of tuples - astral-sh/ty #362</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Excessive runtime for large unions of tuples</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/362">#362</a>
        opened by <a href="https://github.com/nijel">@nijel</a>
        on 2025-05-13 17:48
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/nijel">@nijel</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>I wanted to give <code>ty</code> a try, but it doesn't seem to complete at all on our repo.</p>
<p>I tried to reduce the scope, and it seems to hang on a single file:</p>
<pre><code>uvx ty check weblate/settings_docker.py
</code></pre>
<p>The file in question is https://github.com/WeblateOrg/weblate/blob/main/weblate/settings_docker.py</p>
<p>Maybe I'm just too impatient, but I waited several minutes without any output.</p>
<h3>Version</h3>
<p>0.0.1</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @sharkdp on 2025-05-13 18:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-13 18:04</div>
            <div class="timeline-body"><p>Thank you for reporting this!</p>
<p>From looking at the logs (<code>-vvv</code> in debug mode), it looks like we have problems with the large tuple types that are being constructed in that file. So it might be an instance of #71 (Edit: well, probably not).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">hang</span> added by @MichaReiser on 2025-05-13 18:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2025-05-13 18:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "hangs on some files" to "Excessive runtime for large unions of tuples" by @sharkdp on 2025-05-13 18:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-13 19:02</div>
            <div class="timeline-body"><p>The code in question here essentially does something like the following (see the conditional <code>AUTHENTICATION_BACKENDS += …</code> assignments in the original file):</p>
<pre><code class="language-py">t = ()
if &lt;some check&gt;:
    t += (1,)
if &lt;some check&gt;:
    t += (2,)
if &lt;some check&gt;:
    t += (3,)
if &lt;some check&gt;:
    t += (4,)
# …
if &lt;some check&gt;:
    t += (N,)
</code></pre>
<p>Since every check can be either true or false, this (tries to) build up a union-of-tuples type with 2^N elements. In the original file, N = 24, so that's ~16 million union elements.</p>
<p><code>pyright</code> handles this by falling back to <code>tuple[()] | tuple[Literal[1]] | tuple[int, ...] </code>. Not sure what the exact heuristic is, but at some point it adds <code>tuple[U, ...]</code> members (potential several of them), where <code>U</code> is a combination of (literal-widened) types of respective tuple elements.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nijel">@nijel</a> on 2025-05-14 06:38</div>
            <div class="timeline-body"><p>Is there really heuristic needed? In this particular case, the variable is type annotated since the beginning:</p>
<pre><code class="language-py">AUTHENTICATION_BACKENDS: tuple[str, ...] = ()
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-14 06:46</div>
            <div class="timeline-body"><p>We generally keep track of both: the declared type (if available) and the inferred type. This allows us to check each of the annotated assignments (is the inferred type assignable to the declared type?). And in general, this allows the inferred type to be &quot;narrower&quot; than the declared type. This can be useful if you have something like:</p>
<pre><code class="language-py">def get_int() -&gt; int:
    return -17


x: int | None = get_int()

reveal_type(x)  # int

if x &lt; 0:  # declared type is `int | None`, but inferred type is `int`, so this is fine.
    x = None

reveal_type(x)  # int | None
</code></pre>
<p>So that declared type of <code>tuple[str, ...]</code> doesn't help us here. And even if it would, we'd still need to make sure that we can handle the same situation without a declared type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @sharkdp by @sharkdp on 2025-05-14 12:04</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Beta" by @carljm on 2025-06-11 00:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 15:16</div>
            <div class="timeline-body"><p>We removed precise inference for tuple concatenation, so the issue reported here (in this form) should be fixed now.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-08-15 15:16</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:19:51 UTC
    </footer>
</body>
</html>
