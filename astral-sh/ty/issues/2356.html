<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type narrowing failures involving `Never` - astral-sh/ty #2356</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Type narrowing failures involving <code>Never</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2356">#2356</a>
        opened by <a href="https://github.com/lsorber">@lsorber</a>
        on 2026-01-06 08:39
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/lsorber">@lsorber</a> on 2026-01-06 08:39</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>I found three cases involving a generic parameter <code>T</code> that defaults to <code>Never</code> where ty fails to narrow a type. It is possible to get it to narrow the type correctly with a <code>case Unit() as alias:</code>, but not without <code>as alias</code>.</p>
<p>Minimal reproducible example (<a href="https://play.ty.dev/100eb6e4-decd-4482-96a2-6bedff6d066d">ty playground</a>):</p>
<pre><code class="language-python">from typing import Any, Never


class Unit[T: str = Never]:
    mapping: dict[T, Any]

    def __init__(self, key: T | None = None) -&gt; None: ...


def success[T: str = Never](unit: Unit[T] | T) -&gt; Unit[T]:
    match unit:
        case Unit() as unit_key:
            return unit_key  # Narrowing succeeds!
        case key if not isinstance(key, Unit):
            return Unit[T](key)  # Narrowing succeeds!
    raise AssertionError(&quot;Unreachable&quot;)


def error_match[T: str = Never](unit: Unit[T] | T) -&gt; Unit[T]:
    match unit:
        case Unit():
            return unit  # Case 1: Narrowing fails?
        case key if not isinstance(key, Unit):
            return Unit[T](key)  # Narrowing succeeds!
    raise AssertionError(&quot;Unreachable&quot;)


def error_isinstance[T: str = Never](unit: Unit[T] | T) -&gt; Unit[T]:
    if isinstance(unit, Unit):
        return unit  # Case 2: Narrowing fails?
    if not isinstance(unit, Unit):
        return Unit[T](unit)  # Case 3: Narrowing fails?
    raise AssertionError(&quot;Unreachable&quot;)
</code></pre>
<p>Output:</p>
<pre><code>Return type does not match returned value: expected `Unit[T@error_match]`, found `(Unit[T@error_match] &amp; Unit[Never]) | (T@error_match &amp; Unit[Never])` (invalid-return-type) [Ln 22, Col 20]
Return type does not match returned value: expected `Unit[T@error_isinstance]`, found `(Unit[T@error_isinstance] &amp; Unit[Never]) | (T@error_isinstance &amp; Unit[Never])` (invalid-return-type) [Ln 30, Col 16]
Argument to bound method `__init__` is incorrect: Expected `T@error_isinstance | None`, found `(Unit[T@error_isinstance] &amp; ~Unit[Never]) | (T@error_isinstance &amp; ~Unit[Never])` (invalid-argument-type) [Ln 32, Col 24]
</code></pre>
<h3>Version</h3>
<p>0.0.9</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hoxbro">@hoxbro</a> on 2026-01-06 13:32</div>
            <div class="timeline-body"><p>I have a similar problem with the following:</p>
<pre><code class="language-python">import sys

def func() -&gt; tuple[int, int] | None: ...

output = func()

if output is None:
    sys.exit(1)
else:
    a, _ = output  # works

b, _ = output  # fails
</code></pre>
<p>https://play.ty.dev/3a7e4154-8ba3-4fb5-a14e-7dc3512f250d</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 13:40</div>
            <div class="timeline-body"><p>@hoxbro your issue is covered by https://github.com/astral-sh/ty/issues/690, which at first glance this PR appears unrelated to.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-06 14:07</div>
            <div class="timeline-body"><p>Thanks for the report @lsorber! There's a heady mix of false negatives, false positives and true positives going on here from ty. I'll take your functions one by one...</p>
<hr />
<p>For the <code>success()</code> case -- unfortunately this is not a case of &quot;narrowing succeeding&quot; :/ It's actually a TODO from ty:</p>
<pre><code class="language-py">def success[T: str = Never](unit: Unit[T] | T) -&gt; Unit[T]:
    match unit:
        case Unit() as unit_key:
            reveal_type(unit_key)  # revealed: @Todo
            return unit_key
        case key if not isinstance(key, Unit):
            return Unit[T](key)
    raise AssertionError(&quot;Unreachable&quot;)
</code></pre>
<p>We don't yet infer a precise type for <code>as</code> bindings in <code>match</code> statements, unfortunately; <code>@Todo</code> is equivalent to <code>Any</code>. Because <code>Any</code> and <code>@Todo</code> are assignable to anything, this leads to no diagnostic being emitted: <code>Any</code> is assignable to the return type of <code>Unit[T]</code>.</p>
<hr />
<p>For <code>error_match</code>, your <code>return unit</code> fails because ty has inferred a type of <code>(Unit[T] &amp; Unit[Never]) | (T &amp; Unit[Never])</code>, which it says is not assignable to the return type of <code>Unit[T]</code>.</p>
<pre><code class="language-py">def error_match[T: str = Never](unit: Unit[T] | T) -&gt; Unit[T]:
    match unit:
        case Unit():
            return unit  # Case 1: Narrowing fails?
        case key if not isinstance(key, Unit):
            return Unit[T](key)  # Narrowing succeeds!
    raise AssertionError(&quot;Unreachable&quot;)
</code></pre>
<p>There's definitely <em>a</em> bug here: I think the type ty <em>should</em> have inferred here is <code>Unit[T] | (T &amp; Unit[str])</code>. What happens is that inside the <code>case Unit()</code> branch, ty intersects the pre-existing type of <code>unit</code> (<code>Unit[T] | T</code>) with the &quot;top materialization&quot; of the <code>Unit</code> type. The &quot;top materialization&quot; of a type is a theoretical type which all materializations of that type are subtypes of. For example, the top materialization of <code>Sequence[Any]</code> is <code>Sequence[object]</code>: whatever fully static type <code>T</code> the <code>Any</code> there materializes to, <code>Sequence[T]</code> will always be a subtype of <code>Sequence[object]</code>. In this case, the top materialization of <code>Unit</code> is <code>Unit[str]</code>, because <code>Unit</code> is generic over a type variable that has <code>str</code> as its upper bound; it's impossible to conceive of a valid materialization of <code>Unit</code> that would not be a subtype of <code>Unit[str]</code>. Unfortunately, ty gets this wrong and says that the top materialization of <code>Unit</code> is <code>Unit[Never]</code> -- it uses the TypeVar's default rather than the TypeVar's upper bound. This is tracked in https://github.com/astral-sh/ty/issues/1164, though your issue makes me think that we should bump the priority of that bug report!</p>
<p>If we had inferred the correct top materialization of <code>Unit</code>, then we would have inferred <code>(Unit[str] &amp; Unit[T]) | (Unit[str] &amp; T)</code>, which would have simplified to <code>Unit[T] | (T &amp; Unit[str])</code>. But even if we'd inferred the correct top materialization of <code>Unit</code>, that still would have led us to emit an error on this line -- we would have inferred <code>Unit[T] | (T &amp; Unit[str])</code>, which is not assignable to your return type of <code>Unit[T]</code>. We infer that <code>T &amp; Unit[str]</code> is a possibility here, because <code>T</code> and <code>Unit[T]</code> are not necessarily disjoint types! It's possible to conceive of cases where, due to multiple inheritance, a type checker believes an instance of <code>T</code> is being passed in, but the instance of <code>T</code> is <em>also</em> an instance of <code>Unit</code>, and so the first branch of your <code>match</code> statement ends up being taken:</p>
<pre><code class="language-py">class Bar(Unit[str], str): ...

def returns_foo() -&gt; str:
    return Bar()

reveal_type(error_match(returns_foo()))
</code></pre>
<p>If you add <code>@final</code> to your <code>Unit</code> class, however, ty is able to correctly see that <code>Unit</code> and <code>T</code> are disjoint, and the error goes away. Our revealed types here are a bit confused because of the top-materialization bug I mentioned above, but I believe/hope we still would not emit an error on this even if that bug was fixed: https://play.ty.dev/4d0657ce-7dd5-43a5-ac89-c965ebe13649</p>
<hr />
<p>I think the issues with your third function are basically the same as discussed with your second function.</p>
<hr />
<p>All that said... I don't think there's anything here that isn't discussed in other existing issues:</p>
<ul>
<li>The <code>@Todo</code> type for the <code>match</code> statement is covered by https://github.com/astral-sh/ty/issues/887, I think</li>
<li>The top-materialization bug is covered by https://github.com/astral-sh/ty/issues/1164</li>
<li>https://github.com/astral-sh/ty/issues/1578 discusses whether we should be less &quot;pedantic&quot; about narrowing in cases involving multiple inheritance</li>
</ul>
<p>Thanks again for the report!!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2026-01-06 14:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lsorber">@lsorber</a> on 2026-01-06 15:29</div>
            <div class="timeline-body"><p>Thank you for the thorough analysis, @AlexWaygood!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:42:03 UTC
    </footer>
</body>
</html>
