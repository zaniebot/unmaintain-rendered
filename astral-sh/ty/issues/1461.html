<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Signatures of methods in generic classes should not use `Unknown` specialization - astral-sh/ty #1461</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Signatures of methods in generic classes should not use <code>Unknown</code> specialization</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1461">#1461</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-10-31 12:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-10-31 12:38</div>
            <div class="timeline-body"><p>The signature of <code>C.f</code> should include the <code>T</code> type parameter, not <code>Unknown</code>:</p>
<pre><code class="language-py">from typing import reveal_type

class C[T]:
    def f(self, x: T) -&gt; None:
        pass

reveal_type(C.f)  # ty: def f(self, x: Unknown) -&gt; None

C.f(C[int](), &quot;foo&quot;)  # this should be an error
</code></pre>
<p>https://play.ty.dev/83603661-a572-4022-b155-e560f5bbbe85</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @sharkdp on 2025-10-31 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @sharkdp on 2025-10-31 12:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-31 17:57</div>
            <div class="timeline-body"><p>This is interesting, because it implies that when accessing an unbound method from a generic class, we should implicitly create a generic function with its own generic context and bound typevar instance.</p>
<p>Behavior of other type checkers seems to be a bit all over the place here. <a href="https://pyright-play.net/?pyrightVersion=1.1.405&amp;strict=true&amp;code=MYGwhgzhAEDCDaAVAugLgLACho%2BgEwFMAzaAWwIBcALAezwAoICQiAaaAD1WkQEpoAtAD4eGbLgkAnSgFdJAO05Ys0gG4EwIAPoUAngAcC9WADpy1Or2WZT52gwQBLeRWT1e7AEREaNT1cwgA">Pyright</a> just uses <code>Unknown</code>, like we do currently. <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=a4474cbc042f17218e0d3ea6517e6399">Mypy</a> seems to attempt to do the thing suggested in this issue, but fails to do it correctly -- it ends up with <code>T</code> in the generic context but <code>T'1</code> in the signature, and then fails to solve for <code>T</code> when you try to call it. <a href="https://pyrefly.org/sandbox/?project=N4IgZglgNgpgziAXKOBDAdgEwEYHsAeAdAA4CeSIAxlKnHAAQDCA2gCoC6iAOuvX-Zhhh6AWxgAXABa5MACjgwoYADT18ieqwCU9ALQA%2BTd179TAJwkBXM73w8eFgG4xUUAPrjSxGLMaExUjJa9uh%2BAdJyLBDo4uyyWqpc4Li4SVogyiCW4tBwJOSIIADE9ACqOVAQnvRgluiUObjocCGCwmC4ZiKo4m7oliLYMGay6vTR4joG9HDiZsbmVjY1SQByA0Pz9MD4AL5JPBkgZBZgUKSE4rgiUBQlAAqkp%2BczGDgE9JRNkADm1j0QJqEHglADKMBg9Ek4nExDgiAA9AiTkJzoROj8ETB0AjMLhKHAEV90L9-o0cTVOvRUI5UNBUNhYJ9vhA-mYAU16LhiOS8jwyIF0LpnGY4IDeABeehJADMhAAjAAmA7oEC7TKoBoQZwAMWgMAoaCweCIZDVQA">Pyrefly</a> appears to do the right thing.</p>
<p>I think the pyrefly behavior is what we want, but the wide range of behaviors suggests this isn't a high priority.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-31 18:00</div>
            <div class="timeline-body"><p>The thing that's a bit strange here is that normally an un-specialized reference to <code>C</code> where <code>C</code> is a generic class, implies <code>C[Unknown]</code> (aka the default specialization). Our current behavior, and pyright's behavior, are consistent with that. In order to fix this issue, it sort of seems like we'd be special-casing <code>C.f</code> so that we <em>don't</em> apply the default specialization when we are about to access an attribute of a class. This would definitely complicate the question of when the default specialization should be applied; it's not immediately clear to me what rules should be applied.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:40:54 UTC
    </footer>
</body>
</html>
