<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider separate Rust types and `Type` enum variants for bound vs unbound type variables - astral-sh/ty #926</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Consider separate Rust types and `Type` enum variants for bound vs unbound type variables</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/926">#926</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-08-01 15:01
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/dcreager">@dcreager</a> on 2025-08-01 15:01</div>
            <div class="timeline-body"><p>&quot;Bind&quot; can confusingly mean ~3 different things when talking about Python type variables. Here I mean that a legacy typevar is <em>defined</em> before it is <em>used</em> (or &quot;bound&quot;), and that it can be used/bound multiple times:</p>
<pre><code class="language-py">from typing import Generic, TypeVar

T = TypeVar(&quot;T&quot;)                                   # [1]

def first_binding(t: T) -&gt; T: ...                  # [2]

class SecondBinding(Generic[T]):                   # [3]
    def not_a_new_binding(self, t: T) -&gt; T: ...
</code></pre>
<p>As of https://github.com/astral-sh/ruff/pull/19604, we create a <code>TypeVarInstance</code> for the legacy typevar when it is first defined (<code>[1]</code>), and then additional distinct <code>TypeVarInstance</code>s each time it is used/bound (<code>[2]</code> and <code>[3]</code>).</p>
<p>@MichaReiser suggested trying to use separate Rust types to track the unbound and bound typevars. This turned out to be a beefy enough change that we decided not to fold it into https://github.com/astral-sh/ruff/pull/19604, but it is still worth considering as follow-on work. The hope is that this would bring a performance win, since <code>TypeVarInstance</code> is a salsa-interned struct that we are now creating many more instances of. (We would presumably <em>not</em> have salsa track or intern the proposed <code>BoundTypeVarInstance</code>.)</p>
<p>Note that it would require separate <code>Type</code> variants for bound and unbound typevars, since there are places where we need to refer to (the type of) the legacy typevar before it has been bound:</p>
<pre><code class="language-py">from typing import Generic, TypeVar

T = TypeVar(&quot;T&quot;)
U = TypeVar(&quot;U&quot;, default=T)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @dcreager on 2025-08-01 15:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-06 21:03</div>
            <div class="timeline-body"><blockquote>
<p>Note that it would require separate <code>Type</code> variants for bound and unbound typevars</p>
</blockquote>
<p>I'm a little confused about this part. Do we need any more <code>Type</code> variants than we already have?</p>
<p>We already have <code>Type::TypeVar</code> for &quot;the unknown (possibly bounded/constrained) type spelled by a use of a typevar as a type annotation in a scope where it is bound&quot; -- this should <em>always</em> contain a bound typevar. And we also already have <code>Type::KnownInstance(KnownInstanceType::TypeVar(...))</code> for &quot;the actual <code>typing.TypeVar</code> instance itself, as a runtime Python object&quot;. I think this latter should always contain an unbound typevar, though it's less clear whether it matters, since &quot;boundness&quot; is meaningless in this case. Consider:</p>
<pre><code class="language-py">T = TypeVar(&quot;T&quot;)

def f(x: T) -&gt; T:
    y = T
    z: T = x
    return z
</code></pre>
<p>the type of <code>y</code> should be <code>Type::KnownInstance(KnownInstanceType::TypeVar(&lt;T&gt;))</code>, it should not be <code>Type::TypeVar(&lt;T&gt;)</code> (because this is a value-expression load of the object referenced by the name T, which is simply a regular instance of the class <code>typing.TypeVar</code>; <code>y</code> does not have a generic type). I think ideally the TypeVarInstance wrapped here would not be bound, because boundness has no meaning here. In <code>z: T = x</code>, however, <code>z</code> should have a <code>Type::TypeVar</code> type, which should definitely wrap a bound TypeVarInstance.</p>
<p>I feel like perhaps this calls into question the strategy of binding typevars in <code>infer_place_load</code> in the first place; it seems like maybe we should really only ever be binding them in <code>in_type_expression</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-08-07 01:04</div>
            <div class="timeline-body"><p>I've replied to the above comments in https://github.com/astral-sh/ruff/pull/19796, which implements this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-08-11 19:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:21 UTC
    </footer>
</body>
</html>
