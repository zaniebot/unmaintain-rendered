<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced pattern matching support - astral-sh/ty #887</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Advanced pattern matching support</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/887">#887</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-07-25 07:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/sharkdp">@sharkdp</a></div>
            <div class="timeline-body"><p>We already have basic support for control flow analysis and type narrowing in <code>match</code> statements, but our support is not complete. The list below shows some examples of things that are not working yet, but is probably not exhaustive:</p>
<ul>
<li><p>[ ] Type inference for names that are bound in patterns:</p>
<pre><code>from dataclasses import dataclass

@dataclass
class Person:
    name: str
    age: int

def f(person: Person):
    match person:
        case Person(name, age):
            reveal_type(name)  # @Todo(`match` pattern definition types)
            reveal_type(age)  # @Todo(`match` pattern definition types)

def g(xs: list[int]):
    match xs:
        case [1, 2, x]:
            reveal_type(x)  # @Todo(`match` pattern definition types)
</code></pre>
</li>
<li><p>[ ] Support for <code>__match_args__</code></p>
</li>
<li><p>[ ] <a href="https://docs.python.org/3/reference/compound_stmts.html#class-patterns">Matching on builtin classes</a></p>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">narrowing</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-07-25 07:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">control flow</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-07-25 07:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;GA&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-07-25 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/UnboundVariable">@UnboundVariable</a> on 2025-07-25 21:14</div>
            <div class="timeline-body"><p>Here are some additional cases to track:</p>
<ul>
<li>[ ] Support for <code>Callable()</code> in class patterns</li>
</ul>
<pre><code>def test(subj: int | type[int] | Callable[..., str]) -&gt; int | str | None:
    match subj:
        case Callable():
            reveal_type(subj)  # type[int] | ((...) -&gt; str)

        case _:
            reveal_type(subj)  # int
</code></pre>
<ul>
<li>[ ] <code>self</code> as a subject expression:</li>
</ul>
<pre><code>class ClassA:
    def method1(self) -&gt; str:
        match self:
            case ClassA():
                return &quot;&quot;
</code></pre>
<ul>
<li>[ ] Exhaustion detection for sequence patterns with a star entry:</li>
</ul>
<pre><code>def test() -&gt; int:
    match [10]:
        case [*values]:
            return values[0]
</code></pre>
<ul>
<li>[ ] Inferring types from literal patterns:</li>
</ul>
<pre><code>def test(subj):
    match subj:
        case 3 as a1, -3 as a2:
            reveal_type(a1) # Literal[3]
            reveal_type(a2) # Literal[-3]
</code></pre>
<ul>
<li>[ ] Inferring sequence type from sequence pattern:</li>
</ul>
<pre><code>def test(subj):
    match subj:
        case a, b:
            reveal_type(subj)  # Sequence[Unknown]

        case 1, 2:
            reveal_type(subj)  # Sequence[int]
</code></pre>
<ul>
<li>[ ] Narrowing for <code>None</code>:</li>
</ul>
<pre><code>def test(subj: int | None):
    match subj:
        case None as a:
            reveal_type(a) # None

        case b:
            reveal_type(b) # int
</code></pre>
<ul>
<li>[ ] Discriminated union narrowing based on literal attribute types:</li>
</ul>
<pre><code>class A:
    tag: Literal[&quot;a&quot;]
    name: str


class B:
    tag: Literal[&quot;b&quot;]
    num: int


def test(subj: A | B) -&gt; None:
    match subj.tag:
        case &quot;c&quot;:
            reveal_type(subj)  # Never

        case &quot;a&quot;:
            reveal_type(subj)  # A

        case _:
            reveal_type(subj)  # B
</code></pre>
<ul>
<li>[ ] Narrowing based on mapping pattern:</li>
</ul>
<pre><code>def test(subj: int | dict[str, str]):
    match subj:
        case {1: _}:
            reveal_type(subj)  # Never

        case {&quot;&quot;: &quot;&quot;}:
            reveal_type(subj)  # dict[str, str]
</code></pre>
<ul>
<li>[ ] Discriminated TypedDict narrowing based on mapping pattern:</li>
</ul>
<pre><code>class IntValue(TypedDict):
    type: Literal[&quot;Int&quot;]
    value: int

class StrValue(TypedDict):
    type: Literal[&quot;Str&quot;]
    value: str

def test(subj: IntValue | StrValue | int) -&gt; None:
    match subj:
        case {&quot;type&quot;: &quot;Int&quot;}:
            reveal_type(subj)  # IntValue

        case {&quot;type&quot;: &quot;Str&quot;}:
            reveal_type(subj)  # StrValue

        case _:
            reveal_type(subj)  # int
</code></pre>
<ul>
<li>[ ] Tuple subject expressions with tuple expansion:</li>
</ul>
<pre><code>class A1: pass
class A2: pass
class B1: pass
class B2: pass

type A = A1 | A2
type B = B1 | B2

def test(a: A, b: B):
    subj = a, b
    match subj:
        case A1(), B1():
            reveal_type(subj)  # tuple[A1, B1]

        case A1(), _:
            reveal_type(subj)  # tuple[A1, B2]

        case _:
            reveal_type(subj)  # tuple[A2, B1 | B2]
</code></pre>
<ul>
<li>[ ] Length-based narrowing of tuple subjects:</li>
</ul>
<pre><code>def test(subj: tuple[int] | tuple[str, str] | tuple[int, *tuple[str, ...], complex]):
    match subj:
        case (x,):
            reveal_type(subj)  # tuple[int]

        case (x, y):
            reveal_type(subj)  # tuple[str, str] | tuple[int, complex]

        case (x, y, z):
            reveal_type(subj)  # tuple[int, str, complex]
</code></pre>
<ul>
<li>[ ] Narrowing enums based on value patterns:</li>
</ul>
<pre><code>class Color(Enum):
    Red = &quot;red&quot;
    Blue = &quot;blue&quot;

class Pet(Enum):
    Dog = &quot;dog&quot;
    Cat = &quot;cat&quot;

def test(subj: Color | Pet):
    match subj:
        case Color.Red | Color.Blue:
            reveal_type(subj)  # Color

        case Pet.Dog:
            reveal_type(subj)  # Pet.Dog

        case _:
            reveal_type(subj)  # Pet.Cat
</code></pre>
<ul>
<li>[ ] Value patterns using <code>Final</code> values:</li>
</ul>
<pre><code>class Numbers:
    ZERO: Final = 0.0
    ONE: Final = 1
    INFINITY: Final = float(&quot;inf&quot;)

def test(subj: float):
    match subj:
        case Numbers.ONE:
            reveal_type(subj)  # Literal[1]

        case Numbers.INFINITY:
            reveal_type(subj)  # float

        case Numbers.ZERO:
            reveal_type(subj)  # float

        case _:
            reveal_type(subj)  # float
</code></pre>
<ul>
<li>[ ] Narrowing of expressions used in tuple subject expression:</li>
</ul>
<pre><code>def test(a: int, b: str):
    match a, b:
        case 1, &quot;hi&quot;:
            reveal_type(a)  # Literal[1]
            reveal_type(b)  # Literal[&quot;hi&quot;]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/silamon">@silamon</a> on 2025-08-29 09:03</div>
            <div class="timeline-body"><p>I&#x27;ve been looking a bit into how to code the remaining bullets:</p>
<ol>
<li>It&#x27;s missing the <code>match</code> pattern definition types in infer, but I&#x27;m not seeing how we are able to set up an expression there using infer_expression_types. The code comment <a href="https://github.com/astral-sh/ruff/blob/0d7ed32494df58f62ed6b48a3491f258ca7fd086/crates/ty_python_semantic/src/types/infer.rs#L3664">https://github.com/astral-sh/ruff/blob/0d7ed32494df58f62ed6b48a3491f258ca7fd086/crates/ty_python_semantic/src/types/infer.rs#L3664</a> there was maybe too hard to understand for me.</li>
<li>The match examples rely mostly on sequences and some even more advanced matching examples, but looks like they are missing here:  <a href="https://github.com/astral-sh/ruff/blob/0d7ed32494df58f62ed6b48a3491f258ca7fd086/crates/ty_python_semantic/src/semantic_index/builder.rs#L816">https://github.com/astral-sh/ruff/blob/0d7ed32494df58f62ed6b48a3491f258ca7fd086/crates/ty_python_semantic/src/semantic_index/builder.rs#L816</a> to start with. It feels to me that it was left behind because it needs more refactoring to handle multiple assignments.</li>
</ol>
<p>Anyway, anybody who can give some code pointers on how to handle these or what the challenges could be?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-09-01 08:29</div>
            <div class="timeline-body"><blockquote>
<p>It&#x27;s missing the <code>match</code> pattern definition types in infer, but I&#x27;m not seeing how we are able to set up an expression there using infer_expression_types. The code comment https://github.com/astral-sh/ruff/blob/0d7ed32494df58f62ed6b48a3491f258ca7fd086/crates/ty_python_semantic/src/types/infer.rs#L3664 there was maybe too hard to understand for me.</p>
</blockquote>
<p>@dhruvmanila This was written by you originally, maybe you can have a look?</p>
<blockquote>
<p>The match examples rely mostly on sequences and some even more advanced matching examples, but looks like they are missing here: https://github.com/astral-sh/ruff/blob/0d7ed32494df58f62ed6b48a3491f258ca7fd086/crates/ty_python_semantic/src/semantic_index/builder.rs#L816 to start with. It feels to me that it was left behind because it needs more refactoring to handle multiple assignments.</p>
</blockquote>
<p>That&#x27;s certainly possible, but I don&#x27;t think it hasn&#x27;t been implemented because there are any blocking issues. We do handle multiple assignments in other places (e.g. unpacking). It&#x27;s just that no-one has attempted to implement any of these advanced pattern matching features, so far.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/silamon">@silamon</a> on 2025-09-01 16:08</div>
            <div class="timeline-body"><p>The unpackables make it easier to work all this, but for some reason the matching uses an index based system:</p>
<pre><code>#[derive(Debug, PartialEq)]
struct CurrentMatchCase&lt;&#x27;ast&gt; {
    /// The pattern that&#x27;s part of the current match case.
    pattern: &amp;&#x27;ast ast::Pattern,

    /// The index of the sub-pattern that&#x27;s being currently visited within the pattern.
    ///
    /// For example:
    /// ```py
    /// match subject:
    ///     case a as b: ...
    ///     case [a, b]: ...
    ///     case a | b: ...
    /// ```
    ///
    /// In all of the above cases, the index would be 0 for `a` and 1 for `b`.
    index: u32,
}
</code></pre>
<p>Reading the code, it would make very much sense to make the match ast unpackable as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/flying-sheep">@flying-sheep</a> on 2025-12-18 08:29</div>
            <div class="timeline-body"><p>You can probably add #561 as a sub-issue of this one.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:25:09 UTC
    </footer>
</body>
</html>
