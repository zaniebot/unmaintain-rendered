<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support for Odoo ORM - astral-sh/ty #2172</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support for Odoo ORM</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2172">#2172</a>
        opened by <a href="https://github.com/merlinz01">@merlinz01</a>
        on 2025-12-22 21:30
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/merlinz01">@merlinz01</a></div>
            <div class="timeline-body">Question
<p>Would you be interested in supporting the Odoo ORM in ty?</p>
<p>Quirks of the system that make type checking mess up:</p>
<ul>
<li>Ty already knows that <code>self.env[&quot;some.model.name&quot;]</code> is a reference to a subclass of <code>odoo.models.BaseModel</code>. But it doesn&#x27;t know specifically what model it is because it is not accessed by importing it.</li>
<li>Odoo has its own system of model inheritance where fields and methods defined on a model are available to other models that have <code>_inherit</code> set to the <code>_name</code> of the first model.</li>
<li>The model definitions are scattered through multiple directories each containing an array of Python modules. Model inheritance order is defined by dependencies in a <code>__manifest__.py</code> file in each module.</li>
</ul>
<p>Example single module structure:</p>
<pre><code>product_barcode_generator/
├── __init__.py
├── __manifest__.py
├── models
    ├── __init__.py
    ├── product_product.py
    └── product_template.py
</code></pre>
<p>Example model definition:</p>
<pre><code>from odoo import api, models


class ProductProduct(models.Model):
    _inherit = &quot;product.product&quot;

    @api.model_create_multi
    def create(self, vals_list):
        for vals in vals_list:
            if not vals.get(&quot;barcode&quot;):
                vals[&quot;barcode&quot;] = self.env[&quot;ir.sequence&quot;].next_by_code(&quot;product.barcode&quot;)
        return super().create(vals_list)

    def action_generate_barcode(self):
        &quot;&quot;&quot;Generate barcodes for products that don&#x27;t have one.&quot;&quot;&quot;
        for product in self:
            if not product.barcode:
                product.barcode = self.env[&quot;ir.sequence&quot;].next_by_code(&quot;product.barcode&quot;)
</code></pre>
<p>This is what ty currently says about the above code:</p>
<pre><code>$ ty check custom/product_barcode_generator/models/product_product.py
error[unresolved-attribute]: Object of type `BaseModel` has no attribute `next_by_code`
  --&gt; custom/product_barcode_generator/models/product_product.py:11:35
   |
 9 |         for vals in vals_list:
10 |             if not vals.get(&quot;barcode&quot;):
11 |                 vals[&quot;barcode&quot;] = self.env[&quot;ir.sequence&quot;].next_by_code(&quot;product.barcode&quot;)
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
12 |         return super().create(vals_list)
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `Self@action_generate_barcode` has no attribute `barcode`
  --&gt; custom/product_barcode_generator/models/product_product.py:17:20
   |
15 |         &quot;&quot;&quot;Generate barcodes for products that don&#x27;t have one.&quot;&quot;&quot;
16 |         for product in self:
17 |             if not product.barcode:
   |                    ^^^^^^^^^^^^^^^
18 |                 product.barcode = self.env[&quot;ir.sequence&quot;].next_by_code(&quot;product.barcode&quot;)
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Unresolved attribute `barcode` on type `Self@action_generate_barcode`.
  --&gt; custom/product_barcode_generator/models/product_product.py:18:17
   |
16 |         for product in self:
17 |             if not product.barcode:
18 |                 product.barcode = self.env[&quot;ir.sequence&quot;].next_by_code(&quot;product.barcode&quot;)
   |                 ^^^^^^^^^^^^^^^
   |
info: rule `unresolved-attribute` is enabled by default

error[unresolved-attribute]: Object of type `BaseModel` has no attribute `next_by_code`
  --&gt; custom/product_barcode_generator/models/product_product.py:18:35
   |
16 |         for product in self:
17 |             if not product.barcode:
18 |                 product.barcode = self.env[&quot;ir.sequence&quot;].next_by_code(&quot;product.barcode&quot;)
   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
   |
info: rule `unresolved-attribute` is enabled by default

Found 4 diagnostics
</code></pre>
Version
<p>ty 0.0.4</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by <a href="https://github.com/merlinz01">@merlinz01</a> on 2025-12-22 21:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 22:37</div>
            <div class="timeline-body"><p>I think we will have to restrict special-cased support for libraries (if/when we add any -- we haven&#x27;t yet) to the minimum number of extremely widely-used libraries. The maintenance burden of such special-cased support is significant, and sufficient to cast doubt on the wisdom of doing it at all, even for extremely popular libraries. So I doubt that we would add special-cased support for Odoo. I would strongly recommend to the developers of Odoo and other libraries to consider Python static type checkers in the development of these libraries.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 22:37</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:43 UTC
    </footer>
</body>
</html>
