<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>typevar solver can't solve a generic union - astral-sh/ty #1703</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>typevar solver can't solve a generic union</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1703">#1703</a>
        opened by <a href="https://github.com/suleymanozkeskin">@suleymanozkeskin</a>
        on 2025-12-01 11:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/suleymanozkeskin">@suleymanozkeskin</a> on 2025-12-01 11:37</div>
            <div class="timeline-body"><h3>Summary</h3>
<h1>Summary</h1>
<p>Incomplete type narrowing with <code>TypeIs</code> on generic types after early return</p>
<h2>Description</h2>
<p>Type narrowing fails for <strong>generic types</strong> when using a <code>TypeIs</code> type guard with an early return pattern. Pyright correctly narrows the type in this scenario, but <code>ty</code> does not. The issue does <strong>not</strong> occur with simple (non-generic) classes.</p>
<h2>Minimal Reproducible Example</h2>
<pre><code class="language-python"># exp.py
from typing import Union, Generic, TypeVar
from typing_extensions import TypeIs

T = TypeVar('T', covariant=True)
E = TypeVar('E', covariant=True)


class Ok(Generic[T]):
    def __init__(self, value: T):
        self._value = value
    
    @property
    def ok_value(self) -&gt; T:
        return self._value
    
    def is_err(self) -&gt; bool:
        return False


class Err(Generic[E]):
    def __init__(self, error: E):
        self._error = error
    
    @property
    def err_value(self) -&gt; E:
        return self._error
    
    def is_err(self) -&gt; bool:
        return True


Result = Union[Ok[T], Err[E]]


def is_err(result: Result[T, E]) -&gt; TypeIs[Err[E]]:
    &quot;&quot;&quot;Type guard to check if a result is an Err&quot;&quot;&quot;
    return result.is_err()

# ------------------------------------------------------------

def some_function() -&gt; Result[int, Exception]:
    condition = False
    if condition is False:
        return Err(Exception(&quot;Test error&quot;))
    return Ok(1)

def use_some_function():    
    result = some_function()
    
    if is_err(result):
        print(result.err_value)
        return None

    # After the is_err() check and early return,
    # result should be narrowed to Ok[int]
    okay = result.ok_value  # &lt;- ty reports warning here
    print(okay)
</code></pre>
<h2>Expected Behavior</h2>
<p>After the <code>if is_err(result): return None</code> check, <code>result</code> should be narrowed to <code>Ok[int]</code>, making <code>result.ok_value</code> valid without warnings.</p>
<h2>Actual Behavior</h2>
<pre><code class="language-bash">uv run ty check exp.py
warning[possibly-missing-attribute]: Attribute `ok_value` may be missing on object of type `(Ok[int] &amp; ~Err[Unknown]) | (Err[Exception] &amp; ~Err[Unknown])`
  --&gt; exp.py:57:12
   |
55 |     # After the is_err() check and early return,
56 |     # result should be narrowed to Ok[int]
57 |     okay = result.ok_value  # &lt;- ty reports warning here
   |            ^^^^^^^^^^^^^^^
58 |     print(okay)
   |
info: rule `possibly-missing-attribute` is enabled by default
</code></pre>
<h2>Comparison with Pyright</h2>
<p>Pyright correctly handles this pattern with 0 errors, 0 warnings for both generic and non-generic types.</p>
<ul>
<li>Simple classes with <code>TypeIs</code>: Works correctly in both <code>ty</code> and Pyright</li>
<li>Generic classes with <code>TypeIs</code>: Fails in <code>ty</code>, works in Pyright</li>
</ul>
<h2>Notes</h2>
<ul>
<li>Pattern matching (<code>match</code>/<code>case</code>) works correctly in both type checkers, even with generics</li>
<li>The issue specifically occurs when combining:<ol>
<li>Generic types (e.g., <code>Union[Ok[T], Err[E]]</code>)</li>
<li><code>TypeIs</code> type guards</li>
<li>Early return control flow</li>
</ol>
</li>
<li>Type narrowing appears to be incomplete when the type guard eliminates one branch of a generic union</li>
</ul>
<h2>Environment</h2>
<ul>
<li><code>ty</code> version: 0.0.1a29</li>
<li>Python version: 3.13</li>
</ul>
<h3>Version</h3>
<p>0.0.1a29</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-02 01:56</div>
            <div class="timeline-body"><p>Thanks for the report! This looks like a bug indeed. I think it is a limitation of our current typevar solver; it isn't able to match the generic union parameter type against the union argument and solve both typevars. <a href="https://play.ty.dev/32048e84-3f13-4553-aac7-5d51daccaaa2">This simplified example</a> (without <code>TypeIs</code>, and also without the generic implicit alias, to clarify that's not part of the problem either) shows the root cause:</p>
<pre><code class="language-py">from typing import Union, Generic, TypeVar

T = TypeVar('T', covariant=True)
E = TypeVar('E', covariant=True)


class Ok(Generic[T]):
    def __init__(self, value: T):
        self._value = value
    
    @property
    def ok_value(self) -&gt; T:
        return self._value
    
    def is_err(self) -&gt; bool:
        return False


class Err(Generic[E]):
    def __init__(self, error: E):
        self._error = error
    
    @property
    def err_value(self) -&gt; E:
        return self._error
    
    def is_err(self) -&gt; bool:
        return True



def err_kind(result: Union[Ok[T], Err[E]]) -&gt; E | None:
    pass

# ------------------------------------------------------------

def f(result: Union[Ok[int], Err[Exception]]):
    reveal_type(err_kind(result))  # reveals `Unknown | None`, should reveal `Exception | None`
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @carljm on 2025-12-02 01:58</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Beta" by @carljm on 2025-12-02 01:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "limited type narrowing" to "typevar solver can't solve a generic union" by @carljm on 2025-12-02 02:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "Beta" by @carljm on 2025-12-05 00:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-12-05 00:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @suleymanozkeskin on 2025-12-05 20:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @AlexWaygood on 2025-12-05 20:11</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:47 UTC
    </footer>
</body>
</html>
