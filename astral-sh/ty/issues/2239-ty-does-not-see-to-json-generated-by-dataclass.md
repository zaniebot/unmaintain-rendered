```yaml
number: 2239
title: "ty does not see `to_json` generated by `@dataclass_json`"
type: issue
state: closed
author: vi
labels:
  - question
assignees: []
created_at: 2025-12-27T19:29:12Z
updated_at: 2025-12-29T20:22:40Z
url: https://github.com/astral-sh/ty/issues/2239
synced_at: 2026-01-12T15:54:26Z
```

# ty does not see `to_json` generated by `@dataclass_json`

---

_@vi_

### Question

For example, for this code:

```python
from dataclasses import dataclass
from dataclasses_json import dataclass_json

@dataclass_json
@dataclass
class Qqq:
    a : str
    b : int

x = Qqq("a",4)
print(x.to_json())
```

<details><summary>pyproject.toml</summary>

```toml
[project]
version="0.0.0"
name="qqq"
requires-python = ">=3.11"
dependencies = [
  "dataclasses-json~=0.6.7",
]
```

</details>

Ty should the following error:

    Object of type `Qqq` has no attribute `to_json` ty[unresolved-attribute](https://ty.dev/rules#unresolved-attribute)

Is it a deficiency in Ty or in dataclass_json?

Is there a better way working around than `# ty:ignore[unresolved-attribute]`?, e.g. can I somehow hint that `Qqq` class has `to_json` method (without manually implementing it), so that Ty would typecheck it properly?

For example, the following seems to work:

```python
@dataclass_json
@dataclass
class Qqq:
    a : str
    b : int

    def to_json(self) -> str: raise Exception("This method should be overridden by @dataclass_json")
```

Is it a good idea? Can it fall apart in future due to changes in `dataclass_json`, Python or Ty?

### Version

ty 0.0.2, from VSCode extension

---

_Label `question` added by @vi on 2025-12-27 19:29_

---

_Comment by @Wizzerinus on 2025-12-27 19:31_

Seems like a problem with dataclass_json, since this overload should be picked:
```py
@overload
def dataclass_json(_cls: Type[T], *, letter_case: Optional[LetterCase] = ...,
                   undefined: Optional[Union[str, Undefined]] = ...) -> Type[T]: ...
```

and it says that the input class and the return value are exactly the same type, without saying anything about to_json being created.

---

_Comment by @carljm on 2025-12-27 19:36_

Yes, `dataclass_json` provides no information that should tell a type checker about the `to_json` method. All other type checkers I tried (pyright, pyrefly, mypy) emit the same diagnostic we do here.

I think your solution to define `to_json` yourself and let `dataclass_json` override it is a pretty good option; I'm not thinking of any less-onerous workaround.

---

_Closed by @carljm on 2025-12-27 19:36_

---

_Comment by @vi on 2025-12-27 19:37_

Can `dataclass_json` communicate to Ty that a method is going to be created?

What shall be pursued - making `dataclasses_json` play well with type checkers or finding a better, less verbose workaround?

Shall Ty in general support such injected methods (provided injection libraries cooperate)?

---

_Comment by @Wizzerinus on 2025-12-27 19:39_

This can be possible with an intersection type I believe. Something of the kind

```py
class ToJSONable(Protocol):
  def to_json(self) -> str: ...

@overload
def dataclass_json(_cls: Type[T], *, letter_case: Optional[LetterCase] = ...,
                   undefined: Optional[Union[str, Undefined]] = ...) -> Intersection[Type[ToJSONable], Type[T]]: ...
```
(disclaimer: I have not tried this exactly, here be dragons.)

Intersection types however are currently not Python's first-class citizens, so probably not worth doing this right now

---

_Comment by @carljm on 2025-12-29 20:22_

There is currently nothing in the Python static type system that allows for a class decorator to add arbitrary extra methods to a class (apart from the fixed set of methods added by a `dataclass_transform` decorator).

Intersection types do provide a potential path forward, and are already supported by ty -- but we will need to fix #903 before the version given by @Wizzerinus will work. And of course other type checkers do not support user-spellable intersection types, so until an intersection PEP is accepted, this would be a ty-specific solution.

The way to "inject methods" that works in the current type system would be via mixin inheritance, not via a class decorator.

---
