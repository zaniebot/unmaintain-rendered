<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FR: Update objects with monkey patching and/or setattr - astral-sh/ty #2016</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>FR: Update objects with monkey patching and/or setattr</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2016">#2016</a>
        opened by <a href="https://github.com/deanm0000">@deanm0000</a>
        on 2025-12-17 15:02
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/deanm0000">@deanm0000</a></div>
            <div class="timeline-body">Summary
<p>It would be great if we could update objects and the ty would be aware of those updates. As an example of a real use case, take <a href="https://docs.pola.rs/api/python/stable/reference/api.html">polars&#x27;s</a> ability to extend the API. While this feature works great at runtime, it doesn&#x27;t work with type checking as you can see... https://i.imgur.com/fX4EGpR.png</p>
<p>More generically here&#x27;s a more minimal example</p>
<pre><code>class Foo:
    def __init__(self, thing:str):
        self.bar=thing


my_foo=Foo(&quot;abc&quot;)
setattr(my_foo, &quot;abz&quot;, &quot;hello&quot;) # it&#x27;d be great if it would update what it expects of `my_foo` here
my_foo.abz=&quot;hello&quot; # this syntax too, if possible

print(my_foo.abz) # As-is it gives, Object of type `Foo` has no attribute `abz`

setattr(Foo, &quot;abz&quot;, &quot;hello&quot;) # also updating the class itself
Foo.abz=&quot;hello&quot; 

print(my_foo.abz) # Same message as above
</code></pre>
<p>In rust, this is kind of like implementing your own trait on an imported struct/enum and rust-analyzer knows about the new trait like this</p>
<p><img alt="Image" src="https://github.com/user-attachments/assets/3ec3faf7-154e-4b6e-afc2-c61482e599d7"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-17 15:09</div>
            <div class="timeline-body"><blockquote>
<p>In rust, this is kind of like implementing your own trait on an imported struct/enum and rust-analyzer knows about the new trait like this</p>
</blockquote>
<p>You could do the same thing in Python by subclassing from both <code>Foo</code> and a protocol that describes this dynamic <code>abz</code> member.</p>
<pre><code>class Foo:
    def __init__(self, thing:str):
        self.bar=thing

class HasAbzMember:
    abz: str

class FooWithAbz(Foo, HasAbzMember): ...

my_foo=FooWithAbz(&quot;abc&quot;)
setattr(my_foo, &quot;abz&quot;, &quot;hello&quot;)

reveal_type(my_foo.abz)  # str
</code></pre>
<p>https://play.ty.dev/eeaab3b9-b39d-4e25-b759-d136554d7731</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/deanm0000">@deanm0000</a> on 2025-12-17 16:02</div>
            <div class="timeline-body"><p>For the generic case, subclassing works but in the case of polars, one of its desirable features is the ability to chain Expr expressions like <code>pl.col(&quot;a&quot;).sum().add(5).div(2)</code></p>
<p>Subclassing would break chaining, for example</p>
<pre><code>import polars as pl

class MyExpr(pl.Expr):
    def __init__(self, x):
        self._pyexpr=pl.col(x)._pyexpr
    def new_thing(self):
        return self +5

def mycol(x:str):
    return MyExpr(x)
a=mycol(&quot;a&quot;) ## is a MyExpr

b=a.sum() ## sum returns Expr
b2 = b.new_thing() ## doesn&#x27;t work because b is an Expr

c=a.new_thing() ## works b/c a is still MyExpr
</code></pre>
<p>Also, with subclassing you can&#x27;t import multiple plugins so if I want to use both <code>MyExpr</code> and <code>FranksExpr</code> then I&#x27;d be out of luck.</p>
<p>I realize this looks like a very niche use case but I think if the feature existed other libraries focused on interop would make use of the feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-17 18:43</div>
            <div class="timeline-body"><p>We already support this locally, using regular assignment syntax: https://play.ty.dev/5237acdf-5f51-453b-a96f-3ad94916ab07</p>
<pre><code>class Foo:
    pass

f = Foo()
f.bar = &quot;baz&quot;  # emits an error

reveal_type(f.bar)  # still reveals `Literal[&#x27;baz&#x27;]`
</code></pre>
<p>I think emitting an error on <code>f.bar = &quot;baz&quot;</code> is the right thing to do, as that attribute is not part of the type <code>Foo</code> (and it may well be a typo or a mistake), but if you suppress that error, we&#x27;ll still respect the result of the assignment.</p>
<p>Recognizing <code>setattr</code> with fixed known attribute name would be reasonably easy, but doesn&#x27;t seem very useful -- if the attribute name is known, why use <code>setattr</code> in the first place? (Unless it&#x27;s just a workaround to avoid the type error on the assignment -- but I think if we added support to recognized fixed-name setattr assignments, we&#x27;d emit that error on them, too.) If the attribute name is not statically known, then there&#x27;s not much we can do with that <code>setattr()</code> call.</p>
<p>But I&#x27;m not sure any of this really helps your use case, because we don&#x27;t support any non-local effects here. If you dynamically add an attribute to <code>Foo</code> itself, we aren&#x27;t going to start respecting that attribute on all instances of <code>Foo</code> everywhere. I think this is something we are unlikely to ever support, unless it were carefully designed as a new type system feature in a PEP.</p>
<p>I&#x27;m going to close this issue for now because I don&#x27;t think it&#x27;s currently actionable for us, but not closed to more discussion of the idea! Thanks for the suggestion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2025-12-17 18:43</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:31 UTC
    </footer>
</body>
</html>
