<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>No overload of bound method `__init__` matches arguments for tempfile.TemporaryDirectory - astral-sh/ty #370</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>No overload of bound method `__init__` matches arguments for tempfile.TemporaryDirectory</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/370">#370</a>
        opened by <a href="https://github.com/divaltor">@divaltor</a>
        on 2025-05-13 21:13
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/divaltor">@divaltor</a> on 2025-05-13 21:13</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Python 3.13.3</p>
<p>https://play.ty.dev/2ca5385c-da70-4f1b-b4d3-e4e15b5f9c6c</p>
<pre><code class="language-py">import tempfile

# No overload of bound method `__init__` matches argumentsty(lint:no-matching-overload)
with tempfile.TemporaryDirectory() as tmp:
    ....
</code></pre>
<p>Not sure that is intented behaviour, pyright doesn't mark it as an error.</p>
<p>Probably related issue - https://github.com/astral-sh/ty/issues/274</p>
<h3>Version</h3>
<p>v.0.0.7a (from VS Code extension)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @AlexWaygood on 2025-05-14 00:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-15 03:00</div>
            <div class="timeline-body"><p>Definitely not intended behavior. Seems like the explicit annotations on <code>self</code> in the typeshed <code>__init__</code> overloads are causing us trouble somehow (though I'm not yet sure why).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "No overload of bound method for tempfile.TemporaryDirectory" to "No overload of bound method `__init__` matches arguments for tempfile.TemporaryDirectory" by @carljm on 2025-05-15 03:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-15 11:57</div>
            <div class="timeline-body"><blockquote>
<p>Seems like the explicit annotations on <code>self</code> in the typeshed <code>__init__</code> overloads are causing us trouble somehow (though I'm not yet sure why).</p>
</blockquote>
<p>We currently call <code>__init__</code> on the <a href="https://github.com/astral-sh/ruff/blob/b6b7caa0238b2f8fc455a3a6769f6ca9ae65c2af/crates/ty_python_semantic/src/types.rs#L4462-L4468">unspecialized (or: &quot;identity&quot;-specialized) generic class</a>. We then attempt to assign <code>TemporaryDirectory[AnyStr]</code> to <code>TemporaryDirectory[str]</code> (or <code>TemporaryDirectory[bytes]</code>) during call binding and that fails.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-15 14:47</div>
            <div class="timeline-body"><p>@dcreager I'd be interested in your thoughts on how we should handle this. It seems fairly high priority to be able to handle these instantiations.</p>
<p>One note is that it looks like we should not just accept the instantiation, but also infer the type of the constructed class to match the <code>self</code> annotation of the selected overload. For example:</p>
<pre><code class="language-py">reveal_type(TemporaryDirectory(&quot;foo&quot;))  # revealed: TemporaryDirectory[str]
reveal_type(TemporaryDirectory(b&quot;foo&quot;))  # revealed: TemporaryDirectory[bytes]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-05-15 15:26</div>
            <div class="timeline-body"><p>This is really interesting!</p>
<blockquote>
<p>One note is that it looks like we should not just accept the instantiation, but also infer the type of the constructed class to match the <code>self</code> annotation of the selected overload.</p>
</blockquote>
<p>One possibility would be to use this thought to implement a hack: if an <code>__init__</code> method has an annotation for its <code>self</code> parameter, skip inference entirely and just use that as the constructed instance type. That would certainly work for this particular case.</p>
<p>But it wouldn't work for something more complex:</p>
<pre><code class="language-py">class C[T, U]:
    def __init__(self: C[int, U]) -&gt; None: ...
</code></pre>
<p>i.e. where only <em>some</em> of the class typevars are bound by the <code>self</code> annotation.</p>
<hr />
<p>Pivoting a bit, maybe we could instead update the member lookup logic for a generic alias to skip the member (i.e., treat it as missing/unbound) if the generic alias isn't assignable to the <code>self</code> annotation. But I don't know if that would be enough to make the constructor logic work, since we'd need this to happen when the generic alias is <code>C[T, U]</code> (the identity specialization).</p>
<hr />
<p>Last option, I wonder if this is just showing that we need to infer typevar mappings in both directions?  i.e. what I think is happening is that we end up looking at the pair <code>TemporaryDirectory[str]</code> (the formal annotation) and <code>TemporaryDirectory[AnyStr]</code> (the actual bound self argument, which has the identity specialization applied).  That's backwards from what we normally see, where typevars occur in the formal and are bound to types that appear in the actual.  If we do the binding inference in both directions I think we would end up correctly inferring the specialization <code>{AnyStr = str}</code> for this overload.  I'd just need to convince myself that that wouldn't introduce new false positives.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-15 15:32</div>
            <div class="timeline-body"><blockquote>
<p>One possibility would be to use this thought to implement a hack: if an <code>__init__</code> method has an annotation for its <code>self</code> parameter, skip inference entirely and just use that as the constructed instance type. That would certainly work for this particular case.</p>
</blockquote>
<p>I don't understand how that would work. Wouldn't you always pick the first overload in that case?</p>
<pre><code class="language-pyi">@overload
def __init__(
    self: TemporaryDirectory[str],
    suffix: str | None = None,
    prefix: str | None = None,
    dir: StrPath | None = None,
    ignore_cleanup_errors: bool = False,
    *,
    delete: bool = True,
) -&gt; None: ...
@overload
def __init__(
    self: TemporaryDirectory[bytes],
    suffix: bytes | None = None,
    prefix: bytes | None = None,
    dir: BytesPath | None = None,
    ignore_cleanup_errors: bool = False,
    *,
    delete: bool = True,
) -&gt; None: ...
</code></pre>
<p>Edit: or would it still work because you <em>also</em> have to match the <code>suffix</code> parameter...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-15 20:53</div>
            <div class="timeline-body"><p>The way other type checkers seem to handle this (and I think the desired behavior of the typeshed annotation?) is that <code>TemporaryDirectory()</code> is inferred as <code>TemporaryDirectory[str]</code> (both overloads match, the first one is picked), but <code>TemporaryDirectory(b&quot;foo&quot;)</code> is inferred as <code>TemporaryDirectory[bytes]</code> -- only the second overload matches, because of the <code>suffix</code> parameter.</p>
<p>I think I agree entirely with @dcreager's analysis above. The &quot;hack&quot; mentioned would I think work correctly for this case, but not for potentially more complex cases. Still might make sense to do for now if it's a lot easier, since this case is what we actually see in commonly used typeshed cases. Doing the type inference in both directions seems like the &quot;full&quot; answer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @AlexWaygood on 2025-05-18 11:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dcreager on 2025-05-19 15:45</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:01 UTC
    </footer>
</body>
</html>
