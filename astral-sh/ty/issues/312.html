<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Failed to resolve property on `dagster.Config` - astral-sh/ty #312</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Failed to resolve property on <code>dagster.Config</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/312">#312</a>
        opened by <a href="https://github.com/ion-elgreco">@ion-elgreco</a>
        on 2025-05-10 17:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ion-elgreco">@ion-elgreco</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<pre><code class="language-python">from datetime import datetime
import dagster as dg

class Foo(dg.ConfigurableResource):
    @property
    def current_date(self) -&gt; datetime:
        return datetime.now()

def random_function(date: datetime) -&gt; datetime:
    return date

foo = Foo()
random_function(date=foo.current_date)

</code></pre>
<p>Results in</p>
<pre><code>error[missing-argument]: No argument provided for required parameter `self` of function `__init__`
  --&gt; test.py:16:7
   |
16 | foo = Foo()
   |       ^^^^^
17 | random_function(date=foo.current_date)
   |
info: `missing-argument` is enabled by default

error[invalid-argument-type]: Argument to function `random_function` is incorrect
  --&gt; test.py:17:17
   |
16 | foo = Foo()
17 | random_function(date=foo.current_date)
   |                 ^^^^^^^^^^^^^^^^^^^^^ Expected `datetime`, found `property`
   |
info: Function defined here
  --&gt; test.py:12:5
   |
12 | def random_function(date: datetime) -&gt; datetime:
   |     ^^^^^^^^^^^^^^^ -------------- Parameter declared here
13 |     return date
   |
info: `invalid-argument-type` is enabled by default

Found 2 diagnostics
</code></pre>
<p>If we remove the inherited class, it will pass</p>
<h3>Version</h3>
<p>ty 0.0.0-alpha.8 (0474b40e1 2025-05-09)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @MichaReiser on 2025-05-12 06:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">attribute access</span> added by @MichaReiser on 2025-05-12 06:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-12 10:06</div>
            <div class="timeline-body"><p>Thank you for reporting this. Something seems to be wrong with attribute access on subclasses of <code>dagster.Config</code>. It might be related to the custom metaclass on <code>dg.Config</code> (see <a href="https://github.com/dagster-io/dagster/blob/be9a732f930f18ae63d724d9ba98f7f51d40f8c6/python_modules/dagster/dagster/_config/pythonic_config/config.py#L154">here</a>):</p>
<pre><code class="language-py">import dagster as dg

class Foo(dg.Config):
    x: int = 1

reveal_type(Foo.x)  # Unknown
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Inherited class causes property to not be resolved" to "Broken attribute access when subclassing `dagster.Config`" by @sharkdp on 2025-05-12 10:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2025-05-14 13:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-14 14:26</div>
            <div class="timeline-body"><p>I did some further analysis here. The problem seems to be that we do not resolve the <em>second</em> <code>ModelMetaclass</code> import from pydantic <a href="https://github.com/dagster-io/dagster/blob/0322c21c0594fffdac8157773fb54eb2a4ebc08b/python_modules/dagster/dagster/_config/pythonic_config/typing_utils.py#L9-L14">here</a> (which seems correct? I don't see <code>ModelMetaclass</code> <a href="https://github.com/pydantic/pydantic/blob/main/pydantic/main.py">here</a>):</p>
<pre><code class="language-py">try:
    # Pydantic 1.x
    from pydantic._internal._model_construction import ModelMetaclass
except ImportError:
    # Pydantic 2.x
    from pydantic.main import ModelMetaclass
</code></pre>
<p>This leads us to infer <code>&lt;class 'ModelMetaclass'&gt; | Unknown</code> for the base of <code>BaseConfigMeta</code> <a href="https://github.com/dagster-io/dagster/blob/0322c21c0594fffdac8157773fb54eb2a4ebc08b/python_modules/dagster/dagster/_config/pythonic_config/typing_utils.py#L63">here</a>.</p>
<pre><code class="language-py">@dataclass_transform(kw_only_default=True, field_specifiers=(Field,))
class BaseConfigMeta(ModelMetaclass):  # type: ignore
</code></pre>
<p>Since we don't support unions as bases, we construct an MRO for <code>BaseConfigMeta</code> that includes <code>Unknown</code>. This means that <code>dagter.Config</code> <a href="https://github.com/dagster-io/dagster/blob/be9a732f930f18ae63d724d9ba98f7f51d40f8c6/python_modules/dagster/dagster/_config/pythonic_config/config.py#L154">here</a> ends up having a metaclass with a base that is <code>Unknown</code>:</p>
<pre><code class="language-py">class Config(MakeConfigCacheable, metaclass=BaseConfigMeta):
</code></pre>
<p>When looking up attributes on class objects (<code>Foo</code>/<code>dg.Config</code>), we look them up on the <code>type(Foo)</code> first, i.e. on the <code>BaseConfigMeta</code> metaclass. Since it has an unknown base, <em>every</em> attribute is present on that metaclass (with type <code>Unknown</code>):</p>
<pre><code class="language-py">reveal_type(dg.Config.whatever)  # Unknown
</code></pre>
<p>… which then leads to the observed behavior in the original post here.</p>
<hr />
<p>It seems that we can do better here, even if that import is actually problematic. When we see <code>&lt;class 'ModelMetaclass'&gt; | Unknown</code> as a base, we should probably at least attempt to include <code>&lt;class 'ModelMetaclass'&gt;</code> in the MRO? I'll put up a draft with an experiment...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">attribute access</span> removed by @sharkdp on 2025-05-14 14:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">mro</span> added by @sharkdp on 2025-05-14 14:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Broken attribute access when subclassing `dagster.Config`" to "Invalid metaclass in MRO for `dagster.Config`" by @sharkdp on 2025-05-14 14:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ion-elgreco">@ion-elgreco</a> on 2025-05-14 14:46</div>
            <div class="timeline-body"><p>@sharkdp it's actually here: https://github.com/pydantic/pydantic/blob/main/pydantic/_internal/_model_construction.py</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-14 15:00</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/sharkdp">@sharkdp</a> it's actually here: https://github.com/pydantic/pydantic/blob/main/pydantic/_internal/_model_construction.py</p>
</blockquote>
<p>That's the 1.x import, but the 2.x one (<code>from pydantic.main import ModelMetaclass</code>)?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ion-elgreco">@ion-elgreco</a> on 2025-05-14 15:08</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p><a href="https://github.com/sharkdp">@sharkdp</a> it's actually here: https://github.com/pydantic/pydantic/blob/main/pydantic/_internal/_model_construction.py</p>
</blockquote>
<p>That's the 1.x import, but the 2.x one (<code>from pydantic.main import ModelMetaclass</code>)?</p>
</blockquote>
<p>Their code description is incorrect in dagster, the 1.x import path is actually still the same for 2.x</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-05-14 18:17</div>
            <div class="timeline-body"><blockquote>
<p>When looking up attributes on class objects (<code>Foo</code>/<code>dg.Config</code>), we look them up on the <code>type(Foo)</code> first, i.e. on the <code>BaseConfigMeta</code> metaclass. Since it has an unknown base, <em>every</em> attribute is present on that metaclass (with type <code>Unknown</code>):</p>
</blockquote>
<p>I think the other interesting question is why this results in false positive type errors in the original example here. In general, assuming <code>Unknown</code> is supposed to silence errors (since we don't know the type), so it seems like there is probably something to fix there (in addition to seeing if we can do better in inferring a non-Unknown metaclass here.)</p>
<p>The other potential improvement here is around <code>try: import foo; except ImportError: ...</code> pattern, where in principle we could consider it a &quot;statically known branch&quot; and avoid the <code>| Unknown</code> type in this case. Though I would probably consider this the lowest priority improvement raised by this issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">mro</span> removed by @sharkdp on 2025-05-15 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type properties</span> added by @sharkdp on 2025-05-15 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-15 14:08</div>
            <div class="timeline-body"><blockquote>
<p>I think the other interesting question is why this results in false positive type errors in the original example here. In general, assuming <code>Unknown</code> is supposed to silence errors (since we don't know the type), so it seems like there is probably something to fix there (in addition to seeing if we can do better in inferring a non-Unknown metaclass here.)</p>
</blockquote>
<p>Thank you for asking the right questions! This was another extremely subtle point. We currently fail to recognize that subclass-of-type (<code>type[…</code>]) of a class with a non-fully-static metaclass is assignable to <code>type</code>. This is why the call to the <code>property.__get__</code> method failed (which requires the <code>owner</code> argument to be of type <code>type</code>). Once <a href="https://github.com/astral-sh/ruff/pull/18121">that is fixed</a>, no false diagnostics are left in the original example here. And we actually infer the correct types (not <code>Unknown</code>) for that property.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Invalid metaclass in MRO for `dagster.Config`" to "Failed to resolve property on `dagster.Config`" by @sharkdp on 2025-05-15 14:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-05-15 15:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-05-15 15:14</div>
            <div class="timeline-body"><blockquote>
<p>The other potential improvement here is around <code>try: import foo; except ImportError: ...</code> pattern, where in principle we could consider it a &quot;statically known branch&quot; and avoid the <code>| Unknown</code> type in this case. Though I would probably consider this the lowest priority improvement raised by this issue.</p>
</blockquote>
<p>Given that we handle the given example correct now, I think we can probably defer this idea until it comes up again.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:19:49 UTC
    </footer>
</body>
</html>
