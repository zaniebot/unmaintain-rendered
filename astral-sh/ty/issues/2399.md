```yaml
number: 2399
title: "imprecise inference for types.new_class() with `bases`"
type: issue
state: open
author: bcmills
labels: []
assignees: []
created_at: 2026-01-08T16:18:32Z
updated_at: 2026-01-08T23:48:58Z
url: https://github.com/astral-sh/ty/issues/2399
synced_at: 2026-01-10T01:56:41Z
```

# imprecise inference for types.new_class() with `bases`

---

_Issue opened by @bcmills on 2026-01-08 16:18_

### Summary

https://play.ty.dev/c84dda0b-ff7b-4570-9baa-42cee056d0fd:
```py
from typing import Type
from types import new_class

class Foo:
    pass

def use_new_class() -> Type[Foo]:
    return new_class(
        "NewFoo",
        bases=(Foo,),
    )
```

`ty` reports:
```
Return type does not match returned value: expected `type[Foo]`, found `type` (invalid-return-type) [Ln 8, Col 12]
```

I think that's erroneous: because `Foo` is in the `bases` passed to `new_class`, the returned class _is_ a subclass of `Foo`, so the actual return type is `Type[Foo]`, not _just_ `type`.

### Version

ty 0.0.9

---

_Renamed from "imprecise inference for types.new_class" to "imprecise inference for types.new_class() with `bases`" by @bcmills on 2026-01-08 16:19_

---

_Comment by @AlexWaygood on 2026-01-08 16:25_

Thanks! Wow, I had no idea other type checkers supported this, but apparently it's supported by [mypy](https://mypy-play.net/?mypy=latest&python=3.12&gist=a247ede022eddf79343d76a23aa49f4e), [pyright](https://pyright-play.net/?pyrightVersion=1.1.405&pythonVersion=3.13&reportUnreachable=true&code=GYJw9gtgBALgngBwJYDsDmUkQWEMoAqiApgFCiSwkDOm2u%2BKxA7gPoDGANgIbXWmkuvWgDEwYAFykoMqAmECAJsWBQArtWKsmbIXwAUASigBaAHyESAbTFgAulNlQQxGGpAooOjjwPSnsgBEAHIstoEANP4BUABGvMTUALz6thGGUU6GpEA) and [pyrefly](https://pyrefly.org/sandbox/?project=N4IgZglgNgpgziAXKOBDAdgEwEYHsAeAdAA4CeS4ATrgLYAEALqcROgOZ0Q3G6UN0AVZjAA66MNXpNi8Tt1790MAO4B9AMZRUcOGLGbtcOgDFcuRGLpW6xQ3qwwwdAK5wYqpWoM6AFAEo6AFoAPkFhAG1TXABdC3RrOkoYBmdKeM8NLV9LBOsREAA5FSj8gBoc3LpsbXgAXh8o0r9y%2BOs-MRBSkGcGaDgSckQQAGI6AFVeqAgmOjBndHVe3HRddDFMR1neGlQGD2cabBhKH3xETnQGAJC6OAZKOISklLTZ-IKDo4e6YHwAX3yHS6ZCSYCgpEIDFoUAoowACqRQeDbhgcAQ6OplpA2KldhBloQxKMAMowGB0AAWDAYxDgiAA9PSQY5wYReGx6TB0PTMLh1HB6ZjxBAcZQ8ct6VtKHRUAA3VDQVDYWAYrEi3FLeK4Yia-piMgMCnLQKy45wfHxWp0fIAZkIAEYAEyA9AgP5dVCLCCm4zQGAUNBYPBEMhuoA).

@charliermarsh, maybe one for you after https://github.com/astral-sh/ruff/pull/22291 lands? It looks like `types.new_class()` is basically exactly the same as three-argument `type()`, with the sole exception that you can also provide keywords to the class definition (including `metaclass=`).

---

_Comment by @jelle-openai on 2026-01-08 17:31_

I don't think other type checkers meaningfully support it; if you add a `reveal_type()` in mypy or pyright, it just outputs `type`. I think the difference is that for mypy and pyright `type` is `type[Any]` and for ty it's `type[object]`?

---

_Comment by @AlexWaygood on 2026-01-08 20:16_

> I don't think other type checkers meaningfully support it; if you add a `reveal_type()` in mypy or pyright, it just outputs `type`. I think the difference is that for mypy and pyright `type` is `type[Any]` and for ty it's `type[object]`?

Ah, good catch. Still, I don't see a strong reason why we _shouldn't_ add support for this, given that the machinery we're adding in https://github.com/astral-sh/ruff/pull/22291 is pretty generalised.

---

_Added to milestone `Stable` by @carljm on 2026-01-08 23:48_

---
