<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>report unsafe operator type on subclasses - astral-sh/ty #630</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>report unsafe operator type on subclasses</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/630">#630</a>
        opened by <a href="https://github.com/KotlinIsland">@KotlinIsland</a>
        on 2025-06-11 01:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-06-11 01:08</div>
            <div class="timeline-body"><h3>summary</h3>
<pre><code class="language-py">class A:
    def __add__(self, other: A) -&gt; int:
        return 1


class B(A):
    def __radd__(self, other: A) -&gt; str:
        return &quot;B&quot;


def f(a1: A, a2: A):
    x: int = a1 + a2
    print(x)  # static: int, runtime: &quot;B&quot;

f(A(), B())
</code></pre>
<p>here, the right hand subtype rule will be used, and <code>B.__radd__</code> will be called first, resulting in <code>&quot;B&quot;</code>, not <code>1</code></p>
<p>if the supertype additionally defines a <code>__radd__</code>, then it can be incompatible with it's <code>__add__</code>, as all the information about the operation will be known</p>
<p>to ensure safety we must report when the subtypes <code>__radd__</code> in incompatable with the supertypes <code>__add__</code>, when the super type does not define a <code>__radd__</code>. but the right hand subtype rule complicates things...</p>
<h2>i see two options here:</h2>
<ol>
<li><p>always report a subtypes incompatible right hand operator as unsafe (mypy mode):</p>
<pre><code class="language-py">class A:
     def __add__(self, other: object) -&gt; int: ...
     def __radd__(self, other: object) -&gt; str: ...

class B(A):
     def __radd__(self, other: object) -&gt; str: ... # error: unsafe due to right hand subtype rule

def f(a1: A = A(), a2: A = B()):
    # always assume the right hand can not declare an incompatible type
    a1 + a2  # static: int, runtime: str, but that's okay, we gave an error
</code></pre>
</li>
<li><p>always form a union when the lower bound is not known (my preference):</p>
<pre><code class="language-py">class A:
     def __add__(self, other: object) -&gt; int: ...
     def __radd__(self, other: object) -&gt; str: ...

     def __sub__(self, other: object) -&gt; int: ...

     def __or__(self, other: object) -&gt; int: ...

class B(A):
     def __radd__(self, other: object) -&gt; str: ... # no error, valid override of A.__radd__

     def __rsub__(self, other: object) -&gt; Literal[1]: ... # not error, compatiable with A.__add__

     def __ror__(self, other: object) -&gt; str: ...  # error, incompatible with A.__or__

def f(a1: A = A(), a2: A = B()):
    # when we don't know what `a2` is
    a1 + a2  # static: int | str, runtime: str

    # we definitely know that rhs is a subtype of lhs
    A() + B()  # static: str, runtime: str

    # we definitely know that rhs is not a subtype of lhs
    a1 + A()  # static: int, runtime: int
</code></pre>
</li>
</ol>
<p>i think the second option is more powerful and expressive, and supports more usecases without overly widening types. and can also be enhanced when this insight can be implemented to specialise these cases</p>
<h2>this also applies to inplace operators</h2>
<pre><code class="language-py">class A:
    def __add__(self, other: A) -&gt; int:
        return 1
class B(A):
    def __iadd__(self, other: A) -&gt; str:   # expect error: `__iadd__` must be compatable with `A.__add__`, as `A` does not define `__iadd__`
        return &quot;a&quot;

def f(a1: A, a2: A):
    a = a1
    a += a2
    print(a)  # static: int, runtime: &quot;a&quot;
f(B(), A())
</code></pre>
<p>note that the righthand subtype rule applies <strong>after</strong> <code>__iadd__</code>, so this case is much more straightforward to support</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">runtime semantics</span> added by @AlexWaygood on 2025-06-11 07:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-09 16:51</div>
            <div class="timeline-body"><p>For reference, mypy and pyright both also give <code>int</code> here; mypy also gives the &quot;unsafe operator definitions&quot; diagnostic requested in this issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/KotlinIsland">@KotlinIsland</a> on 2025-09-09 23:26</div>
            <div class="timeline-body"><p>mypy doesn't fully meet the request here:</p>
<pre><code class="language-py">class A:
    def __add__(self, other: A) -&gt; int:
        return 1
    def __radd__(self, other: A) -&gt; str:
        return &quot;a&quot;
class B(A):
    def __radd__(self, other: A) -&gt; str:  # error: Signatures of &quot;__radd__&quot; of &quot;B&quot; and &quot;__add__&quot; of &quot;A&quot; are unsafely overlapping
        return &quot;a&quot;
</code></pre>
<p>this can be perfectly valid, if the analysis of the operation is modified to account for it</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "report unsafe operator type on subclasses" to "right hand operator used when inappropriate/ report unsafe operator type on subclasses" by @KotlinIsland on 2025-09-09 23:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "right hand operator used when inappropriate/ report unsafe operator type on subclasses" to "report unsafe operator type on subclasses" by @KotlinIsland on 2025-09-09 23:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Z post-stable" by @carljm on 2025-11-14 15:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "Z post-stable" by @carljm on 2025-11-18 16:10</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:10 UTC
    </footer>
</body>
</html>
