<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`object` type inferred when accessing possibly missing field with union type - astral-sh/ty #2420</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>`object` type inferred when accessing possibly missing field with union type</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2420">#2420</a>
        opened by <a href="https://github.com/marcofrasvda">@marcofrasvda</a>
        on 2026-01-09 17:36
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/marcofrasvda">@marcofrasvda</a> on 2026-01-09 17:36</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>In the code below, the <code>uid</code> variable in the function is incorrectly inferred as <code>object</code> type when it should be <code>str | None</code>. The same can be reproduced in the global scope. I thought the problem was the usage of <code>hasattr()</code> with a ternary operator but it seems to work correctly with simpler types.</p>
<pre><code class="language-py">class A:
    id: str

class B:
    # id: str - Uncomment this to see how type of &quot;uid&quot; changes below
    raw: bytes

class Container:
    payload: A | B

def process_data(container: Container):
    # This is inferred as `object` instead of `str | None`
    uid = container.payload.id if hasattr(container.payload, &quot;id&quot;) else None
</code></pre>
<h3>Version</h3>
<p>0.0.10</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-09 18:08</div>
            <div class="timeline-body"><p>Thanks for trying ty and taking the time to report an issue!</p>
<p>As it happens, ty's type inference is correct here. There could be a subclass of <code>B</code> that could have an <code>id</code> attribute of any type, so <code>hasattr(container.payload, &quot;id&quot;)</code> does not guarantee that <code>container.payload</code> is of type <code>A</code>, or that <code>container.payload.id</code> is of type <code>str</code>.</p>
<p>If you want to tell ty that subclasses of <code>B</code> are not possible and should not be considered, you can decorate it with <code>typing.final</code> and get the desired type inference: https://play.ty.dev/30b16617-013b-47aa-9f45-57c4f5f44b38</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2026-01-09 18:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/marcofrasvda">@marcofrasvda</a> on 2026-01-09 21:20</div>
            <div class="timeline-body"><p>Oh, that's understandable but surprising behavior, at least coming from Pyright. I did not know about <code>final</code> so I'll accept it's a skill issue until I get more comfortable with how ty works (and RTFM I suppose). Thank you for your kind explanation and example!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:47:12 UTC
    </footer>
</body>
</html>
