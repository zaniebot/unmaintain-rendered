<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nested Pydantic schema causes slow performance - astral-sh/ty #2026</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Nested Pydantic schema causes slow performance</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2026">#2026</a>
        opened by <a href="https://github.com/zsol">@zsol</a>
        on 2025-12-17 18:07
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/zsol">@zsol</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>For example checking the following takes 11s, but the real world example this is taken from takes many minutes (and is a bit more nested):</p>
<pre><code class="language-python">from pydantic_core import core_schema

core_schema.union_schema(
    [
        core_schema.is_instance_schema(...),
        core_schema.chain_schema(
            [
                core_schema.no_info_after_validator_function(
                    function=lambda data: data,
                    schema=core_schema.list_schema(
                        core_schema.list_schema(
                            core_schema.list_schema(),
                        )
                    ),
                ),
            ]
        ),
    ],
)
</code></pre>
<h3>Version</h3>
<p>0.0.2 with #22030 applied</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @carljm on 2025-12-17 18:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-12-17 18:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/oconnor663">@oconnor663</a> on 2025-12-17 18:13</div>
            <div class="timeline-body"><p>Yeah the performance of that specific <code>CoreSchema</code> union in Pydantic has been a known problem in https://github.com/astral-sh/ruff/pull/21467 and https://github.com/astral-sh/ruff/pull/21784. I'm working on <code>TypedDict</code> tagged union support right now, and the hope is that it'll help with this problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-12-19 01:22</div>
            <div class="timeline-body"><p>I just verified that https://github.com/astral-sh/ruff/pull/22052 and https://github.com/astral-sh/ruff/pull/22048 do not appear to help with this particular snippet. Here's the flamegraph (with those pull requests combined) https://share.firefox.dev/3KErPOX</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-12-19 02:02</div>
            <div class="timeline-body"><p>The pattern seems to be</p>
<pre><code>  infer_all_argument_types                                                                                                                                                                                           
    → infer_and_check_argument_types::{{closure}} (try_narrow)                                                                                                                                                       
      → infer_call_expression                                                                                                                                                                                        
        → infer_all_argument_types  (recursive)                                                                                                                                                                     
</code></pre>
<p>Claude claims</p>
<blockquote>
<p>When the type context is a union (52-element <code>CoreSchema</code>), it tries each union element via <code>try_narrow</code>. And for each attempt, nested call expressions also go through the same process. This gives <code>O(52^depth)</code> complexity.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-12-19 02:12</div>
            <div class="timeline-body"><p>I pursued various caching approaches before attempting to fix the root cause of the explosion.</p>
<p>I then had Claude look at a way to prevent the recursion and a patch like</p>
<pre><code class="language-diff">diff --git a/crates/ty_python_semantic/src/types/infer/builder.rs b/crates/ty_python_semantic/src/types/infer/builder.rs
index ac6d092c08..5123f06cf0 100644
--- a/crates/ty_python_semantic/src/types/infer/builder.rs
+++ b/crates/ty_python_semantic/src/types/infer/builder.rs
@@ -7008,12 +7008,18 @@ impl&lt;'db, 'ast&gt; TypeInferenceBuilder&lt;'db, 'ast&gt; {
         let db = self.db();
 
         // If the type context is a union, attempt to narrow to a specific element.
-        let narrow_targets: &amp;[_] = match call_expression_tcx.annotation {
-            // TODO: We could theoretically attempt to narrow to every element of
-            // the power set of this union. However, this leads to an exponential
-            // explosion of inference attempts, and is rarely needed in practice.
-            Some(Type::Union(union)) =&gt; union.elements(db),
-            _ =&gt; &amp;[],
+        // However, skip narrowing if we're already inside a multi-inference context
+        // (i.e., inside a nested call during union narrowing) to avoid exponential blowup.
+        let narrow_targets: &amp;[_] = if self.context.is_in_multi_inference() {
+            &amp;[]
+        } else {
+            match call_expression_tcx.annotation {
+                // TODO: We could theoretically attempt to narrow to every element of
+                // the power set of this union. However, this leads to an exponential
+                // explosion of inference attempts, and is rarely needed in practice.
+                Some(Type::Union(union)) =&gt; union.elements(db),
+                _ =&gt; &amp;[],
+            }
         };
 
         // We silence diagnostics until we successfully narrow to a specific type.
</code></pre>
<p>completely resolves the issue.</p>
<pre><code>  | Nesting | Baseline | With caching | With narrowing fix |                                                                                                                                                         
  |---------|----------|--------------|--------------------|                                                                                                                                                         
  | 2-level | 0.66s    | 0.12s        | 0.02s              |                                                                                                                                                         
  | 3-level | 13s      | 2.1s         | 0.02s              |                                                                                                                                                         
  | 4-level | &gt;120s    | 40.5s        | 0.02s              |     
</code></pre>
<p>I don't feel qualified to say if this is appropriate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/zanieb">@zanieb</a> on 2025-12-19 02:33</div>
            <div class="timeline-body"><p>I felt it was probably not appropriate, so I pursued avoiding redundant narrowing of repeated unions instead as an alternative. https://github.com/astral-sh/ruff/pull/22066 tracks ancestor unions to avoid recursive analysis. This still gives a 250x improvement on the 4-level snippet. I can get another 4x on top of that (i.e., 1000x) with various caching changes.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-19 08:26</div>
            <div class="timeline-body"><p>I don't think we should pursue any micro-optimisations that only benefit pydantic (especially not ones that regress memory usage) until we see the performance impact of @oconnor663's upcoming work to implement tagged-union narrowing for unions of TypedDicts. (We know the pathological performance on pydantic is caused by the fact that they have a huge union of TypedDicts, and it currently never gets narrowed by us.) E.g. the reported pydantic speedup on https://github.com/astral-sh/ruff/pull/22066 is currently very impressive, but it's possible the number changes a lot after Jack's work has landed.</p>
<p>I continue to find https://github.com/astral-sh/ruff/pull/22065 interesting, however, since it's a very targeted change that also shows speedups on non-pydantic benchmarks, and actually shows a memory-usage <em>improvement</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ibraheemdev on 2025-12-20 04:18</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:21:23 UTC
    </footer>
</body>
</html>
