<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>support field_specifiers in dataclass_transform - astral-sh/ty #1068</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>support field_specifiers in dataclass_transform</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/1068">#1068</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-08-20 21:25
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>This is important, because it is used by two of the most popular clients of <code>dataclass_transform</code>, attrs and pydantic.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Beta" by @carljm on 2025-08-20 21:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">feature</span> added by @carljm on 2025-08-20 21:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">typing semantics</span> added by @carljm on 2025-08-20 21:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-22 13:49</div>
            <div class="timeline-body"><p>@PrettyWood is <a href="https://github.com/astral-sh/ruff/pull/19825#issuecomment-3211169196">planning to look into this</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">dataclasses</span> added by @AlexWaygood on 2025-08-22 13:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @carljm by @carljm on 2025-08-22 14:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-22 14:07</div>
            <div class="timeline-body"><p>For some reason GitHub won't let me actually assign the issue to @PrettyWood, so I'm assigning it to myself, just to mark that it isn't unowned</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-22 14:09</div>
            <div class="timeline-body"><blockquote>
<p>For some reason GitHub won't let me actually assign the issue to <a href="https://github.com/PrettyWood">@PrettyWood</a>, so I'm assigning it to myself, just to mark that it isn't unowned</p>
</blockquote>
<p>for people outside the organisation, they need to have commented on the issue before GitHub will let you assign them to the issue</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-22 14:20</div>
            <div class="timeline-body"><blockquote>
<p>for people outside the organisation, they need to have commented on the issue before GitHub will let you assign them to the issue</p>
</blockquote>
<p>I feel like every month or so I learn this again and then forget it again</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/PrettyWood">@PrettyWood</a> on 2025-08-22 14:35</div>
            <div class="timeline-body"><p>I'm actually working on it directly in https://github.com/astral-sh/ruff/pull/19825.</p>
<p>It's trickier than I thought because when I first started, I thought <code>field_specifiers </code>was the only missing piece and I went with</p>
<ul>
<li>parse `@dataclass_transform(field_specifiers=(Field, ...))</li>
<li>store the field specifiers</li>
<li>detect calls to those field specifiers</li>
<li>apply dataclass-like validation (via FieldInstance...)</li>
</ul>
<p>The assumption was that <code>@dataclass_transform</code> itself was already fully supported but it's not. I'm working on making it understood for <code>attrs</code> and <code>pydantic</code>
I'll keep you posted</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @PrettyWood by @carljm on 2025-08-22 14:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @carljm by @carljm on 2025-08-22 14:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-22 15:08</div>
            <div class="timeline-body"><blockquote>
<p>The assumption was that <code>@dataclass_transform</code> itself was already fully supported but it's not. I'm working on making it understood for <code>attrs</code> and <code>pydantic</code></p>
</blockquote>
<p>Interesting, I thought it was supported enough for your plan in the above bullet points to be sufficient. What else is missing? It seems like we support it enough for <code>kw_only_default</code> to be respected.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/PrettyWood">@PrettyWood</a> on 2025-08-23 08:18</div>
            <div class="timeline-body"><p>@carljm metaclasses decorated with <code>@dataclass_transform(kw_only_default=True)</code> did not forward the information to the applied classes, which is what <code>pydantic</code> uses
But it's ok it's now fixed</p>
<details>
  <summary>Here is a summary of current behaviour for dataclass_transform, attrs and pydantic</summary>

<pre><code class="language-py">import attrs
import pydantic
from typing import dataclass_transform, reveal_type
from dataclasses import dataclass


@dataclass(kw_only=True)
class DataclassUser:
    name: str
    age: int


reveal_type(DataclassUser.__init__)
# # `(self: DataclassUser, *, name: str, age: int) -&gt; None` üü¢ 


@dataclass_transform(kw_only_default=True)
def model(cls):
    return cls


@model
class CustomUser:
    name: str
    age: int


reveal_type(CustomUser.__init__)
# `(self: CustomUser, *, name: str, age: int) -&gt; None` üü¢


@dataclass_transform(kw_only_default=True)
class ModelMeta(type):
    pass


class CustomModel(metaclass=ModelMeta):
    def __init__(self, **data):
        for k, v in data.items():
            setattr(self, k, v)


class CustomMetaclassUser(CustomModel):
    name: str
    age: int


reveal_type(CustomMetaclassUser.__init__)
# `(self: CustomMetaclassUser, name: str, age: int) -&gt; None` üü† (`kw_only_default` not recognised)

@attrs.define(kw_only=True)
class AttrsUser:
    name: str
    age: int


reveal_type(AttrsUser.__init__)
# `(self: AttrsUser, name: str, age: int) -&gt; None` üü†
# (`kw_only_default` not recognised but expected because stub file doesn't add `kw_only_default` in `@dataclass_transform`)


class PydanticUser(pydantic.BaseModel):
    name: str
    age: int


reveal_type(PydanticUser.__init__)
# `(self: PydanticUser, __pydantic_extra__: @Todo(unknown type subscript) | None = Any, __pydantic_fields_set__: set[str] = Any, __pydantic_private__: @Todo(unknown type subscript) | None = Any, name: str, age: int) -&gt; None` üî¥
# `kw_only_default` not recognised because Pydantic uses metaclass
# extra fields in signature that will be removed when `field_specifiers` are implemented)
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/PrettyWood">@PrettyWood</a> on 2025-08-24 17:45</div>
            <div class="timeline-body"><p>@carljm @sharkdp (pinging you because you worked on https://github.com/astral-sh/ruff/pull/17445 üôè )
Before opening a PR I would like to get your guidance</p>
<p>To support what I just wrote above (pydantic-like usage with metaclass) I simply changed</p>
<pre><code class="language-diff">--- a/crates/ty_python_semantic/src/types/class.rs
+++ b/crates/ty_python_semantic/src/types/class.rs
@@ -2022,7 +2022,10 @@ impl&lt;'db&gt; ClassLiteral&lt;'db&gt; {
         specialization: Option&lt;Specialization&lt;'db&gt;&gt;,
         name: &amp;str,
     ) -&gt; Option&lt;Type&lt;'db&gt;&gt; {
-        let dataclass_params = self.dataclass_params(db);
+        let dataclass_params = self.dataclass_params(db).or(self
+            .try_metaclass(db)
+            .ok()
+            .and_then(|(_, transformer_params)| transformer_params.map(Into::into)));
         let has_dataclass_param =
             |param| dataclass_params.is_some_and(|params| params.contains(param));
</code></pre>
<p>It works and</p>
<pre><code class="language-py">@dataclass_transform(kw_only_default=True)
def my_dataclass[T](cls: type[T]) -&gt; type[T]:
    return cls

@my_dataclass
class M2:
    x: int

reveal_type(M2.__init__)
</code></pre>
<p>now gives <code>(self: M2, *, x: int) -&gt; None</code> (when it used to be without <code>*</code> so no kw-only)</p>
<p>But I don't really like the fact that this code</p>
<pre><code class="language-rs">            if let Type::FunctionLiteral(f) = decorator_ty {
                // We do not yet detect or flag `@dataclass_transform` applied to more than one
                // overload, or an overload and the implementation both. Nevertheless, this is not
                // allowed. We do not try to treat the offenders intelligently -- just use the
                // params of the last seen usage of `@dataclass_transform`
                let params = f
                    .iter_overloads_and_implementation(self.db())
                    .find_map(|overload| overload.dataclass_transformer_params(self.db()));
                if let Some(params) = params {
                    dataclass_params = Some(params.into());
                    continue;
                }
            }

            if let Type::DataclassTransformer(params) = decorator_ty {
                dataclass_transformer_params = Some(params);
                continue;
            }
</code></pre>
<p>is only called for function literals.</p>
<p>Also in my code the actual <code>field_specifiers</code> are stored separately in <code>FieldSpecifiers</code></p>
<pre><code class="language-rs">#[salsa::interned(debug, heap_size=ruff_memory_usage::heap_size)]
pub struct FieldSpecifiers&lt;'db&gt; {
    #[returns(ref)]
    pub specifiers: Vec&lt;Type&lt;'db&gt;&gt;,
}
</code></pre>
<p>They are linked via <code>OverloadLiteral::field_specifiers</code> to keep this struct <code>Copy</code>-able. Why does it need to be <code>Copy</code>? Only <code>Clone</code> wouldn't be enough?</p>
<p>What I would love is</p>
<ul>
<li>parse <code>@dataclass_transform(...)</code></li>
<li>create a unified <code>DataclassParams</code> that works the same way for both <code>@dataclass</code> and <code>@dataclass_transform</code>
We would have <code>DataclassParams</code> with field specifiers = <code>(dataclasses.field, dataclasses.Field)</code> by default. If it comes from <code>dataclass_transform</code> we set them to <code>()</code> if no field specifiers is set, else the set fields specifiers.</li>
<li>unified logic in <code>own_fields()</code></li>
</ul>
<p>Thank you for your help</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-08-26 11:22</div>
            <div class="timeline-body"><blockquote>
<p>To support what I just wrote above (pydantic-like usage with metaclass) I simply changed [‚Ä¶] It works and [‚Ä¶] now gives (self: M2, *, x: int) -&gt; None (when it used to be without * so no kw-only)</p>
</blockquote>
<p>üëç</p>
<blockquote>
<p>But I don't really like the fact that this code [‚Ä¶] is only called for function literals.</p>
</blockquote>
<p>Can you go into this in more detail? What kind of code sample do you have in mind that wouldn't be supported?</p>
<blockquote>
<p>Also in my code the actual <code>field_specifiers</code> are stored separately in <code>FieldSpecifiers</code> [‚Ä¶] They are linked via <code>OverloadLiteral::field_specifiers</code> to keep this struct <code>Copy</code>-able. Why does it need to be <code>Copy</code>? Only <code>Clone</code> wouldn't be enough?</p>
</blockquote>
<p>Do you mean: &quot;why does <code>OverloadLiteral</code> need to be <code>Copy</code>&quot;? If so, <code>OverloadLiteral</code> is used inside <code>FunctionLiteral</code>. <code>FunctionLiteral</code> is used inside <code>FunctionType</code>. And <code>FunctionType</code> is used in the <code>Type::FunctionLiteral</code> variant, where <code>Type</code> is currently <code>Copy</code>. I think the motivation for that is mostly just &quot;for convenience&quot;. We want it to be a small type that's cheap to clone anyway, so making it <code>Copy</code> too allows for much easier handling of that type (e.g. no explicit <code>.clone()</code> calls everywhere). It also allows us to use <code>Type</code> directly in arguments and return types of salsa queries, which do not allow for references. Maybe there is also an even stricter requirement for it to be <code>Copy</code>, but I can't remember one right now.</p>
<blockquote>
<p>What I would love is</p>
<pre><code>* parse `@dataclass_transform(...)`</code></pre>
</blockquote>
<p>What do you mean by parse? Why is returning a <code>Type::DataclassTransformer(‚Ä¶)</code> variant from calls to <code>dataclass_transform</code> not good enough?</p>
<blockquote>
<p>create a unified DataclassParams that works the same way for both @dataclass and @dataclass_transform
We would have DataclassParams with field specifiers = (dataclasses.field, dataclasses.Field) by default. If it comes from dataclass_transform we set them to () if no field specifiers is set, else the set fields specifiers.</p>
</blockquote>
<p>That seems reasonable</p>
<blockquote>
<p>unified logic in <code>own_fields()</code></p>
</blockquote>
<p>I'm not sure what that means.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-09-09 17:42</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ty/issues/1159 needs this, specifically support for the <code>alias</code> parameter.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gerharddc">@Gerharddc</a> on 2025-10-03 09:13</div>
            <div class="timeline-body"><p>It's a bit unclear if this is related to the issue discussed here, but when I use https://github.com/openapi-generators/openapi-python-client to generate an openapi cient, it generates a class similar to:</p>
<pre><code>...
from attrs import define, evolve, field

@define
class Client:
    ...
    raise_on_unexpected_status: bool = field(default=False, kw_only=True)
    _base_url: str = field(alias=&quot;base_url&quot;)
    ...
    _httpx_args: dict[str, Any] = field(factory=dict, kw_only=True, alias=&quot;httpx_args&quot;)
    ...
</code></pre>
<p>When I then try to use it as follows:</p>
<p><code>client = Client(base_url=&quot;http://10.1.3.3&quot;, raise_on_unexpected_status=True, httpx_args={ &quot;transport&quot;: RetryTransport() })</code></p>
<p>I get <code>unknown-argument</code> warnings for <code>base_url</code> and <code>httpx_args</code> which are using &quot;alias&quot; but there is no warning for <code>raise_on_unexpected_status</code> which does not use it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-10-06 11:20</div>
            <div class="timeline-body"><p>This is related, yes. In addition, that will require us to support the <code>alias</code> field of field specifiers.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @PrettyWood by @sharkdp on 2025-10-09 10:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2025-10-09 10:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @sharkdp on 2025-10-16 18:49</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:20:31 UTC
    </footer>
</body>
</html>
