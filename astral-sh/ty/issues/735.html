<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Consider retrying arity check after argument type expansion - astral-sh/ty #735</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Consider retrying arity check after argument type expansion</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/735">#735</a>
        opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a>
        on 2025-07-01 04:44
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/dhruvmanila">@dhruvmanila</a> on 2025-07-01 04:44</div>
            <div class="timeline-body"><p>Ref: https://github.com/astral-sh/ruff/pull/18996/files#r2172952014</p>
<hr />
<p>This is a regression that was highlighted by the ecosystem check, which shows that we might need to rethink how we perform argument expansion during overload resolution. In particular, we might need to retry both <code>match_parameters</code> <em>and</em> <code>check_types</code> for each expansion. Currently we only retry <code>check_types</code>.</p>
<p>The issue is that argument expansion might produce a splatted value with a different arity than what we originally inferred for the unexpanded value, and that in turn can affect which parameters the splatted value is matched with. In this example, the ternary operator produces a complex union type, which we expand when trying to call <code>range</code>. Our initial guess at its arity is &quot;zero or more&quot;, but there are individual union elements with more precise arities (such as &quot;exactly two&quot;). <code>range</code>, via overloads and parameter defaults, can take in 1, 2, or 3 parameters. Our initial arity guess causes us to assign the splatted argument to all three parameters. But when we check the <code>(0, 100)</code> union element during argument expansion, we only have two values to provide for those three parameters.</p>
<p>For now, we have a workaround that pads out the splatted value with <code>Unknown</code> when we encounter this case, but a proper fix would retry parameter matching for each expanded union element.</p>
<pre><code class="language-py">def _(batch_ids=(0, 100)) -&gt; None:
    arg = batch_ids if isinstance(batch_ids, tuple) else (0, batch_ids)
    # revealed: (Unknown &amp; tuple[Unknown, ...]) | (tuple[Literal[0], Literal[100]] &amp; tuple[Unknown, ...]) | tuple[Literal[0], (Unknown &amp; ~tuple[Unknown, ...]) | (tuple[Literal[0], Literal[100]] &amp; ~tuple[Unknown, ...])]
    reveal_type(arg)
    range(*arg)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">calls</span> added by @dhruvmanila on 2025-07-01 04:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">overloads</span> added by @dhruvmanila on 2025-07-01 04:44</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-01 05:56</div>
            <div class="timeline-body"><p>@erictraut I wonder if you have any insight on how you chose to handle this in pyright. The spec (in step 3, union expansion) says to &quot;repeat from step 2&quot; for each expanded set of arguments, and step 2 is just type checking (step 1 is arity checking). But it seems there are cases (e.g. a union of tuple types of different lengths, used as variadic argument) where union expansion might lead to different arity-check conclusions and different argument-parameter mappings.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/erictraut">@erictraut</a> on 2025-07-01 06:55</div>
            <div class="timeline-body"><p>This is partly related to <a href="https://discuss.python.org/t/standardizing-argument-unpacking-behaviors-for-calls/80747">the thread</a> that I started several months ago in the typing forum. We haven't yet standardized how unpacked arguments are handled in call expressions — in particular, in situations where the unpacked iterable has an indeterminate length. The same is true for dictionary unpacking and keyword arguments. Since there is no standard currently, each type checker needs to decide how to handle this case.</p>
<p>With regard to the overload algorithm, step 1 performs <em>filtering</em> based on arity checks. If the positional argument count is indeterminate because of an unpack operator, then arity-based filtering may not be able to eliminate any overloads. That's the case for the <code>range</code> constructor call in the example above.</p>
<p>Step 2 involves regular (non-overloaded) call evaluation. This is shorthand for &quot;the type checker should do whatever it normally does here for non-overloaded calls&quot;. This is the part that's not yet standardized.</p>
<p>I was curious what mypy and pyright do for the code sample above. Here's a modified version that replaces the <code>range</code> constructor call with an overloaded function that has non-overlapping return types.</p>
<pre><code class="language-python">from typing import overload

@overload
def test(x: int, /) -&gt; tuple[int]: ...
@overload
def test(x: int, y: int, /) -&gt; tuple[int, int]: ...
# @overload
# def test(*args: int) -&gt; tuple[int, ...]: ...
def test(*args: int) -&gt; tuple[int, ...]: ...

def _(arg: tuple[int, ...]):
    result = test(*arg)
    reveal_type(result)
</code></pre>
<p>Interestingly, pyright reveals <code>Unknown</code> whereas mypy reveals <code>tuple[int]</code>. Mypy doesn't follow the algorithm in the typing spec in this case, and I think its result is unsound.</p>
<p>If we uncomment the third overload, then mypy and pyright agree because of step 4 in the overload algorithm.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Beta" by @carljm on 2025-08-19 14:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @dhruvmanila by @dhruvmanila on 2025-08-22 13:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dhruvmanila on 2025-09-12 08:40</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:15 UTC
    </footer>
</body>
</html>
