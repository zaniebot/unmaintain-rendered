<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Avoid literal promotion when constructing `frozenset` from list/set literal - astral-sh/ty #2280</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Avoid literal promotion when constructing <code>frozenset</code> from list/set literal</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/2280">#2280</a>
        opened by <a href="https://github.com/Jammf">@Jammf</a>
        on 2025-12-30 19:34
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Jammf">@Jammf</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Literal promotion is currently performed for <code>tuple</code> but not for <code>frozenset</code>. This is surprising to me given that they both are immutable and behave somewhat similarly. It could be useful to change <code>frozenset</code>, for instance to support the following comparisons:</p>
<pre><code class="language-python">from typing import reveal_type

# tuple
reveal_type((1, 2))  # Revealed type: `tuple[Literal[1], Literal[2]]`
reveal_type((1, 2) == (1, 2))  # Revealed type: `Literal[True]`

# frozenset
reveal_type(frozenset({1, 2}))  # Revealed type: `frozenset[Unknown | int]`
reveal_type(frozenset({1, 2}) == frozenset({1, 2}))  # Revealed type: `bool`
reveal_type(frozenset({1, 2}) == frozenset({2, 1}))  # Revealed type: `bool`
</code></pre>
<p>https://play.ty.dev/464c2ef8-e7bc-4e74-938f-3c0f2cd20916</p>
<p>Related: https://github.com/astral-sh/ty/issues/1284#issuecomment-3403747307</p>
<h3>Version</h3>
<p>ty 0.0.8 (aa7559db8 2025-12-29)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-30 21:15</div>
            <div class="timeline-body"><p>To clarify terminology: &quot;literal promotion&quot; refers to promoting a type like <code>Literal[1]</code> or <code>Literal[1, 2]</code> to the wider type <code>int</code>. So the examples above show that we do not promote literals in tuple types, but we seemingly do in frozenset.</p>
<p>Why do I say &quot;seemingly&quot;? We actually don't promote literals in the frozenset constructor, because frozenset is covariant. In the examples above, we promote the literals before they ever reach frozenset, when we infer a type for the set literal <code>{1, 2}</code> that is passed to the frozenset constructor. We can see the difference in this example:</p>
<pre><code class="language-py">from typing import Literal

l: set[Literal[1, 2]] = {1, 2}
x = frozenset(l)  # x is now `frozenset[Literal[1, 2]]`
</code></pre>
<p>So the feature request here is to pass through the type context from the frozenset constructor so that we avoid literal promotion on the inner container, if it's a list/set literal.</p>
<p>This is something that no other type checker does, so I think it's low priority, but I don't see any reason we couldn't do it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Do not promote literals in `frozenset`" to "Avoid literal promotion when constructing `frozenset` from list/set literal" by @carljm on 2025-12-30 21:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bidirectional inference</span> added by @carljm on 2025-12-30 21:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jammf">@Jammf</a> on 2025-12-30 23:45</div>
            <div class="timeline-body"><p>Thanks for the clarification. I tried to borrow the terminology from the related issue, but I'm pretty new to it all, so it turned out less precise than I'd hoped. Your description makes sense to me though, that the promotion happens in the set literal, and that was I was actually asking for was to avoid that promotion if the set literal was within a frozenset.</p>
<p>If I'm understanding correctly, it seems like the (implied) other part of the feature request (comparisons between <code>frozenset</code> types) might not be feasible.</p>
<pre><code class="language-python">from typing import Literal, reveal_type

l: set[Literal[1, 2]] = {1, 2}
a: frozenset[Literal[1, 2]] = frozenset(l)
b: frozenset[Literal[1, 2]] = frozenset(l)
reveal_type(a == b)  # Revealed type: `bool`
</code></pre>
<p>which I think boils down to there not being a way to specify the exact members of a set/frozenset within a type, since <code>set[Literal[1, 2]]</code> could mean any of <code>{1}</code>,  <code>{2}</code>, or <code>{1, 2}</code>. I also tried explicitly casting to an Intersection that should mean just <code>{1, 2}</code>, which also didn't work:</p>
<pre><code class="language-python">from typing import Literal, reveal_type, cast
from ty_extensions import Intersection, Not

l: set[Literal[1, 2]] = {1, 2}
a: frozenset(l)
b: frozenset(l)

a = cast(&quot;Intersection[frozenset[Literal[1, 2]], Not[frozenset[Literal[1]]], Not[frozenset[Literal[2]]]]&quot;, a)
b = cast(&quot;Intersection[frozenset[Literal[1, 2]], Not[frozenset[Literal[1]]], Not[frozenset[Literal[2]]]]&quot;, b)
reveal_type(a == b)  # Revealed type: `bool`
</code></pre>
<p>But perhaps a more elegant solution would instead be a change to the typing spec, to allow forms like <code>frozenset[int, ...]</code>, <code>frozenset[Literal[1], Literal[2]]</code>, so it'd be like an unordered version of <code>tuple</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-06 02:11</div>
            <div class="timeline-body"><p>Yes, I think your analysis is correct that even if we did infer the frozenset type without literal promotion, it still wouldn't enable the equality behavior you're looking for, without major changes to special-case <code>frozenset</code> in the type system (which I think is unlikely -- it's not likely something we'd implement in ty without a change to the typing spec mandating it.)</p>
<p>I think your intersection version <em>could</em> be implemented, but it would add a lot of complexity, just to give a more <em>precise</em> result in a case where we already give a <em>correct</em> result. So I'm also skeptical that we'd prioritize this.</p>
<p>I think we should limit this issue to considering the inference and literal promotion question, and not the equality behavior. That could be a separate issue, but I'm not sure I'd bother with that.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:21:37 UTC
    </footer>
</body>
</html>
