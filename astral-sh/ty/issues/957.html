<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>set a lower limit for size of literal unions we will do precise type inference of operations for - astral-sh/ty #957</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>set a lower limit for size of literal unions we will do precise type inference of operations for</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/957">#957</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-08-08 17:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/carljm">@carljm</a> on 2025-08-08 17:17</div>
            <div class="timeline-body"><p>For example, we know that if we add <code>Literal[1, 2]</code> to <code>Literal[3]</code>, we get <code>Literal[4, 5]</code>. But in some cyclic scenarios, something like <code>x += 1</code> can result in an ever-expanding union (until we hit the Salsa cycle limit). We currently set an overall limit of 100 on literal-unions size, which is lower than the 200 Salsa cycle limit, but this still means we can iterate 100 times before we converge -- that's a lot.</p>
<p>We don't want to decrease our overall literal-unions size limit any lower than 100 (in fact ideally we'd increase it -- people should be able to explicitly create large literal unions). But we should set a much <em>lower</em> limit on the size of literal unions we are willing to do literal-math on (and beyond that limit we should just fall back to e.g. <code>int</code>). I think a limit in the low double-digits would be reasonable here. This would also significantly reduce the amount of fixpoint iteration needed in cyclic cases before we converge.</p>
<p>(This should apply not just to literal ints, but also operations on literal strings and bytes, too.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">performance</span> added by @carljm on 2025-08-08 17:17</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">set-theoretic types</span> added by @carljm on 2025-08-08 17:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/erictraut">@erictraut</a> on 2025-08-08 17:51</div>
            <div class="timeline-body"><p>In case it's helpful, here are <a href="https://github.com/microsoft/pyright/blob/8b02aa84ec916697e76d5ee69299a89d555ec98c/packages/pyright-internal/src/analyzer/operations.ts#L587">the conditions</a> under which pyright performs literal math.</p>
<ol>
<li>The operation cannot be in a loop (a <code>for</code> or <code>while</code>)</li>
<li>The operation must be acting on a local variable, as opposed to an attribute or subscript expression or a variable defined in some outer scope</li>
<li>The resulting union cannot be greater than 64 in size (a somewhat arbitrary number, but one that seems to work well in practice)</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-20 17:54</div>
            <div class="timeline-body"><p>This would fix #660.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @sharkdp by @sharkdp on 2025-08-22 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-09-22 13:10</div>
            <div class="timeline-body"><p>Another instance of this:</p>
<pre><code class="language-py">class C:
    def __init__(self: &quot;C&quot;):
        self.x1 = 0
        self.x2 = 1
        self.x3 = 0
     
    def f1(self: &quot;C&quot;):
        self.x1 = self.x2 + self.x3
        self.x2 = self.x1 + self.x3
        self.x3 = self.x1 + self.x2

    def f2(self: &quot;C&quot;):
        self.x1 = self.x2 + self.x3
        self.x2 = self.x1 + self.x3
        self.x3 = self.x1 + self.x2
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "GA" by @carljm on 2025-09-22 20:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unassigned @sharkdp by @sharkdp on 2025-09-30 07:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-24 15:23</div>
            <div class="timeline-body"><p>Another case (from #1423 ):</p>
<pre><code class="language-py">from typing import Self

class A:
    def __init__(self: Self):
        self.a = 0
        self.b = 0

    def foo(self: Self):
        if self.a:
            self.b = self.b + 1

    def bar(self: Self):
        if str(self.b):
            self.a = self.b
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-10-28 17:25</div>
            <div class="timeline-body"><p>I think we can leverage the approach in astral-sh/ruff#20566 for type inference of recursively defined values.
That is, by using <code>Divergent</code> as a &quot;cycle marker&quot;, we can detect that &quot;the value is recursively defined&quot;.
Conversely, as long as an expression is not recursively defined, we can assume that the union type of the value is at most a finite set, and it can be as large as the user desires.</p>
<p>However, it would be impossible to generally distinguish between expressions that are &quot;recursively defined but have finite possible states&quot; and expressions that have &quot;infinitely many possible states&quot; - this would be as difficult as the halting problem, or even more.</p>
<p>However, I think the following heuristics might work well:</p>
<ul>
<li>If the input types (types involved in union) are all finite (e.g., bool, a tuple of finite types), the output set is also finite. In this case, we may not need to specify threshold.</li>
<li>If the input types are infinite (e.g., int, str), the output set may be infinite. If the value is recursively defined, widening is performed at a certain threshold (smaller than the current setting).</li>
</ul>
<p>There is a possibility that the finite saturation case may be widened by mistake, but I don't think this will be a serious problem in most practical cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-30 15:58</div>
            <div class="timeline-body"><p>@mtshiba It seems to me that the fix described in the OP here (limiting the size of literal unions we are willing to create, as pyright does) would address all problematic cases arising from potentially-infinite unions of literals, without any need for the use of <code>Divergent</code>, and no other significant downsides. It wouldn't address e.g. infinitely-nested generic types (those are the cases where we need <code>Divergent</code>). I don't think solving this issue requires distinguishing &quot;finite&quot; vs &quot;potentially infinite&quot;[^1] types, or determining whether an expression is recursively defined (beyond what that already happens via Salsa and fixpoint iteration.)</p>
<p>[^1]: Technically all of these types are finite in ty. We only support integer literals up to what fits in an i64, and we limit the length of string and bytes literals. But obviously in both cases the number of possible values is far beyond what we can handle in a union with good performance, or reach in fixpoint iteration within an acceptable number of iterations.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">fatal</span> added by @carljm on 2025-10-30 15:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-10-30 16:01</div>
            <div class="timeline-body"><p>Since (with type-of-self landed) this is now showing up as a major performance regression in real user codebases, I think it is higher priority to fix. Tempted to mark it for beta milestone.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-11-04 16:59</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/mtshiba">@mtshiba</a> It seems to me that the fix described in the OP here (limiting the size of literal unions we are willing to create, as pyright does) would address all problematic cases arising from potentially-infinite unions of literals, without any need for the use of <code>Divergent</code>, and no other significant downsides. It wouldn't address e.g. infinitely-nested generic types (those are the cases where we need <code>Divergent</code>). I don't think solving this issue requires distinguishing &quot;finite&quot; vs &quot;potentially infinite&quot;<a href="#user-content-fn-1-7647dddaba5a72a3ba2e68914f1654e5">1</a> types, or determining whether an expression is recursively defined (beyond what that already happens via Salsa and fixpoint iteration.)</p>
</blockquote>
<p>The examples I'm thinking of are as follows:</p>
<pre><code class="language-python">from typing import Literal

def f(bit: Literal[0, 1]):
   i1 = bit
   i2 = 2*i1 + bit
   i3 = 2*i2 + bit
   i4 = 2*i3 + bit
   i5 = 2*i4 + bit
   i6 = 2*i5 + bit
   i7 = 2*i6 + bit
   i8 = 2*i7 + bit

   reveal_type(i1)  # Literal[0, 1]
   reveal_type(i2)  # Literal[0, 1, 2, 3]
   reveal_type(i3)  # Literal[0, 1, 2, 3, 4, 5, 6, 7]
   reveal_type(i4)  # ...
   reveal_type(i5)
   reveal_type(i6)
   reveal_type(i7)
   reveal_type(i8)
</code></pre>
<p>The type of <code>i8</code> is expected to be a literal type with 256 elements, but since both pyright and ty perform widening beforehand, it becomes <code>int</code>. However, in terms of computational load, there should still be a fair bit of headroom.</p>
<p>On the other hand, widening should be performed promptly in the following case:</p>
<pre><code class="language-python">class C:
   def __init__(self):
       self.i = 0

   def inc(self):
      self.i = self.i + 1

reveal_type(C().i)
</code></pre>
<hr />
<p>What I propose from the discussion so far is to define two thresholds for widening.</p>
<p>For values ​​that are not recursively defined, allow literal types to have a significantly larger number of literal elements than the current threshold (the reason for the threshold is simply to prevent literals from being created with unrealistic number of elements, which would put a huge strain on the computer). I don't think literal-math will be too costly for a few hundred elements, since the fixed point calculation converges in one go.</p>
<p>For values ​​that are recursively defined, set the threshold smaller than the current one to speed up the convergence of fixed-point iteration.</p>
<p>Setting a single threshold without recursion tracking forces a trade-off between the desire to allow literal types with as many elements as possible for non-recursively defined value types and the desire to allow calculations for recursively defined value types to converge as quickly as possible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-11-04 17:11</div>
            <div class="timeline-body"><p>The above proposal does not preclude work to lower the limit in order to improve performance sooner.
For values ​​that are not defined recursively, the limit can be raised later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-11-04 17:35</div>
            <div class="timeline-body"><p>Yes, that all makes sense. I think if we are able to reliably detect recursively-defined values, the two thresholds is certainly nice to have, but it will also be OK, probably for quite a while, if we share a single (low) threshold. That is, it's OK if the first example widens fairly quickly (even already by i4), and it's probably also OK if the second example iterates a couple tens of times.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-11-28 09:23</div>
            <div class="timeline-body"><p>astral-sh/ruff#20566 has been merged, so I'll try to see if my idea works.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-12-05 02:01</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:22 UTC
    </footer>
</body>
</html>
