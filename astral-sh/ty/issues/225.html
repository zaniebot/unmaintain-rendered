<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Control flow modelling error in `try` ... `else` - astral-sh/ty #225</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Control flow modelling error in <code>try</code> ... <code>else</code></h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/225">#225</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2024-12-11 11:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2024-12-11 11:06</div>
            <div class="timeline-body"><p>https://github.com/astral-sh/ty/issues/233 mentions a problem with <code>finally</code> suites, but it looks like we also don't model <code>try</code> â€¦ <code>else</code> control flow correctly in all cases.</p>
<p>We currently infer <code>Literal[1, 2, 3]</code> here, but it should be <code>Literal[1, 3]</code>?</p>
<pre><code class="language-py">def may_raise() -&gt; None: ...
def flag() -&gt; bool: ...

x = 1

try:
    may_raise()
    x = 2
except KeyError:
    pass
else:
    x = 3

reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-11 11:53</div>
            <div class="timeline-body"><p>I spent a while thinking that this had something to do with the fact that we don't yet model the fact that simple statements like <code>x = 2</code> cannot ever raise exceptions (except for <code>KeyboardInterrupt</code>). But it doesn't actually have anything to do with that, I don't think. So let's use this example, which doesn't confuse the two issues in the same way ;)</p>
<pre><code class="language-py">from typing import Literal

def may_raise() -&gt; Literal[2]:
    return 2

x = 1
    
try:
    may_raise()
    x = may_raise()
except:
    pass
else:
    x = 3
    
reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
<p>Like your example, we reveal <code>Literal[1, 2, 3]</code> here, but it's possible that we should ideally reveal <code>Literal[1, 3]</code>. This is because the possible control-flow paths are as follows:</p>
<ol>
<li>One of the <code>may_raise()</code> calls fails with something other than <code>KeyError</code>. The scope immediately terminates; this isn't interesting to us and we don't need to consider it any further.</li>
<li>The first <code>try</code> <code>may_raise()</code> call fails with <code>KeyError</code>; we jump to the <code>except</code> branch before the <code>x</code> reassignment in the <code>try</code> statement. The <code>else</code> branch is not executed; <code>x</code> continues to have type <code>Literal[1]</code>.</li>
<li>The first <code>try</code> <code>may_raise()</code> call succeeds, but the second one fails with <code>KeyError</code>. Since the expression on the r.h.s. of the reassignment statement fails, <code>x</code> is never reassigned, so we jump to the <code>exception</code> block. The <code>else</code> branch is not executed; <code>x</code> continues to have type <code>Literal[1]</code>.</li>
<li>Both <code>try</code> <code>may_raise()</code> calls succeed; we skip to the <code>else</code> branch and the <code>except</code> branch is not executed. The <code>else</code> branch reassigns <code>x</code> again; the type of <code>x</code> is <code>Literal[3]</code> after we exit the entire <code>try</code>/<code>except</code> handler.</li>
</ol>
<p>This indicates that to get the desired result here, we need to have some special handling for assignments when the assignment is the <em>final</em> statement in a <code>try</code> suite. Either the assignment succeeds and we continue to the <code>else</code> suite, or the assignment does not succeed and we jump to the <code>except</code> suite.</p>
<h3>Concern about <code>KeyboardInterrupt</code>s</h3>
<p>This feels like a massive edge case, but <em>is</em> it possible to jump from a <code>try</code> suite to an <code>except</code> suite <em>even if</em> all statements in the <code>try</code> actually succeed? What if something like this happens?</p>
<pre><code class="language-py">from typing import Literal

def may_raise() -&gt; Literal[2]:
    return 2

x = 1
    
try:
    may_raise()
    x = may_raise()
    # &lt;-- !! KeyboardInterrupt is raised here because the user pressed CTRL+C !!
except:
    pass
else:
    x = 3
    
reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
<p>I don't know if it's even possible for a <code>KeyboardInterrupt</code> to intercept control flow at that point, though. (I think I'd probably have to dig deep into CPython's internals to find out?) And even if it <em>is</em> possible, I think it's probably not worth worrying about? It won't be intuitive for users to infer <code>Literal[1, 2, 3]</code> in these cases because of very obscure edge cases involving <code>KeyboardInterrupt</code> that would never happen in practice.</p>
<h3>Concern about assignment expressions</h3>
<p>Consider this variation:</p>
<pre><code class="language-py">from typing import Literal

def may_raise() -&gt; Literal[2]:
    return 2

def may_also_raise(x: object) -&gt; None: ...

x = 1
    
try:
    may_also_raise(x := may_raise())
except:
    pass
else:
    x = 3
    
reveal_type(x)  # revealed: Literal[1, 2, 3]
</code></pre>
<p>Here we <em>should</em> infer <code>Literal[1, 2, 3]</code>, because it's very possible that the reassignment to <code>x</code> succeeds in the <code>try</code> suite even though the reassignment's enclosing statement fails: the inner expression in the <code>try</code>-block final statement (which reassigns <code>x</code>) is executed before the outer expression in the <code>try</code>-block final statement. So it's not enough to merely consider whether an assignment takes place in the final statement of a <code>try</code> block: assignment expressions require special handling.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2024-12-12 10:42</div>
            <div class="timeline-body"><p>In fact, even for assignments that are created via statements rather than assignment expressions, simply looking at whether the assignment occurs in &quot;the last statement&quot; of the <code>try</code> suite would be too simplistic. In this snippet, the reassignment to <code>x</code> occurs in &quot;the last statement&quot; of the <code>try</code> suite (which is a <code>StmtIf</code> node), but it's clearly possible for us to jump to the <code>except</code> suite after <code>x</code> has been successfully reassigned to <code>2</code>, since other statements occur after the reassignment that are also substatements of &quot;the last statement&quot; of the <code>try</code> suite:</p>
<pre><code class="language-py">def may_raise(): ...

x = 1

try:
    may_raise()
    if True:
        x = 2
        may_raise()
except:
    pass
else:
    x = 3
</code></pre>
<p>We would have to recursively examine whether the assignment takes place in the last statement of the last statement of the last statement of [etc. for however many substatements there are] the <code>try</code> suite.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2024-12-14 01:48</div>
            <div class="timeline-body"><p>Great analysis! I don't think we'd have to do anything recursive, though; it should be sufficient to just check if the assignment statement is the last statement in the body of the current try block.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[red-knot] Control flow modelling error in `try` ... `else`" to "Control flow modelling error in `try` ... `else`" by @MichaReiser on 2025-05-07 15:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">control flow</span> added by @AlexWaygood on 2025-05-10 21:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">runtime semantics</span> added by @AlexWaygood on 2025-05-11 07:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Z post-stable" by @carljm on 2025-11-13 16:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "Z post-stable" by @carljm on 2025-11-18 16:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-11-25 12:20</div>
            <div class="timeline-body"><p>Another case that came up in a real world project (modified here to make it a standalone example):</p>
<pre><code class="language-py">def _(x: int | str):
    if isinstance(x, str):
        try:
            x = int(x)
        except ValueError:
            reveal_type(x)  # can only be `str`, but we infer `str | int`
</code></pre>
<p>(https://play.ty.dev/19d16684-ccb8-41c3-942f-60ce61e090ee)</p>
<p>The only statement that can raise the exception is <code>x = int(x)</code> (either during the call, or theoretically during the assignment), and if that <em>does</em> raise, the type of <code>x</code> should still be <code>str</code>. However, ty infers <code>str | int</code>, because we do not recognize that nothing after <code>x = int(x)</code> could possibly raise the exception.</p>
<p>Pyrefly and pyright infer <code>str</code> here. mypy also infers <code>int | str</code>.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:39:24 UTC
    </footer>
</body>
</html>
