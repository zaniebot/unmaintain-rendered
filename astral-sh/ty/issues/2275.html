<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>allowing `@type_check_only` subclasses of a `@final` class - astral-sh/ty #2275</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>allowing <code>@type_check_only</code> subclasses of a <code>@final</code> class</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2275">#2275</a>
        opened by <a href="https://github.com/jorenham">@jorenham</a>
        on 2025-12-30 12:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/jorenham">@jorenham</a> on 2025-12-30 12:37</div>
            <div class="timeline-body"><p>NumPy's <code>ufunc</code> class is <code>@final</code>, but in order to meaningfully annotate its specializations, we use <code>@type_check_only</code> &quot;phantom&quot; subclasses that override e.g. <code>__call__</code> with tailor-made callable signatures. For example, <code>numpy.add</code> and <code>numpy.strings.isupper</code> are both instances of <code>numpy.ufunc</code>, but their callable signatures are very different.
This is also an issue in scipy-stubs, as there are even more ufuncs in <code>scipy.special</code> than in all of numpy. See for example https://github.com/scipy/scipy-stubs/blob/4b2ee9a7a917ebd8918caf1ab51146ba4898a34b/scipy-stubs/special/_ufuncs.pyi .</p>
<p>Somewhere in between 0.0.5 and 0.0.8, ty started reporting <code>subclass-of-final-class</code> for subclasses of <code>ufunc</code>, regardless of whether these subclasses are <code>@type_check_only</code>. But as far as I can tell, this cannot lead to any problems at runtime, so I don't think there's any utility in reporting this error in situations like this. Thoughts?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "allow `@type_check_only` subclass of `@final` class" to "allowing `@type_check_only` subclasses of a `@final` class" by @jorenham on 2025-12-30 12:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-30 13:21</div>
            <div class="timeline-body"><p>I'm not sure we should do this. <code>@final</code> doesn't just signify to the user that you'll get a runtime error if you actually try to subclass that type. It also signifies to the type checker that they are &quot;permitted&quot; to make certain assumptions, simplifications, and optimisations that they cannot otherwise make. ty's special handling of <code>@final</code> classes permeates our whole architecture at this point. Here's a demo of some of the many ways in which we treat <code>@final</code> classes differently to other classes:</p>
<pre><code class="language-py">from typing import final

@final
class A: ...
@final
class A2: ...
@final
class A3: ...

class B: ...
class C: ...
class D: ...

def f(t1: C, t2: type[B], t3: type[A], union1: A | A2 | A3, union2: B | C | D):
    if isinstance(t1, B):
        reveal_type(t1)  # C &amp; B (a class could multiple-inherit from both)

    if isinstance(t1, A):
        reveal_type(t1)  # Never (no class could exist that simultaneously inherits from both)

    reveal_type(t2)  # type[B] (could be any subclass of B)
    reveal_type(t3)  # &lt;class 'A'&gt; (must be the class object `A` exactly, not a subclass)
    
    if isinstance(union1, A):
        reveal_type(union1)  # A
    elif isinstance(union1, A2):
        reveal_type(union1)  # A2
    else:
        reveal_type(union1)  # A3
    
    if isinstance(union2, B):
        reveal_type(union2)  # B
    elif isinstance(union2, C):
        reveal_type(union2)  # C &amp; ~B  (any subtype of `C`, except for the possible
                             #          subtypes that overlap with `B`, as those must
                             #          have been excluded by the previous `if` check
    else:
        reveal_type(union2)  # D &amp; ~B &amp; ~C
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-30 13:29</div>
            <div class="timeline-body"><p>@jorenham, do any other type checkers accept these <code>@type_check_only</code> subclasses?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jorenham">@jorenham</a> on 2025-12-30 13:30</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/jorenham">@jorenham</a>, do any other type checkers accept these <code>@type_check_only</code> subclasses?</p>
</blockquote>
<p>Pyrefly is the only one that doesn't complain, but that might just be a missing feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2025-12-30 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/jorenham">@jorenham</a> on 2025-12-30 13:33</div>
            <div class="timeline-body"><p>But yea, this probably isn't wise to do then... It's too bad that there are no (official) intersection types, or a runtime-only <code>@final</code> or something. I guess I'll stick to <code># ty:ignore</code>-ing them then for now, for the lack of a better alternative.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:41:57 UTC
    </footer>
</body>
</html>
