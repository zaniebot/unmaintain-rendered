<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`TYPE_CHECKING` constraints should apply to basic blocks, not scopes - astral-sh/ty #1553</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>`TYPE_CHECKING` constraints should apply to basic blocks, not scopes</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1553">#1553</a>
        opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a>
        on 2025-11-14 13:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-11-14 13:33</div>
            <div class="timeline-body"><p>We currently track whether an entire scope is enclosed inside an <code>if TYPE_CHECKING</code> block. But there are certain semantics that it would be useful to apply to <code>TYPE_CHECKING</code> blocks where tracking this at the scope level is not sufficiently fine-grained. For example, if your code supports Python 3.9, we allow this type alias (it doesn't really matter that it uses the PEP-604 syntax, since it will never be executed at runtime, and the intent is clear):</p>
<pre><code class="language-py">import typing

if typing.TYPE_CHECKING:
    class Foo:
        X = int | str
</code></pre>
<p>but we don't support this type alias, which is something a user is much more likely to write:</p>
<pre><code class="language-py">import typing

if typing.TYPE_CHECKING:
    X = int | str
</code></pre>
<p>Another case where this would be useful is <code>@type_check_only</code>. Currently we always put symbols marked as <code>@type_check_only</code> at the bottom of autocompletion suggestions, since they're not available at runtime. But this is suboptimal: ideally we wouldn't include them in the list of suggestions at all if we're outside a <code>TYPE_CHECKING</code> block (or maybe we'd keep them at the bottom of the list of suggestions), but we wouldn't apply any downranking for these symbols if the user's cursor is inside a <code>TYPE_CHECKING</code> block, e.g.</p>
<pre><code class="language-py">if TYPE_CHECKING:
    # we could freely suggest typeshed's `_SupportsSynchronousAnext` protocol here, for example
    `_SupportsS&lt;CURSOR&gt;
</code></pre>
<p>We could also freely suggest modules inside <code>TYPE_CHECKING</code> blocks that we know not to exist at runtime, such as the <code>_typeshed</code> module (which contains some very useful types!):</p>
<pre><code class="language-py">if TYPE_CHECKING:
    from _typesh&lt;CURSOR&gt;
</code></pre>
<p>Ruff also has a number of linter rules that require a fine-grained analysis of which basic blocks are inside <code>if TYPE_CHECKING</code> conditions. If we ever want to reimplement these rules using ty's semantic model, we will need to replicate this fine-grained understanding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">typing semantics</span> added by @AlexWaygood on 2025-11-14 13:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Z post-stable" by @carljm on 2025-11-14 17:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "Z post-stable" by @carljm on 2025-11-18 16:10</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:41 UTC
    </footer>
</body>
</html>
