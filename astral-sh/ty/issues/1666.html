<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplification of unions involving type variables - astral-sh/ty #1666</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Simplification of unions involving type variables</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1666">#1666</a>
        opened by <a href="https://github.com/sharkdp">@sharkdp</a>
        on 2025-11-28 14:13
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-11-28 14:13</div>
            <div class="timeline-body"><p>Consider the following example:</p>
<pre><code class="language-py">from typing import TypeVar, Any

type IntOr[T: int] = int | T

def _(x: IntOr[Any]):
    reveal_type(x)
</code></pre>
<p>https://play.ty.dev/b378c2a3-d007-428d-8d59-a3a69f5614c0</p>
<p>ty reveals <code>int</code> here, but every other type checker reveals <code>int | Any</code>, which seems more reasonable? ty eagerly simplifies the <code>int | T</code> union to <code>int</code>, which is correct for every static <code>T &lt;: int</code>... but leads to surprising results when <code>T</code> is explicitly specialized to a dynamic type.</p>
<p>This was prompted by a much more complex example in numpy's codebase:</p>
<pre><code class="language-py">class _SupportsDType(Protocol[_DTypeT_co]):
    @property
    def dtype(self) -&gt; _DTypeT_co: ...

_DTypeLike = type[_ScalarT] | _SupportsDType[dtype[_ScalarT]]
</code></pre>
<p><code>_ScalarT</code> has an upper bound of <code>np.generic</code> (= <code>np.generic[Any]</code>). And <code>np.generic[…]</code> does have a <code>dtype</code> property member. This currently leads us to treat <code>type[_Scalar]</code> as a subtype of <code>_SupportsDType[…]</code>, and so that union gets simplified to <code>_SupportsDType[dtype[_ScalarT]]</code>. Later, <code>_DTypeLike</code> is explicitly specialized with <code>_DTypeLike[Any]</code>, and it is expected that <code>&lt;class 'object'&gt;</code> should be assignable to <code>_DTypeLike[Any]</code> (which would be the case if <code>type[Any]</code> were still part of the union.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @sharkdp on 2025-11-28 14:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type properties</span> added by @sharkdp on 2025-11-28 14:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @carljm on 2025-12-02 03:05</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-12-02 03:05</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-02 03:07</div>
            <div class="timeline-body"><p>Yes, it seems to me we probably need to account for the possibility of specialization to a dynamic type, and avoid doing this kind of simplification. Which would be achieved by considering <code>T: int</code> to be assignable-to, but not subtype-of or redundant-with, <code>int</code> (or <code>object</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-10 21:50</div>
            <div class="timeline-body"><blockquote>
<p>Which would be achieved by considering <code>T: int</code> to be assignable-to, but not subtype-of or redundant-with, <code>int</code> (or <code>object</code>).</p>
</blockquote>
<p>As discussed in https://github.com/astral-sh/ty/issues/1846#issuecomment-3639019092, I agree that we probably shouldn't automatically treat <code>TypeVar</code>s as subtypes of (or redundant with) their upper bound. But I do think that we should continue to see all <code>TypeVar</code>s as subtypes of (and redundant with) <code>object</code>, because <em>all</em> types (even <code>Any</code>!) are subtypes of <code>object</code>. So accounting for the possibility that a <code>TypeVar</code> might be solved to <code>Any</code> is immaterial there.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:46 UTC
    </footer>
</body>
</html>
