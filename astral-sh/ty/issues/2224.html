<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inference failure: PEP 695 recursive type aliases resolve to 'Unknown' - astral-sh/ty #2224</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Inference failure: PEP 695 recursive type aliases resolve to &#x27;Unknown&#x27;</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2224">#2224</a>
        opened by <a href="https://github.com/Blinkion">@Blinkion</a>
        on 2025-12-26 02:51
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Blinkion">@Blinkion</a></div>
            <div class="timeline-body"><p>Summary
ty (v0.0.7) currently fails to resolve recursive type aliases defined using the PEP 695 type statement (introduced in Python 3.12). While the syntax is parsed without errors, the inference engine cannot resolve the recursive structure, leading to Unknown types in Inlay Hints and breaking downstream type safety.</p>
<p>Reproduction</p>
<pre><code>from __future__ import annotations

# Standard PEP 695 recursive type alias
type JSONValue = (
    dict[str, JSONValue] | list[JSONValue] | str | int | float | bool | None
)

# Observed inference failure
test_data = {&quot;a&quot;: {&quot;b&quot;: 1}}
</code></pre>
<p>Actual Behavior
The Inlay Hint for test_data displays: dict[Unknown | str, Unknown | dict[Unknown | str, Unknown | int]]</p>
<p>It seems the inference engine treats the recursive reference JSONValue within the definition as an unknown or unresolved type during the mapping phase.</p>
<p>Expected Behavior
ty should correctly resolve the recursive alias. The Inlay Hint should ideally show JSONValue or its concrete expansion without any Unknown segments.</p>
<p>Environment
ty version: 0.0.7 (cf82a04b5 2025-12-24)</p>
<p>Python version: 3.14.2 (using PEP 695 syntax)</p>
<p>OS: macOS</p>
<p>Additional Context
Using the older JSONValue: TypeAlias = ... or string forward references results in similar Unknown inference or unresolved-reference errors.</p>
<p>This breakdown of type inference renders the static analysis ineffective for deeply nested data structures (like JSON).</p>
<p><img alt="Image" src="https://github.com/user-attachments/assets/df16ef74-1d0e-4ac6-bdab-b6122a424b3c"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Inference failure for recursive types (JSONValue) using string forward references&quot; to &quot;Inference failure: PEP 695 recursive type aliases resolve to &#x27;Unknown&#x27;&quot; by <a href="https://github.com/Blinkion">@Blinkion</a> on 2025-12-26 03:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bidirectional inference</span> added by <a href="https://github.com/mtshiba">@mtshiba</a> on 2025-12-26 03:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-26 17:40</div>
            <div class="timeline-body"><p>In your code sample, the type alias <code>JSONValue</code> is unused. The inference you see for the type of <code>test_data</code> is not related to a recursive type alias at all, it&#x27;s just our normal inference for un-annotated invariant container literals -- the <code>Unknown</code> are to avoid false positives if you didn&#x27;t intend this dict to be limited to string keys and dictionary values. See #1240 where we plan to provide an option to disable this behavior.</p>
<p>If you change your code example as follows, to use the <code>JSONValue</code> type:</p>
<pre><code>from __future__ import annotations

type JSONValue = (
    dict[str, JSONValue] | list[JSONValue] | str | int | float | bool | None
)

test_data: JSONValue = {&quot;a&quot;: {&quot;b&quot;: 1}}
reveal_type(test_data) 
</code></pre>
<p>this reveals a real issue, where we choose to still infer <code>test_data</code> as the &quot;narrower&quot; inferred dictionary type, rather than as <code>JSONValue</code>. This will be fixed by #136.</p>
<p>We do understand the recursive nature of a PEP 695 recursive type alias, as shown in this example:</p>
<pre><code>from __future__ import annotations

type JSONValue = (
    dict[str, JSONValue] | list[JSONValue] | str | int | float | bool | None
)

def f(jsonval: JSONValue):
    reveal_type(jsonval)
    if isinstance(jsonval, dict):
        reveal_type(jsonval)
        reveal_type(jsonval[&quot;foo&quot;])
</code></pre>
<p>Though at a certain point we do currently still fall back to <code>Any</code> at the point of recursion -- this is a known limitation tracked in #1157.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2025-12-26 17:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bidirectional inference</span> removed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-26 18:36</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:46 UTC
    </footer>
</body>
</html>
