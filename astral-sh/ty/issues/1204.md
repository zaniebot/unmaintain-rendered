```yaml
number: 1204
title: "`ABC.register` not recognized on `collections.abc.Mapping`"
type: issue
state: open
author: gerlero
labels:
  - Protocols
assignees: []
created_at: 2025-09-18T16:09:21Z
updated_at: 2026-01-09T00:56:52Z
url: https://github.com/astral-sh/ty/issues/1204
synced_at: 2026-01-10T01:56:40Z
```

# `ABC.register` not recognized on `collections.abc.Mapping`

---

_Issue opened by @gerlero on 2025-09-18 16:09_

### Summary

When using `Mapping.register(...)` to register a virtual subclass, `ty` reports an `unresolved-attribute` error on `register`.

**Code to reproduce:**

```python
from collections.abc import Mapping

class MyClass:
    pass

Mapping.register(MyClass)
```

**Error output:**

```
error[unresolved-attribute]: Type `<class 'Mapping'>` has no attribute `register`
 --> test.py:6:1
  |
4 |     pass
5 |
6 | Mapping.register(MyClass)
  | ^^^^^^^^^^^^^^^^
  |
info: rule `unresolved-attribute` is enabled by default
```
**Notes:**

This suggests to me that `ty` isnâ€™t accounting for the fact that `collections.abc` classes are subclasses of `ABC`.


### Version

ty 0.0.1-alpha.20

---

_Comment by @carljm on 2025-09-18 17:07_

Thanks for the report!

Pyright and pyrefly both emit the same error as ty here, but mypy does not.

Looking at [the typeshed definition](https://github.com/python/typeshed/blob/main/stdlib/typing.pyi#L764) of `Mapping` vs [the runtime definition](https://github.com/python/cpython/blob/main/Lib/_collections_abc.py#L775), if you follow the inheritance tree, the typeshed definition ends up not inheriting from anything defined with a metaclass of `ABCMeta`, whereas the runtime definition does inherit from `Sized` and `Container`, which have the `ABCMeta` metaclass. (`Container` has the same issue itself -- at runtime it has `ABCMeta`, but not in typeshed.)

For e.g. `Sized` or any other type that actually is defined in typeshed as having the `ABCMeta` metaclass, we [do recognize the `register` method](https://play.ty.dev/f609edb2-3ffe-4c5f-a30d-0631a7206e3a).

So this seems like a typeshed bug; mypy must be doing some kind of special-casing to work around it. Maybe we should, too? Or maybe it should be fixed in typeshed?

This seems like an issue @AlexWaygood might have additional context on?

---

_Comment by @AlexWaygood on 2025-09-18 17:14_

> So this seems like a typeshed bug; mypy must be doing some kind of special-casing to work around it. Maybe we should, too? Or maybe it should be fixed in typeshed?
> 
> This seems like an issue [@AlexWaygood](https://github.com/AlexWaygood) might have additional context on?

I think the special-casing mypy does is that mypy is aware that all protocols implicitly have `_ProtocolMeta` as their metaclass, and `_ProtocolMeta` is a subclass of `ABCMeta`. This means that any class that has `Protocol` in its MRO has `_ProtocolMeta` as its metaclass, and therefore has a `register` method available on the class:

```pycon
>>> from typing import Protocol
>>> type(Protocol)
<class 'typing._ProtocolMeta'>
>>> _.__mro__
(<class 'typing._ProtocolMeta'>, <class 'abc.ABCMeta'>, <class 'type'>, <class 'object'>)
>>> Protocol.register
<bound method ABCMeta.register of <class 'typing.Protocol'>>
```

We should probably implement similar special casing, since it's certainly true that a protocol class (or a subclass of a protocol class) does not need to explicitly declare `metaclass=ABCMeta` in order for it to have a `register` method available on the class. Once we implement this special casing, we will recognise `Mapping.register()` as existing, since -- according to typeshed -- `Mapping` has `Protocol` in its MRO.

---

_Comment by @carljm on 2025-09-18 17:26_

Right, so the special-casing comes back to typeshed defining `Protocol` itself as just `Protocol: _SpecialForm`, and giving no details about what `Protocol` actually looks like at runtime. So type-checkers need to replicate via hard-coding all the relevant runtime effects of inheriting `Protocol`. Thanks!

---

_Comment by @AlexWaygood on 2025-09-18 17:46_

> Right, so the special-casing comes back to typeshed defining `Protocol` itself as just `Protocol: _SpecialForm`, and giving no details about what `Protocol` actually looks like at runtime. So type-checkers need to replicate via hard-coding all the relevant runtime effects of inheriting `Protocol`. Thanks!

Indeed! Which is one of those things that I'd theoretically be very open to changing in typeshed, but which in practice I suspect would be pretty hard to change because of the fact that most type checkers (including us) now have hard-coded logic for recognising `Protocol` with its current typeshed definition :/

---

_Label `Protocols` added by @AlexWaygood on 2025-09-22 12:50_

---

_Added to milestone `Stable` by @carljm on 2026-01-09 00:56_

---
