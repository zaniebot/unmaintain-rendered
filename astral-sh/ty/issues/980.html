<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ty wrongly respects `dataclasses.field` as a field specifier for a custom `dataclass_transform` - astral-sh/ty #980</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ty wrongly respects `dataclasses.field` as a field specifier for a custom `dataclass_transform`</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/980">#980</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-08-13 23:15
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/carljm">@carljm</a> on 2025-08-13 23:15</div>
            <div class="timeline-body"><p>In this example code:</p>
<pre><code class="language-py">from typing import dataclass_transform
from dataclasses import field, dataclass

@dataclass_transform()
def create_model(*, init: bool = True):
    def deco[T](cls: T) -&gt; T:
        return cls
    return deco

@create_model()
class A:
    name: str = field(init=False)
   
reveal_type(A(name=&quot;foo&quot;).name) 

@dataclass
class B:
    name: str = field(init=False)

reveal_type(B(name=&quot;foo&quot;).name)
</code></pre>
<p>We have a custom dataclass transform, and one class created using it, and another class created using regular <code>dataclass</code> decorator. Both classes use <code>dataclasses.field</code> to specify a field.</p>
<p>The <a href="https://typing.python.org/en/latest/spec/dataclasses.html#dataclass-transform-parameters">typing spec</a> says this about the <code>field_specifiers</code> argument to <code>dataclass_transform</code>:</p>
<blockquote>
<p>If not specified, field_specifiers will default to an empty tuple (no field specifiers supported). The standard dataclass behavior supports only one type of field specifier called Field plus a helper function (field) that instantiates this class, so if we were describing the stdlib dataclass behavior, we would provide the tuple argument (dataclasses.Field, dataclasses.field)</p>
</blockquote>
<p>This pretty clearly means that <code>dataclasses.Field</code> and <code>dataclasses.field</code> should <em>not</em> be accepted by default as field specifiers for a custom dataclass transform that doesn't list them explicitly in <code>field_specifiers</code>.</p>
<p>Mypy/pyright/pyrefly all implement this, with the result that in the above code, the call <code>A(name=&quot;foo&quot;)</code> is not an error, since <code>field</code> is not a field specifier for <code>create_model</code>, therefore <code>init=False</code> is ignored there. Only <code>B(name=&quot;foo&quot;)</code> is an error.</p>
<p>In ty, we currently wrongly respect <code>dataclasses.field</code> as a field specifier for <code>create_model</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">dataclasses</span> added by @carljm on 2025-08-13 23:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/leandrobbraga">@leandrobbraga</a> on 2025-08-15 00:19</div>
            <div class="timeline-body"><p>Indeed <code>mypy</code> check this code as valid and <code>ty</code> does not, but I'm getting a runtime error trying to run the code you provided, which matches <code>ty</code> error:</p>
<p><code>t.py</code></p>
<pre><code>from dataclasses import field
from typing import dataclass_transform


@dataclass_transform()
def create_model(*, init: bool = True):
    def deco[T](cls: T) -&gt; T:
        return cls

    return deco


@create_model()
class A:
    name: str = field(init=False)


print(A(name=&quot;foo&quot;).name)
</code></pre>
<pre><code class="language-console">uv run teste.py
Traceback (most recent call last):
    A(name=&quot;foo&quot;).name
    ~^^^^^^^^^^^^
TypeError: A() takes no arguments
&gt; uv run python --version
Python 3.13.5
</code></pre>
<p>Am I missing something?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 00:39</div>
            <div class="timeline-body"><p>That's because <code>create_model</code> in the example claims it is a <code>dataclass_transform</code> but doesn't actually transform anything. The example assumes that a real implementation of <code>create_model</code> would actually synthesize an <code>__init__</code> method for the given class, like dataclasses does. In other words, this example shows a buggy/wrong implementation of <code>create_model</code>. That's fine for the example, because type checkers don't verify the internal implementation of a <code>dataclass_transform</code>, they just trust it, and this example is just meant to test the type checker behavior. But it does mean you can't usefully check this example against its runtime behavior.</p>
<p>Ty is wrongly erroring because it is respecting the <code>field(init=False)</code> (even though it shouldn't, since <code>create_model</code> doesn't have a <code>field_specifiers</code>). The runtime error is for a totally different reason, because no <code>__init__</code> method is created at all by this buggy <code>create_model</code> implementation.</p>
<p>If a real implementation of <code>create_model</code> would actually respect options passed to <code>dataclasses.field</code>, then it should list <code>dataclasses.field</code> in its <code>field_specifiers</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/leandrobbraga">@leandrobbraga</a> on 2025-08-15 02:55</div>
            <div class="timeline-body"><p>I was giving a shot at it and would like an advise to how to implement it.</p>
<p>For now I'm doing the following:</p>
<p>First, in <a href="https://github.com/astral-sh/ruff/blob/main/crates/ty_python_semantic/src/types/call/bind.rs#L897-L924">bind.rs</a> I check weather the <code>field_specifier</code> is some, if it is I add a <code>field_specifier</code> bit in the <code>DataclassTransformerParams</code> bitflags. The idea is to identify whenever this value is the default empty tuple value or there are some value here, I'm not parsing the exact values for now, I only care if it's the empty tuple.</p>
<pre><code class="language-rust">Some(KnownFunction::DataclassTransform) =&gt; {
    if let [
        eq_default,
        order_default,
        kw_only_default,
        frozen_default,
        field_specifiers,
        _kwargs,
    ] = overload.parameter_types()
    {
        let mut params = DataclassTransformerParams::empty();

        if to_bool(eq_default, true) {
            params |= DataclassTransformerParams::EQ_DEFAULT;
        }
        if to_bool(order_default, false) {
            params |= DataclassTransformerParams::ORDER_DEFAULT;
        }
        if to_bool(kw_only_default, false) {
            params |= DataclassTransformerParams::KW_ONLY_DEFAULT;
        }
        if to_bool(frozen_default, false) {
            params |= DataclassTransformerParams::FROZEN_DEFAULT;
        }

        if let Some(field_specifiers_type) = field_specifiers {
            // For now, we'll do a simple check: if field_specifiers is not
            // None/empty, we assume it might contain dataclasses.field
            // TODO: Implement proper parsing to check for
            //   dataclasses.field/Field specifically
            if !field_specifiers_type.is_none(db) {
                params |= DataclassTransformerParams::FIELD_SPECIFIERS;
            }
            // If field_specifiers is None or empty tuple, don't set the
            // flag (default behavior)
        }

        overload.set_return_type(Type::DataclassTransformer(params));
    }
}
</code></pre>
<p>Now we need to somehow ignore the <code>Field</code> in <a href="https://github.com/astral-sh/ruff/blob/main/crates/ty_python_semantic/src/types/class.rs#L2345-L2349">here</a>.</p>
<pre><code class="language-rust">if let Some(Type::KnownInstance(KnownInstanceType::Field(field))) = default_ty {
    init = field.init(db);
    kw_only = field.kw_only(db);
}
</code></pre>
<p>The only way that I found to communicate the flag <code>DataclassTransformerParams::FIELD_SPECIFIERS</code> flag was to create a new flag in the <a href="https://github.com/astral-sh/ruff/blob/main/crates/ty_python_semantic/src/types.rs#L477-L522">DataclassParams</a> to convey this meaning. But this is very unsatisfying, since <code>@dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)</code> does not contain such flag.</p>
<pre><code class="language-rust">bitflags! {
    /// Used for the return type of `dataclass(â€¦)` calls. Keeps track of the arguments
    /// that were passed in. For the precise meaning of the fields, see [1].
    ///
    /// [1]: https://docs.python.org/3/library/dataclasses.html
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub struct DataclassParams: u16 {
        const INIT = 0b0000_0000_0001;
        const REPR = 0b0000_0000_0010;
        const EQ = 0b0000_0000_0100;
        const ORDER = 0b0000_0000_1000;
        const UNSAFE_HASH = 0b0000_0001_0000;
        const FROZEN = 0b0000_0010_0000;
        const MATCH_ARGS = 0b0000_0100_0000;
        const KW_ONLY = 0b0000_1000_0000;
        const SLOTS = 0b0001_0000_0000;
        const WEAKREF_SLOT = 0b0010_0000_0000;
    }
}
</code></pre>
<p>Do you have any idea on how to implement this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-15 19:19</div>
            <div class="timeline-body"><p>I think it is fine to have <code>DataclassParams</code> also track some things from <code>DataclassTransformerParams</code> which are not actually overridable in the individual decorator-factory call. (We should have comments to clarify which is which, though.) The alternative would be to have the <code>DataclassDecorator</code> type actually track the origin <code>DataClassTransformerParams</code>, but that doesn't seem necessarily better?</p>
<p>@sharkdp wrote our dataclasses implementation, and he is returning from vacation next week, so if you don't reach a satisfactory approach by then, he may have thoughts as well.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/leandrobbraga">@leandrobbraga</a> on 2025-08-15 20:47</div>
            <div class="timeline-body"><p>Ok, can you assign this to me? I'm out until Wednesday, but I already have a working version in my computer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @leandrobbraga by @carljm on 2025-08-15 20:48</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-08-19 08:21</div>
            <div class="timeline-body"><p>Adding additional flags to <code>DataclassParams</code> seems fine to me, but if I understand correctly, this would just be a temporary solution to fix this bug? Eventually, we'd have to keep track of the static list of classes that describe fields, right? And once we do, is there still a need for that flag?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-19 16:09</div>
            <div class="timeline-body"><p>My interpretation is that in the future the field will change from a boolean flag to a list of classes/functions, but I think the underlying issue will remain the same either way: sometimes handling of a specific field in a dataclass needs access to information defined in the original dataclass-transform definition, and we currently don't thread that through. The options for threading it through will either be to copy some fields from <code>DataclassTransformerParams</code> to <code>DataclassParams</code> at each usage of that particular dataclass-transform, or to otherwise thread through the <code>DataclassTransformerParams</code> itself.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-08-20 18:33</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:22 UTC
    </footer>
</body>
</html>
