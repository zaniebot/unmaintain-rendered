<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Support single-file scripts with PEP 723 metadata - astral-sh/ty #691</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Support single-file scripts with PEP 723 metadata</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/691">#691</a>
        opened by <a href="https://github.com/thoughtpolice">@thoughtpolice</a>
        on 2025-06-22 21:47
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/thoughtpolice">@thoughtpolice</a></div>
            <div class="timeline-body"><p>I looked a bit through the bug tracker but didn&#x27;t see this: I have a few projects that I develop with <code>uv run --script</code>, along with PEP 723 inline metadata for my dependencies. I find this is really nice for simple scripts in my monorepo:</p>
<pre><code>#!/usr/bin/env -S uv run --script
# /// script
# requires-python = &quot;==3.12.*&quot;
# dependencies = [
#     &quot;mlx&gt;=0.26.1&quot;,
#     &quot;mlx-lm&gt;=0.25.2&quot;,
#     &quot;urllib3==1.26.6&quot;,
#     &quot;click&gt;=8.0.0&quot;,
#     &quot;rich&gt;=13.0.0&quot;,
#     &quot;prompt-toolkit&gt;=3.0.0&quot;,
# ]
# ///
...
</code></pre>
<p>However, if I execute <code>uvx ty check foo.py</code> on these files, then the following occurs:</p>
<pre><code>aseipp@navi bizarro % uvx ty check bizarro.py
WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
error[unresolved-import]: Cannot resolve imported module `click`
  --&gt; bizarro.py:31:8
   |
30 | # Third-party imports
31 | import click
   |        ^^^^^
... many more errors follow ...
</code></pre>
<p>I think this can obviously be avoided by using <code>pyproject.toml</code>, but it would be wonderful if ty could also work for this case too. I have a bunch of one-shot scripts like this that I occasionally need to import a library with, so it&#x27;d be nice to not require more project scaffolding. Q: Perhaps it should also require a <code>--script</code> argument to <code>ty check</code> to make it more uniform with <code>uv run</code>?</p>
<blockquote>
<p>P.S. Many thanks for uv/ruff/ty!</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-23 06:03</div>
            <div class="timeline-body"><p>Thank you for your feature request!</p>
<p>The way we intend to solve this is through uv. In fact, there&#x27;s an open feature request for a <a href="https://github.com/astral-sh/uv/issues/6542"><code>--with-requirements script.py</code></a> option (and an <a href="https://github.com/astral-sh/uv/pull/12763">open PR</a>), which would serve this exact use case. So once this is implemented, you could run something like</p>
<pre><code>uvx --with-requirements script.py ty check script.py
</code></pre>
<p>There&#x27;s probably a follow-up question here whether or not there should be a more convenient command for this that would avoid having to repeat the path to the script twice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">cli</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-23 06:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-06-23 06:14</div>
            <div class="timeline-body"><p>A one-liner hack that I use is the following:</p>
<pre><code>uvx ty check script.py --python &quot;$(uv python find --script script.py)&quot;
</code></pre>
<p>I think it requires that you run the script once via <code>uv run script.py</code> in order to create a cached venv.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-23 06:20</div>
            <div class="timeline-body"><blockquote>
<p>The way we intend to solve this is through uv.</p>
</blockquote>
<p>We also plan on exploring a tighter uv integration in the LSP, so that the LSP could automatically setup the venv when opening a script file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">cli</span> removed by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-23 06:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> added by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-06-23 06:20</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/bortels">@bortels</a> on 2025-06-29 02:01</div>
            <div class="timeline-body"><p>I am not sure if this qualifies as part of this wish, or as a separate issue.</p>
<p>When you try to run ty against a single file script that does not end in .py (ie. the scripts in my ~/bin directory) - it says:</p>
<p>WARN No python files found under the given path(s)
All checks passed!</p>
<p>If I add a .py extension, it&#x27;s happy. I can fix this with a symlink of &quot;scriptname.py&quot; to &quot;scriptname&quot;, but that makes me sad.</p>
<p>I also note it does this with a shebang line of &quot;#!/bin/env python3&quot; - so it&#x27;s not the shebang, it&#x27;s the extension.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/PetterS">@PetterS</a> on 2025-09-13 16:53</div>
            <div class="timeline-body"><blockquote>
<p>A one-liner hack that I use is the following:</p>
<p>uvx ty check script.py --python &quot;$(uv python find --script script.py)/../..&quot;
I think it requires that you run the script once via <code>uv run script.py</code> in order to create a cached venv.</p>
</blockquote>
<p>That seems to work pretty well! But why the <code>../..</code>? It works for me without (i.e. ty seems to accept being passed a python binary)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-09-15 07:47</div>
            <div class="timeline-body"><blockquote>
<p>But why the <code>../..</code>? It works for me without (i.e. ty seems to accept being passed a python binary)</p>
</blockquote>
<p>You&#x27;re right. This may have been fixed in <a href="https://github.com/astral-sh/ruff/pull/18827">astral-sh/ruff#18827</a>, which was merged around the same time that I wrote my comment. Will update the comment to include your suggestion. Hopefully, we can soon use <code>uvx --with-requirements script.py ty check script.py</code> instead of this workaround. See <a href="https://github.com/astral-sh/ty/issues/989">astral-sh/ty#989</a>#issuecomment-3265190699.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Janno">@Janno</a> on 2025-11-05 12:27</div>
            <div class="timeline-body"><blockquote>
<p>The way we intend to solve this is through uv. In fact, there&#x27;s an open feature request for a <a href="https://github.com/astral-sh/uv/issues/6542"><code>--with-requirements script.py</code></a> option (and an <a href="https://github.com/astral-sh/uv/pull/12763">open PR</a>), which would serve this exact use case. So once this is implemented, you could run something like [..]</p>
</blockquote>
<p>AFAICT  the <code>uv</code> feature is now implemented but your code example does not work for me. <code>uvx</code> happily installs the dependencies but <code>ty</code> seems to be oblivious about that. Is there extra work needed in <code>ty</code> to make this work?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-05 12:34</div>
            <div class="timeline-body"><p>@Janno this is related to <a href="https://github.com/astral-sh/ty/issues/989">astral-sh/ty#989</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">wish</span> removed by <a href="https://github.com/carljm">@carljm</a> on 2025-11-13 00:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;Stable&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-11-13 00:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-11-13 09:00</div>
            <div class="timeline-body"><blockquote>
<p>The way we intend to solve this is through uv. In fact, there&#x27;s an open feature request for a <a href="https://github.com/astral-sh/uv/issues/6542"><code>--with-requirements script.py</code></a> option (and an <a href="https://github.com/astral-sh/uv/pull/12763">open PR</a>), which would serve this exact use case. So once this is implemented, you could run something like</p>
<pre><code>uvx --with-requirements script.py ty check script.py
</code></pre>
</blockquote>
<p>With recent changes in ty and uv, this is working now.</p>
<p>One thing I&#x27;ve noticed is that we do not seem to make use of the <code>requires-python</code> constraint from the inline metadata in the script. For example, when running the following command from inside the ruff repository (which has a <code>pyproject.toml</code> with a <code>requires-python</code> of 3.7), I get:</p>
<p><code>test.py</code></p>
<pre><code># /// script
# requires-python = &quot;&gt;=3.14&quot;
# dependencies = [
#     &quot;httpx&quot;,
# ]
# ///
from typing_extensions import reveal_type
import httpx
import sys

r = httpx.get(&quot;https://www.example.org/&quot;)
reveal_type(r)

reveal_type(sys.version_info[:2])
</code></pre>
<pre><code>‚ñ∂ uvx --with-requirements test.py ty check test.py
info[revealed-type]: Revealed type
  --&gt; test.py:12:13
   |
11 | r = httpx.get(&quot;https://www.example.org/&quot;)
12 | reveal_type(r)
   |             ^ `Response`
13 |
14 | reveal_type(sys.version_info[:2])
   |

info[revealed-type]: Revealed type
  --&gt; test.py:14:13
   |
12 | reveal_type(r)
13 |
14 | reveal_type(sys.version_info[:2])
   |             ^^^^^^^^^^^^^^^^^^^^ `tuple[Literal[3], Literal[7]]`
   |

Found 2 diagnostics
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-13 09:11</div>
            <div class="timeline-body"><blockquote>
<p>One thing I&#x27;ve noticed is that we do not seem to make use of the requires-python constraint from the inline metadata in the script. For example, when running the following command from inside the ruff repository (which has a pyproject.toml with a requires-python of 3.7), I get:</p>
</blockquote>
<p>That makes sense to me. ty only looks at <code>ty.toml</code> and <code>pyproject.toml</code> files but not any inline script metadata. I&#x27;m not yet sure if we want a <code>ty check --script test.py</code> or if we should always try to read the metadata or if ty should try to read the metadata if a single file was specified.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/Gankra">@Gankra</a> by <a href="https://github.com/Gankra">@Gankra</a> on 2025-11-13 16:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2025-11-13 16:34</div>
            <div class="timeline-body"><p>I think we should always read the metadata, we need to do so in the LSP context.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-13 16:37</div>
            <div class="timeline-body"><blockquote>
<p>I think we should always read the metadata, we need to do so in the LSP context.</p>
</blockquote>
<p>I don&#x27;t think we can? Like, if you&#x27;re checking an entire project, respecting the script metadata would require a separate db instance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-11-13 16:47</div>
            <div class="timeline-body"><p>I think the ideal experience in an LSP is that when you open a PEP 723 script, it gets checked independently from everything else, using its own inline metadata. This should be no different from opening files from multiple projects at once in the editor?</p>
<p>Not sure what the CLI experience should be if you check a project that has PEP 723 scripts inside it -- we might need to just notify you that they have to be checked separately? Or maybe we really do need to at some point build &quot;multiple db instances in a single CLI run&quot; feature, even if its just via subprocesses or something...</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2025-11-13 16:57</div>
            <div class="timeline-body"><blockquote>
<p>I don&#x27;t think we can? Like, if you&#x27;re checking an entire project, respecting the script metadata would require a separate db instance.</p>
</blockquote>
<p>Yes, I am roughly picturing a workflow like:</p>
<ul>
<li>detect this is a PEP 723 script by finding the metadata at all (easy)</li>
<li>detect that they have uv installed</li>
<li>ask uv to ensure the script has a venv and to give us a path to it</li>
<li>two paths:<ul>
<li>parse the metadata ourselves for the info we need (would let us analyze scripts partially, or fully for non-dep-having ones)</li>
<li>have uv report the metadata to us (we need it to setup the script&#x27;s private venv anyway)</li>
</ul>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2025-11-13 16:58</div>
            <div class="timeline-body"><p>This is to say, the script is already very much so &quot;in a separate workspace&quot;, and should be treated as such.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-11-13 17:15</div>
            <div class="timeline-body"><p>Agree, that we should pick up the script metadata in the LSP</p>
<blockquote>
<p>Not sure what the CLI experience should be if you check a project that has PEP 723 scripts inside it -- we might need to just notify you that they have to be checked separately? Or maybe we really do need to at some point build &quot;multiple db instances in a single CLI run&quot; feature, even if its just via subprocesses or something...</p>
</blockquote>
<p>What we discussed originally is that they&#x27;re checked with the same configuration and that users would exclude it if they shouldn&#x27;t be part of the ty project.</p>
<p>Either way, I think a first step is to make scripts work when you pass a single file or in the LSP.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jay-Madden">@Jay-Madden</a> on 2025-12-01 21:21</div>
            <div class="timeline-body"><p>Very much looking forward to this for neovim integration</p>
<p>For now i have just disabled the lspconfig version of ty and instead am using this to support single file scripts.</p>
<pre><code>    vim.api.nvim_create_autocmd(&quot;FileType&quot;, {
      pattern = &quot;python&quot;,
      callback = function(_)
        local first_line = vim.api.nvim_buf_get_lines(0, 0, 1, false)[1] or &quot;&quot;
        local has_inline_metadata = first_line:match(&quot;^# /// script&quot;)

        local cmd, name, root_dir
        if has_inline_metadata then
          local filepath = vim.fn.expand(&quot;%:p&quot;)
          local filename = vim.fn.fnamemodify(filepath, &quot;:t&quot;)

          -- Set a unique name for the server instance based on the filename
          -- so we get a new client for new scripts
          name = &quot;ty-&quot; .. filename

          local relpath = vim.fn.fnamemodify(filepath, &quot;:.&quot;)

          cmd = { &quot;uvx&quot;, &quot;--with-requirements&quot;, relpath, &quot;ty&quot;, &quot;server&quot; }
          root_dir = vim.fn.fnamemodify(filepath, &quot;:h&quot;)
        else
          name = &quot;ty&quot;
          cmd = { &quot;ty&quot;, &quot;server&quot; }
          root_dir = vim.fs.root(0, { &#x27;ty.toml&#x27;, &#x27;pyproject.toml&#x27;, &#x27;setup.py&#x27;, &#x27;setup.cfg&#x27;, &#x27;requirements.txt&#x27;, &#x27;.git&#x27; })
        end

        vim.lsp.start({
          name = name,
          cmd = cmd,
          root_dir = root_dir,
        })
      end,
    })

</code></pre>
<p>Seems to be working so far in my testing, but its far from battle tested so use at your own risk üòÅ</p>
<p>Edit: I have actually ended up using this a lot more than I expected. So I spun it out as a very small plugin for convenience if anyone wants. https://github.com/Jay-Madden/tylsp-pep723.nvim</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/a-alak">@a-alak</a> on 2025-12-29 13:41</div>
            <div class="timeline-body"><blockquote>
<p>Very much looking forward to this for neovim integration</p>
<p>For now i have just disabled the lspconfig version of ty and instead am using this to support single file scripts.</p>
<pre><code>vim.api.nvim_create_autocmd(&quot;FileType&quot;, {
  pattern = &quot;python&quot;,
  callback = function(_)
    local first_line = vim.api.nvim_buf_get_lines(0, 0, 1, false)[1] or &quot;&quot;
    local has_inline_metadata = first_line:match(&quot;^# /// script&quot;)

    local cmd, name, root_dir
    if has_inline_metadata then
      local filepath = vim.fn.expand(&quot;%:p&quot;)
      local filename = vim.fn.fnamemodify(filepath, &quot;:t&quot;)

      -- Set a unique name for the server instance based on the filename
      -- so we get a new client for new scripts
      name = &quot;ty-&quot; .. filename

      local relpath = vim.fn.fnamemodify(filepath, &quot;:.&quot;)

      cmd = { &quot;uvx&quot;, &quot;--with-requirements&quot;, relpath, &quot;ty&quot;, &quot;server&quot; }
      root_dir = vim.fn.fnamemodify(filepath, &quot;:h&quot;)
    else
      name = &quot;ty&quot;
      cmd = { &quot;uvx&quot;, &quot;ty&quot;, &quot;server&quot; }
      root_dir = vim.fs.root(0, { &#x27;ty.toml&#x27;, &#x27;pyproject.toml&#x27;, &#x27;setup.py&#x27;, &#x27;setup.cfg&#x27;, &#x27;requirements.txt&#x27;, &#x27;.git&#x27; })
    end

    vim.lsp.start({
      name = name,
      cmd = cmd,
      root_dir = root_dir,
    })
  end,
})</code></pre>
<p>Seems to be working so far in my testing, but its far from battle tested so use at your own risk üòÅ</p>
</blockquote>
<p>Do you still have vim.lsp.enable(&#x27;ty&#x27;) somewhere else with this or do you completely take over managing the lsp server with this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/max397574">@max397574</a> on 2025-12-29 16:38</div>
            <div class="timeline-body"><p>no need for the lsp.enable with this</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DinoChiesa">@DinoChiesa</a> on 2025-12-30 06:07</div>
            <div class="timeline-body"><p>re: @Gankra <a href="https://github.com/astral-sh/ty/issues/691#issuecomment-3528778986">comment</a></p>
<p>The &quot;workflow&quot; that you describe seems mostly reasonable, but most of that is not done within ty LSP, right?  It&#x27;s done within the client.</p>
<p>| task | responsible actor |
| --- | --- |
| detect this is a PEP 723 script by finding the metadata at all (easy) | editor / client |
| detect that they have uv installed | editor / per-user configuration (maybe they use uv, maybe something else) |
| ask uv to ensure the script has a venv and to give us a path to it | editor / client |
| parse the metadata ourselves for the info we need (would let us analyze scripts partially, or fully for non-dep-having ones) | only uv or similar should parse PEP723 metadata |
| have uv report the metadata to <em>us</em> (we need it to setup the script&#x27;s private venv anyway) | who is <em>us</em> and <em>we</em>?   The LSP client should inform the LSP Server about where to find installed dependencies, aka the venv. |</p>
<p>Parsing PEP723 metadata should not be the job of any LSP; or at the very least I think <em>doing anything</em> with the parsed metadata is not part of the responsibilities of an LSP.  From what I understand, the metadata is intended to be use only by tools such as uv that set up a magic venv somewhere (definitely not in .venv) <em>just for that script</em>, and install the named dependencies into the venv.  Unless ty LSP is going to do that, it should not act on the PEP723 metadata. It should not care about that metadata.</p>
<p>ty LSP is a <em>consumer</em> or <em>user</em> of that prepared per-script venv, which is an indirect product of the metadata.  But ty LSP is not a system that needs to parse PEP723 metadata, beyond checking for well-formedness maybe.</p>
<p><em>detecting that uv or some other tool is installed</em> is also not the job of an LSP.  <em>having uv (or other) report things to the LSP server</em> is also not a thing the LSP Server should actively DO.   That is client-configuration stuff.</p>
<p>It seems to me....
ty language server needs to allow an LSP client like vim, zed, emacs a way to provide workspace configuration information like: &quot;for this workspace, use <strong>this</strong> python interpreter, and  <strong>this specific</strong> venv directory&quot;.   True, determining that information is easy with uv; for example the python is returned by <code>uv python find --script myfile.py</code>.  And there are similar ways to find the venv. But that determination should be done by the LSP client (editor) according to configuration done by the user; it should not be done by the LSP Server.  There are other non-uv tools that may set up per-script venv&#x27;s (eg poetry), and there would be different commands for those other tools obviously. But the client-to-server workspace configuration should be the same.</p>
<p><img alt="Image" src="https://github.com/user-attachments/assets/3c4c4316-d074-4a5d-a8b8-83fceb2e8639"></p>
<p>In theory an LSP client would just run the necessary command, and pass the required information either in <code>initializationOptions</code> or <code>workspace/configuration</code> via LSP protocol to ty LSP.  Then ty LSP would use that venv  and that python for resolving symbols and etc.</p>
<p>But at this moment <a href="https://docs.astral.sh/ty/features/language-server/#feature-reference">ty LSP documentation says</a> that ty LSP supports neither of those LSP operations/features.</p>
<p>Seems like a gap. PEP723 and per-script dependency lists means it is no longer viable to assume a single venv (always named .venv !) per directory.  So every tool that depends on a venv, and this includes ty LSP, needs to have a way for a caller to specify the location of the specific venv for any particular python file.   And the LSP protocol has a nice facility to do that.</p>
<hr>
<p>Another problem is that the interfaces aren&#x27;t standardized, AFAIK.  emacs can tell basedpyright where to find the python (and implicitly, the venv), but ... does that same LSP message work with pylsp? with ty?  Do those servers use the same LSP messages and same message content?  vim can ask poetry where the venv is, but... it uses a different command with poetry than it if were using pip directly, or uv.  So we end up having an NxM configuration problem which will inevitably make it confusing for users.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Request: support single-file scripts with PEP 723 metadata&quot; to &quot;Support single-file scripts with PEP 723 metadata&quot; by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-31 16:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2025-12-31 16:49</div>
            <div class="timeline-body"><blockquote>
<p>detect this is a PEP 723 script by finding the metadata at all (easy)</p>
</blockquote>
<p>Are there any clients that do this today?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DinoChiesa">@DinoChiesa</a> on 2026-01-02 18:36</div>
            <div class="timeline-body"><p>@MichaReiser - Not sure if you count emacs as a worthwhile client, but ... yes.  In emacs, everything is a matter of extensions via lisp.  So ...</p>
<pre><code>(defun epep723/has-pep723-p (&amp;optional _file)
  &quot;Return non-nil if current buffer contains PEP 723 script metadata.&quot;
  (let ((case-fold-search nil))
    (save-match-data
      (save-restriction
        (widen)
        (save-excursion
          (goto-char (point-min))
          ;; Search first 2048 chars for the script tag
          (re-search-forward &quot;^# /// script&quot; 2048 t))))))
</code></pre>
<p>The thinking is that the module docstring can precede the <code># /// script</code> markup, so it needs to search potentially past that.</p>
<p>This test is used before starting up an LSP server, to let the LSP serverknow, either via startup arguments, or via the LSP messages themselves, like <code>initializationOptions</code> (probably not), or <code>workspace/configuration</code> (better):</p>
<ul>
<li>where is the python interpreter and venv</li>
<li>this is a single-file project; don&#x27;t load or analyze other files</li>
</ul>
<p>This test has been useful with basedpyright - it accepts <code>python.pythonPath</code> in the <code>workspace/configuration</code> options.  I have not figured out how to launch ty with the appropriate information.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MichaReiser">@MichaReiser</a> on 2026-01-02 20:08</div>
            <div class="timeline-body"><p>emacs is a notable client but I don&#x27;t see why we should wait for all other major clients to implement script support, just so that we can provide great experience in ty (besides that I think there are other advantages of implementing script support natively)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jay-Madden">@Jay-Madden</a> on 2026-01-04 15:37</div>
            <div class="timeline-body"><p>I think fundamentally the problem statement of &quot;how is the venv created&quot; is seperate from ty&#x27;s scope of responsibility.</p>
<p>The various clients plugins can trivially handle creating the venv itself in either an ephemeral or persistent capacity.</p>
<p>All ty needs is a way to configure the path it looks at. Let the editor clients handle the rest.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2026-01-04 18:45</div>
            <div class="timeline-body"><blockquote>
<p>But ty LSP is not a system that needs to parse PEP723 metadata, beyond checking for well-formedness maybe.</p>
</blockquote>
<p>I disagree with this part. <code>uv</code> and <code>ty</code> have fundamentally different goals when they read the metadata. The contents of a script&#x27;s metadata (and the equivalent metadata in a pyproject.toml) are input constraints that uv wants to solve to a set of definite answers that it checks into a lockfile and renders into a venv.</p>
<p>However ty already has analysis to the effect of &quot;ok, so, you claim you work with python 3.12, but, you&#x27;re using APIs that were introduced in 3.13 (and don&#x27;t have a <code>version &gt;= 3.13</code> check surrounding that code)&quot;. This is a quite substantial issue because it&#x27;s quite common for a project to have conservative python requirements for compatibility, but the PEP scripts in the project to have bleeding edge requirements because they don&#x27;t need compatibility and <code>uv</code> will silently handle installing and using the more modern python.</p>
<p>It&#x27;s much more pie-in-the-sky for ty to do similar analysis for every random library (so I don&#x27;t really care about it as much), but in principle we can do the same thing with random pypi packages as we do for the python stdlib, so we also have a reason to want to get the raw dependency constraints for those too.</p>
<p>Less pie-in-the-sky, it&#x27;s already an established precedent in the typing ecosystem for typecheckers to include special knowledge and handling of important libraries in the python ecosystem, and so it wouldn&#x27;t be unreasonable for us to go &quot;hey it looks like you&#x27;re trying to use pydantic, but it&#x27;s not in your script&#x27;s dependencies, do you want to add it?&quot; (<a href="https://peps.python.org/pep-0794/">actually this may not even require special-casing</a>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DinoChiesa">@DinoChiesa</a> on 2026-01-04 20:21</div>
            <div class="timeline-body"><p>Regarding this:</p>
<blockquote>
<p>&quot;ok, so, you claim you work with python 3.12, but, you&#x27;re using APIs that were introduced in 3.13 (and don&#x27;t have a version &gt;= 3.13 check surrounding that code)&quot;.</p>
</blockquote>
<p>Is it not sufficient for ty to rely on the constructed venv to test &quot;does this script work with this version of python?&quot;   In the pep723 markup, a script can specify the version of python to use (<code>requires-python = &quot;&gt;=3.12&quot;</code>).   If uv or poetry or some other pep723-aware venv-manager creates a venv complete with a version of python, .... using the version specified via <code>requires-python</code> in the markup..... then.... ty should just use that venv to check for compatibility, right?</p>
<p>I don&#x27;t know specifically what a &quot;claim to work with python 3.12&quot; would look like, other than a specification of the python version in the pep723 markup (or if we are expanding beyond single-file projects, in the pyproject.toml).  If that is the extent of it, why wouldn&#x27;t ty just use the venv that has been created <em>from that specification</em>?</p>
<p>re:</p>
<blockquote>
<p>&quot;hey it looks like you&#x27;re trying to use pydantic, but it&#x27;s not in your script&#x27;s dependencies, do you want to add it?&quot;</p>
</blockquote>
<p>Yes that makes sense to me. I hadn&#x27;t thought of that.  There are two places where this is relevant: (1) the <em>import</em>  statement in the script, and (2) the specification of the dependency itself.  If ty wants to be able to offer code actions (via the <code>textDocument/codeAction</code> message in LSP), for item (2), it would need to be able to suggest changes in either PEP723 markup or the pyproject.toml file to add a dependency.   So it would need to be able to parse the pep723 markup I guess.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/quencs">@quencs</a> on 2026-01-04 20:32</div>
            <div class="timeline-body"><p>This feels a bit out of scope for ty to reason about explicitly.</p>
<p>If a script specifies requires-python via PEP 723 (or via pyproject.toml), and a PEP 723‚Äìaware tool creates a venv using that specification, then Python version compatibility should already be encoded in the environment itself. From that point on, ty can simply type-check against the interpreter it is given.</p>
<p>In that model, using a 3.13-only API in a 3.12 environment is just a normal type error, without ty needing to interpret or enforce ‚Äúversion claims‚Äù on its own.</p>
<p>Dependency diagnostics feel different: missing imports vs declared dependencies do seem like something ty could reasonably help with, which would require understanding (and possibly editing) PEP 723 metadata. But version selection itself seems better left to the environment manager.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DinoChiesa">@DinoChiesa</a> on 2026-01-04 20:38</div>
            <div class="timeline-body"><p>I agree with both of those points ^^ .</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/quencs">@quencs</a> on 2026-01-04 20:40</div>
            <div class="timeline-body"><p>I don‚Äôt think this is something ty should be responsible for at all.</p>
<p>If a script declares requires-python (via PEP 723 or pyproject.toml), then selecting and provisioning the correct Python version is the job of the environment manager. Once a venv is constructed, ty should simply type-check against the interpreter it is given.</p>
<p>Introducing additional logic in ty to interpret ‚Äúclaims to work with Python X‚Äù duplicates responsibility that already belongs to the toolchain, and risks divergence between what the environment enforces and what the type checker assumes.</p>
<p>In contrast, dependency completeness (e.g. importing a library that is not declared) is plausibly in scope, since it‚Äôs not enforced by the interpreter itself and benefits from static analysis. But Python version selection and compatibility should remain strictly out of scope for ty.</p>
<p>In short, ty should trust the interpreter it is invoked with. Anything beyond that is a layering violation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jay-Madden">@Jay-Madden</a> on 2026-01-04 21:59</div>
            <div class="timeline-body"><p>@quencs the problem is currently ty does not support being given a specific venv to use.</p>
<p>Once that is supported the various clients can support 723 via plugins.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/a-alak">@a-alak</a> on 2026-01-04 22:17</div>
            <div class="timeline-body"><blockquote>
<p>the problem is currently ty does not support being given a specific venv to use.</p>
</blockquote>
<p>What about the environment.python configuration to the right interpreter (e.g. output of uv python find). Will that not work?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-04 22:32</div>
            <div class="timeline-body"><p>FWIW, ty (intentionally) does not ever &quot;just check according to the Python version of the given environment.&quot; If your <code>pyproject.toml</code> declares that your project is supposed to work with Python &gt;=3.12, then ty will (by default, if not otherwise configured) check against 3.12, even if the env is e.g. 3.14. We currently don&#x27;t even consider the active env as signal for the Python version to check against. (One reason for this is that the only way to reliably detect the Python version of an env is to actually execute the Python binary in the env and check its self-reported version, and this is something we would strongly prefer not to do, for speed reasons.)</p>
<p>I don&#x27;t think there&#x27;s a clear right answer here. For e.g. some CI scenarios (which is not an LSP use case), it might make more sense to just use the Python version from the env, since CI typically runs across a matrix of Python versions, and each check is done in its own env. But for local development of a library that is intended to support 3.12+, there won&#x27;t likely be a matrix of envs -- I may well be developing on 3.14 locally, but still want ty to alert me if I use something that doesn&#x27;t exist on 3.12.</p>
<blockquote>
<p>ty does not support being given a specific venv to use.</p>
</blockquote>
<p>It does, via <code>environment.python</code> config. But the point here may be that it isn&#x27;t currently possible to configure this directly via LSP, without involving a ty configuration file? I&#x27;m not totally clear on the status here, <a href="https://github.com/astral-sh/ty/issues/2010">astral-sh/ty#2010</a>#issuecomment-3665555239 suggests there is a way to do this? More discussion in <a href="https://github.com/astral-sh/ty/issues/2032">astral-sh/ty#2032</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-04 22:42</div>
            <div class="timeline-body"><blockquote>
<p>We currently don&#x27;t even consider the active env as signal for the Python version to check against.</p>
</blockquote>
<p>@carljm that&#x27;s not true -- if we can determine the Python version from a virtual environment&#x27;s pyvenv.cfg file or the layout of a Python environment on disk, then we do consider the version of your active environment as a fallback in some situations. (But we only do this if you don&#x27;t have the Python version set via the command line, you don&#x27;t have <code>tool.ty.environment.python-version</code> set in a configuration file, and you don&#x27;t have <code>project.requires-python</code> set in a configuration file.) You can see this in our code <a href="https://github.com/astral-sh/ruff/blob/92a2f2c99226706feb4bd1b35d4fea205ae2113c/crates/ty_project/src/metadata/options.rs#L223-L231">here</a>, and it&#x27;s documented <a href="https://docs.astral.sh/ty/reference/configuration/#python-version">here</a> where it&#x27;s listed as the second fallback if no explicit configuration is given in a pyproject.toml or ty.toml file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/quencs">@quencs</a> on 2026-01-05 00:03</div>
            <div class="timeline-body"><p>Thanks for the clarification ‚Äî that‚Äôs helpful. You‚Äôre right that ty does consider the active environment‚Äôs Python version as a fallback when it can be inferred from pyvenv.cfg or the on-disk layout, and when no explicit configuration is provided.</p>
<p>I think the remaining point of tension is that this behavior is both conditional and implicit. From a user perspective, it‚Äôs not always obvious which signal ends up being used in a given run, especially once CI, lockfile generation, or tool-driven environments are involved. In those cases, the effective Python version used for checking can diverge from the one users intuitively expect.</p>
<p>That‚Äôs why this came up in the first place: not because the fallback doesn‚Äôt exist, but because relying on implicit inference makes it harder to reason about why a particular check or error is happening, and harder to ensure that validation is aligned with the environment users think they‚Äôre targeting.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Gankra">@Gankra</a> on 2026-01-05 12:07</div>
            <div class="timeline-body"><blockquote>
<p>I think the remaining point of tension is that this behavior is both conditional and implicit. From a user perspective, it‚Äôs not always obvious which signal ends up being used in a given run</p>
</blockquote>
<p>We&#x27;re actually quite explicit about it in diagnostics (unfortunately these extra-rich details only appear on the CLI right now, but improving that is orthogonal to this discussion).</p>
<p><img alt="Image" src="https://github.com/user-attachments/assets/48e349bb-aa2d-46e9-89c4-69c748b7010c"></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DinoChiesa">@DinoChiesa</a> on 2026-01-06 00:41</div>
            <div class="timeline-body"><blockquote>
<p>if we can determine the Python version from a virtual environment&#x27;s pyvenv.cfg file or the layout of a Python environment on disk, then we do consider the version of your active environment as a fallback in some situations.</p>
</blockquote>
<p>This seems like an example of the layering violation described by <a href="https://github.com/astral-sh/ty/issues/691#issuecomment-3708408548">quencs</a></p>
<p><em>There should be</em> a venv, and it <em>should be</em> consistent with the pyenv.cfg, but it is not the job of ty (I think) to check that consistency.  Instead ty should just use the python it is given.  The ask here I think, is for ty (LSP or command line)  to accept a pythonpath, as an invocation option or LSP message, not as a configuration file entry, which points to the python provisioned in the venv.  Maybe that means this issue is a duplicate of #2032.</p>
<p>re: <a href="https://github.com/astral-sh/ty/issues/691#issuecomment-3708486141">carljm&#x27;s comment yesterday</a></p>
<blockquote>
<p>I may well be developing on 3.14 locally, but still want ty to alert me if I use something that doesn&#x27;t exist on 3.12.</p>
</blockquote>
<p>This seems like a broken development process that ty would be wise to discourage. If a dev wants to build something for deployment on 3.12, the Dev should use a venv with 3.12, and ty or any checker should just line up on that venv.  It does not make sense for ty to try to figure out the set of what works and what doesn&#x27;t across the matrix of possibilities.  The python and features available should be determined by the venv. Simple, clear, easy. What is the downside with this?  It&#x27;s not as if it&#x27;s difficult to install 3.12 and 3.14 in different venvs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-06 00:51</div>
            <div class="timeline-body"><blockquote>
<p><em>There should be</em> a venv, and it <em>should be</em> consistent with the pyenv.cfg, but it is not the job of ty (I think) to check that consistency.</p>
</blockquote>
<p>ty is not checking consistency, it is just trusting the <code>pyvenv.cfg</code> as a source of truth, given a lack of other good options.</p>
<p>You are assuming that there&#x27;s some easy and reliable way to detect the actual Python version, given a Python environment, but there really isn&#x27;t one. The most reliable option is to execute the Python binary and ask it to tell you its version, but this is a) very slow relative to ty&#x27;s check speed, and b) also not really reliable, as it opts into a bunch of assumptions about ty&#x27;s ability to execute a random binary.</p>
<p>@AlexWaygood was simply listing the two unreliable methods we use: check <code>pyvenv.cfg</code>, and check the <code>lib/pythonX.X</code> directory existence. Unfortunately even the combination of these two methods does not cover nearly all possible Python environments. The first method applies only to virtual environments created by the stdlib <code>venv</code> module, and the second method applies only to POSIX layouts (Windows Python environments, for example, don&#x27;t include the Python version in their lib directory name.)</p>
<blockquote>
<p>If a dev wants to build something for deployment on 3.12, the Dev should use a venv with 3.12, and ty or any checker should just line up on that venv.</p>
</blockquote>
<p>That&#x27;s a reasonable point of view. I think it would probably be best to open a separate issue to discuss it.</p>
<p>One major challenge in adopting this point of view is the difficulty of reliably obtaining a Python version from a Python environment, as discussed above.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:24:54 UTC
    </footer>
</body>
</html>
