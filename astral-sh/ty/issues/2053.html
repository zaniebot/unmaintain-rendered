<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Use Iterable type context when inferring types inside a literal tuple - astral-sh/ty #2053</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Use Iterable type context when inferring types inside a literal tuple</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/2053">#2053</a>
        opened by <a href="https://github.com/gpajot">@gpajot</a>
        on 2025-12-18 07:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/gpajot">@gpajot</a></div>
            <div class="timeline-body"><h3>Summary</h3>
<p>This has some similarities with https://github.com/astral-sh/ty/issues/1576 at first glance.</p>
<p><a href="https://play.ty.dev/19eadbf5-16e1-49e6-bc2b-f9f7743df92e">Playground link</a></p>
<p>It fails in all those circumstances:</p>
<ul>
<li><code>float</code> is replaced by any union type (<code>float</code> itself is transformed to <code>int | float</code> as per the error message)</li>
<li><code>Iterable</code> is replaced by <code>Sequence</code> (and maybe other <code>collections.abc</code> types?)</li>
<li>input value is replaced by <code>set</code> or <code>list</code></li>
<li><code>dataclass</code> is replaced by either a normal generic class or a generic pydantic model</li>
</ul>
<p>It does work if we replace <code>Iterable</code> by a concrete container class such as <code>tuple</code>.
It also works if replacing the generic data class by a generic built-in type such as <code>list[T]</code>.</p>
<p>Thanks for the tremendous work by the way!</p>
<h3>Version</h3>
<p>ty 0.0.3 (06305f3c0 2025-12-18)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @sharkdp on 2025-12-18 09:41</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-18 09:45</div>
            <div class="timeline-body"><p>Thank you for reporting this.</p>
<p>This seems like a problem that is related to invariance and the <a href="https://docs.astral.sh/ty/reference/typing-faq/#why-does-ty-show-int-float-when-i-annotate-something-as-float">float special case</a>.</p>
<p>The error goes away if I change <code>v: T</code> to <code>_v: T</code> to make <code>Value</code> covariant in <code>T</code>.</p>
<p>Maybe it's also related to bidirectional type-checking (involving generic protocols), because this works just fine:</p>
<pre><code class="language-py">def accepts_single_value(value: Value[float]): ...

accepts_single_value(Value(1.))
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gpajot">@gpajot</a> on 2025-12-18 10:56</div>
            <div class="timeline-body"><p>Right üëç thanks for the replay, makes sense. Using <code>Final[T]</code> works as well, though specifying the data class as frozen doesn't seem to make it infer the proper variance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-22 23:26</div>
            <div class="timeline-body"><p>Several things going on here!</p>
<p>First of all, <code>frozen=True</code> doesn't make the dataclass covariant due to the <code>__replace__</code> method added in Python 3.13: all dataclasses (even frozen ones) end up inferred as invariant. Pyright has the same behavior. This is unfortunate and a known open issue in Python dataclass typing. Under Python 3.12 we <a href="https://play.ty.dev/d95f51aa-fc93-4062-b046-63f5c8954d19">infer it as covariant</a>.</p>
<p>Given invariance, it is correct that <code>tuple[Value[float], Value[float]]</code> is not assignable to <code>Iterable[Value[float | int]]</code>. The discrepancy between <code>float</code> in the first case and <code>float | int</code> in the second case is because of the special case where <code>float</code> in a type expression is interpreted as <code>float | int</code>, but we infer <code>Value[float]</code> (not <code>Value[float | int]</code>) from the literal float in <code>Value(0.1)</code>. We could consider having less precise inference of float literals in general, to help with invariance cases like this, but this seems unfortunate.</p>
<p>Alternatively, we could apply type context so that we choose a better inference for these particular instantiations of <code>Value</code>.</p>
<p>It may help clarify if we transform the example to this version, using <code>int</code> and <code>bool</code> instead, so as to avoid the <code>float | int</code> special case.</p>
<pre><code class="language-py">from collections.abc import Iterable
from dataclasses import dataclass

@dataclass(frozen=True)
class Value[T]:
    v: T


def func(values: Iterable[Value[int]]) -&gt; None:
    for v in values:
        print(v)

func((Value(True), Value(False)))
</code></pre>
<p>This passes in pyright, due to bidirectional inference giving a hint that <code>Value[True]</code> and <code>Value[False]</code> should be inferred as <code>Value[int]</code> not <code>Value[bool]</code>. (We can see that bidirectional inference is the key by <a href="https://pyright-play.net/?pythonVersion=3.14&amp;strict=true&amp;code=GYJw9gtgBAxmA28CmMAuBLMA7AzgOgEMAjGKdCABzBFSgElUkRjkAoUSKAEwNQJngEcOJDjKVqtHnwFCcrVgAFp-QcIAUHAF5IsAXgAqIAK5IAlK1nCoANQLxTAbQMBdAFysoXqADc3UAwVWLiRgKGBjLBh1H3tTHH8GJhYkRzsHVPQsVBcXMygAWgA%2BKAA5bCQPb3DqXzIsXzjRKurvChAs1BiLVgAPKD0odXTTdSNTMwAaWyb1ADF7ETMeiKj1XrMgA">extracting the argument expression to a separate line</a>, causing the type context to be lost, and making this an error in Pyright.)</p>
<p>The current PR for #1576 doesn't quite fix this for us. It fixes it (even with floats) if we use a list instead of a tuple at the call site:</p>
<pre><code class="language-py">from collections.abc import Iterable
from dataclasses import dataclass

@dataclass(frozen=True)
class Value[T]:
    v: T


def func(values: Iterable[Value[float]]) -&gt; None:
    for v in values:
        print(v)

func([Value(0.1), Value(0.2)])
</code></pre>
<p>But it looks like we'll need some additional work to apply the <code>Iterable[Value[float]]</code> type context to the <code>Value</code> instantiations inside a tuple.</p>
<p>Keeping this issue open (separate from #1576) to track that piece.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "`Iterable[<GenericClass>[<Union>]]` not accepting concrete implementations" to "Use Iterable type context when inferring types inside a literal tuple" by @carljm on 2025-12-22 23:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bidirectional inference</span> added by @carljm on 2025-12-22 23:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-12-22 23:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-08 19:12</div>
            <div class="timeline-body"><p>The original OP example here works now, because we now widen <code>float</code> to <code>float | int</code> wherever we would widen literals. But this example still doesn't work, because we aren't actually pushing down the type context into the tuple:</p>
<pre><code class="language-py">from collections.abc import Iterable
from dataclasses import dataclass

@dataclass(frozen=True)
class Value[T]:
    v: T


def func(values: Iterable[Value[int]]) -&gt; None:
    for v in values:
        print(v)

func((Value(True), Value(False)))
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:21:24 UTC
    </footer>
</body>
</html>
