<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type context can be wrongly included in diagnostic type when there is no solution - astral-sh/ty #2537</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Type context can be wrongly included in diagnostic type when there is no solution</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/2537">#2537</a>
        opened by <a href="https://github.com/randolf-scholz">@randolf-scholz</a>
        on 2026-01-16 20:33
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/randolf-scholz">@randolf-scholz</a></div>
            <div class="timeline-body">Summary
<p>Consider a <code>dict[K, V]</code> like class with a get method:</p>
<pre><code>from typing import Any, reveal_type

class Map[K, V]:
    def set(self, key: K, value: V) -&gt; None: ...
    def get[T=None](self, key: Any, default: T = None, /) -&gt; V | T: ...

d: Map[str, int] = Map[str, int]()

# as expected, these are both `int | None`
reveal_type(d.get(&quot;key&quot;))  # int | None  ✅️
reveal_type(d.get(&quot;key&quot;, None))  # int | None  ✅️
# outer context should not overrule the argument type!
result: str = reveal_type(d.get(&quot;key&quot;, None))  # int | None | str ❌️
</code></pre>
<p><code>d.get(&quot;key&quot;, None)</code> alone produces <code>int | None</code> as expected, but in the last case we have <code>str</code> as outer context. This gives an unsolvable situation for the type variable <code>T</code> as we would need both <code>T &lt;: str</code> and <code>T :&gt; None</code>. It seems <code>ty</code> gives priority to the outer constraint <code>T &lt;: str</code> here, which seems misguided, as it produces an illogical <code>reveal_type</code> result: <code>int | None | str</code>.</p>
<p>But <code>d.get(&quot;key&quot;, None)</code> cannot produce a <code>str</code>!</p>
<p>Instead, the inner constraint <code>T :&gt; None</code> should probably be prioritized in this situation.</p>
<p>See also mirror issues in <code>mypy</code> and <code>pyrefly</code> tracker: <a href="https://github.com/python/mypy/issues/20576">python/mypy#20576</a>, <a href="https://github.com/facebook/pyrefly/issues/2136">facebook/pyrefly#2136</a></p>
Version
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-17 01:45</div>
            <div class="timeline-body"><p>Just to be clear, this is purely an issue of the diagnostic / hover / revealed type -- there is no type checking correctness issue here?</p>
<p>I think this is a known issue with how we apply type context in generic cases. We would like to fix it, but we don&#x27;t consider it super high priority since it just makes the revealed types sometimes wrongly include the context type, when there is no solution that satisfies the context type. It doesn&#x27;t ever change the correctness of a program.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bidirectional inference</span> added by <a href="https://github.com/carljm">@carljm</a> on 2026-01-17 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Bad Type Variable resolution with outer context (`dict.get`)&quot; to &quot;Type context can be wrongly included in diagnostic type when there is no solution&quot; by <a href="https://github.com/carljm">@carljm</a> on 2026-01-17 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by <a href="https://github.com/carljm">@carljm</a> on 2026-01-17 01:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-17 01:46</div>
            <div class="timeline-body"><p>@ibraheemdev do we already have an issue open for this? If not, we can use this one.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">diagnostics</span> added by <a href="https://github.com/carljm">@carljm</a> on 2026-01-17 01:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/electronick1">@electronick1</a> on 2026-01-17 02:20</div>
            <div class="timeline-body"><p>It looks like this PR <a href="https://github.com/astral-sh/ruff/pull/21267">astral-sh/ruff#21267</a> is related, it adds context for cases when type can not be assigned.
<a href="https://github.com/astral-sh/ruff/pull/21267/files#diff-8c9ae4384d5808e43fce19d9835dd6e49048297bd4989c5379ebe0f476d34e4fR425">For example</a> in annotations.md:</p>
<pre><code># error: [invalid-assignment] &quot;Object of type `list[int | str]` is not assignable to `list[int]`&quot;
g: list[int] = f(&quot;a&quot;)
</code></pre>
<p><code>f(&quot;a&quot;)</code> - can not return <code>list[int | str]</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2026-01-17 03:13</div>
            <div class="timeline-body"><blockquote>
<p><code>f(&quot;a&quot;)</code> - can not return <code>list[int | str]</code></p>
</blockquote>
<p>I&#x27;m not sure what you mean by that. <code>f(&quot;a&quot;)</code> can and should produce a <code>list[int | str]</code> given a type context of <code>list[int | str]</code>. In this case, the constraints are unsolvable, and our attempt to solve them produces a <code>list[int | str]</code>. I do agree that it is slightly confusing, but it is not incorrect.</p>
<p>Ignoring the type context completely can lead to confusing diagnostics, which is why we removed that behavior in <a href="https://github.com/astral-sh/ruff/pull/21267">astral-sh/ruff#21267</a>. For example, we use the type context to avoid literal promotion</p>
<pre><code>from typing import Literal

def f[T](x: T) -&gt; list[T]:
    return [x]

# Option A: Object of type `list[Literal[&quot;hello&quot;] | int]` is not assignable to `list[Literal[&quot;hello&quot;] | bool]`
# Option B: Object of type `list[Literal[&quot;hello&quot;] | int]` is not assignable to `list[str | bool]`
x: list[Literal[&quot;hello&quot;] | bool] = [&quot;hello&quot;, 1]
</code></pre>
<p>Or to infer <code>TypedDict</code> types:</p>
<pre><code>class A(TypedDict):
    bar: int

# Option A: Object of type `list[A | int]` is not assignable to `list[A | bool]`
# Option B: Object of type `list[A | int | dict[Unknown | str, Unknown | int]]` is not assignable to `list[A | bool]`
y: list[A | bool] = [{&quot;bar&quot;: 1}, 1]
</code></pre>
<p>The second diagnostic is a lot more confusing in both cases, and suggests that there is a problem with literal promotion or typed dict inference.</p>
<p>I do think we can be better in the generics case though, and should not resolve without the type context if we fail to arrive at a valid specialization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/electronick1">@electronick1</a> on 2026-01-17 04:03</div>
            <div class="timeline-body"><p>I mean, if we consider function:</p>
<pre><code>def f[T](x: T) -&gt; list[T]:
    return [x]
</code></pre>
<p>And function call <code>f(&quot;a&quot;)</code> - <code>f</code> will produce <code>list[str]</code>, while message says: &quot;<code>list[int | str]</code> is not assignable to <code>list[int]</code>&quot; - which is confusing in case of <code>f(&quot;a&quot;)</code> call, even if <code>T</code> of <code>f</code> could be any other type.</p>
<blockquote>
<p>I do think we can be better in the generics case though, and should not resolve without the type context if we fail to arrive at a valid specialization.</p>
</blockquote>
<p>Yeah I was looking at specialization logic too, I can see your PR #22643 is addressing this</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:27:11 UTC
    </footer>
</body>
</html>
