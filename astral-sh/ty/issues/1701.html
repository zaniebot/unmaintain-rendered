<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Use decorated function as type context when inferring decorator expression (or more aggressively promote literals in decorators) - astral-sh/ty #1701</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Use decorated function as type context when inferring decorator expression (or more aggressively promote literals in decorators)</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/1701">#1701</a>
        opened by <a href="https://github.com/patrick91">@patrick91</a>
        on 2025-12-01 11:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/patrick91">@patrick91</a></div>
            <div class="timeline-body">Summary
<p>Not sure if the title is descriptive enough, anyway, I have this decorator:</p>
<pre><code>from typing import Literal
from collections.abc import AsyncGenerator, Callable


def decorator[Item](
    message: Item,
) -&gt; Callable[[Callable[[], AsyncGenerator[Item]]], Callable[[], AsyncGenerator[Item]]]:
    def inner(fn: Callable[[], AsyncGenerator[Item]]) -&gt; Callable[[], AsyncGenerator[Item]]:
        return fn
    return inner
</code></pre>
<p>When I try to use and pass a message, the inferred type is too narrow, see:</p>
<pre><code>@decorator(message=&quot;hello&quot;)
async def my_generator() -&gt; AsyncGenerator[Literal[&quot;hello&quot;]]:
    yield &quot;hello&quot;

# this one fails with:
# Argument is incorrect: Expected `() -&gt; AsyncGenerator[Literal[&quot;hello&quot;], None]`, found `def my_generator2() -&gt; AsyncGenerator[str, None]` (invalid-argument-type) [Ln 18, Col 1]
@decorator(message=&quot;hello&quot;)
async def my_generator2() -&gt; AsyncGenerator[str]:
    yield &quot;world&quot;
</code></pre>
<p>I also tried with this, but I get the same output ðŸ˜Š</p>
<pre><code>message: str = &quot;hello&quot;

@decorator(message=message)
async def my_generator3() -&gt; AsyncGenerator[str]:
    yield &quot;world&quot;
</code></pre>
<p>https://play.ty.dev/67bbea2d-a7d1-40a9-bce6-fa6787129244</p>
Version
<p>ty 0.0.1-alpha.29 (0c3cae494 2025-11-28)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-01 11:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-01 11:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-01 11:19</div>
            <div class="timeline-body"><p>Thank you for reporting this.</p>
<p>This will hopefully be fixed by #623.</p>
<blockquote>
<p>I also tried with this, but I get the same output ðŸ˜Š</p>
<pre><code>message: str = &quot;hello&quot;

@decorator(message=message)
async def my_generator3() -&gt; AsyncGenerator[str]:
    yield &quot;world&quot;
</code></pre>
</blockquote>
<p>That doesn&#x27;t work because we still use <code>Literal[&quot;hello&quot;]</code> as the inferred type of <code>message</code> in the local scope, even though it&#x27;s declared as <code>str</code>. <code>@decorator(message=cast(str, &quot;hello&quot;))</code> would be a workaround.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-02 02:23</div>
            <div class="timeline-body"><p>I don&#x27;t think the new constraint solver alone will solve this. It will also require an additional feature (not otherwise discussed in an issue, AFAIK) to use the decorated function as part of a callable type context when inferring the decorator expression.</p>
<p>I&#x27;m not quite sure how to interpret mypy and pyright&#x27;s behavior here. They seem to use this type context to some degree, because they are fine with both <code>my_generator</code> and <code>my_generator2</code>. If they were unconditionally doing literal promotion here with no type context, they would fail on <code>my_generator</code>. But they don&#x27;t seem to fully use the type context, because they both fail on a <code>my_generator3</code> that returns <code>AsyncGenerator[object]</code>, even though it&#x27;s also perfectly valid to infer <code>Item=object</code> from <code>@decorator(message=&quot;hello&quot;)</code>.</p>
<p>EDIT: Oh, actually mypy and pyright&#x27;s behavior is fully explainable by literal promotion, without any use of type context, because <code>AsyncGenerator</code> is covariant in its yielded type.</p>
<p>So it seems like our choice here is to attempt to do better than mypy/pyright (but in a way that probably few users will care about) by using this type context, or to more aggressively promote literals in this case (which requires defining the limits of &quot;this case&quot;) and match their behavior.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;Stable&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-12-02 02:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Generic type parameter inferred as literal type instead of widening to match decorated function&#x27;s return type&quot; to &quot;Use decorated function as type context when inferring decorator expression&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-12-02 02:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Use decorated function as type context when inferring decorator expression&quot; to &quot;Use decorated function as type context when inferring decorator expression (or more aggressively promote literals in decorators)&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-12-02 02:35</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:11 UTC
    </footer>
</body>
</html>
