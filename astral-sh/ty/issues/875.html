<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>names bound at some point in a class scope, but not at point of access, fall back to global scope - astral-sh/ty #875</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>names bound at some point in a class scope, but not at point of access, fall back to global scope</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/875">#875</a>
        opened by <a href="https://github.com/carljm">@carljm</a>
        on 2025-07-22 20:54
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/carljm">@carljm</a></div>
            <div class="timeline-body"><p>Python's scoping semantics in class scopes are really quite odd. There's a subtle difference at runtime between these two examples:</p>
<pre><code class="language-py">x: str

def f(x: int):
    class C:
        reveal_type(x)  # revealed: int

def g(x: int):
    class C:
        reveal_type(x)  # revealed: str
        x = None
</code></pre>
<p>In both examples, <code>x</code> has no value assigned to it in the scope of class <code>C</code> at the point where it is referenced (in the <code>reveal_type</code>).</p>
<p>In the case of <code>f</code> where <code>x</code> is never bound in the scope of <code>class C</code>, at runtime a <code>LOAD_DICT_OR_DEREF</code> opcode is used, which will fall back to the <code>x</code> in the scope of <code>f</code>. But if <code>x</code> <em>is</em> bound at any point in the scope of <code>C</code> (as occurs in <code>g</code>), then a <code>LOAD_NAME</code> is used instead, which falls back only to the global scope, bypassing any enclosing function scopes.</p>
<p>Currently we don't model this difference correctly, so we wrongly infer <code>int</code> in both cases above. It should be a fairly simple change to <code>TypeInferenceBuilder::infer_place_load</code> to fix this (I think).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @carljm on 2025-07-22 20:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @carljm on 2025-07-22 20:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">runtime semantics</span> added by @carljm on 2025-07-22 20:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/erictraut">@erictraut</a> on 2025-07-22 20:59</div>
            <div class="timeline-body"><p>Yeah, mypy doesn't model this correctly either.</p>
<p>Probably not a high priority.</p>
<p>It took quite a bit of work to model this correctly in pyright. Looks like pyrefly models it too.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-22 21:01</div>
            <div class="timeline-body"><p>Yeah, both mypy and pyrefly get it wrong.</p>
<p>I <em>think</em> it should be pretty easy for us to get it right? But if I'm wrong, I agree it's not a high priority to spend a lot of time on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-08-05 03:21</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:20:21 UTC
    </footer>
</body>
</html>
