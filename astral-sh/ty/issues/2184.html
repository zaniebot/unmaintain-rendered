<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Showing annotated `float` as `int | float` might not be right - astral-sh/ty #2184</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Showing annotated <code>float</code> as <code>int | float</code> might not be right</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/2184">#2184</a>
        opened by <a href="https://github.com/cmp0xff">@cmp0xff</a>
        on 2025-12-23 12:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/cmp0xff">@cmp0xff</a> on 2025-12-23 12:26</div>
            <div class="timeline-body"><h3>Summary</h3>
<ul>
<li><a href="https://pypi.org/project/flake8-pyi/22.7.0/"><code>Y041</code> in <code>flake8</code></a> marks <code>float | int</code> as redundant</li>
<li><a href="https://peps.python.org/pep-0484/#the-numeric-tower">PEP484</a> suggests <code>float</code> contains <code>int</code></li>
<li><code>mypy</code>, <code>pyright</code> and <a href="https://pyrefly.org/sandbox/?project=N4IgZglgNgpgziAXKOBDAdgEwEYHsAeAdAA4CeS4ATrgLYAEALqcROgOZ0Q3G6UN2UYANxiooAfSbEYAHSwwwdMLlwAKAJR0AtAD4lUXKgaI5dMwJgMArpXR0AjHLmCRYycxirla9erkgAGhArBmg4EnJEEABiOgBVUKgIJiUrdABjUNx0OCd5RWVKGiNxdCsabBhKVXxETnQGTV06OAZKEztzQWtbJRkQADlyyva6YHwAX37-ILJBMChSQgZaKApYgAVSecWWjBwCOnTsyDYbIwhswjlYgGUYGDoACwYGYjhEAHpPuYVFwl4bE%2BMHQn0wuHScE%2Bx3Qp3OWVBSl4dFQQlQ0FQ2FgRxOEDOlAu2TouGICPCcjIDCe2S0IkocEudgAvHR%2BgBmQj2ABM03QIAmQVQmQgIgAYtAYBQ0Fg8EQyPygA"><code>pyrefly</code></a> show annotated <code>float</code> as <code>float</code></li>
<li>However, <a href="https://play.ty.dev/6d776ddf-569d-4a56-b8b1-2c2d73166635"><code>ty</code></a> shows annotated <code>float</code> as <code>int | float</code></li>
</ul>
<pre><code class="language-py">from typing import reveal_type
def foo() -&gt; float:
    return 1

reveal_type(foo())  # ty shows int | float
</code></pre>
<h3>Version</h3>
<p>5ea30c4c5</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-12-23 12:29</div>
            <div class="timeline-body"><p>Hey, thanks for the report. Does this FAQ answer your question? https://docs.astral.sh/ty/reference/typing-faq/#why-does-ty-show-int-float-when-i-annotate-something-as-float</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> added by @AlexWaygood on 2025-12-23 12:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cmp0xff">@cmp0xff</a> on 2025-12-23 12:39</div>
            <div class="timeline-body"><p>Hi, thank you for showing me the FAQ. What I wanted to say is that <code>ty</code> goes against a PEP here, which can be surprising to users.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-23 16:13</div>
            <div class="timeline-body"><p>I don't think ty &quot;goes against a PEP&quot; here. Interpreting an annotation of <code>float</code> as meaning <code>float | int</code> is one way to implement the (not very well specified) comment in PEP 484 about an int &quot;being acceptable&quot; where <code>float</code> is annotated. It is also consistent with <code>Y041</code> -- an annotation of <code>float | int</code> is redundant when <code>float</code> already means <code>float | int</code>.</p>
<p><code>float</code> and <code>int</code> are different (and not compatible) types at runtime, so the choice in PEP 484 to pretend they are compatible has left type-checkers with not a great set of choices here. The implementation in ty is not so different from that in pyright, except we choose to show the type to users in the same way it is understood internally.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @carljm on 2025-12-23 16:13</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-26 17:28</div>
            <div class="timeline-body"><p>I'm going to reopen this issue to track whether we do need to do something differently to reduce user confusion here, because we get a lot of reports around this.</p>
<p>Options could include:</p>
<ol>
<li>Choosing a different (and unsound) interpretation of the int/float special case.</li>
<li>Displaying the <code>int | float</code> union type differently.</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @carljm on 2025-12-26 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">question</span> removed by @carljm on 2025-12-26 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">needs-decision</span> added by @carljm on 2025-12-26 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-12-26 17:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cmp0xff">@cmp0xff</a> on 2025-12-26 22:33</div>
            <div class="timeline-body"><p>Thank you for opening the Issue again. Based on my understanding in pandas-dev/pandas-stubs#1574, I think printing as JustFloat | JustInt makes a lot of sense.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jammf">@Jammf</a> on 2025-12-27 23:58</div>
            <div class="timeline-body"><p>I would argue that the special-casing in the typing spec only applies to <strong>argument type</strong> annotations. This seems to differ from ty's interpretation, which also treats explicit <strong>return type</strong> <code>float</code> annotations as <code>float | int</code>.</p>
<p>From <a href="https://typing.python.org/en/latest/spec/special-types.html#special-cases-for-float-and-complex">Python typing spec</a>, emphasis added:</p>
<blockquote>
<p>Pythonâ€™s numeric types complex, float and int are not subtypes of each other, but to support common use cases, the type system contains a straightforward shortcut: when an <strong>argument</strong> is annotated as having type float, an argument of type int is acceptable; similar, for an <strong>argument</strong> annotated as having type complex, arguments of type float or int are acceptable.</p>
</blockquote>
<p>If only arguments have special-casing, that would imply that the following are typed incorrectly and should each emit a diagnostic:</p>
<pre><code class="language-python">def foo() -&gt; float:
    return 1

def bar(a: float) -&gt; float:   # equivalently: (float | int) -&gt; JustFloat
    return a

def baz(a: float, b: float) -&gt; float:   # equivalently: (float | int, float | int) -&gt; JustFloat
    return a + b
</code></pre>
<p>since <code>bar(1)</code> and <code>baz(1, 2)</code> both return  an <code>int</code>, which is incompatible with <code>float</code>. Some potential fixes that users could do, depending on their intent:</p>
<pre><code class="language-python"># Modify annotations to clarify expected types
def foo() -&gt; int: ...

def bar(a: float) -&gt; float | int: ...
# -or-
def bar(a: JustFloat) -&gt; float: ...

def baz(a: float, b: float) -&gt; float | int: ...
# -or-
def baz(a: JustFloat, b: JustFloat) -&gt; float: ...

# ---

# Modify impl. to match annotations
def foo() -&gt; float:
    return float(1)

def bar(a: float) -&gt; float:
    return float(a)

def baz(a: float, b: float) -&gt; float:
    return float(a + b)
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-29 20:09</div>
            <div class="timeline-body"><p>It is true that the spec only mentions arguments, but no type checker has ever interpreted the special case in that way (all type checkers are OK with your first <code>foo</code> function). I would attribute the wording in the spec to careless word choice in PEP 484 rather than a real intention that the special case should apply only to arguments, given that the authors of PEP 484 were also among the original authors of mypy.</p>
<p>We could of course decide to follow the literal wording in the spec, but since this would be a change from the behavior of all current type checkers, we should not do it just &quot;because the spec says so,&quot; but only if we actually believe it's a better approach. I definitely don't think it is. IMO it is a non-starter to have your <code>bar</code> function fail to type-check.</p>
<p>There is general agreement already that the current wording in the spec is under-specified and does not clearly describe a desirable behavior that type checkers are willing to implement. As a result, every type checker currently implements a slightly different (and differently confusing) version of the special case. There isn't, however, consensus yet on how best to clarify it. See https://github.com/python/typing/issues/1746 for extensive prior discussion.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jammf">@Jammf</a> on 2025-12-29 21:54</div>
            <div class="timeline-body"><p>Thank you for the link to the prior discussion, it seems there has been quite an extensive debate! It definitely does sound like a clarification to the spec is needed. The reason I commented earlier was because of the following scenario, which I assumed to be an oversight rather than intentional design:</p>
<pre><code class="language-python">a = 0.1
b = 0.2
reveal_type(a)  # float
reveal_type(b)  # float

c = a + b
reveal_type(c)  # int | float
</code></pre>
<p>I had expected the result of adding two <code>JustFloat</code>s would be another <code>JustFloat</code>, and figured the <code>float.__add__(self, value: float, /) -&gt; float</code> declaration from typeshed was causing ty to incorrectly determine the return type was <code>int | float</code>. I opted to add on to this issue since the root causes overlapped, but I'm happy to raise a separate issue if one doesn't already exist.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-12-29 22:06</div>
            <div class="timeline-body"><p>Makes sense! Feel free to open another issue for that, though I'm not sure there is an obvious short-term resolution in ty, pending a clarification in the spec. If we can agree on the &quot;<code>float</code> annotation means <code>int | float</code>&quot; interpretation of the special case, which ty uses, then it would make sense to introduce a <code>JustFloat</code> annotation, and it would make sense for typeshed to use that type in the return type of <code>float.__add__</code>. But it will be difficult to make this change in typeshed before we have agreement on how type-checkers should handle <code>float</code> annotations.</p>
<p>We could consider patching typeshed or special-casing some methods in ty as a short-term fix.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:41:50 UTC
    </footer>
</body>
</html>
