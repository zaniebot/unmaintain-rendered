<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>improve typevar solving - astral-sh/ty #623</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>improve typevar solving</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/623">#623</a>
        opened by <a href="https://github.com/DetachHead">@DetachHead</a>
        on 2025-06-10 11:56
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/DetachHead">@DetachHead</a> on 2025-06-10 11:56</div>
            <div class="timeline-body"><h3>Summary</h3>
<pre><code class="language-py">def safe[T](value: T | None) -&gt; T: ...


def _(value: int | None):
    reveal_type(safe(value)) # int | None
</code></pre>
<p>https://play.ty.dev/8370e070-c8b0-430a-8e42-b645793e5561</p>
<p>it looks like <code>T</code> is being inferred as <code>int | None</code>, but it would be more convenient if it was inferred as <code>int</code>, so that the <code>safe</code> function can behave sort of like a type guard that removes <code>None</code> from types.</p>
<p>both <a href="https://basedpyright.com/?typeCheckingMode=all&amp;code=CYUwZgBAzghmIG0AqBdAFANxgGwK4gC4IkIAfCAOQHsA7EASggFoA%2BYogOi4ChfRIA%2Bphz4iASxoAXMpVoMC3CEogAnEBhA4BkgJ4AHEGljxheBowDEECZKA">pyright</a> and <a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=c87e6bb90e256b9e3dfd15db83195ff4">mypy</a> support inferring the generics this way.</p>
<h3>Version</h3>
<p>0.0.1-alpha.8 (c1337c962 2025-06-02)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @AlexWaygood on 2025-06-10 12:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-06-10 18:09</div>
            <div class="timeline-body"><p>Our specialization inference is very limited at the moment, <a href="https://github.com/astral-sh/ruff/blob/6051a118d16355b0c5a5d4ff763b383b7e88c064/crates/ty_python_semantic/src/types/generics.rs#L674-L683">especially for union types</a>. This is a good example of something that should be handled by the full constraint solver that we're planning on adding.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Beta" by @carljm on 2025-07-23 22:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-07-23 22:58</div>
            <div class="timeline-body"><p>Doesn't seem like we have an open issue for better constraint solver, so repurposing this one for that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "removing a type from a union using a generic doesn't work" to "improve typevar solving" by @carljm on 2025-07-23 22:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @dcreager by @dcreager on 2025-07-24 01:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-11-05 17:44</div>
            <div class="timeline-body"><p>Here's a minimized version of https://github.com/astral-sh/ty/issues/1481, which is something we should aim to support with the new constraint solver:</p>
<pre><code class="language-py">from typing import Protocol, reveal_type

class SupportsNext[T](Protocol):
    def __next__(self) -&gt; T:
        raise NotImplementedError

class HasNext:
    def __next__(self) -&gt; int:
        return 42

def solve_my_typevar_please[T](x: SupportsNext[T]) -&gt; T:
    raise NotImplementedError

def _(x: HasNext):
    reveal_type(solve_my_typevar_please(x))  # Currently `Unknown`, should be `int`
</code></pre>
<p>Here <code>HasNext</code> only implicitly implements <code>SupportsNext</code> (it does not explicitly subclass <code>SupportsNext</code>), so the missing support for this with the current solver relates to <a href="https://github.com/astral-sh/ruff/blob/eda85f3c646ddb9f3dddf13315d653f51d187f64/crates/ty_python_semantic/src/types/generics.rs#L1551-L1559">this TODO here</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "Beta" by @MichaReiser on 2025-12-05 15:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @MichaReiser on 2025-12-05 15:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andythomas">@andythomas</a> on 2025-12-10 09:03</div>
            <div class="timeline-body"><p>I do not know, if this adds something new, but even to judge that gets too difficult for me...</p>
<p>I have two issues: The incorrect error message from ty that <code>a.error</code> is &quot;Not an instance or subclass of <code>BaseException</code>&quot;, which might or might not be caused by the narrowing of <code>a</code> &quot;(Success[str] &amp; Top[Error[Unknown]]) | Error[FileNotFoundError]&quot;</p>
<p>https://play.ty.dev/ae688c4a-c03d-4b8d-9b08-f0494ec8f7d4</p>
<pre><code class="language-python">from dataclasses import dataclass
from typing import Generic, TypeAlias, TypeVar

T = TypeVar(&quot;T&quot;)
E = TypeVar(&quot;E&quot;)


@dataclass(frozen=True)
class Success(Generic[T]):
    value: T


@dataclass(frozen=True)
class Error(Generic[E]):
    error: E


Result: TypeAlias = Success[T] | Error[E]


def find_binary(binary: str) -&gt; Result[str, FileNotFoundError]:
    if binary == &quot;b&quot;:
        return Success(&quot;yes.&quot;)
    else:
        return Error(FileNotFoundError(&quot;File not found.&quot;))


a = find_binary(&quot;a&quot;)
if isinstance(a, Error):
    raise a.error
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-12-10 09:25</div>
            <div class="timeline-body"><p>@andythomas Your problem is not really related to generics. If you look at the narrowed type of <code>a</code> inside the <code>isinstance</code> branch, you'll notice that it is <code>(Success[str] &amp; Top[Error[Unknown]]) | Error[FileNotFoundError]</code>, which shows that it's not as narrow as you might think. The first part of the union (<code>Success[str] &amp; Top[Error[Unknown]]</code>) accounts for the possibility of common subclasses of <code>Success</code> and <code>Error</code>. To avoid this, you could make one or both of <code>Success</code> and <code>Error</code> <code>@final</code>, in which case the &quot;Cannot raise object of type&quot; error disappears.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/andythomas">@andythomas</a> on 2025-12-10 09:37</div>
            <div class="timeline-body"><p>Excellent, that works as intended. Thank you for the very quick help!</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 02:11:10 UTC
    </footer>
</body>
</html>
