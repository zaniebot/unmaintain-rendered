<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create separate representations for specialized and unspecialized function literals - astral-sh/ty #462</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Create separate representations for specialized and unspecialized function literals</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/astral-sh/ty/issues/462">#462</a>
        opened by <a href="https://github.com/dcreager">@dcreager</a>
        on 2025-05-20 16:24
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/dcreager">@dcreager</a></div>
            <div class="timeline-body"><p>We currently represent &quot;class literals&quot; and &quot;class types&quot; differently, which differ in how they handle generic classes. For a generic class, the class literal is unspecialized, and the class type is specialized.</p>
<p>We did not do the same thing for functions, thinking that it wasn't needed since specialized functions are ephemeral, only needed for the duration of checking a particular call of the specialized function. This is not true, though, for a method of a generic class, which should have the specialization of the class applied to its signature. (It's possible to &quot;persist&quot; this &quot;generic&quot; function via e.g. <code>C[int].method</code>.)</p>
<p>We should update the function representation to encode the same distinction. This will help with the property test failure in https://github.com/astral-sh/ty/issues/459.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">type properties</span> added by @AlexWaygood on 2025-05-20 17:59</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dcreager">@dcreager</a> on 2025-05-21 14:14</div>
            <div class="timeline-body"><p>Copying some notes from an in-person discussion we just had at the PyCon sprint.</p>
<p>It will be important to recognize that the inhabitants of a type are not &quot;runtime objects&quot;, they're &quot;runtime objects with some disambiguation (mumble mumble)&quot;. As a concrete example, given</p>
<pre><code class="language-py">class C[T]:
    @staticmethod
    def method(x: T) -&gt; None: ...
</code></pre>
<p><code>C[int].method</code> and <code>C[str].method</code> are runtime identical (same physical object; equivalent per <code>id()</code> and <code>is</code>). But they do not have the same behavior according to the type system, since <code>C[int].method(&quot;string&quot;)</code> is an invalid call but <code>C[str].method(&quot;string&quot;)</code> is valid. Since they have different behavior, they cannot be (type system) equivalent, nor subtypes of each other (in either direction), even though they are runtime equivalent. So runtime equivalence cannot be the same thing as type-system equivalence.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @carljm on 2025-11-14 14:42</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:19:57 UTC
    </footer>
</body>
</html>
