<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ty fails to enforce invariance and covariance rules for generic containers (List vs Sequence) - astral-sh/ty #1505</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>ty fails to enforce invariance and covariance rules for generic containers (List vs Sequence)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/1505">#1505</a>
        opened by <a href="https://github.com/FHaggs">@FHaggs</a>
        on 2025-11-09 12:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/FHaggs">@FHaggs</a></div>
            <div class="timeline-body">Summary
<p>https://play.ty.dev/54af2346-91e3-407f-a99f-bad9b19360ef</p>
<p>ty does not flag violations of Python’s type variance rules when using list and Sequence type hints.</p>
<p>Specifically:</p>
<p>List should be invariant</p>
<p>Sequence should be covariant</p>
<p>However, ty currently accepts code that passes list[Dog] where list[Animal] is expected which breaks type safety guarantees that every other checker (Pyright) enforces. Check the reference for more information.</p>
<p>Also the other way around does not flag an error.</p>
<pre><code>def imutable_thing(arr: list[Animal]) -&gt; int:
    return len(arr)
</code></pre>
<p>These should not accept a list[Dog], the function signature should be arr: Sequence[Animal]. That would be ok.</p>
<p>References:
https://peps.python.org/pep-0484/#covariance-and-contravariance</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-11-09 16:50</div>
            <div class="timeline-body"><p>Thanks for the report!</p>
<p>The issue here isn&#x27;t that ty doesn&#x27;t understand variance -- we do! Here&#x27;s your initial snippet, and you&#x27;re correct that we don&#x27;t emit any diagnostics on it:</p>
<pre><code>from typing import Sequence

class Animal:
    pass

class Dog(Animal):
    pass


def imutable_thing(arr: Sequence[Animal]) -&gt; int:
    return len(arr)

def mutable(arr: list[Animal]):
    arr.append(Animal())


a = [Animal(), Animal()]
d = [Dog(), Dog()]

res = imutable_thing(d)  # ✅ Should be fine (Sequence is covariant)
mutable(a)               # ✅ OK
mutable(d)               # ❌ Should FAIL — List is invariant
</code></pre>
<p>But if I apply this diff to your snippet...</p>
<pre><code>
```py
  from typing import Sequence

  class Animal:
      pass

  class Dog(Animal):
      pass


  def imutable_thing(arr: Sequence[Animal]) -&gt; int:
      return len(arr)

  def mutable(arr: list[Animal]):
      arr.append(Animal())


- a = [Animal(), Animal()]
- d = [Dog(), Dog()]
+ a: list[Animal] = [Animal(), Animal()]
+ d: list[Dog] = [Dog(), Dog()]

  res = imutable_thing(d)  # ✅ Should be fine (Sequence is covariant)
  mutable(a)               # ✅ OK
  mutable(d)               # ❌ Should FAIL — List is invariant
</code></pre>
<p>Then ty does indeed emit the diagnostic you&#x27;re expecting:</p>
<pre><code>error[invalid-argument-type]: Argument to function `mutable` is incorrect
  --&gt; foo.py:22:9
   |
20 | res = imutable_thing(d)  # ✅ Should be fine (Sequence is covariant)
21 | mutable(a)               # ✅ OK
22 | mutable(d)               # ❌ Should FAIL — List is invariant
   |         ^ Expected `list[Animal]`, found `list[Dog]`
   |
info: Function defined here
  --&gt; foo.py:13:5
   |
11 |     return len(arr)
12 |
13 | def mutable(arr: list[Animal]):
   |     ^^^^^^^ ----------------- Parameter declared here
14 |     arr.append(Animal())
   |
info: rule `invalid-argument-type` is enabled by default

Found 1 diagnostic
</code></pre>
<p>The issue is that without the explicit annotations, ty doesn&#x27;t infer the type of <code>a</code> as <code>list[Animal]</code> (it infers <code>list[Animal | Unknown]</code>) and doesn&#x27;t infer the type of <code>d</code> as <code>list[Dog]</code> (it infers <code>list[Dog | Unknown]</code>).</p>
<p>Correctly inferring the type of unannotated collection literals is a surprisingly hard problem. We know we need to do better here; the <code>| Unknown</code> union is a temporary measure to avoid false positives. One such false positive can be demonstrated from your example here: an equally valid inference for the <code>d</code> variable would be <code>list[Animal]</code> rather than <code>list[Dog]</code> -- no type checker has an issue if you provide <code>list[Animal]</code> as the annotation for that variable:</p>
<pre><code>from typing import Sequence

class Animal:
    pass

class Dog(Animal):
    pass


def imutable_thing(arr: Sequence[Animal]) -&gt; int:
    return len(arr)

def mutable(arr: list[Animal]):
    arr.append(Animal())


a: list[Animal] = [Animal(), Animal()]
d: list[Animal] = [Dog(), Dog()]

res = imutable_thing(d)  # ✅ Should be fine (Sequence is covariant)
mutable(a)               # ✅ OK
mutable(d)               # ❌ Should FAIL — List is invariant

</code></pre>
<ul>
<li><a href="https://mypy-play.net/?mypy=latest&amp;python=3.12&amp;gist=9382f8d13f715a0019eef13ff97b2aba">Mypy</a></li>
<li><a href="https://pyright-play.net/?pyrightVersion=1.1.405&amp;strict=true&amp;code=GYJw9gtgBALgngBwJYDsDmUkQWEMoDKApgI4CuRKAxkQLABQDVANgIYDO7UAgilq8wBcDKKKgIO7BkzacoAETBoAFL37MAlMPpjxk6Y3oATIsEwQyMVgCNmRAPowAFqhWsQIQYVIVqRANpqEAIAuhpQALQAfJgoMNq6IEQwZCAoUHYoyu4gGgYmZhZWtkTZHl7MSOwwgXzBzGEJYjkAdKwICJRGqnUCyhp5hgysFVU1QaFQALxQter9ADQ8vcz9IQxGo9Vz9SHTs4oqGkuHawZJXDNYljZ2ji7oykbhUADEUICg5IROYGTMRlBrEQoMBUMDlMRyJQaJguFQwAA3dxIVhxQZFW6lVgvXS43TvL4AeQA0gwMSUnji8Xj3oAZcm%2Bv3%2BUAAYtwAJIAGSggBQCKAcsaw2JIkAouIGIA">Pyright</a></li>
<li><a href="https://pyrefly.org/sandbox/?project=N4IgZglgNgpgziAXKOBDAdgEwEYHsAeAdAA4CeS4ATrgLYAEALqcROgOZ0Q3G6UN0BlGAEcArjHQBjGAB10cyVFRw4dAILouqKIjl19dYsrhyFSlXQAiuNgAoNWqAEpd6A4eOn5WGGE41RBlRsWAB9BgALVjtUSkpEQRFxKRgAbQcabQBdJzoAWgA%2BTnQGV3dKGAZRSjdYdFtYyicvTF86AKCQmAa4hKgIOAZ0zUyoHLKDRsJUYmIJTHsR7VsnZu85VD6BoYzsugBeOmHHFYAadSWoFay5TC3B49Gsg6PrOydzt%2BuvCtVDrkCwTCkWitkwuToAGI6IBQckEEVwoigmDo2BgdEg6HRtiEYgk0k4qkkuAAbrEIBgGGsOkDuqgIe5Ge5oXCAPIAaTkNK6YIZTKZ0MAMuTwxHIugAMTUAEkADJ0QAoBHQZdtCcUyZQKSUvCBTiBAtA4CRyIgQNCAKoMaAQJgY0RSS24dAmbytPxgXiZBihdCiGhoyi2fAJVhU-JFQbxPQGCpVGoYmQgAByvv9CWA%2BAAvgm5DqQGQKmAoKRCAxaFAKNCAAqkAtFuhoLB4fB0YnoSBsaqoB3oQhyaFCdERBgMYhwRAAenH%2Bd8RcIvDY44k48wuEkcHHrfbne744xvDoqDJ0FpLcdW8oXYgjrouGI3cNcjIkUdeRJMEocCvbkOCYAzIQAEYACZs3QEAM11VBJEtN9xWgGAKAbHACCNcCgA">Pyrefly</a></li>
</ul>
<p>So we can&#x27;t know exactly what the user intended without an explicit annotation. In situations like this, other type checkers either demand type annotations or make (what we consider to be) unwarranted assumptions regarding the user&#x27;s intent (for example, solving the type as <code>list[Dog]</code> even though <code>list[Animal]</code> would be an equally valid way to solve the type and would avoid a type error being emitted later on in the scope). We hope eventually to be able to use constraints and bidirectional inference to do better than other type checkers in this area -- but this is still some way off.</p>
<p>See <a href="https://github.com/astral-sh/ty/issues/1473">astral-sh/ty#1473</a> for more detail on our plans in this area.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-11-09 16:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/FHaggs">@FHaggs</a> on 2025-11-09 16:53</div>
            <div class="timeline-body"><p>Thank you for the explanation</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:25:55 UTC
    </footer>
</body>
</html>
