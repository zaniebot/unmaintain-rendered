<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type expression with string literal treated as the object it represents. - astral-sh/ty #2294</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Type expression with string literal treated as the object it represents.</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/2294">#2294</a>
        opened by <a href="https://github.com/inoa-jboliveira">@inoa-jboliveira</a>
        on 2025-12-31 19:18
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/inoa-jboliveira">@inoa-jboliveira</a></div>
            <div class="timeline-body">Summary
<p>I have this annotated int type in an application where it just records the name of the actual list of ints (it has some metadata of each number, so not a literal).</p>
<pre><code>from typing import Annotated

foo: Annotated[int, &#x27;FOO&#x27;]

class ChoiceType:
    def __class_getitem__(cls, choice_name: str):
        return Annotated[int, choice_name]

foo: ChoiceType[&#x27;FOO&#x27;]
</code></pre>
<pre><code>$ uvx ty check
error[unresolved-reference]: Name `FOO` used when not defined
 --&gt; foo.py:9:18
  |
7 |         return Annotated[int, choice_name]
8 |
9 | foo: ChoiceType[&#x27;FOO&#x27;]
  |                  ^^^^^
  |
info: rule `unresolved-reference` is enabled by default

Found 1 diagnostic
</code></pre>
<p>If I import the name, it will complain that such object shall not be used in a type literal or whatever.</p>
<p>The point is. Why is it trying to convert a literal string into the value it represents?</p>
<p>I understand this an edge case, but I was hoping these 2 were equivalent</p>
<pre><code>foo: Annotated[int, &#x27;FOO&#x27;]
foo: ChoiceType[&#x27;FOO&#x27;]
</code></pre>
<p>The &#x27;FOO&#x27; from Annotated is treated as a literal</p>
Version
<p>ty 0.0.8 (aa7559db8 2025-12-29)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2026-01-06 01:27</div>
            <div class="timeline-body"><p>Thanks for trying ty!</p>
<p>The syntax of type annotations is <a href="https://typing.python.org/en/latest/spec/annotations.html#type-and-annotation-expressions">quite constrained</a>; the type system won&#x27;t let you put arbitrary dynamic code into a type annotation (although runtime will, mostly). No other type checker handles this in the way you are hoping for, either.</p>
<p>In a type annotation, subscript syntax always and only means a generic type with a type argument (or a known special form, like <code>Annotated</code>, <code>Literal</code>, etc), but <code>ChoiceType</code> is not a known special form and not a generic type (it doesn&#x27;t inherit <code>typing.Generic</code> or use PEP 695 <code>class ChoiceType[T]</code> syntax).</p>
<p>A string in a type expression means a <a href="https://typing.python.org/en/latest/spec/annotations.html#string-annotations">string annotation</a>: this is the old (pre Python 3.14) way to enable forward references. This is why type checkers interpret the <code>&quot;FOO&quot;</code> in your annotation as a reference to something named <code>FOO</code>.</p>
<p>So ty is working as expected here -- the Python static type system just isn&#x27;t designed to do what you are asking it to do.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/carljm">@carljm</a> on 2026-01-06 01:27</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:26:52 UTC
    </footer>
</body>
</html>
