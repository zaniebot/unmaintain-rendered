<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Prefer declared attribute on base class over inferred attribute on subclass - astral-sh/ty #1067</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Prefer declared attribute on base class over inferred attribute on subclass</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/1067">#1067</a>
        opened by <a href="https://github.com/jankatins">@jankatins</a>
        on 2025-08-20 20:37
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/jankatins">@jankatins</a></div>
            <div class="timeline-body">Summary
<p>We use some descriptor (like) classes and basically have an attribute set by <code>__set_name__</code>  (https://docs.python.org/3/reference/datamodel.html#object.<strong>set_name</strong>)</p>
<p>This is a boiled down example:</p>
<pre><code>from typing import Any


class Mixin:
    name: str


class Concrete(Mixin):
    def __init__(self) -&gt; None:
        self.name = None  # type: ignore[assignment]

    def __set_name__(self, owner: Any, name: str) -&gt; None:
        self.name = name

class X:
    c = Concrete()

x = X()
# mypy is ok here, but ty chokes on it
print(x.c.name.upper()) # prints &quot;C&quot;

</code></pre>
<p>mypy trusts the declaration in the mixin and allows accessing the attribute unconditionally, but ty seems does not see the descriptor protocol (and does not trust the explicit typing info) and assumes the attribute is not set:</p>
<pre><code>λ  python test.py      
C

λ  mypy test.py        
Success: no issues found in 1 source file

λ  uvx ty check test.py
WARN ty is pre-release software and not ready for production use. Expect to encounter bugs, missing features, and fatal errors.
Checking ------------------------------------------------------------ 1/1 files                                                                                                                                                                                                                                     warning[possibly-unbound-attribute]: Attribute `upper` on type `Unknown | str | None` is possibly unbound                                                                                                                                                                                                           
  --&gt; test.py:20:7
   |
18 | x = X()
19 | # mypy is ok here, but ty chokes on it
20 | print(x.c.name.upper()) # prints &quot;C&quot;
   |       ^^^^^^^^^^^^^^
   |
info: rule `possibly-unbound-attribute` is enabled by default

Found 1 diagnostic
</code></pre>
<p>Given that I do quite a lot of <code>c.name</code> like usages, I would really avoid having to check every place for None... :-)</p>
Version
<p>ty 0.0.1-alpha.19</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/carljm">@carljm</a> on 2025-08-20 21:52</div>
            <div class="timeline-body"><p>Thanks for the report! This is definitely a bug. I think the descriptor protocol and <code>__set_name__</code> are unrelated, though. We look at all assignments to the name in all methods, we won&#x27;t handle <code>__set_name__</code> any different from any other method in that regard.</p>
<p>Here&#x27;s an <a href="https://play.ty.dev/88cd3d79-9c3f-4058-bd6b-f5d797080ea4">even more simplified example</a> (edit by @sharkdp: modified the example to let <code>B</code> actually derive from <code>A</code>) of the bug. There are really two bugs there: one is that we should error on <code>self.name = None</code> (that&#x27;s already tracked in #166), and the other is that if you ignore that error (as your example does), we should still prefer the declared type from the base class: we should not include the type from the bad assignment, and we should also not union with <code>Unknown</code>, because the attribute is declared on the base class.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;Beta&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-08-20 21:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Attribute set by __set_name__()  is not seen and typing not trusted&quot; to &quot;Prefer declared attribute on base class over inferred attribute on subclass&quot; by <a href="https://github.com/carljm">@carljm</a> on 2025-08-20 21:52</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/sharkdp">@sharkdp</a> by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-08-22 13:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/sharkdp">@sharkdp</a> on 2025-10-13 07:28</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:25:22 UTC
    </footer>
</body>
</html>
