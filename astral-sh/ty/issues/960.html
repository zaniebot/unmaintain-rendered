<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incorrect type narrow/infer when creating dict with `dict(key=value)` (not for `{&quot;key&quot;:value}`) - astral-sh/ty #960</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Incorrect type narrow/infer when creating dict with <code>dict(key=value)</code> (not for <code>{&quot;key&quot;:value}</code>)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/960">#960</a>
        opened by <a href="https://github.com/DanielYang59">@DanielYang59</a>
        on 2025-08-09 20:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/DanielYang59">@DanielYang59</a> on 2025-08-09 20:06</div>
            <div class="timeline-body"><h3>Summary</h3>
<p>Seems like a bug (if I understand everything correctly) regarding type narrowing of dict with <code>dict()</code> interface.</p>
<pre><code class="language-python">from typing import Any


name: str = &quot;hello&quot;
d: dict[str, Any] = dict(name=name)  # {&quot;name&quot;: name} wouldn't
d[&quot;age&quot;] = 0
</code></pre>
<p>Triggers:</p>
<pre><code>error[invalid-assignment]: Method `__setitem__` of type `bound method dict[str, str].__setitem__(key: str, value: str, /) -&gt; None` cannot be called with a key of type `Literal[&quot;age&quot;]` and a value of type `Literal[0]` on object of type `dict[str, str]`
 --&gt; debug.py:6:1
  |
4 | name: str = &quot;hello&quot;
5 | d: dict[str, Any] = dict(name=name)  # {&quot;name&quot;: name} wouldn't
6 | d[&quot;age&quot;] = 0
  | ^
  |
info: rule `invalid-assignment` is enabled by default

Found 1 diagnostic
</code></pre>
<h3>Version</h3>
<p>ty 0.0.1-alpha.17 (1712284c8 2025-08-06)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DanielYang59">@DanielYang59</a> on 2025-08-09 20:22</div>
            <div class="timeline-body"><p>Noticed another issue related to using <code>dict()</code> instead of <code>{}</code>:</p>
<pre><code class="language-python">inner_list = &quot;hello world&quot;.split()  # noqa:SIM905

out_dict = dict(hello=inner_list)  # {&quot;hello&quot;: inner_list} wouldn't
</code></pre>
<p>Gives (again using <code>{}</code> wouldn't trigger any issue):</p>
<pre><code>error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
 --&gt; debug.py:3:17
  |
1 | inner_list = &quot;hello world&quot;.split()  # noqa:SIM905
2 |
3 | out_dict = dict(hello=inner_list)  # {&quot;hello&quot;: inner_list} wouldn't
  |                 ^^^^^^^^^^^^^^^^ Expected `list[str]`, found `list[LiteralString]`
  |
info: Matching overload defined here
    --&gt; stdlib/builtins.pyi:2907:9
     |
2905 |     def __init__(self) -&gt; None: ...
2906 |     @overload
2907 |     def __init__(self: dict[str, _VT], **kwargs: _VT) -&gt; None: ...  # pyright: ignore[reportInvalidTypeVarUse]  #11780
     |         ^^^^^^^^                       ------------- Parameter declared here
2908 |     @overload
2909 |     def __init__(self, map: SupportsKeysAndGetItem[_KT, _VT], /) -&gt; None: ...
     |
info: Non-matching overloads for bound method `__init__`:
info:   (self) -&gt; None
info:   (self, map: SupportsKeysAndGetItem[_KT@dict, _VT@dict], /) -&gt; None
info:   (self: dict[str, _VT@dict], map: SupportsKeysAndGetItem[str, _VT@dict], /, **kwargs: _VT@dict) -&gt; None
info:   (self, iterable: Iterable[tuple[_KT@dict, _VT@dict]], /) -&gt; None
info:   (self: dict[str, _VT@dict], iterable: Iterable[tuple[str, _VT@dict]], /, **kwargs: _VT@dict) -&gt; None
info:   (self: dict[str, str], iterable: Iterable[list[str]], /) -&gt; None
info:   (self: dict[bytes, bytes], iterable: Iterable[list[bytes]], /) -&gt; None
info: rule `invalid-argument-type` is enabled by default
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[invalid-assignment] Incorrect type narrowing when creating dict with `dict(key=value)`" to "[invalid-assignment] Incorrect type narrowing when creating dict with `dict(key=value)` instead of `{"key":value}`" by @DanielYang59 on 2025-08-09 20:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[invalid-assignment] Incorrect type narrowing when creating dict with `dict(key=value)` instead of `{"key":value}`" to "[invalid-assignment] Incorrect type narrow/infer when creating dict with `dict(key=value)` instead of `{"key":value}`" by @DanielYang59 on 2025-08-09 20:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/DanielYang59">@DanielYang59</a> on 2025-08-09 20:29</div>
            <div class="timeline-body"><p>One more related bug:</p>
<pre><code class="language-python">d: dict[str, str | float] = dict(width=1.5)
</code></pre>
<pre><code>error[invalid-assignment]: Object of type `dict[str, float]` is not assignable to `dict[str, str | int | float]`
 --&gt; debug.py:1:1
  |
1 | d: dict[str, str | float] = dict(width=1.5)
  | ^
  |
info: rule `invalid-assignment` is enabled by default
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[invalid-assignment] Incorrect type narrow/infer when creating dict with `dict(key=value)` instead of `{"key":value}`" to "[invalid-assignment] Incorrect type narrow/infer when creating dict with `dict(key=value)` (not for `{"key":value}`)" by @DanielYang59 on 2025-08-09 20:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "[invalid-assignment] Incorrect type narrow/infer when creating dict with `dict(key=value)` (not for `{"key":value}`)" to "Incorrect type narrow/infer when creating dict with `dict(key=value)` (not for `{"key":value}`)" by @DanielYang59 on 2025-08-09 20:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MatthewMckee4">@MatthewMckee4</a> on 2025-08-10 20:56</div>
            <div class="timeline-body"><p>This is due to the fact that we infer <code>dict(name=name)</code> as <code>dict[str, str]</code>, and the <code>dict[str, Any]</code> does not take priority because <code>dict[str, str]</code> is not a <a href="https://typing.python.org/en/latest/spec/concepts.html#gradual-types">gradual type</a>.</p>
<p>If you need this to work with the <code>dict</code> builtin, then you can do <code>d = dict[str, Any](name=name)</code> provided you are on python 3.9 or greater.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2025-08-10 21:03</div>
            <div class="timeline-body"><p>Ideally we would use the user-supplied declaration as &quot;type context&quot; to take into account when solving the TypeVars in the <code>dict</code> constructor calls; this would avoid the false positives at the places where the keys are set later on. This is also known as &quot;bidirectional type inference&quot;, and it's something both mypy and pyright are capable of, so it's definitely something we should aspire to do as well, but it requires some design from us. See https://github.com/astral-sh/ty/issues/168.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @AlexWaygood on 2025-08-11 13:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bidirectional inference</span> added by @AlexWaygood on 2025-08-11 13:30</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-11-04 22:13</div>
            <div class="timeline-body"><p>These two snippets are examples of https://github.com/astral-sh/ty/issues/1228, which will be fixed by https://github.com/astral-sh/ruff/pull/20933:</p>
<pre><code class="language-py">from typing import Any

def _(key: str):
    a: dict[str, Any] = dict(key=key)
    a[key] = 0
</code></pre>
<pre><code class="language-py">b: dict[str, str | float] = dict(width=1.5)
</code></pre>
<p>The last example I think is actually the correct diagnostic, and is unrelated to <code>dict</code>:</p>
<pre><code class="language-py"># error: expected `list[str]`, found `list[LiteralString]`
x: list[str] = &quot;hello world&quot;.split()
</code></pre>
<p>Pyright also errors in this case. I guess we <em>could</em> promote the literal string based on the type annotation, but I'm not at all sure how that would work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ibraheemdev">@ibraheemdev</a> on 2025-11-12 19:19</div>
            <div class="timeline-body"><p>Confirmed that the first two examples are fixed on main.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @ibraheemdev on 2025-11-12 19:19</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 11:40:18 UTC
    </footer>
</body>
</html>
