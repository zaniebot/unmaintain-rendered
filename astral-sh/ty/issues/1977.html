<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generic type parameter incorrectly inferred from `Callable[[S], T | None]` as `T | None` instead of `T` - astral-sh/ty #1977</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Generic type parameter incorrectly inferred from <code>Callable[[S], T | None]</code> as <code>T | None</code> instead of <code>T</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/astral-sh/ty/issues/1977">#1977</a>
        opened by <a href="https://github.com/fadedDexofan">@fadedDexofan</a>
        on 2025-12-17 05:47
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/fadedDexofan">@fadedDexofan</a></div>
            <div class="timeline-body"><h2>Summary</h2>
<p>When a generic class has two parameters that share a type variable <code>T</code>:</p>
<ul>
<li><code>extractor: Callable[[S], T | None]</code></li>
<li><code>inner: Specification[T]</code></li>
</ul>
<p>ty incorrectly infers <code>T</code> from the Callable's return type as <code>T | None</code>, ignoring the concrete <code>T</code> from the <code>Specification[T]</code> argument.</p>
<p><strong>Expected:</strong> <code>T = int</code> (from <code>GreaterThanSpec</code> which is <code>Specification[int]</code>)
<strong>Actual:</strong> <code>T = int | None</code> (from <code>Callable[[Container], int | None]</code>)</p>
<p>mypy correctly infers <code>T = int</code>.</p>
<h2>Minimal Reproduction</h2>
<p><a href="https://play.ty.dev/dc5ccb2a-a953-4fa2-bef6-96cdd466a1bb">Ty playground link</a>
<a href="https://mypy-play.net/?mypy=latest&amp;python=3.14&amp;flags=strict&amp;gist=a1a4f9b57096163feedf6302549b4e69">MyPy playground link</a></p>
<pre><code class="language-python">from abc import ABC, abstractmethod
from collections.abc import Callable


class Specification[T](ABC):
    @abstractmethod
    def is_satisfied_by(self, candidate: T, /) -&gt; bool:
        pass

    def via[S](self, extractor: Callable[[S], T | None]) -&gt; Specification[S]:
        return LiftSpec(extractor, self)


class LiftSpec[S, T](Specification[S]):
    def __init__(
        self,
        extractor: Callable[[S], T | None],
        inner: Specification[T],
    ) -&gt; None:
        self._extractor = extractor
        self._inner = inner

    def is_satisfied_by(self, candidate: S, /) -&gt; bool:
        extracted = self._extractor(candidate)
        return extracted is not None and self._inner.is_satisfied_by(extracted)


class GreaterThanSpec(Specification[int]):
    def __init__(self, threshold: int) -&gt; None:
        self._threshold = threshold

    def is_satisfied_by(self, candidate: int, /) -&gt; bool:
        return candidate &gt; self._threshold


class Container:
    def __init__(self, value: int | None) -&gt; None:
        self.value = value


def extract_value(c: Container) -&gt; int | None:
    return c.value


# All three should work - T should be inferred as `int` from GreaterThanSpec
spec1 = LiftSpec(extract_value, GreaterThanSpec(5))  # ty error
spec2 = GreaterThanSpec(10).via(extract_value)       # ty error  
spec3 = LiftSpec[Container, int](extract_value, GreaterThanSpec(5))  # works with explicit params

reveal_type(spec1)
reveal_type(spec2)
reveal_type(spec3)
</code></pre>
<h2>ty output</h2>
<pre><code>error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --&gt; repro.py:26:16
   |
25 |     def via[S](self, extractor: Callable[[S], T | None]) -&gt; Specification[S]:
26 |         return LiftSpec(extractor, self)
   |                         ^^^^^^^^^ Expected `(S@via, /) -&gt; None`, found `(S@via, /) -&gt; T@Specification | None`

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --&gt; repro.py:26:27
   |
26 |         return LiftSpec(extractor, self)
   |                                    ^^^^ Expected `Specification[None]`, found `Self@via`

error[invalid-argument-type]: Argument to bound method `__init__` is incorrect
  --&gt; repro.py:51:32
   |
51 | spec1 = LiftSpec(extract_value, GreaterThanSpec(5))
   |                                 ^^^^^^^^^^^^^^^^^^ Expected `Specification[int | None]`, found `GreaterThanSpec`
</code></pre>
<h2>mypy output</h2>
<p>Passes with no errors. <code>reveal_type</code> shows correct inference:</p>
<pre><code>Revealed type is &quot;LiftSpec[Container, int]&quot;
</code></pre>
<h2>Version</h2>
<pre><code>Python 3.14.2
ty 0.0.2 (42835578d 2025-12-16)
mypy 1.19.1
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Generic type parameter incorrectly inferred from Callable[[S], T | None] as T | None instead of T" to "Generic type parameter incorrectly inferred from `Callable[[S], T | None]` as `T | None` instead of `T`" by @fadedDexofan on 2025-12-17 05:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">generics</span> added by @AlexWaygood on 2025-12-17 07:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "Stable" by @AlexWaygood on 2025-12-17 07:45</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/AlexWaygood">@AlexWaygood</a> on 2026-01-18 12:33</div>
            <div class="timeline-body"><p>Fixed in https://github.com/astral-sh/ruff/pull/22495</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @AlexWaygood on 2026-01-18 12:33</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-18 13:11:56 UTC
    </footer>
</body>
</html>
