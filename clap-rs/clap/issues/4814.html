<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for &quot;nested commands&quot; (as defined in the description) or &quot;Parsing from the string&quot; as opposed to `sys.env` - clap-rs/clap #4814</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for &quot;nested commands&quot; (as defined in the description) or &quot;Parsing from the string&quot; as opposed to <code>sys.env</code></h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/4814">#4814</a>
        opened by <a href="https://github.com/Davoodeh">@Davoodeh</a>
        on 2023-03-31 14:17
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Davoodeh">@Davoodeh</a></div>
            <div class="timeline-body">Please complete the following tasks
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
Clap Version
<p>4.2.1</p>
Regarding Issue/Discussions search
<p>First off, I am not sure if I actually made a good job searching in the issues. I skimmed through the results of queries for &quot;String&quot;, &quot;Nested&quot;, &quot;Extend&quot; and some other keywords in both issues and discussions (all states, closed and open). I could not find anything related. If I missed it, or if this is not in match with the scope or philosophy of the project, I sincerely apologize.</p>
Describe your use case
Use case
<p>Imagine somebody wrote an argparser for an application crate which we want to include in our program. So the example is that we want to <code>use</code> (as in import, not as in edit) somebody else&#x27;s source + clap argparser in our code. Doesn&#x27;t matter why we just do.</p>
<p>This is VERY similar to &quot;subcommand&quot; option. However with a twist, it is not possible for us to edit the source of the <code>Args</code> struct they wrote. So we need to use it as as a subcommand but without doing it in a traditional clap sense. There is no way to add <code>Subcommand</code> drive to the struct.</p>
<p><img src="https://www.plantuml.com/plantuml/dsvg/XLBDRjH03BxFKtpQ2rBPx0DmGEq1YLue4kNUISPDHioCLsEdeKAyEsCboueWmIMAxS_VZvDRKLzrpiaDoOlWmtUbMdo25nn-5vyhZzNd0tuu0DqLTLT7SJ_TjlmmLu4jjfVTpbiRhl1_CToNywmhnrUXkjMDmo25bT2pAcVmypPpzqMKVB1ENBT7ZcL4Y9K6JQzGXaw4VPWt0jC-kiU9NjjEmvd7tVY4EmnKrSU2v-H7a_aRvGPVq1E4C-bawYb-8pnr7MsgJrYcE4nOOaeDkRcZS75tmQsYBHIujIiMha6EVvuBKN3pwU7n1XuozmFdx4lOEOEr5a9pLbWTXQY8AXWua8bctmos7XSwuIClz4BrQ8t92om7B0e7WKvULtYB9ZYpIEmJdHoLqAZ9kUshTU_DWBZsiE9g-XqENupnnQUPn8nU3_F_Yvot7ydTDi4vfry0" alt="Example Diagram (code in )"></p>

<pre>
@startuml
class External as &quot;External Program&quot; {
   - External Args
}

<p>class Ours as &quot;Our Program&quot; {</p>
<ul>
<li>Our Args</li>
</ul>
<ul>
<li>External Args
}</li>
</ul>
<p>class Inputs as &quot;User Inputs&quot; {
}</p>
<p>note bottom of Inputs
Instead of inputs going directly to the External Program&#x27;s Args,
They go to Our Program&#x27;s Args. A certain flag of Our Program&#x27;s Args
can be something like <code>--external</code> which will be directed to the external Args.
In other words, External Args is <em>NOT</em> a subcommand of Our Program and we cannot
edit its code to make it one. However, it has some methods that make this possible.
endnote</p>
<p>Inputs -&gt; Ours
Ours -&gt; External : &quot;Some values of --external will be directed to the external program&quot;
@enduml
</pre></p>


<p>The code will look somethine like this:</p>
<pre><code>// in external.rs
#[derive(Parse)
pub struct Args {
   // whatever
}
</code></pre>
<pre><code>// in main.rs
use external::Args as ExternalArgs;

#[derive(Parse)]
pub struct  Args {
  #[arg(long, external_sub_command_without_a_subcommand_derive)]
  external: ExternalArgs,
  // whatever
}
</code></pre>
After that (future)
<p>Maybe after this we can flatten it as well! Meaning there is no need to write <code>--external</code> to pass everything to the external parser and it will just work if the fields do not intersect.</p>
Why?
<p>The actual feature does not matter! Trying to do this I noticed there are two more important underlying problems with Clap which lead to the user not being able to this (assuming there are no ways and it&#x27;s not just me not knowing how to do these):</p>
<ol>
<li>There is no way to call <code>Args::parse()</code> (in drive mode or its equivalent in functional mode) on a string. This method only takes the inputs from <code>env</code>.</li>
<li>The nesting subcommands is not intuitive and it is not a general solution. As demonstrated, the current implementation does not resolve such niche cases.</li>
</ol>
<p>Regardless, it can have benefits like code reusability. The real problem I had is that I&#x27;m providing a <code>commons</code> library crate which has a series of common utilities a series of binary microservices can benefit from. If there is a feature like this in Clap, I can also provide a bare bone common argparser (some sort of standard argument set for every microservice binary) which every implementation can expand upon if needed.</p>
Describe the solution you&#x27;d like
<p>So as I explained in the previous section, there are two ways to make such a sub-command inclusion work.
First, to tamper with the current implementation of the <code>Subcommand</code>. Second, to add a <code>Args::parse_from_string(s: &amp;str) -&gt; Result&lt;Self&gt;</code> method that does not rely on <code>env</code>, also doesn&#x27;t cause any side-effects (terminates the program early).</p>
<p>In the builder method, this would look something like <code>Argparser.get_matches_from_string(&amp;str) -&gt; Result&lt;Whatever&gt;</code>.</p>
<p>I think the second feature is an absolute must! Regardless of the use case I have here. If implemented, the user can do something like this to fix my usecase:</p>
<pre><code>use external::Args as ExternalArgs;

#[derive(From, Into)]
enum ExternalArgsHolder {
  Struct(ExternalArgs),
  String(String),
}

#[derive(Parser)]
struct Args {
    #[long]
    external: ExternalArgsHolder,
}

impl Args {
    pub fn parse() -&gt; Result&lt;Self&gt; {
        let mut candidate = &lt;Self as Parser&gt;::parse();
        let external = ExternalArgs::parse_from_string(
            candidate
                .external
                .try_into()
                .expect(&quot;just received string so we are sure it gets converted to &amp;str&quot;),
        )?;
        candidate.external = ExternalArgsHolder::Struct(external);
        Ok(candidate)
    }
}
</code></pre>
<p>P.S: Again I&#x27;m sorry if what I wrote doesn&#x27;t make sense or if it&#x27;s unrelated. I couldn&#x27;t put it to words better than this. I&#x27;d appreciate any constructive questions that help me clarify the examples and text better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by <a href="https://github.com/Davoodeh">@Davoodeh</a> on 2023-03-31 14:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-03-31 15:33</div>
            <div class="timeline-body"><p>There are several parts to this that aren&#x27;t quite clear to me.  Hopefully clarifying some specific points will help us get on the same page.</p>
<p>First, I want to clarify something about <code>Parser:s::parse</code>.  I&#x27;d recommend checking out the <a href="https://docs.rs/clap/latest/clap/trait.Parser.html">trait definition</a> as there are many variants of that, like <code>try_parse</code> (return the error), <code>parse_from</code> (parses an in-memory value, rather than <code>std::env::args_os</code>), and <code>try_parse_from</code>.  The reason we don&#x27;t support parsing a <code>&amp;str</code> is because that has a lot of shell-specific logic in it (quoting, globbing, etc).  With that said, the <a href="https://docs.rs/clap/latest/clap/_derive/_cookbook/repl/index.html">repl cookbook example</a> does show one way you can do that.</p>
<p>Second, so long as the foreign type implements the clap types, nothing extra is needed.  You can directly <code>flatten</code> the type into your struct.  You can also define your own subcommands and flatten into that.  Say you don&#x27;t even have access to a type that is compatible with the derive but you have an opaque argument parser.  In that case, you can capture the argments with <code>trailing_var_arg</code> + <code>allow_hyphen_values</code> or external subcommands and then take the collected values and pass them along to the external parser.  Think <code>cargo run --manifest-path Cargo.toml -- --help</code>, cargo is using clap to capture <code>--help</code> and pass it along to your binary.  The <code>--</code> is needed to disambiguate whether <code>--help</code> refers to <code>cargo</code> or your program.  You don&#x27;t need <code>--</code> for positionals (think <code>cargo test filter</code>, <code>filter</code> gets forwarded to your test binary).  If you don&#x27;t want to require <code>--</code> then that is where external subcommands come in handy which cargo uses today for <code>cargo</code> plugins like <code>cargo release --help</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Davoodeh">@Davoodeh</a> on 2023-03-31 16:50</div>
            <div class="timeline-body"><p>@epage Thank you for your fast and detailed answer</p>
<p>There is A LOT that I don&#x27;t know about Clap. I hoped that my initial issue reflect that.</p>
<p>I appreciate your useful links. I close this issue for now, till I check out the links and I will compose a new answer and reopen the issue (or simply post what I learned here for a future reference and keep it closed) after I got a conclusion. I&#x27;ll be back either with more questions or more answers/examples.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/Davoodeh">@Davoodeh</a> on 2023-03-31 16:50</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:59:43 UTC
    </footer>
</body>
</html>
