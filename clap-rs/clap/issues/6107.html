<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Native completions have incorrect behavior when completing in the middle with `sudo` - clap-rs/clap #6107</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Native completions have incorrect behavior when completing in the middle with `sudo`</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/6107">#6107</a>
        opened by <a href="https://github.com/epage">@epage</a>
        on 2025-08-19 13:31
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/epage">@epage</a> on 2025-08-19 13:31</div>
            <div class="timeline-body"><h3>Problem</h3>
<p><code>cargo</code> does not complete correctly when I try to complete <em>in the middle</em> with <code>sudo</code> using the <code>native-completions</code> feature.</p>
<h3>Steps</h3>
<ol>
<li>Run <code>source &lt;(CARGO_COMPLETE=bash cargo +nightly)</code> to ensure that we're using <code>native-completions</code> feature</li>
<li>Create a cargo project with two examples, <code>apple</code> and <code>banana</code></li>
<li>Invoke completion like this:</li>
</ol>
<pre><code class="language-bash">cargo build --example ap&lt;TAB&gt; --example banana
</code></pre>
<ol start="4">
<li>Notice that we've got the correct result:</li>
</ol>
<pre><code class="language-bash">cargo build --example apple --example banana
</code></pre>
<ol start="5">
<li>Prepend with <code>sudo</code> and invoke completion again:</li>
</ol>
<pre><code class="language-bash">sudo cargo build --example ap&lt;TAB&gt; --example banana
</code></pre>
<ol start="6">
<li>Notice that we've got the wrong result:</li>
</ol>
<pre><code class="language-bash">sudo cargo build --example banana --example banana
</code></pre>
<h3>Possible Solution(s)</h3>
<p><em>No response</em></p>
<h3>Notes</h3>
<p>Completions by <code>rustup completions bash</code> are correct in both cases, and this bug only occurs when using completions by <code>CARGO_COMPLETE=bash cargo +nightly</code>.</p>
<h3>Version</h3>
<pre><code class="language-text">$ cargo +nightly version --verbose
cargo 1.91.0-nightly (71eb84f21 2025-08-17)
release: 1.91.0-nightly
commit-hash: 71eb84f21aef43c07580c6aed6f806a6299f5042
commit-date: 2025-08-17
host: x86_64-unknown-linux-gnu
libgit2: 1.9.1 (sys:0.20.2 vendored)
libcurl: 8.14.1-DEV (sys:0.4.82+curl-8.14.1 vendored ssl:OpenSSL/3.5.0)
ssl: OpenSSL 3.5.0 8 Apr 2025
os: Ubuntu 24.4.0 (noble) [64-bit]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">E-hard</span> added by @epage on 2025-08-19 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-completion</span> added by @epage on 2025-08-19 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">E-help-wanted</span> added by @epage on 2025-08-19 13:31</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-lang/cargo/issues/15862.html">rust-lang/cargo#15862</a> on 2025-08-19 13:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2025-08-19 13:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Incorrect behavior when completing in the middle with `sudo`" to "Incorrect behavior when completing in the middle with `sudo` (native competions)" by @epage on 2025-08-19 13:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Incorrect behavior when completing in the middle with `sudo` (native competions)" to "Native completions have incorrect behavior when completing in the middle with `sudo`" by @epage on 2025-08-19 13:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-19 13:34</div>
            <div class="timeline-body"><p>In figuring this out, maybe we'd gain insights into how to resolve #5653</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-19 14:31</div>
            <div class="timeline-body"><p>Hi @epage, following up with our discussion, I will like to take on this. Thank you.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-20 11:45</div>
            <div class="timeline-body"><p>Hi @epage, I am already looking towards the issue,</p>
<p>The main cause of the issue is mostly because, the Native was setup only for when the command starts with Cargo but, was not setup when the command start with sudo. I guess the solution will be to find where the completion is defined or implemented, and implement it for Sudo scenerio.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-20 14:30</div>
            <div class="timeline-body"><p>Also @epage, I am guessing the reason why the issue is open against clap is because the cargo uses a library from the clap ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-20 15:50</div>
            <div class="timeline-body"><blockquote>
<p>The main cause of the issue is mostly because, the Native was setup only for when the command starts with Cargo but, was not setup when the command start with sudo. I guess the solution will be to find where the completion is defined or implemented, and implement it for Sudo scenerio.</p>
</blockquote>
<p>Maybe I'm missing something but that seems to be re-framing the symptom while the root cause still needs to be determined.</p>
<p>It appears that <code>sudo</code> can tell bash to delegate completions to another program (like we want in #5653).  What does this look like to our completer?  How is this normally expected to work in completers?</p>
<blockquote>
<p>I am guessing the reason why the issue is open against clap is because the cargo uses a library from the clap ?</p>
</blockquote>
<p>Yes, cargo is using <code>clap_complete::env</code> to handle completions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-21 18:46</div>
            <div class="timeline-body"><p>Hi @epage,</p>
<p>So, I have made some attempt in figuring out what the problem is with when <code>sudo</code> is placed at the front of the <code>cargo</code>,</p>
<p>Basically when someone run</p>
<p><code>source &lt;(CARGO_COMPLETE=bash cargo +nightly)</code></p>
<p>this part of the command is used</p>
<p>https://github.com/rust-lang/cargo/blob/master/src/bin/cargo/main.rs#L43</p>
<pre><code>    if nightly_features_allowed {
        let _span = tracing::span!(tracing::Level::TRACE, &quot;completions&quot;).entered();
        let args = std::env::args_os();
        let current_dir = std::env::current_dir().ok();
        let completer = clap_complete::CompleteEnv::with_factory(|| {
            let mut gctx = GlobalContext::default().expect(&quot;already loaded without errors&quot;);
            cli::cli(&amp;mut gctx)
        })
        .var(&quot;CARGO_COMPLETE&quot;);
        if completer
            .try_complete(args, current_dir.as_deref())

</code></pre>
<p>and the above basically make a call to clap</p>
<pre><code> pub fn try_complete(
        self,
        args: impl IntoIterator&lt;Item = impl Into&lt;OsString&gt;&gt;,
        current_dir: Option&lt;&amp;std::path::Path&gt;,
    ) -&gt; clap::error::Result&lt;bool&gt; {
        self.try_complete_(args.into_iter().map(|a| a.into()).collect(), current_dir)
    }

    fn try_complete_(
        self,
        mut args: Vec&lt;OsString&gt;,
        current_dir: Option&lt;&amp;std::path::Path&gt;,
    ) -&gt; clap::error::Result&lt;bool&gt; {
        let Some(name) = std::env::var_os(self.var) else {
            return Ok(false);
        };
        if name.is_empty() || name == &quot;0&quot; {
            return Ok(false);
        }

        // Ensure any child processes called for custom completers don't activate their own
        // completion logic.
        std::env::remove_var(self.var);

        let shell = self.shell(std::path::Path::new(&amp;name))?;

        let mut cmd = (self.factory)();
        cmd.build();

        let completer = args.remove(0);
        let escape_index = args
            .iter()
            .position(|a| *a == &quot;--&quot;)
            .map(|i| i + 1)
            .unwrap_or(args.len());
        args.drain(0..escape_index);
        if args.is_empty() {
            let mut buf = Vec::new();
            self.write_registration(&amp;cmd, current_dir, shell, completer, &amp;mut buf)?;
            std::io::stdout().write_all(&amp;buf)?;
        } else {
            let mut buf = Vec::new();
            shell.write_complete(&amp;mut cmd, args, current_dir, &amp;mut buf)?;
            std::io::stdout().write_all(&amp;buf)?;
        }

</code></pre>
<p>at this point, the <code>if args.is_empty()</code> will be true and <code>self.write_registration()</code> will be called and this will make a call to <code>shell.write_registration()</code></p>
<p>https://github.com/clap-rs/clap/blob/master/clap_complete/src/env/mod.rs#L245</p>
<p>and <code>shell.write_registration()</code> basically makes a create a shell program</p>
<pre><code>        let script = r#&quot;
_clap_complete_NAME() {
    local IFS=$'\013'
    local _CLAP_COMPLETE_INDEX=${COMP_CWORD}
    local _CLAP_COMPLETE_COMP_TYPE=${COMP_TYPE}
    if compopt +o nospace 2&gt; /dev/null; then
        local _CLAP_COMPLETE_SPACE=false
    else
        local _CLAP_COMPLETE_SPACE=true
    fi
    local words=(&quot;${COMP_WORDS[@]}&quot;)
    if [[ &quot;${BASH_VERSINFO[0]}&quot; -ge 4 ]]; then
        words[COMP_CWORD]=&quot;$2&quot;
    fi
    COMPREPLY=( $( \
        _CLAP_IFS=&quot;$IFS&quot; \
        _CLAP_COMPLETE_INDEX=&quot;$_CLAP_COMPLETE_INDEX&quot; \
        _CLAP_COMPLETE_COMP_TYPE=&quot;$_CLAP_COMPLETE_COMP_TYPE&quot; \
        _CLAP_COMPLETE_SPACE=&quot;$_CLAP_COMPLETE_SPACE&quot; \
        VAR=&quot;bash&quot; \
        &quot;COMPLETER&quot; -- &quot;${words[@]}&quot; \
    ) )
    if [[ $? != 0 ]]; then
        unset COMPREPLY
    elif [[ $_CLAP_COMPLETE_SPACE == false ]] &amp;&amp; [[ &quot;${COMPREPLY-}&quot; =~ [=/:]$ ]]; then
        compopt -o nospace
    fi
}
if [[ &quot;${BASH_VERSINFO[0]}&quot; -eq 4 &amp;&amp; &quot;${BASH_VERSINFO[1]}&quot; -ge 4 || &quot;${BASH_VERSINFO[0]}&quot; -gt 4 ]]; then
    complete -o nospace -o bashdefault -o nosort -F _clap_complete_NAME BIN
else
    complete -o nospace -o bashdefault -F _clap_complete_NAME BIN
fi
&quot;#
        .replace(&quot;NAME&quot;, &amp;escaped_name)
        .replace(&quot;BIN&quot;, bin)
        .replace(&quot;COMPLETER&quot;, &amp;completer)
</code></pre>
<p>and this is what is sourced.</p>
<p>https://github.com/clap-rs/clap/blob/master/clap_complete/src/env/shells.rs</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-21 18:47</div>
            <div class="timeline-body"><p>an example version created for me</p>
<pre><code>_clap_complete_cargo() {
    local IFS=$'\013'
    local _CLAP_COMPLETE_INDEX=${COMP_CWORD}
    local _CLAP_COMPLETE_COMP_TYPE=${COMP_TYPE}
    if compopt +o nospace 2&gt; /dev/null; then
        local _CLAP_COMPLETE_SPACE=false
    else
        local _CLAP_COMPLETE_SPACE=true
    fi
    local words=(&quot;${COMP_WORDS[@]}&quot;)
    if [[ &quot;${BASH_VERSINFO[0]}&quot; -ge 4 ]]; then
        words[COMP_CWORD]=&quot;$2&quot;
    fi
    COMPREPLY=( $( \
        _CLAP_IFS=&quot;$IFS&quot; \
        _CLAP_COMPLETE_INDEX=&quot;$_CLAP_COMPLETE_INDEX&quot; \
        _CLAP_COMPLETE_COMP_TYPE=&quot;$_CLAP_COMPLETE_COMP_TYPE&quot; \
        _CLAP_COMPLETE_SPACE=&quot;$_CLAP_COMPLETE_SPACE&quot; \
        CARGO_COMPLETE=&quot;bash&quot; \
        &quot;/home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo&quot; -- &quot;${words[@]}&quot; \
    ) )
    if [[ $? != 0 ]]; then
        unset COMPREPLY
    elif [[ $_CLAP_COMPLETE_SPACE == false ]] &amp;&amp; [[ &quot;${COMPREPLY-}&quot; =~ [=/:]$ ]]; then
        compopt -o nospace
    fi
}
if [[ &quot;${BASH_VERSINFO[0]}&quot; -eq 4 &amp;&amp; &quot;${BASH_VERSINFO[1]}&quot; -ge 4 || &quot;${BASH_VERSINFO[0]}&quot; -gt 4 ]]; then
    complete -o nospace -o bashdefault -o nosort -F _clap_complete_cargo cargo
else
    complete -o nospace -o bashdefault -F _clap_complete_cargo cargo
fi
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-21 18:57</div>
            <div class="timeline-body"><p>So any time a completion start with cargo it basically call the above shell function which set some variable and basically the cargo again and passed those variables to it.</p>
<p>The shell is able to know that it should called cargo for completion when the first part of the completion is cargo because of the below script.</p>
<pre><code>if [[ &quot;${BASH_VERSINFO[0]}&quot; -eq 4 &amp;&amp; &quot;${BASH_VERSINFO[1]}&quot; -ge 4 || &quot;${BASH_VERSINFO[0]}&quot; -gt 4 ]]; then
    complete -o nospace -o bashdefault -o nosort -F _clap_complete_cargo cargo
else
    complete -o nospace -o bashdefault -F _clap_complete_cargo cargo
fi
</code></pre>
<p>for completion instead of cargo to call <code>shell.write_registration()</code> it basically call <code>shell.write_completion </code>  which take care of the completion.</p>
<p>https://github.com/clap-rs/clap/blob/master/clap_complete/src/env/shells.rs#L72C5-L72C7</p>
<p>From what I understand the problem when the shell sees sudo cargo, it is calling completion for the sudo and not for the cargo,</p>
<p>One solution I am thinking of is that,</p>
<p>We enhanced the bash script generated by <code>shell.write_completion</code> to sort of call completion for cargo when it see that the second argument after <code>sudo</code> is <code>cargo</code></p>
<p>something like this will be the crux of the command</p>
<pre><code>    if [[ &quot;${words[0]}&quot; == &quot;sudo&quot; &amp;&amp; &quot;${words[1]}&quot; == &quot;cargo&quot; ]]; then

</code></pre>
<p>what do you think ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-21 19:09</div>
            <div class="timeline-body"><p>We can't be specializing a solution for <code>sudo</code> only.  This is likely a general feature of bash completions which is part of what I was hoping you'd dig into.  We need to understand the principles of how this works to determine what solution we should use.  We also need to look at how other shells handle this situation so we can determine if the solution needs to live in our shell-specific glue code or in our shell-agnostic Rust code.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-22 22:29</div>
            <div class="timeline-body"><p>Hi @epage, I did some further research into how the shell completion works for each of the shell,</p>
<p>fish, zsh, bash and Elvish,</p>
<p>And I tried to replicate the above bugs in the four of them.</p>
<p>Firstly, the bug is not present in fish at all and the above works perfectly but, it is present in bash, zsh and Elvish and this depends on how each of them implement their completion system.</p>
<p>So for Bash,</p>
<p>It uses the first word to know which completion function to call, so if you type something like sudo cargo or env cargo,</p>
<p>the cargo completion function would not be called at all, it will call the completion for sudo or env or just use the bashdefault.</p>
<p>So, the propose solution here  will be done in shell-specific glue code to use the cargo completion when cargo completion when cargo follows commands like sudo or env.</p>
<p>Something that was done by python argcomplete does is that they use  the -D flag <a href="https://github.com/kislyuk/argcomplete/blob/main/argcomplete/bash_completion.d/_python-argcomplete#L246">Python argcomplete</a>  which route all completion which is not explicitely mentioned to a single function. So since sudo is not explicetely mentioned, the functiion is called and it explicitely stripped the sudo before passing it to their python shell-agnostic Python code for completion so, the only solution is in the shell-specific glue code for function detection.</p>
<p>For zsh,</p>
<p>This automatically will call the correct function even if sudo is put at the front, it will still call cargo but, it would not remove sudo from whatever is  passed to our cargo completion function, so it basically remove sudo from knowing which completion to use but, does not remove sudo when it is passing as an argument to the cargo completion, so what we can do is either handle in the shell specific glue by stripping the sudo before passing it to the cargo completion rust function or handle it in the cargo completion rust function.</p>
<p>https://zsh.sourceforge.io/Doc/Release/Completion-System.html#Completion-of-commands - check for the behaviour in the zsh docs specifically (autoload and precommand) sudo, env and all this sort are handled.</p>
<p>For Elvish, it also seems to be the same as bash.</p>
<p>But, fish handle evertything from stripping commands like sudo, env for knowing which completion function to call to also passing the args to our cargo function without the sudo or env.</p>
<p>I think one general thing we can do is to handle removing of sudo and env or other things from our shell-agnostic rust code and then in the shell for fish and bash, ensure they both know which completion function to call even if the command start with sudo or env or other but still passed all the args including sudo to the rust agnostic code(which we have wired to remove sudo or other things).</p>
<p>What do you think ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-25 18:44</div>
            <div class="timeline-body"><blockquote>
<p>Firstly, the bug is not present in fish at all and the above works perfectly but, it is present in bash, zsh and Elvish and this depends on how each of them implement their completion system.</p>
</blockquote>
<p>Did you verify if you were using built-in fish completions or our custom completions?</p>
<blockquote>
<p>So for Bash,</p>
<p>It uses the first word to know which completion function to call, so if you type something like sudo cargo or env cargo,</p>
<p>the cargo completion function would not be called at all, it will call the completion for sudo or env or just use the bashdefault.</p>
<p>So, the propose solution here will be done in shell-specific glue code to use the cargo completion when cargo completion when cargo follows commands like sudo or env.</p>
</blockquote>
<p>When it calls our completions when nesting, what do the various pieces of information passed to us look like?</p>
<blockquote>
<p>Something that was done by python argcomplete does is that they use the -D flag <a href="https://github.com/kislyuk/argcomplete/blob/main/argcomplete/bash_completion.d/_python-argcomplete#L246">Python argcomplete</a> which route all completion which is not explicitely mentioned to a single function. So since sudo is not explicetely mentioned, the functiion is called and it explicitely stripped the sudo before passing it to their python shell-agnostic Python code for completion so, the only solution is in the shell-specific glue code for function detection.</p>
</blockquote>
<p>What was done to confirm it was the <code>-D</code> flag that is helping them?  Do you have a more complete description of what the <code>-D</code> flag affects?</p>
<p>From my reading of <code>complete --help</code> and https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html, it sounds like this would make the completions for any <code>clap_complete</code> command to be called for <em>any</em> command which seems a bit excessive.</p>
<blockquote>
<p>This automatically will call the correct function even if sudo is put at the front, it will still call cargo but, it would not remove sudo from whatever is passed to our cargo completion function,</p>
</blockquote>
<p>Sounds like <code>_normal</code> can help with this when used for zsh-only completions.  Might be worth looking at how thats implemented to see if there is logic we can use.</p>
<blockquote>
<p>I think one general thing we can do is to handle removing of sudo and env or other things from our shell-agnostic rust code and then in the shell for fish and bash, ensure they both know which completion function to call even if the command start with sudo or env or other but still passed all the args including sudo to the rust agnostic code(which we have wired to remove sudo or other things).</p>
</blockquote>
<p>From what I gather, the only thing we need to do is handle removing the prefix commands and adjusting our indexing.  We shouldn't need to register to complete in more situations, that is what <code>sudo</code> and <code>env</code>s completers set up in a general way.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-25 22:06</div>
            <div class="timeline-body"><blockquote>
<p>Did you verify if you were using built-in fish completions or our custom completions?</p>
</blockquote>
<p>Yeah, I did.</p>
<blockquote>
<p>When it calls our completions when nesting, what do the various pieces of information passed to us look like?</p>
</blockquote>
<p>For the example above</p>
<pre><code class="language-console">$ cargo build --example ap&lt;TAB&gt; --example banana
</code></pre>
<h3>For bash</h3>
<p>This is the snippet for completion</p>
<pre><code>    COMPREPLY=( $( \
        _CLAP_IFS=&quot;$IFS&quot; \
        _CLAP_COMPLETE_INDEX=&quot;$_CLAP_COMPLETE_INDEX&quot; \
        _CLAP_COMPLETE_COMP_TYPE=&quot;$_CLAP_COMPLETE_COMP_TYPE&quot; \
        _CLAP_COMPLETE_SPACE=&quot;$_CLAP_COMPLETE_SPACE&quot; \
        CARGO_COMPLETE=&quot;bash&quot; \
        &quot;/home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo&quot; -- &quot;${words[@]}&quot; \
    ) )
</code></pre>
<p>where <code>${words[@]}&quot;</code>  -&gt; <code>cargo build --example ap --example banana</code> i.e the exact command we passed.</p>
<p>and all these are environment variable</p>
<pre><code>        _CLAP_IFS=&quot;$IFS&quot; \
        _CLAP_COMPLETE_INDEX=&quot;$_CLAP_COMPLETE_INDEX&quot; \
        _CLAP_COMPLETE_COMP_TYPE=&quot;$_CLAP_COMPLETE_COMP_TYPE&quot; \
        _CLAP_COMPLETE_SPACE=&quot;$_CLAP_COMPLETE_SPACE&quot; \
        CARGO_COMPLETE=&quot;bash&quot; \
</code></pre>
<p><code>_CLAP_IFS=$'\013'</code> → Field separator (vertical tab) that Clap uses when printing multiple completions, so Bash can safely split them even if suggestions contain spaces.</p>
<p><code>_CLAP_COMPLETE_INDEX=3</code> → Index of the word being completed (matches COMP_CWORD), here word #3 = &quot;ap&quot;.</p>
<p><code>_CLAP_COMPLETE_COMP_TYPE=9</code> → Type of completion requested (how the user triggered completion, e.g. pressing <TAB>).</p>
<p><code>_CLAP_COMPLETE_SPACE=false</code> → Whether Bash should insert a trailing space after a completion (false = don’t insert, e.g. for --flag= style options).</p>
<p><code>CARGO_COMPLETE=bash</code> → Tells Cargo/Clap to run in bash completion mode instead of normal command execution</p>
<h3>For FIsh</h3>
<pre><code>complete --keep-order --exclusive --command cargo --arguments &quot;(CARGO_COMPLETE=fish &quot;'/home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo'&quot; -- (commandline --current-process --tokenize --cut-at-cursor) (commandline --current-token))&quot;
</code></pre>
<p>simply this -&gt; <code>CARGO_COMPLETE=fish cargo -- (commandline --current-process --tokenize --cut-at-cursor) (commandline --current-token)</code></p>
<p><code>argv = [&quot;cargo&quot;, &quot;build&quot;, &quot;--example&quot;, &quot;ap&quot;] - </code>commandline --current-process --tokenize --cut-at-cursor<code> </code>current_token = &quot;ap&quot;<code> -</code>commandline --current-token`</p>
<p>Basically fish does not send all but cut it at the part we are trying to complete.</p>
<h3>For Zsh</h3>
<p>Similar to bash</p>
<pre><code>    local _CLAP_COMPLETE_INDEX=$(expr $CURRENT - 1)
    local _CLAP_IFS=$'\n'

    local completions=(&quot;${(@f)$( \
        _CLAP_IFS=&quot;$_CLAP_IFS&quot; \
        _CLAP_COMPLETE_INDEX=&quot;$_CLAP_COMPLETE_INDEX&quot; \
        CARGO_COMPLETE=&quot;zsh&quot; \
        /home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo -- &quot;${words[@]}&quot; 2&gt;/dev/null \
    )}&quot;)
</code></pre>
<pre><code>_CLAP_IFS=$'\n' \
_CLAP_COMPLETE_INDEX=3 \
CARGO_COMPLETE=zsh \
/home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo -- \
    cargo build --example ap --example banana
</code></pre>
<h3>For Elvish</h3>
<pre><code>set edit:completion:arg-completer[cargo] = { |@words|
    var index = (count $words)
    set index = (- $index 1)

    put (env _CLAP_IFS=&quot;\n&quot; _CLAP_COMPLETE_INDEX=(to-string $index) CARGO_COMPLETE=&quot;elvish&quot; /home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo -- $@words) | to-lines
</code></pre>
<p>expands to something like this.</p>
<pre><code>env _CLAP_IFS=&quot;\n&quot; _CLAP_COMPLETE_INDEX=&quot;5&quot; CARGO_COMPLETE=&quot;elvish&quot; \
  /home/uniqueusman/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/bin/cargo \
  -- cargo build --example ap --example banana
</code></pre>
<p>I tried using elvish, the completion seems not work.</p>
<hr />
<blockquote>
<p>What was done to confirm it was the <code>-D</code> flag that is helping them? Do you have a more complete description of what the <code>-D</code> flag affects?</p>
<p>From my reading of <code>complete --help</code> and https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion.html, it sounds like this would make the completions for any <code>clap_complete</code> command to be called for <em>any</em> command which seems a bit excessive.</p>
</blockquote>
<p>Yeah, I will look into this more, but, an approach is to capture sudo and maybe env or others and if cargo follow it, use cargo complete else go leave it to bash to pick the right completion. - This seems to be the only I have seen, I will still check around.</p>
<blockquote>
<p>Sounds like <code>_normal</code> can help with this when used for zsh-only completions. Might be worth looking at how thats implemented to see if there is logic we can use.</p>
</blockquote>
<p>As I said initially, zsh already shipped with _sudo, _env and all which basically uses _normal, the issue with zsh is that it does not strip sudo or env when passing to our completion function. It strip it to detect which completion function to call.</p>
<blockquote>
<p>From what I gather, the only thing we need to do is handle removing the prefix commands and adjusting our indexing. We shouldn't need to register to complete in more situations, that is what <code>sudo</code> and <code>env</code>s completers set up in a general way.</p>
</blockquote>
<p>Yeah, exactly, but this only works for all of it , if is done in shell code and not rust. If we do in rust, it would not work for bash and elvish, which does not even call our cargo completion code if the command is not starting with cargo.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-26 17:32</div>
            <div class="timeline-body"><blockquote>
<p>For the example above</p>
<pre><code class="language-console">$ cargo build --example ap&lt;TAB&gt; --example banana
</code></pre>
</blockquote>
<p>That doesn't seem to be a nesting situation.  If this was prefixed with <code>sudo</code> then that would work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-26 22:50</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>For the example above
$ cargo build --example ap<TAB> --example banana</p>
</blockquote>
<p>That doesn't seem to be a nesting situation. If this was prefixed with <code>sudo</code> then that would work.</p>
</blockquote>
<p>Yeah, I did a little more research and I actually see that, there are actually already implemented solution for this for bash.</p>
<p>https://github.com/scop/bash-completion</p>
<p>This can be installed on ubuntu and I was able to install it on my Arch Linux and the above bugs disappear after installing it.</p>
<p>It basically have a completion system for sudo, env and many others. So, the logic is something we have been discussing which is too basically check the next word after sudo and strip it when passing to cargo. It add Extend PATH to include /sbin etc., so privileged commands are found.</p>
<p>And I tested the above after installing, the bugs disappear.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-28 15:23</div>
            <div class="timeline-body"><p>Yeah, <code>sudo cargo &lt;TAB&gt;</code> works for me as well but the filer of rust-lang/cargo#15862 says its not working.</p>
<p>If the old completions work, it might still be worth finding a way to make this work for greatest compatibility.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-28 15:29</div>
            <div class="timeline-body"><p>Oh right, its not that we aren't completing but that we aren't completing correctly.  I'm able to reproduce the problem where, with <code>sudo</code>, arguments get swapped</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-28 16:58</div>
            <div class="timeline-body"><blockquote>
<p>If</p>
</blockquote>
<p>By old and new completing, what do you mean by that  ?</p>
<p>This -&gt;<code> cargo build --example ap&lt;TAB&gt; --example banana</code> and this <code>sudo cargo &lt;TAB&gt;</code>, works perfectly for me after getting the bash-completions</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-28 16:59</div>
            <div class="timeline-body"><blockquote>
<p>Oh right, its not that we aren't completing but that we aren't completing correctly. I'm able to reproduce the problem where, with <code>sudo</code>, arguments get swapped</p>
</blockquote>
<p>This exact <code>cargo build --example ap&lt;TAB&gt; --example banana</code> ? How did you reproduce it ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-28 17:36</div>
            <div class="timeline-body"><blockquote>
<p>This exact cargo build --example ap<TAB> --example banana ? How did you reproduce it ?</p>
</blockquote>
<p>I followed the issues reproduction steps</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-28 17:48</div>
            <div class="timeline-body"><p>hmm, apparently, it works perfectly on my arch linux, I will try to get the same environment as the above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-28 18:13</div>
            <div class="timeline-body"><p>@epage, I just reproduce on Ubuntu, but, it works pefectly on arch linux. I will look into it more again.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-08-28 19:10</div>
            <div class="timeline-body"><p>While looking at the source code for bash completion script in both arch linux and the ubuntu, they are different, the arch linux use the exact source code in the https://github.com/scop/bash-completion and it is different in ubuntu, I will guess the main problem comes from their, I will look into it more to verify</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../RustBeginners/awesome-rust-mentors/issues/206.html">RustBeginners/awesome-rust-mentors#206</a> on 2025-08-29 05:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Unique-Usman">@Unique-Usman</a> on 2025-09-08 23:07</div>
            <div class="timeline-body"><p>@epage still working on this, go busy with school work recently. Will resume asap.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:35 UTC
    </footer>
</body>
</html>
