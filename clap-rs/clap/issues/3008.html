<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[modular] User-driven validation - clap-rs/clap #3008</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>[modular] User-driven validation</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/3008">#3008</a>
        opened by <a href="https://github.com/epage">@epage</a>
        on 2021-11-09 14:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/epage">@epage</a> on 2021-11-09 14:38</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the existing issues</li>
</ul>
<h3>Clap Version</h3>
<p>master</p>
<h3>Describe your use case</h3>
<ul>
<li>We want to get clap smaller (#1365) and right now validation adds bulk regardless of what parts people use<ul>
<li>We could put parts behind a feature flag but that could end up getting messy</li>
</ul>
</li>
<li>In https://github.com/clap-rs/clap/discussions/3005 / #3135, a user requested specialized validation logic</li>
</ul>
<h3>Describe the solution you'd like</h3>
<p>Define one or more App Validation trait</p>
<ul>
<li>Validate: Takes a built <code>App</code> and <code>ArgMatches</code> as an input, reports errors</li>
<li>Requires: Takes a built <code>App</code>,   <code>ArgMatches</code>, and args as input, reports which args are required</li>
<li><em>(maybe)</em> Default value: Takes a built <code>App</code>, <code>ArgMatches</code>, and args as input, reports default values for them</li>
</ul>
<p>With maybe a <code>hint(&amp;self, app: &amp;App) -&gt; Option&lt;String&gt;</code> (see #1695 and #3321)</p>
<ul>
<li>Should it also accept a <code>matches: Option&lt;&amp;ArgMatches&gt;</code> for <a href="https://github.com/clap-rs/clap/discussions/3331">smart hints</a>?</li>
</ul>
<p>Steps</p>
<ol>
<li>Refactor all requires, conflicts, etc APIs to be implemented in terms of this<ul>
<li>Try to overcome weirdnesses in the <a href="https://docs.rs/clap/3.0.0-beta.5/clap/struct.Arg.html#method.default_value_if"><code>default_value_if</code> API with its use of <code>Option</code></a> by clarifying intent through builders</li>
</ul>
</li>
<li>Expose the trait and structs to the user in a <code>clap::validate</code></li>
<li>Deprecate the old <code>Arg</code> functions so now only those using this API pay the cost due to dead code elimination</li>
</ol>
<h3>Alternatives, if applicable</h3>
<p><em>No response</em></p>
<h3>Additional Context</h3>
<p>See also https://github.com/clap-rs/clap/discussions/2832</p>
<p>Related issues</p>
<ul>
<li>#4682</li>
<li>#4702</li>
<li>#4731</li>
</ul>
<p>Risks are usability and performance.  The most basic APIs, like <code>required</code>, we probably need to keep baked in.  Its the special inter-arg interactions that we should be focusing on.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by @epage on 2021-11-09 14:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: validators</span> added by @epage on 2021-11-09 14:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/3029.html">clap-rs/clap#3029</a> on 2021-11-15 19:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1634.html">clap-rs/clap#1634</a> on 2021-11-17 21:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/235.html">epage/clapng#235</a> on 2021-12-06 22:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> removed by @epage on 2021-12-08 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-08 21:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2332.html">clap-rs/clap#2332</a> on 2021-12-13 16:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-mentor</span> added by @epage on 2021-12-13 22:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-01-09 04:05</div>
            <div class="timeline-body"><p>I'm not quite understanding what the <code>Validate</code> trait will look like. Is this a project-level trait that will be implemented on a certain <code>Fn / FnMut</code>, meaning users don't need to worry about it, or will it be provided by a <code>clap_validate</code> crate, and users need to include that crate and its trait to get <code>App::validator_all</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-01-10 16:24</div>
            <div class="timeline-body"><p>My general expectation for traits in this issue and related ones (e.g. https://github.com/clap-rs/clap/issues/2683) is they would live in <code>clap</code> (we'd need access to them) and we will have an impl for <code>Fn</code> signatures where they make sense for convinience.  We'd work to duplicate clap's validation functionality in structs that implement these traits.  These would most likely live in clap, relying on the compiler deleting dead code (this will be easier for a compiler to detect than the current under-used validation code).</p>
<p>All of this would start out behind an <code>unstable-*</code> feature flag as we work to polish it up.  Once we felt good with them, we'd remove the feature flag and deprecate the old functionality.  On the next major release, we'd then remove the old functionality, pushing people to use the trait-based version.</p>
<p>This is all contingent on the design working out.  We might find it just isn't worth completing this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-01-13 07:22</div>
            <div class="timeline-body"><p>Wait, why would <code>clap</code> need access to the trait?</p>
<p>The trait could just fit into <code>clap</code>'s builder pattern for <code>App</code>, providing a function for <code>App</code> which modifies <code>App</code>.</p>
<p>Then you could call <code>App::error</code> in the <code>Validator</code> trait impl. <code>clap</code> wouldn't need to know the validator exists so long as <code>App</code> has the right struct members <code>pub</code> or <code>fn</code>'s to get them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-01-13 15:11</div>
            <div class="timeline-body"><p>The proposed validator trait would be called during parse so we have the context of the specific subcommand being processed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-01-13 16:31</div>
            <div class="timeline-body"><p>Forgive me for not knowing the internals as well as you, but couldn't the Validator trait, instead of being called on <code>App</code>, be called on <code>ArgMatches</code> instead?</p>
<p>Perhaps as <code>app.get_matches().validate()</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-01-13 17:15</div>
            <div class="timeline-body"><p>It needs access to the relevant <code>App</code> for any extra error reporting it wants to do, like</p>
<ul>
<li>Checking for additional context for whether validation has failed or not</li>
<li>Showing usage</li>
<li>Showing help if we made this replace <code>ArgsRequiredElseHelp</code>'</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-01-13 18:49</div>
            <div class="timeline-body"><p>I see. Honestly, as much as I don't like it, perhaps you do have a strong case for pushing <code>App::error</code> on downstream users, and we're just going to have to learn to live with it. ;-)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-01-13 18:58</div>
            <div class="timeline-body"><p>The primary motivation behind this is to see if we can make the cost of validation paid by those who use it rather than everyone (ie clap's existing validation logic like conflicts, special require rules, etc).  A secondary motivation is to simplify the APIs for the more complex validation APIs in clap today.  All other validation use cases would just be a bonus since we do have solutions like <code>App::error</code>.  This might work and be merged; it might fail and we reject this issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-01-13 19:36</div>
            <div class="timeline-body"><p>Hopefully you can avoid my horrible situation of the past week: adding an API (https://github.com/MFEK/glifparser.rlib/commit/6aaf88012709fce8fd21ccf0b61d1074a95307a3), realizing it's broken and trying to fix it (<a href="https://github.com/MFEK/glifparser.rlib/commit/d9aa702df074094f1509f071e15e11cc696a4ca3">https://github.com/MFEK/glifparser.rlib/commit/d9aa702df074094f1509f071e15e11cc696a4ca3</a>)…twice (<a href="https://github.com/MFEK/glifparser.rlib/commit/9b06a9422b796d25ab2b270abfd51500c6e5857b">https://github.com/MFEK/glifparser.rlib/commit/9b06a9422b796d25ab2b270abfd51500c6e5857b</a>). Maybe it has no edge cases now, we shall see. Popular software can't afford such…unprofessionalism, I'm aware. :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-01-13 20:03</div>
            <div class="timeline-body"><p>This would most likely be implemented via</p>
<ol>
<li>Refactor the existing implementation to use a <code>pub(crate) trait</code> (dog fooding)</li>
<li>Expose it as a <code>pub trait</code> behind a feature flag with a stablization process (e.g. https://github.com/clap-rs/clap/issues/2861) (collect public feedback)</li>
<li>Stablize the feature (point of no return ... until next major version)</li>
<li>On next major version, remove parts of API not needed anymore</li>
</ol>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1126.html">clap-rs/clap#1126</a> on 2022-01-17 15:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3321.html">clap-rs/clap#3321</a> on 2022-01-20 15:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1695.html">clap-rs/clap#1695</a> on 2022-01-20 15:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1365.html">clap-rs/clap#1365</a> on 2022-02-01 17:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3135.html">clap-rs/clap#3135</a> on 2022-04-15 12:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3633.html">clap-rs/clap#3633</a> on 2022-04-15 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kraktus">@kraktus</a> on 2022-05-06 15:56</div>
            <div class="timeline-body"><p>What about relying on <code>serde</code> for custom validation instead? <code>clap</code> would serialise it, and users who would write custom deserialisation, helped with the helper methods of serde. That would a be more modular than <code>clap</code> implementing its own trait and visitor</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-05-06 16:03</div>
            <div class="timeline-body"><p>I worry <code>serde</code> would too much complexity for most cases since a lot of the cases people are interested in validating would require hand-writing <code>serde</code> traits which can be burdensome while just providing a <code>Vaidator</code> trait in clap that works on an <code>ArgMatches</code> would be relatively trivial to implement.  No visitors needed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-05-06 21:12</div>
            <div class="timeline-body"><p>Not necessarily.</p>
<p>With <a href="https://docs.rs/serde-value/">serde_value</a>, you get a <a href="https://docs.rs/serde-value/latest/serde_value/enum.Value.html"><code>Value</code></a> type that represents any Serde &quot;object&quot;. These can be coerced into the user's structs because they also implement <code>Deserialize</code>.</p>
<p>I think @kraktus' idea is a good middle ground.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-05-06 21:24</div>
            <div class="timeline-body"><blockquote>
<p>With <a href="https://docs.rs/serde-value/">serde_value</a>, you get a <a href="https://docs.rs/serde-value/latest/serde_value/enum.Value.html">Value</a> type that represents any Serde &quot;object&quot;. These can be coerced into the user's structs because they also implement Deserialize.</p>
</blockquote>
<p>I'm not seeing how that addressed the concern I raised.  I'm assuming there is context missing that I could make guesses at but I would prefer to understand what you are getting at then understanding my assumptions :)</p>
<p>The other problem with serde is it assumes Paths are UTF-8 so naive handling of paths will be done incorrectly while clap is wanting to ensure paths are default handled as a bag of bytes rather than utf-8</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-05-06 21:29</div>
            <div class="timeline-body"><p>I was thinking that you'd have <code>Deserialize</code> on the whole <code>ArgMatches</code>. It's already normal for me to have an <code>Args</code> struct. If <code>ArgMatches</code> could become a <code>serde::Value</code> then it could become also an <code>Args</code>, right?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-05-06 21:40</div>
            <div class="timeline-body"><p>How does users writing custom validation fit into that picture?  If the user just wants to do a field-level validator, they can use the field attributes to provide their own custom deserializer.  If they want to validate the entire struct, which is what this issue is focusing on, then they would need to hand write the entire <code>Deserialize</code> trait which is not pretty to do by hand.</p>
<p>Compare that to just passing in a value that implements <code>Validator</code> as described earlier.   That is a large burden for the user to do one vs the other and so doesn't seem a viable way of solving this problem.   We also have a custom derive that offers a lot of domain-specific value that can't be had with clap, which lowers the value add of going down this route for custom validation.</p>
<p>That said, it would be interesting for people to support serde support for <code>ArgMatches</code> but I think that would best start out as an external crate so it gives people room to experiment and try out ideas more to see what works or doesn't before pulling it into clap.  This will require a newtype due to the orphan rules.  Some more features will be needed from <code>ArgMatches</code> which I would like to provide but they are blocked on some v4 changes because of difficulties with our internal <code>Id</code> type.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-05-06 21:55</div>
            <div class="timeline-body"><p>My problem was I was only considering my patch #3029 and not that you wanted to make <em>every</em> case work.</p>
<p>To refresh memories, my patch was focused on validating <em>a single struct field</em> that contains <em>multiple values</em>.</p>
<p>So I could use a Newtype and <code>impl FromStr</code>.</p>
<p>But you're right this won't let you validate <em>the whole struct</em>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ctrlcctrlv">@ctrlcctrlv</a> on 2022-05-06 22:01</div>
            <div class="timeline-body"><p>Erm, or I could <code>impl From&lt;Vec&lt;…&gt;&gt; for Newtype</code>.</p>
<p>Then when I call <code>values_of</code> / <code>values_of_os</code>...I could quickly make the returned Vec into my Newtype.</p>
<p>I hadn't considered the other cases, my bad, I forgot this issue was not just about #3029</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3869.html">clap-rs/clap#3869</a> on 2022-07-11 20:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2688.html">clap-rs/clap#2688</a> on 2022-07-11 20:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/4987.html">clap-rs/clap#4987</a> on 2023-06-25 00:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Easyoakland">@Easyoakland</a> on 2023-06-25 02:12</div>
            <div class="timeline-body"><p>Where is work being done on this? Is there more discussion that must be had first?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-06-25 02:19</div>
            <div class="timeline-body"><p>For myself, I have tasks on other projects that I feel are higher priority on this.  Someone else could do some exploratory work on this but the challenge is this is very open-ended work and someone working on it would need to keep us in the loop on decisions to make sure there is buy-in on the direction being taken.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Easyoakland">@Easyoakland</a> on 2023-06-25 03:46</div>
            <div class="timeline-body"><p>It seems like what this is proposing is a validator trait on functions which can take a validator to make new validator. Then use <a href="https://en.wikipedia.org/wiki/Combinatory_logic">Combinatory_logic</a> to define all the validators. How is this proposed approach different from copying <a href="https://docs.rs/bpaf/latest/bpaf/">bpaf</a>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pacak">@pacak</a> on 2023-06-30 16:50</div>
            <div class="timeline-body"><blockquote>
<p>How is this proposed approach different from copying <a href="https://docs.rs/bpaf/latest/bpaf/">bpaf</a>?</p>
</blockquote>
<p>In <code>bpaf</code> you would compose parsers instead of validators, see this article for a general idea: https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/</p>
<p>Disclaimer, I'm not an expert in <code>clap</code>, but I can try to give some examples according some hopefully idiomatic existing code.</p>
<p><code>cargo-add</code> needs user to specify the source, so it defines https://github.com/rust-lang/cargo/blob/5b377cece0e0dd0af686cf53ce4637d5d85c2a10/src/bin/cargo/commands/add.rs#L85 a bunch of arguments with some  validation - &quot;tag&quot; requires &quot;git&quot;, &quot;path&quot; conflicts with &quot;git&quot;, etc.</p>
<p>Values later extracted into variables https://github.com/rust-lang/cargo/blob/5b377cece0e0dd0af686cf53ce4637d5d85c2a10/src/bin/cargo/commands/add.rs#L226</p>
<p>And consumed with https://github.com/rust-lang/cargo/blob/5b377cece0e0dd0af686cf53ce4637d5d85c2a10/src/bin/cargo/commands/add.rs#L259</p>
<p>Biggest problem with that is that user code (<code>parse_dependencies</code>) relies on <em>validated</em> invariants, not parsed ones.</p>
<p>With bpaf you would have those values constructed either by derive or <code>construct!</code> macro.</p>
<pre><code class="language-rust">struct Options {
   ... 
   source: Input,
   ...
}

enum Ref {
    Branch { branch: String },
    Tag { tag: String },
     Rev { rev: String },
}

enum Input {
    Crate { name: String },
    File { path: PathBuf },
    Git { uri: String, ref: Option&lt;Ref&gt;  },
}
</code></pre>
<p>With parsers and validators operating on strictly typed Rust values.</p>
<p>For hypothetical input validator (let's say against crate blacklist) <code>clap</code> version would have to deal with the same steps - getting fields, assuming some invariants been vitiated earlier (<code>unreachable!(&quot;clap should ensure we have some source selected&quot;);</code>) and validating them. With <code>bpaf</code> validator would get a <code>val: &amp;Input</code> or <code>val: &amp;Ref</code> depending on where it is placed.</p>
<p>Now say you want to add one extra input type, let's call it &quot;interactive picker&quot;.</p>
<p>With clap you modify parser definition and then you have to go over all the places where <code>ArgMatches</code> are used and update them, otherwise things will explode on runtime with <code>unreachable!(&quot;clap should ensure we have some source selected&quot;);</code></p>
<p>With <code>bpaf</code> compiler will tell you all the places where <code>match val</code> needs to be updated to handle one more branch.</p>
<p>This becomes a problem when argument parser or parts of it are shared across multiple binaries, but even within a single crate it is easier to work with the right type</p>
<pre><code class="language-rust">enum OutputFormat {
    Intel,
    Att,
    Llvm,
    LlvmInput,
    Mir,
    Wasm,
    McaIntel,
    McaAtt,
}
</code></pre>
<p>rather than trying to emulate it using product types:</p>
<pre><code class="language-rust">struct OutputFormat {
    intel: bool,
    att: bool,
    llvm: bool,
    ...
}
</code></pre>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:33 UTC
    </footer>
</body>
</html>
