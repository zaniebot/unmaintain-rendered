<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>`required` ignores `default_value`, making some requirements impossible to express - clap-rs/clap #6031</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>`required` ignores `default_value`, making some requirements impossible to express</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/6031">#6031</a>
        opened by <a href="https://github.com/lilyball">@lilyball</a>
        on 2025-06-10 19:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/lilyball">@lilyball</a> on 2025-06-10 19:29</div>
            <div class="timeline-body"><p>clap v3.2.0 changed the behavior of required args to ignore default values. For simple cases this can be accounted for (though it’s not properly documented), but in the case of conditional defaults or conditional requires, this leads to some requirements being impossible to express that otherwise would have.</p>
<p>This was previously noticed in https://github.com/clap-rs/clap/issues/3838, which was closed as requiring a v5 to fix, though I believe this could be fixed by adding a new app setting to opt in to having defaults affect requirements.</p>
<p>The problem with the current behavior is conditional defaults and conditional requires combine to make more complicated patterns impossible to express. Here’s an example:</p>
<pre><code class="language-rust">// Not a contribution.
let cmd = clap::Command::new(&quot;cli&quot;)
    // --use-color gates all color flags
    .arg(clap::arg!(--&quot;use-color&quot;))
    // --color is required with --use-color, but has a default
    .arg(
        clap::arg!(--color &lt;COLOR&gt;)
            .value_parser([&quot;red&quot;, &quot;blue&quot;])
            .default_value_if(&quot;use-color&quot;, ArgPredicate::IsPresent, &quot;red&quot;)
            .requires(&quot;use-color&quot;),
    )
    // --shade is required if --color=red
    .arg(
        clap::arg!(--shade &lt;SHADE&gt;)
            .value_parser([&quot;maroon&quot;, &quot;pink&quot;])
            .required_if_eq(&quot;color&quot;, &quot;red&quot;)
            .requires(&quot;use-color&quot;),
    );
let matches = cmd.get_matches_from([&quot;cli&quot;, &quot;--use-color&quot;]);
// this should have failed with an error saying --shade is required,
// but instead it parses just fine.
</code></pre>
<p>With this config, the <code>--shade</code> flag is supposed to be required any time <code>--color=red</code>, but you can only write <code>--color=red</code> if you also write <code>--use-color</code>. As it is today, it’s impossible to express this. If it wasn’t for the <code>--use-color</code> flag then I could give color an unconditional default and use <code>.required_unless_present(&quot;color&quot;)</code> on <code>--shade</code> to cover the default case, but I can’t do that once I have a <code>default_value_if</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-06-10 19:50</div>
            <div class="timeline-body"><p>The example you gave is not quite clear.  It would help if you followed the issue template, including providing concrete commands that you run and what the out is and what you expect the output to me.</p>
<p>Also, to note #3838 was not closed as requiring a v5.  We'll have a v5 so we'd have left it open in that case.  A simple change was not going to be done for that issue and I'm hesitant about adding new validation related logic at this time because we need to figure out what our general approach is as people come with a lot of different validation requests and to satisfy them all, we'd need balloon the API, binary size, and build time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/lilyball">@lilyball</a> on 2025-06-12 00:25</div>
            <div class="timeline-body"><p>The example I gave is self-contained and should reproduce against any version of clap v4, and the comments in the example explain what was expected. You can also see it in <a href="https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2024&amp;gist=8bb9169f406735da836f7310425dc96b">the Playground</a>.</p>
<p>More generally, the change from 3.2 that caused requirements to ignore default values is confusing and not properly documented[^1]. If a flag has a default value, then not passing the flag should behave the same as passing it with the default value. Yet as the example I gave demonstrates, <code>cli --use-color</code> parses just fine but the equivalent <code>cli --use-color --color=red</code> would have errored out saying that the <code>--shade</code> flag was expected too. That error is what should have happened with <code>cli --use-color</code>, but doesn't because the requirements ignore the default values. And it's very weird that requirements would ignore default values, because behavior shouldn't change just because an implicit flag was made explicit.</p>
<p>In simpler cases, the fact that requirements ignore default values can be worked around, e.g. saying <code>arg.required_if_eq(&quot;color&quot;, &quot;red&quot;).required_unless_present(&quot;color&quot;)</code> can be used to say that the arg is required if <code>--color</code> is omitted or is set to <code>red</code> (which mimics requirements obeying defaults if <code>--color</code> defaults to <code>red</code>). But as soon as you use <code>default_value_if</code>, there's no way to handle that with current behavior.</p>
<p>The ideal solution here is to revert to the pre-3.2 behavior, where requirements obey defaults[^2]. That's a breaking change though, and so would require doing in a v5. I'm proposing that this can be done via an app setting or arg setting instead, to allow for opting into the fixed behavior (and then also just fixing it for v5, if a v5 happens).</p>
<p>[^1]: <code>required_if_eq</code> uses the phrase &quot;is present at runtime&quot; but it's not obvious that this means &quot;was provided explicitly by the user&quot;, because a default value affects runtime behavior.
[^2]: I think ideally conflicts would still ignore defaults, I'm not sure offhand what the pre-3.2 behavior there was with conflicts but it makes sense to me that default values would be overridden by explicitly-provided conflicting args, because otherwise setting a default value on an arg would make conflicting args unusable.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-08-07 20:17</div>
            <div class="timeline-body"><p>A straight revert to the pre-3.2 behavior is not happening.  That had fundamental problems that were being addressed as mentioned in #3838.</p>
<p>I can think of two angles to look at your problem</p>
<ul>
<li>This is less about defaults about about implied arguments which may need different semantics.  <code>Command::replace</code> (#2836) was one attempt at this but was very crude which led to several blockers.  I thought we had another issue for this but I'm not finding it</li>
<li>This seems to be less about <code>required</code> and more about <code>required_if_eq</code> and in that case, it might make sense to check the value, independent of the <code>ValueSource</code>.</li>
</ul>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:09 UTC
    </footer>
</body>
</html>
