```yaml
number: 2033
title: "Expand template macros found in Rust comments [feature request]"
type: issue
state: open
author: sjackman
labels:
  - C-enhancement
  - S-waiting-on-decision
  - A-help
assignees: []
created_at: 2020-07-24T17:53:27Z
updated_at: 2021-12-10T21:59:12Z
url: https://github.com/clap-rs/clap/issues/2033
synced_at: 2026-01-10T01:57:44Z
```

# Expand template macros found in Rust comments [feature request]

---

_Issue opened by @sjackman on 2020-07-24 17:53_

### Make sure you completed the following tasks

- [x] Searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [x] Searched the closed issues

### Describe your use case

I'm using the `clap` with its derive macros. The same library code is used with two separate executables. I'd like to include the name of the executable in the about text of a command line argument. For example.

### Describe the solution you'd like

```rust
    /// Path to the JSON file produced by '{bin} clean --out=JSON INPUT.TXT'
    #[clap(long = "json")]
    pub json: CliPath,
```
where `{bin}` is the name of one of the two executables that uses this library code.

### Alternatives, if applicable

We could convert the program to use builder notation rather than the derive macros, which would make it easier to programmatically format the text of an about option. All of our projects use the derive macros though, so this would be a deviation from our other projects. Is either the YAML or macro mode appropriate?

### Additional context

Thank you very much for Clap! It's fantastic!

---

_Label `T: new feature` added by @sjackman on 2020-07-24 17:53_

---

_Comment by @CreepySkeleton on 2020-07-24 20:36_

I think this is one of those feature requests which are, while unquestionably useful, very hard to design and implement properly.

### Why derive-only won't do

For starters, this cannot be derive macro only feature because

* The binary name (for example) is unknown until runtime, and `#[derive(Clap)]` works at "macro expansion time". There's no `{bin}`  we could replace the placeholder with, or rather, it's to be determined when you actually run the program (aliases and stuff). The derive code doesn't have the data simply because the data... doesn't exist yet.
* I see people often make the same mistake when they talk about derive macros - they don't understand that "one `#[derive]`, one expansion". You want to reuse the generated code in two different places (you wrote about two executables), but you expect the generated code to differ (you want different help messages). It won't.

### Alternative proposal

Build it in clap itself:
```rust
Arg::new("json")
    .long("json")
    .help("Path to the JSON file produced by '{bin} clean --out=JSON INPUT.TXT'")
```

Then clap scans the help messages at runtime seeking for `{placeholder}`, replaces it, and prints it (or does whatever was requested).

### List of placeholders

Anything other than `{bin}`? I would like a list here.

### Runtime overhead

If this is implemented, clap will have to scan through _all_ help messages at runtime. Good news is, the scanning will run only when generating help messages, and that ain't the part you expect to be amazingly fast. We may run the scan step only if `AppSettings::HelpPlaceholders` is set, but I don't think it worth expanding public API.



---

_Label `C: help message` added by @CreepySkeleton on 2020-07-24 20:37_

---

_Label `D: hard` added by @CreepySkeleton on 2020-07-24 20:37_

---

_Label `P4: nice to have` added by @CreepySkeleton on 2020-07-24 20:37_

---

_Comment by @sjackman on 2020-07-24 22:20_

> If this is implemented, clap will have to scan through all help messages at runtime. Good news is, the scanning will run only when generating help messages, and that ain't the part you expect to be amazingly fast.

Yes, I agree that the expansion would happen at run time.
Thanks for your quick response!

I specifically want this feature when using Clap with its derive macros. When using the builder pattern, `format!` can easily be used.
```rust
Arg::new("json")
    .long("json")
    .help(format!("Path to the JSON file produced by '{} clean --out=JSON INPUT.TXT'"), bin_name)
```

When using the derive macro
```rust
    /// Path to the JSON file produced by '{bin} clean --out=JSON INPUT.TXT'
    #[clap(long = "json")]
    pub json: CliPath,
```
the expansion of `{bin}` would be done at run time when the user invokes `command --help`.
```diff
pub fn get_help<T: IntoApp>() -> String {
    let mut output = Vec::new();
    <T as IntoApp>::into_app().write_help(&mut output).unwrap();
-   let output = String::from_utf8(output).unwrap();
+   let output = String::from_utf8(output).unwrap().replace("{bin}", self.get_bin_name()?);

    eprintln!("\n%%% HELP %%%:=====\n{}\n=====\n", output);
    eprintln!("\n%%% HELP (DEBUG) %%%:=====\n{:?}\n=====\n", output);

    output
}
```

> Anything other than {bin}? I would like a list here.

https://docs.rs/clap/2.33.1/clap/struct.App.html#method.template

I looked through the other template macros, and `{bin}` seemed like the only one that would be useful to me.

---

_Comment by @pksunkara on 2020-07-24 22:22_

You should be able to use `format!` with derive macros too since doc strings are just syntactic sugar for `#[doc = ""]`

---

_Comment by @sjackman on 2020-07-24 23:04_

@CreepySkeleton pointed out aboveâ€¦

> The binary name (for example) is unknown until runtime, and #[derive(Clap)] works at "macro expansion time". There's no {bin} we could replace the placeholder with, or rather, it's to be determined when you actually run the program (aliases and stuff). The derive code doesn't have the data simply because the data... doesn't exist yet.


---

_Comment by @TeXitoi on 2020-07-27 17:29_

That's not totally true: the code is generated at expantiin time, but the given string can be generated at run time. See the lazy_static hack

---

_Comment by @pickfire on 2020-08-09 05:45_

Templating doc comments is a bit hard even when using a macro but there is a tool on that https://github.com/dtolnay/paste. Not sure if this is useful.

---

_Referenced in [epage/clapng#159](../../epage/clapng/issues/159.md) on 2021-12-06 20:16_

---

_Label `T: new feature` removed by @epage on 2021-12-08 21:12_

---

_Label `C-enhancement` added by @epage on 2021-12-08 21:12_

---

_Comment by @epage on 2021-12-10 21:59_

Agreed that we'd want to implement this feature in the Builder for the Derive API to use.

#2914's idea for code-genning help messages would open the door for us doing this without incurring runtime costs.

---

_Label `P4: nice to have` removed by @epage on 2021-12-10 21:59_

---

_Label `E-hard` removed by @epage on 2021-12-10 21:59_

---

_Label `S-waiting-on-decision` added by @epage on 2021-12-10 21:59_

---
