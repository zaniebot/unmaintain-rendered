<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature: Custom Derive for ArgEnum - clap-rs/clap #1103</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Feature: Custom Derive for ArgEnum</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/1103">#1103</a>
        opened by <a href="https://github.com/Hoverbear">@Hoverbear</a>
        on 2017-11-12 18:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/Hoverbear">@Hoverbear</a></div>
            <div class="timeline-body"><p>Hey!</p>
<p>I had a bit of time, and a hankering to write a custom derive, so I got working on a custom derive for <code>ArgEnum</code>.</p>
<p>I've structured the crate so if we want to expand it, it should be easy. I think this is related to #835 but I didn't look too deeply into what the progress is with that.</p>
<p>The crate is https://github.com/Hoverbear/clap-derives and unpublished, and I'd be more than happy to transfer you (@kbknapp) ownership. It's a first draft and could probably use refinement.</p>
<p>You can see an example here:</p>
<pre><code class="language-rust">#[macro_use]
extern crate clap;
#[macro_use]
extern crate clap_derive;

use clap::{App, Arg};

#[derive(ArgEnum, Debug)]
enum ArgChoice {
    Foo,
    Bar,
    Baz,
}

fn main() {
    let matches = App::new(env!(&quot;CARGO_PKG_NAME&quot;))
            .arg(Arg::with_name(&quot;arg&quot;)
                .required(true)
                .takes_value(true)
                .possible_values(&amp;ArgChoice::variants())
            ).get_matches();
    
    let t = value_t!(matches.value_of(&quot;arg&quot;), ArgChoice)
        .unwrap_or_else(|e| e.exit());

    println!(&quot;{:?}&quot;, t);
}
</code></pre>
<p>Will derive this:</p>
<pre><code class="language-rust">impl ::std::str::FromStr for ArgChoice {
    type Err = String;
    fn from_str(input: &amp;str) -&gt; ::std::result::Result&lt;Self, Self::Err&gt; {
        match input {
            val if ::std::ascii::AsciiExt::eq_ignore_ascii_case(val, &quot;Foo&quot;) =&gt; Ok(ArgChoice::Foo),
            val if ::std::ascii::AsciiExt::eq_ignore_ascii_case(val, &quot;Bar&quot;) =&gt; Ok(ArgChoice::Bar),
            val if ::std::ascii::AsciiExt::eq_ignore_ascii_case(val, &quot;Baz&quot;) =&gt; Ok(ArgChoice::Baz),
            _ =&gt; Err({
                let v = [&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;];



                ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                    &amp;[&quot;valid values: &quot;],
                    &amp;match (&amp;v.join(&quot; ,&quot;),) {
                        (__arg0,) =&gt; {
                            [
                                ::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt),
                            ]
                        }
                    },
                    &amp;[
                        ::std::fmt::rt::v1::Argument {
                            position: ::std::fmt::rt::v1::Position::At(0usize),
                            format: ::std::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::std::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::std::fmt::rt::v1::Count::Implied,
                                width: ::std::fmt::rt::v1::Count::Implied,
                            },
                        },
                    ],
                ))
            }),
        }
    }
}
impl ArgChoice {
    fn variants() -&gt; [&amp;'static str; 3usize] {
        [&quot;Foo&quot;, &quot;Bar&quot;, &quot;Baz&quot;]
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-11-12 18:52</div>
            <div class="timeline-body"><p>Hey!</p>
<p>cc @TeXitoi</p>
<p>Excellent! This is a great start towards my ideas for 3.x. I've cc'd @TeXitoi because I'd like to re-invigorate the move towards 3.x and finishing the CustomDerive piece is a big part of that movement. With my job monopolizing my time this kind of fell off in #835 but now that the <a href="https://github.com/kbknapp/clap-rs/tree/v3-master">v3-master branch</a> is coming together it's worth working towards again.</p>
<p>The grand plan is to create a <code>clap_derive</code> crate which contains <code>#[derive(*)]</code> directives:</p>
<ul>
<li><code>ArgEnum</code> as you've done :heart_eyes:</li>
<li><code>IntoApp</code> which takes an arbitrary struct and creates a <code>clap::App</code> (currently implemented in <a href="https://github.com/TeXitoi/structopt"><code>structopt</code></a> which I'd like to pull into this <code>clap_derive</code> crate)</li>
<li><code>FromArgMatches</code> which takes a <code>clap::ArgMatches</code> struct and creates the arbitrary struct (also implemented in <code>structopt</code>)</li>
<li><code>ClapApp</code> which is a convenience marking and simply does <em>both</em> <code>IntoApp</code> and <code>FromArgMatches</code></li>
<li><code>ClapKey</code> (name?...maybe <code>ArgKey</code>?) which allows using an enum instead of strings to access <code>clap::Arg</code>s, <code>clap::App</code>s (formerly <code>clap::SubCommand</code>s in v2.x), and <code>clap::ArgGroup</code>s.</li>
</ul>
<p>I was tentatively planning on storing all the <code>clap_*</code> crates (I'm also moving the shell completions to <code>clap_completions</code> and macros to <code>clap_macros</code>) at the root of the clap repo, but individual repos are OK as well, although I'd like everything to versioned in lock-step which is harder in individual repos.</p>
<p>If both @Hoverbear and @TeXitoi think the design is sound/doable I'd like to make PRs against the v3-master branch, or if keeping individual repos is better, making PRs against the <code>clap_derive</code> crate. If that's the route we go, I would like to transfer the crate to me in order to provide less confusion to the community as this would be part of the &quot;official&quot; clap crates, however I would also like to keep/add @Hoverbear and @TeXitoi as authors in the <code>Cargo.toml</code> because they the ones deserving of it. Also at that point, both would become collaborators on this repo so they could continue to work on this even when I'm busy with my day job.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-11-12 19:06</div>
            <div class="timeline-body"><p>Here are the unknowns still, and what needs to be decided</p>
<h3>Supporting Subcommands via CustomDerive</h3>
<p>We need to find out how to support a struct with arbitrary options/flags and also a subcommand, and how that gets represented via CustomDerive. I believe @TeXitoi suggested an enum, where each variant holds it's arbitrary struct representation. I'm good with this, and we just need to work towards ironing out the details and actually implementing. I believe this would also require adding another <code>#[derive(*)]</code> directive such as <code>ClapSubCommand</code> for enums which are to represent a subcommand.</p>
<p>The hard part is how does this work ergonomically.</p>
<p>Some code examples. I want the end user result to be as close as possible to to this:</p>
<pre><code class="language-rust">#[derive(ClapApp)]
struct MyApp {
    flag: bool,
    subcommand: MySubCommand
}

#[derive(ClapSubCommand)]
enum MySubCommand {
    Foo(FooCommand),
    Bar(BarCommand),
}

#[derive(ClapApp)]
struct FooCommand {
    verbose: bool
}

#[derive(ClapApp)]
struct BarCommand {
    name: String
}

fn main() {
    // run with `$ myapp bar kevin`
    let app = MyApp::parse();
    match app.subcommand {
        FooCommand(foo) =&gt; println!(&quot;Verbose used?: {:?}&quot;, foo.verbose),
        BarCommand(bar) =&gt; println!(&quot;Hello {}!&quot;, bar.name),
        _ =&gt; println!(&quot;No subcommand used.&quot;),
    }
}
</code></pre>
<h3>Supporting ASCII Case Insensitive ArgEnums</h3>
<p>As @Hoverbear and I discussed briefly at RustBeltRust, we need these ArgEnums to be case insensitive, but I'd also like an opt-in version that <em>is</em> case sensitive (perhaps via a different <code>#[derive(*)]</code> directive...<code>ArgEnumCaseSenseitive</code>? To incentivise case insensitivity due to typing length?</p>
<h3>Supporting Hyphens <code>-</code> in ArgEnums</h3>
<p>There's also discussion in #1098 about if hyphens should be ignored or allowed, etc. I'm inclined to either allow hyphens (i.e. ignore them) or require special chars such as underscore (<code>_</code>) to allow them. Bottom line is there should be a way for people to use hyphens in their <code>ArgEnum</code>s</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1037.html">clap-rs/clap#1037</a> on 2017-11-12 19:15</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Hoverbear">@Hoverbear</a> on 2017-11-12 19:28</div>
            <div class="timeline-body"><p>@kbknapp Please be aware custom derive crates must <strong>only</strong> contain custom derives. So we'd need a <code>clap_derive</code> crate with all of them in it separate from <code>clap</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Hoverbear">@Hoverbear</a> on 2017-11-12 19:29</div>
            <div class="timeline-body"><p>For case sensitivity around <code>ArgEnum</code> we could have an attribute that is <code>#[case_insensitive]</code>, for example.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Hoverbear">@Hoverbear</a> on 2017-11-12 19:33</div>
            <div class="timeline-body"><p>@kbknapp You should have a transfer request in your inbox.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-11-12 19:44</div>
            <div class="timeline-body"><blockquote>
<p>Please be aware custom derive crates must only contain custom derives. So we'd need a clap_derive crate with all of them in it separate from clap</p>
</blockquote>
<p>Ah ok I wasn't aware of this having not done much with CustomDerive. OK separate repos it is, I'm good with it :smile:  :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-11-12 19:49</div>
            <div class="timeline-body"><p>This issue was moved to kbknapp/clap-derives#1</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @kbknapp on 2017-11-12 19:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1659.html">clap-rs/clap#1659</a> on 2020-02-03 09:17</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:47:02 UTC
    </footer>
</body>
</html>
