<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic subcommands - clap-rs/clap #5109</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Dynamic subcommands</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/5109">#5109</a>
        opened by <a href="https://github.com/diegofariasm">@diegofariasm</a>
        on 2023-09-01 22:53
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/diegofariasm">@diegofariasm</a></div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Clap Version</h3>
<p>clap = { version = &quot;4.3.1&quot;, features = [&quot;derive&quot;] }</p>
<h3>Describe your use case</h3>
<h2>What i want to do:</h2>
<p>In my use case, i want to be able to make the cli adapt to ther user environment.
That means that i want the cli to be able to change depending on what it is fed.</p>
<h4>Examples</h4>
<blockquote>
<p>User has two monitors
Runs the cli
Gets subcommands for two monitors</p>
</blockquote>
<blockquote>
<p>User has one monitor
Runs the cli
Gets subcommands for one monitor</p>
</blockquote>
<h3>Describe the solution you'd like</h3>
<p>I though about having, for example, a way to read subcommands from a file and feed it to the cli.</p>
<p>For example:</p>
<blockquote>
<p>config.toml</p>
</blockquote>
<pre><code>[volume]
increase = &quot;increase volume&quot;
decrease = &quot;decrease volume&quot;
</code></pre>
<p>That would look something like this:</p>
<pre><code>const CLAP_JSON = read_from_file(&quot;cli,json)&quot;

let app: clap::App = serde_json::from_str::&lt;clap_serde::CommandWrap&gt;(CLAP_JSON)
    .expect(&quot;parse failed&quot;)
    .into();


</code></pre>
<h3>Alternatives, if applicable</h3>
<p>I though about using clap_serde, which seems to actually fit my requirements. But, in the other hand, seems to be deprecated.</p>
<h3>Additional Context</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @diegofariasm on 2023-09-01 22:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Subcommands based on other inputs" to "Dynamic subcommands" by @diegofariasm on 2023-09-02 11:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/diegofariasm">@diegofariasm</a> on 2023-09-04 23:26</div>
            <div class="timeline-body"><p>I have actually managed to do it. Not the prettiest code, but you can check it out:</p>
<p>Disclamer: i am not really that used to rust. As you can see, it's just not my best code.</p>
<pre><code>use clap::ArgMatches;
use std::collections::HashMap;
use std::path::PathBuf;
mod config;
mod utils;

fn string_to_static_str(s: String) -&gt; &amp;'static str {
    Box::leak(s.into_boxed_str())
}

fn iterate_groups(group: &amp;config::CommandGroup, group_name: String) -&gt; clap::Command {
    let group_command_about = group.about.clone();
    let group_command_name = string_to_static_str(group_name);

    let mut group_command = clap::Command::new(group_command_name)
        .about(group_command_about)
        .subcommand_required(true);

    if let Some(commands) = &amp;group.commands {
        for (command_name, command) in commands {
            let about = command.about.clone();
            let name = string_to_static_str(command_name.clone());

            group_command = group_command.subcommand(clap::Command::new(name).about(about));
        }
    }

    if let Some(groups) = &amp;group.groups {
        for (sub_group_name, sub_group) in groups.iter() {
            let sub_group_app = iterate_groups(sub_group, sub_group_name.clone());

            group_command = group_command.subcommand(sub_group_app);
        }
    }

    group_command
}

fn collect_subcommand_names(matches: &amp;ArgMatches) -&gt; Vec&lt;String&gt; {
    let mut names = Vec::new();

    if let Some(subcommand_name) = matches.subcommand_name() {
        names.push(subcommand_name.to_string());

        if let Some(submatches) = matches.subcommand_matches(subcommand_name) {
            names.extend(collect_subcommand_names(submatches));
        }
    }

    names
}

fn cli_config() -&gt; HashMap&lt;String, config::CommandGroup&gt; {
    let config_file_path = PathBuf::from(&quot;maiden.toml&quot;); // Replace with your actual file path

    let parsed_config = match config::load(config_file_path) {
        Ok(parsed_config) =&gt; parsed_config,
        Err(err) =&gt; {
            panic!(&quot;Failed to load config. {}&quot;, err);
        }
    };

    parsed_config
}

fn cli(parsed_config: &amp;HashMap&lt;String, config::CommandGroup&gt;) -&gt; clap::Command {
    let mut app = clap::Command::new(&quot;maiden&quot;)
        .about(&quot;abouter tool for controlling things like volume, brightness and etc.&quot;)
        .subcommand_required(true);

    for (name, group) in parsed_config {
        // Add the matched subcommand to the cli.
        // The iterate through will automatically go through
        // any of the nested groups.
        app = app.subcommand(iterate_groups(&amp;group, name.clone()));
    }

    app
}

fn find_command(
    group: &amp;config::CommandGroup,
    names: &amp;[String],
    cli_cfg: &amp;HashMap&lt;String, config::CommandGroup&gt;,
) {
    if let Some(commands) = &amp;group.commands {
        for (command_name, command) in commands {
            if names.contains(&amp;command_name) {
                // Run the &quot;bin&quot; specified in the toml file.
                // This also uses the args defined there.
                match utils::run_command(&amp;command.bin, &amp;command.args) {
                    Ok(output) =&gt; {
                        // Print the output so other things can use.
                        // For example: if using deflisten on eww,
                        // you could use this wrapper to run the scripts.
                        println!(&quot;{}&quot;, output)
                    }
                    Err(e) =&gt; {
                        panic!(&quot;Failed to run: {}&quot;, e);
                    }
                }
            }
        }
    }
    if let Some(groups) = &amp;group.groups {
        for (sub_group_name, sub_group) in groups.iter() {
            if names.contains(&amp;sub_group_name) {
                find_command(sub_group, names, cli_cfg);
            }
        }
    }
}

fn main() {
    let cli_cfg = cli_config();
    let cli = cli(&amp;cli_cfg);

    let matches = cli.get_matches();
    let names = collect_subcommand_names(&amp;matches);

    // Match the used command.
    // It is matched against the config.
    // Later, i will rework this so you can also add normal commands.
    for name in &amp;names {
        if let Some(group) = cli_cfg.get(name) {
            find_command(group, &amp;names, &amp;cli_cfg);
        }
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @diegofariasm on 2023-09-04 23:26</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:49:12 UTC
    </footer>
</body>
</html>
