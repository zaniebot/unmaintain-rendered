<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Add support for using enums in place of strings - clap-rs/clap #459</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Add support for using enums in place of strings</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/459">#459</a>
        opened by <a href="https://github.com/hgrecco">@hgrecco</a>
        on 2016-03-26 15:29
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/hgrecco">@hgrecco</a></div>
            <div class="timeline-body"><p>I have been using <code>clap-rs</code> for a while now and I find it very useful. The only annoying thing is that most things are <code>stringly typed</code>. For example, notice how we need to check for strings in the following example:</p>
<pre><code>enum Mode {
    A,
    B,
    C,
}

let matches = App::new(&quot;example&quot;)
                        .arg(Arg::with_name(&quot;ModeA&quot;)
                                    .short(&quot;a&quot;))
                        .arg(Arg::with_name(&quot;ModeB&quot;)
                                    .short(&quot;b&quot;))
                        .arg(Arg::with_name(&quot;ModeC&quot;)
                                    .short(&quot;c&quot;))
                        .group(ArgGroup::with_name(&quot;mode&quot;)
                                            .required(true)
                                            .args(&amp;[&quot;ModeA&quot;, &quot;ModeB&quot;, &quot;ModeC&quot;]))
                        .get_matches();

    let mode = if matches.is_present(&quot;ModeA&quot;) {
        Mode::A
    } else if matches.is_present(&quot;ModeB&quot;) {
        Mode::B
    } else {
        Mode::C
    };

    // Do something
</code></pre>
<p>Here we are using strings not only in the part related to the arguments but also to deal with them afterwards. I would like to keep all the strings (which are prone to errors) in one part. I think there is no way, right?</p>
<p>I would like something like (syntax is debatable):</p>
<pre><code>let matches = App::new(&quot;example&quot;)
                        .arg(Arg::with_enum_value(Mode::A)
                                    .short(&quot;a&quot;))
                        .arg(Arg::with_enum_value(Mode::B)
                                    .short(&quot;b&quot;))
                        .arg(Arg::with_enum_value(Mode::C)
                                    .short(&quot;c&quot;))
                        .group(ArgGroup::with_name(&quot;mode&quot;)
                                            .required(true)
                                            .enum(Mode)
                        .get_matches();

    let mode =  matches.value_of(&#x27;mode&#x27;);

    // Do something
</code></pre>
<p>Where the <code>enum_args</code> check that all enum values exhausted and <code>matches.value_of(&#x27;mode&#x27;)</code> returns the chosen enum value (not a string). If you do not want all values as arguments, you could do something like:</p>
<pre><code>        .enum_values(&amp;[Mode::A, Mode::B])
</code></pre>
<p>Something similar could be done for subcommands.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:32</div>
            <div class="timeline-body"><p>This is a problem (&quot;stringly typed&quot;) I&#x27;ve been thinking about a lot, and have always leaned towards an auto serialized version to solve it although wasn&#x27;t sure of a good way to do this.</p>
<p>Your way, using enums is a very cool idea that I hadn&#x27;t thought of! On top of that, it could absolutely be added without breaking backwards compatibility.</p>
<p>I&#x27;m really excited to try this out and see how it plays out. My free time is a little limited over the next week, but I&#x27;ll test out some ideas and see how it all plays out. I&#x27;ll post back here for discussion on the topic.</p>
<p>Thanks for submitting this :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: intermediate</span> added by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">P3: want to have</span> added by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 2.x</span> added by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from &quot;Using Enums all over&quot; to &quot;Add support for using enums in place of strings&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to <a href="https://github.com/kbknapp">@kbknapp</a> by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-26 16:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/joshtriplett">@joshtriplett</a> on 2016-03-27 03:42</div>
            <div class="timeline-body"><p>I&#x27;m quite interested in this as well.  In particular, when I have a <code>matches m.subcommand()</code> block, I&#x27;d like rustc to tell me if I&#x27;ve added a new subcommand but failed to add the corresponding implementation.  If the subcommands correspond to an enum, then rustc&#x27;s existing warning for non-exhaustive matches of an enum will handle that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-27 04:28</div>
            <div class="timeline-body"><p>I think I can have an initial implementation of this done tomorrow if all goes as planned. I&#x27;ve played with some simple ideas and really like how it works thus far.</p>
<p>The hard part will be doing this in a way that isn&#x27;t breaking if it changes the <code>ArgMatches</code> struct (i.e. <code>ArgMatches&lt;&#x27;a&gt;</code> -&gt; <code>ArgMatches&lt;&#x27;a, A&gt;</code> is technically breaking. But I have some ideas for a way around this where all existing code should work as is...worse case scenario I bump to <code>clap</code> v3 as this is a big enough win that I&#x27;m willing to do so for all the reasons @joshtriplett and @hgrecco have mentioned, along with other such instances adding args, or changing args, etc (i.e. all the downsides of &quot;stringly typed&quot; things).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/joshtriplett">@joshtriplett</a> on 2016-03-27 04:57</div>
            <div class="timeline-body"><p>@kbknapp Sounds awesome!</p>
<p>In the same spirit as docopt&#x27;s macro version, it&#x27;d be nice if clap could write the enum for me: I write the subcommands, and clap gives me back a freshly minted enum of subcommands.  Ditto for argument groups as @hgrecco suggested.  That said, this would be great even if I have to write the enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;2.3&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-27 20:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-28 02:57</div>
            <div class="timeline-body"><p>Good news, I&#x27;ve got this working with subcommands thus far. Next to implement Args and should be just as straight forward.</p>
<p>Anywhere you used to use a string to access a subcommand, you can now use a enum variant if it implements the proper traits. Or you can use a macro implement said traits automatically.</p>
<p>You can see #465 for details, but this is what it looks like:</p>
<pre><code>#[macro_use]
extern crate clap;
use clap::{App, SubCommand};

// Note lowercase variants, the subcommand will be exactly as typed here 
// (because of this, cannot contain hyphens, or rust keywords...for those see below)
subcommands!{
    enum MyProg {
        show,
        delete,
        make
    }
}

// Alternatively, if you wish to have variants which display
// differently, contain hyphens (&quot;-&quot;), or use Rust keywords, one can use this variation of
// the macro
subcommands!{
    enum MyProgAlt {
        Show =&gt; &quot;show&quot;,
        Delete =&gt; &quot;delete&quot;,
        DoStuff =&gt; &quot;do-stuff&quot;
    }
}

fn main() {
    let m = App::new(&quot;myprog&quot;)
        .subcommand(SubCommand::with_name(MyProg::show))
        .subcommand(SubCommand::with_name(MyProg::delete))
        .subcommand(SubCommand::with_name(MyProg::make))
        .get_matches();

    match m.subcommand() {
        (MyProg::show, _) =&gt; println!(&quot;&#x27;myprog show&#x27; was used&quot;),
        (MyProg::delete, _) =&gt; println!(&quot;&#x27;myprog delete&#x27; was used&quot;),
        (MyProg::make, _) =&gt; println!(&quot;&#x27;myprog make&#x27; was used&quot;),
        (MyProg::None, _) =&gt; println!(&quot;No subcommand was used&quot;), // The &quot;None&quot; variant is automatically added to denote &quot;No subcommand used&quot;
    }
}
</code></pre>
<p>The macro does a good bit, but it can all be done manually if one so chooses. Things one would need to do in order to use an enum as the name</p>
<ul>
<li>Implement <code>clapp::SubCommandKey</code> which defines two methods used internally by <code>clap</code>. One to denote the &quot;none&quot; variant, and one to convert from a &quot;&amp;str&quot; to the enum cheaply.</li>
<li>Implement <code>std::convert::AsRef&lt;str&gt;</code> which does the opposite of enum-&gt;&amp;str conversion</li>
</ul>
<p>The macro actually does a little more than that, but it&#x27;s not required. The macro also:</p>
<ul>
<li>defines a <code>variants()</code> function which returns an array of <code>&amp;&#x27;static str</code>s which contains the variant names</li>
<li>Implements <code>std::fmt::Display</code> for each variant</li>
<li>Adds the <code>None</code> variant.</li>
</ul>
<p>I expect <code>Args</code> to similar and should be done soon. Once all is good, docs are updated, examples added, etc. I&#x27;ll merge the PR.</p>
<p>This <em>does</em> contain a <em>very slight</em> breaking change that should affect very few in the wild, only require a single line change. So I&#x27;m debating just doing a bump to 2.3 and giving fair notice to anyone it would affect.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/joshtriplett">@joshtriplett</a> on 2016-03-28 03:56</div>
            <div class="timeline-body"><p>Nice!  That looks really promising.</p>
<p>A few things that jump out at me:</p>
<p>Rather than adding a None variant, might it make sense to return an Option instead?  Then, subcommand_name or subcommand can return Some(show) or None.  (Likely possible manually via the trait, but defaults matter, and it seems odd to add a None to an enum rather than wrapping it in Option.  Plus, Option has a pile of existing methods and helper functions.)</p>
<p>Also, could <code>clap_app!</code> and <code>clap_yaml!</code> automatically generate the enum?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-28 15:05</div>
            <div class="timeline-body"><p>@joshtriplett</p>
<blockquote>
<p>Rather than adding a None variant, might it make sense to return an Option instead?</p>
</blockquote>
<p><code>subcommand_name()</code> returns an option, so the <code>None</code> value isn&#x27;t really possible from there. It will return <code>Option::None</code> if no subcommand was used. Unfortunately <code>subcommand()</code> returns a tuple for convenience sake, and changing to an <code>Option</code> would be a much larger breaking change.</p>
<p>The more I think about it though, the more I kind of just want to bump to 3x and it correctly. i.e. <code>Option</code> the wrap the tuple, and remove the <code>Option</code> from the <code>ArgMatches</code> since it can&#x27;t really ever be a <code>Option::None</code> value. And remove the <code>None</code> variant from the subcommand. We&#x27;ll see....</p>
<blockquote>
<p>could clap_app! and clap_yaml! automatically generate the enum?</p>
</blockquote>
<p>I don&#x27;t think so. I mean they <em>technically</em> could, but the enum would be limited to the scope of the function they&#x27;re declared in so the usefulness is somewhat limited.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hgrecco">@hgrecco</a> on 2016-03-29 00:00</div>
            <div class="timeline-body"><p>I agree with @kbknapp about the enum and the version.</p>
<p>About the enum, I think that explicit is better than implicit (Sorry about my python bias!).</p>
<p>Regarding the version,  My opinion is that even if the new version was fully backwards compatible, bumping to 3x is the right thing to do. This is a powerful new feature which will change the way we build big apps (and even small ones). Using enums will finally allow us to put all the strings in just one part (when we say that, eg, <code>.short(&quot;c&quot;)</code>) bringing Rust safety to argument parsing. Notice that <code>clap</code> already provides a lot of safety that is more annoying to implement by hand (for example with <code>required</code>). This feature closes the last hole.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x</span> added by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-29 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 2.x</span> removed by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-29 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;3.0&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-29 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone &quot;2.3&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-03-29 01:27</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/joshtriplett">@joshtriplett</a> on 2016-06-09 19:56</div>
            <div class="timeline-body"><p>In the same spirit of attempting to provide more structured types, would it make sense to support (but not require) filling in an argument structure?  For instance:</p>
<pre><code>subcommands!{
    enum MyProg {
        log { verbose: bool, patch: bool, branch: String },
        diff { format: DiffFormat, context: usize, stat: bool, from: String },
    }
}
</code></pre>
<p><code>subcommands!</code> could then parse the parameters and fill in the structure.</p>
<p>(It might make sense to write the structure and generate the options from that, or it might make sense to write the options and let clap generate the structure; the latter would make it easier to provide help, short names, and other data.  It might also make sense to have separate structures, and in any case to have a separate structure for the top-level non-subcommand options.  Either way, though, I&#x27;d love to have structured parameters.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-12-27 04:34</div>
            <div class="timeline-body"><p>Waiting on Macros 1.1 in order to just use a <code>custom_derive</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap#818</a> on 2017-01-18 14:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap#817</a> on 2017-01-30 04:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drusellers">@drusellers</a> on 2017-05-02 12:31</div>
            <div class="timeline-body"><p>Stoked to see this coming along. Type safety FTW</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/WaDelma">@WaDelma</a> on 2017-12-06 20:58</div>
            <div class="timeline-body"><p>I would also be happy to have this. Custom derives are even stable now!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-12-06 23:13</div>
            <div class="timeline-body"><p>See kbknapp/clap-derive#6 for related discussion</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone &quot;3.0&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2018-02-02 01:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;v3-alpha1&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2018-02-02 01:51</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2018-07-22 02:41</div>
            <div class="timeline-body"><p>Closing this issue in favor of #1104</p>
<p>This issue still serves as good back-reading though for the problem.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/kbknapp">@kbknapp</a> on 2018-07-22 02:41</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap_derive#23</a> on 2019-12-20 19:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>drogue-iot/drg#4</a> on 2021-03-17 05:27</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:56:23 UTC
    </footer>
</body>
</html>
