```yaml
number: 167
title: add benchmarks
type: issue
state: closed
author: kbknapp
labels:
  - C-enhancement
  - A-parsing
assignees: []
created_at: 2015-07-27T12:25:07Z
updated_at: 2018-08-02T03:29:41Z
url: https://github.com/clap-rs/clap/issues/167
synced_at: 2026-01-10T01:57:39Z
```

# add benchmarks

---

_Issue opened by @kbknapp on 2015-07-27 12:25_

_No description provided._

---

_Label `T: enhancement` added by @kbknapp on 2015-07-27 12:25_

---

_Label `D: easy` added by @kbknapp on 2015-07-27 12:25_

---

_Label `P3: want to have` added by @kbknapp on 2015-07-27 12:25_

---

_Label `C: parsing` added by @kbknapp on 2015-07-27 12:25_

---

_Label `E: tedious` added by @kbknapp on 2015-07-27 12:25_

---

_Comment by @severen on 2015-07-28 07:17_

I could try and do this next week, doesn't this require the Rust nightly though?


---

_Comment by @kbknapp on 2015-07-28 10:31_

That would be awesome! Yep it does, but you can use a cargo "feature" to only compile the benchmarks when on nightly. Just use the `unstable` feature. 


---

_Referenced in [clap-rs/clap#168](../../clap-rs/clap/pulls/168.md) on 2015-07-29 21:57_

---

_Comment by @kbknapp on 2015-07-30 22:59_

As per the gitter chat, here's the things I'd like to see some benchmarks on:

Using the `clap-tests` binary as a base since it contains a decent number of options and rules:

``` rust
    let m_val_names = ["one", "two"];
    let args = "-o --option=[opt]... 'tests options'
                [positional] 'tests positionals'";
    let opt3_vals = ["fast", "slow"];
    let pos3_vals = ["vi", "emacs"];
    let matches = App::new("claptests")
                        // Test version from Cargo.toml
                        .version(&crate_version!()[..])
                        .about("tests clap library")
                        .author("Kevin K. <kbknapp@gmail.com>")
                        .args_from_usage(args)
                        .arg(Arg::from_usage("-f --flag... 'tests flags'")
                            .global(true))
                        .args(vec![
                            Arg::from_usage("[flag2] -F 'tests flags with exclusions'").conflicts_with("flag").requires("option2"),
                            Arg::from_usage("--long-option-2 [option2] 'tests long options with exclusions'").conflicts_with("option").requires("positional2"),
                            Arg::from_usage("[positional2] 'tests positionals with exclusions'"),
                            Arg::from_usage("-O --Option [option3] 'tests options with specific value sets'").possible_values(&opt3_vals),
                            Arg::from_usage("[positional3]... 'tests positionals with specific values'").possible_values(&pos3_vals),
                            Arg::from_usage("--multvals [multvals] 'Tests mutliple values, not mult occs'").value_names(&m_val_names),
                            Arg::from_usage("--multvalsmo [multvalsmo]... 'Tests mutliple values, not mult occs'").value_names(&m_val_names),
                            Arg::from_usage("--minvals2 [minvals]... 'Tests 2 min vals'").min_values(2),
                            Arg::from_usage("--maxvals3 [maxvals]... 'Tests 3 max vals'").max_values(3)
                        ])
                        .subcommand(SubCommand::with_name("subcmd")
                                                .about("tests subcommands")
                                                .version("0.1")
                                                .author("Kevin K. <kbknapp@gmail.com>")
                                                .arg_from_usage("-o --option [scoption]... 'tests options'")
                                                .arg_from_usage("[scpositional] 'tests positionals'"));
```
- Time to build the app
- Time to parse a clean (no arguments) run
- Time to parse a single valid flag
- Time to parse a single valid option
- Time to parse a single valid positional
- Time to parse a single valid subcommand
- Repeat all with subcommand (i.e. single valid subcommand with single flag, etc.)
- Time to parse a complex run (i.e. multiple flags/options/positionals, all valid) such as `claptests -ff -o some arg1 -O fast arg2 --multvals one two three`

Anything else you can think of is welcome ;)


---

_Referenced in [clap-rs/clap#186](../../clap-rs/clap/pulls/186.md) on 2015-08-27 08:40_

---

_Comment by @sru on 2015-08-30 03:01_

``` rust
extern crate test;

use super::{App, Arg, SubCommand};

use self::test::Bencher;

#[bench]
fn build_app(b: &mut Bencher) {
    let m_val_names = ["one", "two"];
    let args = "-o --option=[opt]... 'tests options'
                            [positional] 'tests positionals'";
    let opt3_vals = ["fast", "slow"];
    let pos3_vals = ["vi", "emacs"];

    b.iter(|| App::new("claptests")
                // Test version from Cargo.toml
                .version("0.1")
                .about("tests clap library")
                .author("Kevin K. <kbknapp@gmail.com>")
                .args_from_usage(args)
                .arg(Arg::from_usage("-f --flag... 'tests flags'")
                             .global(true))
                .args(vec![
                          Arg::from_usage("[flag2] -F 'tests flags with exclusions'").conflicts_with("flag").requires("option2"),
                          Arg::from_usage("--long-option-2 [option2] 'tests long options with exclusions'").conflicts_with("option").requires("positional2"),
                          Arg::from_usage("[positional2] 'tests positionals with exclusions'"),
                          Arg::from_usage("-O --Option [option3] 'tests options with specific value sets'").possible_values(&opt3_vals),
                          Arg::from_usage("[positional3]... 'tests positionals with specific values'").possible_values(&pos3_vals),
                          Arg::from_usage("--multvals [multvals] 'Tests mutliple values, not mult occs'").value_names(&m_val_names),
                          Arg::from_usage("--multvalsmo [multvalsmo]... 'Tests mutliple values, not mult occs'").value_names(&m_val_names),
                          Arg::from_usage("--minvals2 [minvals]... 'Tests 2 min vals'").min_values(2),
                          Arg::from_usage("--maxvals3 [maxvals]... 'Tests 3 max vals'").max_values(3)
                    ])
                .subcommand(SubCommand::with_name("subcmd")
                                        .about("tests subcommands")
                                        .version("0.1")
                                        .author("Kevin K. <kbknapp@gmail.com>")
                                        .arg_from_usage("-o --option [scoption]... 'tests options'")
                                        .arg_from_usage("[scpositional] 'tests positionals'")));
}
```

I got the "Time to build the app" part working although I am not confident that it is measuring what it is suppose to measure.
- `crate_version!` macro does not work because of lifetime issues that I don't understand.
- Writing `App::new(...)` for every single benchmark would be hard to maintain & tedious. I tried writing function or macro to return the test `App` struct without much success.
- I assume we measure the build time because getting parsing time alone is impossible (`.get_matches_from` consumes the `self`).
- I get about 22 +- 1 milliseconds running above benchmark.

I made separate `benchmarks.rs` in `src` folder and added it into the `lib.rs` file. However, it can also be inside the `tests.rs` file.


---

_Comment by @kbknapp on 2015-08-30 03:25_

> I got the "Time to build the app" part working although I am not confident that it is measuring what it is suppose to measure

My goal is measure how long it takes `clap` to parse out all the valid options and be ready to actually start the parsing. Because until things like syntax extensions become usable on stable Rust, all that parsing has to happen at runtime. So I want to make sure we're taking as little time as possible to actually "parse and store all possible valid options" before actually parsing the string the user gives at the command line.

> `crate_verison!` macro does not work because of lifetime issues that I don't understand.

I'm not worried about testing that. Using `crate_version` is the same performance wise as passing in a `&'static str` to `version()` because the computation happens at compile time; so there's any additional overhead.

> Writing App::new(...) for every single benchmark would be hard to maintain & tedious. I tried writing function or macro to return the test App struct without much success.

This should be possible. You can start a PR and place all these benchmarks in a `benchmarks` directory (similar to `tests`) so I can take a look.

> I assume we measure the build time because getting parsing time alone is impossible (.get_matches_from consumes the self)

Correct. This way when we _do_ measure parsing time, we can subtract the build time (because it'll have to be re-built on each iteration).

> I get about 22 +- 1 milliseconds running above benchmark.

Hopefully you mean nanoseconds...miliseconds would be quite long :stuck_out_tongue_winking_eye: 

> I made separate benchmarks.rs in src folder and added it into the lib.rs file. However, it can also be inside the tests.rs file

I'd move it to a `benchmarks` folder like the `tests` folder so we can break them out if need-be. Thanks for all the work on this! :+1: 


---

_Comment by @sru on 2015-08-30 03:51_

~~Interestingly, Cargo does not pick up benchmarks from `benchmarks` folder.~~

EDIT: It has to be named `benches`.

The performance is crap probably because I am running it inside VM.


---

_Referenced in [clap-rs/clap#203](../../clap-rs/clap/pulls/203.md) on 2015-08-30 04:12_

---

_Comment by @kbknapp on 2015-08-30 04:15_

Ah yeah, could be - I just checked on a native i7 laptop and I get ~14,000 nanoseconds :wink:


---

_Referenced in [clap-rs/clap#214](../../clap-rs/clap/pulls/214.md) on 2015-09-01 16:02_

---

_Comment by @kbknapp on 2015-09-07 02:18_

@sru Do you have additional benchmarks you'd like to add, or should this issue be closed?


---

_Comment by @sru on 2015-09-07 02:40_

@kbknapp not for now. This issue can be closed.


---

_Comment by @kbknapp on 2015-09-07 02:41_

Sounds good :+1:


---

_Closed by @kbknapp on 2015-09-07 02:41_

---
