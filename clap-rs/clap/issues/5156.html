<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show the type of arguments in help message? - clap-rs/clap #5156</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Show the type of arguments in help message?</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/clap-rs/clap/issues/5156">#5156</a>
        opened by <a href="https://github.com/epage">@epage</a>
        on 2023-10-02 17:47
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/epage">@epage</a> on 2023-10-02 17:47</div>
            <div class="timeline-body"><h3>Discussed in https://github.com/clap-rs/clap/discussions/5153</h3>
<div type='discussions-op-text'>

<p><sup>Originally posted by <strong>tigerros</strong> October  1, 2023</sup>
Let's say you have this:</p>
<pre><code class="language-rust">#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
pub struct MyParser {
    #[arg(long)]
    pub foo: u32,
}
</code></pre>
<p>Running <code>--help</code> will show this message:</p>
<pre><code>Options:
      --foo &lt;FOO&gt;
  -h, --help       Print help
  -V, --version    Print version
</code></pre>
<p>Is it possible to also show the type? For example:</p>
<pre><code>--foo &lt;FOO&gt; (unsigned 32 bit integer)
</code></pre>
<p><code>u32</code> would be nice, but it's not standard.</div></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2023-10-02 17:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-help</span> added by @epage on 2023-10-02 17:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-derive</span> added by @epage on 2023-10-02 17:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-design</span> added by @epage on 2023-10-02 17:47</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-10-02 17:47</div>
            <div class="timeline-body"><blockquote>
<p>There is an argument parser for another language that does this; I wish I could remember which.</p>
<p>If we did this, it could work to fill in similar to <code>[possible values: foo, bar]</code> in style.</p>
<p>However, I'm concerned about</p>
<ul>
<li><p>Clutter in the help output</p>
</li>
<li><p>Not being in the user's terms (while most CLI users are programmers, not all are), even if its &quot;unsigned 32 bit integer&quot;.</p>
</li>
</ul>
<p>However, the <code>value_name</code> fills a similar role and I think it'd be a worthwhile to look into leveraging that. <code>long</code> and <code>id</code> are more akin to a field name while <code>value_name</code> is more akin to the type (in flags, positionals are weird in that they need to convey both). Framing this way, makes me feel like we could have a type associated term as the value name.</p>
<p>I had considered such a thing in #2683 but held off in #3732.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-10-02 17:56</div>
            <div class="timeline-body"><p>My thought</p>
<ul>
<li>Add to <code>TypedValueParser</code> a <code>fn value_name(&amp;self) -&gt; String</code> with an inherent impl that returns <code>VALUE</code><ul>
<li>Update various built-in value parsers to return a meaningful name</li>
<li>Add to <code>TypedValueParser</code> a <code>fn deferred_name(&amp;self, name: impl Fn() -&gt; String) -&gt; NamedValueParser</code> so it can be added to closures, etc</li>
<li>Adjust things so deriving <code>ValueEnum</code> will also allow setting <code>deferred_name</code>, with the default being the type's name, turned into SCREAMING_CASE</li>
<li>Add a setting to some value parsers so users can decide between showing the values vs name</li>
</ul>
</li>
<li>Update <code>--help</code> to show the value parser's <code>value_name</code> for flags<ul>
<li>Is there anything we can do for positionals?</li>
<li>Is the divergence between named and positional values worth it?</li>
</ul>
</li>
</ul>
<p>So this would look like</p>
<ul>
<li><code>--option &lt;BOOL&gt;</code> (placeholder) or <code>--option &lt;true|false&gt;</code> (literal</li>
<li><code>--option &lt;PATH&gt;</code><ul>
<li><a href="https://docs.rs/clio/latest/clio/">clio</a> could then specialize this further as <code>--option &lt;FILE&gt;</code> and <code>--option &lt;DIR&gt;</code></li>
</ul>
</li>
<li><code>--option &lt;NUM&gt;</code> (placeholder) or <code>--option &lt;10..30&gt;</code> (literal)</li>
<li><code>--option &lt;MY_ENUM&gt;</code> (placeholder) or <code>--option &lt;foo|bar&gt;</code> (literal)</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tigerros">@tigerros</a> on 2023-10-02 18:36</div>
            <div class="timeline-body"><blockquote>
<ul>
<li>Clutter in the help output</li>
<li>Not being in the user's terms (while most CLI users are programmers, not all are), even if its &quot;unsigned 32 bit integer&quot;.</li>
</ul>
</blockquote>
<p>By making it optional both of these issues are solved, no?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-10-02 20:01</div>
            <div class="timeline-body"><p>In clap, we have to balance features with compile time, binary size, and API size.   Adding the suggested solution for a niche would hurt the whole.   If you are set on it being implemented that way, you can extend your doc comments to include the type information.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-11-06 19:09</div>
            <div class="timeline-body"><p>We talked about this some in the WG-CLI meeting</p>
<p>We'd like to keep configuration down to a minimum due to compile time + binary size concerns.  This means we'd likely not want to make placerholder vs literal configurable.  In that case, we leaned towards literals (when a meaningful enough one can be made).  If we default to literals, then working around it with <code>value_name(&quot;10..30&quot;)</code> requires them to duplicate information they provide to clap.  On the other hand, if we default to literals, then the work around is to do <code>value_name(&quot;NUM&quot;)</code> which is a unique textual representation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-11-06 19:24</div>
            <div class="timeline-body"><p>Current proposal</p>
<p>Add:</p>
<pre><code class="language-rust">trait TypedValueParser {
    // ... existing

    /// Fallback for [`Arg::value_name`] for options
    fn get_value_name(&amp;self) -&gt; Option&lt;String&gt; {
        None
    }

    /// Fallback for [`Arg::value_name`] for options
    fn value_parser(self, name: fn() -&gt; String) -&gt; NamedValueParser {
        NamedValueParser { name, self }
    }
}

pub NamedValueParser {
    name: fn() -&gt; String,
    inner: impl TypedValueParser
}

// ....

let value_names = if let Some(value_names) = arg.get_value_names() {
    value_names
} else if arg.is_positional() {
    [arg.get_id()]
} else {
    self.get_value_parser().get_value_names()
};
</code></pre>
<p>Hmm, the main problem with this is this mostly helps <code>clap_derive</code> and <code>clap_derive</code> <a href="https://github.com/clap-rs/clap/blob/master/clap_derive/src/derives/args.rs#L252">implicitly calls <code>Arg::value_name</code></a>.  So we'd need to decide if we wanted to make that conditional or not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-11-09 16:25</div>
            <div class="timeline-body"><p>Just realized that a way to force showing of the literal would be to respect hide_possible_values.  This would help cases like #5203.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/5392.html">clap-rs/clap#5392</a> on 2024-11-14 18:07</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-05-22 13:49</div>
            <div class="timeline-body"><p>In addition to help, we should ensure we cover the &quot;missing required argument&quot; error as mentioned in #6008.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6008.html">clap-rs/clap#6008</a> on 2025-05-22 13:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6056.html">clap-rs/clap#6056</a> on 2025-08-06 16:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6109.html">clap-rs/clap#6109</a> on 2025-08-25 14:50</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/380.html">clap-rs/clap#380</a> on 2025-09-08 15:24</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:35:30 UTC
    </footer>
</body>
</html>
