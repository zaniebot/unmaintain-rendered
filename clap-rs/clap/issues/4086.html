<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>default_value_if derive macro has no effect - clap-rs/clap #4086</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>default_value_if derive macro has no effect</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/4086">#4086</a>
        opened by <a href="https://github.com/grebnetiew">@grebnetiew</a>
        on 2022-08-17 11:08
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/grebnetiew">@grebnetiew</a></div>
            <div class="timeline-body">Please complete the following tasks
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
Rust Version
<p>rustc 1.62.0 (a8314ef7d 2022-06-27)</p>
Clap Version
<p>3.2.17</p>
Minimal reproducible code
<pre><code>use clap::Parser;

#[derive(Parser)]
struct Config {
    #[clap(long)]
    aaa: String,
    #[clap(long, default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;)))]
    bbb: String,
}

fn main() {
    // Be sure to enable the &#x27;derive&#x27; feature of clap in Cargo.toml
    let _ = Config::parse();
}
</code></pre>
Steps to reproduce the bug with the above code
<p>@thomasTNO</p>
<pre><code>cargo run -- --aaa Hello
</code></pre>
Actual Behaviour
<pre><code>error: The following required arguments were not provided:
    --bbb &lt;BBB&gt;

USAGE:
    bug --aaa &lt;AAA&gt; --bbb &lt;BBB&gt;

For more information try --help
</code></pre>
Expected Behaviour
<p>The program ends successfully.</p>
Additional Context
<p>The equivalent argument definition in the builder pattern does work:</p>
<pre><code>use clap::{Arg, Command};

fn main() {
    let _ = Command::new(&quot;app&quot;)
        .arg(Arg::new(&quot;aaa&quot;).long(&quot;aaa&quot;).takes_value(true))
        .arg(
            Arg::new(&quot;bbb&quot;)
                .long(&quot;bbb&quot;)
                .takes_value(true)
                .default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;)),
        )
        .get_matches();
}
</code></pre>
<p>My colleague @thomasTNO first discovered this bug and can also provide clarifications.</p>
Debug Output

  Hidden because of the length - click here to expand
<pre>
    Finished dev [unoptimized + debuginfo] target(s) in 0.01s
     Running `target/debug/bug --aaa Hello`
[      clap::builder::command] 	Command::_do_parse
[      clap::builder::command] 	Command::_build: name=&quot;bug&quot;
[      clap::builder::command] 	Command::_propagate:bug
[      clap::builder::command] 	Command::_check_help_and_version: bug
[      clap::builder::command] 	Command::_check_help_and_version: Removing generated version
[      clap::builder::command] 	Command::_propagate_global_args:bug
[      clap::builder::command] 	Command::_derive_display_order:bug
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Arg::_debug_asserts:aaa
[clap::builder::debug_asserts] 	Arg::_debug_asserts:bbb
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;--aaa&quot;)&#x27; ([45, 45, 97, 97, 97])
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;--aaa&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::parse_long_arg
[        clap::parser::parser] 	Parser::parse_long_arg: Does it contain &#x27;=&#x27;...
[        clap::parser::parser] 	Parser::parse_long_arg: Found valid arg or flag &#x27;--aaa &#x27;
[        clap::parser::parser] 	Parser::parse_long_arg(&quot;aaa&quot;): Found an arg with value &#x27;None&#x27;
[        clap::parser::parser] 	Parser::parse_opt_value; arg=aaa, val=None, has_eq=false
[        clap::parser::parser] 	Parser::parse_opt_value; arg.settings=ArgFlags(REQUIRED | TAKES_VAL)
[        clap::parser::parser] 	Parser::parse_opt_value; Checking for val...
[        clap::parser::parser] 	Parser::parse_opt_value: More arg vals required...
[        clap::parser::parser] 	Parser::get_matches_with: After parse_long_arg Opt(aaa)
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;Hello&quot;)&#x27; ([72, 101, 108, 108, 111])
[        clap::parser::parser] 	Parser::split_arg_values; arg=aaa, val=RawOsStr(&quot;Hello&quot;)
[        clap::parser::parser] 	Parser::split_arg_values; trailing_values=false, DontDelimTrailingVals=false
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=aaa, resolved=0, pending=1
[        clap::parser::parser] 	Parser::resolve_pending: id=aaa
[        clap::parser::parser] 	Parser::react action=StoreValue, identifier=Some(Long), source=CommandLine
[        clap::parser::parser] 	Parser::react: cur_idx:=1
[        clap::parser::parser] 	Parser::remove_overrides: id=aaa
[   clap::parser::arg_matcher] 	ArgMatcher::start_occurrence_of_arg: id=aaa
[      clap::builder::command] 	Command::groups_for_arg: id=aaa
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;Hello&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=2
[      clap::builder::command] 	Command::groups_for_arg: id=aaa
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=aaa, resolved=1, pending=0
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:aaa:
[        clap::parser::parser] 	Parser::add_default_value:iter:aaa: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:aaa: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:bbb:
[        clap::parser::parser] 	Parser::add_default_value:iter:bbb: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: has conditional defaults
[        clap::parser::parser] 	Parser::split_arg_values; arg=bbb, val=RawOsStr(&quot;b&quot;)
[        clap::parser::parser] 	Parser::split_arg_values; trailing_values=false, DontDelimTrailingVals=false
[        clap::parser::parser] 	Parser::react action=StoreValue, identifier=None, source=DefaultValue
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=bbb, source=DefaultValue
[      clap::builder::command] 	Command::groups_for_arg: id=bbb
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;b&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=3
[      clap::builder::command] 	Command::groups_for_arg: id=bbb
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=bbb, resolved=1, pending=0
[     clap::parser::validator] 	Validator::validate
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=aaa
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=aaa
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([Child { id: aaa, children: [] }, Child { id: bbb, children: [] }])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::gather_requires:iter:aaa
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[     clap::parser::validator] 	Validator::validate_required:iter:aog=bbb
[     clap::parser::validator] 	Validator::validate_required:iter: This is an arg
[     clap::parser::validator] 	Validator::is_missing_required_ok: bbb
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=bbb
[      clap::builder::command] 	Command::groups_for_arg: id=bbb
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=bbb, conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=aaa
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=aaa, conflicts=[]
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::missing_required_error; incl=[]
[     clap::parser::validator] 	Validator::missing_required_error: reqs=ChildGraph([Child { id: aaa, children: [] }, Child { id: bbb, children: [] }])
[         clap::output::usage] 	Usage::get_required_usage_from: incls=[], matcher=true, incl_last=true
[         clap::output::usage] 	Usage::get_required_usage_from: unrolled_reqs={aaa, bbb}
[         clap::output::usage] 	Usage::get_required_usage_from:iter:aaa arg is_present=true
[         clap::output::usage] 	Usage::get_required_usage_from:iter:bbb arg is_present=false
[         clap::output::usage] 	Usage::get_required_usage_from: ret_val={&quot;--bbb &quot;}
[     clap::parser::validator] 	Validator::missing_required_error: req_args=[
    &quot;--bbb &quot;,
]
[         clap::output::usage] 	Usage::create_usage_with_title
[         clap::output::usage] 	Usage::create_usage_no_title
[         clap::output::usage] 	Usage::create_smart_usage
[         clap::output::usage] 	Usage::get_required_usage_from: incls=[aaa], matcher=false, incl_last=true
[         clap::output::usage] 	Usage::get_required_usage_from: unrolled_reqs={aaa, bbb}
[         clap::output::usage] 	Usage::get_required_usage_from:iter:aaa arg is_present=false
[         clap::output::usage] 	Usage::get_required_usage_from:iter:bbb arg is_present=false
[         clap::output::usage] 	Usage::get_required_usage_from:iter:aaa arg is_present=false
[         clap::output::usage] 	Usage::get_required_usage_from: ret_val={&quot;--aaa &quot;, &quot;--bbb &quot;}
[      clap::builder::command] 	Command::color: Color setting...
[      clap::builder::command] 	Auto
error: The following required arguments were not provided:
    --bbb 

<p>USAGE:
bug --aaa  --bbb </p>
<p>For more information try --help
</pre></p>


</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by <a href="https://github.com/grebnetiew">@grebnetiew</a> on 2022-08-17 11:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/grebnetiew">@grebnetiew</a> on 2022-08-17 11:17</div>
            <div class="timeline-body"><p>Running <code>cargo expand</code> on the minimal reproducible code does produce a builder version with <code>default_value_if</code>:</p>
<pre><code>                        .value_parser(clap::builder::ValueParser::string())
                        .action(clap::ArgAction::StoreValue);
                    let arg = arg.long(&quot;bbb&quot;).default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;));
                    arg
                });
</code></pre>
<p>Nevertheless, the default value is not used if <code>--aaa</code> is present.</p>
Click here for the full main.rs with expanded derive macros<pre>
#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use clap::Parser;
struct Config {
    #[clap(long)]
    aaa: String,
    #[clap(long, default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;)))]
    bbb: String,
}
impl clap::Parser for Config {}
#[allow(dead_code, unreachable_code, unused_variables, unused_braces)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
)]
#[deny(clippy::correctness)]
#[allow(deprecated)]
impl clap::CommandFactory for Config {
    fn into_app&lt;&#x27;b&gt;() -&gt; clap::Command&lt;&#x27;b&gt; {
        let __clap_app = clap::Command::new(&quot;bug&quot;);
        ::augment_args(__clap_app)
    }
    fn into_app_for_update&lt;&#x27;b&gt;() -&gt; clap::Command&lt;&#x27;b&gt; {
        let __clap_app = clap::Command::new(&quot;bug&quot;);
        ::augment_args_for_update(__clap_app)
    }
}
#[allow(dead_code, unreachable_code, unused_variables, unused_braces)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
)]
#[deny(clippy::correctness)]
impl clap::FromArgMatches for Config {
    fn from_arg_matches(
        __clap_arg_matches: &clap;::ArgMatches,
    ) -&gt; ::std::result::Result {
        Self::from_arg_matches_mut(&mut; __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut; clap::ArgMatches,
    ) -&gt; ::std::result::Result {
        #![allow(deprecated)]
        let v = Config {
            aaa: __clap_arg_matches
                .get_one::(&quot;aaa&quot;)
                .map(|s| ::std::ops::Deref::deref(s))
                .ok_or_else(|| clap::Error::raw(
                    clap::ErrorKind::MissingRequiredArgument,
                    {
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;[&quot;The following required argument was not provided: &quot;],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;&quot;aaa&quot;)],
                            ),
                        );
                        res
                    },
                ))
                .and_then(|s| {
                    ::std::str::FromStr::from_str(s)
                        .map_err(|err| clap::Error::raw(
                            clap::ErrorKind::ValueValidation,
                            {
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &amp;[&quot;Invalid value for &quot;, &quot;: &quot;],
                                        &amp;[
                                            ::core::fmt::ArgumentV1::new_display(&amp;&quot;aaa&quot;),
                                            ::core::fmt::ArgumentV1::new_display(&err;),
                                        ],
                                    ),
                                );
                                res
                            },
                        ))
                })?,
            bbb: __clap_arg_matches
                .get_one::(&quot;bbb&quot;)
                .map(|s| ::std::ops::Deref::deref(s))
                .ok_or_else(|| clap::Error::raw(
                    clap::ErrorKind::MissingRequiredArgument,
                    {
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;[&quot;The following required argument was not provided: &quot;],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;&quot;bbb&quot;)],
                            ),
                        );
                        res
                    },
                ))
                .and_then(|s| {
                    ::std::str::FromStr::from_str(s)
                        .map_err(|err| clap::Error::raw(
                            clap::ErrorKind::ValueValidation,
                            {
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &amp;[&quot;Invalid value for &quot;, &quot;: &quot;],
                                        &amp;[
                                            ::core::fmt::ArgumentV1::new_display(&amp;&quot;bbb&quot;),
                                            ::core::fmt::ArgumentV1::new_display(&err;),
                                        ],
                                    ),
                                );
                                res
                            },
                        ))
                })?,
        };
        ::std::result::Result::Ok(v)
    }
    fn update_from_arg_matches(
        &mut; self,
        __clap_arg_matches: &clap;::ArgMatches,
    ) -&gt; ::std::result::Result&lt;(), clap::Error&gt; {
        self.update_from_arg_matches_mut(&mut; __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut(
        &mut; self,
        __clap_arg_matches: &mut; clap::ArgMatches,
    ) -&gt; ::std::result::Result&lt;(), clap::Error&gt; {
        #![allow(deprecated)]
        if __clap_arg_matches.contains_id(&quot;aaa&quot;) {
            #[allow(non_snake_case)]
            let aaa = &mut; self.aaa;
            *aaa = __clap_arg_matches
                .get_one::(&quot;aaa&quot;)
                .map(|s| ::std::ops::Deref::deref(s))
                .ok_or_else(|| clap::Error::raw(
                    clap::ErrorKind::MissingRequiredArgument,
                    {
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;[&quot;The following required argument was not provided: &quot;],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;&quot;aaa&quot;)],
                            ),
                        );
                        res
                    },
                ))
                .and_then(|s| {
                    ::std::str::FromStr::from_str(s)
                        .map_err(|err| clap::Error::raw(
                            clap::ErrorKind::ValueValidation,
                            {
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &amp;[&quot;Invalid value for &quot;, &quot;: &quot;],
                                        &amp;[
                                            ::core::fmt::ArgumentV1::new_display(&amp;&quot;aaa&quot;),
                                            ::core::fmt::ArgumentV1::new_display(&err;),
                                        ],
                                    ),
                                );
                                res
                            },
                        ))
                })?;
        }
        if __clap_arg_matches.contains_id(&quot;bbb&quot;) {
            #[allow(non_snake_case)]
            let bbb = &mut; self.bbb;
            *bbb = __clap_arg_matches
                .get_one::(&quot;bbb&quot;)
                .map(|s| ::std::ops::Deref::deref(s))
                .ok_or_else(|| clap::Error::raw(
                    clap::ErrorKind::MissingRequiredArgument,
                    {
                        let res = ::alloc::fmt::format(
                            ::core::fmt::Arguments::new_v1(
                                &amp;[&quot;The following required argument was not provided: &quot;],
                                &amp;[::core::fmt::ArgumentV1::new_display(&amp;&quot;bbb&quot;)],
                            ),
                        );
                        res
                    },
                ))
                .and_then(|s| {
                    ::std::str::FromStr::from_str(s)
                        .map_err(|err| clap::Error::raw(
                            clap::ErrorKind::ValueValidation,
                            {
                                let res = ::alloc::fmt::format(
                                    ::core::fmt::Arguments::new_v1(
                                        &amp;[&quot;Invalid value for &quot;, &quot;: &quot;],
                                        &amp;[
                                            ::core::fmt::ArgumentV1::new_display(&amp;&quot;bbb&quot;),
                                            ::core::fmt::ArgumentV1::new_display(&err;),
                                        ],
                                    ),
                                );
                                res
                            },
                        ))
                })?;
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(dead_code, unreachable_code, unused_variables, unused_braces)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
)]
#[deny(clippy::correctness)]
impl clap::Args for Config {
    fn augment_args&lt;&#x27;b&gt;(__clap_app: clap::Command&lt;&#x27;b&gt;) -&gt; clap::Command&lt;&#x27;b&gt; {
        {
            let __clap_app = __clap_app;
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new(&quot;aaa&quot;)
                        .takes_value(true)
                        .value_name(&quot;AAA&quot;)
                        .required(true &amp;&amp; clap::ArgAction::StoreValue.takes_values())
                        .validator(|s| {
                            ::std::str::FromStr::from_str(s).map(|_: String| ())
                        })
                        .value_parser(clap::builder::ValueParser::string())
                        .action(clap::ArgAction::StoreValue);
                    let arg = arg.long(&quot;aaa&quot;);
                    arg
                });
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new(&quot;bbb&quot;)
                        .takes_value(true)
                        .value_name(&quot;BBB&quot;)
                        .required(true &amp;&amp; clap::ArgAction::StoreValue.takes_values())
                        .validator(|s| {
                            ::std::str::FromStr::from_str(s).map(|_: String| ())
                        })
                        .value_parser(clap::builder::ValueParser::string())
                        .action(clap::ArgAction::StoreValue);
                    let arg = arg.long(&quot;bbb&quot;).default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;));
                    arg
                });
            __clap_app
        }
    }
    fn augment_args_for_update&lt;&#x27;b&gt;(__clap_app: clap::Command&lt;&#x27;b&gt;) -&gt; clap::Command&lt;&#x27;b&gt; {
        {
            let __clap_app = __clap_app;
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new(&quot;aaa&quot;)
                        .takes_value(true)
                        .value_name(&quot;AAA&quot;)
                        .required(false &amp;&amp; clap::ArgAction::StoreValue.takes_values())
                        .validator(|s| {
                            ::std::str::FromStr::from_str(s).map(|_: String| ())
                        })
                        .value_parser(clap::builder::ValueParser::string())
                        .action(clap::ArgAction::StoreValue);
                    let arg = arg.long(&quot;aaa&quot;);
                    arg
                });
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new(&quot;bbb&quot;)
                        .takes_value(true)
                        .value_name(&quot;BBB&quot;)
                        .required(false &amp;&amp; clap::ArgAction::StoreValue.takes_values())
                        .validator(|s| {
                            ::std::str::FromStr::from_str(s).map(|_: String| ())
                        })
                        .value_parser(clap::builder::ValueParser::string())
                        .action(clap::ArgAction::StoreValue);
                    let arg = arg.long(&quot;bbb&quot;).default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;));
                    arg
                });
            __clap_app
        }
    }
}
fn main() {
    let _ = Config::parse();
}
</pre>

</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-08-17 16:26</div>
            <div class="timeline-body"><p>The builder is equivalent of</p>
<pre><code>#!/usr/bin/env -S rust-script --debug

//! ```cargo
//! [dependencies]
//! clap = { version = &quot;3.2&quot;, features = [&quot;derive&quot;, &quot;debug&quot;] }
//! ```

use clap::{Arg, Command};

fn main() {
    let _ = Command::new(&quot;app&quot;)
        .arg(Arg::new(&quot;aaa&quot;).long(&quot;aaa&quot;).takes_value(true).required(true))
        .arg(
            Arg::new(&quot;bbb&quot;)
                .long(&quot;bbb&quot;)
                .takes_value(true)
                .default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;))
                .required(true),
        )
        .get_matches();
}
</code></pre>
<p>Note the <code>required(true)</code></p>
<p>So to fix this, you need to override the <code>required(true)</code> call:</p>
<pre><code>#!/usr/bin/env -S rust-script --debug

//! ```cargo
//! [dependencies]
//! clap = { version = &quot;3.2&quot;, features = [&quot;derive&quot;, &quot;debug&quot;] }
//! ```

use clap::Parser;

#[derive(Parser)]
struct Config {
    #[clap(long)]
    aaa: String,
    #[clap(long, default_value_if(&quot;aaa&quot;, None, Some(&quot;b&quot;)), required = false)]
    bbb: String,
}

fn main() {
    // Be sure to enable the &#x27;derive&#x27; feature of clap in Cargo.toml
    let _ = Config::parse();
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jimmy-Z">@Jimmy-Z</a> on 2022-08-25 11:00</div>
            <div class="timeline-body"><p>I also encountered this today:</p>
<pre><code>use clap::Parser;

#[derive(Parser, Debug)]
struct Args {
    #[clap(short)]
    a: bool,
    #[clap(short, default_value_t = 0, default_value_if(&quot;a&quot;, Some(&quot;true&quot;), Some(&quot;42&quot;)))]
    b: u8,
}

fn main(){
    println!(&quot;{:?}&quot;, Args::parse());
    println!(&quot;{:?}&quot;, Args::parse_from([&quot;&quot;, &quot;-a&quot;]));
}
</code></pre>
<p>output</p>
<pre><code>Args { a: false, b: 0 }
Args { a: true, b: 0 }
</code></pre>
<p>I&#x27;d expect the second b to be 42.</p>
<p>on playground:
https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=7364fa83ea195e952288e5c52c1dfb5b</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jimmy-Z">@Jimmy-Z</a> on 2022-08-25 11:10</div>
            <div class="timeline-body"><p>@epage &#x27;s <code>required = false</code> fix above does fix the original case but not in the case I presented above, should I open a new issue?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-08-25 11:52</div>
            <div class="timeline-body"><p>The default action for a <code>bool</code> / flag is to only mark it as present / not-present.  To make that work, you would do</p>
<pre><code>#!/usr/bin/env -S rust-script --debug

//! ```cargo
//! [dependencies]
//! clap = { version = &quot;3.2&quot;, features = [&quot;derive&quot;, &quot;debug&quot;] }
//! ```

use clap::Parser;

#[derive(Parser, Debug)]
struct Args {
    #[clap(short)]
    a: bool,
    #[clap(short, default_value_t = 0, default_value_if(&quot;a&quot;, None, Some(&quot;42&quot;)))]
    b: u8,
}

fn main() {
    let a = Args::parse();
    dbg!(a);
}
</code></pre>
<p>In clap v4 we are changing that behavior and you can opt-in by adding a defaulted <code>action</code> attribute</p>
<pre><code>#!/usr/bin/env -S rust-script --debug

//! ```cargo
//! [dependencies]
//! clap = { version = &quot;3.2&quot;, features = [&quot;derive&quot;, &quot;debug&quot;] }
//! ```

use clap::Parser;

#[derive(Parser, Debug)]
struct Args {
    #[clap(short, action)]
    a: bool,
    #[clap(
        short,
        default_value_t = 0,
        default_value_if(&quot;a&quot;, Some(&quot;true&quot;), Some(&quot;42&quot;))
    )]
    b: u8,
}

fn main() {
    let a = Args::parse();
    dbg!(a);
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Jimmy-Z">@Jimmy-Z</a> on 2022-08-25 12:11</div>
            <div class="timeline-body"><p>Thanks for the workaround but isn&#x27;t it a little counter-intuitive? after all the 2nd a is true.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-08-25 13:46</div>
            <div class="timeline-body"><p>This is a side effect of the Builder API that underlies the Derive API.  I agree with &quot;present&quot;/&quot;not-present&quot; not being ideal which is one of the reasons we are moving away from it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/epage">@epage</a> on 2022-08-25 13:47</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:59:13 UTC
    </footer>
</body>
</html>
