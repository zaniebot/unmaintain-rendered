<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AppSettings::SubcommandsNegateReqs may cause panic in Clap::parse(), Clap::try_parse() - clap-rs/clap #2255</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>AppSettings::SubcommandsNegateReqs may cause panic in Clap::parse(), Clap::try_parse()</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/2255">#2255</a>
        opened by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a>
        on 2020-12-14 02:16
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a> on 2020-12-14 02:16</div>
            <div class="timeline-body"><h3>Clap version</h3>
<p>3.0.0-beta.2</p>
<h3>Where</h3>
<p>https://docs.rs/clap/3.0.0-beta.2/clap/enum.AppSettings.html#variant.SubcommandsNegateReqs</p>
<h3>What's wrong</h3>
<p>There's no mention that this AppSetting can cause the Clap derive macro to panic on parse() and try_parse()</p>
<h3>How to fix</h3>
<pre><code>use clap::{AppSettings, Clap, IntoApp, FromArgMatches};

#[derive(Debug, Clap)]
#[clap(setting(AppSettings::SubcommandsNegateReqs))]
struct ExOpts {
    
    req_str: String,

    #[clap(subcommand)]
    pub cmd: Option&lt;SubCommands&gt;,
}

#[derive(Debug, Clap)]
enum SubCommands{
    ExSub {
        #[clap(short, long, parse(from_occurrences))]
        verbose: u8
    },
}

fn main(){

    // We cant use Clap::parse or try_parse because we have SubcommandsNegateReqs enabled
    // this would cause a panic when Clap attempts to parse the req_str arg that isn't there
    // let opts = ExOpts::parse(); // panics
    // let opts = ExOpts::try_parse(); // panics 

    // Instead we need to check to see if a subcommand exists before we run from_arg_matches on ExOpts
    let matches = ExOpts::into_app().get_matches();
    if matches.subcommand_name().is_none() {
        // If no subcommand we can derive ExOpts
        let opts = ExOpts::from_arg_matches(&amp;matches);
        println!(&quot;{:?}&quot;, opts);
    } else {
        // If subcommand we need derive the subcommands instead
        let cmd_opts = SubCommands::from_arg_matches(&amp;matches);
        println!(&quot;{:?}&quot;, cmd_opts);
    }

}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: docs</span> added by @BeldrothTheGold on 2020-12-14 02:16</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "3.0" by @pksunkara on 2020-12-14 02:17</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-12-14 02:17</div>
            <div class="timeline-body"><p>What's the panic message you were getting?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a> on 2020-12-14 02:18</div>
            <div class="timeline-body"><p>thread 'main' panicked at 'called <code>Option::unwrap()</code> on a <code>None</code> value', src/main.rs:7:14
note: run with <code>RUST_BACKTRACE=1</code> environment variable to display a backtrace</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-12-14 02:19</div>
            <div class="timeline-body"><p>Try changing to the following and describe what happens (with error message):</p>
<pre><code class="language-rust">    #[clap(required = true)]
    req_str: Option&lt;String&gt;,
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-12-14 02:21</div>
            <div class="timeline-body"><p>Definitely needs to be documented though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a> on 2020-12-14 02:24</div>
            <div class="timeline-body"><p>Oh wait. Haha, sorry. No it still panics. Sorry.</p>
<p>$ cargo run -- ex-sub
Finished dev [unoptimized + debuginfo] target(s) in 0.02s
Running <code>target/debug/clap-ex ex-sub</code>
thread 'main' panicked at 'called <code>Option::unwrap()</code> on a <code>None</code> value', src/main.rs:9:14
note: run with <code>RUST_BACKTRACE=1</code> environment variable to display a backtrace</p>
<pre><code>#[allow(unused_imports)]
use clap::{AppSettings, Clap, IntoApp, FromArgMatches};

#[derive(Debug, Clap)]
#[clap(setting(AppSettings::SubcommandsNegateReqs))]
struct ExOpts {

    #[clap(required = true)]
    req_str: String,

    #[clap(subcommand)]
    pub cmd: Option&lt;SubCommands&gt;,
}

#[derive(Debug, Clap)]
enum SubCommands{
    ExSub {
        #[clap(short, long, parse(from_occurrences))]
        verbose: u8
    },
}

fn main(){

    // We cant use Clap::parse or try_parse because we have SubcommandsNegateReqs enabled
    // this would cause a panic when Clap attempts to parse the req_str arg that isn't there
    let opts = ExOpts::parse(); // panics
    println!(&quot;{:?}&quot;, opts);

}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-12-14 02:26</div>
            <div class="timeline-body"><p>It's probably better to find a way to get this working though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-12-14 02:26</div>
            <div class="timeline-body"><p>Huh, you haven't done <code>req_str: Option&lt;String&gt;</code>. Please try with that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a> on 2020-12-14 02:29</div>
            <div class="timeline-body"><p>This does not compile.</p>
<pre><code class="language-rust">    #[clap(required = true)]
    req_str: Option&lt;String&gt;,
</code></pre>
<pre><code>error: required is meaningless for Option
 --&gt; src/main.rs:8:12
  |
8 |     #[clap(required = true)]
  |            ^^^^^^^^

error: aborting due to previous error
</code></pre>
<p>this does compile but req_str is no longer required</p>
<pre><code class="language-rust">    req_str: Option&lt;String&gt;
</code></pre>
<pre><code> cargo run -- 
   Compiling clap-ex v0.1.0 (/home/scummin2/dev/rust/clap-ex)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/clap-ex`
Ok(ExOpts { req_str: None, cmd: None })
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a> on 2020-12-14 02:32</div>
            <div class="timeline-body"><p>At the very least it might be a good idea to make a try_from_arg_matches() fn which can bubble up any issues so try_parse doesn't panic</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Document AppSettings::SubcommandsNegateReqs may cause panic in Clap::parse(), Clap::try_parse()" to "AppSettings::SubcommandsNegateReqs may cause panic in Clap::parse(), Clap::try_parse()" by @BeldrothTheGold on 2021-02-15 03:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BeldrothTheGold">@BeldrothTheGold</a> on 2021-02-15 03:05</div>
            <div class="timeline-body"><p>found this related issue in structopt repo https://github.com/TeXitoi/structopt/issues/124</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2614.html">clap-rs/clap#2614</a> on 2021-07-21 21:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-10-05 15:01</div>
            <div class="timeline-body"><p>tl;dr</p>
<ul>
<li>We can't make the listed example work because we don't have a way to instantiate <code>req_string</code></li>
<li>If we update our derive to allow <code>required = true</code> with <code>Option</code>, this gives people the flexibility to create their own solution for this</li>
<li>As this is development time, I think a panic is acceptable (its like an assert)<ul>
<li>Unrelated to this, we should also be allowing proper error reporting, rather than panicing, for our derives</li>
</ul>
</li>
</ul>
<p>Did a quick update to this to clarify things for me</p>
<pre><code class="language-rust">use clap::AppSettings;
use clap::Clap;
use clap::FromArgMatches;
use clap::IntoApp;

#[derive(Debug, clap::Clap)]
#[clap(setting(AppSettings::SubcommandsNegateReqs))]
struct ExOpts {
    req_str: String,

    #[clap(subcommand)]
    pub cmd: Option&lt;SubCommands&gt;,
}

#[derive(Debug, clap::Subcommand)]
enum SubCommands {
    ExSub {
        #[clap(short, long, parse(from_occurrences))]
        verbose: u8,
    },
}

fn main() {
    // Reproduction cases
    // - `cargo run -- ex-sub`
    if true {
        // We cant use Clap::parse or try_parse because we have SubcommandsNegateReqs enabled
        // this would cause a panic when Clap attempts to parse the req_str arg that isn't there
        let opts = ExOpts::parse(); // panics
        let opts = ExOpts::try_parse(); // panics
    } else {
        // Instead we need to check to see if a subcommand exists before we run from_arg_matches on ExOpts
        let matches = ExOpts::into_app().get_matches();
        if matches.subcommand_name().is_none() {
            // If no subcommand we can derive ExOpts
            let opts = ExOpts::from_arg_matches(&amp;matches);
            println!(&quot;{:?}&quot;, opts);
        } else {
            // If subcommand we need derive the subcommands instead
            let cmd_opts = SubCommands::from_arg_matches(&amp;matches);
            println!(&quot;{:?}&quot;, cmd_opts);
        }
    }
}
</code></pre>
<p>The big problem is we have no way to instantiate <code>ExOpts</code>.  I view this as a development-time error and assert-like behavior is acceptable (a panic).</p>
<p>If we switch to</p>
<pre><code>#[derive(Debug, clap::Clap)]
#[clap(setting(AppSettings::SubcommandsNegateReqs))]
struct ExOpts {
    req_str: Option&lt;String&gt;,

    #[clap(subcommand)]
    pub cmd: Option&lt;SubCommands&gt;,
}
</code></pre>
<p>There is no longer a panic but a field is no longer required!</p>
<p>Clap will error though if you do</p>
<pre><code class="language-rust">#[derive(Debug, clap::Clap)]
#[clap(setting(AppSettings::SubcommandsNegateReqs))]
struct ExOpts {
    #[clap(required = true)]
    req_str: Option&lt;String&gt;,

    #[clap(subcommand)]
    pub cmd: Option&lt;SubCommands&gt;,
}
</code></pre>
<p>with</p>
<pre><code>error: required is meaningless for Option
 --&gt; src/main.rs:9:12
  |
9 |     #[clap(required = true)]
  |            ^^^^^^^^
</code></pre>
<p>Apparently, its not meaningless.</p>
<p>I do however feel that we should have a non-panicing way of doing our derive but for a different use case.  I maintain <code>clap-cargo</code>, a reusable set of command line flags to imitate cargo.  I want people to be able to use the builder API with it which means we have less control over the behavior and should be more careful about panicing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2021-10-05 17:01</div>
            <div class="timeline-body"><p>IMO the correct way forward here is to allow <code>#[clap(required = true)] req_string: Option&lt;String&gt;</code>, so we remove our compile error. <em>Technically</em> the <code>String</code> in the example should be an <code>Option</code> since if a subcommand is used, it has no value (other possibilities would be having a default value, or impl <code>Default</code>).</p>
<p>The hard hard becomes how do we detect that and not panic? Or rather, I'm OK with <code>panic</code>ing, so long as the message is clear as to why, and how to fix it. The easiest method is probably to have a validation step that gets run during or at the end of <code>derive</code> which looks for any problematic cases and can error (or panic since its a developer compile time error).</p>
<p>For now, that validation phase would only include a single check of is <code>AppSettings::SubcomamndsNegateReqs</code> used with a non-<code>Option</code> field (or non-<code>Default</code>/non-<code>default_value</code>). That's probably a little harder to implement than I'm making it sound, but I think that'd be a good way forward.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2817.html">clap-rs/clap#2817</a> on 2021-10-05 19:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-10-05 20:24</div>
            <div class="timeline-body"><p>Just recording some thoughts in looking at the code.</p>
<p>At the moment, the key signature here is</p>
<pre><code class="language-rust">    fn from_arg_matches(matches: &amp;ArgMatches) -&gt; Option&lt;Self&gt;;
</code></pre>
<p>The <code>Option</code> is currently used to test which <code>#[flatten] subcmd</code> matches the current command.  Reusing it for other logic would muddy the waters.  However, we could refactor this to instead use <code>has_subcommand</code> and we'd no longer attach meaning to the <code>Option</code> and it can be either an <code>Option</code> or <code>Result</code> and we can start passing up the stack.</p>
<p>However, unless we start attaching stack traces to our errors, this will make debugging a development time issue pretty difficult (no indication of what is causing the failure).  Maybe we should attach that as part of the <code>debug</code> feature or something.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2820.html">clap-rs/clap#2820</a> on 2021-10-05 20:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-10-05 23:59</div>
            <div class="timeline-body"><p>Pulling this over from #2820</p>
<blockquote>
<p>Granted, as we discussed in that issue, the developer <em>should</em> use an <code>Option</code> + <code>clap(required = true)</code>, but that is not exactly intuitive. And the <code>panic</code> message that is emitted doesn't point them in the right direction either (using the test case in the linked issue):</p>
<pre><code>thread 'required_option_type' panicked at 'app should verify arg is required', clap_derive/tests/options.rs:346:18
</code></pre>
<p>We should probably change that to something generic-ish like <code>arg 'X' should be of type Option&lt;T&gt;, and manually add #[clap(required = true)] due to conflicting attributes</code>. This doesn't say what those conflicting attributes are, because I'm not sure we want to try and enumerate all cases or detect which one triggered it, but at least points them in the right direction.</p>
</blockquote>
<p>For the message &quot;app should verify arg is required&quot;, all we know is something didn't work right and we expected a <code>Some(_)</code> but got a <code>None</code>.  This could be because</p>
<ul>
<li>A bug in <code>clap_derive</code></li>
<li>The user uncovered an unexpected combination of flags (like this Issue)</li>
<li>The user is calling <code>from_arg_matches</code> directly on the struct but set flags that clap_derive` didn't expect<ul>
<li>This might sound strange but something I'm wanting to eventually see is having crates like <code>clap-cargo</code> be usable by both the derive and non-derive API (which is why I want to switch us to error handling over panic)</li>
</ul>
</li>
</ul>
<p>We could a combination of</p>
<ul>
<li>Give preference to one error case to smooth it out, confusing users in other, more rare, error cases</li>
<li>Pattern match against known failures and provide suggestions for the user (only reactive, still could lead to other confusing cases)</li>
<li>Switch to error reporting and have <code>debug</code> feature flag also add backtraces to our errors (this just moves the problem but doesn't help with the core of it)</li>
<li>Regardless of panic or error, we can restructure the code to include more information in the panic (what field on what struct).  This will help bloat binaries though (at least it doesn't show up in our crate ;) ).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2021-10-06 00:09</div>
            <div class="timeline-body"><blockquote>
<p>For the message &quot;app should verify arg is required&quot;, all we know is something didn't work right and we expected a Some(_) but got a None.</p>
</blockquote>
<p>This message is emitted if the developer <em>doesn't</em> use an <code>Option</code>, i.e.</p>
<pre><code class="language-rust">#[derive(Debug, Clap)]
#[clap(setting(AppSettings::SubcommandsNegateReqs))]
struct ExOpts {

    #[clap(required = true)]
    req_str: String,

    #[clap(subcommand)]
    pub cmd: Option&lt;SubCommands&gt;,
}

#[derive(Debug, Clap)]
enum SubCommands{
    ExSub {
        #[clap(short, long, parse(from_occurrences))]
        verbose: u8
    },
}
</code></pre>
<p>Which is why I think the &quot;you should verify arg is required&quot; leaves one like....wut? :smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-10-06 00:12</div>
            <div class="timeline-body"><blockquote>
<p>Which is why I think the &quot;you should verify arg is required&quot; leaves one like....wut? smile</p>
</blockquote>
<p>I know its easy to miss but its &quot;app&quot;, not &quot;you&quot;, as in we expect we created the <code>App</code>s validation to prevent this case.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2827.html">clap-rs/clap#2827</a> on 2021-10-06 19:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2888.html">clap-rs/clap#2888</a> on 2021-10-15 20:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2890.html">clap-rs/clap#2890</a> on 2021-10-16 00:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Assigned to @epage by @epage on 2021-10-25 21:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2943.html">clap-rs/clap#2943</a> on 2021-10-25 23:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @bors[bot] on 2021-10-26 20:56</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3118.html">clap-rs/clap#3118</a> on 2021-12-09 16:20</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:34:23 UTC
    </footer>
</body>
</html>
