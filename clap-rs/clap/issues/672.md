```yaml
number: 672
title: How does one print help or usage when no arguments supplied?
type: issue
state: closed
author: lunemec
labels: []
assignees: []
created_at: 2016-09-29T13:50:07Z
updated_at: 2025-03-20T01:04:11Z
url: https://github.com/clap-rs/clap/issues/672
synced_at: 2026-01-10T01:57:40Z
```

# How does one print help or usage when no arguments supplied?

---

_Issue opened by @lunemec on 2016-09-29 13:50_

Hello,
I haven't found this in any of the examples, nor going through the documentation. I would like to get some usage string or the help when someone invokes the program without arguments.

If you set the argument to be required, I'd like the program to print the help instead of the error message. Is this possible?

Thank you.


---

_Comment by @nabijaczleweli on 2016-09-29 17:06_

Make at least one of the arguments required or see `AppSettings` for more options.


---

_Comment by @lunemec on 2016-09-30 05:49_

Hmm, yes, that works, but it prints the error message that at least more arguments is required, se --help for more info. I meant to print help when no arguments are supplied.

Lets say you have a App with several subcommands, but none of them are required. They are just operating mode switches, and if user just runs the program, you want to print the help message with all the subcommands listed. I don't think this is possible now, or is it?


---

_Comment by @lunemec on 2016-09-30 05:54_

Oh: ArgRequiredElseHelp that should do it. Thanks for pointing me in the right direction.


---

_Closed by @lunemec on 2016-09-30 05:54_

---

_Comment by @kbknapp on 2016-10-04 16:58_

@nabijaczleweli thanks :+1: 


---

_Comment by @ghost on 2018-03-14 21:43_

how to print it programatically?

UPDATE:
`app.print_help();` and `app.print_long_help();`

from docs:
* [print_help](https://docs.rs/clap/2.31.1/clap/struct.App.html#method.print_help)
* [print_long_help](https://docs.rs/clap/2.31.1/clap/struct.App.html#method.print_long_help)

---

_Comment by @kbknapp on 2018-03-14 22:42_

There is also `App::write_help` to use a custom `Write` object instead of just stdout.

---

_Comment by @Hubro on 2022-06-18 01:08_

How do I do this when using the derive API? How do I find a reference to the app?

For example:

```rust
#[derive(Debug, Parser)]
struct Args {
    #[clap(value_parser)]
    pattern: Option<String>,

    /// The path to a log file to parse
    #[clap(short, long, value_parser = file_exists)]
    logfile: Option<String>,
}
```

I have a pretty ugly workaround going at the moment...

```rust
// No arguments given and STDIN is a TTY, just print help and exit
if atty::is(atty::Stream::Stdin) {
    let _ = Exec::cmd(std::env::args().next().unwrap())
        .arg("--help")
        .join();
    return;
}
```

In my case, the user can provide one of:
- A positional argument
- An option
- Pipe STDIN

If the user does none of these, I want to print the help message.

---

_Comment by @epage on 2022-06-18 01:30_

Try
```rust
use clap::CommandFactory;
let mut cmd = Args::command();
cmd.print_help();
```

---

_Comment by @Hubro on 2022-06-18 11:20_

@epage That did it! I found this extremely hard to look up in the documentation, perhaps because of all the derive magic... :smile: 

---

_Comment by @epage on 2022-06-18 17:32_

One type of derive magic I try to avoid is generating code that is unrelated to the specified traits.  We push that a little bit by deriving some super traits.  So if you look at the definition of `Parser`, you'll see that `CommandFactory` also has to be implemented.

We also call it out in the [tips of the derive reference](https://github.com/clap-rs/clap/tree/master/examples/derive_ref#tips).  Still easy to miss.

btw we recommend having a test that calls `Command::debug_assert`, see https://github.com/clap-rs/clap/blob/master/examples/tutorial_derive/05_01_assert.rs

---

_Comment by @NaokiM03 on 2023-03-08 17:20_

I came here from a web search.

I noticed that I can use `arg_required_else_help` even for derive macro.

```
// clap = { version = "4.1.8", features = ["derive"] }

#[derive(Debug, Parser)]
#[command(arg_required_else_help(true))]
struct Args {
    // ...
}
```

---

_Comment by @ismet55555 on 2023-08-13 21:43_

> I came here from a web search.
> 
> I noticed that I can use `arg_required_else_help` even for derive macro.
> 
> ```
> // clap = { version = "4.1.8", features = ["derive"] }
> 
> #[derive(Debug, Parser)]
> #[command(arg_required_else_help(true))]
> struct Args {
>     // ...
> }
> ```

Thank you! This worked for me.

---

_Comment by @chibby0ne on 2025-03-20 01:04_

More generally you can use any method name for any of the `Command`, `Arg`, `PossibleValue` and other structs as a derive attributes as seen here: https://docs.rs/clap/latest/clap/_derive/index.html#terminology.

The specific attributes for `Command` are explained a bit better here: https://docs.rs/clap/latest/clap/_derive/index.html#command-attributes. The example actually mentions how `#[command(arg_required_else_help(true))]` translates to `cmd.arg_required_else_help(true)`

---
