<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Default subcommand - clap-rs/clap #975</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Default subcommand</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/clap-rs/clap/issues/975">#975</a>
        opened by <a href="https://github.com/hcpl">@hcpl</a>
        on 2017-05-29 22:35
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/hcpl">@hcpl</a> on 2017-05-29 22:35</div>
            <div class="timeline-body"><h2>Feature request</h2>
<p>This is a proposal to add a means to reduce verbosity of command-line calls.</p>
<p>The API presented here is <code>App::default_subcommand()</code> method. It is used to show how this feature can be employed, so feel free to implement the functionality however you find suitable.</p>
<h3>Description</h3>
<p>Arguments of the default subcommand are merged into arguments of the enclosing app-like entity (subcommands can exploit this behavior regarding inner subcommands too).</p>
<p>Naming conflicts are resolved by preferring the arguments defined in the enclosing entity because otherwise they would be shadowed permanently. In other words, only merge the non-conflicting arguments into the scope, whilst preserving its own conflicting ones.</p>
<p>Inspecting the presence of these arguments is done unambiguously â€” through the entity where they were defined.</p>
<h3>Sample Code</h3>
<pre><code class="language-rust">extern crate clap;
use clap::{Arg, App, SubCommand};

fn main() {
    let matches = App::new(&quot;test&quot;)
        .subcommand(SubCommand::with_name(&quot;info&quot;)
            .arg(Arg::with_name(&quot;verbose&quot;)
                .short(&quot;v&quot;)
                .long(&quot;verbose&quot;))
            .arg(Arg::with_name(&quot;PARAM&quot;)))
        .subcommand(SubCommand::with_name(&quot;sync&quot;)
            .arg(Arg::with_name(&quot;encrypt&quot;)
                .short(&quot;e&quot;)
                .long(&quot;encrypt&quot;)))
        .default_subcommand(&quot;info&quot;)    // new method
        .get_matches();

    if let Some(info) = matches.subcommand_matches(&quot;info&quot;) {
        println!(&quot;{:?}&quot;, info.is_present(&quot;verbose&quot;));
        println!(&quot;{:?}&quot;, info.value_of(&quot;PARAM&quot;));
    }

    if let Some(sync) = matches.subcommand_matches(&quot;sync&quot;) {
        println!(&quot;{:?}&quot;, sync.is_present(&quot;encrypt&quot;));
    }
}
</code></pre>
<h3>Expected Behavior Summary</h3>
<pre><code class="language-sh">$ ./clap-test    # same as ./clap-test info 
false
None
$ ./clap-test -v    # same as ./clap-test info -v
true
None
$ ./clap-test foo    # same as ./clap-test info foo
false
Some(&quot;foo&quot;)
$ ./clap-test sync -e    # sync is not default, needs to be explicitly written
true
$ ./clap-test --help    # help message is also affected
test 

USAGE:
    clap-test [SUBCOMMAND]

FLAGS:
    -e, --encrypt    
    -h, --help       Prints help information
    -V, --version    Prints version information

SUBCOMMANDS:
    help    Prints this message or the help of the given subcommand(s)
    info    
    sync    
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hcpl">@hcpl</a> on 2017-05-29 22:44</div>
            <div class="timeline-body"><p>This proposal can be extended to something like <code>App::merge_subcommand()</code> and <code>App::merge_subcommands()</code> methods which can be applied to many subcommands instead of one.</p>
<p>For this case, it should be noted that the order in which subcommands are merged matters. Otherwise, their descriptions are the same as the one for <code>App::default_subcommand()</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-05-30 00:54</div>
            <div class="timeline-body"><p>I think this is an interesting concept, but I'd be worried it could create confusion args from the &quot;default&quot; subcommand are intermixed with args from the parent subcommand such as <code>program --parent --default --parent2</code> etc.</p>
<p>Using <a href="https://docs.rs/clap/2.24.2/clap/enum.AppSettings.html#variant.InferSubcommands"><code>AppSettings::InferSubcommands</code></a> does <em>almost</em> the same thing, but with less confusion in my mind. As the verbosity is about as minimal as it gets where al these are the same as your examples:</p>
<pre><code>$ ./clap-test i    # same as ./clap-test info 
false
None
$ ./clap-test i -v    # same as ./clap-test info -v
true
None
$ ./clap-test i foo    # same as ./clap-test info foo
false
Some(&quot;foo&quot;)
$ ./clap-test s -e    # sync is not default, needs to be explicitly written
true
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> added by @kbknapp on 2017-05-30 00:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../tsoding/dimooper/pulls/234.html">tsoding/dimooper#234</a> on 2017-07-27 11:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @kbknapp on 2017-11-06 03:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1120.html">clap-rs/clap#1120</a> on 2017-12-02 20:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/keirlawson">@keirlawson</a> on 2019-06-24 08:34</div>
            <div class="timeline-body"><p>FWIW this feature would be useful to me, I'm porting and application from Python's <a href="https://click.palletsprojects.com/en/7.x/">click</a> which supports this feature and <code>InferSubcommands</code> doesn't quite cut it in my scenario as the default subcommand should be predetermined.  In my scenario I am not concerned about confusion with the arguments of the parent command as I only have the default help/options there, though I appreciate in other scenarios this would be more confusing.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../TeXitoi/structopt/issues/68.html">TeXitoi/structopt#68</a> on 2021-04-24 18:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/timboudreau">@timboudreau</a> on 2021-05-05 21:08</div>
            <div class="timeline-body"><p>While <code>AppSettings::InferSubcommands</code> is nice, where a default subcommand would really add value is <em>when you are adding subcommands to an app that did not have *any* before</em> and want existing scripts that call the app to still work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2021-05-06 00:32</div>
            <div class="timeline-body"><p>The thing is default subcommand can be implemented in non clap code by simply running that subcommand logic when no subcommand is found. We do not want add complicated parsing logic when there is an easy and actually better work around.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/SWHes">@SWHes</a> on 2021-05-16 11:10</div>
            <div class="timeline-body"><p>@pksunkara I do not completely agree with your statement. A subcommand might have a complex set of arguments. It would be quite complicate to to re-implement the arg parsing and everything clap gives. Or is there an easy way to do so ?</p>
<p>To avoid misunderstanding, what I would like is for the user to avoid typing the subcommand's name but clap to parse the subcommand's fields.</p>
<p>The difference here is &quot;default subcommand&quot; (what I need) versus &quot;default behavior&quot; (what you suggested). I hope I correctly interpreted your message.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2021-05-18 18:38</div>
            <div class="timeline-body"><blockquote>
<p>It would be quite complicate to to re-implement the arg parsing and everything clap gives</p>
</blockquote>
<p>You don't need to parse it yourself. What you can do is abstract out that subcommand args and use them on both the subcommand and the main app.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/SWHes">@SWHes</a> on 2021-05-18 21:11</div>
            <div class="timeline-body"><p>Ok but then, how do you make these args mandatory when no subcommand is given but invalid with the wrong subcommand?</p>
<p>Example:
<code>./app subcommand1 -arg1</code> is valid
<code>./app -arg1</code> is valid because <code>subcommand1</code> is implicit
<code>./app subcommand2 -arg1</code> is invalid
<code>./app -arg1 subcommand2</code> is invalid
where <code>subcommand1</code> is the default one and <code>-arg1</code> is specific to <code>subcommand1</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2021-05-18 23:27</div>
            <div class="timeline-body"><blockquote>
<p><code>./app subcommand2 -arg1</code></p>
</blockquote>
<p>I am not sure if you have even tried clap, but it is already invalid.</p>
<blockquote>
<p><code>./app -arg1 subcommand2</code> is invalid</p>
</blockquote>
<p>This might be a good argument for needing default subcommand.</p>
<p>But an earlier point raised by Kevin still stands:</p>
<blockquote>
<p>I'd be worried it could create confusion args from the &quot;default&quot; subcommand are intermixed with args from the parent subcommand such as <code>program --parent --default --parent2</code> etc</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2122.html">clap-rs/clap#2122</a> on 2021-05-20 18:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/misalcedo">@misalcedo</a> on 2022-01-14 02:49</div>
            <div class="timeline-body"><p>For posterity,
you can achieve this with clap 3.X by using a combination of <code>Arg::global</code> and <code>AppSettings::ArgsNegateSubcommands</code>.</p>
<p>For example:</p>
<pre><code class="language-rust">#[derive(Parser)]
#[clap(author, version, about)]
#[clap(global_setting(AppSettings::ArgsNegateSubcommands))]
pub struct Arguments {
    #[clap(short, long, global(true), parse(from_occurrences))]
    /// Make the subcommand more talkative.
    pub verbose: usize,
    /// The sub-command to execute.
    #[clap(subcommand)]
    pub command: Option&lt;Commands&gt;,
    #[clap(short, long)]
    /// The language that the fenced code blocks must match to be included in the output.
    pub language: Option&lt;String&gt;,
    #[clap(short, long, requires(&quot;language&quot;))]
    /// Require fenced code blocks have a language to be included in the output.
    pub required: bool,
}
</code></pre>
<p>This allows <code>binary --language foo --empty</code> but not <code>binary command --language bar</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../CertainLach/jrsonnet/issues/81.html">CertainLach/jrsonnet#81</a> on 2022-05-30 08:22</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljw1004">@ljw1004</a> on 2023-02-10 21:42</div>
            <div class="timeline-body"><p>@misalcedo Correct me if I'm wrong, but I think I see what your example does and it doesn't address the original problem statement. What @hcpl is after is something where</p>
<pre><code>binary --language foo   # allowed
binary command1 --language foo  # allowed, and is the same as the above
binary command2 --language foo  # disallowed
</code></pre>
<p>I think your approach would disallow the second line.</p>
<p>@pksunkara You suggested &quot;abstract out that subcommand args and use them on both the subcommand and the main app.&quot; I don't understand what you're describing. If you have time and it's not too much trouble, I wonder if you'd be able to explain more or write out a little example?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-10 21:56</div>
            <div class="timeline-body"><p>FYI the <a href="https://docs.rs/clap/latest/clap/_derive/_cookbook/git_derive/index.html">git cookbook entry</a> includes support for <code>git stash</code> which has a default subcommand of <code>push</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljw1004">@ljw1004</a> on 2023-02-10 22:30</div>
            <div class="timeline-body"><p>Thank you @epage. I have extracted out the minimal parts of the git cookbook entry to answer the original question in this issue:</p>
<pre><code>#[derive(Debug, clap::Parser)]
#[command(args_conflicts_with_subcommands = true)] // part 1/3 for emulating &quot;default subcommand&quot;
pub struct Arguments {
    #[clap(subcommand)]
    pub command: Option&lt;Commands&gt;,

    // part 2/3 for emulating &quot;default subcommand&quot;
    #[clap(flatten)]
    pub info: InfoArgs,
}

#[derive(Debug, clap::Subcommand)]
pub enum Commands {
    Info(InfoArgs),
    Sync,
}

#[derive(Debug, clap::Args)]
pub struct InfoArgs {
    #[clap(long)]
    pub verbose: bool,
}

pub fn main() {
    let args: Arguments = clap::Parser::parse();
    let command = args.command.unwrap_or(Commands::Info(args.info)); // part 3/3 for emulating &quot;default subcommand&quot;
    println!(&quot;{command:?}&quot;);
}
</code></pre>
<p>The solution requires three parts:</p>
<ol>
<li>We have <code>Option&lt;Commands&gt;</code> in case a subcommand such Info is specified, and <code>#[clap(flatten)] InfoArgs</code> in case a subcommand isn't specified and we therefore need to get the InfoArgs directly</li>
<li>We have <code>args_conflicts_with_subcommands = true</code> so that only one of the two paths above is taken. In particular, if the user does <code>--verbose info --verbose</code> then the first one counts as an arg, which conflicts with subcommands, and hence doesn't allow the subcommand &quot;info&quot;</li>
<li>The code uses <code>.unwrap_or</code> to pick whichever of the two paths was picked.</li>
</ol>
<p>It's not an ideal answer because the help text isn't quite right:</p>
<pre><code>$ cargo run -- --help
Usage: fiddle [OPTIONS]
       fiddle &lt;COMMAND&gt;

Commands:
  info  
  sync  
  help  Print this message or the help of the given subcommand(s)

Options:
      --verbose  
  -h, --help     Print help
</code></pre>
<p>In an ideal world, it would only document the &quot;--verbose&quot; flag if you did &quot;cargo run -- info --help&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-10 22:37</div>
            <div class="timeline-body"><blockquote>
<p>In an ideal world, it would only document the &quot;--verbose&quot; flag if you did &quot;cargo run -- info --help&quot;.</p>
</blockquote>
<p>I don't think this is universal though: I personally prefer what it currently does as it documents how it can be used without a command.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljw1004">@ljw1004</a> on 2023-02-10 23:13</div>
            <div class="timeline-body"><blockquote>
<p>as it documents how it can be used without a command.</p>
</blockquote>
<p>Strictly, both options document how it can be used, (1) the message &quot;if no command then info is assumed&quot; and (2) the current behavior.</p>
<p>The difference is with (2) the user has no indication what the difference in meaning is between &quot;--verbose&quot; and &quot;info --verbose&quot;, or indeed whether there is a difference. (We the programmer know there isn't a difference). Nor does the (2) tell the user what happens when they run the binary on its own without specifying any flags or commands. And (2) gives the impression that options are allowed with the command, while in fact they're not.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-11 01:13</div>
            <div class="timeline-body"><p>One option is to put the options under a custom help heading so it says &quot;info options&quot; or something like that</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../nextest-rs/nextest/issues/800.html">nextest-rs/nextest#800</a> on 2023-02-14 20:14</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljw1004">@ljw1004</a> on 2023-02-19 20:29</div>
            <div class="timeline-body"><p>@epage Could you clarify what you mean, please? When I try to add a custom help heading then it gives a build-time message &quot;error: methods are not allowed for flattened entry&quot;.</p>
<pre><code>    #[clap(flatten, help_heading = Some(&quot;OPTIONS-1&quot;))]
    pub info: InfoArgs,
</code></pre>
<p>https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=43b93b114af6ff20434544ef26deb702</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-20 13:49</div>
            <div class="timeline-body"><p>We do not yet support <code>help_heading</code> with <code>flatten</code>.  It is one of the last things left in #1807.</p>
<p>iirc you can set it on the <code>struct</code>.  If that doesn't work, then on each field.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ljw1004">@ljw1004</a> on 2023-02-20 17:32</div>
            <div class="timeline-body"><blockquote>
<p>iirc you can set it on the struct. If that doesn't work, then on each field.</p>
</blockquote>
<p>Setting on the struct gives a build-time error &quot;no method named <code>help_heading</code> found for struct <code>clap::Command</code> in the current scope&quot;</p>
<p>Setting on each field doesn't give the desired effect because, even though it achieves the desired affect that &quot;mybinary --help&quot; shows the options for the info subcommand in a separate heading, &quot;mybinary info --help&quot; also shows them in a separate heading. https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=fb338e3037a1a00e96e4c3d3ed82b530</p>
<p>I guess I'll wait for #1807. Thank you @epage for your continued assistance - much appreciated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../jj-vcs/jj/pulls/1525.html">jj-vcs/jj#1525</a> on 2023-04-15 14:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../tweag/topiary/pulls/583.html">tweag/topiary#583</a> on 2023-07-19 09:54</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/opeolluwa">@opeolluwa</a> on 2023-09-22 14:52</div>
            <div class="timeline-body"><p>I visited this issue earlier but I could seem to get a fix here's what I did. I hope it helps someone in the future</p>
<p>Here's the root of my application</p>
<pre><code class="language-rust">// mount clap parser here 
#[derive(Parser)]
#[command(author, version, about =&quot;Compilation of utility scripts for everyday use&quot;, long_about = None)]
#[command(propagate_version = true)]
pub struct Utils {
    #[command(subcommand)]
    pub command: Commands,
}

impl Utils {
    pub async fn run() {
        let utils = Utils::parse();
        match utils.command {
            Commands::Ignore(git_ignore) =&gt; git_ignore.parse(),
            Commands::Mailto(email) =&gt; email.parse().await,
            Commands::Readme(readme) =&gt; readme.parse(),
            Commands::Store(store) =&gt; store.parse().await,
            // _ =&gt; PrintColoredText::error(&quot;invalid command&quot;),
        }
    }
}

#[derive(Subcommand)]
pub enum Commands {
    /// store data as key value pair
    Store(StoreCommands),
    /// generate .gitignore
    Ignore(GitIgnoreCommands),
    /// send email from the command line
    Mailto(EmailCommands),
    /// add readme to a git software project
    Readme(ReadmeCommands),
}
</code></pre>
<p>My help script look like this</p>
<pre><code class="language-sh">Compilation of utility scripts for everyday use

Usage: utils &lt;COMMAND&gt;

Commands:
  store   store data as key value pair
  ignore  generate .gitignore
  mailto  send email from the command line
  readme  add a readme to a git software project
  help    Print this message or the help of the given subcommand(s)

Options:
  -h, --help     Print help
  -V, --version  Print version

</code></pre>
<p>I wanted to implement a default subcommand for the store subcommand such that I can say</p>
<ul>
<li>`utils store key value&quot; to store a key-value pair, this would be the default subcommand</li>
<li><code>utils store list</code> to list the stored key-value pair</li>
</ul>
<p>To solve this,</p>
<ol>
<li>I implemented the  fields as optional properties (argument and sub commands) thus</li>
</ol>
<pre><code class="language-rust">#[derive(Args, Debug, Serialize, Deserialize)]
pub struct StoreCommands {
    #[clap(short, long, value_parser)]
    pub key: Option&lt;String&gt;,
    #[clap(short, long, value_parser)]
    pub value: Option&lt;String&gt;,
    #[command(subcommand)]
    pub subcommands: Option&lt;SubCommands&gt;,
}
</code></pre>
<ol start="2">
<li>I relied heavily on correct pattern-matching</li>
</ol>
<pre><code class="language-rust">    pub async fn parse(&amp;self) {
        if let Some(command) = &amp;self.subcommands {
            match command {
                SubCommands::List =&gt; Self::list().await,
                SubCommands::Delete { key } =&gt; Self::delete(key).await,
                SubCommands::Clear =&gt; Self::clear().await,
                SubCommands::Update { key, value } =&gt; Self::update(key, value).await,
            }
        } else {
            let Some(key) = &amp;self.key else {
                PrintColoredText::error(&quot;Invalid key&quot;);
                return;
            };
            let Some(value) = &amp;self.value else {
                PrintColoredText::error(&quot;Invalid value&quot;);
                return;
            };
            Store::new(key, value).save().await.unwrap();
            let message = format!(&quot;{key} successfully stored&quot;);
            PrintColoredText::success(&amp;message);
        }
    }
</code></pre>
<p>The entirety of the source is as follows</p>
<pre><code class="language-rust">use clap::{Args, Subcommand};
use serde::{Deserialize, Serialize};

use crate::{database::Store, style::PrintColoredText};

#[derive(Args, Debug, Serialize, Deserialize)]
pub struct StoreCommands {
    #[clap(short, long, value_parser)]
    pub key: Option&lt;String&gt;,
    #[clap(short, long, value_parser)]
    pub value: Option&lt;String&gt;,
    #[command(subcommand)]
    pub subcommands: Option&lt;SubCommands&gt;,
}

#[derive(Debug, Subcommand, Serialize, Deserialize)]
pub enum SubCommands {
    /// list the stored data
    List,
    /// delete a key
    Delete { key: String },
    /// clear all stored data
    Clear,
    /// update the value of a key
    Update { key: String, value: String },
}

impl StoreCommands {
    pub async fn parse(&amp;self) {
        if let Some(command) = &amp;self.subcommands {
            match command {
                SubCommands::List =&gt; Self::list().await,
                SubCommands::Delete { key } =&gt; Self::delete(key).await,
                SubCommands::Clear =&gt; Self::clear().await,
                SubCommands::Update { key, value } =&gt; Self::update(key, value).await,
            }
        } else {
            let Some(key) = &amp;self.key else {
                PrintColoredText::error(&quot;Invalid key&quot;);
                return;
            };
            let Some(value) = &amp;self.value else {
                PrintColoredText::error(&quot;Invalid value&quot;);
                return;
            };
            Store::new(key, value).save().await.unwrap();
            let message = format!(&quot;{key} successfully stored&quot;);
            PrintColoredText::success(&amp;message);
        }
    }
    async fn list() {
        let data = crate::database::Store::find().await;
        if data.is_empty() {
            PrintColoredText::error(&quot;no data found&quot;);
            return;
        }
        let data = crate::database::Database(data);
        println!(&quot;{}&quot;, data);
    }

    async fn delete(key: &amp;str) {
        crate::database::Store::remove(key).await;
    }

    async fn update(key: &amp;str, value: &amp;str) {
        let _ = crate::database::Store::update(key, value).await.ok();

        let message = format!(&quot;{key} successfully updated&quot;);
        PrintColoredText::success(&amp;message);
    }

    async fn clear() {
        crate::database::Store::clear().await;
    }
}
</code></pre>
<p>I hope this helps someone. the project source code is available at https://github.com/opeolluwa/utils</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/MatheusRich">@MatheusRich</a> on 2024-01-12 11:59</div>
            <div class="timeline-body"><p>While it's possible to mark the subcommand as optional and use pattern matching to use <code>None</code> as the default command, I didn't like that it pushes that responsibility outside of the Cli.</p>
<p>A solution I've found was to keep the <code>command</code> field private, and use a public method on <code>Cli</code> to return it (or a default value). That way the implementation can all live inside the cli:</p>
<pre><code class="language-rs">#[derive(Subcommand, Clone, Debug)]
pub enum Command {
    Compile,
    Format
}

#[derive(Parser)]
#[command(author, version, about, long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    command: Option&lt;Command&gt;,
}

impl Cli {
    pub fn command(&amp;self) -&gt; Command {
        self.command.clone().unwrap_or(Command::Compile)
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rustls/rustls/pulls/2024.html">rustls/rustls#2024</a> on 2024-07-01 11:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/squeaktoy">@squeaktoy</a> on 2024-12-16 17:30</div>
            <div class="timeline-body"><p>@MatheusRich That doesn't seem to work if you use Args in your command enum.</p>
<pre><code class="language-rust">use clap::{Args, Parser, Subcommand};

#[derive(Subcommand, Clone, Debug)]
pub enum Command {
    /// Download a URL (default)
    Download(DownloadArgs),
    /// List supported websites
    Sites,
}

#[derive(Parser)]
#[command(version, about, long_about = None)]
pub struct Cli {
    #[command(subcommand)]
    command: Option&lt;Command&gt;,

    /// Turn debugging information on
    #[arg(short, long, action = clap::ArgAction::Count)]
    pub debug: u8,
}

#[derive(Args, Clone, Debug)]
pub struct DownloadArgs {
    /// URL to download
    pub url: String,
}

impl Cli {
    pub fn command(&amp;self) -&gt; Command {
        self.command.clone().unwrap_or(Command::Download(DownloadArgs))
    }
}
</code></pre>
<p>This fails to compile:</p>
<pre><code>error[E0423]: expected value, found struct `DownloadArgs`
  --&gt; src/config.rs:30:58
   |
23 | / pub struct DownloadArgs {
24 | |     /// URL to download
25 | |     pub url: String,
26 | | }
   | |_- `DownloadArgs` defined here
...
30 |           self.command.clone().unwrap_or(Command::Download(DownloadArgs))
   |                                                            ^^^^^^^^^^^^ help: use struct literal syntax instead: `DownloadArgs { url: val }`
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/PlexSheep">@PlexSheep</a> on 2025-01-29 16:59</div>
            <div class="timeline-body"><p>I found a workaround if you also want to use subcommands with their own arguments:</p>
<pre><code class="language-rs">use clap::{Parser, Subcommand};
use std::env::args;
use std::path::PathBuf;

#[derive(Parser)]
struct Cli {
    #[command(subcommand)]
    command: Option&lt;Commands&gt;,
}

#[derive(Subcommand)]
enum Commands {
    #[clap(visible_alias = &quot;&quot;)]
    Backup {
        paths: Vec&lt;PathBuf&gt;,
        #[arg(short = 'z', long)]
        compress: bool,
    },
// more commands
}

fn help_and_exit() -&gt; ! {
    use clap::CommandFactory;
    let mut cmd = Cli::command();
    cmd.print_help().expect(&quot;could not print&quot;);
    std::process::exit(1)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let cli;
    let command = {
        let mut a: Vec&lt;String&gt; = std::env::args().collect();
        if a.len() &lt; 2 {
            help_and_exit()
        }
        if !a[1].starts_with(&quot;-&quot;)
            || a[1] == &quot;restore&quot;
            || a[1] == &quot;other_cmd&quot;
        {
            let slice = &amp;[&quot;&quot;.to_string()];
            a.splice(1..1, slice.iter().cloned());
        }
        cli = Cli::parse_from(a.iter());
        cli.command.unwrap()
    };
    dbg!(&amp;command);


    match command { ... }
}
</code></pre>
<p>We need to manually insert an empty string into the arguments, since the standard library rightfully does not include empty strings in the arguments.</p>
<p>Though I'm finding more and more caveats to this.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:07 UTC
    </footer>
</body>
</html>
