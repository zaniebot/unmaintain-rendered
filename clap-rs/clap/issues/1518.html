<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>idea: generate the yaml representation from mocked CLI usage - clap-rs/clap #1518</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>idea: generate the yaml representation from mocked CLI usage</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/1518">#1518</a>
        opened by <a href="https://github.com/nilslice">@nilslice</a>
        on 2019-07-07 20:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/nilslice">@nilslice</a></div>
            <div class="timeline-body"><p>Hi - great work on <code>clap</code>! I am starting a CLI-related project and upon seeing <code>clap</code>&#x27;s support for a YAML-based representation, I thought maybe my project could be a PR to <code>clap</code> instead.. apologies for using a GitHub issue for this, but I figured others who use <code>clap</code> might also be interested.</p>
<p>I&#x27;m working on a CLI &quot;generator&quot;.. call it <code>cli-gen</code>, which allows a developer to <em>generate</em> their CLI code by pretending to invoke the CLI app and it&#x27;s flags/arguments before anything exists. For example, say I have an image resizing library, and I&#x27;d like to wrap it in a CLI.. I&#x27;d want to use this new CLI (call it <code>img-size</code>) like so:</p>
<pre><code>$ img-size -i original.jpg -o resized.jpg --keep-proportion --max-width=420
</code></pre>
<p>If parsed well, the following can be inferred:</p>
<ul>
<li>command name: <code>img-size</code></li>
<li>arg: <code>i</code> <em>string</em></li>
<li>arg: <code>o</code> <em>string</em></li>
<li>arg: <code>keep-proportion</code> <em>boolean</em></li>
<li>arg: <code>max-width</code> <em>int</em></li>
</ul>
<p>The same parser could tell if there were subcommands, if no <code>-</code>/<code>--</code> token is found before an argument, after which it would recursively parse its args. Poorly illustrated, but for example:</p>
<pre><code>$ img-size convert -i original.jpg -o resized.png --conversion=jpg-to-png
</code></pre>
<p>The parser would capture the <em>intent</em> of the CLI to be generated, and store some pseudo &quot;intermediate representation&quot; of the CLI in YAML (this is how I found your project)... we&#x27;d generate the YAML, use <code>clap</code>&#x27;s ability to turn that into Rust code, but also provide utils to go from YAML to Go, PHP, Bash, Python, etc.</p>
<p>The ultimate usage would be something like:</p>
<ol>
<li>generate your CLI representation:</li>
</ol>
<pre><code>$ cli-gen new img-size -i original.jpg -o resized.jpg --keep-proportion --max-width=420
&gt; created &quot;img-size.yml&quot;
</code></pre>
<ul>
<li>this outputs the same structured <a href="https://github.com/clap-rs/clap/blob/master/examples/17_yaml.yml">YAML</a> you have already defined, but with empty fields where the developer can fill more detail in (like long name if only short was used)</li>
</ul>
<ol>
<li>modify/add sub-commands, etc.</li>
</ol>
<pre><code>$ cli-gen add img-size convert -i original.jpg -o resized.png --conversion=jpg-to-png
&gt; added &quot;convert&quot; sub-command to &quot;img-size.yml&quot;
</code></pre>
<ul>
<li>this would decode the YAML file (expected to exist), add a new sub-command <code>convert</code> along with the parsed arguments and example values, and encode it back to YAML on disk.</li>
</ul>
<ol>
<li>generate language specific code to bind CLI usage to a developers codebase/lib</li>
</ol>
<pre><code>$ cli-gen generate -o python ./img-size.yml
</code></pre>
<ul>
<li>this assumes there is a executble called <code>cli-gen-python</code>  in the system $PATH which is invoked, and passed the <code>./img-size.yml</code> bytes to its <code>stdin</code>. <code>cli-gen-python</code> would read the YAML, decode it to then generate the file(s) needed for the python code to use as CLI bindings.</li>
</ul>
<p>If you don&#x27;t think this belongs <em>within</em> <code>clap</code>, that&#x27;s all I need to know :) I figured I&#x27;d reach out in case this was something you&#x27;d like to support. Otherwise, I&#x27;ll probably still use <code>clap</code> as the primary arg parser, and try to leverage your data structures for the YAML representation too. ~~Also, I noticed #1515 (whose name caught my eye as possibly similar) but couldn&#x27;t find much about it...~~ I now see it&#x27;s a separate project -- my bad!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: other</span> added by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-02-01 13:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: maybe</span> added by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-02-01 13:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-02-06 19:26</div>
            <div class="timeline-body"><p>While I think it is intriguing, I am not sure it falls into Clap&#x27;s scope. You can generate a Clap template though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nilslice">@nilslice</a> on 2020-02-06 19:37</div>
            <div class="timeline-body"><p>Yea I agree - thanks for the input! Will close.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/nilslice">@nilslice</a> on 2020-02-06 19:37</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:57:26 UTC
    </footer>
</body>
</html>
