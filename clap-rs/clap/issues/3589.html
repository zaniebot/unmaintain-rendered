<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>try_from_str and try_from_os_str functions are called twice - clap-rs/clap #3589</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>try_from_str and try_from_os_str functions are called twice</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/clap-rs/clap/issues/3589">#3589</a>
        opened by <a href="https://github.com/aj-bagwell">@aj-bagwell</a>
        on 2022-03-29 12:42
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/aj-bagwell">@aj-bagwell</a> on 2022-03-29 12:42</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Rust Version</h3>
<p>rustc 1.58.1 (db9d1b20b 2022-01-20)</p>
<h3>Clap Version</h3>
<p>3.1.6</p>
<h3>Minimal reproducible code</h3>
<pre><code class="language-rust">use clap::Parser;
use std::sync::atomic::{AtomicU8, Ordering};

static COUNT: AtomicU8 = AtomicU8::new(0);

#[derive(Parser)]
#[clap(name = &quot;from_str&quot;)]
struct Opt {
    #[clap(parse(try_from_str = spy))]
    s: String,
}

fn main() {
    let opt = Opt::parse_from(&amp;[&quot;foo&quot;, &quot;h&quot;]);
    assert_eq!(COUNT.load(Ordering::SeqCst), 1);
}

fn spy(s: &amp;str) -&gt; Result&lt;String, String&gt; {
    let c = COUNT.fetch_add(1, Ordering::SeqCst);
    println!(&quot;spy called {}&quot;, c);
    Ok(s.to_string())
}
</code></pre>
<h3>Steps to reproduce the bug with the above code</h3>
<p><code>cargo run</code></p>
<h3>Actual Behaviour</h3>
<p>When specifying a parser for an attribute using <code>try_from_str</code> and the <code>#[derive(Parser)]</code> macro the function passed used for parising is called twice, once as part of the validate phase and then again to convert the argument to the expected type.</p>
<p>This causes issues when the function is not idemponent, such as opening a file, or performing a network request.</p>
<h3>Expected Behaviour</h3>
<p>The <code>try_from_str</code> should only be called once.</p>
<h3>Additional Context</h3>
<p><em>No response</em></p>
<h3>Debug Output</h3>
<pre><code>[        clap::build::command] 	App::_do_parse
[        clap::build::command] 	App::_build
[        clap::build::command] 	App::_propagate:from_str
[        clap::build::command] 	App::_check_help_and_version: from_str
[        clap::build::command] 	App::_check_help_and_version: Removing generated version
[        clap::build::command] 	App::_propagate_global_args:from_str
[        clap::build::command] 	App::_derive_display_order:from_str
[  clap::build::debug_asserts] 	Command::_debug_asserts
[  clap::build::debug_asserts] 	Arg::_debug_asserts:help
[  clap::build::debug_asserts] 	Arg::_debug_asserts:s
[  clap::build::debug_asserts] 	Command::_verify_positionals
[         clap::parse::parser] 	Parser::get_matches_with
[         clap::parse::parser] 	Parser::get_matches_with: Begin parsing 'RawOsStr(&quot;h&quot;)' ([104])
[         clap::parse::parser] 	Parser::get_matches_with: Positional counter...1
[         clap::parse::parser] 	Parser::get_matches_with: Low index multiples...false
[         clap::parse::parser] 	Parser::possible_subcommand: arg=RawOsStr(&quot;h&quot;)
[         clap::parse::parser] 	Parser::get_matches_with: sc=None
[         clap::parse::parser] 	Parser::remove_overrides: id=s
[    clap::parse::arg_matcher] 	ArgMatcher::inc_occurrence_of_arg: id=s
[        clap::build::command] 	App::groups_for_arg: id=s
[         clap::parse::parser] 	Parser::add_val_to_arg; arg=s, val=RawOsStr(&quot;h&quot;)
[         clap::parse::parser] 	Parser::add_val_to_arg; trailing_values=false, DontDelimTrailingVals=false
[         clap::parse::parser] 	Parser::add_single_val_to_arg: adding val...&quot;h&quot;
[         clap::parse::parser] 	Parser::add_single_val_to_arg: cur_idx:=1
[        clap::build::command] 	App::groups_for_arg: id=s
[    clap::parse::arg_matcher] 	ArgMatcher::needs_more_vals: o=s
[      clap::parse::validator] 	Validator::validate
[         clap::parse::parser] 	Parser::add_defaults
[         clap::parse::parser] 	Parser::add_defaults:iter:s:
[         clap::parse::parser] 	Parser::add_value: doesn't have conditional defaults
[         clap::parse::parser] 	Parser::add_value:iter:s: doesn't have default vals
[         clap::parse::parser] 	Parser::add_value:iter:s: doesn't have default missing vals
[      clap::parse::validator] 	Validator::validate_conflicts
[      clap::parse::validator] 	Validator::validate_exclusive
[      clap::parse::validator] 	Validator::validate_exclusive:iter:s
[      clap::parse::validator] 	Validator::validate_conflicts::iter: id=s
[      clap::parse::validator] 	Conflicts::gather_conflicts
[      clap::parse::validator] 	Validator::validate_required: required=ChildGraph([Child { id: s, children: [] }])
[      clap::parse::validator] 	Validator::gather_requires
[      clap::parse::validator] 	Validator::gather_requires:iter:s
[      clap::parse::validator] 	Validator::validate_required_unless
[      clap::parse::validator] 	Validator::validate_matched_args
[      clap::parse::validator] 	Validator::validate_matched_args:iter:s: vals=Flatten {
    inner: FlattenCompat {
        iter: Fuse {
            iter: Some(
                Iter(
                    [
                        [
                            &quot;h&quot;,
                        ],
                    ],
                ),
            ),
        },
        frontiter: None,
        backiter: None,
    },
}
[      clap::parse::validator] 	Validator::validate_arg_num_vals
[      clap::parse::validator] 	Validator::validate_arg_values: arg=&quot;s&quot;
[      clap::parse::validator] 	Validator::validate_arg_values: checking validator...
spy called 0
[      clap::parse::validator] 	good
[      clap::parse::validator] 	Validator::validate_arg_num_occurs: &quot;s&quot;=1
[    clap::parse::arg_matcher] 	ArgMatcher::get_global_values: global_arg_vec=[help]
spy called 1
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `2`,
 right: `1`', src/main.rs:15:5
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by @aj-bagwell on 2022-03-29 12:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aj-bagwell">@aj-bagwell</a> on 2022-03-29 12:46</div>
            <div class="timeline-body"><p>I think that fixing this should be as simple as just never adding the validators, if there is an error in the get phase it is beautifully printed in exactly the same way as the validator would.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-derive</span> added by @epage on 2022-03-29 14:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-mentor</span> added by @epage on 2022-03-29 14:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2683.html">clap-rs/clap#2683</a> on 2022-03-29 14:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-03-29 14:30</div>
            <div class="timeline-body"><p>Huh, we had a previous PR for this but no issue.  https://github.com/clap-rs/clap/issues/2683 is the tracking issue for resolving this</p>
<blockquote>
<p>I think that fixing this should be as simple as just never adding the validators, if there is an error in the get phase it is beautifully printed in exactly the same way as the validator would.</p>
</blockquote>
<p>There are subtle differences, like color support.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aj-bagwell">@aj-bagwell</a> on 2022-03-29 15:55</div>
            <div class="timeline-body"><p>Bah, you are of course right it is not as simple as I thought,
with validator (pretty colours for the <code>&lt;S&gt;</code> and <code>&quot;/tmp/not-found&quot;</code>):</p>
<pre><code>error: Invalid value &quot;/tmp/not-found&quot; for '&lt;S&gt;': No such file or directory (os error 2)

For more information try --help
</code></pre>
<p>without validator (only <code>error:</code> gets color):</p>
<pre><code>error: Invalid value for s: No such file or directory (os error 2)

USAGE:
    foo [OPTIONS] &lt;S&gt;
</code></pre>
<p>Since the nice error message relies on the <code>context</code> which can't be set via the public API, I don't think it is worth adding the colours, but adding the value is easy.</p>
<p>Would you be interested in a PR dropping the validate calls or should I just wait for 4.0?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-03-29 18:45</div>
            <div class="timeline-body"><blockquote>
<p>I don't think it is worth adding the colours,</p>
</blockquote>
<p>I would consider that a blocker for a solution</p>
<blockquote>
<p>Would you be interested in a PR dropping the validate calls</p>
</blockquote>
<p>Even if the final message ends up looking exactly the same, this would be borderline for breaking compatibility due to changes in expectations of behavior.  Let's just wait for that 4.0 work to go through.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/aj-bagwell">@aj-bagwell</a> on 2022-03-29 19:19</div>
            <div class="timeline-body"><p>4.0 it is then! Thank you for all your hard work and speedy responses.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/3732.html">clap-rs/clap#3732</a> on 2022-05-17 21:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3734.html">clap-rs/clap#3734</a> on 2022-05-18 00:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/3742.html">clap-rs/clap#3742</a> on 2022-05-23 12:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2022-05-23 15:33</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wiktor-k">@wiktor-k</a> on 2022-05-26 07:59</div>
            <div class="timeline-body"><p>I've taken a look at the new way of parsing with <code>#[clap(value_parser)]</code> and it looks very nice! :clap:</p>
<p>One question though: now the structs to be parsed need to <code>impl Clone</code> even though they are not cloned by the value parser. Is this intentional?</p>
<p>I wanted to parse the object and create it only once and intentionally make it non-clone'able since it owns some resources that should not be shared (ie. file descriptors). So it would be really nice if the must-impl-Clone restriction was lifted...</p>
<p>An example:</p>
<pre><code class="language-rust">use std::convert::TryFrom;

#[derive(Debug)]
struct Xing;

impl Clone for Xing { // this is needed by value_parser
    fn clone(&amp;self) -&gt; Self {
        todo!() // this is not called
    }
}


impl std::str::FromStr for Xing { // FromStr needs to be implemented
    type Err = std::io::Error;

    fn from_str(_s: &amp;str) -&gt; Result&lt;Self, Self::Err&gt; {
        eprintln!(&quot;Calling...&quot;); // this is printed only once -&gt; nice!
        Ok(Xing)
    }
}

use clap::Parser;

#[derive(Parser, Debug)]
struct Args {
    #[clap(short, long, value_parser)] // this is new
    x: Xing,
}

fn main() {
    let args = Args::parse();
    println!(&quot;Hello, world: {:?}&quot;, args);
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-05-26 12:04</div>
            <div class="timeline-body"><blockquote>
<p>One question though: now the structs to be parsed need to impl Clone even though they are not cloned by the value parser. Is this intentional?</p>
</blockquote>
<p>The derive API is built on top of the builder API.  The parser generates data into an <code>ArgMatches</code> which implements <code>Clone</code>, so the data needs to be <code>Clone</code>.  Technically, we cheat right now and wrap the data in an <code>Arc</code> because I couldn't quite get it working right but (1) I want the implementation flexibility to remove the <code>Arc</code> later and (2) if the <code>Arc</code>s ref count is greater than 1, we can't move out of it and have to clone instead.</p>
<p>Feel free to create an issue for this if you want.</p>
<p>An idea I'm playing with for the future is to have <code>ArgMatches</code> implement a trait and allow alternative implementations to be used.  The main intent would be for people to organize the values in a different way than clap currently does (e.g. easier handling of order-dependent flags) but it could potentially allow a more optimized implementation for the derive API that has fewer restrictions (just <code>Any + 'static</code>, removing <code>Clone</code>, <code>Send</code>, and <code>Sync</code>).  This is still a very immature idea and I don't know how much is feasible and there are a lot of other priorities (right now, implementing Actions to fully deprecate <code>parse</code>).</p>
<p>At one point, <code>ArgMatches</code> exposed the <code>Arc</code> and we did the move-out-of-arc-or-clone there.  I had considered adding Deref specialization to it so we could clone where possible and panic otherwise.  I removed the <code>Arc</code> from <code>ArgMatches</code> to make the API cleaner and to give implementation flexibility (#3747).</p>
<p>However, I suspect most exclusive resources are not safe to acquire at process start regardless of what happens for the rest of the program and that not needing <code>Clone</code> is a corner case.  For example, a file-write handle would cause files to be created even if everything else fails.  On Windows, even file reads can be a problem because of their semantics.  This is why I have not been too worried about the lack of <code>Clone</code>.  Users can always acquire the resource later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wiktor-k">@wiktor-k</a> on 2022-05-27 10:22</div>
            <div class="timeline-body"><p>Thanks for the detailed explanation and your work on clap in general!</p>
<p>What I'm trying to achieve here is constructing my own objects from command line parameters only once.</p>
<p>Previously this was not the case (the objects were constructed twice: once during validation). With <code>value_parser</code> the situation is improved as the object is created only once but the added constraint of being <code>Clone</code>able, even if currently not used, still doesn't promise that the objects will be created only once (since creating object through <code>from_str</code> is not much different from cloning another one from the first one).</p>
<p>So, while technically the issue here is solved (<code>from_str</code> is not called twice now) the underlying intent I had (objects created only once) is not.</p>
<blockquote>
<p>Feel free to create an issue for this if you want.</p>
</blockquote>
<p>I'm not sure if that's only me and I don't want to put more work on your plate if this is a rare edge-case but I still wanted to explain my rationale.</p>
<p>Thank you for your time!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3792.html">clap-rs/clap#3792</a> on 2022-06-06 14:23</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-06-09 02:23</div>
            <div class="timeline-body"><p>@wiktor-k what are your thoughts on adding a <code>T: PartialEq</code> bound to our adapter from <code>FromStr</code>?  Users could still manually implement <code>TypedValueParser</code> to workaround it.</p>
<p>Right now we have a <code>default_value_if_eq</code> that compares raw values and supporting comparators in <code>TypedValueParser</code> could possibly be a way for us to support a version of <code>default_value_if_eq</code> that uses native types for the comparison.  See https://github.com/clap-rs/clap/issues/3792#issuecomment-1147834606</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../aj-bagwell/clio/issues/4.html">aj-bagwell/clio#4</a> on 2022-06-22 09:07</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:08 UTC
    </footer>
</body>
</html>
