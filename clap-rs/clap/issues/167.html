<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>add benchmarks - clap-rs/clap #167</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>add benchmarks</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/clap-rs/clap/issues/167">#167</a>
        opened by <a href="https://github.com/kbknapp">@kbknapp</a>
        on 2015-07-27 12:25
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-07-27 12:25</div>
            <div class="timeline-body"><p><em>No description provided.</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: enhancement</span> added by @kbknapp on 2015-07-27 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: easy</span> added by @kbknapp on 2015-07-27 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">P3: want to have</span> added by @kbknapp on 2015-07-27 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: parsing</span> added by @kbknapp on 2015-07-27 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">E: tedious</span> added by @kbknapp on 2015-07-27 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/severen">@severen</a> on 2015-07-28 07:17</div>
            <div class="timeline-body"><p>I could try and do this next week, doesn't this require the Rust nightly though?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-07-28 10:31</div>
            <div class="timeline-body"><p>That would be awesome! Yep it does, but you can use a cargo &quot;feature&quot; to only compile the benchmarks when on nightly. Just use the <code>unstable</code> feature.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/168.html">clap-rs/clap#168</a> on 2015-07-29 21:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-07-30 22:59</div>
            <div class="timeline-body"><p>As per the gitter chat, here's the things I'd like to see some benchmarks on:</p>
<p>Using the <code>clap-tests</code> binary as a base since it contains a decent number of options and rules:</p>
<pre><code class="language-rust">    let m_val_names = [&quot;one&quot;, &quot;two&quot;];
    let args = &quot;-o --option=[opt]... 'tests options'
                [positional] 'tests positionals'&quot;;
    let opt3_vals = [&quot;fast&quot;, &quot;slow&quot;];
    let pos3_vals = [&quot;vi&quot;, &quot;emacs&quot;];
    let matches = App::new(&quot;claptests&quot;)
                        // Test version from Cargo.toml
                        .version(&amp;crate_version!()[..])
                        .about(&quot;tests clap library&quot;)
                        .author(&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;)
                        .args_from_usage(args)
                        .arg(Arg::from_usage(&quot;-f --flag... 'tests flags'&quot;)
                            .global(true))
                        .args(vec![
                            Arg::from_usage(&quot;[flag2] -F 'tests flags with exclusions'&quot;).conflicts_with(&quot;flag&quot;).requires(&quot;option2&quot;),
                            Arg::from_usage(&quot;--long-option-2 [option2] 'tests long options with exclusions'&quot;).conflicts_with(&quot;option&quot;).requires(&quot;positional2&quot;),
                            Arg::from_usage(&quot;[positional2] 'tests positionals with exclusions'&quot;),
                            Arg::from_usage(&quot;-O --Option [option3] 'tests options with specific value sets'&quot;).possible_values(&amp;opt3_vals),
                            Arg::from_usage(&quot;[positional3]... 'tests positionals with specific values'&quot;).possible_values(&amp;pos3_vals),
                            Arg::from_usage(&quot;--multvals [multvals] 'Tests mutliple values, not mult occs'&quot;).value_names(&amp;m_val_names),
                            Arg::from_usage(&quot;--multvalsmo [multvalsmo]... 'Tests mutliple values, not mult occs'&quot;).value_names(&amp;m_val_names),
                            Arg::from_usage(&quot;--minvals2 [minvals]... 'Tests 2 min vals'&quot;).min_values(2),
                            Arg::from_usage(&quot;--maxvals3 [maxvals]... 'Tests 3 max vals'&quot;).max_values(3)
                        ])
                        .subcommand(SubCommand::with_name(&quot;subcmd&quot;)
                                                .about(&quot;tests subcommands&quot;)
                                                .version(&quot;0.1&quot;)
                                                .author(&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;)
                                                .arg_from_usage(&quot;-o --option [scoption]... 'tests options'&quot;)
                                                .arg_from_usage(&quot;[scpositional] 'tests positionals'&quot;));
</code></pre>
<ul>
<li>Time to build the app</li>
<li>Time to parse a clean (no arguments) run</li>
<li>Time to parse a single valid flag</li>
<li>Time to parse a single valid option</li>
<li>Time to parse a single valid positional</li>
<li>Time to parse a single valid subcommand</li>
<li>Repeat all with subcommand (i.e. single valid subcommand with single flag, etc.)</li>
<li>Time to parse a complex run (i.e. multiple flags/options/positionals, all valid) such as <code>claptests -ff -o some arg1 -O fast arg2 --multvals one two three</code></li>
</ul>
<p>Anything else you can think of is welcome ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/186.html">clap-rs/clap#186</a> on 2015-08-27 08:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sru">@sru</a> on 2015-08-30 03:01</div>
            <div class="timeline-body"><pre><code class="language-rust">extern crate test;

use super::{App, Arg, SubCommand};

use self::test::Bencher;

#[bench]
fn build_app(b: &amp;mut Bencher) {
    let m_val_names = [&quot;one&quot;, &quot;two&quot;];
    let args = &quot;-o --option=[opt]... 'tests options'
                            [positional] 'tests positionals'&quot;;
    let opt3_vals = [&quot;fast&quot;, &quot;slow&quot;];
    let pos3_vals = [&quot;vi&quot;, &quot;emacs&quot;];

    b.iter(|| App::new(&quot;claptests&quot;)
                // Test version from Cargo.toml
                .version(&quot;0.1&quot;)
                .about(&quot;tests clap library&quot;)
                .author(&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;)
                .args_from_usage(args)
                .arg(Arg::from_usage(&quot;-f --flag... 'tests flags'&quot;)
                             .global(true))
                .args(vec![
                          Arg::from_usage(&quot;[flag2] -F 'tests flags with exclusions'&quot;).conflicts_with(&quot;flag&quot;).requires(&quot;option2&quot;),
                          Arg::from_usage(&quot;--long-option-2 [option2] 'tests long options with exclusions'&quot;).conflicts_with(&quot;option&quot;).requires(&quot;positional2&quot;),
                          Arg::from_usage(&quot;[positional2] 'tests positionals with exclusions'&quot;),
                          Arg::from_usage(&quot;-O --Option [option3] 'tests options with specific value sets'&quot;).possible_values(&amp;opt3_vals),
                          Arg::from_usage(&quot;[positional3]... 'tests positionals with specific values'&quot;).possible_values(&amp;pos3_vals),
                          Arg::from_usage(&quot;--multvals [multvals] 'Tests mutliple values, not mult occs'&quot;).value_names(&amp;m_val_names),
                          Arg::from_usage(&quot;--multvalsmo [multvalsmo]... 'Tests mutliple values, not mult occs'&quot;).value_names(&amp;m_val_names),
                          Arg::from_usage(&quot;--minvals2 [minvals]... 'Tests 2 min vals'&quot;).min_values(2),
                          Arg::from_usage(&quot;--maxvals3 [maxvals]... 'Tests 3 max vals'&quot;).max_values(3)
                    ])
                .subcommand(SubCommand::with_name(&quot;subcmd&quot;)
                                        .about(&quot;tests subcommands&quot;)
                                        .version(&quot;0.1&quot;)
                                        .author(&quot;Kevin K. &lt;kbknapp@gmail.com&gt;&quot;)
                                        .arg_from_usage(&quot;-o --option [scoption]... 'tests options'&quot;)
                                        .arg_from_usage(&quot;[scpositional] 'tests positionals'&quot;)));
}
</code></pre>
<p>I got the &quot;Time to build the app&quot; part working although I am not confident that it is measuring what it is suppose to measure.</p>
<ul>
<li><code>crate_version!</code> macro does not work because of lifetime issues that I don't understand.</li>
<li>Writing <code>App::new(...)</code> for every single benchmark would be hard to maintain &amp; tedious. I tried writing function or macro to return the test <code>App</code> struct without much success.</li>
<li>I assume we measure the build time because getting parsing time alone is impossible (<code>.get_matches_from</code> consumes the <code>self</code>).</li>
<li>I get about 22 +- 1 milliseconds running above benchmark.</li>
</ul>
<p>I made separate <code>benchmarks.rs</code> in <code>src</code> folder and added it into the <code>lib.rs</code> file. However, it can also be inside the <code>tests.rs</code> file.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-08-30 03:25</div>
            <div class="timeline-body"><blockquote>
<p>I got the &quot;Time to build the app&quot; part working although I am not confident that it is measuring what it is suppose to measure</p>
</blockquote>
<p>My goal is measure how long it takes <code>clap</code> to parse out all the valid options and be ready to actually start the parsing. Because until things like syntax extensions become usable on stable Rust, all that parsing has to happen at runtime. So I want to make sure we're taking as little time as possible to actually &quot;parse and store all possible valid options&quot; before actually parsing the string the user gives at the command line.</p>
<blockquote>
<p><code>crate_verison!</code> macro does not work because of lifetime issues that I don't understand.</p>
</blockquote>
<p>I'm not worried about testing that. Using <code>crate_version</code> is the same performance wise as passing in a <code>&amp;'static str</code> to <code>version()</code> because the computation happens at compile time; so there's any additional overhead.</p>
<blockquote>
<p>Writing App::new(...) for every single benchmark would be hard to maintain &amp; tedious. I tried writing function or macro to return the test App struct without much success.</p>
</blockquote>
<p>This should be possible. You can start a PR and place all these benchmarks in a <code>benchmarks</code> directory (similar to <code>tests</code>) so I can take a look.</p>
<blockquote>
<p>I assume we measure the build time because getting parsing time alone is impossible (.get_matches_from consumes the self)</p>
</blockquote>
<p>Correct. This way when we <em>do</em> measure parsing time, we can subtract the build time (because it'll have to be re-built on each iteration).</p>
<blockquote>
<p>I get about 22 +- 1 milliseconds running above benchmark.</p>
</blockquote>
<p>Hopefully you mean nanoseconds...miliseconds would be quite long :stuck_out_tongue_winking_eye:</p>
<blockquote>
<p>I made separate benchmarks.rs in src folder and added it into the lib.rs file. However, it can also be inside the tests.rs file</p>
</blockquote>
<p>I'd move it to a <code>benchmarks</code> folder like the <code>tests</code> folder so we can break them out if need-be. Thanks for all the work on this! :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sru">@sru</a> on 2015-08-30 03:51</div>
            <div class="timeline-body"><p>~~Interestingly, Cargo does not pick up benchmarks from <code>benchmarks</code> folder.~~</p>
<p>EDIT: It has to be named <code>benches</code>.</p>
<p>The performance is crap probably because I am running it inside VM.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/203.html">clap-rs/clap#203</a> on 2015-08-30 04:12</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-08-30 04:15</div>
            <div class="timeline-body"><p>Ah yeah, could be - I just checked on a native i7 laptop and I get ~14,000 nanoseconds :wink:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/214.html">clap-rs/clap#214</a> on 2015-09-01 16:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-09-07 02:18</div>
            <div class="timeline-body"><p>@sru Do you have additional benchmarks you'd like to add, or should this issue be closed?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/sru">@sru</a> on 2015-09-07 02:40</div>
            <div class="timeline-body"><p>@kbknapp not for now. This issue can be closed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-09-07 02:41</div>
            <div class="timeline-body"><p>Sounds good :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @kbknapp on 2015-09-07 02:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:06 UTC
    </footer>
</body>
</html>
