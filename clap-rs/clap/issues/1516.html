<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Change `mut self` to `&amp;mut self` on `App` Implementation and Possible Variants - clap-rs/clap #1516</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Change `mut self` to `&amp;mut self` on `App` Implementation and Possible Variants</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/1516">#1516</a>
        opened by <a href="https://github.com/erayerdin">@erayerdin</a>
        on 2019-07-05 12:25
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/erayerdin">@erayerdin</a> on 2019-07-05 12:25</div>
            <div class="timeline-body"><!--
Please use the following template to assist with creating an issue and to ensure a speedy resolution. If an area is not applicable, feel free to delete the area or mark with `N/A`
-->

<h3>Rust Version</h3>
<ul>
<li>rustc 1.34.0 (91856ed52 2019-04-10)</li>
</ul>
<h3>Affected Version of clap</h3>
<pre><code>name = &quot;clap&quot;
 &quot;clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)&quot;,
&quot;checksum clap 2.33.0 (registry+https://github.com/rust-lang/crates.io-index)&quot; = &quot;5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9&quot;
</code></pre>
<h3>Feature Request Summary</h3>
<p><code>&amp;self</code> instead of <code>self</code> in <code>Arg</code> implementation.</p>
<h3>Expected Behavior Summary</h3>
<pre><code class="language-rust">// assuming I have an instance called `app`
// and I have two `Arg` instance called `arg1` and `arg2`
app.arg(arg1)
app.arg(arg2) // I expect it to succeed
</code></pre>
<h3>Actual Behavior Summary</h3>
<p>Compiler yells that I have moved <code>app</code> in <code>app.arg(arg1)</code> and fails on <code>app.arg(arg2)</code>.</p>
<h3>Steps to Reproduce the issue</h3>
<p>Told above.</p>
<h3>Sample Code or Link to Sample Code</h3>
<p>I actually discussed this <a href="https://www.reddit.com/r/rust/comments/c7ujoq/hey_rustaceans_got_an_easy_question_ask_here/eswcw86?utm_medium=android_app&amp;utm_source=share">on a thread in r/rust</a> and provided sample codes there.</p>
<h3>Further Elaboration</h3>
<p>I do not know if this is a design choice due to enforcing <em>builder pattern</em>, but I find it convenient to define my <code>Arg</code>s and <code>SubCommand</code>s as a variable beforehand and then put it into builder pattern. What I find convenient is:</p>
<pre><code class="language-rust">// assuming I have `app`

let sc1 = SubCommand::with_name(&quot;sc1&quot;);
let foo_arg = Arg::with_name(&quot;foo&quot;);
sc1.arg(foo_arg);

let sc2 = SubCommand::with_name(&quot;sc2&quot;);
let bar_arg = Arg::with_name(&quot;bar&quot;);
sc2.arg(bar_arg);

app.subcommand(sc1);
app.subcommand(sc2); // fails here because app moved in the line above
// because `subcommand` signature contains `mut self`, not `&amp;mut self`
</code></pre>
<p>I am aware there are methods (i) that I can provide <code>SubCommand</code>s and <code>Arg</code>s as array as in <code>subcommands</code> and <code>args</code> methods that accept a reference to an array and (ii) that I can use a builder kind-of pattern when constructing subcommands and args and adding them into <code>App</code>.</p>
<p>However, don't you think it would be better to separate the definition of <code>Arg</code>s and/or <code>SubCommand</code>s beforehand due to the pros below:</p>
<ul>
<li><strong>It would be more convenient</strong> for programmer's mind.</li>
<li><strong>It would be more programmatic</strong> while constructing <code>Arg</code>s and <code>SubCommand</code>s.</li>
<li><strong>It would be way more readable</strong> if we seperated the definitions of <code>Arg</code>s and <code>SubCommand</code>s. Instead of nesting them each other, separating them would make it more easier to read and debug in mind.</li>
</ul>
<p>On the other hand, I, kinda, understand why the current approach is chosen:</p>
<ul>
<li><strong>You might like to enforce builder pattern</strong></li>
<li>Or <strong>defining the app once and keeping it immutable during the lifetime of a program</strong> would make it safer so nobody could change the <code>Arg</code>s or <code>SubCommand</code>s while the program runs.</li>
</ul>
<p>I could not find or define a possible variant of this issue so I have wanted to create myself. If this is duplicate or is not considered to be implemented, core developers can close the issue. Thanks in advance.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/comfortablynick">@comfortablynick</a> on 2019-07-18 21:42</div>
            <div class="timeline-body"><p>As a workaround, this will work:</p>
<pre><code class="language-rust">// assuming I have `app`
let app = app.subcommand(sc1);
let app = app.subcommand(sc2); 
</code></pre>
<p>I'm not sure if there are any performance penalties, but that's what I've done when I needed to get around the builder pattern (e.g., conditionally calling a method on <code>app</code>).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-02-01 13:12</div>
            <div class="timeline-body"><blockquote>
<p>I do not know if this is a design choice due to enforcing builder pattern</p>
</blockquote>
<p>Yes, this is intentional design choice. <code>&amp;mut self</code> and <code>mut self</code> are different types of builders, this is described <a href="https://docs.rs/derive_builder/0.7.2/derive_builder/#builder-patterns">there</a> in detail, both have their own pros and cons. <code>clap</code> made it's choice.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @CreepySkeleton on 2020-02-01 13:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> added by @pksunkara on 2020-02-01 19:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: wont do</span> added by @pksunkara on 2020-02-01 19:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2022-09-01 21:23</div>
            <div class="timeline-body"><p>Can this decision be reconsidered?</p>
<p>At least <a href="https://docs.rs/derive_builder/latest/derive_builder/index.html#-performance-considerations"><code>derive_builder</code> claims</a>:</p>
<blockquote>
<p>Luckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=self) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.</p>
</blockquote>
<p>The restrictiveness is very noticeable when dynamically generating a command and ending up needing a mutable variable you need to reassign for each conditional setting etc. or when having interactions in loops.</p>
<p>Changing it to <code>&amp;mut</code> would either require any function consuming an e.g. Command to allow a reference, or it would need to have a build() method cloning it. So I can understand the hesitation changing this. On top of the obvious breaking change.</p>
<p>Just wanted to voice my opinion, running into this problem immediately when using the builder pattern as I used the derive macro until now.</p>
<p>My problem would probably be a lot less noticeable when all the builder methods would take options, but e.g. version takes the <code>&amp;str</code> directly, meaning the only way to conditionally set it, is like so:</p>
<pre><code class="language-rs">if let Some(version) = version {
  command = command.version(version);
}
// or (non mut variable)
let command = if let Some(version) = version {
  command.version(version)
} else {
  command
}
</code></pre>
<p>As many of my uses look like that, enabling support for passing options into e.g. <code>version()</code> would improve this greatly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-01 22:30</div>
            <div class="timeline-body"><p>Personally, the reason I dislike <code>&amp;mut self</code> builders is</p>
<pre><code class="language-rust">let cmd = std::process::Command::new(&quot;foo&quot;).arg(&quot;bar&quot;);
```
fails to compile because `cmd` is capturing a `&amp;mut` and instead you need to do
```rust
let mut cmd = std::process::Command::new(&quot;foo&quot;).;
cmd.arg(&quot;bar&quot;);
```

&gt; Luckily Rust is clever enough to optimize these clone-calls away in release builds for your every-day use cases. Thats quite a safe bet - we checked this for you. ;-) Switching to consuming signatures (=self) is unlikely to give you any performance gain, but very likely to restrict your API for non-chained use cases.

I would be very cautious about relying on the compiler optimization as its dependent on inlining.  The function probably needs a `#[inline(always)]`.
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2022-09-02 09:37</div>
            <div class="timeline-body"><p>But maybe we could add <code>set_*</code> methods that can be used on <code>&amp;mut</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-02 12:23</div>
            <div class="timeline-body"><p>Not really thrilled with having both builders in the API</p>
<ul>
<li>I don't want to keep up two different sets and it will be easy for contributors to do so</li>
<li>This puts the dilemma of choice on users which we should be cautious with</li>
<li>We already have a problem with having too much in rustdoc, this will make it worse</li>
<li>This will be more for the compiler to chew on and we are looking to drop compile times.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2022-09-02 12:44</div>
            <div class="timeline-body"><p>Makes sense. Also, I noticed looking at the most recent changes, with the new implementation using <code>Resettable</code> it allows using the builder pattern even for conditional <code>version</code> etc., so at least for my use case that solves this inconvenience mostly.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:34:00 UTC
    </footer>
</body>
</html>
