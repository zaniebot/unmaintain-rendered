<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implement a partial parse method for Command - clap-rs/clap #4395</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Implement a partial parse method for Command</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/clap-rs/clap/issues/4395">#4395</a>
        opened by <a href="https://github.com/0xForerunner">@0xForerunner</a>
        on 2022-10-17 15:50
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/0xForerunner">@0xForerunner</a></div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Clap Version</h3>
<p>4.0.8</p>
<h3>Describe your use case</h3>
<p>I want to build an interactive parser. Imagine you have a program with dozens of nested subcommands and args. In this case it is not practical for the user to enter everything in one line. I think an interactive parser itself might be outside of scope for clap, but a method that allows partial parsing would make this much easier and more elegant for perhaps another crate to use.
Example:</p>
<pre><code>#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Parser)]
#[serde(rename_all = &quot;snake_case&quot;)]
pub enum Msg {
    SetConfig {
        #[command(subcommand)]
        set_config_msg: AnotherEnum,
    },
    AddAsset {
        asset_info_type: MyStruct,
    },
}

#[derive(Parser)]
pub struct AnotherEnum {
    Variant0,
    Variant1(MyStruct),
}

pub struct MyStruct {
    string0: String,
    string1: String
} 

</code></pre>
<p>My program would eventually look like this:</p>
<pre><code>&gt;&gt;&gt; my-cli
Enter Msg (set_config or add_asset)
&gt;&gt;&gt; set_config
Enter set_config_msg (Variant0 or Variant1)
&gt;&gt;&gt; Variant1
Enter string0:
&gt;&gt;&gt; Hello
Enter string1:
&gt;&gt;&gt; World
Done
</code></pre>
<h3>Describe the solution you'd like</h3>
<p>I think there are a couple things that need to be built to allow this. To reiterate I don't think clap should be doing the readline implementation, just the partial parsing.
I imagine the function signature would looks something like this</p>
<pre><code>    pub fn try_get_partial_matches_from&lt;I, T&gt;(mut self, itr: I) -&gt; ClapResult&lt;PartialArgMatches&gt;
    where
        I: IntoIterator&lt;Item = T&gt;,
        T: Into&lt;OsString&gt; + Clone,
    {
        ...
    }
</code></pre>
<p>and PartialArgMatches would contain all the same information, except potentially omit any info from the next subcommand:</p>
<pre><code>#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct PartialArgMatches {
    #[cfg(debug_assertions)]
    pub(crate) valid_args: Vec&lt;Id&gt;,
    #[cfg(debug_assertions)]
    pub(crate) valid_subcommands: Vec&lt;Str&gt;,
    pub(crate) args: FlatMap&lt;Id, MatchedArg&gt;,
    pub(crate) subcommand: Option&lt;Box&lt;PartialSubCommand&gt;&gt;,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub(crate) struct PartialSubCommand {
    pub(crate) name: String,
    pub(crate) matches: Result&lt;PartialArgMatches, MatchesError&gt;,
}
</code></pre>
<p>try_get_partial_matches_from would succeed if it receives all required args and required subcommands for the specific command it was called on. It would attempt to traverse down the subcommand tree, but if it fails it would simply return as much successful parsing as possible, and the error would be contained in a PartialSubCommand</p>
<p>I don't think this will be too much work hopefully, as the new method should be very similar to what is already created. The only difference really is when to error. Ideally try_get_partial_matches_from will only error if it cannot successfully parse the very first subcommand.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @0xForerunner on 2022-10-17 15:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-10-17 16:56</div>
            <div class="timeline-body"><p>At first I thought you were discussing a REPL which <a href="https://docs.rs/clap/latest/clap/_derive/_cookbook/repl/index.html">clap already supports</a> but instead you are wanting to prompt the user for each part of the struct as it gets built up.</p>
<p>We do have #1634 for prompts for fields, which would act as another input like an arg, an env variable, a default, etc.</p>
<p>But your use case goes further and has people entering sub-prompts for subcommands.</p>
<p>I don't think this is as simple as the issue describes it to be to implement as this is effectively pausing the parser and having it resumed later.  This also feels too specialized that the work and code to support this wouldn't give enough pay off.  This would also not work with the derive which the introductory code makes it sound like it would be expected.</p>
<p>On reddit, I had brought up the idea of CommandActions like ArgActions but seeing more detail, I'm unsure if that would apply; it'd very much depend on how we design the actions.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/0xForerunner">@0xForerunner</a> on 2022-10-17 17:34</div>
            <div class="timeline-body"><p>@epage thanks so much for taking the time to look at this. I dug a little deeper into clap this morning and I agree it looks like it might be more complicated than I suggested above. I'll look into those link you sent and see if perhaps that will work as a workaround for me. The CommandActions that I was looking for on reddit would have been a hacky workaround to get the functionality that I want, but the feature request above is really what I'm looking to achieve. I'm curious If you have any other ideas for how I can achieve this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/0xForerunner">@0xForerunner</a> on 2022-10-17 18:01</div>
            <div class="timeline-body"><blockquote>
<p>This would also not work with the derive which the introductory code makes it sound like it would be expected.</p>
</blockquote>
<p>Why would this not work with derive? There might be something I'm not understanding here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/0xForerunner">@0xForerunner</a> on 2022-10-17 18:05</div>
            <div class="timeline-body"><p>@epage  If I were to do this work myself, do you imagine that this could potentially be included in clap via a PR? or do you think it's too niche to warrant inclusion within clap? If you think it could eventually be included, could you perhaps give me some guidance on how you would implement it? I don't have any experience with clap so getting a little insight would be great.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-10-20 01:50</div>
            <div class="timeline-body"><blockquote>
<p>Why would this not work with derive? There might be something I'm not understanding here.</p>
</blockquote>
<p>The derive needs everything parsed to be able to fill in the fields.</p>
<blockquote>
<p>@epage If I were to do this work myself, do you imagine that this could potentially be included in clap via a PR? or do you think it's too niche to warrant inclusion within clap? If you think it could eventually be included, could you perhaps give me some guidance on how you would implement it? I don't have any experience with clap so getting a little insight would be great.</p>
</blockquote>
<p>Native, built-in support for this exact work flow is unlikely to get in unless we see a wider need.  If we can find a solution that provides the building blocks for your need that can be useful more broadly, then that can work.  For example, if we could expose a single parse pass and callers build on top of that, then that might work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/0xForerunner">@0xForerunner</a> on 2022-10-21 04:23</div>
            <div class="timeline-body"><p>That sounds good @epage. I created a super basic repo called <a href="https://github.com/ewoolsey/clap-interactive">clap-interactive</a> with support for clap. I'm not sure that's the best way to get the functionality that I want but it works pretty well for what I need. I am still looking for a better way to begin the interactive mode when the clap parser errors out.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-triage</span> added by @epage on 2022-11-08 04:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-parsing</span> added by @epage on 2022-11-08 04:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6185.html">clap-rs/clap#6185</a> on 2025-11-18 16:30</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:48:51 UTC
    </footer>
</body>
</html>
