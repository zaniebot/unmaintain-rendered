<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Using index_of()/indices_of() with optional arguments that take optional values - clap-rs/clap #2419</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Using index_of()/indices_of() with optional arguments that take optional values</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/2419">#2419</a>
        opened by <a href="https://github.com/cptpcrd">@cptpcrd</a>
        on 2021-03-20 17:21
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/cptpcrd">@cptpcrd</a> on 2021-03-20 17:21</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the existing issues</li>
</ul>
<h3>Describe your use case</h3>
<p>I have multiple optional arguments with optional values. If several of them were specified <em>without</em> passing a value, I want to determine the indices of the arguments so I can find out which one was specified first. However, it seems that this is one of the few cases where <code>Arg::index_of()</code>/<code>Arg::indices_of()</code> <em>doesn't</em> work.</p>
<p>A simple example can be found below.</p>
<h3>Describe the solution you'd like</h3>
<p>Ideally, <code>Arg::index_of()</code> would work for arguments with optional values.</p>
<h3>Alternatives, if applicable</h3>
<p>Perhaps a new method, say <code>Args::index_of_opt()</code> (which would return the index of the flag like <code>-a</code> or --all`, instead of the value) could be added?</p>
<h3>Additional Context</h3>
<p>I'm using <code>structopt</code>, but I've translated this to <code>clap</code> code.</p>
<p>Example with clap 2.33:</p>
<pre><code class="language-rust">fn main() {
    use clap::{Arg, App};
    
    let app = App::new(&quot;Basic Test&quot;)
        .arg(Arg::with_name(&quot;abc&quot;)
            .short(&quot;a&quot;)
            .long(&quot;abc&quot;)
            .takes_value(true)
            .multiple(false)
            .min_values(0)
            .max_values(1));

    // I can get the index in all of these cases (because clap returns the index of the value)

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-a1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;--abc=1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-a&quot;, &quot;1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;--abc&quot;, &quot;1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    // But I can't get the index in these cases (which is when I really need it!)

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-a&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;--abc&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));
}
</code></pre>
<p>This produces the following output:</p>
<pre><code>Some(2)
Some(2)
Some(2)
Some(2)
None
None
</code></pre>
<details>
<summary>Updated for clap 3 (produces the same output as the above version when run against the latest master):</summary>

<pre><code class="language-rust">fn main() {
    use clap::{Arg, App};
    
    let app = App::new(&quot;Basic Test&quot;)
        .arg(Arg::new(&quot;abc&quot;)
            .short('a')
            .long(&quot;abc&quot;)
            .takes_value(true)
            .multiple(false)
            .min_values(0)
            .max_values(1));

    // I can get the index in all of these cases (because clap returns the index of the value)

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-a1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;--abc=1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-a&quot;, &quot;1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;--abc&quot;, &quot;1&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    // But I can't get the index in these cases (which is when I really need it!)

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-a&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;--abc&quot;]);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;abc&quot;));
}
</code></pre>
</details>

</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by @cptpcrd on 2021-03-20 17:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "3.0" by @ldm0 on 2021-03-20 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "3.0" by @pksunkara on 2021-03-20 21:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "3.1" by @pksunkara on 2021-03-20 21:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: matches</span> added by @pksunkara on 2021-03-20 21:45</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/183.html">epage/clapng#183</a> on 2021-12-06 21:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: matches</span> removed by @epage on 2021-12-08 20:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-parsing</span> added by @epage on 2021-12-08 20:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> removed by @epage on 2021-12-08 21:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-08 21:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-13 16:36</div>
            <div class="timeline-body"><p>Currently, we only support indices for values, not arguments.  This will require some design work for what the API / behavior should be.</p>
<blockquote>
<p>If several of them were specified without passing a value, I want to determine the indices of the arguments so I can find out which one was specified first.</p>
</blockquote>
<p>Could you elaborate on your use case for why the order they are set matters?  Its helpful to have the wider context on these types of things.</p>
<blockquote>
<p>I'm using structopt, but I've translated this to clap code.</p>
</blockquote>
<p>How are you getting the index with structopt?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "3.1" by @epage on 2021-12-13 16:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-design</span> added by @epage on 2021-12-13 16:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cptpcrd">@cptpcrd</a> on 2021-12-13 22:34</div>
            <div class="timeline-body"><blockquote>
<p>Could you elaborate on your use case for why the order they are set matters? Its helpful to have the wider context on these types of things.</p>
</blockquote>
<p>I'm trying to match the behavior of a C program where the order matters. That isn't terribly uncommon for C programs; e.g. <code>tar -C</code>.</p>
<blockquote>
<p>How are you getting the index with structopt?</p>
</blockquote>
<p>Something like this (see <a href="https://docs.rs/structopt/0.3.23/structopt/trait.StructOpt.html#required-methods">docs</a>):</p>
<pre><code>use structopt::StructOpt;

#[derive(Debug, StructOpt)]
struct Opt {
    #[structopt(short, long)]
    debug: bool,
}

fn main() {
    let matches = Opt::clap().get_matches_from(&amp;[&quot;&quot;, &quot;-d&quot;]);
    let opt = Opt::from_clap(&amp;matches);
    println!(&quot;{:?}&quot;, opt);
    println!(&quot;{:?}&quot;, matches.index_of(&quot;debug&quot;));
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fabianfreyer">@fabianfreyer</a> on 2023-05-15 16:33</div>
            <div class="timeline-body"><p>I'm running into a related issue (https://github.com/clap-rs/clap/discussions/4908). In my use case there are multiple configuration layers that override each other (e.g. <code>--config-file /path/to/file --env --url https://example.com/</code>, where ordering of each option matters. One of these options takes an optional argument. In this case, <code>index_of</code> doesn't return the index of the argument.</p>
<p>@epage:</p>
<blockquote>
<p>Currently, we only support indices for values, not arguments. This will require some design work for what the API / behavior should be.</p>
</blockquote>
<p>Is this still true? The docs say:</p>
<blockquote>
<p>For flags (i.e. those arguments which donâ€™t have an associated value), indices refer to occurrence of the switch, such as -f, or --flag. However, for options the indices refer to the values -o val would therefore not represent two distinct indices, only the index for val would be recorded. This is by design.</p>
</blockquote>
<p>FWIW, this would be the behaviour I'd expect:</p>
<pre><code class="language-rust">use clap;

fn main() {
    use clap::{Arg, Command};
    
    let app = Command::new(&quot;Basic Test&quot;)
        .arg(Arg::new(&quot;optional&quot;)
            .short('o')
            .num_args(0..=1))
        .arg(Arg::new(&quot;flag&quot;)
            .short('f')
            .num_args(0))
        .arg(Arg::new(&quot;value&quot;)
            .short('v')
            .num_args(1));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-f&quot;]);
    assert_eq!(matches.index_of(&quot;flag&quot;), Some(1));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-v&quot;, &quot;42&quot;]);
    assert_eq!(matches.index_of(&quot;value&quot;), Some(2));

    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-o&quot;, &quot;42&quot;]);
    assert_eq!(matches.index_of(&quot;optional&quot;), Some(2));
    
    let matches = app.clone().get_matches_from(&amp;[&quot;&quot;, &quot;-o&quot;]);
    assert_eq!(matches.index_of(&quot;optional&quot;), Some(1)); // Fails, returns None.
}
</code></pre>
<p>I've drafted up PR #4909 to implement this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/4909.html">clap-rs/clap#4909</a> on 2023-05-15 17:34</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fabianfreyer">@fabianfreyer</a> on 2023-05-16 11:18</div>
            <div class="timeline-body"><p>Perhaps opening a PR was the wrong thing to do here -- what would be the best way to help move this forward?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-05-17 21:40</div>
            <div class="timeline-body"><blockquote>
<p>Is this still true? The docs say:</p>
</blockquote>
<p>Nuance: it is true for <code>ArgAction::Set</code> and <code>ArgAction::Append</code>.  It is not true for <code>ArgAction::SetTrue</code>.</p>
<p>When you do <code>num_args(0..=1)</code>, that is still an <code>ArgAction::Set</code> even if it still sometimes acts like <code>ArgAction::SetTrue</code>.</p>
<blockquote>
<p>FWIW, this would be the behaviour I'd expect:</p>
</blockquote>
<p>That works for you, but what about others? Users are relying on a mapping between values and indices.</p>
<blockquote>
<p>Perhaps opening a PR was the wrong thing to do here -- what would be the best way to help move this forward?</p>
</blockquote>
<p>Examine the relevant use cases for indices and come up with a proposal that meets them.  If its a breaking change, evaluate if there is a way to opt into it now or whether we have to wait on clap v5.0.0 for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fabianfreyer">@fabianfreyer</a> on 2023-06-14 01:52</div>
            <div class="timeline-body"><p>Right, so, use cases. There seem to be two disjunct use cases here:</p>
<ol>
<li><p>Keeping track of the order of <em>values</em>: this is currently supported, and there is a 1:1 mapping between an <code>ArgMatch</code>'s values (e.g. via <code>ArgMatches::get_many</code>), which do not include any occurrences of an <code>Arg</code> with no value.</p>
<pre><code>--arg --arg foo --arg bar
</code></pre>
<p>Given the above arguments, the expected behavior would be:</p>
<pre><code class="language-toml">values = [&quot;foo&quot;, &quot;bar&quot;]
indices = [1, 2]
</code></pre>
</li>
<li><p>Keeping track of an <code>Arg</code>'s <em>occurrences</em>, independently of whether any values are passed: this is what was proposed by #4909. In this case, there would need to be a 1:1 mapping between the list of indices and the list of occurrences, e.g.:</p>
<pre><code>--arg --arg foo --arg bar
</code></pre>
<p>Given the above arguments, the expected behavior would be:</p>
<pre><code class="language-toml">occurrences = [[], [&quot;foo&quot;], [&quot;bar&quot;]]
indices = [1, 2, 3]
</code></pre>
</li>
</ol>
<p>I currently see the following ways forward:</p>
<ol>
<li>Introduce a separate index, e.g. <code>ArgMatches::ocurrence_indices()</code>. Pro: This would allow opt-in to this functionality without breaking changes. Contra: It's confusing and clutters <code>ArgMatches</code>.</li>
<li>Implement functionality as proposed in #4909. This would be a breaking change. An argument can be made that users who allow optional arguments should use <code>occurrences</code> to handle the cases they explicitely allow. This could be gated behind a feature flag which is removed in clap v5.0. <br />
<strong>Pro</strong>: The code for this is already around, and it's trivial to adapt.
<strong>Contra</strong>: Asking users to use <code>ocurrences</code> to iterate over optional values may be confusing.</li>
<li>Enforce downcasting in <code>ArgMatches::get_many</code> and similar functions  for optional argument values to types that support emptiness, e.g. <code>Option</code> (<code>num_args(0..=1)</code>) and/or iterable types such as <code>Vec</code> (<code>num_args(0..n)</code>). This would be a breaking change, which could be gated behind a feature flag which is removed in clap v5.0. <br />
<strong>Pro</strong>: indices would map directly to ocurrences <em>and</em> values, and values for optional arguments are inherently optional (<code>Option</code> or empty Vecs etc), leading to more idiomatic code. <br />
<strong>Contra</strong>: Arguably the most breaking change.</li>
</ol>
<p>A mixture of these approaches could also be possible, e.g. going with 1.) for clap v4 and implementing 3.) for clap v5 and feature-gating it for clap v4, then deprecating 1.) in clap v5.</p>
<p>I'd be curious to see what aspects I missed, because I'm sure there are some.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-06-14 13:39</div>
            <div class="timeline-body"><p>For some extra context, we did not expose grouping-by-occurrence until clap v4.1.0 (see #2924), so index per occurrence was not possible until then.</p>
<p>An extra challenge in all of this is #3846.  Would occurrence indexes (whether replacing value indexes or parallel to it) make that issue harder, easier, or no difference?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/fabianfreyer">@fabianfreyer</a> on 2023-06-15 19:27</div>
            <div class="timeline-body"><p>TL;DR:
Ocurrence indices don't make #3846 harder. They do make it easier <em>if</em> vectors of optional values are considered. Otherwise, there is no difference.</p>
<p>Long form:
I think that would depend on details. This issue is about having a mapping of indices to <em>ocurrences</em>, whereas #3846 is about having a mapping of values to their source locations (and hence indices). While not every value can be assigned an index (e.g. what index would a default value have?), if we constrain that to values set by arguments, then every value should be attributable to a specific occurrence of an argument, and hence, an index.</p>
<p>Current value indices form a subset of the proposed occurrence indices, every value is part of an ocurrence, but not all ocurrences have values:</p>
<pre><code>                --arg --arg foo --arg bar
value idx:                  ^0        ^1
occurrence idx:      ^0     ^1        ^2
</code></pre>
<p>Therefore, using ocurrence indices instead of value indices definitely don't make it harder to find an index for every value (i.e. #3846).</p>
<p>Now consider (since I'm not sure how to do <code>num_args</code> via derive) lists of optional values, e,g.:</p>
<pre><code class="language-rust">#[derive(Args)]
struct MyArgs {
    // --arg1 --arg1=42 -&gt; vec![None, Some(42)]
    #[clap(short, long, value_source)]
    pub arg1: Vec&lt;Value&lt;Option&lt;u8&gt;&gt;&gt;,

    // --arg2 --arg2 foo --arg2 foo bar -&gt; vec![vec![], vec![&quot;foo&quot;], vec![&quot;foo&quot;, &quot;bar&quot;]]
    #[clap(short, long, value_source)]
    pub arg1: Vec&lt;Value&lt;Vec&lt;String&gt;&gt;&gt;,
}
</code></pre>
<p>In these cases, finding an index to assign to the empty values would be possible using occurrence indices, but not possible using value indices. (i.e. making #3864 easier) However, since args taking a variable number of values seem to not be supported like that using derive (unless I'm mistaken?) at the moment, I'd say at the moment it doesn't make a difference.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:08 UTC
    </footer>
</body>
</html>
