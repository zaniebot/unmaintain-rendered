```yaml
number: 1103
title: "Feature: Custom Derive for ArgEnum"
type: issue
state: closed
author: Hoverbear
labels: []
assignees: []
created_at: 2017-11-12T18:11:36Z
updated_at: 2018-08-02T03:30:14Z
url: https://github.com/clap-rs/clap/issues/1103
synced_at: 2026-01-10T01:57:42Z
```

# Feature: Custom Derive for ArgEnum

---

_Issue opened by @Hoverbear on 2017-11-12 18:11_

Hey!

I had a bit of time, and a hankering to write a custom derive, so I got working on a custom derive for `ArgEnum`. 

I've structured the crate so if we want to expand it, it should be easy. I think this is related to #835 but I didn't look too deeply into what the progress is with that.

The crate is https://github.com/Hoverbear/clap-derives and unpublished, and I'd be more than happy to transfer you (@kbknapp) ownership. It's a first draft and could probably use refinement.

You can see an example here: 

```rust
#[macro_use]
extern crate clap;
#[macro_use]
extern crate clap_derive;

use clap::{App, Arg};

#[derive(ArgEnum, Debug)]
enum ArgChoice {
    Foo,
    Bar,
    Baz,
}

fn main() {
    let matches = App::new(env!("CARGO_PKG_NAME"))
            .arg(Arg::with_name("arg")
                .required(true)
                .takes_value(true)
                .possible_values(&ArgChoice::variants())
            ).get_matches();
    
    let t = value_t!(matches.value_of("arg"), ArgChoice)
        .unwrap_or_else(|e| e.exit());

    println!("{:?}", t);
}
```

Will derive this:

```rust
impl ::std::str::FromStr for ArgChoice {
    type Err = String;
    fn from_str(input: &str) -> ::std::result::Result<Self, Self::Err> {
        match input {
            val if ::std::ascii::AsciiExt::eq_ignore_ascii_case(val, "Foo") => Ok(ArgChoice::Foo),
            val if ::std::ascii::AsciiExt::eq_ignore_ascii_case(val, "Bar") => Ok(ArgChoice::Bar),
            val if ::std::ascii::AsciiExt::eq_ignore_ascii_case(val, "Baz") => Ok(ArgChoice::Baz),
            _ => Err({
                let v = ["Foo", "Bar", "Baz"];



                ::fmt::format(::std::fmt::Arguments::new_v1_formatted(
                    &["valid values: "],
                    &match (&v.join(" ,"),) {
                        (__arg0,) => {
                            [
                                ::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Display::fmt),
                            ]
                        }
                    },
                    &[
                        ::std::fmt::rt::v1::Argument {
                            position: ::std::fmt::rt::v1::Position::At(0usize),
                            format: ::std::fmt::rt::v1::FormatSpec {
                                fill: ' ',
                                align: ::std::fmt::rt::v1::Alignment::Unknown,
                                flags: 0u32,
                                precision: ::std::fmt::rt::v1::Count::Implied,
                                width: ::std::fmt::rt::v1::Count::Implied,
                            },
                        },
                    ],
                ))
            }),
        }
    }
}
impl ArgChoice {
    fn variants() -> [&'static str; 3usize] {
        ["Foo", "Bar", "Baz"]
    }
}
````

---

_Comment by @kbknapp on 2017-11-12 18:52_

Hey! 

cc @TeXitoi

Excellent! This is a great start towards my ideas for 3.x. I've cc'd @TeXitoi because I'd like to re-invigorate the move towards 3.x and finishing the CustomDerive piece is a big part of that movement. With my job monopolizing my time this kind of fell off in #835 but now that the [v3-master branch](https://github.com/kbknapp/clap-rs/tree/v3-master) is coming together it's worth working towards again.

The grand plan is to create a `clap_derive` crate which contains `#[derive(*)]` directives:

* `ArgEnum` as you've done :heart_eyes: 
* `IntoApp` which takes an arbitrary struct and creates a `clap::App` (currently implemented in [`structopt`](https://github.com/TeXitoi/structopt) which I'd like to pull into this `clap_derive` crate)
* `FromArgMatches` which takes a `clap::ArgMatches` struct and creates the arbitrary struct (also implemented in `structopt`)
* `ClapApp` which is a convenience marking and simply does *both* `IntoApp` and `FromArgMatches`
* `ClapKey` (name?...maybe `ArgKey`?) which allows using an enum instead of strings to access `clap::Arg`s, `clap::App`s (formerly `clap::SubCommand`s in v2.x), and `clap::ArgGroup`s.

I was tentatively planning on storing all the `clap_*` crates (I'm also moving the shell completions to `clap_completions` and macros to `clap_macros`) at the root of the clap repo, but individual repos are OK as well, although I'd like everything to versioned in lock-step which is harder in individual repos.

If both @Hoverbear and @TeXitoi think the design is sound/doable I'd like to make PRs against the v3-master branch, or if keeping individual repos is better, making PRs against the `clap_derive` crate. If that's the route we go, I would like to transfer the crate to me in order to provide less confusion to the community as this would be part of the "official" clap crates, however I would also like to keep/add @Hoverbear and @TeXitoi as authors in the `Cargo.toml` because they the ones deserving of it. Also at that point, both would become collaborators on this repo so they could continue to work on this even when I'm busy with my day job.

---

_Comment by @kbknapp on 2017-11-12 19:06_

Here are the unknowns still, and what needs to be decided

### Supporting Subcommands via CustomDerive

We need to find out how to support a struct with arbitrary options/flags and also a subcommand, and how that gets represented via CustomDerive. I believe @TeXitoi suggested an enum, where each variant holds it's arbitrary struct representation. I'm good with this, and we just need to work towards ironing out the details and actually implementing. I believe this would also require adding another `#[derive(*)]` directive such as `ClapSubCommand` for enums which are to represent a subcommand.

The hard part is how does this work ergonomically.

Some code examples. I want the end user result to be as close as possible to to this:

```rust
#[derive(ClapApp)]
struct MyApp {
    flag: bool,
    subcommand: MySubCommand
}

#[derive(ClapSubCommand)]
enum MySubCommand {
    Foo(FooCommand),
    Bar(BarCommand),
}

#[derive(ClapApp)]
struct FooCommand {
    verbose: bool
}

#[derive(ClapApp)]
struct BarCommand {
    name: String
}

fn main() {
    // run with `$ myapp bar kevin`
    let app = MyApp::parse();
    match app.subcommand {
        FooCommand(foo) => println!("Verbose used?: {:?}", foo.verbose),
        BarCommand(bar) => println!("Hello {}!", bar.name),
        _ => println!("No subcommand used."),
    }
}
``` 

### Supporting ASCII Case Insensitive ArgEnums

As @Hoverbear and I discussed briefly at RustBeltRust, we need these ArgEnums to be case insensitive, but I'd also like an opt-in version that *is* case sensitive (perhaps via a different `#[derive(*)]` directive...`ArgEnumCaseSenseitive`? To incentivise case insensitivity due to typing length?



### Supporting Hyphens `-` in ArgEnums

There's also discussion in #1098 about if hyphens should be ignored or allowed, etc. I'm inclined to either allow hyphens (i.e. ignore them) or require special chars such as underscore (`_`) to allow them. Bottom line is there should be a way for people to use hyphens in their `ArgEnum`s

---

_Referenced in [clap-rs/clap#1037](../../clap-rs/clap/issues/1037.md) on 2017-11-12 19:15_

---

_Comment by @Hoverbear on 2017-11-12 19:28_

@kbknapp Please be aware custom derive crates must **only** contain custom derives. So we'd need a `clap_derive` crate with all of them in it separate from `clap`.

---

_Comment by @Hoverbear on 2017-11-12 19:29_

For case sensitivity around `ArgEnum` we could have an attribute that is `#[case_insensitive]`, for example.

---

_Comment by @Hoverbear on 2017-11-12 19:33_

@kbknapp You should have a transfer request in your inbox.

---

_Comment by @kbknapp on 2017-11-12 19:44_

> Please be aware custom derive crates must only contain custom derives. So we'd need a clap_derive crate with all of them in it separate from clap

Ah ok I wasn't aware of this having not done much with CustomDerive. OK separate repos it is, I'm good with it :smile:  :+1: 

---

_Comment by @kbknapp on 2017-11-12 19:49_

This issue was moved to kbknapp/clap-derives#1

---

_Closed by @kbknapp on 2017-11-12 19:49_

---

_Referenced in [clap-rs/clap#1659](../../clap-rs/clap/issues/1659.md) on 2020-02-03 09:17_

---
