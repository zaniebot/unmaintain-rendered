<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>[brain-dump]: Build commandline objects in code, for testing - clap-rs/clap #1595</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>[brain-dump]: Build commandline objects in code, for testing</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/1595">#1595</a>
        opened by <a href="https://github.com/matthiasbeyer">@matthiasbeyer</a>
        on 2019-11-08 16:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/matthiasbeyer">@matthiasbeyer</a></div>
            <div class="timeline-body"><p><strong>Disclaimer</strong>: This is just a brain-dump, I have not looked at other comments/issues/prs whatsoever, so feel free to close this and call me a moron if this already exists or is not possible, ... I'm just dumping my brain here.</p>
<hr />
<p>It would be nice to have an option to build the <code>ArgMatches</code> objects that get returned from clap when parsing the commandline in code.
My idea is to generate a <code>ArgMatches</code> object, (where the build process actually fails if it does not meet the spec written before, maybe even at compiletime if that is possible), and then being able to feed that <code>ArgMatches</code> object to my program like it would be feeded when calling the actual binary...</p>
<p>with that in place, it would be extremely easy to test commandline applications. Right now <a href="https://git.imag-pim.org/imag/tree/tests/ui/src/imag_header.rs#n30">I manually call the actual binary</a>, which is obviously another solution to the problem and also works quite well, but having an option to test the program via generating <code>clap</code> objects seems also to be a really nice way of doing things!</p>
<hr />
<p>Maybe such a thing already exists, I don't know... maybe I just missed something. But <em>maybe</em> this is an idea for you...</p>
<p>Have a nice weekend! :heart:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RaboliotLeGris">@RaboliotLeGris</a> on 2019-11-16 00:31</div>
            <div class="timeline-body"><p>I'm trying to build ArgMatches to tests some functions too. And for now the only thing I've found is that the struct implements the Default traits that allow us to easily built an empty ArgMatches (<code>clap::ArgMatches::default()</code>).</p>
<p>After some digging:
Create an empty ArgMatches it's fairly doable. Then I tried to populate the <code>args</code> value that is an Hashmap (It was close) and then you need to build a <code>MatchArgs</code> (That implements the Default traits o/), that is not expose in the <code>libs.rs</code>, so we can't build it :(</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/igozali">@igozali</a> on 2019-11-25 22:26</div>
            <div class="timeline-body"><p>Couldn't you lift the creation of <code>clap::App</code> into a function, and use the <code>App</code> object to parse your command line args in main and test? Something like this:</p>
<pre><code class="language-rust">use clap::{App, Arg};

fn make_app&lt;'a, 'b&gt;() -&gt; App&lt;'a, 'b&gt; {
    App::new(&quot;my-app&quot;).arg(
        Arg::with_name(&quot;name&quot;)
            .short(&quot;-n&quot;)
            .long(&quot;--name&quot;)
            .takes_value(true),
    )
}

fn main() {
    let app = make_app();
    let matches = app.get_matches();
    println!(&quot;name: {}&quot;, matches.value_of(&quot;name&quot;).unwrap_or(&quot;None&quot;));
}

#[cfg(test)]
mod test {
    use super::make_app;
    #[test]
    fn test_parse() {
        let app = make_app();
        let matches = app.get_matches_from(&amp;[&quot;./my-app&quot;, &quot;-n&quot;, &quot;first&quot;]);
        assert_eq!(matches.value_of(&quot;name&quot;).unwrap(), &quot;first&quot;);
    }
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/RaboliotLeGris">@RaboliotLeGris</a> on 2019-11-26 20:06</div>
            <div class="timeline-body"><p>Yep! If we use <code>get_matches_from</code>, we can build whatever we want and it solves my tests issues.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matthiasbeyer">@matthiasbeyer</a> on 2019-11-27 13:21</div>
            <div class="timeline-body"><p>As said in the preface, I'm dumb. This is already doable right now with <code>get_matches_from</code> of course.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @matthiasbeyer on 2019-11-27 13:21</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:47:25 UTC
    </footer>
</body>
</html>
