<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expose related and mutually exclusive arguments via struct / enum? - clap-rs/clap #3115</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Expose related and mutually exclusive arguments via struct / enum?</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/3115">#3115</a>
        opened by <a href="https://github.com/epage">@epage</a>
        on 2021-12-09 16:11
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/epage">@epage</a></div>
            <div class="timeline-body"><p><a href="https://github.com/epage"><img src="https://avatars.githubusercontent.com/u/60961?v=4"></a> <strong>Issue by <a href="https://github.com/epage">epage</a></strong>
<em>Thursday May 03, 2018 at 02:38 GMT</em>
<em>Originally opened as <a href="https://github.com/TeXitoi/structopt/issues/104">TeXitoi/structopt#104</a></em></p>
<hr>
<p>I&#x27;m working on a CLI that currently looks like</p>
<pre><code>#[derive(StructOpt, Debug)]
#[structopt(name = &quot;staging&quot;)]
pub struct Arguments {
    #[structopt(short = &quot;i&quot;, long = &quot;input&quot;, name = &quot;STAGE&quot;, parse(from_os_str))]
    pub input_stage: path::PathBuf,
    #[structopt(short = &quot;d&quot;, long = &quot;data&quot;, name = &quot;DATA_DIR&quot;, parse(from_os_str))]
    pub data_dir: Vec&lt;path::PathBuf&gt;,
    #[structopt(flatten)]
    pub output: Output,
    #[structopt(short = &quot;v&quot;, long = &quot;verbose&quot;, parse(from_occurrences))]
    pub verbosity: u8,
}

#[derive(StructOpt, Debug)]
pub struct Output {
    #[structopt(short = &quot;o&quot;, long = &quot;output&quot;, name = &quot;OUT&quot;, parse(from_os_str))]
    pub dir: path::PathBuf,
    #[structopt(long = &quot;format&quot;,
                raw(possible_values = &quot;&amp;Format::variants()&quot;, case_insensitive = &quot;true&quot;),
                raw(default_value = &quot;DEFAULT_FORMAT&quot;))]
    pub format: Format,
    #[structopt(short = &quot;n&quot;, long = &quot;dry-run&quot;)]
    pub dry_run: bool,
}
</code></pre>
<p>I&#x27;m looking at adding some options that are mutually exclusive with <code>Arguments::output</code>.</p>
<p>This gave me the ideas:</p>
<ul>
<li>Allow flattened structs to define groups</li>
<li>Allow <code>Option&lt;Output&gt;</code> on an entire flattened struct to say the arguments require each other</li>
<li>Allow an <code>enum</code> to define mutually exclusive flags.  For example:</li>
</ul>
<pre><code>#[derive(StructOpt, Debug)]
#[structopt(name = &quot;staging&quot;)]
pub struct Arguments {
    #[structopt(short = &quot;i&quot;, long = &quot;input&quot;, name = &quot;STAGE&quot;, parse(from_os_str))]
    pub input_stage: path::PathBuf,
    #[structopt(short = &quot;d&quot;, long = &quot;data&quot;, name = &quot;DATA_DIR&quot;, parse(from_os_str))]
    pub data_dir: Vec&lt;path::PathBuf&gt;,
    #[structopt(flatten)]
    pub flags: Flags,
    #[structopt(short = &quot;v&quot;, long = &quot;verbose&quot;, parse(from_occurrences))]
    pub verbosity: u8,
}

// `Output` as above

#[derive(StructOpt, Debug)]
pub enum Flags
{
    Output(Output),
    Completions(Completions),
    DumpConfig(DumpConfig),
    DumpData(DumpData),
}

#[derive(StructOpt, Debug)]
pub struct Completions {
    #[structopt(long = &quot;completion&quot;, name = &quot;OUT&quot;, parse(from_os_str))]
    pub completion: path::PathBuf,
}

#[derive(StructOpt, Debug)]
pub struct DumpConfig{
    #[structopt(long = &quot;dump-config&quot;)]
    pub dump_config: bool,
}

#[derive(StructOpt, Debug)]
pub struct DumpData{
    #[structopt(long = &quot;dump-data&quot;)]
    pub dump_data: bool,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4"></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Thursday May 03, 2018 at 10:00 GMT</em></p>
<hr>
<p>First thought on the proposition, that is interesting, but not yet mature enough:</p>
<ul>
<li><code>derive(StructOpt)</code> on an enum will do subcommand, thus it need something else.</li>
<li><code>flatten</code> on an enum set subcommand for now, thus this feature might need a special keyword.</li>
<li>having DumpData just for a bool is quite sad, it would be better to have <code>Completions</code>, <code>DumpConfig</code> and DumpData` just be empty enum variant.</li>
<li><code>Completions</code> would be better with just the <code>PathBuf</code> directly inside.</li>
</ul>
<p>Maybe something like that:</p>
<pre><code>#[derive(StructOpt, Debug)]
#[structopt(name = &quot;staging&quot;)]
pub struct Arguments {
    #[structopt(short = &quot;i&quot;, long = &quot;input&quot;, name = &quot;STAGE&quot;, parse(from_os_str))]
    pub input_stage: path::PathBuf,
    #[structopt(short = &quot;d&quot;, long = &quot;data&quot;, name = &quot;DATA_DIR&quot;, parse(from_os_str))]
    pub data_dir: Vec&lt;path::PathBuf&gt;,
    #[structopt(group)]
    pub flags: Flags,
    #[structopt(short = &quot;v&quot;, long = &quot;verbose&quot;, parse(from_occurrences))]
    pub verbosity: u8,
}

#[derive(StructOptGroup, Debug)]
pub enum Flags
{
    // no annotation? an annotation?
    Output(Output), // &lt;- How to handle that with clap?
    #[structopt(long = &quot;completion&quot;, name = &quot;OUT&quot;, parse(from_os_str))]
    Completions(PathBuf),
    #[structopt(long = &quot;dump-config&quot;)]
    DumpConfig,
    #[structopt(long = &quot;dump-data&quot;)]
    DumpData,
}

#[derive(StructOpt, Debug)]
pub struct Output {
    #[structopt(short = &quot;o&quot;, long = &quot;output&quot;, name = &quot;OUT&quot;, parse(from_os_str))]
    pub dir: path::PathBuf,
    #[structopt(long = &quot;format&quot;,
                raw(possible_values = &quot;&amp;Format::variants()&quot;, case_insensitive = &quot;true&quot;),
                raw(default_value = &quot;DEFAULT_FORMAT&quot;))]
    pub format: Format,
    #[structopt(short = &quot;n&quot;, long = &quot;dry-run&quot;)]
    pub dry_run: bool,
}
</code></pre>
<p>For this particular need, subcommands seem more appropriate, and is working today. But that may be interesting for other cases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/epage"><img src="https://avatars.githubusercontent.com/u/60961?v=4"></a> <strong>Comment by <a href="https://github.com/epage">epage</a></strong>
<em>Thursday May 03, 2018 at 13:15 GMT</em></p>
<hr>
<blockquote>
<p>having DumpData just for a bool is quite sad, it would be better to have Completions, DumpConfig and DumpData` just be empty enum variant.</p>
</blockquote>
<p>Yeah, it was more for illustrative purposes of the wider idea.  As you say, even better if I can directly annotate an enum variant to say that its just a flag.</p>
<blockquote>
<p>Output would be better with just the String directly inside.</p>
</blockquote>
<p>Except that isn&#x27;t what I was trying to point out.  This is supposed to take in the <code>Output</code> struct.  In clap, I&#x27;d say</p>
<ul>
<li>the defaulted parts of the <code>Output</code> struct require <code>--output</code>.</li>
<li>The members of the <code>Output</code> struct are a group and that completions and dump conflict with the group.</li>
</ul>
<blockquote>
<p>For this particular need, subcommands seem more appropriate, and is working today. But that may be interesting for other cases.</p>
</blockquote>
<p>I&#x27;d considered that but its pretty common for CLIs to not go the subommand route for non-routine alternative behaviors of the application</p>
<ul>
<li><code>--version</code></li>
<li><code>--help</code></li>
<li><code>--completions</code></li>
<li>Creation of configuration files to jump start the user</li>
</ul>
<p>At that point, it felt awkward to create subcommands just for my debugging, so I went ahead and made my dump state flags do similar.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4"></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Thursday May 03, 2018 at 13:46 GMT</em></p>
<hr>
<blockquote>
<blockquote>
<p>Output would be better with just the String directly inside.</p>
</blockquote>
</blockquote>
<p>Sorry, I mean Completions</p>
<blockquote>
<p>Except that isn&#x27;t what I was trying to point out. This is supposed to take in the Output struct. In clap, I&#x27;d say</p>
<ul>
<li>the defaulted parts of the Output struct require --output.</li>
<li>The members of the Output struct are a group and that completions and dump conflict with the group.</li>
</ul>
</blockquote>
<p>Is it possible to express such constraints in pure clap? because if that&#x27;s not possible, we can&#x27;t do it in structopt.</p>
<p>I&#x27;m also afraid that this machinery will be too complicated to be understood by the users. Finding a clear, flexible and usable interface is a challenge here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/epage"><img src="https://avatars.githubusercontent.com/u/60961?v=4"></a> <strong>Comment by <a href="https://github.com/epage">epage</a></strong>
<em>Thursday May 03, 2018 at 14:09 GMT</em></p>
<hr>
<blockquote>
<blockquote>
<p>Is it possible to express such constraints in pure clap? because if that&#x27;s not possible, we can&#x27;t do it in structopt.</p>
</blockquote>
</blockquote>
<blockquote>
<p>Thee members of the Output struct are a group and that completions and dump conflict with the group.</p>
</blockquote>
<pre><code>    .group(ArgGroup::with_name(&quot;output_struct&quot;)
        .multiple(true)
        .args(&amp;[&quot;dir&quot;, &quot;format&quot;, &quot;dry_run&quot;])
        .conflicts_with_all(&amp;[&quot;completions&quot;, &quot;dump&quot;]))
</code></pre>
<blockquote>
<p>the defaulted parts of the Output struct require --output.</p>
</blockquote>
<p>I&#x27;ll admit, this one was more aspirational.  One option is to iterate on the fields and, if there are required fields, to mark the optional fields as depending on the required fields.</p>
<blockquote>
<p>I&#x27;m also afraid that this machinery will be too complicated to be understood by the users. Finding a clear, flexible and usable interface is a challenge here.</p>
</blockquote>
<p>Are you referring to the developer or to the user?</p>
<p>For the user, I think its understandable that some arguments only work in some settings.  I normally visually group these in the help (with python&#x27;s argparse) but haven&#x27;t played too much with doing that with clap yet.</p>
<p>For the developer, I&#x27;d say they are.  These are the things I&#x27;m  intuitively trying to do but can&#x27;t.  Instead I&#x27;m having to drop down into <code>raw</code> calls which, as I mentioned on another issue, have been challenging enough to get right, that I&#x27;ve just given up.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4"></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Thursday May 03, 2018 at 15:09 GMT</em></p>
<hr>
<p>Yeah, I mean the user of StructOpt, the developer of the cli.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/porglezomp"><img src="https://avatars.githubusercontent.com/u/1690225?v=4"></a> <strong>Comment by <a href="https://github.com/porglezomp">porglezomp</a></strong>
<em>Saturday May 05, 2018 at 05:51 GMT</em></p>
<hr>
<p>I wanted something very similar to these proposals, and was actually slightly surprised when nothing like them was available. I&#x27;d imagine that you could have something like:</p>
<pre><code>#[derive(StructOpt)]
#[structopt(flag_group)]
enum Mode {
    #[structopt(short = &quot;s&quot;, long = &quot;stack&quot;)]
    Stack,
    #[structopt(short = &quot;q&quot;, long = &quot;queue&quot;)]
    Queue,
}

#[derive(StructOpt)]
#[structopt(name = &quot;letter&quot;)]
struct Opt {
    #[structopt(from_flag_group)]
    mode: Mode,
}
</code></pre>
<p>and then you can either use <code>letter --stack</code> or <code>letter --queue</code>.
This would generate a required group, and unpack the options into the enum.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/sunshowers"><img src="https://avatars.githubusercontent.com/u/180618?v=4"></a> <strong>Comment by <a href="https://github.com/sunshowers">sunshowers</a></strong>
<em>Wednesday Mar 10, 2021 at 00:31 GMT</em></p>
<hr>
<p>One random thought I had is that I&#x27;ve noticed some remarkable similarities between structopt&#x27;s and serde&#x27;s data models. It seems like subcommands are equivalent to serde&#x27;s <a href="https://serde.rs/enum-representations.html#externally-tagged">externally tagged</a> enums, while mutually exclusive options, if modeled through enums, are similar to <a href="https://serde.rs/enum-representations.html#untagged">untagged</a> enums. It may be worth aligning with serde&#x27;s design in this respect.</p>
<p>One thing it suggests is the possibility for internally tagged enums, which may be reflected in the CLI as e.g. <code>path/to/binary --command foo --arg1 x --arg2 y</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/nathan-at-least"><img src="https://avatars.githubusercontent.com/u/4369700?v=4"></a> <strong>Comment by <a href="https://github.com/nathan-at-least">nathan-at-least</a></strong>
<em>Friday Aug 27, 2021 at 16:04 GMT</em></p>
<hr>
<p>I just skimmed this because I want this feature. IIUC in <a href="https://github.com/TeXitoi/structopt/issues/104">TeXitoi/structopt#104</a>#issuecomment-386308405 it <em>is</em> possible in <code>clap</code>, correct? If so, then only the <code>structopt</code> API needs to be defined. I&#x27;d be happy with the suggestion in <a href="https://github.com/TeXitoi/structopt/issues/104">TeXitoi/structopt#104</a>#issuecomment-386246259 .</p>
<p>For my current case, I simply want exclusive options: either <code>--verbose</code> or <code>--quiet</code> or neither, but not both. Is this already expressable in <code>structopt</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:11</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4"></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Friday Aug 27, 2021 at 16:18 GMT</em></p>
<hr>
<p>@nathan-at-least https://github.com/TeXitoi/structopt/blob/master/examples/group.rs is almost what you want.</p>
<p>And what you want is:</p>
<pre><code>use structopt::StructOpt;

#[derive(Debug, StructOpt)]
struct Opt {
    #[structopt(short, long, group = &quot;verbosity&quot;)]
    verbose: bool,
    #[structopt(short, long, group = &quot;verbosity&quot;)]
    quiet: bool,
    #[structopt(short, long)]
    name: Option&lt;String&gt;,
}

fn main() {
    let opt = Opt::from_args();
    println!(&quot;{:?}&quot;, opt);
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:15</div>
            <div class="timeline-body"><p>Going to close this in favor of #2621</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-derive</span> added by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:58:32 UTC
    </footer>
</body>
</html>
