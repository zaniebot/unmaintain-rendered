<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>allow_missing_positional with allow_hyphen_values not working - clap-rs/clap #4649</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>allow_missing_positional with allow_hyphen_values not working</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/clap-rs/clap/issues/4649">#4649</a>
        opened by <a href="https://github.com/ismell">@ismell</a>
        on 2023-01-18 18:04
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/ismell">@ismell</a></div>
            <div class="timeline-body">Please complete the following tasks
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
Rust Version
<p>rustc 1.66.0 (69f9c33d7 2022-12-12)</p>
Clap Version
<p>4.0.29</p>
Minimal reproducible code
<pre><code>#[derive(Parser, Debug, PartialEq, Eq)]
#[command(allow_missing_positional = true)]
pub struct Args {
    /// Version number.
    /// If not specified the PVR variable is used.
    #[arg(allow_hyphen_values = true)]
    v1: Option&lt;String&gt;,

    /// -gt, -ge, -lt, -le, -eq, -ne
    #[arg(allow_hyphen_values = true)]
    op: String,

    /// Version number.
    v2: String,
}

#[test]
fn test_three_args() -&gt; Result&lt;()&gt; {  // &lt;-- This works
    let args = Args::try_parse_from(vec![&quot;prog&quot;, &quot;0.3&quot;, &quot;-gt&quot;, &quot;0.2&quot;])?;
    assert_eq!(
        args,
        Args {
            v1: Some(&quot;0.3&quot;.to_owned()),
            op: &quot;-gt&quot;.to_owned(),
            v2: &quot;0.2&quot;.to_owned(),
        }
    );

    Ok(())
}

#[test]
fn test_two_args() -&gt; Result&lt;()&gt; { // &lt;-- This fails
    let args = Args::try_parse_from(vec![&quot;prog&quot;, &quot;-gt&quot;, &quot;0.2&quot;])?;
    assert_eq!(
        args,
        Args {
            v1: None,
            op: &quot;-gt&quot;.to_owned(),
            v2: &quot;0.2&quot;.to_owned(),
        }
    );

    Ok(())
}

</code></pre>
Steps to reproduce the bug with the above code
<p>https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=1b582ab81b2884b8696d70789b6e9ed4</p>
Actual Behaviour
<pre><code>---- test_two_args stdout ----
Error: error: The following required arguments were not provided:
  &lt;OP&gt;

Usage: prog &lt;V1&gt; &lt;OP&gt; &lt;V2&gt;
</code></pre>
Expected Behaviour
<p>There should be no parsing error and the <code>v1</code> <code>Option</code> should be <code>None</code>.</p>
Additional Context
<p>The command I&#x27;m replicating is documented here: https://mgorny.pl/articles/the-ultimate-guide-to-eapi-7.html#version-comparison-ver-test</p>
Debug Output
<pre><code>
running 2 tests
test ver_test::tests::test_three_args ... [      clap::builder::command] 	Command::_do_parse
[      clap::builder::command] 	Command::_build: name=&quot;ver_test&quot;
[      clap::builder::command] 	Command::_propagate:ver_test
[      clap::builder::command] 	Command::_check_help_and_version:ver_test expand_help_tree=false
[      clap::builder::command] 	Command::long_help_exists
[      clap::builder::command] 	Command::_check_help_and_version: Building default --help
[      clap::builder::command] 	Command::_propagate_global_args:ver_test
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:v1
[clap::builder::debug_asserts] 	Arg::_debug_asserts:op
[clap::builder::debug_asserts] 	Arg::_debug_asserts:v2
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;0.3&quot;)&#x27; ([48, 46, 51])
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;0.3&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...1
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;-gt&quot;)&#x27; ([45, 103, 116])
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;-gt&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::parse_short_arg: short_arg=ShortFlags { inner: RawOsStr(&quot;gt&quot;), utf8_prefix: CharIndices { front_offset: 0, iter: Chars([&#x27;g&#x27;, &#x27;t&#x27;]) }, invalid_suffix: None }
[        clap::parser::parser] 	Parser::parse_short_args: positional at 2 allows hyphens
[        clap::parser::parser] 	Parser::get_matches_with: After parse_short_arg MaybeHyphenValue
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...2
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::is_new_arg: RawOsStr(&quot;0.2&quot;):op
[        clap::parser::parser] 	Parser::is_new_arg: Allow hyphen
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;0.2&quot;)
[        clap::parser::parser] 	Parser::resolve_pending: id=&quot;v1&quot;
[        clap::parser::parser] 	Parser::react action=Set, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=&quot;v1&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;v1&quot;, source=CommandLine
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v1&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;Args&quot;, source=CommandLine
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;0.3&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=1
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=v1, pending=0
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: expected=1, actual=0
[        clap::parser::parser] 	Parser::react not enough values passed in, leaving it to the validator to complain
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;0.2&quot;)&#x27; ([48, 46, 50])
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;0.2&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...3
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::resolve_pending: id=&quot;op&quot;
[        clap::parser::parser] 	Parser::react action=Set, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=&quot;op&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;op&quot;, source=CommandLine
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;op&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;Args&quot;, source=CommandLine
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;-gt&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=2
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=op, pending=0
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: expected=1, actual=0
[        clap::parser::parser] 	Parser::react not enough values passed in, leaving it to the validator to complain
[        clap::parser::parser] 	Parser::resolve_pending: id=&quot;v2&quot;
[        clap::parser::parser] 	Parser::react action=Set, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=&quot;v2&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;v2&quot;, source=CommandLine
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v2&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;Args&quot;, source=CommandLine
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;0.2&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=3
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=v2, pending=0
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: expected=1, actual=0
[        clap::parser::parser] 	Parser::react not enough values passed in, leaving it to the validator to complain
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:v1:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:v1: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:op:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:op: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:v2:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:v2: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[     clap::parser::validator] 	Validator::validate
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v1&quot;
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;v1&quot;, conflicts=[]
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;Args&quot;, conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;op&quot;
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;op&quot;, conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v2&quot;
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;v2&quot;, conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;v1&quot;
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;Args&quot;
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;op&quot;
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;v2&quot;
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=&quot;v1&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;v1&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=&quot;op&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;op&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=&quot;v2&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;v2&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([Child { id: &quot;op&quot;, children: [] }, Child { id: &quot;v2&quot;, children: [] }])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;v1&quot;
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;Args&quot;
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;Args&quot;:group
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;op&quot;
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;v2&quot;
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[   clap::parser::arg_matcher] 	ArgMatcher::get_global_values: global_arg_vec=[]
ok
test ver_test::tests::test_two_args ... [      clap::builder::command] 	Command::_do_parse
[      clap::builder::command] 	Command::_build: name=&quot;ver_test&quot;
[      clap::builder::command] 	Command::_propagate:ver_test
[      clap::builder::command] 	Command::_check_help_and_version:ver_test expand_help_tree=false
[      clap::builder::command] 	Command::long_help_exists
[      clap::builder::command] 	Command::_check_help_and_version: Building default --help
[      clap::builder::command] 	Command::_propagate_global_args:ver_test
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:v1
[clap::builder::debug_asserts] 	Arg::_debug_asserts:op
[clap::builder::debug_asserts] 	Arg::_debug_asserts:v2
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;-gt&quot;)&#x27; ([45, 103, 116])
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;-gt&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::parse_short_arg: short_arg=ShortFlags { inner: RawOsStr(&quot;gt&quot;), utf8_prefix: CharIndices { front_offset: 0, iter: Chars([&#x27;g&#x27;, &#x27;t&#x27;]) }, invalid_suffix: None }
[        clap::parser::parser] 	Parser::parse_short_args: positional at 1 allows hyphens
[        clap::parser::parser] 	Parser::get_matches_with: After parse_short_arg MaybeHyphenValue
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...1
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;0.2&quot;)&#x27; ([48, 46, 50])
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;0.2&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...2
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::get_matches_with: Bumping the positional counter...
[        clap::parser::parser] 	Parser::resolve_pending: id=&quot;v1&quot;
[        clap::parser::parser] 	Parser::react action=Set, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=&quot;v1&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;v1&quot;, source=CommandLine
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v1&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;Args&quot;, source=CommandLine
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;-gt&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=1
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=v1, pending=0
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: expected=1, actual=0
[        clap::parser::parser] 	Parser::react not enough values passed in, leaving it to the validator to complain
[        clap::parser::parser] 	Parser::resolve_pending: id=&quot;v2&quot;
[        clap::parser::parser] 	Parser::react action=Set, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=&quot;v2&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;v2&quot;, source=CommandLine
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v2&quot;
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;Args&quot;, source=CommandLine
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;0.2&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=2
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=v2, pending=0
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: expected=1, actual=0
[        clap::parser::parser] 	Parser::react not enough values passed in, leaving it to the validator to complain
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:v1:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:v1: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:op:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:op: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:v2:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:v2: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[     clap::parser::validator] 	Validator::validate
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v1&quot;
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;v1&quot;, conflicts=[]
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;Args&quot;, conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;v2&quot;
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;v2&quot;, conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;v1&quot;
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;Args&quot;
[     clap::parser::validator] 	Validator::validate_exclusive:iter:&quot;v2&quot;
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=&quot;v1&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;v1&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=&quot;v2&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;v2&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([Child { id: &quot;op&quot;, children: [] }, Child { id: &quot;v2&quot;, children: [] }])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;v1&quot;
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;Args&quot;
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;Args&quot;:group
[     clap::parser::validator] 	Validator::gather_requires:iter:&quot;v2&quot;
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[     clap::parser::validator] 	Validator::validate_required:iter:aog=&quot;op&quot;
[     clap::parser::validator] 	Validator::validate_required:iter: This is an arg
[     clap::parser::validator] 	Validator::is_missing_required_ok: op
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;op&quot;
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;op&quot;
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=&quot;op&quot;, conflicts=[]
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=&quot;op&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=&quot;Args&quot;
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_required:iter: Missing &quot;op&quot;
[     clap::parser::validator] 	Validator::missing_required_error; incl=[&quot;op&quot;]
[     clap::parser::validator] 	Validator::missing_required_error: reqs=ChildGraph([Child { id: &quot;op&quot;, children: [] }, Child { id: &quot;v2&quot;, children: [] }])
[         clap::output::usage] 	Usage::get_required_usage_from: incls=[&quot;op&quot;], matcher=true, incl_last=true
[         clap::output::usage] 	Usage::get_required_usage_from: unrolled_reqs=[&quot;op&quot;, &quot;v2&quot;]
[         clap::output::usage] 	Usage::get_required_usage_from:iter:&quot;op&quot; arg is_present=false
[         clap::output::usage] 	Usage::get_required_usage_from:iter:&quot;v2&quot; arg is_present=true
[         clap::output::usage] 	Usage::get_required_usage_from:iter:&quot;op&quot; arg is_present=false
[         clap::output::usage] 	Usage::get_required_usage_from: ret_val=[StyledStr { pieces: [(Some(Placeholder), &quot;&lt;OP&gt;&quot;)] }]
[     clap::parser::validator] 	Validator::missing_required_error: req_args=[
    &quot;&lt;OP&gt;&quot;,
]
[         clap::output::usage] 	Usage::create_usage_with_title
[         clap::output::usage] 	Usage::create_usage_no_title
[         clap::output::usage] 	Usage::create_smart_usage
[         clap::output::usage] 	Usage::get_args: incls=[&quot;v1&quot;, &quot;v2&quot;, &quot;op&quot;]
[         clap::output::usage] 	Usage::get_args: unrolled_reqs=[&quot;op&quot;, &quot;v2&quot;]
[         clap::output::usage] 	Usage::get_args: ret_val=[StyledStr { pieces: [(Some(Placeholder), &quot;&lt;V1&gt;&quot;)] }, StyledStr { pieces: [(Some(Placeholder), &quot;&lt;OP&gt;&quot;)] }, StyledStr { pieces: [(Some(Placeholder), &quot;&lt;V2&gt;&quot;)] }]
[      clap::builder::command] 	Command::color: Color setting...
[      clap::builder::command] 	Auto
[      clap::builder::command] 	Command::color: Color setting...
[      clap::builder::command] 	Auto
FAILED

failures:

---- ver_test::tests::test_two_args stdout ----
Error: error: The following required arguments were not provided:
  &lt;OP&gt;

Usage: prog &lt;V1&gt; &lt;OP&gt; &lt;V2&gt;

For more information try &#x27;--help&#x27;

Backtrace:
   0: clap::error::Backtrace::new
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/error/mod.rs:839:19
   1: clap::error::Error&lt;F&gt;::new
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/error/mod.rs:135:28
   2: clap::error::Error&lt;F&gt;::missing_required_argument
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/error/mod.rs:488:23
   3: clap::parser::validator::Validator::missing_required_error
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/parser/validator.rs:454:13
   4: clap::parser::validator::Validator::validate_required
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/parser/validator.rs:366:17
   5: clap::parser::validator::Validator::validate
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/parser/validator.rs:85:17
   6: clap::parser::parser::Parser::get_matches_with
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/parser/parser.rs:481:9
   7: clap::builder::command::Command::_do_parse
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/builder/command.rs:3796:29
   8: clap::builder::command::Command::try_get_matches_from_mut
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/builder/command.rs:708:9
   9: clap::builder::command::Command::try_get_matches_from
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/builder/command.rs:624:9
  10: clap::derive::Parser::try_parse_from
             at /home/rrangel/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-4.0.32/src/derive.rs:126:31
  11: alchemist::ver_test::tests::test_two_args
             at src/bin/alchemist/ver_test.rs:79:20
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by <a href="https://github.com/ismell">@ismell</a> on 2023-01-18 18:04</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-01-18 19:10</div>
            <div class="timeline-body"><p>As a heads up, the reproduction case for ths is a lot simpler; <code>allow_hyphen_values</code> is not needed:</p>
<pre><code>#!/usr/bin/env -S rust-script

//! ```cargo
//! [dependencies]
//! clap = { path = &quot;../clap&quot;, features = [&quot;derive&quot;] }
//! ```

use clap::Parser;

#[derive(Parser, Debug, PartialEq, Eq)]
#[command(allow_missing_positional = true)]
pub struct Args {
    /// Version number.
    /// If not specified the PVR variable is used.
    v1: Option&lt;String&gt;,

    /// -gt, -ge, -lt, -le, -eq, -ne
    op: String,

    /// Version number.
    v2: String,
}

fn main() {
    let args = Args::parse();
    println!(&quot;{:?}&quot;, args);
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-01-18 19:13</div>
            <div class="timeline-body"><p><code>allow_missing_positional</code> is fairly limited without using <code>--</code>: it only allows the second-to-last positional to be skipped, causing <code>op</code> to be skipped.  Since <code>op</code> is required, we then error when we get to the required checks.</p>
<p>I would likely implement this as</p>
<pre><code>pub struct Args {
    #[arg(allow_hyphen_values = true, required = true, num_args=2..=3)]
    args: Vec&lt;String&gt;,
}
</code></pre>
<p>and then extract the arguments as needed</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ismell">@ismell</a> on 2023-01-19 00:13</div>
            <div class="timeline-body"><p>That&#x27;s what I ended up using after trying to get clap to parse the args correctly. It&#x27;s not a blocker for me, but a nice to have :)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-01-19 02:50</div>
            <div class="timeline-body"><p>The challenge is getting all of the semantics right as you can&#x27;t interpret an argument context-free but instead need to process all previous arguments to know what the next one will look like.</p>
<p>This can be faked with the second to last argument because we can peek at the next and make a guess as to whether it is a positional or not.  If its not, we assume we need to skip the second to last.  To get an idea of how complex this is, <a href="https://github.com/clap-rs/clap/blob/master/src/parser/parser.rs#L311,L368">see our code for skipping</a>.  This does include one other case (<code>low_index_mults</code>) but that isn&#x27;t a major part of the code.</p>
<p>Even still, I can think of cases that break this, like if you had a positional followed by  flag and then a positional.</p>
<p>Similarly, we could make this also consider <code>required = true</code> but that would exclude support for global requireds that require holistic knowledge to support or that a conflict can disable a <code>required = true</code>.666</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> removed by <a href="https://github.com/epage">@epage</a> on 2023-01-31 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by <a href="https://github.com/epage">@epage</a> on 2023-01-31 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-parsing</span> added by <a href="https://github.com/epage">@epage</a> on 2023-01-31 22:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-design</span> added by <a href="https://github.com/epage">@epage</a> on 2023-01-31 22:09</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:59:36 UTC
    </footer>
</body>
</html>
