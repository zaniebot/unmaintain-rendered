<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Handle parsing vector of custom structures - clap-rs/clap #1704</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Handle parsing vector of custom structures</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/1704">#1704</a>
        opened by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a>
        on 2020-02-22 19:26
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-22 19:26</div>
            <div class="timeline-body"><h3>What are you trying to do?</h3>
<p>I have group of options which could be used multiple times. All such groups should be kept without overwriting previous one.</p>
<pre><code class="language-bash">$ prometheus_sensors_exporter \
    \
    `# 2 physical sensors located on physycial different i2c bus or address` \
    --sensor \
        --sensor-device=tmp102 \
        --sensor-name=&quot;temperature_tmp102_outdoor&quot; \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=0x48 \
    --sensor \
        --sensor-device=tmp102 \
        --sensor-name=&quot;temperature_tmp102_indoor&quot; \
        --sensor-i2c-bus=1 \
        --sensor-i2c-address=0x49 \
</code></pre>
<p><code>--sensor</code> specifies instance of new group. Then suboptions are only for current group.</p>
<p>Ideally parsing would generate instance of Vector&lt;Sensor&gt; defined something like</p>
<pre><code class="language-rust">pub enum Device {
    Tmp102,
    Si7021,
}

pub struct Sensor {
    sensor_device: Device,
    sensor_name: String,
    sensor_i2c_bus: Option&lt;usize&gt;,
    sensor_i2c_address: Option&lt;u8&gt;,
}
</code></pre>
<p>Could it be possible?</p>
<p>Or maybe would you recommend to model it in some another way which could be easier to implement?</p>
<h3>What have you tried already?</h3>
<p>I tired few examples, but I didn't find anything similar so far.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> added by @krystian-wojtas on 2020-02-22 19:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-23 23:22</div>
            <div class="timeline-body"><p>I tried some prove of concept. Actually it is implemented with structopt, not clap. Just to give some idea.</p>
<p>I found that structopt has method <code>from_iter</code> which I can use instead of <code>from_args</code>. Then I can provide some subgroup of all parameters and invoke it few times as many sensors are defined by provided user command line parameters.</p>
<p>To split all parameters in such subgroups I used <code>Vector::split</code> function with custom delimiter <code>--sensor</code>.</p>
<h3>Code</h3>
<p>Here is implementation with only 2 such sensor parameters</p>
<pre><code class="language-rust">// Standard modules paths
use std::env;
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
#[structopt()]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[structopt(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[structopt(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

}


#[derive(StructOpt, Debug)]
#[structopt()]
pub struct OptSensor {

    /// Number in decimal
    #[structopt(long, default_value = &quot;1&quot;)]
    sensor_i2c_bus: usize,

    /// Number in hexadecimal
    #[structopt(long)]
    sensor_i2c_address: Option&lt;u8&gt;,

}


#[derive(Debug)]
pub struct Config {
    generic: OptGeneric,
    sensors: Vec&lt;OptSensor&gt;,
}

impl Config {

    pub fn parse(args: std::env::Args) -&gt; Config {

        // Split command line arguments into groups separated by '--sensor' delimiter
        let arguments: Vec&lt;String&gt; = args.collect();
        let mut sensor_parameters_groups = arguments.split(|argument| argument == &quot;--sensor&quot;);

         // First group of parameters is generic without any information for specific sensor
         let generic_parameters = sensor_parameters_groups.next()
             .unwrap();

         // Parse generic parameters
         let generic = OptGeneric::from_iter(generic_parameters);

         // Create vector for sensors to be parsed
         let mut sensors = Vec::new();

         // Iterate over rest of groups each containing complete sensor information
         for sensor_parameters in sensor_parameters_groups {

             // OptSensor::from_iter is going to skip first item, so it have to be put anything to be skipped
             // TODO maybe StructOpt::from_iter should not skip first item to not have to workaround it?
             let array_with_empty_item = [String::from(&quot;&quot;)];
             let iter_with_extra_first_item = array_with_empty_item.iter().chain(sensor_parameters);

             // Parse each sensor information
             let sensor = OptSensor::from_iter(iter_with_extra_first_item);

             // Fill sensors vector
             sensors.push(sensor);
         }

        // Return result
        Config{generic, sensors}
    }

}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = Config::parse(env::args());

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}

</code></pre>
<h3>Run</h3>
<p>Invocations are like that:</p>
<ul>
<li>without any arguments</li>
</ul>
<pre><code class="language-bash">% cargo run --
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter`
Config {
    generic: OptGeneric {
        socket_interface: &quot;0.0.0.0&quot;,
        socket_port: 9898,
    },
    sensors: [],
}
</code></pre>
<ul>
<li>some sensors</li>
</ul>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    `# 3 physical sensors located on physycial different i2c bus or address` \
    --sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    --sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=2 \
    --sensor \
        --sensor-i2c-bus=1 \
        --sensor-i2c-address=1 \
&gt;
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 --sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 --sensor --sensor-i2c-bus=0 --sensor-i2c-address=2 --sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
Config {
    generic: OptGeneric {
        socket_interface: &quot;1.1.1.1&quot;,
        socket_port: 10000,
    },
    sensors: [
        OptSensor {
            sensor_i2c_bus: 0,
            sensor_i2c_address: Some(
                1,
            ),
        },
        OptSensor {
            sensor_i2c_bus: 0,
            sensor_i2c_address: Some(
                2,
            ),
        },
        OptSensor {
            sensor_i2c_bus: 1,
            sensor_i2c_address: Some(
                1,
            ),
        },
    ],
}
</code></pre>
<ul>
<li>help message</li>
</ul>
<pre><code class="language-bash">% cargo run -- --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --help`
prometheus_sensors_exporter 0.1.2

USAGE:
    prometheus_sensors_exporter [OPTIONS]

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --socket-interface &lt;socket-interface&gt;    Address of interface to bind [default: 0.0.0.0]
        --socket-port &lt;socket-port&gt;              Number in decimal [default: 9898]
</code></pre>
<h3>Questions</h3>
<ul>
<li>Is it some valid approach?</li>
<li>Could clap be used to implement something similar?</li>
<li>How to include sensors parameters into help message?</li>
<li>There is some workaround in <code>array_with_empty_item</code>. Library is going to skip first element, so I have to provide anything to be skipped. Does clap also requires such workaround?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 20:45</div>
            <div class="timeline-body"><p>I have some another tries</p>
<h3>subcommand enum</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[structopt(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[structopt(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[structopt(subcommand)]
    sensor: OptSensor
}

#[derive(StructOpt, Debug)]
pub enum OptSensor {

    Sensor {
        /// Number in decimal
        #[structopt(long, default_value = &quot;1&quot;)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[structopt(long)]
        sensor_i2c_address: Option&lt;u8&gt;,
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::from_args();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run with one sensor</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \


    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1`
OptGeneric {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensor: Sensor {
        sensor_i2c_bus: 0,
        sensor_i2c_address: Some(
            1,
        ),
    },
}
</code></pre>
<p>Run with 2 sensors</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    sensor \
      --sensor-i2c-bus=1 \
      --sensor-i2c-address=1 \
&gt;
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
error: Found argument 'sensor' which wasn't expected, or isn't valid in this context

USAGE:
    prometheus_sensors_exporter sensor --sensor-i2c-address &lt;sensor-i2c-address&gt; --sensor-i2c-bus &lt;sensor-i2c-bus&gt;

For more information try --help
</code></pre>
<h3>subcommand vec enum</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use structopt::StructOpt;

#[derive(StructOpt, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[structopt(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[structopt(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[structopt(subcommand)]
    sensors: Vec&lt;OptSensor&gt;
}

#[derive(StructOpt, Debug)]
pub enum OptSensor {

    Sensor {
        /// Number in decimal
        #[structopt(long, default_value = &quot;1&quot;)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[structopt(long)]
        sensor_i2c_address: Option&lt;u8&gt;,
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::from_args();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Cannot compile</p>
<pre><code class="language-bash">% cargo build
   Compiling prometheus_sensors_exporter v0.1.2 (/home/k/project/prometheus_sensors_exporter)
error[E0277]: the trait bound `std::vec::Vec&lt;OptSensor&gt;: structopt::StructOptInternal` is not satisfied
  --&gt; src/main.rs:17:17
   |
17 |     #[structopt(subcommand)]
   |                 ^^^^^^^^^^ the trait `structopt::StructOptInternal` is not implemented for `std::vec::Vec&lt;OptSensor&gt;`
   |
   = note: required by `structopt::StructOptInternal::from_subcommand`

error[E0277]: the trait bound `std::vec::Vec&lt;OptSensor&gt;: structopt::StructOptInternal` is not satisfied
 --&gt; src/main.rs:4:10
  |
4 | #[derive(StructOpt, Debug)]
  |          ^^^^^^^^^ the trait `structopt::StructOptInternal` is not implemented for `std::vec::Vec&lt;OptSensor&gt;`
  |
  = note: required by `structopt::StructOptInternal::augment_clap`

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0277`.
error: could not compile `prometheus_sensors_exporter`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Should I implement StructOptInternal trait? Is it something recommended in this case?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-02-24 20:45</div>
            <div class="timeline-body"><p>Can you try with the master branch of clap? We have <code>clap_derive</code></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 20:58</div>
            <div class="timeline-body"><p>@pksunkara, sure I would try it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 21:12</div>
            <div class="timeline-body"><p>Using master clap</p>
<h3>subcommand enum</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(subcommand)]
    sensor: OptSensor
}

#[derive(Clap, Debug)]
pub enum OptSensor {

    Sensor {
        /// Number in decimal
        #[clap(long, default_value = &quot;1&quot;)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[clap(long)]
        sensor_i2c_address: Option&lt;u8&gt;,
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::parse();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run with one sensor is ok</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \

   Compiling prometheus_sensors_exporter v0.1.2 (/home/k/project/prometheus_sensors_exporter)
    Finished dev [unoptimized + debuginfo] target(s) in 0.52s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1`
OptGeneric {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensor: Sensor {
        sensor_i2c_bus: 0,
        sensor_i2c_address: Some(
            1,
        ),
    },
}
</code></pre>
<p>Run with 2 sensors is not allowed</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    sensor \
      --sensor-i2c-bus=1 \
      --sensor-i2c-address=1 \

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
error: Found argument 'sensor' which wasn't expected, or isn't valid in this context
If you tried to supply `sensor` as a PATTERN use `-- sensor`

USAGE:
    prometheus_sensors_exporter sensor [OPTIONS]

For more information try --help
</code></pre>
<h3>subcommand vec enum</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(subcommand)]
    sensors: Vec&lt;OptSensor&gt;
}

#[derive(Clap, Debug)]
pub enum OptSensor {

    Sensor {
        /// Number in decimal
        #[clap(long, default_value = &quot;1&quot;)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[clap(long)]
        sensor_i2c_address: Option&lt;u8&gt;,
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::parse();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Cannot compile. Error message is much better than structopt</p>
<pre><code class="language-bash">[Running 'cargo check']
    Checking prometheus_sensors_exporter v0.1.2 (/home/k/project/prometheus_sensors_exporter)
error[E0277]: the trait bound `std::vec::Vec&lt;OptSensor&gt;: clap::derive::Subcommand` is not satisfied
 --&gt; src/main.rs:4:10
  |
4 | #[derive(Clap, Debug)]
  |          ^^^^ the trait `clap::derive::Subcommand` is not implemented for `std::vec::Vec&lt;OptSensor&gt;`
  |
  = note: required by `clap::derive::Subcommand::augment_subcommands`

error[E0277]: the trait bound `std::vec::Vec&lt;OptSensor&gt;: clap::derive::Subcommand` is not satisfied
  --&gt; src/main.rs:17:12
   |
17 |     #[clap(subcommand)]
   |            ^^^^^^^^^^ the trait `clap::derive::Subcommand` is not implemented for `std::vec::Vec&lt;OptSensor&gt;`
   |
   = note: required by `clap::derive::Subcommand::from_subcommand`

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0277`.
error: could not compile `prometheus_sensors_exporter`.

To learn more, run the command again with --verbose.
[Finished running. Exit status: 101]
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 21:27</div>
            <div class="timeline-body"><p>Clap has</p>
<blockquote>
<p>Support their own sub-arguments, and sub-sub-commands independent of the parent</p>
</blockquote>
<p>Maybe this is some solution? Could it be sub-sub-sub-...-commands also? Could it be wrapped into Option (with Box?) to brake infinite recursion?</p>
<p>This try is interesting as it compiles ok, but overflow stack in runtime</p>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(subcommand)]
    sensors: OptSensor
}

#[derive(Clap, Debug)]
pub enum OptSensor {

    Sensor {
        /// Number in decimal
        #[clap(long, default_value = &quot;1&quot;)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[clap(long)]
        sensor_i2c_address: Option&lt;u8&gt;,

        #[clap(subcommand)]
        sensors: Option&lt;Box&lt;OptSensor&gt;&gt;
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::parse();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \


   Compiling prometheus_sensors_exporter v0.1.2 (/home/k/project/prometheus_sensors_exporter)
    Finished dev [unoptimized + debuginfo] target(s) in 0.62s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1`

thread 'main' has overflowed its stack
fatal runtime error: stack overflow
[1]    9558 abort (core dumped)  cargo run -- `# generic configuration` --socket-interface=1.1.1.1  sensor
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 21:28</div>
            <div class="timeline-body"><p>I see that there is some proper example of subcommands on some nested levels
https://github.com/clap-rs/clap/blob/master/examples/20_subcommands.rs</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 22:07</div>
            <div class="timeline-body"><p>I see that example from documentation have specified tree of subcommands known ahead at compile time.</p>
<p>Here is some another attempt</p>
<h3>not multiple</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(subcommand)]
    sensor: OptSensor,
}

#[derive(Clap, Debug)]
pub enum OptSensor {

    Sensor {

        /// Number in decimal
        #[clap(long, default_value = &quot;1&quot;)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[clap(long)]
        sensor_i2c_address: Option&lt;u8&gt;,

        #[clap()]
        more_optional_sensors: Vec&lt;String&gt;,
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::parse();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run help</p>
<pre><code class="language-bash">% cargo run -- help
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter help`
prometheus_sensors_exporter

USAGE:
    prometheus_sensors_exporter [OPTIONS] &lt;SUBCOMMAND&gt;

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --socket-interface &lt;socket-interface&gt;    Address of interface to bind [default: 0.0.0.0]
        --socket-port &lt;socket-port&gt;              Number in decimal [default: 9898]

SUBCOMMANDS:
    help      Prints this message or the help of the given subcommand(s)
    sensor
</code></pre>
<p>Run help for subcommand</p>
<pre><code class="language-bash">% cargo run -- help sensor
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter help sensor`
prometheus_sensors_exporter-sensor

USAGE:
    prometheus_sensors_exporter sensor [OPTIONS] [more-optional-sensors]...

ARGS:
    &lt;more-optional-sensors&gt;...

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --sensor-i2c-address &lt;sensor-i2c-address&gt;    Number in hexadecimal
        --sensor-i2c-bus &lt;sensor-i2c-bus&gt;            Number in decimal [default: 1]
</code></pre>
<p>Run with one sensor</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
&gt;
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1`
OptGeneric {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensor: Sensor {
        sensor_i2c_bus: 0,
        sensor_i2c_address: Some(
            1,
        ),
        more_optional_sensors: [],
    },
}
</code></pre>
<p>Run with 2 sensors</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    \
    sensor \
        --sensor-i2c-bus=1 \
        --sensor-i2c-address=1 \
&gt;
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
error: The argument '--sensor-i2c-bus &lt;sensor-i2c-bus&gt;' was provided more than once, but cannot be used multiple times

USAGE:
    prometheus_sensors_exporter sensor [OPTIONS] [more-optional-sensors]...

For more information try --help
</code></pre>
<h3>multiple</h3>
<pre><code class="language-rust">// Standard modules paths
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptGeneric {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(subcommand)]
    sensor: OptSensor,
}

#[derive(Clap, Debug)]
pub enum OptSensor {

    Sensor {

        /// Number in decimal
        #[clap(long, default_value = &quot;1&quot;, multiple = true)]
        sensor_i2c_bus: usize,

        /// Number in hexadecimal
        #[clap(long, multiple = true)]
        sensor_i2c_address: Option&lt;u8&gt;,

        #[clap()]
        more_optional_sensors: Vec&lt;String&gt;,
    }
}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = OptGeneric::parse();

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run with 2 sensors</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    \
    sensor \
        --sensor-i2c-bus=1 \
        --sensor-i2c-address=1 \

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
OptGeneric {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensor: Sensor {
        sensor_i2c_bus: 0,
        sensor_i2c_address: Some(
            1,
        ),
        more_optional_sensors: [
            &quot;sensor&quot;,
        ],
    },
}
</code></pre>
<p>Parsing consumes all parameters overwriting previous ones and they are not available in more_optional_sensors strings vector.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-24 23:14</div>
            <div class="timeline-body"><p>Here is best result I have so far</p>
<h3>structopt</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use std::env;
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptBasic {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(flatten)]
    sensor: OptSensor,

    // Field is declared only for help message
    // Vector is never filled
    /// Each sensor definition should start with &lt;sensor&gt; keyword followed by its options
    #[clap()]
    more_optional_sensors: Vec&lt;String&gt;,
}


#[derive(Clap, Debug)]
pub struct OptSensor {

    /// Number in decimal
    #[clap(long, default_value = &quot;1&quot;)]
    sensor_i2c_bus: usize,

    /// Number in hexadecimal
    #[clap(long)]
    sensor_i2c_address: Option&lt;u8&gt;,
}


#[derive(Debug)]
pub struct Config {

    // Address of interface to bind
    socket_interface: String,

    // Number in decimal
    socket_port: u16,

    // All sensors
    sensors: Vec&lt;OptSensor&gt;,
}

impl Config {

    pub fn parse(args: std::env::Args) -&gt; Self {

        // Split command line arguments into groups separated by '--sensor' delimiter
        let arguments: Vec&lt;String&gt; = args.collect();
        let mut sensor_parameters_groups = arguments.split(|argument| argument == &quot;sensor&quot;);

         // First group of parameters is basic without any information for specific sensor
         let basic_parameters = sensor_parameters_groups.next()
             .unwrap();

         // Parse basic parameters
         let basic = OptBasic::from_iter(basic_parameters);

         // Create vector to be filled with all parsed sensors
         let mut sensors = Vec::new();

         // Add already parsed basic sensor to list of all sensors
         sensors.push(basic.sensor);

         // Iterate over rest of groups each containing complete sensor information
         for sensor_parameters in sensor_parameters_groups {

             // OptSensor::from_iter is going to skip first item, so it have to be put anything to be skipped
             // TODO maybe StructOpt::from_iter should not skip first item to not have to workaround it?
             let array_with_empty_item = [String::from(&quot;&quot;)];
             let iter_with_extra_first_item = array_with_empty_item.iter().chain(sensor_parameters);

             // Parse each sensor information
             let sensor = OptSensor::from_iter(iter_with_extra_first_item);

             // Fill sensors vector
             sensors.push(sensor);
         }

        // Return result
        Config {
            socket_interface: basic.socket_interface,
            socket_port: basic.socket_port,
            sensors,
        }
    }

}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = Config::parse(env::args());

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run help</p>
<pre><code class="language-bash">% cargo run -- --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --help`
prometheus_sensors_exporter 0.1.2

USAGE:
    prometheus_sensors_exporter [OPTIONS] [more-optional-sensors]...

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --sensor-i2c-address &lt;sensor-i2c-address&gt;    Number in hexadecimal
        --sensor-i2c-bus &lt;sensor-i2c-bus&gt;            Number in decimal [default: 1]
        --socket-interface &lt;socket-interface&gt;        Address of interface to bind [default: 0.0.0.0]
        --socket-port &lt;socket-port&gt;                  Number in decimal [default: 9898]

ARGS:
    &lt;more-optional-sensors&gt;...    Each sensor definition should start with &lt;sensor&gt; keyword followed by its options
</code></pre>
<p>Run with one sensor</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    `# Basic sensor` \
    --sensor-i2c-bus=4 \

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 --sensor-i2c-bus=4`
Config {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensors: [
        OptSensor {
            sensor_i2c_bus: 4,
            sensor_i2c_address: None,
        },
    ],
}
</code></pre>
<p>Run with 3 sensors</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    `# Basic sensor` \
    --sensor-i2c-bus=4 \
    \
    `# More optional sensors` \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    \
    sensor \
        --sensor-i2c-bus=1 \
        --sensor-i2c-address=1 \

    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 --sensor-i2c-bus=4 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
Config {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensors: [
        OptSensor {
            sensor_i2c_bus: 4,
            sensor_i2c_address: None,
        },
        OptSensor {
            sensor_i2c_bus: 0,
            sensor_i2c_address: Some(
                1,
            ),
        },
        OptSensor {
            sensor_i2c_bus: 1,
            sensor_i2c_address: Some(
                1,
            ),
        },
    ],
}
</code></pre>
<h3>clap</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use std::env;
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptBasic {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(flatten)]
    sensor: OptSensor,

    // Field is declared only for help message
    // Vector is never filled
    /// Each sensor definition should start with &lt;sensor&gt; keyword followed by its options
    #[clap()]
    more_optional_sensors: Vec&lt;String&gt;,
}


#[derive(Clap, Debug)]
pub struct OptSensor {

    /// Number in decimal
    #[clap(long, default_value = &quot;1&quot;)]
    sensor_i2c_bus: usize,

    /// Number in hexadecimal
    #[clap(long)]
    sensor_i2c_address: Option&lt;u8&gt;,
}


#[derive(Debug)]
pub struct Config {

    // Address of interface to bind
    socket_interface: String,

    // Number in decimal
    socket_port: u16,

    // All sensors
    sensors: Vec&lt;OptSensor&gt;,
}

impl Config {

    pub fn parse(args: std::env::Args) -&gt; Self {

        // Split command line arguments into groups separated by '--sensor' delimiter
        let arguments: Vec&lt;String&gt; = args.collect();
        let mut sensor_parameters_groups = arguments.split(|argument| argument == &quot;sensor&quot;);

         // First group of parameters is basic without any information for specific sensor
         let basic_parameters = sensor_parameters_groups.next()
             .unwrap();

         // Parse basic parameters
         let basic = OptBasic::from_iter(basic_parameters);

         // Create vector to be filled with all parsed sensors
         let mut sensors = Vec::new();

         // Add already parsed basic sensor to list of all sensors
         sensors.push(basic.sensor);

         // Iterate over rest of groups each containing complete sensor information
         for sensor_parameters in sensor_parameters_groups {

             // OptSensor::from_iter is going to skip first item, so it have to be put anything to be skipped
             // TODO maybe StructOpt::from_iter should not skip first item to not have to workaround it?
             let array_with_empty_item = [String::from(&quot;&quot;)];
             let iter_with_extra_first_item = array_with_empty_item.iter().chain(sensor_parameters);

             // Parse each sensor information
             let sensor = OptSensor::from_iter(iter_with_extra_first_item);

             // Fill sensors vector
             sensors.push(sensor);
         }

        // Return result
        Config {
            socket_interface: basic.socket_interface,
            socket_port: basic.socket_port,
            sensors,
        }
    }

}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = Config::parse(env::args());

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Cannot compile</p>
<pre><code class="language-bash">[Running 'cargo check']
    Checking prometheus_sensors_exporter v0.1.2 (/home/k/project/prometheus_sensors_exporter)
error[E0599]: no function or associated item named `from_iter` found for type `OptBasic` in the current scope
  --&gt; src/main.rs:68:32
   |
6  | pub struct OptBasic {
   | ------------------- function or associated item `from_iter` not found for this
...
68 |          let basic = OptBasic::from_iter(basic_parameters);
   |                                ^^^^^^^^^ function or associated item not found in `OptBasic`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `from_iter`, perhaps you need to implement it:
           candidate #1: `std::iter::FromIterator`

error[E0599]: no function or associated item named `from_iter` found for type `OptSensor` in the current scope
  --&gt; src/main.rs:85:38
   |
30 | pub struct OptSensor {
   | -------------------- function or associated item `from_iter` not found for this
...
85 |              let sensor = OptSensor::from_iter(iter_with_extra_first_item);
   |                                      ^^^^^^^^^ function or associated item not found in `OptSensor`
   |
   = help: items from traits can only be used if the trait is implemented and in scope
   = note: the following trait defines an item `from_iter`, perhaps you need to implement it:
           candidate #1: `std::iter::FromIterator`

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0599`.
error: could not compile `prometheus_sensors_exporter`.

To learn more, run the command again with --verbose.
[Finished running. Exit status: 101]
</code></pre>
<p>Is there any similar method to pass custom iterator for clap parser?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-25 20:22</div>
            <div class="timeline-body"><p><code>structopt::from_iter</code> is called <code>clap::parse_from</code>.</p>
<p>Here is same thing as previous implemented with clap.</p>
<h3>clap</h3>
<p>Code</p>
<pre><code class="language-rust">// Standard modules paths
use std::env;
use clap::Clap;

#[derive(Clap, Debug)]
pub struct OptBasic {

    // Socket

    /// Address of interface to bind
    #[clap(long, default_value = &quot;0.0.0.0&quot;)]
    socket_interface: String,

    /// Number in decimal
    #[clap(long, default_value = &quot;9898&quot;)]
    socket_port: u16,

    #[clap(flatten)]
    sensor: OptSensor,

    // Field is declared only for help message
    // Vector is never filled
    /// Each sensor definition should start with &lt;sensor&gt; keyword followed by its options
    #[clap()]
    more_optional_sensors: Vec&lt;String&gt;,
}


#[derive(Clap, Debug)]
pub struct OptSensor {

    /// Number in decimal
    #[clap(long, default_value = &quot;1&quot;)]
    sensor_i2c_bus: usize,

    /// Number in hexadecimal
    #[clap(long)]
    sensor_i2c_address: Option&lt;u8&gt;,
}


#[derive(Debug)]
pub struct Config {

    // Address of interface to bind
    socket_interface: String,

    // Number in decimal
    socket_port: u16,

    // All sensors
    sensors: Vec&lt;OptSensor&gt;,
}

impl Config {

    pub fn parse(args: std::env::Args) -&gt; Self {

        // Split command line arguments into groups separated by '--sensor' delimiter
        let arguments: Vec&lt;String&gt; = args.collect();
        let mut sensor_parameters_groups = arguments.split(|argument| argument == &quot;sensor&quot;);

         // First group of parameters is basic without any information for specific sensor
         let basic_parameters = sensor_parameters_groups.next()
             .unwrap();

         // Parse basic parameters
         let basic = OptBasic::parse_from(basic_parameters);

         // Create vector to be filled with all parsed sensors
         let mut sensors = Vec::new();

         // Add already parsed basic sensor to list of all sensors
         sensors.push(basic.sensor);

         // Iterate over rest of groups each containing complete sensor information
         for sensor_parameters in sensor_parameters_groups {

             // Parse each sensor information
             let sensor = OptSensor::parse_from(sensor_parameters);

             // Fill sensors vector
             sensors.push(sensor);
         }

        // Return result
        Config {
            socket_interface: basic.socket_interface,
            socket_port: basic.socket_port,
            sensors,
        }
    }

}


fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {

    // Parse configuration
    let config = Config::parse(env::args());

    // Debug purpose only
    println!(&quot;{:#?}&quot;, config);

    // Return success
    Ok(())
}
</code></pre>
<p>Run with some sensors</p>
<pre><code class="language-bash">% cargo run -- \
    \
    `# generic configuration` \
    --socket-interface=1.1.1.1 \
    --socket-port=10000 \
    \
    `# Basic sensor` \
    --sensor-i2c-bus=4 \
    \
    `# More optional sensors` \
    sensor \
        --sensor-i2c-bus=0 \
        --sensor-i2c-address=1 \
    \
    sensor \
        --sensor-i2c-bus=1 \
        --sensor-i2c-address=1 \

   Compiling prometheus_sensors_exporter v0.1.2 (/home/k/project/prometheus_sensors_exporter)
    Finished dev [unoptimized + debuginfo] target(s) in 0.65s
     Running `target/debug/prometheus_sensors_exporter --socket-interface=1.1.1.1 --socket-port=10000 --sensor-i2c-bus=4 sensor --sensor-i2c-bus=0 --sensor-i2c-address=1 sensor --sensor-i2c-bus=1 --sensor-i2c-address=1`
Config {
    socket_interface: &quot;1.1.1.1&quot;,
    socket_port: 10000,
    sensors: [
        OptSensor {
            sensor_i2c_bus: 4,
            sensor_i2c_address: None,
        },
        OptSensor {
            sensor_i2c_bus: 1,
            sensor_i2c_address: Some(
                1,
            ),
        },
        OptSensor {
            sensor_i2c_bus: 1,
            sensor_i2c_address: Some(
                1,
            ),
        },
    ],
}
</code></pre>
<p>Help</p>
<pre><code class="language-bash">% cargo run -- --help
    Finished dev [unoptimized + debuginfo] target(s) in 0.04s
     Running `target/debug/prometheus_sensors_exporter --help`
prometheus_sensors_exporter

USAGE:
    prometheus_sensors_exporter [OPTIONS] [more-optional-sensors]...

ARGS:
    &lt;more-optional-sensors&gt;...    Each sensor definition should start with &lt;sensor&gt; keyword followed by its options

FLAGS:
    -h, --help       Prints help information
    -V, --version    Prints version information

OPTIONS:
        --sensor-i2c-address &lt;sensor-i2c-address&gt;    Number in hexadecimal
        --sensor-i2c-bus &lt;sensor-i2c-bus&gt;            Number in decimal [default: 1]
        --socket-interface &lt;socket-interface&gt;        Address of interface to bind [default: 0.0.0.0]
        --socket-port &lt;socket-port&gt;                  Number in decimal [default: 9898]
</code></pre>
<p>It works fine. Clap and structopt are great :) Clap looks a little better.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/krystian-wojtas">@krystian-wojtas</a> on 2020-02-25 20:31</div>
            <div class="timeline-body"><p>To summarize:</p>
<p>I have parsing of command line arguments using this great library. For my case I had to split all commands to some smaller groups and run individual parsing for them.</p>
<p>I'm wondering if it could be possible to express this logic by clap itself? Is such case worth to implement? Would it be more users interested in it? Or there are a low chance that anyone else would like to use clap in similar way?</p>
<p>Is it useful to implement passing vector of enums? Something like</p>
<pre><code class="language-rust">#[clap(subcommand)] 
// or #[clap(subcommands)]  ?
field: Vec&lt;UserEnum&gt;
</code></pre>
<p>Maybe there is some better way to model such command line arguments to fit into current clap implementation?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-02-26 01:40</div>
            <div class="timeline-body"><p>@CreepySkeleton What do you think about this whole issue? It's a different way of doing things for sure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-02-27 16:01</div>
            <div class="timeline-body"><p>I'm afraid there's no way to implement <em>this exact</em> design with clap, but you can get pretty close.</p>
<p>You see, <code>--sensor</code> takes arbitrary number of values <em>up to the next occurrence of <code>--sensor</code></em>. There's no way to express this condition via clap API, unfortunately, so it couldn't work, not out of box.</p>
<p>You can overcome this limitation by applying some sort of external preprocessing, splitting the args into groups manually, as you do in the <code>structopt</code> example.</p>
<p>I can think about the alternative:</p>
<pre><code>$ prometheus_sensors_exporter \
    \
    `# 2 physical sensors located on physycial different i2c bus or address` \
    --sensor \
        sensor-device=tmp102 \
        sensor-name=&quot;temperature_tmp102_outdoor&quot; \
        sensor-i2c-bus=0 \
        sensor-i2c-address=0x48 \
    --sensor \
        sensor-device=tmp102 \
        sensor-name=&quot;temperature_tmp102_indoor&quot; \
        sensor-i2c-bus=1 \
        sensor-i2c-address=0x49 \
</code></pre>
<p>The idea is to threat each group as <em>one option with multiple arguments</em>, each parameter is a key-value pair. Unfortunately, parsing these values is up to you, and the auto generated help message leaves much to be desired.</p>
<blockquote>
<p>I'm wondering if it could be possible to express this logic by clap itself? Is such case worth to implement? Would it be more users interested in it? Or there are a low chance that anyone else would like to use clap in similar way?</p>
</blockquote>
<p>Those are good questions, and whether we will consider adding support for this use case or not depends on the answers. This is the first such request, and it is also the first time I personally encounter this design.</p>
<blockquote>
<p>Maybe there is some better way to model such command line arguments to fit into current clap implementation?</p>
</blockquote>
<p>Ideas are welcome!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/leshow">@leshow</a> on 2020-03-03 22:03</div>
            <div class="timeline-body"><p>I found this issue trying to do the exact same thing. The case is that I want to pass multiple <code>--something</code> where each <code>Something</code> has a set of values.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: parsing</span> added by @CreepySkeleton on 2020-06-30 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: hard</span> added by @CreepySkeleton on 2020-06-30 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">help wanted</span> added by @CreepySkeleton on 2020-06-30 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by @CreepySkeleton on 2020-06-30 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: maybe</span> added by @CreepySkeleton on 2020-06-30 10:20</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../TeXitoi/structopt/issues/457.html">TeXitoi/structopt#457</a> on 2020-12-28 18:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/140.html">epage/clapng#140</a> on 2021-12-06 19:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> removed by @epage on 2021-12-08 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> removed by @epage on 2021-12-08 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-08 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-08 21:02</div>
            <div class="timeline-body"><p>We've also talked some about this in https://github.com/clap-rs/clap/issues/2683</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">E-hard</span> removed by @epage on 2021-12-09 21:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">E-help-wanted</span> removed by @epage on 2021-12-09 21:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/elkowar">@elkowar</a> on 2022-09-03 16:54</div>
            <div class="timeline-body"><p>I'd still love to see this, currently my CLI api is very much suffering from this not being implemented ^^'</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-03 17:45</div>
            <div class="timeline-body"><p>In the upcoming clap v4, we at least have a Builder example for position-sensitive options: https://github.com/clap-rs/clap/blob/master/examples/find.rs.  That can be re-worked to handle grouping of arguments.  The derive reference describes how to integrate sections of builder code into wider derive uses.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../bitcoindevkit/bdk-cli/pulls/124.html">bitcoindevkit/bdk-cli#124</a> on 2022-10-02 14:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Isaac-Leonard">@Isaac-Leonard</a> on 2024-02-17 13:55</div>
            <div class="timeline-body"><p>Has there been any changes with this, I've been struggling to implement it for a few hours but it doesn't seem to be possible.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../fedimint/fedimint/pulls/4473.html">fedimint/fedimint#4473</a> on 2024-03-06 07:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2024-03-21 12:34</div>
            <div class="timeline-body"><p>A thought I had: combining command-chaining (#2222) with subcommand flags would allow users to create something like this (when there is a struct-start argument)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/5488.html">clap-rs/clap#5488</a> on 2024-05-08 07:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../LeoBorai/wait-on/issues/3.html">LeoBorai/wait-on#3</a> on 2024-05-17 04:37</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cavivie">@cavivie</a> on 2024-09-12 06:22</div>
            <div class="timeline-body"><p>Uhh, fortunately I encountered this issue and found it opened here, unfortunately the solution is not yet in sight.</p>
<p>I don't think command-chaining is a solution to this issue, it just seems like a workaround.</p>
<p>An argument itself means a single value, but how a single value is parsed actually depends on the value parser of the argument itself. I expect <code>Vec</code> to be treated as a special object. If the argument has the &quot;argument group&quot; flag, then an argument parser (let's call it <code>ArgGroupValueParser</code>) is provided to parse the value after the argument into a <code>Vec</code> element type. Then we require that the elements in <code>Vec</code> can be parsed by <code>ArgGroupValueParser</code>. In fact, this requires clap to provide a capability to parse the value of the argument itself as a command line argument, which seems to have the meaning of <code>Matryoshka doll</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/cavivie">@cavivie</a> on 2024-09-12 06:27</div>
            <div class="timeline-body"><p>At present, without affecting the structural design, I use <code>JSON Array</code> strings to parse into all <code>Vec&lt;Struct&gt;</code> parameters (for<code>HashMap</code>, <code>JSON Object</code> is used), which makes the cli look weird. I hope a solution can be discussed here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2222.html">clap-rs/clap#2222</a> on 2025-07-09 14:11</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:32 UTC
    </footer>
</body>
</html>
