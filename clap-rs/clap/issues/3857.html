<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Set default subcommand via Derive API - clap-rs/clap #3857</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Set default subcommand via Derive API</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/3857">#3857</a>
        opened by <a href="https://github.com/dyc3">@dyc3</a>
        on 2022-06-21 00:36
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/dyc3">@dyc3</a> on 2022-06-21 00:36</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Clap Version</h3>
<p>3.1.18</p>
<h3>Describe your use case</h3>
<p>I maintain <a href="https://github.com/dyc3/steamguard-cli">steamguard-cli</a> and I recently upgraded clap to v3, and switched over to the derive API. A feature of the program is that whenever you don't supply a subcommand, it generates a code.</p>
<p>My current solution is to have the subcommands be optional, like so:</p>
<p>https://github.com/dyc3/steamguard-cli/blob/2678961a4c938c153eac0b80b952999903d41861/src/cli.rs#L35-L49</p>
<p>This is OK, but I wanted to add an <code>--offline</code> flag that would only be valid when generating a code. This means I need a new <code>Code</code> subcommand, but adding this in it's current form would break my backwards compatibility.</p>
<h3>Describe the solution you'd like</h3>
<p>It's already possible to have a default subcommand, as shown in this example: https://github.com/clap-rs/clap/blob/731d18f300919a396eee62253f31239b9b02a943/examples/git.rs#L32-L39 All that needs to be done is expose this via the derive api.</p>
<pre><code>#[clap(subcommand, default=&quot;Code&quot;)]
sub: Subcommands
</code></pre>
<h3>Alternatives, if applicable</h3>
<p><code>Option&lt;Subcommands&gt;</code> makes it so that subcommands are optional altogether, but that means any arguments you need in the <code>None</code> case must become global arguments, which can get confusing for end users.</p>
<h3>Additional Context</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @dyc3 on 2022-06-21 00:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-06-21 01:09</div>
            <div class="timeline-body"><blockquote>
<p>This is OK, but I wanted to add an --offline flag that would only be valid when generating a code. This means I need a new Code subcommand, but adding this in it's current form would break my backwards compatibility.</p>
</blockquote>
<p>Why would that break backwards compatibility?  Could you clarify how this is related to the default subcommands?</p>
<blockquote>
<p>Option<Subcommands> makes it so that subcommands are optional altogether, but that means any arguments you need in the None case must become global arguments, which can get confusing for end users.</p>
</blockquote>
<p>How come you say they would need to be <code>global = true</code>? The stash example you referenced doesn't do that.</p>
<p>What isn't quite clear is what the concerns are for users <a href="https://github.com/clap-rs/clap/blob/master/examples/git-derive.rs#L55">implementing this with the existing primitives we offer</a> besides the extra boiler plate.</p>
<blockquote>
<p>All that needs to be done is expose this via the derive api.</p>
</blockquote>
<p>Ideally we add new major features like this at the Builder API level so everyone can take advantage of it.  As we dig in, there might be some technical details that force us into it (like if we need any <code>debug_asserts</code>).</p>
<p>The challenge we run into is we are trying to focus on providing users building blocks rather than baking in everything to help with</p>
<ul>
<li>Keeping binary sizes down</li>
<li>Keeping compile times down</li>
<li>Minimizing the API surface so what we do have is more discoverable</li>
</ul>
<p>If there are challenges with doing this with the building blocks or if this becomes important enough across our user base, we can re-evaluate native support for it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-decision</span> added by @epage on 2022-06-21 01:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-builder</span> added by @epage on 2022-06-21 01:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dyc3">@dyc3</a> on 2022-06-21 01:57</div>
            <div class="timeline-body"><blockquote>
<p>Why would that break backwards compatibility? Could you clarify how this is related to the default subcommands?
How come you say they would need to be <code>global = true</code>?</p>
</blockquote>
<p>Ah, I didn't realize global had a specific meaning. Let me try again.</p>
<p>Here's my understanding:</p>
<p>Suppose we have my current implementation:</p>
<pre><code class="language-rust">#[derive(Parser)]
struct Args {
    sub: Option&lt;Commands&gt;
}

#[derive(Parser)]
enum Commands {
    Setup(ArgsSetup),
}

#[derive(Parser)]
struct ArgsSetup;
</code></pre>
<p>When <code>sub == None</code>, it will generate a code. The match looks something like</p>
<pre><code class="language-rust">match args.sub {
    Some(Commands::Setup(subargs)) =&gt; run_setup(subargs),
    None =&gt; generate_code(args),
}
</code></pre>
<p>I want to add an <code>--offline</code> flag that is only valid when generating a code, which would have to look something like:</p>
<pre><code class="language-rust">#[derive(Parser)]
struct Args {
    #[clap(long)]
    offline: bool

    sub: Option&lt;Commands&gt;
}

#[derive(Parser)]
enum Commands {
    Setup(ArgsSetup),
}

#[derive(Parser)]
struct ArgsSetup;
</code></pre>
<p>Correct me if I'm wrong, but this would make <code>--offline</code> a valid argument regardless of the subcommand (as in it gets parsed and doesn't cause errors, even though it's ultimately unused).</p>
<p>Ideally, I would like it to look something like this:</p>
<pre><code class="language-rust">#[derive(Parser)]
struct Args {
    #[clap(subcommand, default = &quot;Code&quot;)]
    sub: Commands
}

#[derive(Parser)]
enum Commands {
    Setup(ArgsSetup),
    Code(ArgsCode),
}

#[derive(Parser)]
struct ArgsSetup;

#[derive(Parser)]
struct ArgsCode {
    #[clap(long)]
    offline: bool
}
</code></pre>
<p>This way, <code>--offline</code> would only be valid in the context of the <code>Code</code> subcommand. <code>steamguard-cli code --offline</code> and <code>steamguard-cli --offline</code> would have the same effect. <code>args_conflicts_with_subcommands</code> was not listed in the derive API documentation, so I didn't even know it was accessible.</p>
<p>Regardless, the git-derive example you linked feels really unintuitive to me. I have no idea how to apply it to my situation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-06-21 14:07</div>
            <div class="timeline-body"><blockquote>
<p>args_conflicts_with_subcommands was not listed in the derive API documentation, so I didn't even know it was accessible.</p>
</blockquote>
<p>The derive documentation delegates to the builder documentation with <a href="https://github.com/clap-rs/clap/tree/master/examples/derive_ref#command-attributes">this statement</a></p>
<blockquote>
<p><strong>Raw attributes:</strong> Any <a href="https://docs.rs/clap/latest/clap/type.Command.html">Command method</a> can also be used as an attribute, see <a href="https://github.com/clap-rs/clap/tree/master/examples/derive_ref#terminology">Terminology</a> for syntax.</p>
<ul>
<li>e.g. <code>#[clap(arg_required_else_help(true))]</code> would translate to <code>cmd.arg_required_else_help(true)</code></li>
</ul>
</blockquote>
<blockquote>
<p>Regardless, the git-derive example you linked feels really unintuitive to me. I have no idea how to apply it to my situation.</p>
</blockquote>
<p>The key parts</p>
<ul>
<li>Subcommands under <code>stash</code> are optional (<code>command: Option&lt;StashCommands&gt;,</code>), allowing someone to not provide one</li>
<li>We reuse arguments between <code>git stash</code> and <code>git stash push</code> via <code>#[clap(flatten)] push: StashPush,</code></li>
<li>We prevent using <code>git stash</code> flags with any of the <code>git stash</code> subcommands with <code>#[clap(args_conflicts_with_subcommands = true)]</code></li>
<li>We simplify the match code by treating the <code>git stash</code> args as if they were passed to <code>git stash push</code> via <code>let stash_cmd = stash.command.unwrap_or(StashCommands::Push(stash.push));</code></li>
</ul>
<p>It sounds like doing similar what give you similar results</p>
<pre><code class="language-rust">#[derive(Parser)]
#[clap(args_conflicts_with_subcommands = true)]
struct Args {
    #[clap(subcommand)]
    sub: Option&lt;Commands&gt;,

    #[clap(flatten)]
    code: ArgsCode,
}

#[derive(Parser)]
enum Commands {
    Setup(ArgsSetup),
    Code(ArgsCode),
}

#[derive(Parser)]
struct ArgsSetup;

#[derive(Parser)]
struct ArgsCode {
    #[clap(long)]
    offline: bool
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dyc3">@dyc3</a> on 2022-06-21 23:29</div>
            <div class="timeline-body"><p>That's a really good breakdown, thank you! I'm able to get the behavior I want. I still think having derive syntax for a default subcommand would be convenient and easier to work with. Purely as a nice to have though, not missing functionality.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/gregdhill">@gregdhill</a> on 2022-09-07 13:05</div>
            <div class="timeline-body"><p>@epage what if some of the commands in <code>ArgsCode</code> are required?</p>
<p>For example if we try <code>Args::parse()</code> here we get <code>MissingRequiredArgument</code>.</p>
<pre><code class="language-rust">#[derive(Parser)]
struct Args {
    #[clap(subcommand)]
    sub: Option&lt;Commands&gt;,

    #[clap(flatten)]
    code: ArgsCode,
}

#[derive(Parser)]
enum Commands {
    Setup(ArgsSetup),
    Code(ArgsCode),
}

#[derive(Parser)]
struct ArgsSetup;

#[derive(Parser)]
struct ArgsCode {
    #[clap(long)]
    name: String,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-07 13:50</div>
            <div class="timeline-body"><p>@gregdhill Your example would look like</p>
<pre><code class="language-rust">#[derive(Parser)]
#[clap(args_conflicts_with_subcommands = true)]
struct Args {
    #[clap(subcommand)]
    sub: Option&lt;Commands&gt;,

    #[clap(flatten)]
    code: ArgsCode,
}

#[derive(Parser)]
enum Commands {
    Setup(ArgsSetup),
    Code(ArgsCode),
}

#[derive(Parser)]
struct ArgsSetup;

#[derive(Parser)]
struct ArgsCode {
    #[clap(long, required = true)]
    name: Option&lt;String&gt;,
}
</code></pre>
<ul>
<li><code>args_conflicts_with_subcommands </code> will override <code>required = true</code></li>
<li><code>name</code> needs to be <code>Option&lt;T&gt;</code> so we have something to put in its place when it isn't required</li>
<li>Because <code>name</code> is <code>Option&lt;T&gt;</code>, <code>required = true</code> isn't being set for us and we need to do it ourselves.</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-07 13:51</div>
            <div class="timeline-body"><p>btw another discussion on default subcommands: https://github.com/clap-rs/clap/discussions/4134</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-07 13:56</div>
            <div class="timeline-body"><p>I'm closing this because</p>
<ul>
<li>We have shown that this is possible today with existing primitives</li>
<li>This seems uncommon enough that it doesn't warrant built-in behavior</li>
</ul>
<p>If someone wants to continue the discussion to see if a solution aligns well enough with clap that we can merge it anyways, some points to consider</p>
<ul>
<li>The derive API is built on top of the builder API and a design will need to include how it maps to the builder API</li>
<li>What is more likely to get supported is if you can find general primitives to make default subcommands easier but also help in other cases (e.g. instead of us merging 3-4 different <code>multicall</code> options, we simplified it down to just one style of <code>multicall</code> that all of the others can be built off of).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2022-09-07 13:56</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-09-08 17:18</div>
            <div class="timeline-body"><p><a href="https://github.com/yargs/yargs/blob/main/docs/advanced.md#default-commands">yargs supports default subcommands</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/4442.html">clap-rs/clap#4442</a> on 2022-11-02 15:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-decision</span> removed by @epage on 2022-11-02 15:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-wont-fix</span> added by @epage on 2022-11-02 15:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2022-11-02 15:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../fastly/Viceroy/pulls/229.html">fastly/Viceroy#229</a> on 2023-02-27 22:11</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:35:03 UTC
    </footer>
</body>
</html>
