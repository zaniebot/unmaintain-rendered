<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>default_value_if depends on order in struct - clap-rs/clap #4713</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>default_value_if depends on order in struct</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/4713">#4713</a>
        opened by <a href="https://github.com/drmikehenry">@drmikehenry</a>
        on 2023-02-18 12:18
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/drmikehenry">@drmikehenry</a> on 2023-02-18 12:18</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Rust Version</h3>
<p>rustc 1.65.0 (897e37553 2022-11-02)</p>
<h3>Clap Version</h3>
<p>4.1.6</p>
<h3>Minimal reproducible code</h3>
<pre><code class="language-rust">use clap::{builder::ArgPredicate, Parser};

#[derive(Parser, Debug)]
struct Cli {
    #[arg(
        long,
        default_value_if(&quot;imply_both&quot;, ArgPredicate::IsPresent, Some(&quot;true&quot;))
    )]
    flag1: bool,

    /// imply both --flag1 and --flag2
    #[arg(long)]
    imply_both: bool,

    #[arg(
        long,
        default_value_if(&quot;imply_both&quot;, ArgPredicate::IsPresent, Some(&quot;true&quot;))
    )]
    flag2: bool,
}

fn main() {
    let cli = Cli::parse();
    println!(&quot;{:#?}&quot;, cli);
}

</code></pre>
<h3>Steps to reproduce the bug with the above code</h3>
<pre><code>cargo run -q --
</code></pre>
<h3>Actual Behaviour</h3>
<p>This output is generated when no options are given:</p>
<pre><code class="language-console">Cli {
    flag1: false,
    imply_both: false,
    flag2: true,
}
</code></pre>
<p>Note that <code>flag2</code> is true.</p>
<h3>Expected Behaviour</h3>
<p>I expected that <code>flag1</code>, <code>flag2</code>, and <code>imply_both</code> would all be <code>false</code>.</p>
<p>Note that when I move the <code>imply_both</code> argument to the end of the <code>Cli</code> struct, it works as I expect:</p>
<pre><code class="language-rust">use clap::{builder::ArgPredicate, Parser};

#[derive(Parser, Debug)]
struct Cli {
    #[arg(
        long,
        default_value_if(&quot;imply_both&quot;, ArgPredicate::IsPresent, Some(&quot;true&quot;))
    )]
    flag1: bool,

    #[arg(
        long,
        default_value_if(&quot;imply_both&quot;, ArgPredicate::IsPresent, Some(&quot;true&quot;))
    )]
    flag2: bool,

    /// imply both --flag1 and --flag2
    #[arg(long)]
    imply_both: bool,
}

fn main() {
    let cli = Cli::parse();
    println!(&quot;{:#?}&quot;, cli);
}
</code></pre>
<pre><code class="language-console">Cli {
    flag1: false,
    flag2: false,
    imply_both: false,
}
</code></pre>
<p>But with this ordering, the automatically generated help is not in my preferred order.</p>
<h3>Additional Context</h3>
<p><em>No response</em></p>
<h3>Debug Output</h3>
<pre><code class="language-console">[      clap::builder::command] 	Command::_do_parse
[      clap::builder::command] 	Command::_build: name=&quot;clapdefault&quot;
[      clap::builder::command] 	Command::_propagate:clapdefault
[      clap::builder::command] 	Command::_check_help_and_version:clapdefault expand_help_tree=false
[      clap::builder::command] 	Command::long_help_exists
[      clap::builder::command] 	Command::_check_help_and_version: Building default --help
[      clap::builder::command] 	Command::_propagate_global_args:clapdefault
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:flag1
[clap::builder::debug_asserts] 	Arg::_debug_asserts:imply_both
[clap::builder::debug_asserts] 	Arg::_debug_asserts:flag2
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:flag1:
[        clap::parser::parser] 	Parser::add_default_value: has conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:flag1: has default vals
[        clap::parser::parser] 	Parser::add_default_value:iter:flag1: wasn't used
[        clap::parser::parser] 	Parser::react action=SetTrue, identifier=None, source=DefaultValue
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;flag1&quot;, source=DefaultValue
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;false&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=1
[        clap::parser::parser] 	Parser::add_defaults:iter:imply_both:
[        clap::parser::parser] 	Parser::add_default_value: doesn't have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:imply_both: has default vals
[        clap::parser::parser] 	Parser::add_default_value:iter:imply_both: wasn't used
[        clap::parser::parser] 	Parser::react action=SetTrue, identifier=None, source=DefaultValue
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;imply_both&quot;, source=DefaultValue
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;false&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=2
[        clap::parser::parser] 	Parser::add_defaults:iter:flag2:
[        clap::parser::parser] 	Parser::add_default_value: has conditional defaults
[        clap::parser::parser] 	Parser::react action=SetTrue, identifier=None, source=DefaultValue
[   clap::parser::arg_matcher] 	ArgMatcher::start_custom_arg: id=&quot;flag2&quot;, source=DefaultValue
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;true&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=3
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value: doesn't have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn't have default vals
[     clap::parser::validator] 	Validator::validate
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[   clap::parser::arg_matcher] 	ArgMatcher::get_global_values: global_arg_vec=[]
Cli {
    flag1: false,
    imply_both: false,
    flag2: true,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by @drmikehenry on 2023-02-18 12:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drmikehenry">@drmikehenry</a> on 2023-02-18 14:21</div>
            <div class="timeline-body"><p>For reference, in <code>Cargo.toml</code> is:</p>
<pre><code class="language-toml">[dependencies]
clap = { version = &quot;4.1.6&quot;, features = [&quot;debug&quot;, &quot;derive&quot;] }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mattmadeofpasta">@mattmadeofpasta</a> on 2023-02-22 08:41</div>
            <div class="timeline-body"><p>Using <code>ArgPredicate::Equals(&quot;true&quot;.into())</code> instead of <code>ArgPredicate::IsPresent</code> does what you are trying to achieve.</p>
<pre><code>use clap::{builder::ArgPredicate, Parser};

#[derive(Parser, Debug)]
struct Cli {
    #[arg(
        long,
        default_value_if(&quot;imply_both&quot;, ArgPredicate::Equals(&quot;true&quot;.into()), Some(&quot;true&quot;))
    )]
    flag1: bool,

    /// imply both --flag1 and --flag2
    #[arg(long)]
    imply_both: bool,

    #[arg(
        long,
        default_value_if(&quot;imply_both&quot;, ArgPredicate::Equals(&quot;true&quot;.into()), Some(&quot;true&quot;))
    )]
    flag2: bool,
}

fn main() {
    let cli = Cli::parse();
    println!(&quot;{:#?}&quot;, cli);
}
</code></pre>
<pre><code>$ cargo run -q --  
Cli {
    flag1: false,
    imply_both: false,
    flag2: false,
}
</code></pre>
<pre><code>$ cargo run -q --  --imply-both
Cli {
    flag1: true,
    imply_both: true,
    flag2: true,
}
</code></pre>
<p>I am not sure what is happening here with <code>ArgPredicate::IsPresent</code>. It looks like <code>ArgPredicate::IsPresent</code> also includes if the argument has already been defined and has a default value.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/drmikehenry">@drmikehenry</a> on 2023-02-22 09:29</div>
            <div class="timeline-body"><p>Thanks for the explanation; your suggestion works perfectly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @drmikehenry on 2023-02-22 09:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-22 13:26</div>
            <div class="timeline-body"><p>@mattmadeofpasta thanks for providing that answer!</p>
<p>I'm going to re-open though as generally the <code>ArgPredicate::IsPresent</code> means &quot;it is explicitly present&quot; which excludes defaults (but includes env variables) but <code>default_value_if</code> is not doing an explicit check.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @epage on 2023-02-22 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-parsing</span> added by @epage on 2023-02-22 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">M-breaking-change</span> added by @epage on 2023-02-22 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "5.0" by @epage on 2023-02-22 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-22 13:28</div>
            <div class="timeline-body"><p>I went ahead and marked this as a breaking change and scheduled it for 5.0.  This is one of those cases where the line between bug fix and breaking change is unclear, so I marked it as the more extreme case until a more thorough determination can be made.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-22 13:33</div>
            <div class="timeline-body"><p>Past changes like this were treated as non-breaking</p>
<ul>
<li>#3420</li>
<li>#3793<ul>
<li>Which actually broke someone; #3838</li>
</ul>
</li>
</ul>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:34 UTC
    </footer>
</body>
</html>
