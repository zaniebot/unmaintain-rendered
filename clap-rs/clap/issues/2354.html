<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allow end users to indicate that specific arguments may be ignored if not recognized - clap-rs/clap #2354</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Allow end users to indicate that specific arguments may be ignored if not recognized</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/clap-rs/clap/issues/2354">#2354</a>
        opened by <a href="https://github.com/wchargin">@wchargin</a>
        on 2021-02-20 02:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/wchargin">@wchargin</a> on 2021-02-20 02:46</div>
            <div class="timeline-body"><p><a href="https://github.com/clap-rs/clap/issues/2354#issuecomment-992652202">Closing comment</a>:</p>
<blockquote>
<p>The proposed solution is fairly specialized but can be built with #1404 and <code>IgnoreErrors</code> (not seeing it marked as deprecated) might be a stop gap.</p>
<p>Closing this in favor of those options. If there is any concern with that, let us know!</p>
</blockquote>
<hr />
<h3>Make sure you completed the following tasks</h3>
<ul>
<li>[x] Searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a><ul>
<li>Relevant: #2314 opened by @josvisser66. That discussion has one
request to file it as an issue, and one request for more info.
Here, then, is an issue with more info.</li>
</ul>
</li>
<li>[x] Searched the closed issues: for <em>unrecognized arguments</em></li>
</ul>
<h3>Describe your use case</h3>
<p>My team distributes two binaries; one written in Python, and one in Rust
with Clap. The Python binary invokes the Rust binary. As we add new
options to the Rust binary, <a href="https://github.com/tensorflow/tensorboard/pull/4689#discussion_r579563330">we can’t immediately teach the Python
binary to pass them</a>, because the most recently released version of
the Rust binary would fail with an “unrecognized option” error.</p>
<p>Another use case, as discussed in #2314, involves rolling deployments.
You have a binary at v1.0.0 running in production. You add a flag to it,
but you can’t teach your your prod configs to pass the new flag, because
v1.0.0 will choke if given that flag. Instead, you can change the
configs to pass <code>--undefok=bar --bar=1</code>.  On v1.0.0, this will do
nothing; once v1.1.0 is rolled out, the flag value will be honored.</p>
<h3>If a project of yours is blocked on this feature, please, mention it explicitly.</h3>
<p>Kind of: this would make developing my team’s project (TensorBoard)
notably easier, as noted in the above link, but we have workarounds.</p>
<h3>Describe the solution you'd like</h3>
<p>The Google flags system has a feature called <a href="https://gflags.github.io/gflags/#special"><code>undefok</code></a> (read as
“undefined OK”). If your binary <code>myprog</code> uses gflags, and you run</p>
<pre><code>myprog --undefok=bar --foo=1 --bar=2
</code></pre>
<p>then:</p>
<ul>
<li>if <code>myprog</code> knows about the <code>--bar</code> option, it will interpret the
option as usual;</li>
<li>but if <code>myprog</code> does not know about the <code>--bar</code> option, then it will
be ignored. (Without <code>--undefok=bar</code>, this would be an error that
there is no known flag by the name <code>bar</code>.)</li>
</ul>
<p>Note that supporting or passing <code>--undefok=bar</code> does <em>not</em> mean that you
can pass <em>arbitrary</em> unrecognized arguments: <code>--wat=3</code> would still be an
error.</p>
<p>I imagine that this could be implemented either as a new <code>AppSettings</code>:</p>
<pre><code class="language-rust">let m = App::new(&quot;myprog&quot;)
    .setting(AppSettings::AllowUndefok)
    .arg(Arg::with_name(&quot;foo&quot;).long(&quot;foo&quot;).takes_value(true))
    .get_matches_from(vec![
        &quot;myprog&quot;, &quot;--undefok=bar&quot;, &quot;--foo=1&quot;, &quot;--bar=2&quot;,
    ]);

assert_eq!(m.value_of(&quot;foo&quot;), Some(&quot;1&quot;));
assert_eq!(m.value_of(&quot;baz&quot;), None); // arg just ignored
</code></pre>
<p>…or as an <code>ArgSettings</code> to allow customizing the magic name <code>undefok</code>:</p>
<pre><code class="language-rust">let m = App::new(&quot;myprog&quot;)
    .arg(Arg::with_name(&quot;foo&quot;).long(&quot;foo&quot;).takes_value(true))
    .arg(Arg::with_name(&quot;undefok&quot;).long(&quot;my-undef-ok&quot;).undefok(true))
    .get_matches_from(vec![
        &quot;myprog&quot;, &quot;--my-undef-ok=bar&quot;, &quot;--foo=1&quot;, &quot;--bar=2&quot;,
    ]);

assert_eq!(m.value_of(&quot;foo&quot;), Some(&quot;1&quot;));
assert_eq!(m.value_of(&quot;bar&quot;), None); // arg just ignored
</code></pre>
<h3>Alternatives, if applicable</h3>
<p>One heavyweight alternative is to provide a mode in which arbitrary
unrecognized flags are permitted. But this carries too high a cost:
users who make a typo in an option name should be alerted, not have
their inputs silently ignored.</p>
<h3>Additional context</h3>
<p>IMHO, it’s okay if we need to require that <code>--undefok</code> precede the
undefined arguments on the command line:</p>
<pre><code>--undefok=bar --bar=2  # should be accepted and ignored
--bar=2 --undefok=bar  # it's okay with me if this is rejected
</code></pre>
<p>I also imagine that there might be issues distinguishing flags from
options. It’s okay with me if we need to require that any <code>undefok</code>
options use the “stuck” form:</p>
<pre><code>--undefok=bar --bar=2  # should be accepted and ignored
--undefok=bar --bar 2  # it's okay with me if this is rejected
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by @wchargin on 2021-02-20 02:46</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Allow users to indicate that specific arguments may be ignored if not recognized" to "Allow end users to indicate that specific arguments may be ignored if not recognized" by @wchargin on 2021-02-20 02:48</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: parsing</span> added by @pksunkara on 2021-02-20 12:11</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tmplt">@tmplt</a> on 2021-07-29 22:33</div>
            <div class="timeline-body"><blockquote>
<p>provide a mode in which arbitrary unrecognized flags are permitted.</p>
</blockquote>
<p>This would be useful in programs that extend <code>cargo build</code>. For example, in <a href="https://github.com/probe-rs/cargo-flash"><code>cargo-flash</code></a> and <a href="https://github.com/rtic-scope/cargo-rtic-scope"><code>cargo-rtic-scope</code></a> we want to forward unknown arguments to <code>cargo build</code>. At present this is possible with <code>AppSettings:TrailingVarArgs | Appsettings::AllowLeadingHyphens</code>, but it requires cargo options to be passed as the last options. E.g. <code>cargo flash --bin foobar --release [cargo-flash options...]</code> would be invalid whereas <code>cargo flash [cargo-flash options...] --bin foobar --release</code> would be correct, but not immidiately obvious for the end-user.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../probe-rs/cargo-flash/pulls/188.html">probe-rs/cargo-flash#188</a> on 2021-07-29 22:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rtic-scope/cargo-rtic-scope/issues/28.html">rtic-scope/cargo-rtic-scope#28</a> on 2021-07-29 22:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-07-30 00:44</div>
            <div class="timeline-body"><p>@tmplt another related issue is https://github.com/clap-rs/clap/issues/1880</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tmplt">@tmplt</a> on 2021-07-30 00:55</div>
            <div class="timeline-body"><p>@epage, thanks. The minimal viable solution proposed within would help my case, but it seems that <code>IgnoreErrors</code> has been deprecated.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/179.html">epage/clapng#179</a> on 2021-12-06 21:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> removed by @epage on 2021-12-08 21:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-08 21:10</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-13 16:28</div>
            <div class="timeline-body"><p>The proposed solution is fairly specialized but can be built with #1404 and <code>IgnoreErrors</code> (not seeing it marked as deprecated) might be a stop gap.</p>
<p>Closing this in favor of those options.  If there is any concern with that, let us know!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2021-12-13 16:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-wont-fix</span> added by @epage on 2022-01-11 18:28</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:08 UTC
    </footer>
</body>
</html>
