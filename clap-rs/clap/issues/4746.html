<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Empty pathbufs are no longer accepted by `default_value` - clap-rs/clap #4746</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Empty pathbufs are no longer accepted by `default_value`</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/4746">#4746</a>
        opened by <a href="https://github.com/mejrs">@mejrs</a>
        on 2023-03-05 13:46
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/mejrs">@mejrs</a> on 2023-03-05 13:46</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Rust Version</h3>
<p>rustc 1.69.0-nightly (5243ea5c2 2023-02-20)</p>
<h3>Clap Version</h3>
<p>4.1.8</p>
<h3>Minimal reproducible code</h3>
<pre><code class="language-rust">use clap::Parser;
use std::path::PathBuf;

#[derive(Debug, Parser)]
struct Cli {
    #[clap(short, long, default_value = &quot;&quot;)]
    pub output: PathBuf,
}

fn main() {
    let dummy: Vec&lt;String&gt; = vec![];
    let cli = Cli::parse_from(dummy);
    assert_eq!(cli.output, PathBuf::new());
}
</code></pre>
<h3>Steps to reproduce the bug with the above code</h3>
<p>cargo run</p>
<h3>Actual Behaviour</h3>
<pre><code>thread 'main' panicked at 'Argument `output`'s default_value=&quot;&quot; failed validation: error: a value is required for '--output &lt;OUTPUT&gt;' but none was supplied

For more information, try '--help'.
', C:\Users\bruno\.cargo\registry\src\github.com-1ecc6299db9ec823\clap-4.1.8\src\builder\debug_asserts.rs:867:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
<h3>Expected Behaviour</h3>
<p>I expect it to run successfully, like it did with clap 3.</p>
<h3>Additional Context</h3>
<p><em>No response</em></p>
<h3>Debug Output</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by @mejrs on 2023-03-05 13:46</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-03-06 14:53</div>
            <div class="timeline-body"><p>When comparing 1:1 with clap 3, this does reproduce:</p>
<pre><code class="language-rust">use clap::Parser;
use std::path::PathBuf;

#[derive(Debug, Parser)]
struct Cli {
    #[clap(short, long, default_value = &quot;&quot;, value_parser)]
    pub output: PathBuf,
}

fn main() {
    let dummy: Vec&lt;String&gt; = vec![];
    let cli = Cli::parse_from(dummy);
    assert_eq!(cli.output, PathBuf::new());
}
</code></pre>
<p>The defaulted <code>value_parser</code> attribute opts you into the clap v4 behavior.</p>
<p>The assumption made with the default <code>PathBuf</code> value parser is that empty paths are not used, so the old <code>forbid_empty_values</code> is automatically enabled.  Changing the default to <code>.</code> would fix this.</p>
<p>If you have a use case for accepting an empty <code>PathBuf</code>, I'd be open to hearing it.</p>
<p>You can workaround this by</p>
<ul>
<li>Changing the type to <code>OsString</code></li>
<li>Adding the attribute <code>value_parser = OsStringValueParser::new().map(PathBuf::from))</code></li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mejrs">@mejrs</a> on 2023-03-06 22:44</div>
            <div class="timeline-body"><blockquote>
<p>If you have a use case for accepting an empty PathBuf, I'd be open to hearing it.</p>
</blockquote>
<p>My program produces files and needs to save them somewhere, and uses either</p>
<ul>
<li>the value given on the command line, if given</li>
<li>an environment variable, if present</li>
<li>the current directory (that's where the empty path comes in)</li>
</ul>
<p>I think that's a reasonable use case unless there's something I'm missing something about pathbufs and/or clap...</p>
<p>I actually ended up needing more than this for other reasons, so I went with a <code>impl FromArgMatches for Newtype </code> implementation ðŸ™‚</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-03-06 22:49</div>
            <div class="timeline-body"><p>So your program accepts <code>&quot;&quot;</code> on the command line for CWD?  That seems awkward to enter compared to <code>.</code> and not very clear in <code>--help</code>.</p>
<blockquote>
<p>I actually ended up needing more than this for other reasons, so I went with a impl FromArgMatches for Newtype implementation ðŸ™‚</p>
</blockquote>
<p>Wow, what was it that led you to doing that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/mejrs">@mejrs</a> on 2023-03-06 23:05</div>
            <div class="timeline-body"><p>I decided I also wanted to keep track of <em>why</em> it's using the path, <a href="https://github.com/mejrs/rs3cache/commit/371f264f891ae96b4142efe82072a52527de6627#diff-b2bbdb7136980ab236d2398b541fff08911fc2b21fed5a1ee6de17b4b29a3e59">so I used an enum instead of PathBuf</a>.</p>
<blockquote>
<p>So your program accepts &quot;&quot; on the command line for CWD?</p>
</blockquote>
<p>My intention was to not require the argument at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-03-27 21:02</div>
            <div class="timeline-body"><p>As this is no longer blocking you and the other case had an alternatives (e.g. using <code>&quot;.&quot;</code> as the default), I'm going to go ahead and close this.</p>
<p>If someone else finds a use case that is block on this, we can always re-open and re-evaluate.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2023-03-27 21:02</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/5368.html">clap-rs/clap#5368</a> on 2024-02-18 12:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2024-02-19 18:26</div>
            <div class="timeline-body"><p>From #5368</p>
<p>@akanalytics</p>
<blockquote>
<p>Sorry - this is a duplicate of #4746. But I think this is still a bug, that seems to trip people up. Paths are such a common command line parameter.</p>
<p>Usecase: lots of code can use an empty pathbuf as an alternative to Option. Rust explicitly offers a new() constructor which does exactly this, and it reduces the boilerplate in many places.</p>
<p>Using &quot;.&quot; does not have the same meaning. (ls . and ls '' give different results on my linux system).</p>
<p>Although personally Im not a fan of empty PathBufs, Rust clearly does support them, and command line tools such as the Linux 'ls' command does distinguish between empty paths and &quot;.&quot; paths.</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2024-02-19 18:28</div>
            <div class="timeline-body"><blockquote>
<p>Rust explicitly offers a new() constructor which does exactly this, and it reduces the boilerplate in many places.</p>
</blockquote>
<p>I'm not too sure how <code>Path::new(&quot;&quot;)</code> is relevant as this is focused on how people parse their command line.  Could you clarify that?</p>
<blockquote>
<p>Using &quot;.&quot; does not have the same meaning. (ls . and ls '' give different results on my linux system).</p>
</blockquote>
<p><code>touch &quot;&quot;</code> fails on my system, so using it as a path without further context seems incorrect which is what this is trying to help users with.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/akanalytics">@akanalytics</a> on 2024-02-24 12:38</div>
            <div class="timeline-body"><p>Clarifying #5368</p>
<p>Firstly, clap is an excellent library, and it's trivial for me to work around the &quot;forbidding empty pathbuf default&quot; in my particualr case. However, to me clap is not just a beginner's library, its almost <em>THE</em> standard parsing library. And as such I feel it should support everything rust supports. So these are thoughts, in case this is ever explored further.</p>
<p>a) <strong>Empty PathBuf is a genuine concept/thing</strong>
Rust supports the empty Path/PathBuf. Is is used in the default constructor PathBuf::new() - note: no quotes, though equivalent to PathBuf::from(&quot;&quot;).
One can debate whether an empty path is a wise decision or not. I can't say Im a fan personally, but Rust has adopted it.</p>
<p>Java and Posix both use it too, and have explicit logic around it, that Rust replicates.
Note: Posix says that &quot;&quot; must fail to resolve on its own. This is why touch &quot;&quot; fails.</p>
<p>Thus it can only really be used in combination with other path components. So the use case is always going to be something like
<code>mycommand --basepath=something --file1=filename1.txt --file2=filename2.txt</code>
where basepath is used as a base or parent directory to files 1 and 2.</p>
<p><code>InPath --path=xyz</code>
..a hypothetical command line utility that checks whether xyz is in the PATH environment variable would be another example or usecase. These are path fragments (colon separated on unix), and &quot;&quot; and &quot;.&quot; should be searchable, though are functionally equivalent in PATH.</p>
<p>b) <strong>Dot and Empty are not the same</strong>
.. though they are very very close.
PathBuf::new() has behaviour different from PathBuf::from(&quot;.&quot;)
path.parent() will return Some(empty-path) on occasion. Mixing the two (empty and '.') seems wrong.</p>
<p>A command line parameter of base_path = &quot;&quot; (empty) will satisfy</p>
<p><code>PathBuf::from(&quot;filename.txt&quot;).parent() == Some(base_path)</code></p>
<p>but base_path = &quot;.&quot; will not.</p>
<p>Forbidding empty_path doesnt quite work for the hypothetical  InPath command (above) either.</p>
<p>I think a) and b) means that using a default of &quot;.&quot; is not quite correct, though this works in 95% of cases.</p>
<p>c) <strong>OsString is a poor substitute (due to serialization and communication of intent)</strong>
OsString as a substitute for PathBuf has the disadvantage that it does not serialize (in a platform compatible way). Serialization of clap structures matters as I think progress is being made towards combining command line args and config files (read using Serde).
Often an additional macro or serialization is added to a clap structure to make this work. We're not quite there yet, but I can see several approaches being explored.
Having a path or path component stored as a PathBuf rather than an OsString surely clarifies, and makes handling this in a cross-platform manner easier (in the future).</p>
<p>Summary:
My particular use case is fine, I can work around. Im happy.
The above are just thoughts for the future, if this comes up again.
The approach to leave this as it is for now, seems fine.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2024-02-26 21:40</div>
            <div class="timeline-body"><blockquote>
<p>However, to me clap is not just a beginner's library, its almost THE standard parsing library. And as such I feel it should support everything rust supports. So these are thoughts, in case this is ever explored further.</p>
</blockquote>
<p>This also means that we have to move carefully. We have a lot of users but only a couple will interact on any issue and we could change things without anyone noticing until its too late.</p>
<blockquote>
<p>Mixing the two (empty and '.') seems wrong.</p>
</blockquote>
<p>I'm still confused as to why discussing the APIs for <code>Path</code> affects what we expose as the CLI.  Also not the strongest argument to focus on things being &quot;wrong&quot; as that can vary by people.</p>
<blockquote>
<p>OsString as a substitute for PathBuf has the disadvantage that it does not serialize (in a platform compatible way).</p>
</blockquote>
<p>Could you clarify what you mean here?</p>
<blockquote>
<p>Having a path or path component stored as a PathBuf rather than an OsString surely clarifies, and makes handling this in a cross-platform manner easier (in the future).</p>
</blockquote>
<p>You can still use a <code>PathBuf</code> and just provide a custom <code>value_parser</code> that builds on top of the <code>OsString</code> value parser (<code>value_parser = clap::builder::OsStringValueParser::new().map(|os| PathBuf::from(os))</code>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/akanalytics">@akanalytics</a> on 2024-03-02 12:33</div>
            <div class="timeline-body"><p>Moving carefully -&gt; agree 100%.</p>
<p>&quot;Seems wrong&quot; perhaps better phrased as &quot;because of point b regarding difference in behaviour between empty and dot&quot;.  Apologies.</p>
<p>OsString as a substitute, and serialization -&gt;
If you store default configuration as data types similar/identical to clap command line types, (and some helper configuration crates do this btw), then OsString does not serialize in a platform independent way.</p>
<p>For example if the default for a file/path in a configuration file is stored as a PathBuf in a struct: this serializes to/from string text in a  platform independent manner for utf8 pathbufs (via serde).</p>
<p>But OsString serializes (via serde) rather badly.
<code>filename = &quot;foo&quot;</code>
serializes as
<code>&quot;filename&quot;: { &quot;Unix&quot;: [102, 111, 111] }</code></p>
<p>This is because OsString is a platform dependent enum.
Very few would want a config file that has entries like the above. Most would want simply
filename: &quot;foo&quot; (in the equivalent yaml/json/toml format)</p>
<p>custom value_parser =&gt; sounds promising, I will look into doing that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2024-03-12 21:11</div>
            <div class="timeline-body"><blockquote>
<p>OsString as a substitute, and serialization</p>
</blockquote>
<p>As I mentioned, you can still make your field a <code>PathBuf</code> by using a custom <code>value_parser</code> that starts with receiving an <code>OsStr</code> from clap and turns it into a <code>PathBuf</code> in your own way.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:35:21 UTC
    </footer>
</body>
</html>
