<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>A subcommand is not optional when using derive macros - clap-rs/clap #2844</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>A subcommand is not optional when using derive macros</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/2844">#2844</a>
        opened by <a href="https://github.com/tobx">@tobx</a>
        on 2021-10-11 12:35
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/tobx">@tobx</a> on 2021-10-11 12:35</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the existing issues</li>
</ul>
<h3>Rust Version</h3>
<p>rustc 1.55.0 (c8dfcfe04 2021-09-06)</p>
<h3>Clap Version</h3>
<p>3.0.0-beta.4</p>
<h3>Minimal reproducible code</h3>
<pre><code class="language-rust">use clap::Clap;

#[derive(Clap)]
#[clap(name = &quot;test&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

#[derive(Clap)]
enum SubCommand {
    Test(Test),
}

#[derive(Clap)]
struct Test;

fn main() {
    Opts::parse();
}
</code></pre>
<h3>Steps to reproduce the bug with the above code</h3>
<p><code>cargo run</code></p>
<h3>Actual Behaviour</h3>
<p>Running the app without arguments shows the help text and exits.</p>
<p>The help text shows the subcommand as required:</p>
<pre><code>USAGE:
    test-clap &lt;SUBCOMMAND&gt;
</code></pre>
<h3>Expected Behaviour</h3>
<p>The subcommand should be optional.</p>
<p>The help text should show the subcommand as optional:</p>
<pre><code>USAGE:
    test-clap [SUBCOMMAND]
</code></pre>
<h3>Additional Context</h3>
<p>This minimal example without using derive macros works as expected:</p>
<pre><code class="language-rust">use clap::App;

fn main() {
    App::new(&quot;test&quot;)
        .subcommand(App::new(&quot;test&quot;))
        .get_matches();
}
</code></pre>
<h3>Debug Output</h3>
<p>[            clap::build::app] 	App::_do_parse
[            clap::build::app] 	App::_build
[            clap::build::app] 	App::_propagate:test
[            clap::build::app] 	App::_check_help_and_version
[            clap::build::app] 	App::_check_help_and_version: Building help subcommand
[            clap::build::app] 	App::_propagate_global_args:test
[            clap::build::app] 	App::_derive_display_order:test
[            clap::build::app] 	App::_derive_display_order:test
[            clap::build::app] 	App::_derive_display_order:help
[clap::build::app::debug_asserts] 	App::_debug_asserts
[clap::build::arg::debug_asserts] 	Arg::_debug_asserts:help
[clap::build::arg::debug_asserts] 	Arg::_debug_asserts:version
[         clap::parse::parser] 	Parser::get_matches_with
[         clap::parse::parser] 	Parser::_build
[         clap::parse::parser] 	Parser::_verify_positionals
[         clap::parse::parser] 	Parser::get_matches_with: SubcommandRequiredElseHelp=true
[         clap::parse::parser] 	Parser::color_help
[          clap::output::help] 	Help::new
[          clap::output::help] 	Help::write_help
[          clap::output::help] 	should_show_arg: use_long=false, arg=help
[          clap::output::help] 	Help::write_templated_help
[          clap::output::help] 	Help::write_before_help
[          clap::output::help] 	Help::write_bin_name
[         clap::output::usage] 	Usage::create_usage_no_title
[         clap::output::usage] 	Usage::create_help_usage; incl_reqs=true
[         clap::output::usage] 	Usage::get_required_usage_from: incls=[], matcher=false, incl_last=false
[         clap::output::usage] 	Usage::get_required_usage_from: unrolled_reqs=[]
[         clap::output::usage] 	Usage::get_required_usage_from: ret_val=[]
[         clap::output::usage] 	Usage::needs_flags_tag
[         clap::output::usage] 	Usage::needs_flags_tag:iter: f=help
[         clap::output::usage] 	Usage::needs_flags_tag:iter: f=version
[         clap::output::usage] 	Usage::needs_flags_tag: [FLAGS] not required
[         clap::output::usage] 	Usage::create_help_usage: usage=test-clap <SUBCOMMAND>
[          clap::output::help] 	Help::write_all_args
[          clap::output::help] 	should_show_arg: use_long=false, arg=help
[          clap::output::help] 	should_show_arg: use_long=false, arg=version
[          clap::output::help] 	Help::write_args
[          clap::output::help] 	should_show_arg: use_long=false, arg=help
[          clap::output::help] 	Help::write_args: Current Longest...2
[          clap::output::help] 	Help::write_args: New Longest...6
[          clap::output::help] 	should_show_arg: use_long=false, arg=version
[          clap::output::help] 	Help::write_args: Current Longest...6
[          clap::output::help] 	Help::write_args: New Longest...9
[          clap::output::help] 	should_show_arg: use_long=false, arg=help
[          clap::output::help] 	Help::spec_vals: a=--help
[          clap::output::help] 	should_show_arg: use_long=false, arg=version
[          clap::output::help] 	Help::spec_vals: a=--version
[          clap::output::help] 	Help::spec_vals: a=--help
[          clap::output::help] 	Help::short
[          clap::output::help] 	Help::long
[          clap::output::help] 	Help::val: arg=help
[          clap::output::help] 	Help::val: Has switch...
[          clap::output::help] 	Yes
[          clap::output::help] 	Help::val: nlh...false
[          clap::output::help] 	Help::help
[          clap::output::help] 	Help::help: Next Line...false
[          clap::output::help] 	Help::help: Too long...
[          clap::output::help] 	No
[          clap::output::help] 	Help::spec_vals: a=--version
[          clap::output::help] 	Help::short
[          clap::output::help] 	Help::long
[          clap::output::help] 	Help::val: arg=version
[          clap::output::help] 	Help::val: Has switch...
[          clap::output::help] 	Yes
[          clap::output::help] 	Help::val: nlh...false
[          clap::output::help] 	Help::help
[          clap::output::help] 	Help::help: Next Line...false
[          clap::output::help] 	Help::help: Too long...
[          clap::output::help] 	No
[          clap::output::help] 	Help::write_subcommands
[          clap::output::help] 	Help::write_subcommands longest = 4
[          clap::output::help] 	Help::sc_spec_vals: a=test
[          clap::output::help] 	Help::sc_spec_vals: a=help
[          clap::output::help] 	Help::write_subcommand
[          clap::output::help] 	Help::sc_spec_vals: a=help
[          clap::output::help] 	Help::help
[          clap::output::help] 	Help::help: Next Line...false
[          clap::output::help] 	Help::help: Too long...
[          clap::output::help] 	No
[          clap::output::help] 	Help::write_subcommand
[          clap::output::help] 	Help::sc_spec_vals: a=test
[          clap::output::help] 	Help::help
[          clap::output::help] 	Help::help: Next Line...false
[          clap::output::help] 	Help::help: Too long...
[          clap::output::help] 	No
[          clap::output::help] 	Help::write_after_help
[           clap::output::fmt] 	is_a_tty: stderr=true</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: bug</span> added by @tobx on 2021-10-11 12:35</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-10-11 13:33</div>
            <div class="timeline-body"><p>I've added an arg to your example:</p>
<pre><code class="language-rust">use clap::Clap;

#[derive(Clap)]
#[clap(name = &quot;test&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: SubCommand,
}

#[derive(Clap)]
enum SubCommand {
    Test(Test),
}

#[derive(Clap)]
struct Test {
    #[clap(long)]
    arg: String,
}

fn main() {
    Opts::parse();
}
</code></pre>
<p>In this, both <code>--arg</code> and the subcommand are required.  As-represented, there is no alternative; for us to construct an <code>Opts</code>; we have to populate the <code>subcmd</code> and <code>arg</code> fields with something.</p>
<p>What you can do is:</p>
<pre><code class="language-rust">use clap::Clap;

#[derive(Clap)]
#[clap(name = &quot;test&quot;)]
struct Opts {
    #[clap(subcommand)]
    subcmd: Option&lt;SubCommand&gt;,
}

#[derive(Clap)]
enum SubCommand {
    Test(Test),
}

#[derive(Clap)]
struct Test {
    #[clap(long)]
    arg: Option&lt;String&gt;,
}

fn main() {
    Opts::parse();
}
</code></pre>
<p>Now <code>Opts</code> can be constructed without the user selecting a subcmd or an arg.  <code>clap_derive</code> takes advantage of this to use it as a way of specifying an argument is not required.</p>
<p>There is another way of allowing non-required arguments, but not subcommands, defaults</p>
<pre><code class="language-rust">#[derive(Clap)]
struct Test {
    #[clap(long, default_value_t)]
    arg: String,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tobx">@tobx</a> on 2021-10-11 13:37</div>
            <div class="timeline-body"><p>I just tried if I can just set <code>Option&lt;SubCommand&gt;</code> and wanted to close the issue, but you were faster, thank you for the detailed answer.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @tobx on 2021-10-11 13:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Locked by @clap-rs on 2021-10-11 14:05</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:34:39 UTC
    </footer>
</body>
</html>
