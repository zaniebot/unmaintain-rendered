<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Custom collections - clap-rs/clap #3114</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Custom collections</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/clap-rs/clap/issues/3114">#3114</a>
        opened by <a href="https://github.com/epage">@epage</a>
        on 2021-12-09 16:10
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/epage">@epage</a></div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="96" height="96" hspace="10"></img></a> <strong>Issue by <a href="https://github.com/vorner">vorner</a></strong>
<em>Friday Mar 09, 2018 at 11:20 GMT</em>
<em>Originally opened as https://github.com/TeXitoi/structopt/issues/79</em></p>
<hr />
<p>Hello</p>
<p>I discovered I'm missing one use case of command line parsing. Something like the <code>-D</code> parameter of GCC, where you can do <code>-D NDEBUG=1</code> ‒ basically way to parse key-value pairs.</p>
<p>I'm not sure if there needs to be some support from clap, but AFAIK clap just returns bunch of strings for each parameter (if multiple are allowed) and type-conversion is up to structop.</p>
<p>So I was wondering, similar as structopt provides <code>Vec&lt;T&gt;</code>, it could be extended to either <code>Vec&lt;(Key, Value)&gt;</code> or <code>HashMap/BTreeMap&lt;Key, Value&gt;</code>.</p>
<p>Does that make sense? Or is a better place to add such feature?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Friday Mar 09, 2018 at 15:58 GMT</em></p>
<hr />
<p>You can do https://github.com/TeXitoi/structopt/blob/master/examples/keyvalue.rs</p>
<p>It may be interesting to be able to choose to use a dedicated collection, but that's really not trivial to propose a great syntax. Maybe something like:</p>
<pre><code class="language-rust">fn parse_key_val(s: &amp;str) -&gt; Result&lt;(String, String), String&gt; {
    unimplemented!()
}
struct Opt {
    #[structopt(short = &quot;D&quot;, collect(try_from_str = &quot;parse_key_val&quot;))]
    defines: HashMap&lt;String, String&gt;,
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/vorner">vorner</a></strong>
<em>Friday Mar 09, 2018 at 16:43 GMT</em></p>
<hr />
<p>I understand I can „force“ it to do what I want with custom functions and so on. My point was more about if structopt should be able to handle these out of the box. If there should be a way for it to recognize these other collections (sets could be easy) and do The Right Thing.</p>
<p>But I admit I don't have a concrete idea how that should work exactly ‒ because I might want to specify how the separator looks like, or how to specify the parser for both left and right side. Maybe having a special-case of <code>(String, T)</code> and the parser would be for the right side only (as one part of the solution) and recognizing other collections other than Vec (trivial for sets, rewriting to parsing tuples for maps).</p>
<p>Anyway, that's mostly brainstorming.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Friday Mar 09, 2018 at 16:58 GMT</em></p>
<hr />
<p>As structopt works at the macro level, there is no type information. You can't check if some type implement <code>FromIterator</code>, as I can't check if some type implement <code>From&lt;OsStr&gt;</code>. Thus only black magic can do that, and I don't want black magic in structopt.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/vorner">vorner</a></strong>
<em>Saturday Mar 10, 2018 at 07:58 GMT</em></p>
<hr />
<p>I understand you can't check if the type implements <code>FromIterator</code> or something. But still, it is possible to check for concrete types. I wasn't really thinking about black magic. There's a special case for <code>Option&lt;T&gt;</code> and for <code>Vec&lt;T&gt;</code> (there must be ‒ it sets options on clap), so I was thinking it would be possible to special-case <code>HashSet&lt;T&gt;</code> and <code>BTreeSet&lt;T&gt;</code> in the exactly same way as <code>Vec&lt;T&gt;</code> and <code>HashMap&lt;String, T&gt;</code>, <code>BTreeMap&lt;String, T&gt;</code>, <code>Vec&lt;(String, T)&gt;</code> with the key-value parsing. If you wanted, I could give it a try… but I don't have much free time, so it would be a while before I get to it.</p>
<p>I understand having many special cases isn't good for the code. So if that wouldn't look good, does it make sense to provide some common parser functions as part of the library, so one could reuse them instead of implementing (I'm talking about the one from the example). The <code>collect(parser_fn)</code> thing didn't look bad either.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/pksunkara"><img src="https://avatars.githubusercontent.com/u/174703?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/pksunkara">pksunkara</a></strong>
<em>Friday Jan 17, 2020 at 18:59 GMT</em></p>
<hr />
<p>What about adding support for <code>HashMap&lt;K,V&gt;</code> in clap? Wouldn't that be a better solution?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Saturday Jan 18, 2020 at 12:12 GMT</em></p>
<hr />
<p>I'm not a big fun of specializing types that are not in <code>prelude</code>. Specializing in proc-macros has it's own drawbacks.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Saturday Jan 18, 2020 at 12:23 GMT</em></p>
<hr />
<p>I agree, and I'd prefere to support all the collections implementing FromIterator.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Saturday Jan 18, 2020 at 12:43 GMT</em></p>
<hr />
<p>Hey, @TeXitoi , care to join https://rust-lang.zulipchat.com/#narrow/stream/220302-wg-cli ?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/pickfire"><img src="https://avatars.githubusercontent.com/u/4687791?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/pickfire">pickfire</a></strong>
<em>Sunday Mar 29, 2020 at 14:17 GMT</em></p>
<hr />
<p>Any news on this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Sunday Mar 29, 2020 at 14:26 GMT</em></p>
<hr />
<p>No, nothing new AFAIK.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/pickfire"><img src="https://avatars.githubusercontent.com/u/4687791?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/pickfire">pickfire</a></strong>
<em>Sunday Mar 29, 2020 at 14:45 GMT</em></p>
<hr />
<p>@TeXitoi Can the automatic <code>Vec</code> handling act like a fallback so the parsing functions for <code>try_parse_str</code> could return <code>Result&lt;Vec&lt;T&gt;, E&gt;</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Sunday Mar 29, 2020 at 14:46 GMT</em></p>
<hr />
<p>@pickfire Could you explain what you mean? A piece of pseudocode would help a lot</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/pickfire"><img src="https://avatars.githubusercontent.com/u/4687791?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/pickfire">pickfire</a></strong>
<em>Sunday Mar 29, 2020 at 15:35 GMT</em></p>
<hr />
<pre><code class="language-rust">#[derive(StructOpt)]
struct Opt {
    #[structopt(..., try_from_str = parse_format_string)]
    // without format: Format,
    format: Vec&lt;Token&gt;,
}

// without fn parse_format_string(input: &amp;str) -&gt; Format {
fn parse_format_string(input: &amp;str) -&gt; Vec&lt;Token&gt; {
    ...
}

// without type Format = Vec&lt;Token&gt;;
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Sunday Mar 29, 2020 at 16:24 GMT</em></p>
<hr />
<p>This is not how validators in clap work: they check arguments one by one. <code>-&gt; Vec&lt;T&gt;</code> is not gonna work.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/pickfire"><img src="https://avatars.githubusercontent.com/u/4687791?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/pickfire">pickfire</a></strong>
<em>Sunday Mar 29, 2020 at 16:49 GMT</em></p>
<hr />
<p>No, I mean the function needs to return <code>Vec&lt;T&gt;</code> by just using one argument, like separating <code>,</code> or parsing a string into list of tokens.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:10</div>
            <div class="timeline-body"><p><a href="https://github.com/rustonaut"><img src="https://avatars.githubusercontent.com/u/7632017?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/rustonaut">rustonaut</a></strong>
<em>Tuesday Jan 12, 2021 at 01:16 GMT</em></p>
<hr />
<p>I believe a solution to &quot;custom&quot; collections should:</p>
<ul>
<li>Allow different kinds of collections including map and set, but also custom data types.</li>
<li>Allow custom parsing value parsing (potentially splitting values in one or even multiple key
value pairs)</li>
<li>Allow deciding how duplicate keys are handled (for a map collection). Should they replace the old value, error or merge the values for the same key in some manner.</li>
</ul>
<p>I think a good idea would be to first initialize a empty container (using some <code>default</code> like mechanism) and then fold all occurrences of given argument (value) into the empty container with a fallible folding function.</p>
<p>For example something like following rust <em>sketch</em>:</p>
<pre><code class="language-rust">use thiserror::Error;
use std::collections::HashMap;

[derive(Debug, StructOpt)[
struct Options {
    #[structopt(
        short=&quot;k&quot;,
        // implies takes_value=true,multiple=true
        try_fold(fold_kv_map),
    )]
    kv_map: HashMap&lt;String, String&gt;
}

fn fold_kv_map(
    mut state: HashMap&lt;String, String&gt;,
    raw: &amp;str
) -&gt; Result&lt;HashMap&lt;String, String&gt;, Error&gt; {
    let (key, value) = parse_key_value(raw)?;
    let old = state.insert(key.to_owned(), value.to_owned());
    if old.is_some() {
        Err(Error::DuplicateKey { key: key.to_owned() })
    } else {
        Ok(state)
    }
}

#[derive(Debug, Error)]
enum Error {
    #[error(&quot;...&quot;)]
    MalformedKVPair,
    #[error(&quot;...&quot;)]
    DuplicateKey { key: String }
}
</code></pre>
<p>By default <code>Default::default()</code> is used to create the initial folding value.</p>
<p>Alternatively something like:</p>
<p><code>#[structopt(try_fold(init=create_container, fold_kv_map)]</code></p>
<p>To not rely on <code>Default::default()</code>.</p>
<p>EDIT: Shortened sketch example.</p>
<hr />
<p>I myself have run recently into this issue when I needed arguments like <code>-k key:v1,v2 -k key2:v1,v4 -k key3</code> mapping to <code>HashMap&lt;String, Vec&lt;String&gt;&gt;</code> (with some parts like combining duplicate keys) which wouldn't nicely resolve with a   <code>FromIterator</code> based approach. As far as I can tell a folding based approach covers more or less all potential use cases, it's even usable with some <code>Settings: Default</code> struct with isn't a collection in the classical sense (not that you would normally need that).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-derive</span> added by @epage on 2021-12-09 16:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-09 16:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-triage</span> added by @epage on 2021-12-13 22:38</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/stevefan1999-personal">@stevefan1999-personal</a> on 2022-06-17 09:22</div>
            <div class="timeline-body"><p>This is a pretty good feature, as we can use it for directly deriving set relations with multiple values.</p>
<p>Right now I have iterate through the vector then collect them as HashSet/BTreeSet which incurs extra allocation cost, although some may argue I can just use into_iter to consume the vector, this is not ergonomic to manually do this all the time from my perspective.</p>
<p>Also, having set support would let us have a nice little feature to preempt errors early about duplicated values, by first cloning the vector (or the iterator) and then cast it into a set data structure.</p>
<p>Thanks to set theory, if the length of both container doesn't match, there must be duplicates. Based off this we can have more optimization opportunities such as saving the length of the original vector and then convert it into a set directly.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-triage</span> removed by @epage on 2022-11-08 04:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-waiting-on-design</span> added by @epage on 2022-11-08 04:57</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/valkum">@valkum</a> on 2023-02-13 16:35</div>
            <div class="timeline-body"><p>I came up with the following solution for supporting a custom collection (even a little bit more advanced).
Sadly, it requires a lot of manual implementations. Derive support would be really nice. Maybe allow the exclusion of the generation of the <code>FromArgMatches</code> impl and support for defining parse-time intermediate types (multiple occurrences end up in a Vec internally, so it makes sense to not have the final collection type stored in this internal Vec).</p>
<p>https://play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=d2e25bdbfebd50d941b16a11cc1cd0c4</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-02-13 16:54</div>
            <div class="timeline-body"><blockquote>
<p>Sadly, it requires a lot of manual implementations. Derive support would be really nice</p>
</blockquote>
<p>The first step for general support is defining how users interact with it.  Ideally, we'd just leverage <code>FromIterator</code> on types but we'd need to know when to use <code>remove_many</code> + <code>FromIterator</code> instead of <code>remove_one</code> as currently the use of <code>remove_many</code> is controlled by the type being a <code>Vec</code>.</p>
<p>Maybe #3912 or #4626 could help</p>
<blockquote>
<p>Maybe allow the exclusion of the generation of the FromArgMatches impl</p>
</blockquote>
<p>You are welcome to create an API proposal for this</p>
<blockquote>
<p>support for defining parse-time intermediate types (multiple occurrences end up in a Vec internally, so it makes sense to not have the final collection type stored in this internal Vec).</p>
</blockquote>
<p>This would be more of an optimization than anything else.  I think it would be great to do eventually but it will be a lot of work and can come at the risk (depending on the implementation) of losing support for things like <a href="https://docs.rs/clap/latest/clap/builder/struct.Arg.html#method.requires_if"><code>requires_if</code></a> and friends</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/4626.html">clap-rs/clap#4626</a> on 2023-02-13 18:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/domenkozar">@domenkozar</a> on 2024-02-29 09:02</div>
            <div class="timeline-body"><p>It would be great if I could parse <code>--option key value --option key value</code> into <code>HashMap&lt;String, String&gt;</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kriswuollett">@kriswuollett</a> on 2024-11-15 11:39</div>
            <div class="timeline-body"><blockquote>
<p><a href="https://github.com/TeXitoi"><img alt="" width="48" height="48" src="https://avatars.githubusercontent.com/u/5787066?v=4"></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong> <em>Friday Mar 09, 2018 at 15:58 GMT</em></p>
<p>You can do https://github.com/TeXitoi/structopt/blob/master/examples/keyvalue.rs</p>
<p>It may be interesting to be able to choose to use a dedicated collection, but that's really not trivial to propose a great syntax. Maybe something like:</p>
<pre><code class="language-rust">fn parse_key_val(s: &amp;str) -&gt; Result&lt;(String, String), String&gt; {
    unimplemented!()
}
struct Opt {
    #[structopt(short = &quot;D&quot;, collect(try_from_str = &quot;parse_key_val&quot;))]
    defines: HashMap&lt;String, String&gt;,
}
</code></pre>
</blockquote>
<p>Is deciding on a specific collection type, or allowing for customization, even necessary? Are there performance constraints for command-line parsing that discourage the requirement to move values from say a <code>HashMap</code> to a <code>BTreeMap</code> if the downstream app prefers? Let alone for those that want a <code>Vec&lt;(String, String)&gt;</code> instead for multi-value.</p>
<p>Isn't <code>ArgMatches</code> a collection? The <code>--map=key=value</code> / <code>--map key=value</code>  / <code>--map key value</code> arguments look to me as a different way of encoding arguments to what <code>clap</code> calls a <code>Command</code>. From a near-term pragmatic point of view, there could be a <code>ArgMatchesValueParser</code> which is built literally from a <code>Command</code>. Probably behind a feature flag if distributed by <code>clap</code> itself to somewhat discourage usage until and if some better design is proposed. But at least it would evolve in sync with the rest of the code.</p>
<p>As a user I still would probably want a simple string map value parser behind a feature flag to avoid copy and pasting the example in projects if validation isn't necessary or possible at command line argument parsing time.</p>
<p>Longer term if the idea makes sense, it seems that some refactoring would be involved, but I don't have an idea nor opinion on how <code>clap</code> would represent what you could say in another programming language that something called like an <code>OptionList</code> is a subclass of <code>Command</code>, and <code>OptionMatches</code> is a subclass of <code>ArgMatches</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2024-11-15 19:29</div>
            <div class="timeline-body"><blockquote>
<p>Is deciding on a specific collection type, or allowing for customization, even necessary? Are there performance constraints for command-line parsing that discourage the requirement to move values from say a HashMap to a BTreeMap if the downstream app prefers? Let alone for those that want a Vec&lt;(String, String)&gt; instead for multi-value.</p>
</blockquote>
<p>We have baked in <code>Vec</code> today.  Other types could be useful in terms of (1) being more natural to express for their application or (2) better fitting their application domain.</p>
<blockquote>
<p>Isn't ArgMatches a collection? The --map=key=value / --map key=value / --map key value arguments look to me as a different way of encoding arguments to what clap calls a Command. From a near-term pragmatic point of view, there could be a ArgMatchesValueParser which is built literally from a Command. Probably behind a feature flag if distributed by clap itself to somewhat discourage usage until and if some better design is proposed. But at least it would evolve in sync with the rest of the code.</p>
</blockquote>
<p><code>ArgMatches</code> has a tight relationship to the parser and would be difficult to generalize.  If you are suggesting user-provided <code>ArgMatchesValueParser</code>, then that would also be a very heavy-handed solution for what is being discussed here.  If you are suggesting the derive generate the implemetnation to cut out the <code>ArgMatches</code> middleman, that is an interesting idea but we would still need a solution for how to populate the users fields.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-12 17:48:15 UTC
    </footer>
</body>
</html>
