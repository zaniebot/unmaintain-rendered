<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Allow specifying types for arguments - clap-rs/clap #818</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Allow specifying types for arguments</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/818">#818</a>
        opened by <a href="https://github.com/quodlibetor">@quodlibetor</a>
        on 2017-01-18 14:13
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/quodlibetor">@quodlibetor</a></div>
            <div class="timeline-body"><p>Feature discussion/request: add something like Python&#x27;s <a href="http://click.pocoo.org/5/parameters/#parameter-types">click library&#x27;s &quot;types&quot;</a>.</p>
<p>There are two big reasons to do this:</p>
<ul>
<li>It could be used to unify/specify the conversion and validation logic that would be necessary for auto-derived apps or apps with differently-typed matches (mentioned in #817 and #146, #459, maybe some others)</li>
<li>It would allow types to define how they generate auto-completion behavior for the various shells that clap supports[1].</li>
</ul>
<p>It seems like a:</p>
<pre><code>trait ParamType {
    type Into;

    fn convert(&amp;self) -&gt; Result&lt;Self::Into, [some::click::error]&gt;;

    fn shell_complete(option_name: Optiona&lt;&amp;str&gt;,
                      parameter_name: Option&lt;&amp;str&gt;) -&gt; Option&lt;String&gt; {
        parameter_name
    }

    fn zsh_complete() -&gt; String {
        Self::shell_complete()
    }

    // etc
}
</code></pre>
<p>Might be a good-enough start.</p>
<p>1: Maybe this should be a separate bug, but: it&#x27;s <em>mildly</em> annoying that ripgrep&#x27;s auto-completion behavior (in zsh) is as follows:</p>
<pre><code>$ rg &lt;TAB&gt;
$ rg PAT
$ rg PAT&lt;TAB&gt;
PATH     -- A file or directory to search.
PATTERN  -- A regular expression used for searching.
</code></pre>
<p>And in particular that once I&#x27;ve got part of the path that I want to search it refuses to complete it, so I have this behavior:</p>
<pre><code>$ ls
$ tmp
$ rg t&lt;TAB&gt;     # error
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-01-19 01:29</div>
            <div class="timeline-body"><p>I agree that custom shell completion is needed, which is the discussion for #568 but I think these three issues (type conversion for args, stringly typed arg keys, and custom shell completions) are separate issues that I wouldn&#x27;t want to mix.</p>
<p>I&#x27;ll expand a little bit.</p>
<hr>
Type Conversions
<p>This can already be done via macros (<a href="https://docs.rs/clap/2.20.0/clap/macro.value_t.html"><code>value_t!</code></a> and <a href="https://docs.rs/clap/2.20.0/clap/macro.value_t_or_exit.html"><code>value_t_or_exit!</code></a>, plus plurals) or manually (via the <a href="https://doc.rust-lang.org/std/str/trait.FromStr.html"><code>std::str::FromStr</code></a> trait). The problem is manually defining all these conversions is painful and time consuming. As you correctly pointed out, #146 aims to do this with a single <code>#[derive()]</code> directive to remove those pain points).</p>
<p>IMO, but I&#x27;m up for discussion, <code>clap</code> doesn&#x27;t need to provide any traits for this because it can already be done with <code>FromStr</code>|<code>From</code>|<code>Into</code>. <code>clap</code> would need to <em>return</em> the type <code>T</code>, but that isn&#x27;t possible today:</p>
<pre><code>fn value_of(&amp;self, arg: &amp;str) -&gt; T {
   // ...
}
</code></pre>
<p>Unless I&#x27;m misunderstanding what you&#x27;re asking for. What I&#x27;d like to do is provide a way someone to either specify upfront what the type is (thing something like a functional <code>Arg::type::&lt;T&gt;()</code> ), or simply infer the type from the name or something <code>int_foo</code> and use one of these two to do the converting for you upon converting <code>ArgMatches</code> into something else, such as <code>Args</code> as discussed in #817 using <code>From&lt;ArgMatches&gt;</code>.</p>
<p>The point being all the work is done for you, minus maybe specifying the type, which isn&#x27;t any worse than what you&#x27;re already doing by specifying the parameters for the arg.</p>
<p>This should look something like</p>
<pre><code>#[derive(FromMatches)]
struct Args {
    num: u64
}

// ---

let args: Args = matches.into();
if args.num &gt; 28 { /* do stuff */ }

// Instead of
if matches.value_of(&quot;num&quot;).unwrap() &gt; 27 { /* do stuff */ }
</code></pre>
Stringly Typed Arg Keys
<p>This can be done today by using enums and impl&#x27;ing <code>AsRef&lt;str&gt;</code> for said enum. The problem again is it&#x27;s painful and tedious to do by hand. I had a branch which did this via a macro, but with Macros 1.1 quickly arriving I&#x27;m waiting in order to use another <code>#[derive()]</code> directive and make this even easier.</p>
<p>It will look like:</p>
<pre><code>#[derive(ArgKey)]
enum Foo {
    Bar,
    Baz,
    Qux
}

// ---

let value = matches.value_of(Foo::Baz);
</code></pre>
<p>Which has a huge benefit of compile time checking of keys and one of biggest pain points of <code>clap</code>. This is all discussed in #459 like you said.</p>
Custom Shell Completion
<p>As discussed in #568 this is something I really want. But unlike the two above, there really isn&#x27;t a way to do this today. When I originally wrote the shell completions portions of <code>clap</code> I was expecting they&#x27;d be used as a starting point for people to further customize, but it turns out shell completions are hard and <code>clap</code> gets close enough that it&#x27;s not really worth the extra effort since you&#x27;d have to stay in sync with changes to your CLI and the nice thing about <code>clap</code> generating it for you, is you&#x27;re never out of sync. A catch 22.</p>
<p>The problem with implementing this is I just haven&#x27;t had a good time to sit down and think about <em>how</em> (because of work, holidays, family, etc.). I want a way to specify this that abstracts well enough to work for all shells. The easiest way is to say, &quot;Put your arbitrary completion shell script here inside this <code>Arg::complete_with(&amp;str)</code>&quot; but that feels super hacky to me, and potentially unsafe. What I&#x27;d like to do is provide a <code>Arg::complete_with(Fn(&amp;str, &amp;str)-&gt;String)</code> (and a <code>Arg::complete_with_os(Fn(&amp;str,&amp;OsStr)-&gt;OsString)</code> where an arbitrary Rust function is called...but herein lies the problem; shell completions are run <em>before</em> the program executes. This has led to some people using hidden args or something like, <code>$ prog --complete me&lt;tab&gt;</code> calling a shell completer that actually runs <code>$ prog --_complete_arg &quot;complete&quot; --_complete_prefix &quot;me&quot;</code> which generates the possible completions and returns them to the shell. I&#x27;m not against doing that, but again feels strange because you&#x27;re injecting hidden args into a CLI. Although typing this out right now does make me lean towards this solution.</p>
<hr>
<p>Sorry for the long discussion, but please let me know if I&#x27;m off on any bases.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> added by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-01-19 01:29</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap#568</a> on 2017-01-19 01:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;3.0&quot; by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-01-30 04:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-01-30 05:06</div>
            <div class="timeline-body"><p>I&#x27;m going to close this issue since it&#x27;s covered by individual other issues. Please let me know if it needs to be re-opened for something outside the issues listed above.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-01-30 05:06</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:56:44 UTC
    </footer>
</body>
</html>
