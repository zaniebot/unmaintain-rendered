<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>clap::parser::Values enters unreachable code if used inside zip and reversed - clap-rs/clap #4870</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>clap::parser::Values enters unreachable code if used inside zip and reversed</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/4870">#4870</a>
        opened by <a href="https://github.com/nappa85">@nappa85</a>
        on 2023-04-29 18:42
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/nappa85">@nappa85</a> on 2023-04-29 18:42</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Rust Version</h3>
<p>1.69.0</p>
<h3>Clap Version</h3>
<p>4.2.5</p>
<h3>Minimal reproducible code</h3>
<pre><code class="language-rust">use clap::{
    error::ErrorKind, value_parser, Arg, ArgAction, ArgMatches, Args, Command, Error,
    FromArgMatches, Parser,
};

#[derive(Debug, Parser)]
struct Opt {
    #[clap(flatten)]
    groups: OptGroups,
}

#[derive(Debug)]
struct OptGroups {
    groups: Vec&lt;OptGroup&gt;,
}

#[derive(Debug)]
struct OptGroup {
    aopt: usize,
    bopt: Option&lt;usize&gt;,
    copt: usize,
}

impl Args for OptGroups {
    fn augment_args(cmd: Command) -&gt; Command {
        cmd.arg(
            Arg::new(&quot;aopt&quot;)
                .short('a')
                .long(&quot;aopt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new(&quot;bopt&quot;)
                .short('b')
                .long(&quot;bopt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new(&quot;copt&quot;)
                .short('c')
                .long(&quot;copt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
    }
    fn augment_args_for_update(cmd: Command) -&gt; Command {
        cmd.arg(
            Arg::new(&quot;aopt&quot;)
                .short('a')
                .long(&quot;aopt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new(&quot;bopt&quot;)
                .short('b')
                .long(&quot;bopt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new(&quot;copt&quot;)
                .short('c')
                .long(&quot;copt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
    }
}

impl FromArgMatches for OptGroups {
    fn from_arg_matches(matches: &amp;ArgMatches) -&gt; Result&lt;Self, Error&gt; {
        let mut matches = matches.clone();
        Self::from_arg_matches_mut(&amp;mut matches)
    }
    fn from_arg_matches_mut(matches: &amp;mut ArgMatches) -&gt; Result&lt;Self, Error&gt; {
        let mut this = Self { groups: vec![] };
        this.update_from_arg_matches_mut(matches)?;
        Ok(this)
    }
    fn update_from_arg_matches(&amp;mut self, matches: &amp;ArgMatches) -&gt; Result&lt;(), Error&gt; {
        let mut matches = matches.clone();
        self.update_from_arg_matches_mut(&amp;mut matches)
    }
    fn update_from_arg_matches_mut(&amp;mut self, matches: &amp;mut ArgMatches) -&gt; Result&lt;(), Error&gt; {
        // collect tuples (index, value) for aopt
        let mut aopt_indices = matches
            .indices_of(&quot;aopt&quot;)
            .map(|i| i.collect::&lt;Vec&lt;_&gt;&gt;())
            .zip(matches.remove_many(&quot;aopt&quot;))
            //.zip(matches.remove_many(&quot;aopt&quot;).map(|m| m.collect::&lt;Vec&lt;_&gt;&gt;()))
            .map(|(i, m)| i.into_iter().zip(m).rev().collect::&lt;Vec&lt;_&gt;&gt;());
        // collect tuples (index, value) for bopt
        let mut bopt_indices = matches
            .indices_of(&quot;bopt&quot;)
            .map(|i| i.collect::&lt;Vec&lt;_&gt;&gt;())
            .zip(matches.remove_many(&quot;bopt&quot;))
            //.zip(matches.remove_many(&quot;bopt&quot;).map(|m| m.collect::&lt;Vec&lt;_&gt;&gt;()))
            .map(|(i, m)| i.into_iter().zip(m).rev().collect::&lt;Vec&lt;_&gt;&gt;());
        // collect tuples (index, value) for copt
        let Some(copt_indices) = matches
            .indices_of(&quot;copt&quot;)
            .map(|i| i.collect::&lt;Vec&lt;_&gt;&gt;())
            .zip(matches.remove_many(&quot;copt&quot;))
            .map(|(i, m)| i.into_iter().zip(m).collect::&lt;Vec&lt;_&gt;&gt;()) else {
                if aopt_indices.is_some() || bopt_indices.is_some() {
                    return Err(Error::new(ErrorKind::InvalidSubcommand));
                }
                else {
                    return Ok(());
                }
            };

        // for every copt, find previous aopt and bopt
        let mut prev_copt_index = 0;
        for (copt_index, copt) in copt_indices {
            let aopt = if let Some(indices) = &amp;mut aopt_indices {
                if let Some((index, _)) = indices.last() {
                    if *index &gt; copt_index || *index &lt; prev_copt_index {
                        None
                    } else {
                        indices.pop().map(|(_, v)| v)
                    }
                } else {
                    None
                }
            } else {
                None
            };
            let bopt = if let Some(indices) = &amp;mut bopt_indices {
                if let Some((index, _)) = indices.last() {
                    if *index &gt; copt_index || *index &lt; prev_copt_index {
                        None
                    } else {
                        indices.pop().map(|(_, v)| v)
                    }
                } else {
                    None
                }
            } else {
                None
            };
            self.groups.push(OptGroup {
                aopt: aopt.unwrap_or_default(),
                bopt,
                copt,
            });
            prev_copt_index = copt_index;
        }

        // if there are remaining aopt or bopt we have an invalid syntax
        if aopt_indices.as_ref().map(Vec::is_empty) == Some(false)
            || bopt_indices.as_ref().map(Vec::is_empty) == Some(false)
        {
            return Err(Error::new(ErrorKind::InvalidSubcommand));
        }

        Ok(())
    }
}

fn main() {
    println!(&quot;{:?}&quot;, Opt::parse());
}
</code></pre>
<h3>Steps to reproduce the bug with the above code</h3>
<pre><code class="language-bash">cargo run -- -a1 -b1 -c1 -c2 -b3 -c3
</code></pre>
<h3>Actual Behaviour</h3>
<p>thread 'main' panicked at 'internal error: entered unreachable code', /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/core/src/iter/adapters/zip.rs:206:5</p>
<h3>Expected Behaviour</h3>
<p>The application should not panic.</p>
<p>If you decomment the <code>.zip(matches.remove_many(&quot;Xopt&quot;))</code> lines and decomment the <code>.zip(matches.remove_many(&quot;Xopt&quot;).map(|m| m.collect::&lt;Vec&lt;_&gt;&gt;()))</code> lines, the application works correctly, but there should no be difference between the two</p>
<h3>Additional Context</h3>
<p>I was trying to implement the solution suggested in https://github.com/clap-rs/clap/discussions/3399</p>
<h3>Debug Output</h3>
<pre><code>[clap_builder::builder::command]Command::_do_parse
[clap_builder::builder::command]Command::_build: name=&quot;clap-test&quot;
[clap_builder::builder::command]Command::_propagate:clap-test
[clap_builder::builder::command]Command::_check_help_and_version:clap-test expand_help_tree=false
[clap_builder::builder::command]Command::long_help_exists
[clap_builder::builder::command]Command::_check_help_and_version: Building default --help
[clap_builder::builder::command]Command::_propagate_global_args:clap-test
[clap_builder::builder::debug_asserts]Command::_debug_asserts
[clap_builder::builder::debug_asserts]Arg::_debug_asserts:aopt
[clap_builder::builder::debug_asserts]Arg::_debug_asserts:bopt
[clap_builder::builder::debug_asserts]Arg::_debug_asserts:copt
[clap_builder::builder::debug_asserts]Arg::_debug_asserts:help
[clap_builder::builder::debug_asserts]Command::_verify_positionals
[clap_builder::parser::parser]Parser::get_matches_with
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-a1&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-a1&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;a1&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['a', '1']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:a
[clap_builder::parser::parser]Parser::parse_short_arg:iter:a: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:a: val=&quot;1&quot;, short_arg=ShortFlags { inner: &quot;a1&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['1']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=aopt, val=Some(&quot;1&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=1
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;aopt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;aopt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;aopt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;1&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=2
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=aopt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-a2&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-a2&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;a2&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['a', '2']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:a
[clap_builder::parser::parser]Parser::parse_short_arg:iter:a: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:a: val=&quot;2&quot;, short_arg=ShortFlags { inner: &quot;a2&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['2']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=aopt, val=Some(&quot;2&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=3
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;aopt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;aopt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;aopt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;2&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=4
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=aopt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-b1&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-b1&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;b1&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['b', '1']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:b
[clap_builder::parser::parser]Parser::parse_short_arg:iter:b: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:b: val=&quot;1&quot;, short_arg=ShortFlags { inner: &quot;b1&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['1']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=bopt, val=Some(&quot;1&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=5
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;bopt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;bopt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;bopt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;1&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=6
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=bopt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-c1&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-c1&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;c1&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['c', '1']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c: val=&quot;1&quot;, short_arg=ShortFlags { inner: &quot;c1&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['1']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=copt, val=Some(&quot;1&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=7
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;copt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;copt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;copt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;1&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=8
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=copt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-c2&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-c2&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;c2&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['c', '2']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c: val=&quot;2&quot;, short_arg=ShortFlags { inner: &quot;c2&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['2']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=copt, val=Some(&quot;2&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=9
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;copt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;copt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;copt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;2&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=10
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=copt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-b3&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-b3&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;b3&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['b', '3']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:b
[clap_builder::parser::parser]Parser::parse_short_arg:iter:b: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:b: val=&quot;3&quot;, short_arg=ShortFlags { inner: &quot;b3&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['3']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=bopt, val=Some(&quot;3&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=11
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;bopt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;bopt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;bopt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;3&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=12
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=bopt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::get_matches_with: Begin parsing '&quot;-c3&quot;'
[clap_builder::parser::parser]Parser::possible_subcommand: arg=Ok(&quot;-c3&quot;)
[clap_builder::parser::parser]Parser::get_matches_with: sc=None
[clap_builder::parser::parser]Parser::parse_short_arg: short_arg=ShortFlags { inner: &quot;c3&quot;, utf8_prefix: CharIndices { front_offset: 0, iter: Chars(['c', '3']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c: Found valid opt or flag
[clap_builder::parser::parser]Parser::parse_short_arg:iter:c: val=&quot;3&quot;, short_arg=ShortFlags { inner: &quot;c3&quot;, utf8_prefix: CharIndices { front_offset: 1, iter: Chars(['3']) }, invalid_suffix: None }
[clap_builder::parser::parser]Parser::parse_opt_value; arg=copt, val=Some(&quot;3&quot;), has_eq=false
[clap_builder::parser::parser]Parser::parse_opt_value; arg.settings=ArgFlags(NO_OP)
[clap_builder::parser::parser]Parser::parse_opt_value; Checking for val...
[clap_builder::parser::parser]Parser::react action=Append, identifier=Some(Short), source=CommandLine
[clap_builder::parser::parser]Parser::react: cur_idx:=13
[clap_builder::parser::parser]Parser::remove_overrides: id=&quot;copt&quot;
[clap_builder::parser::arg_matcher]ArgMatcher::start_custom_arg: id=&quot;copt&quot;, source=CommandLine
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;copt&quot;
[clap_builder::parser::parser]Parser::push_arg_values: [&quot;3&quot;]
[clap_builder::parser::parser]Parser::add_single_val_to_arg: cur_idx:=14
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: o=copt, pending=0
[clap_builder::parser::arg_matcher]ArgMatcher::needs_more_vals: expected=1, actual=0
[clap_builder::parser::parser]Parser::react not enough values passed in, leaving it to the validator to complain
[clap_builder::parser::parser]Parser::get_matches_with: After parse_short_arg ValuesDone
[clap_builder::parser::parser]Parser::add_defaults
[clap_builder::parser::parser]Parser::add_defaults:iter:aopt:
[clap_builder::parser::parser]Parser::add_default_value: doesn't have conditional defaults
[clap_builder::parser::parser]Parser::add_default_value:iter:aopt: doesn't have default vals
[clap_builder::parser::parser]Parser::add_defaults:iter:bopt:
[clap_builder::parser::parser]Parser::add_default_value: doesn't have conditional defaults
[clap_builder::parser::parser]Parser::add_default_value:iter:bopt: doesn't have default vals
[clap_builder::parser::parser]Parser::add_defaults:iter:copt:
[clap_builder::parser::parser]Parser::add_default_value: doesn't have conditional defaults
[clap_builder::parser::parser]Parser::add_default_value:iter:copt: doesn't have default vals
[clap_builder::parser::parser]Parser::add_defaults:iter:help:
[clap_builder::parser::parser]Parser::add_default_value: doesn't have conditional defaults
[clap_builder::parser::parser]Parser::add_default_value:iter:help: doesn't have default vals
[clap_builder::parser::validator]Validator::validate
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;aopt&quot;
[clap_builder::parser::validator]Conflicts::gather_direct_conflicts id=&quot;aopt&quot;, conflicts=[]
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;bopt&quot;
[clap_builder::parser::validator]Conflicts::gather_direct_conflicts id=&quot;bopt&quot;, conflicts=[]
[clap_builder::builder::command]Command::groups_for_arg: id=&quot;copt&quot;
[clap_builder::parser::validator]Conflicts::gather_direct_conflicts id=&quot;copt&quot;, conflicts=[]
[clap_builder::parser::validator]Validator::validate_conflicts
[clap_builder::parser::validator]Validator::validate_exclusive
[clap_builder::parser::validator]Validator::validate_exclusive:iter:&quot;aopt&quot;
[clap_builder::parser::validator]Validator::validate_exclusive:iter:&quot;bopt&quot;
[clap_builder::parser::validator]Validator::validate_exclusive:iter:&quot;copt&quot;
[clap_builder::parser::validator]Validator::validate_conflicts::iter: id=&quot;aopt&quot;
[clap_builder::parser::validator]Conflicts::gather_conflicts: arg=&quot;aopt&quot;
[clap_builder::parser::validator]Conflicts::gather_conflicts: conflicts=[]
[clap_builder::parser::validator]Validator::validate_conflicts::iter: id=&quot;bopt&quot;
[clap_builder::parser::validator]Conflicts::gather_conflicts: arg=&quot;bopt&quot;
[clap_builder::parser::validator]Conflicts::gather_conflicts: conflicts=[]
[clap_builder::parser::validator]Validator::validate_conflicts::iter: id=&quot;copt&quot;
[clap_builder::parser::validator]Conflicts::gather_conflicts: arg=&quot;copt&quot;
[clap_builder::parser::validator]Conflicts::gather_conflicts: conflicts=[]
[clap_builder::parser::validator]Validator::validate_required: required=ChildGraph([])
[clap_builder::parser::validator]Validator::gather_requires
[clap_builder::parser::validator]Validator::gather_requires:iter:&quot;aopt&quot;
[clap_builder::parser::validator]Validator::gather_requires:iter:&quot;bopt&quot;
[clap_builder::parser::validator]Validator::gather_requires:iter:&quot;copt&quot;
[clap_builder::parser::validator]Validator::validate_required: is_exclusive_present=false
[clap_builder::parser::arg_matcher]ArgMatcher::get_global_values: global_arg_vec=[]
thread 'main' panicked at 'internal error: entered unreachable code', /rustc/84c898d65adf2f39a5a98507f1fe0ce10a2b8dbc/library/core/src/iter/adapters/zip.rs:206:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by @nappa85 on 2023-04-29 18:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/nappa85">@nappa85</a> on 2023-04-29 19:44</div>
            <div class="timeline-body"><p>A more minimal reproducible code:</p>
<pre><code class="language-rust">use clap::{value_parser, Arg, ArgAction, Command};

fn main() {
    let mut matches = Command::new(&quot;myprog&quot;)
        .arg(
            Arg::new(&quot;aopt&quot;)
                .short('a')
                .long(&quot;aopt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new(&quot;bopt&quot;)
                .short('b')
                .long(&quot;bopt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .arg(
            Arg::new(&quot;copt&quot;)
                .short('c')
                .long(&quot;copt&quot;)
                .value_parser(value_parser!(usize))
                .action(ArgAction::Append),
        )
        .get_matches_from(vec![&quot;myprog&quot;, &quot;-a1&quot;, &quot;-b1&quot;, &quot;-c1&quot;, &quot;-c2&quot;, &quot;-b3&quot;, &quot;-c3&quot;]);

    let aopt = matches
        .indices_of(&quot;aopt&quot;)
        .expect(&quot;missing aopt indices&quot;)
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .into_iter()
        .zip(
            matches
                .remove_many::&lt;usize&gt;(&quot;aopt&quot;)
                .expect(&quot;missing aopt values&quot;),
        )
        .rev()
        .collect::&lt;Vec&lt;_&gt;&gt;();
    let bopt = matches
        .indices_of(&quot;bopt&quot;)
        .expect(&quot;missing bopt indices&quot;)
        .collect::&lt;Vec&lt;_&gt;&gt;()
        .into_iter()
        .zip(
            matches
                .remove_many::&lt;usize&gt;(&quot;bopt&quot;)
                .expect(&quot;missing bopt values&quot;),
        )
        .rev()
        .collect::&lt;Vec&lt;_&gt;&gt;();
    println!(&quot;{aopt:?} {bopt:?}&quot;);
}
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/4875.html">clap-rs/clap#4875</a> on 2023-05-02 18:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2023-05-02 19:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2023-05-02 19:08</div>
            <div class="timeline-body"><p>4.2.7is out with the fix</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:35:23 UTC
    </footer>
</body>
</html>
