<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>&quot;allow_hyphen_values&quot; absorbs short options (-f), but not long options (--flag) - clap-rs/clap #3880</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>&quot;allow_hyphen_values&quot; absorbs short options (-f), but not long options (--flag)</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/3880">#3880</a>
        opened by <a href="https://github.com/david0u0">@david0u0</a>
        on 2022-06-28 09:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header"><a href="https://github.com/david0u0">@david0u0</a></div>
            <div class="timeline-body">Please complete the following tasks
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
Rust Version
<p>rustc 1.60.0-nightly (88fb06a1f 2022-02-05)</p>
Clap Version
<p>3.1.8</p>
Minimal reproducible code
<pre><code>use clap::Parser;

#[derive(Parser, Debug)]
#[clap(disable_help_subcommand = true, args_override_self = true)]
pub enum Root {
    #[clap(allow_hyphen_values = true)]
    Run {
        #[clap(long, short)]
        flag: bool,
        #[clap(default_value = &quot;-&quot;)]
        query: String,
        #[clap(allow_hyphen_values = true)]
        args: Vec&lt;String&gt;,
    },
}

fn handle_args(s: &amp;str) -&gt; Root {
    Root::from_iter(s.split(&#x27; &#x27;))
}

fn extract(r: Root) -&gt; Vec&lt;String&gt; {
    match r {
        Root::Run {args, ..} =&gt; args
    }
}

fn main() {
    let root = handle_args(&quot;test run query -f&quot;);
    println!(&quot;{:?}&quot;, root);
    assert_eq!(extract(root), vec![&quot;-f&quot;]);

    let root = handle_args(&quot;test run query --flag&quot;);
    println!(&quot;{:?}&quot;, root);
    assert_eq!(extract(root), vec![&quot;--flag&quot;]); // &lt;- fail!!
}
</code></pre>
Steps to reproduce the bug with the above code
<p><code>cargo run</code></p>
<p>The second assert will fail</p>
Actual Behaviour
<p>With argument &quot;test run query --flag&quot;, the &quot;--flag&quot; will be treated as the option, instead of the positional argument</p>
<p>This seems be not consistent, because the short option &quot;-f&quot; will be treated as the positional argument</p>
Expected Behaviour
<p>Treat the long option as positional argument</p>
<p>Or treat the short option as option?</p>
Additional Context
<p><em>No response</em></p>
Debug Output
first
<p>[      clap::builder::command] 	Command::_do_parse
[      clap::builder::command] 	Command::_build: name=&quot;clap-hyphen&quot;
[      clap::builder::command] 	Command::_propagate:clap-hyphen
[      clap::builder::command] 	Command::_check_help_and_version: clap-hyphen
[      clap::builder::command] 	Command::_check_help_and_version: Removing generated version
[      clap::builder::command] 	Command::_propagate_global_args:clap-hyphen
[      clap::builder::command] 	Command::_propagate removing run&#x27;s help
[      clap::builder::command] 	Command::_propagate pushing help to run
[      clap::builder::command] 	Command::_derive_display_order:clap-hyphen
[      clap::builder::command] 	Command::_derive_display_order:run
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;run&quot;)&#x27; ([114, 117, 110])
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...1
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;run&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=Some(&quot;run&quot;)
[        clap::parser::parser] 	Parser::parse_subcommand
[         clap::output::usage] 	Usage::get_required_usage_from: incls=[], matcher=false, incl_last=true
[         clap::output::usage] 	Usage::get_required_usage_from: unrolled_reqs={}
[         clap::output::usage] 	Usage::get_required_usage_from: ret_val={}
[      clap::builder::command] 	Command::_build_subcommand Setting bin_name of run to &quot;test run&quot;
[      clap::builder::command] 	Command::_build_subcommand Setting display_name of run to &quot;clap-hyphen-run&quot;
[      clap::builder::command] 	Command::_build: name=&quot;run&quot;
[      clap::builder::command] 	Command::_propagate:run
[      clap::builder::command] 	Command::_check_help_and_version: run
[      clap::builder::command] 	Command::_check_help_and_version: Removing generated version
[      clap::builder::command] 	Command::_propagate_global_args:run
[      clap::builder::command] 	Command::_derive_display_order:run
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:flag
[clap::builder::debug_asserts] 	Arg::_debug_asserts:query
[clap::builder::debug_asserts] 	Arg::_debug_asserts:args
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::parse_subcommand: About to parse sc=run
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;query&quot;)&#x27; ([113, 117, 101, 114, 121])
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...1
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;query&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::split_arg_values; arg=query, val=RawOsStr(&quot;query&quot;)
[        clap::parser::parser] 	Parser::split_arg_values; trailing_values=false, DontDelimTrailingVals=false
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;-f&quot;)&#x27; ([45, 102])
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...2
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;-f&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::parse_short_arg: short_arg=ShortFlags { inner: RawOsStr(&quot;f&quot;), utf8_prefix: CharIndices { front_offset: 0, iter: Chars([&#x27;f&#x27;]) }, invalid_suffix: None }
[        clap::parser::parser] 	Parser::parse_short_args: positional at 2 allows hyphens
[        clap::parser::parser] 	Parser::get_matches_with: After parse_short_arg MaybeHyphenValue
[        clap::parser::parser] 	Parser::resolve_pending: id=query
[        clap::parser::parser] 	Parser::react action=StoreValue, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=query
[   clap::parser::arg_matcher] 	ArgMatcher::start_occurrence_of_arg: id=query
[      clap::builder::command] 	Command::groups_for_arg: id=query
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;query&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=1
[      clap::builder::command] 	Command::groups_for_arg: id=query
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=query, resolved=1, pending=0
[        clap::parser::parser] 	Parser::split_arg_values; arg=args, val=RawOsStr(&quot;-f&quot;)
[        clap::parser::parser] 	Parser::split_arg_values; trailing_values=true, DontDelimTrailingVals=false
[        clap::parser::parser] 	Parser::resolve_pending: id=args
[        clap::parser::parser] 	Parser::react action=StoreValue, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=args
[   clap::parser::arg_matcher] 	ArgMatcher::start_occurrence_of_arg: id=args
[      clap::builder::command] 	Command::groups_for_arg: id=args
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;-f&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=2
[      clap::builder::command] 	Command::groups_for_arg: id=args
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=args, resolved=1, pending=0
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:flag:
[        clap::parser::parser] 	Parser::add_default_value:iter:flag: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:flag: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:query:
[        clap::parser::parser] 	Parser::add_default_value:iter:query: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:query: has default vals
[        clap::parser::parser] 	Parser::add_default_value:iter:query: was used
[        clap::parser::parser] 	Parser::add_defaults:iter:args:
[        clap::parser::parser] 	Parser::add_default_value:iter:args: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:args: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[     clap::parser::validator] 	Validator::validate
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_exclusive:iter:query
[     clap::parser::validator] 	Validator::validate_exclusive:iter:args
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=query
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=query
[      clap::builder::command] 	Command::groups_for_arg: id=query
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=query, conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=args
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=args, conflicts=[]
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=args
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=args
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::gather_requires:iter:query
[     clap::parser::validator] 	Validator::gather_requires:iter:args
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[     clap::parser::validator] 	Validator::validate_required_unless
[     clap::parser::validator] 	Validator::validate_matched_args
[     clap::parser::validator] 	Validator::validate_matched_args:iter:query: vals=Flatten {
inner: FlattenCompat {
iter: Fuse {
iter: Some(
Iter(
[
[
AnyValue {
inner: alloc::string::String,
},
],
],
),
),
},
frontiter: None,
backiter: None,
},
}
[     clap::parser::validator] 	Validator::validate_arg_num_vals
[     clap::parser::validator] 	Validator::validate_arg_values: arg=&quot;query&quot;
[     clap::parser::validator] 	Validator::validate_arg_values: checking validator...
[     clap::parser::validator] 	good
[     clap::parser::validator] 	Validator::validate_arg_num_occurs: &quot;query&quot;=1
[     clap::parser::validator] 	Validator::validate_matched_args:iter:args: vals=Flatten {
inner: FlattenCompat {
iter: Fuse {
iter: Some(
Iter(
[
[
AnyValue {
inner: alloc::string::String,
},
],
],
),
),
},
frontiter: None,
backiter: None,
},
}
[     clap::parser::validator] 	Validator::validate_arg_num_vals
[     clap::parser::validator] 	Validator::validate_arg_values: arg=&quot;args&quot;
[     clap::parser::validator] 	Validator::validate_arg_values: checking validator...
[     clap::parser::validator] 	good
[     clap::parser::validator] 	Validator::validate_arg_num_occurs: &quot;args&quot;=1
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[     clap::parser::validator] 	Validator::validate
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[     clap::parser::validator] 	Validator::validate_required_unless
[     clap::parser::validator] 	Validator::validate_matched_args
[   clap::parser::arg_matcher] 	ArgMatcher::get_global_values: global_arg_vec=[help, help]</p>
second
<p>[      clap::builder::command] 	Command::_do_parse
[      clap::builder::command] 	Command::_build: name=&quot;clap-hyphen&quot;
[      clap::builder::command] 	Command::_propagate:clap-hyphen
[      clap::builder::command] 	Command::_check_help_and_version: clap-hyphen
[      clap::builder::command] 	Command::_check_help_and_version: Removing generated version
[      clap::builder::command] 	Command::_propagate_global_args:clap-hyphen
[      clap::builder::command] 	Command::_propagate removing run&#x27;s help
[      clap::builder::command] 	Command::_propagate pushing help to run
[      clap::builder::command] 	Command::_derive_display_order:clap-hyphen
[      clap::builder::command] 	Command::_derive_display_order:run
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;run&quot;)&#x27; ([114, 117, 110])
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...1
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;run&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=Some(&quot;run&quot;)
[        clap::parser::parser] 	Parser::parse_subcommand
[         clap::output::usage] 	Usage::get_required_usage_from: incls=[], matcher=false, incl_last=true
[         clap::output::usage] 	Usage::get_required_usage_from: unrolled_reqs={}
[         clap::output::usage] 	Usage::get_required_usage_from: ret_val={}
[      clap::builder::command] 	Command::_build_subcommand Setting bin_name of run to &quot;test run&quot;
[      clap::builder::command] 	Command::_build_subcommand Setting display_name of run to &quot;clap-hyphen-run&quot;
[      clap::builder::command] 	Command::_build: name=&quot;run&quot;
[      clap::builder::command] 	Command::_propagate:run
[      clap::builder::command] 	Command::_check_help_and_version: run
[      clap::builder::command] 	Command::_check_help_and_version: Removing generated version
[      clap::builder::command] 	Command::_propagate_global_args:run
[      clap::builder::command] 	Command::_derive_display_order:run
[clap::builder::debug_asserts] 	Command::_debug_asserts
[clap::builder::debug_asserts] 	Arg::_debug_asserts:flag
[clap::builder::debug_asserts] 	Arg::_debug_asserts:query
[clap::builder::debug_asserts] 	Arg::_debug_asserts:args
[clap::builder::debug_asserts] 	Arg::_debug_asserts:help
[clap::builder::debug_asserts] 	Command::_verify_positionals
[        clap::parser::parser] 	Parser::parse_subcommand: About to parse sc=run
[        clap::parser::parser] 	Parser::get_matches_with
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;query&quot;)&#x27; ([113, 117, 101, 114, 121])
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...1
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;query&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::split_arg_values; arg=query, val=RawOsStr(&quot;query&quot;)
[        clap::parser::parser] 	Parser::split_arg_values; trailing_values=false, DontDelimTrailingVals=false
[        clap::parser::parser] 	Parser::get_matches_with: Begin parsing &#x27;RawOsStr(&quot;--flag&quot;)&#x27; ([45, 45, 102, 108, 97, 103])
[        clap::parser::parser] 	Parser::get_matches_with: Positional counter...2
[        clap::parser::parser] 	Parser::get_matches_with: Low index multiples...false
[        clap::parser::parser] 	Parser::possible_subcommand: arg=Ok(&quot;--flag&quot;)
[        clap::parser::parser] 	Parser::get_matches_with: sc=None
[        clap::parser::parser] 	Parser::parse_long_arg
[        clap::parser::parser] 	Parser::parse_long_arg: Does it contain &#x27;=&#x27;...
[        clap::parser::parser] 	Parser::parse_long_arg: Found valid arg or flag &#x27;--flag&#x27;
[        clap::parser::parser] 	Parser::parse_long_arg(&quot;flag&quot;): Presence validated
[        clap::parser::parser] 	Parser::resolve_pending: id=query
[        clap::parser::parser] 	Parser::react action=StoreValue, identifier=Some(Index), source=CommandLine
[        clap::parser::parser] 	Parser::remove_overrides: id=query
[   clap::parser::arg_matcher] 	ArgMatcher::start_occurrence_of_arg: id=query
[      clap::builder::command] 	Command::groups_for_arg: id=query
[        clap::parser::parser] 	Parser::push_arg_values: [&quot;query&quot;]
[        clap::parser::parser] 	Parser::add_single_val_to_arg: cur_idx:=1
[      clap::builder::command] 	Command::groups_for_arg: id=query
[   clap::parser::arg_matcher] 	ArgMatcher::needs_more_vals: o=query, resolved=1, pending=0
[        clap::parser::parser] 	Parser::react action=IncOccurrence, identifier=Some(Long), source=CommandLine
[        clap::parser::parser] 	Parser::react: cur_idx:=2
[        clap::parser::parser] 	Parser::remove_overrides: id=flag
[        clap::parser::parser] 	Parser::remove_overrides:iter:flag: removing
[   clap::parser::arg_matcher] 	ArgMatcher::start_occurrence_of_arg: id=flag
[      clap::builder::command] 	Command::groups_for_arg: id=flag
[        clap::parser::parser] 	Parser::get_matches_with: After parse_long_arg ValuesDone
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:flag:
[        clap::parser::parser] 	Parser::add_default_value:iter:flag: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:flag: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:query:
[        clap::parser::parser] 	Parser::add_default_value:iter:query: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:query: has default vals
[        clap::parser::parser] 	Parser::add_default_value:iter:query: was used
[        clap::parser::parser] 	Parser::add_defaults:iter:args:
[        clap::parser::parser] 	Parser::add_default_value:iter:args: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:args: doesn&#x27;t have default vals
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[     clap::parser::validator] 	Validator::validate
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_exclusive:iter:query
[     clap::parser::validator] 	Validator::validate_exclusive:iter:flag
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=query
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=query
[      clap::builder::command] 	Command::groups_for_arg: id=query
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=query, conflicts=[]
[      clap::builder::command] 	Command::groups_for_arg: id=flag
[     clap::parser::validator] 	Conflicts::gather_direct_conflicts id=flag, conflicts=[flag]
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_conflicts::iter: id=flag
[     clap::parser::validator] 	Conflicts::gather_conflicts: arg=flag
[     clap::parser::validator] 	Conflicts::gather_conflicts: conflicts=[]
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::gather_requires:iter:query
[     clap::parser::validator] 	Validator::gather_requires:iter:flag
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[     clap::parser::validator] 	Validator::validate_required_unless
[     clap::parser::validator] 	Validator::validate_matched_args
[     clap::parser::validator] 	Validator::validate_matched_args:iter:query: vals=Flatten {
inner: FlattenCompat {
iter: Fuse {
iter: Some(
Iter(
[
[
AnyValue {
inner: alloc::string::String,
},
],
],
),
),
},
frontiter: None,
backiter: None,
},
}
[     clap::parser::validator] 	Validator::validate_arg_num_vals
[     clap::parser::validator] 	Validator::validate_arg_values: arg=&quot;query&quot;
[     clap::parser::validator] 	Validator::validate_arg_values: checking validator...
[     clap::parser::validator] 	good
[     clap::parser::validator] 	Validator::validate_arg_num_occurs: &quot;query&quot;=1
[     clap::parser::validator] 	Validator::validate_matched_args:iter:flag: vals=Flatten {
inner: FlattenCompat {
iter: Fuse {
iter: Some(
Iter(
[
[],
],
),
),
},
frontiter: None,
backiter: None,
},
}
[     clap::parser::validator] 	Validator::validate_arg_num_vals
[     clap::parser::validator] 	Validator::validate_arg_values: arg=&quot;flag&quot;
[     clap::parser::validator] 	Validator::validate_arg_num_occurs: &quot;flag&quot;=1
[        clap::parser::parser] 	Parser::add_defaults
[        clap::parser::parser] 	Parser::add_defaults:iter:help:
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default missing vals
[        clap::parser::parser] 	Parser::add_default_value: doesn&#x27;t have conditional defaults
[        clap::parser::parser] 	Parser::add_default_value:iter:help: doesn&#x27;t have default vals
[     clap::parser::validator] 	Validator::validate
[     clap::parser::validator] 	Validator::validate_conflicts
[     clap::parser::validator] 	Validator::validate_exclusive
[     clap::parser::validator] 	Validator::validate_required: required=ChildGraph([])
[     clap::parser::validator] 	Validator::gather_requires
[     clap::parser::validator] 	Validator::validate_required: is_exclusive_present=false
[     clap::parser::validator] 	Validator::validate_required_unless
[     clap::parser::validator] 	Validator::validate_matched_args
[   clap::parser::arg_matcher] 	ArgMatcher::get_global_values: global_arg_vec=[help, help]</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-bug</span> added by <a href="https://github.com/david0u0">@david0u0</a> on 2022-06-28 09:14</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap#3887</a> on 2022-06-30 04:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap#4039</a> on 2022-08-08 02:52</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tedinski">@tedinski</a> on 2022-08-19 21:19</div>
            <div class="timeline-body"><p>I ran into this as well. I expected short and long args to be treated identically w.r.t. <code>allow_hyphen_values</code>, instead if you have &quot;allow_hyphen_values&quot; enabled as a final positional argument, clap will recognize long options before it but not short options.</p>
<pre><code>fn main() {
    let config = CompilerArgs::parse();
    println!(&quot;{:?}&quot;, config);
}

use anyhow::Result;
use clap::Parser;

#[derive(Debug, Parser)]
#[clap(name = &quot;clap-bug&quot;, allow_hyphen_values(true))]
pub struct CompilerArgs {
    /// a flag
    #[clap(long, short = &#x27;O&#x27;)]
    pub other: bool,

    /// Eat the rest
    #[clap(allow_hyphen_values = true, min_values(0))]
    pub remainder: Vec&lt;String&gt;,
}

fn test_case(args: &amp;[&amp;str]) -&gt; Result&lt;()&gt; {
    println!(&quot;Beginning test case {:?}&quot;, args);
    let config = CompilerArgs::try_parse_from(args)?;
    println!(&quot;Got {:?}&quot;, config);
    assert!(config.other);
    Ok(())
}

#[test]
fn check_just_long() -&gt; Result&lt;()&gt; {
    test_case(&amp;[&quot;clap-bug&quot;, &quot;--other&quot;])
    // always works
}
#[test]
fn check_just_short() -&gt; Result&lt;()&gt; {
    test_case(&amp;[&quot;clap-bug&quot;, &quot;-O&quot;])
    // always fails: other = false, remainder = [&quot;-O&quot;]
    // expected: other = true, remainder = []
}
#[test]
fn check_short() -&gt; Result&lt;()&gt; {
    test_case(&amp;[&quot;clap-bug&quot;, &quot;-O&quot;, &quot;--extra&quot;])
    // always fails: other = false, remainder = [&quot;-O&quot;, &quot;--extra&quot;]
    // expected: other = true, remainder = [&quot;--extra&quot;]
}
#[test]
fn check_long() -&gt; Result&lt;()&gt; {
    test_case(&amp;[&quot;clap-bug&quot;, &quot;--other&quot;, &quot;--extra&quot;])
    // Without AppSettings::AllowHyphenValues fails:
    // error: Found argument &#x27;--extra&#x27; which wasn&#x27;t expected, or isn&#x27;t valid in this context
    // With AppSettings::AllowHyphenValues, works. This seems odd.
    // I expected it to work without, and probably don&#x27;t want to globally enable that option.
}
#[test]
fn check_long_delimiter() -&gt; Result&lt;()&gt; {
    test_case(&amp;[&quot;clap-bug&quot;, &quot;--other&quot;, &quot;--&quot;, &quot;--extra&quot;])
    // always works
}
</code></pre>
<p>Is there any way to get this behavior from clap 3.x? (That is, greedily parsing short options too, not just long, and only switch to collecting the remainder at an unrecognized option.) This is reduced from a failed attempt to upgrade from 2.x.</p>
<p>(I thought we might be able to switch to requiring <code>--</code>, but it turns out this will break things, not an option.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">M-breaking-change</span> added by <a href="https://github.com/epage">@epage</a> on 2022-08-26 20:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-parsing</span> added by <a href="https://github.com/epage">@epage</a> on 2022-08-26 20:59</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone &quot;4.0&quot; by <a href="https://github.com/epage">@epage</a> on 2022-08-26 21:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-08-26 21:00</div>
            <div class="timeline-body"><p>At this point, we&#x27;ve probably had the behavior long enough that I would be hesitant to change it during 3.0.  I am getting close on 4.0.0 being ready and already need to look at some <code>allow_hyphen_value</code> behavior, so I can look at this as part of that</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>clap-rs/clap#4187</a> on 2022-09-07 02:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by <a href="https://github.com/epage">@epage</a> on 2022-09-07 12:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a>model-checking/kani#1647</a> on 2022-09-07 18:24</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-20 19:59:06 UTC
    </footer>
</body>
</html>
