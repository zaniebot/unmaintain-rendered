<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>greedy argument parsing introduced by obviously evil ;) commit: 6669f0a - clap-rs/clap #109</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>greedy argument parsing introduced by obviously evil ;) commit: 6669f0a</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/clap-rs/clap/issues/109">#109</a>
        opened by <a href="https://github.com/Byron">@Byron</a>
        on 2015-05-06 09:27
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/Byron">@Byron</a> on 2015-05-06 09:27</div>
            <div class="timeline-body"><p>6669f0a introduces shorthand parsing for multiple values. However, this causes subcommands to be parsed as flag-values, thus making it impossible to properly call the program.</p>
<p>For example, calls like this ...</p>
<pre><code>groupsmigration1 --scope foobar archive insert group -u simple README.md
</code></pre>
<p>... now fail as <code>-u</code> is not a valid argument. This is as <code>--scope &lt;url&gt;...</code> has eaten all arguments until the first <code>-flag</code>, then <code>-u</code> is interpreted as top-level flag which it is not. Usually <code>archive</code> and <code>insert</code> are subcommands, and <code>group</code> as well as <code>-u</code> are required flags of <code>insert</code>.</p>
<p>I have made <a href="https://github.com/Byron/clap-rs/tree/evil-fix">a quick-fix</a> (<a href="https://github.com/Byron/clap-rs/commit/1d6ade762c00634eb853a9d5394e2f63cc71e743"><em>notes</em></a>) which might not be ready for a PR, and I am unsure whether I am fit to fix this properly. Clearly we would want to add a few tests to assure this truly works and to protect from regression.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-05-06 14:33</div>
            <div class="timeline-body"><p>I would either set the number of values for <code>--scope</code> if you know how many, I'll also look at evaluating subcommands earlier so as to stop parsing <code>--scope</code> if a subcommand is reached. Currently it only stops if it reaches the max, or exact, number of expected values for <code>--scope</code>, or it reaches another argument starting with <code>-</code>. I can roll this up into #111 too</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Byron">@Byron</a> on 2015-05-06 15:32</div>
            <div class="timeline-body"><p>Unfortunately I don't - <code>--scope</code> is setup exactly how it needs to be, limiting it would be arbitrary. This issue stems from the simplification which allows me to also specify tiny multi-flags like <code>-r foo=bar snoo=baz</code> only once, which is appreciated too.
But if I'd have to choose, I would choose correct parsing over this convenience.
On the other hand, a proper implementation seems possible, it's just that values for <code>+</code> multi-value flags must not be subcommand names anymore.
If there really is no way, I would probably just make <code>--scope</code> single-value, which is what it had to be in the old-ages of <code>docopt</code>, which had the same problem. Interestingly, <code>argparse</code> in python has the same issue too, and I explicitly hacked my own copy to get rid of that limitation back in the days.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-05-06 15:39</div>
            <div class="timeline-body"><p>No worries, it should be fixed with #111 ~~Once it's merged I'll update crates.io~~ (0.8.1 on crates.io)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/111.html">clap-rs/clap#111</a> on 2015-05-06 15:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @kbknapp on 2015-05-06 15:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">bug</span> added by @kbknapp on 2015-05-06 15:58</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2015-05-06 16:02</div>
            <div class="timeline-body"><p>The newest version should solve the issue for you, and it was a valid bug.</p>
<p>To expand on the issue though; the only thing I <em>can't</em> currently do (and realistically it's probably impossible to do) is tell when a [unlimited] multiple value stops and a <em>positional</em> starts. Because positionals have no specifier (unless you count <code>--</code> which works, but it also marks all following arguments after that as positional as well). The answer is to either rearrange the arguments (so the positional comes before the multiple values), or use <code>--</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Byron">@Byron</a> on 2015-05-06 20:07</div>
            <div class="timeline-body"><p>Thank you ! I have rolled-back my change locally and could verify it works fine.</p>
<p>Regarding the stated problem with positionals (and grammars like <code>prog &lt;x&gt; &lt;y&gt; -m &lt;v&gt;...</code>) which are difficult to parse unless in the right order: I think we just have no technology advanced enough just yet.
Well, actually, it is there, just not for this field: regular expressions. The engine behind that is able to act non-greedily, while maximizing matches for respective terms.
I know no implementation using regex though - maybe because for the most part, arg-parsers could get away with relatively trivial (compared to a regex system) and manual implementations.</p>
<p>Now that I am implementing a simple <a href="https://github.com/Byron/json-tools">json lexer</a> to allow me to write a filter to get rid of null values in json streams, I am also thinking that this kind of pattern matching would be totally suited to any kind of token-based system. However, a non-text based regular expression engine is also nowhere to be found. Such a thing would certainly be overkill for what I want to do, but I am lazy and would prefer to write a simple substitution regex which works on my json tokens.</p>
<p>Anyway, thanks again for all the fixes - I believe I am totally happy now, with the CLI at least :).</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:35:06 UTC
    </footer>
</body>
</html>
