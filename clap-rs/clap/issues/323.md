```yaml
number: 323
title: Inconsistent and incorrect behavior with optional options that take multiple values
type: issue
state: closed
author: jimmycuadra
labels:
  - C-bug
  - A-parsing
assignees: []
created_at: 2015-10-28T03:55:46Z
updated_at: 2018-08-02T03:29:46Z
url: https://github.com/clap-rs/clap/issues/323
synced_at: 2026-01-10T01:57:40Z
```

# Inconsistent and incorrect behavior with optional options that take multiple values

---

_Issue opened by @jimmycuadra on 2015-10-28 03:55_

I've come across a few cases using optional options that take multiple values where the input on the CLI is parsed inconsistently or incorrectly depending on the argument order or form.

Given the sample program:

``` rust
extern crate clap;

use clap::{App, Arg};

fn main() {
    let matches = App::new("example")
        .arg(
            Arg::with_name("positional")
                .index(1)
                .required(true)
        )
        .arg(
            Arg::with_name("optional")
                .short("o")
                .long("optional")
                .takes_value(true)
                .multiple(true)
        )
        .get_matches();

    println!("{:?}", matches.values_of("optional"));
}
```

Here are some example inputs and their output.

This works:

```
$ ./target/debug/clap_sample pos -ofoo
Some(["foo"])
```

Adding a second value for "optional" causes a complete failure:

```
$ ./target/debug/clap_sample pos -ofoo -obar
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
```

Using the long form for the second value makes it work:

```
$ ./target/debug/clap_sample pos -ofoo --optional=bar
Some(["foo", "bar"])
```

But not if you use a space instead of an equals sign for the key/value delimiter:

```
$ ./target/debug/clap_sample pos -ofoo --optional bar
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
```

A single value for "optional" using the long form and a space delimiter fails as well:

```
./target/debug/clap_sample pos --optional foo
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
```

While an equals sign works:

```
$ ./target/debug/clap_sample pos --optional=foo
Some(["foo"])
```

And adding a second value using the same syntax works:

```
$ ./target/debug/clap_sample pos --optional=foo --optional=bar
Some(["foo", "bar"])
```

But using any other form of syntax fails:

```
$ ./target/debug/clap_sample pos --optional=foo -obar
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
$ ./target/debug/clap_sample pos --optional=foo -o bar
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
$ ./target/debug/clap_sample pos --optional=foo -o=bar
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
$ ./target/debug/clap_sample pos --optional=foo --optional bar
error: The following required arguments were not supplied:

USAGE:
    clap_sample <positional> --optional <optional>...

For more information try --help
```

If the positional argument is removed from the `clap::App`, the behavior is different still.

A single value for "optional" continues to work with the short, spaceless form:

```
./target/debug/clap_sample -ofoo
Some(["foo"])
```

But adding a second value ignores the second value instead of causing an error like the version with the positional argument did:

```
$ ./target/debug/clap_sample -ofoo -obar
Some(["foo"])
```

Using the long form for the second value makes it work, as before:

```
$ ./target/debug/clap_sample -ofoo --optional=bar
Some(["foo", "bar"])
```

And even works using a space delimiter, which caused an error in the version with the positional argument!

```
$ ./target/debug/clap_sample -ofoo --optional bar
Some(["foo", "bar"])
```

A single value provided using the long option in both forms works:

```
$ ./target/debug/clap_sample --optional bar
Some(["bar"])
$ ./target/debug/clap_sample --optional=bar
Some(["bar"])
```

As does providing a second value with either form of the long option:

```
$ ./target/debug/clap_sample --optional foo --optional bar
Some(["foo", "bar"])
$ ./target/debug/clap_sample --optional foo --optional=bar
Some(["foo", "bar"])
```

But using the short form for the second value, only a space delimiter actually captures the value:

```
$ ./target/debug/clap_sample --optional foo -obar
Some(["foo"])
$ ./target/debug/clap_sample --optional foo -o=bar
Some(["foo"])
$ ./target/debug/clap_sample --optional foo -o bar
Some(["foo", "bar"])
```

I know that providing multiple values without repeating the name of the option itself (`-o foo bar` or `--optional foo bar`) works more consistently (but not in all cases!), but my expectation is that all variations of short and long forms, with or without the app having a positional argument, should correctly recognize the option and extract all the provided values.

All these examples use clap 1.4.5 on Rust 1.3 (OS X). Hope this is helpful! Thanks!


---

_Comment by @kbknapp on 2015-10-28 07:42_

Thanks for the detailed write, we really appreciate it! I'll start working on this bug and post back here with updates :+1: 


---

_Label `T: bug` added by @kbknapp on 2015-10-28 07:42_

---

_Label `P1: urgent` added by @kbknapp on 2015-10-28 07:42_

---

_Label `D: easy` added by @kbknapp on 2015-10-28 07:42_

---

_Label `C: parsing` added by @kbknapp on 2015-10-28 07:42_

---

_Label `W: 1.x` added by @kbknapp on 2015-10-28 07:42_

---

_Comment by @kbknapp on 2015-10-28 07:54_

These are the forms I'm tracking as not working. I'll check off as fixed.
- [x] `$ prog pos -ofoo -obar`
- [x] `$ prog pos -o foo -obar`
- [x] `$ prog pos -ofoo -o bar`
- [x] `$ prog pos -ofoo --optional bar`
- [x] `$ prog pos --optional foo`
- [x] `$ prog pos --optional=foo -obar`
- [x] `$ prog pos --optional=foo -o bar`
- [x] `$ prog pos --optional=foo --optional bar`
- [x] `$ prog --optional foo -obar`
- [x] `$ prog -ofoo -obar`
- [x] `$ prog -o foo -obar`
- [x] `$ prog -ofoo -o bar`
- [x] `$ prog --optional foo -obar`

One note is that forms like this  `$ ./target/debug/clap_sample pos --optional=foo -o=bar` aren't designed to be supported. No reason we probably couldn't add it, but the short form with `=` wasn't an intended form. Just FYI ;)


---

_Comment by @jimmycuadra on 2015-10-28 10:00_

Thanks so much! I don't actually use the equals form myself, but some tools do (even exclusively) so once I realized there was some strangeness going on I started trying all the combinations I could think of. :}


---

_Comment by @kbknapp on 2015-10-28 12:57_

@jimmycuadra All those bugs are fixed with #324 

One thing that has not been added yet is using `=` with a short option (long option and `=` works). Is that required for your use case? If so, we can add it to the tracker for implementation.


---

_Added to milestone `1.4.6` by @kbknapp on 2015-10-28 13:59_

---

_Comment by @jimmycuadra on 2015-10-28 21:10_

That was fast! No, I don't have any particular use for the short form with an equals sign. Thank you!


---

_Closed by @kbknapp on 2015-10-29 07:02_

---
