<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fallback for ValueEnum - clap-rs/clap #5885</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Fallback for ValueEnum</h1>

    <div class="meta">
        <span class="state state-open">Open</span>
        <a href="https://github.com/clap-rs/clap/issues/5885">#5885</a>
        opened by <a href="https://github.com/ModProg">@ModProg</a>
        on 2025-01-19 23:18
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/ModProg">@ModProg</a> on 2025-01-19 23:18</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[x] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[x] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Clap Version</h3>
<p>4.5.26</p>
<h3>Describe your use case</h3>
<p>I'd like to have support for a fallback option when using <code>ValueEnum</code>.</p>
<h3>Describe the solution you'd like</h3>
<p>When <code>derive(ValueEnum)</code> is used I'd like to have a variant e.g., <code>Other(String)</code>, annotated with something like <code>#[clap(other|fallback)]</code> to contain the literal value if none of the enum variants matches.</p>
<h3>Alternatives, if applicable</h3>
<p>Using <code>value_parser</code> to and <code>skip</code> like so:</p>
<pre><code class="language-rs">#[derive(Debug, Parser)]
struct Args {
    #[clap(value_parser = enum_parser)]
    arg: Enum,
}

#[derive(ValueEnum, Clone, Debug)]
enum Enum {
    A,
    B,
    #[clap(skip)]
    Other(String),
}

fn enum_parser(value: &amp;str) -&gt; Result&lt;Enum, Infallible&gt; {
    Ok(Enum::from_str(value, true).unwrap_or_else(|_| Enum::Other(value.to_owned())))
}
</code></pre>
<h3>Additional Context</h3>
<p><em>No response</em></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @ModProg on 2025-01-19 23:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/5886.html">clap-rs/clap#5886</a> on 2025-01-20 01:24</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2025-01-20 01:25</div>
            <div class="timeline-body"><p>I tried to implement a solution, but it turns out this is not a purely proc-macro change.</p>
<p>This would require to either add fallback to the <code>ValueEnum</code> trait or make <code>EnumValueParser</code> respect <code>ValueEnum</code>'s <code>from_str</code> implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2025-01-20 01:26</div>
            <div class="timeline-body"><p>Not sure what your preferred implementation would be here, should you want to implement this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-01-20 15:52</div>
            <div class="timeline-body"><p>Serde calls such an attribute [<code>other</code>].</p>
<p>Adding to <code>ValueEnum</code> would be a breaking change.  Any thoughts on what that would look like?  Changing <code>EnumValueParser</code> might be able to be considered a breaking change.</p>
<p>An important question for this is also how to handle different types.  One option is to only accept <code>String</code> and related types (<code>OsString</code>, <code>PathBuf</code>).  Another is to use <code>value_parser!</code> on the variant's type and allow <code>other = value_parser</code>.</p>
<p>We'd also need to look at the impact on dynamic completions in case it affects the design at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2025-01-20 17:10</div>
            <div class="timeline-body"><p><code>other</code> might be the better name then.</p>
<p>I'd have gone for only String based types for now, though I could see someone wanting to use, e.g., a number. Though then you might want to have multiple <code>fallback</code> or <code>others</code>, this could be expanded on in the future, if we design the change to <code>EnumValueParser</code> or <code>ValueEnum</code> correctly.</p>
<p>Currently, <code>EnumValueParser</code> is just ignoring the implementation of <code>ValueEnum::from_str</code> I don't know if this is intentional. Changing that is a breaking change I guess, though it is one that is quite unlikely to affect anyone, as <code>ValueEnum::from_str</code> will be the default implementation for most, which matches the implementation in <code>EnumValueParser</code> AFAICT.</p>
<p>Adding a new function with a default implementation to <code>ValueEnum</code> would also only be a breaking change for those that manually implemented parsing for generic <code>ValueEnum</code>s which is probably also not very common.</p>
<p>For dynamic completions I'd have said it should be considered <code>skipped</code> as it is not a variant that could be completed (at least for the simple String case, if we supported <code>value_parser</code> then there could be completions).</p>
<p>To support completions for the <code>other</code> variant, I think we'd definitely need to change the API of <code>ValueEnum</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-01-20 18:07</div>
            <div class="timeline-body"><blockquote>
<p>Currently, EnumValueParser is just ignoring the implementation of ValueEnum::from_str I don't know if this is intentional. Changing that is a breaking change I guess, though it is one that is quite unlikely to affect anyone, as ValueEnum::from_str will be the default implementation for most, which matches the implementation in EnumValueParser AFAICT.</p>
</blockquote>
<p>I don't remember the details but it looks like <code>EnumValueParser</code> offers better error messages.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ModProg">@ModProg</a> on 2025-01-20 18:27</div>
            <div class="timeline-body"><blockquote>
<p>I don't remember the details but it looks like EnumValueParser offers better error messages.</p>
</blockquote>
<p>Yeah, <code>ValueEnum</code> returns a <code>String</code> error. To keep the better error messages, one approach could be to just call <code>ValueEnum::from_str</code> and ignore the error message:
https://github.com/clap-rs/clap/blob/f89134d5e11cbd779a48bff6efec897e9cb55ecc/clap_builder/src/builder/value_parser.rs#L1119-L1126</p>
<pre><code class="language-rs">let value = E::from_str(value, ignore_case).map_err(|| {
</code></pre>
<p>The other would be to move the generating of a proper error inside <code>ValueEnum</code> but that would require either adding a new function or changing <code>from_str</code>.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:35 UTC
    </footer>
</body>
</html>
