<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Partial / Pre Parsing a CLI - clap-rs/clap #1880</title>
    <link rel="stylesheet" href="../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../index.html">Back to index</a>
    </div>

    <h1>Partial / Pre Parsing a CLI</h1>

    <div class="meta">
        <span class="state state-closed">Closed</span>
        <a href="https://github.com/clap-rs/clap/issues/1880">#1880</a>
        opened by <a href="https://github.com/kbknapp">@kbknapp</a>
        on 2020-04-29 15:38
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/kbknapp">@kbknapp</a> on 2020-04-29 15:38</div>
            <div class="timeline-body"><p><a href="https://github.com/clap-rs/clap/issues/1880#issuecomment-990173791">Comment on closing</a>:</p>
<blockquote>
<p>In the short term, we now have IgnoreErrors.</p>
<p>Longer term, I feel like #1404 is a more general solution and has existing precedence (Python's argparse at least) compared to a <code>get_partial_matches(arg_name)</code> which only works in a narrow set of cases.</p>
</blockquote>
<hr />
<h3>Make sure you completed the following tasks</h3>
<ul>
<li>[x] Searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[x] Searched the closed issues</li>
</ul>
<h3>Describe your use case</h3>
<p>A way to declare a subset of arguments to be parsed, then return from parsing early. With the expectation that parsing will be called again, and run to full completion.</p>
<p>This most often comes up when you want some argument to handle some aspect of the CLI itself (such as <code>--color</code> flags to control error messages during parsing, or in the above <code>--arg-file</code> which needs to determine a file to load prior to parsing the rest of the CLI).</p>
<h3>Describe the solution you'd like</h3>
<p>From a <em>user</em> stand point, nothing changes. The run the CLI and things just work. From the a clap <em>consumer</em> stand point, it essentially allows you to pull out some values from the CLI (ignoring everything else), change something about the CLI and continue parsing.</p>
<pre><code class="language-rust">// .. already have some App struct
let pre_matches = app.get_partial_matches(&quot;color&quot;); // Only parse the `--color` option, ignore all else
app = if let Some(&quot;never&quot;) = pre_matches.value_of(&quot;color&quot;) {
    app.setting(AppSettings::ColorNever)
} else {
    app
};

let matches = app.get_matches();
</code></pre>
<p>Maybe it's biting off more than we want to chew for now, but this issue seems to come up time and time again where we want to parse some particular subset of arguments, and use those values to inform how the CLI itself behaves.</p>
<h3>Alternatives, if applicable</h3>
<p>You can already reparse your CLI twice.</p>
<pre><code class="language-rust">let matches = app.get_matches();
app = if let Some(&quot;never&quot;) = matches.value_of(&quot;color&quot;) {
    app.setting(AppSettings::ColorNever)
} else {
    app
};

let matches = app.get_matches();
</code></pre>
<p>But this doesn't help if there are errors in the initial parse, or options included included in the initial parse that the initial app isn't aware of. For example, an <code>iptables</code> style CLI where <code>-m &lt;foo&gt;</code> enables many other arguments and options.</p>
<h3>Additional context</h3>
<p>This could potentially be used in #1693 #1089 #1232 #568</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by @kbknapp on 2020-04-29 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: parsing</span> added by @kbknapp on 2020-04-29 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: medium</span> added by @kbknapp on 2020-04-29 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">P4: nice to have</span> added by @kbknapp on 2020-04-29 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> added by @kbknapp on 2020-04-29 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x</span> added by @kbknapp on 2020-04-29 15:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/380.html">clap-rs/clap#380</a> on 2020-05-01 21:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alerque">@alerque</a> on 2020-05-05 07:53</div>
            <div class="timeline-body"><p>This feature would also be immensely useful for implementing #380, localizing a CLI interface.</p>
<blockquote>
<p>You can already reparse your CLI twice.</p>
</blockquote>
<p>This is not <em>quite</em> true. You already mentioned some exceptions such as in the case of parse errors, but there is one more road block that makes that technique unworkable. A number of things happen in <code>get_matches()</code> that have the potential to short circuit the rest of the application life-cycle. For example having a <code>help</code> subcommand. If this is detected it immediately outputs stuff to the terminal and quits. This means you don't get a chance to reliably parse the CLI a second time.</p>
<p>This makes the technique useless for localization because by the time we get information about a potential language flag the App has already spit out strings that may have needed localization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1910.html">clap-rs/clap#1910</a> on 2020-05-11 18:43</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-06-02 20:11</div>
            <div class="timeline-body"><p>As a minimal viable solution, we could simply allow ignoring unknown or missing positionals and options.</p>
<pre><code class="language-rust">// first &quot;probe&quot; app
let preprocess = App::new(&quot;app&quot;)
    .settings(IgnoreErrors) // also disables --help, version, and others
    .arg(&quot;--color &lt;color&gt; 'coloring policy: never/always'&quot;)
    .get_matches(); // will succeed no matter what

let mut app = App::new(&quot;main_app&quot;);

match preprocess.value_of(&quot;color&quot;) {
    Some(&quot;always&quot;) =&gt; app = app.setting(ColorAlways),
    Some(&quot;never&quot;) =&gt; app = app.setting(ColorNever),
    _ =&gt; {}
}

// real parsing starts here
app.get_matches()
</code></pre>
<p>This kind or partial parsing would allow for most, if not all, cases and would be fairly easy to implement.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1232.html">clap-rs/clap#1232</a> on 2020-06-02 20:16</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alerque">@alerque</a> on 2020-06-02 21:17</div>
            <div class="timeline-body"><p>Yes that does indeed sound like a MVS, and something along the lines of what I expected to be able to hack together already and failed. It's not the most elegant solution maybe, but it would get me by for my use case of localization.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../sharkdp/fd/issues/600.html">sharkdp/fd#600</a> on 2020-06-05 08:39</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/wabain">@wabain</a> on 2020-06-07 14:10</div>
            <div class="timeline-body"><p>@alerque It sounds like <a href="https://docs.rs/clap/2.33.1/clap/struct.App.html#method.get_matches_safe">get_matches_safe</a> could be what you're looking for? That would address the immediate problem of clap prematurely exiting with help or an error.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-06-07 15:10</div>
            <div class="timeline-body"><p>@wabain But it wouldn't give you the partial mach, see the color example above</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/acheronfail">@acheronfail</a> on 2020-07-01 23:35</div>
            <div class="timeline-body"><p>I am building an app which spawns another process, and needs to &quot;sniff&quot; if certain flags were passed to the subprocess. Having an <code>AppSettings::IgnoreErrors</code> would be invaluable, since I only want to match some specific args, and leave the rest alone.</p>
<p>Right now I believe this is impossible with <code>clap</code>, and I have to parse the args manually.</p>
<hr />
<p>For some more detail, my app is used like this:</p>
<pre><code>app &lt;args sent to subprocess&gt;
</code></pre>
<p>The subprocess supports <em>hundreds</em> of arguments, and I don't want to have to write code to match <em>all</em> of them if I'm just interested in 2 or 3 flags.</p>
<p>The <code>get_matches_safe</code> doesn't work here for me though, since that bails out and completely fails.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kenoss">@kenoss</a> on 2020-07-15 20:06</div>
            <div class="timeline-body"><p>Let me have some examples because my English is poor and I might miss points.</p>
<p>The original problem is &quot;lax position of arguments.&quot;</p>
<pre><code># Good.  `--project` option belongs to `Arg(&quot;gcloud&quot;)` and `--zone` to `Arg(&quot;ssh&quot;)`.
$ gcloud --project=hoge compute ssh --zone=asia-northeast1-a instance-name

# Good.  `--project` option can descend to subcommands.
$ gcloud compute --project=hoge ssh --zone=asia-northeast1-a instance-name

# Also good.
$ gcloud compute ssh --project=hoge --zone=asia-northeast1-a instance-name
 
# Bad.  `--zone` option belongs to `ssh` subcommand.
$ gcloud --project=hoge compute --zone=asia-northeast1-a ssh instance-name
</code></pre>
<p>I think this is solved by adding option to <code>Arg</code>.  No tricks.
There's possibility the implementation of parsing become little complicated, but developer using clap can use intuitively.
This is also glad with the viewpoint of https://github.com/clap-rs/clap/issues/1232 .  Tricks like alternative <code>App</code> and <code>get_matches_safe</code> make the systematic completion harder.</p>
<p>This approach will be match with the @acheronfail 's case.  I guess there're two types of app:</p>
<pre><code>time othercommand ...
cargo run -- othercommand-or-options ...
</code></pre>
<p>The former is very limited.  <code>time</code> do not have subcommands because subcommands conflict with <code>othercommand</code>.  It can have only root <code>App</code> and parse will terminate with <code>othercommand</code>.  Hence the above approach has no ambiguity.</p>
<p>The later is similar.  Parsing will terminate with first &quot;--&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-07-17 16:55</div>
            <div class="timeline-body"><p>@kenoss Thanks for looking into this, we appreciate that. I didn't quite get your comment, so let's try to get on the same page first.</p>
<blockquote>
<p>The original problem is &quot;lax position of arguments.&quot;</p>
</blockquote>
<p>Could you please elaborate? I think this is where the misunderstanding comes from. The original problem in my understanding is to &quot;loosely parse flags, options, and subcommands but ignore positional arguments entirely&quot;. The <code>--</code> thing is another topic; I'm not sure why you brought it up.</p>
<blockquote>
<p>Good.  <code>--project</code> option belongs to <code>Arg(&quot;gcloud&quot;)</code> and <code>--zone</code> to <code>Arg(&quot;ssh&quot;)</code>.</p>
</blockquote>
<p>You have introduced &quot;belongs to&quot; relationship between two arguments. I can't wrap my head around it - arguments can't belong to each other. An argument can &quot;belong&quot; to a subcommand or the top-level app.</p>
<p>Maybe you meant <code>App</code>?</p>
<hr />
<p>The complexity of implementation... Guys, I think we've all been missing the elephant in the room. The current parsing algorithm can't just &quot;ignore&quot; arguments, <em>especially positional</em> ones. Well, It can <em>ignore</em>, but it can't <em>recover</em>. I think this issue belongs to &quot;postponed until after I finally rewrite the parser algorithm&quot; category.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kenoss">@kenoss</a> on 2020-08-05 15:39</div>
            <div class="timeline-body"><p>Sorry for late reply.</p>
<blockquote>
<p>The original problem in my understanding is to &quot;loosely parse flags, options, and subcommands but ignore positional arguments entirely&quot;.</p>
</blockquote>
<p>I read the issue again and I've got the point.  Thanks to catch me up the argument.</p>
<blockquote>
<p>The -- thing is another topic; I'm not sure why you brought it up.</p>
</blockquote>
<p>Sorry.  I misunderstood by <code>get_matches_safe</code> and <code>app &lt;args sent to subprocess&gt;</code>.</p>
<blockquote>
<p>Maybe you meant App?</p>
</blockquote>
<p>Yes.</p>
<p>I've found that this is a critical blocker of https://github.com/clap-rs/clap/issues/1232 and I should parsing implementation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1404.html">clap-rs/clap#1404</a> on 2021-03-30 15:35</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../knurling-rs/flip-link/issues/31.html">knurling-rs/flip-link#31</a> on 2021-04-05 14:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/2480.html">clap-rs/clap#2480</a> on 2021-05-13 14:30</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1185.html">clap-rs/clap#1185</a> on 2021-05-26 10:57</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../bootandy/dust/pulls/147.html">bootandy/dust#147</a> on 2021-06-05 13:24</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2354.html">clap-rs/clap#2354</a> on 2021-07-30 00:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x</span> removed by @pksunkara on 2021-08-13 10:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/92.html">epage/clapng#92</a> on 2021-12-06 17:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/156.html">epage/clapng#156</a> on 2021-12-06 20:15</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/179.html">epage/clapng#179</a> on 2021-12-06 21:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: RFC / question</span> removed by @epage on 2021-12-08 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> removed by @epage on 2021-12-08 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-08 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 19:40</div>
            <div class="timeline-body"><p>In the short term, we now have IgnoreErrors.</p>
<p>Longer term, I feel like #1404 is a more general solution and has existing precedence (Python's argparse at least) compared to a <code>get_partial_matches(arg_name)</code> which only works in a narrow set of cases.</p>
<p>If there is any concern with this, feel free to comment and we can re-open this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2021-12-09 19:40</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alerque">@alerque</a> on 2021-12-14 11:08</div>
            <div class="timeline-body"><p>I don't see anything in #1404 covering the use cases <a href="https://github.com/clap-rs/clap/issues/1880#issuecomment-623910845">I commented on above</a>. An option would need to be added to <em>stop</em> the default short-circuit behavior where the app prints something and exits when encountering some flags, e.g. <code>--help</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-14 14:24</div>
            <div class="timeline-body"><blockquote>
<p>I don't see anything in #1404 covering the use cases <a href="https://github.com/clap-rs/clap/issues/1880#issuecomment-623910845">I commented on above</a>. An option would need to be added to <em>stop</em> the default short-circuit behavior where the app prints something and exits when encountering some flags, e.g. <code>--help</code>.</p>
</blockquote>
<p>So if I understand, you would define one <code>App</code> with the localization flag(s), parse that to know how to handle it, and then do a full parse.</p>
<p>For the partial parse, couldn't you either set <code>NoAutoHelp</code> / <code>NoAutoVersion</code> or <code>DisableHelpFlag</code> / <code>DisableVersionFlag</code> / <code>DisableHelpSubcommand</code>?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alerque">@alerque</a> on 2021-12-14 14:57</div>
            <div class="timeline-body"><blockquote>
<p>For the partial parse, couldn't you either set <code>NoAutoHelp</code> / <code>NoAutoVersion</code> or <code>DisableHelpFlag</code> / <code>DisableVersionFlag</code> / <code>DisableHelpSubcommand</code>?</p>
</blockquote>
<p>Honestly, I hadn't considered that — but it seems like quite a song and dance for what I want. First I'd have to set both of those (since they aren't the default), do one parsing pass, then unset both of them again for the second pass. I would suggest that should be an option on the parsing function (or an alternate function) to disable all current &amp; future <code>Auto____</code> functionality during a parse.</p>
<p>Should I open a new issue for that?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-14 15:04</div>
            <div class="timeline-body"><blockquote>
<blockquote>
<p>For the partial parse, couldn't you either set <code>NoAutoHelp</code> / <code>NoAutoVersion</code> or <code>DisableHelpFlag</code> / <code>DisableVersionFlag</code> / <code>DisableHelpSubcommand</code>?</p>
</blockquote>
<p>Honestly, I hadn't considered that — but it seems like quite a song and dance for what I want. First I'd have to set both of those (since they aren't the default), do one parsing pass, then unset both of them again for the second pass. I would suggest that should be an option on the parsing function (or an alternate function) to disable all current &amp; future <code>Auto____</code> functionality during a parse.</p>
<p>Should I open a new issue for that?</p>
</blockquote>
<p>You can, it would be a better place to continue to discuss it.  With that said, I am concerned about the number of parsing functions we already have today and would be preferring we find ways to reduce the number, rather than increase it.  As long as we provide the building blocks, that is my main concern.  How nice we make things past that is dependent on how prevalent the workflow is.</p>
<p>Already, you either have to be setting <code>IgnoreErrors</code> or calling the partial parsing proposed in #1404 with subset of arguments you want verified.  This seems like something that is already going to be a specialized parse pass, so the level of burden of setting a couple more flags seems low.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-wont-fix</span> added by @epage on 2022-01-11 18:25</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/scottidler">@scottidler</a> on 2022-03-14 01:16</div>
            <div class="timeline-body"><pre><code class="language-rust">fn extract(item: (ContextKind, &amp;ContextValue)) -&gt; Option&lt;&amp;ContextValue&gt; {                                                                                         
    let (k, v) = item;                                                                                                                                            
    if k == ContextKind::InvalidArg {                                                                                                                             
        return Some(v);                                                                                                                                           
    }                                                                                                                                                             
    None                                                                                                                                                          
}                                                                                                                                                                 
                                                                                                                                                                  
fn parse_known_args(cmd: &amp;Command) -&gt; Result&lt;(ArgMatches, Vec&lt;String&gt;), Error&gt; {                                                                                  
    let mut rem: Vec&lt;String&gt; = vec![];                                                                                                                            
    let mut args: Vec&lt;String&gt; = env::args().collect();                                                                                                            
    loop {                                                                                                                                                        
        match cmd.clone().try_get_matches_from(&amp;args) {                                                                                                           
            Ok(matches) =&gt; {                                                                                                                                      
                return Ok((matches, rem));                                                                                                                        
            },                                                                                                                                                    
            Err(error) =&gt; {                                                                                                                                       
                match error.kind() {                                                                                                                              
                    ErrorKind::UnknownArgument =&gt; {                                                                                                               
                        let items = error.context().find_map(extract);                                                                                            
                        match items {                                                                                                                             
                            Some(x) =&gt; {                                                                                                                          
                                match x {                                                                                                                         
                                    ContextValue::String(s) =&gt; {                                                                                                  
                                        rem.push(s.to_owned());                                                                                                   
                                        args.retain(|a| a != s);                                                                                                  
                                    },                                                                                                                            
                                    _ =&gt; {                                                                                                                        
                                        return Err(error);                                                                                                        
                                    },                                                                                                                            
                                }                                                                                                                                 
                            },                                                                                                                                    
                            None =&gt; {                                                                                                                             
                                return Err(error);                                                                                                                
                            },                                                                                                                                    
                        }                                                                                                                                         
                    },                                                                                                                                            
                    _ =&gt; {                                                                                                                                        
                        return Err(error);                                                                                                                        
                    },                                                                                                                                            
                }                                                                                                                                                 
            },                                                                                                                                                    
        }                                                                                                                                                         
    }                                                                                                                                                             
}   
</code></pre>
<pre><code class="language-rust">fn main() {                                                                                                                                                       
    let cmd = Command::new(&quot;cmd&quot;)                                                                                                                                 
        .allow_hyphen_values(true)                                                                                                                                
        .trailing_var_arg(true)                                                                                                                                   
        .disable_help_flag(true)                                                                                                                                  
        .disable_version_flag(true)                                                                                                                               
        .arg(                                                                                                                                                     
            Arg::new(&quot;config&quot;)                                                                                                                                    
                .takes_value(true)                                                                                                                                
                .short('c')                                                                                                                                       
                .long(&quot;config&quot;)                                                                                                                                   
                .help(&quot;path to config&quot;),                                                                                                                          
        );                                                                                                                                                        
    let result = parse_known_args(&amp;cmd);                                                                                                                          
    let (matches, rem) = result.unwrap();                                                                                                                         
    println!(&quot;matches={:#?}&quot;, matches);                                                                                                                           
    println!(&quot;rem={:#?}&quot;, rem);   
    let matches = cmd.get_matches_from(&amp;rem);
}
</code></pre>
<p>For anyone who comes across this and is looking for an equivalent to Python Argparse's <code>parse_known_args</code>, I hacked this code together. I am sure it could be improved as I am new to Rust. It would be nice to have some ergonomics in the Clap code base for this use case, but until then maybe this provides some usefulness to someone.</p>
<p>For anyone who doesn't understand why you would want this, it is a VERY common pattern for me to supply the config file in the first pass, that will either effect the default values if not alter the program's options entirely.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../jj-vcs/jj/pulls/824.html">jj-vcs/jj#824</a> on 2022-12-01 20:28</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/novafacing">@novafacing</a> on 2023-09-09 00:02</div>
            <div class="timeline-body"><p>Sorry for the long time bump, I liked @scottidler's answer here so I've made it a little more generic. Slap this at the top of your cli code and you're good to go. My use case is for wrapping <code>clang</code> for LibAFL use -- I want to extract some arguments and pass everything else down to the clang command I'm wrapping.</p>
<pre><code class="language-rust">use anyhow::{anyhow, bail, Result};
use clap::{
    error::{ContextKind, ContextValue, ErrorKind},
    ArgMatches, Command, CommandFactory, FromArgMatches, Parser,
};
use std::env::args;

#[derive(Debug, Clone)]
struct Known&lt;T&gt;
where
    T: FromArgMatches,
{
    matches: T,
    rest: Vec&lt;String&gt;,
}

impl&lt;T&gt; Known&lt;T&gt;
where
    T: FromArgMatches,
{
    pub fn new&lt;I, S&gt;(matches: ArgMatches, rest: I) -&gt; Result&lt;Self&gt;
    where
        I: IntoIterator&lt;Item = S&gt;,
        S: AsRef&lt;str&gt;,
    {
        Ok(Self {
            matches: T::from_arg_matches(&amp;matches)?,
            rest: rest.into_iter().map(|a| a.as_ref().to_string()).collect(),
        })
    }
}

trait ParseKnown: FromArgMatches {
    fn parse_known() -&gt; Result&lt;Known&lt;Self&gt;&gt;;
}

impl&lt;T&gt; ParseKnown for T
where
    T: CommandFactory + FromArgMatches,
{
    fn parse_known() -&gt; Result&lt;Known&lt;T&gt;&gt; {
        let command = Self::command();
        let mut rest = Vec::new();
        let mut args = args().collect::&lt;Vec&lt;_&gt;&gt;();

        loop {
            match command.clone().try_get_matches_from(&amp;args) {
                Ok(matches) =&gt; {
                    return Known::new(matches, rest);
                }
                Err(e) if matches!(e.kind(), ErrorKind::UnknownArgument) =&gt; {
                    if let Some(ContextValue::String(v)) = e
                        .context()
                        .find_map(|(k, v)| matches!(k, ContextKind::InvalidArg).then_some(v))
                    {
                        let unknown = args
                            .iter()
                            .find(|a| a.starts_with(v))
                            .cloned()
                            .ok_or_else(|| anyhow!(&quot;No argument starts with {}&quot;, v))?;

                        if args.contains(&amp;unknown) {
                            args.retain(|a| a != &amp;unknown);
                            rest.push(unknown);
                        } else {
                            bail!(&quot;Got unknown argument {} but it is not in args at all.&quot;, v);
                        }
                    } else {
                        bail!(&quot;No string value found for unknown argument: {}&quot;, e);
                    }
                }
                Err(e) =&gt; bail!(&quot;Error getting matches from args '{:?}': {}&quot;, args, e),
            }
        }
    }
}

#[derive(Parser, Debug, Clone)]
#[clap(
    allow_hyphen_values = true,
    trailing_var_arg = true,
    disable_help_flag = true,
    disable_version_flag = true
)]
struct Args {
    #[arg(long)]
    libafl_no_link: bool,
    #[arg(long)]
    libafl: bool,
    #[arg(long)]
    libafl_ignore_configurations: bool,
    #[arg(long, value_delimiter = ',')]
    libafl_configurations: Vec&lt;String&gt;,
}

fn main() -&gt; Result&lt;()&gt; {
    let args = Args::parse_known()?;
    println!(&quot;{:#?}&quot;, args);
    Ok(())
}
</code></pre>
<p>Handles e.g. <code>cargo run -- -x --libafl -y -zexecstack -fsanitize=fuzzer-no-link -fno-common --libafl-ignore-configurations</code> (the above example will fail with single-hyphen commands)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-09 23:28:32 UTC
    </footer>
</body>
</html>
