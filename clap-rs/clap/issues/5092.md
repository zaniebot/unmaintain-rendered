```yaml
number: 5092
title: "#[command(flatten)] on optional field makes it required"
type: issue
state: open
author: smessmer
labels:
  - C-bug
  - M-breaking-change
  - A-validators
  - S-waiting-on-design
assignees: []
created_at: 2023-08-27T19:10:01Z
updated_at: 2025-01-27T23:03:33Z
url: https://github.com/clap-rs/clap/issues/5092
synced_at: 2026-01-10T01:57:48Z
```

# #[command(flatten)] on optional field makes it required

---

_Issue opened by @smessmer on 2023-08-27 19:10_

### Please complete the following tasks

- [X] I have searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [X] I have searched the [open](https://github.com/clap-rs/clap/issues) and [rejected](https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed) issues

### Rust Version

1.72

### Clap Version

4.3.4

### Minimal reproducible code

```rust
use clap::{Args, Parser};

fn main() {
    MainArgs::parse();
}

#[derive(Parser, Debug)]
pub struct MainArgs {
    #[arg(short = 'V', long)]
    pub version: bool,

    #[command(flatten)]
    pub specific_args: Option<SpecificArgs>,
}

#[derive(Args, Debug)]
pub struct SpecificArgs {
    pub positional: String,
}
```

### Steps to reproduce the bug with the above code

```
cargo r -- --version
```

### Actual Behaviour

```
error: the following required arguments were not provided:
  <POSITIONAL>

Usage: test-executable --version <POSITIONAL>

For more information, try '--help'.
```

### Expected Behaviour

No error because the `SpecificArgs` is optional.

### Additional Context

I want to use this to have a top level `Parser` with a few global args (e.g. `--version` but also some others), and I want to reuse this across different CLI tools, each with their own `ConcreteArgs`. The `ConcreteArgs` are usually written as mandatory in their corresponding `#[derive(Args)]` parser, but they should only be mandatory if none of the global flags are present. To do this, I made `SpecificArgs` optional in the `#[command(flatten)]` but that doesn't seem to have the intended effect.

Similar discussion: https://github.com/clap-rs/clap/discussions/4954

### Debug Output

_No response_

---

_Label `C-bug` added by @smessmer on 2023-08-27 19:10_

---

_Label `M-breaking-change` added by @epage on 2023-08-28 13:53_

---

_Label `A-validators` added by @epage on 2023-08-28 13:53_

---

_Label `S-waiting-on-design` added by @epage on 2023-08-28 13:53_

---

_Comment by @epage on 2023-08-28 13:57_

We have a discrepancy in how we treat `Option` between `Arg` (required, no required) and `ArgGroup` (no-op, track whether present).

A lot of this depends on how people are using an `ArgGroup`
- Composing structs: lack of `Option` shouldn't mean anything
- Require or don't require an `ArgGroup`
- Override required Args within an `ArgGroup` (what this issue wants

Can we pick a one-size-fits all option?  If not, how do we allow variability of this?

---

_Comment by @jannschu on 2023-09-02 20:13_

Is there a workaround?

---

_Comment by @epage on 2023-09-03 01:30_

The way to workaround this heavily depends on your use case.  If you want one argument to be present when the group is, you can use [ArgGroup::requires](https://docs.rs/clap/latest/clap/struct.ArgGroup.html#method.requires).

As an example, let's take the reproduction case and change it to use that:
```rust
use clap::{Args, Parser};

fn main() {
    MainArgs::parse();
}

#[derive(Parser, Debug)]
pub struct MainArgs {
    #[arg(short = 'V', long)]
    pub version: bool,

    #[command(flatten)]
    pub specific_args: Option<SpecificArgs>,
}

#[derive(Args, Debug)]
#[group(requires = "positional")]
pub struct SpecificArgs {
    #[arg(required = false)]
    pub positional: String,
}
```
`SpecificArgs` will only be instantiated if the group is present and if the group is present then `positional` must be present as well, so you can skip using `Option` for it and just override the default `required = true` with `required = false`.

---

_Referenced in [Analog-Labs/timechain#518](../../Analog-Labs/timechain/pulls/518.md) on 2023-09-22 15:35_

---

_Referenced in [mullvad/mullvadvpn-app#5366](../../mullvad/mullvadvpn-app/pulls/5366.md) on 2023-10-26 09:05_

---

_Referenced in [clap-rs/clap#5292](../../clap-rs/clap/issues/5292.md) on 2024-01-08 21:27_

---

_Referenced in [cowprotocol/services#2909](../../cowprotocol/services/pulls/2909.md) on 2024-08-19 15:43_

---

_Comment by @JMLX42 on 2025-01-27 21:59_

> SpecificArgs will only be instantiated if the group is present and if the group is present then positional must be present as well, so you can skip using Option for it and just override the default required = true with required = false.

I might be missing something, but there is not much value in flattening a struct with a single field. And the proposal does not scale well with multiple fields.

Here is an example: 

```rust
#[derive(Debug, Clone, Default, Deserialize, Serialize, clap::Args)]
#[group(conflicts_with = "camera_node")]
#[group(requires = "x")]
pub struct CameraCoordinates {
    /// X position of the camera
    #[arg(long, required = false)]
    pub x: f32,
    /// Y position of the camera
    #[arg(long, required = false)]
    pub y: f32,
    /// Z position of the camera
    #[arg(long, required = false)]
    pub z: f32,
    /// X target of the camera
    #[arg(long, required = false)]
    pub target_x: f32,
    /// Y target of the camera
    #[arg(long, required = false)]
    pub target_y: f32,
    /// Z target of the camera
    #[arg(long, required = false)]
    pub target_z: f32,
    /// Z far of the camera
    #[arg(long, required = false, default_value = "1000.0")]
    pub z_far: f32,
}

#[derive(Parser, Debug, Default, Clone)]
pub struct Args {
    #[clap(flatten)]
    pub camera_coordinates: Option<CameraCoordinates>,
    #[clap(long)]
    pub camera_node: Option<Uuid<GltfLiveNode>>,
}
```

> The way to workaround this heavily depends on your use case. If you want one argument to be present when the group is, you can use [ArgGroup::requires](https://docs.rs/clap/latest/clap/struct.ArgGroup.html#method.requires).

In this case, if `--x` is present, all the arguments in the group become required.

```
$ cargo run --target=x86_64-unknown-linux-gnu --target-dir=target/x86_64-unknown-linux-gnu --profile=dev --bin=gltf-live open --gltf 0194a8cb-fc67-70a3-836b-7b900dbeb5f7 --x 10
    Finished `dev` profile [optimized + debuginfo] target(s) in 20.04s
     Running `target/x86_64-unknown-linux-gnu/x86_64-unknown-linux-gnu/debug/gltf-live open --gltf 0194a8cb-fc67-70a3-836b-7b900dbeb5f7 --x 10`
Error: error: The following required argument was not provided: y

Usage: gltf_live_app [OPTIONS] <COMMAND>

For more information, try '--help'.
```

Yet, IMHO the code says the exact opposite:

- `camera_coordinates: Option<CameraCoordinates>` suggests the entire group is optional
- `required = false` on all fields of `CameraCoordinates` suggests all fields of the group are optional
- `requires = "x"` suggests only the `x` field is required when the group is present

And yet, all the other fields of `CameraCoordinates` are treated as required...

Ironically, the behavior is the one I want. But unless I missed something, it's not the expected behavior.

Am I missing something?

---

_Comment by @iamjpotts on 2025-01-27 23:03_

> camera_coordinates: Option<CameraCoordinates> suggests the entire group is optional

I would like to be able to do that, without having to mark `required = false` on the individual fields or mark `requires_all` on the group. It would be nice if both of those were respectively derived from a) the fields on `FooConfig` not being optional, and b) `Option<FooConfig>`.

```rust
#[derive(clap::Parser)]
#[group(requires_all = ["bar", "qux", "baz"])]
pub struct FooConfig {
    #[arg(env, required = false)]
    pub bar: String,

    #[arg(env, required = false)]
    pub qux: String,

    #[arg(env, required = false)]
    pub baz: String
}
```

The single field variant is also useful if FooConfig is used elsewhere in the code base either as a type wrapper or on other cli tools with subsets or different combinations of config from each other.

```rust
#[derive(Parser, Debug, Default, Clone)]
pub struct CliEnv {
    #[clap(flatten)]
    pub foo: Option<FooConfig>,

    pub abc: String,
}

#[derive(Parser, Debug, Default, Clone)]
pub struct SomeOtherCliEnv {
    #[clap(flatten)]
    pub foo: Option<FooConfig>,

    pub xyz: String,
}

```

---

_Referenced in [scroll-tech/rollup-node#65](../../scroll-tech/rollup-node/pulls/65.md) on 2025-04-23 17:16_

---
