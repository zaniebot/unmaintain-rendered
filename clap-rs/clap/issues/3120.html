<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structopt derive doesn't like type-parametric structs - clap-rs/clap #3120</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Structopt derive doesn't like type-parametric structs</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/3120">#3120</a>
        opened by <a href="https://github.com/epage">@epage</a>
        on 2021-12-09 16:14
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="96" height="96" hspace="10"></img></a> <strong>Issue by <a href="https://github.com/vorner">vorner</a></strong>
<em>Thursday Jul 26, 2018 at 20:30 GMT</em>
<em>Originally opened as https://github.com/TeXitoi/structopt/issues/128</em></p>
<hr />
<p>Probably better showed with some code:</p>
<pre><code class="language-rust">struct Wrapper&lt;O&gt; {
    #[structopt(flatten)]
    sub: O,
}
</code></pre>
<p>I get this error message:</p>
<pre><code>error[E0412]: cannot find type `O` in this scope
  --&gt; src/lib.rs:31:10
   |
31 | #[derive(StructOpt)]
   |          ^^^^^^^^^ did you mean `OW`?

error[E0243]: wrong number of type arguments: expected 1, found 0
  --&gt; src/lib.rs:31:10
   |
31 | #[derive(StructOpt)]
   |          ^^^^^^^^^ expected 1 type argument
</code></pre>
<p>Similar thing works with serde, where it automatically places correct type bounds on the generated impl block.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Friday Jul 27, 2018 at 10:10 GMT</em></p>
<hr />
<p>StructOpt was not design with generics in mind. That's a complicated thing.</p>
<p>What is your use case?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/vorner">vorner</a></strong>
<em>Friday Jul 27, 2018 at 10:55 GMT</em></p>
<hr />
<p>Yes, I already noticed it's a bit harder than just making sure the impl gets the type bounds, because some things are not part of the trait. But I've found a workaround for my own use case.</p>
<p>I'm building a helper start-me-a-daemon library. Some of the options will be specific for each daemon, while some others will be common for all of them (like logging and option not to go to background). So I want to compose the common ones (defined in the library) with the daemon-specific ones provided by the user of the library as a generic.</p>
<p>For now, I have this (I haven't tried it yet, but I guess it should work).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Friday Jul 27, 2018 at 12:29 GMT</em></p>
<hr />
<p>Others are doing it in the other way, see https://crates.io/crates/clap-verbosity-flag and https://crates.io/crates/clap-port-flag</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/vorner">vorner</a></strong>
<em>Friday Jul 27, 2018 at 12:48 GMT</em></p>
<hr />
<p>Yes, but that's a different use case ‒ they want to expose the verbosity flag to the end application. I don't want to give the application the logging configuration etc ‒ I just want to logging to be configured automagically. That means my library needs access to the common configuration (if I went the verbosity way, I'd have to let the user tell me where the logging configuration is) and it would pollute the user's configuration structure.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/vorner">vorner</a></strong>
<em>Friday Jul 27, 2018 at 12:49 GMT</em></p>
<hr />
<p>(Oh, I haven't included the link in the post up there ↑ ‒ this is what I do now: https://github.com/vorner/spirit/blob/master/src/lib.rs#L59)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Friday Jul 27, 2018 at 12:59 GMT</em></p>
<hr />
<p>Great workaround!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Tuesday Dec 03, 2019 at 01:21 GMT</em></p>
<hr />
<p>Let's get back to the original issue. Do we want to support generic structs and what the pitfalls are?
Or will we just close it as &quot;wontfix&quot;?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Tuesday Dec 03, 2019 at 08:46 GMT</em></p>
<hr />
<p>wontfix is fine for me.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Wednesday Dec 25, 2019 at 20:00 GMT</em></p>
<hr />
<p>@TeXitoi actually, there is <a href="https://www.reddit.com/r/rust/comments/efi4kb/who_else_depends_on_structopts_internal_api/fc0w1cu?utm_source=share&amp;utm_medium=web2x">a use case</a> where this would be pretty useful.</p>
<p>What if we just copy-paste the bounds?</p>
<pre><code class="language-rust">
#[derive(StructOpt)] 
struct Opt&lt;T, U: Read&gt; {}

// expands to 
impl&lt;T, U: Read&gt; StructOpt for Opt&lt;T, U&gt; {
    // ...
}
</code></pre>
<p>I understand that it's not enough in some corner cases (like type items, implicit <code>Sized</code> stuff and all) and yet we will have 99% covered, including the case above.</p>
<p>As an alternative, we could mimic <a href="https://serde.rs/attr-bound.html">serde</a>:</p>
<pre><code class="language-rust">// `T: StructOpt` will be added automatically 
// since there's no `#[structopt(bound(...))]` annotation  
// But no bounds for `U` will be generated since it's `skip`
#[derive(StructOpt)]
struct StructOpt&lt;T, U&gt; {
    arg: T,

    #[structopt(skip)]
    skipped: U
}

// `T: StructOpt` will NOT be added  
// since there's an explicit `#[structopt(bound(...))]` annotation  
#[derive(StructOpt)]
#[structopt(bound(&quot;S: FromStr + StructOpt&quot;))]
struct StructOpt&lt;S, T&gt; {
    #[structopt(parse(from_str))]
    arg: S,

    #[structopt(skip)]
    skipped: T,
}
</code></pre>
<p>Both alternatives are pretty easy to implement</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Monday Dec 30, 2019 at 19:14 GMT</em></p>
<hr />
<p>I'm reopening this since it looks like there are people interested in this feature out there (#317).</p>
<p>A PR implementing this serde-like design will be accepted:</p>
<pre><code class="language-rust">// Every generic that occurs in a field annotated with 
// either `#[structopt(flatten)]` or `#[structopt(subcommand)]` 
// will be given `G: StructOpt` bound by default 
// (i.e when no `#[structopt(bound(...))]` is present).
//
// `T: StructOpt` will be added automatically
// since there's no `#[structopt(bound(...))]` annotation and 
// it occurs in `#[structopt(flatten)]`. Same story for `U` (because of `subcommand`).
//
// No `StructOpt` bounds for B should be generated 
// since none of the fields it occurs in
// are marked with `subcommand` nor `flatten`.
//
// Additionally, each field marked with `#[structopt(parse(...))]` 
// (with no explicit function) has to be bounded with one of
//
// * G: std::convert::From&lt;&amp;'_ str&gt; (for `from_str`)
// * G: std::str::FromStr&lt;&amp;'_ str&gt; (for `try_from_str`, including implicit)
// * G: std::convert::From&lt;&amp;'_ OsStr&gt; (for `from_os_str`)
// * G: std::convert::From::from&lt;bool&gt; (for `from_flag`)
//
// No &quot;parse&quot; bounds will be generated for `from_occurences` (subject for future design)
// and `try_from_os_str`, as well as no &quot;parse&quot; bounds will be generated for explicit 
// `#[structopt(parse(type = explicit::function))]`
// 
#[derive(StructOpt)]
struct ImplicitBounds&lt;T, U, B&gt; {
    #[structopt(flatten)]
    arg: T,

    #[structopt(subcommand)]
    subcmd: U,

    #[structopt(skip)]
    skipped: B,

    other: B,

    // implicit `parse(try_from_str)`
    //
    // T: std::str::FromStr&lt;&amp;'_ str&gt;
    arg2: T, 

    // U: std::convert::From&lt;&amp;'_ str&gt;
    #[structopt(parse(from_str))]
    arg3: U,

    // B: std::convert::From&lt;&amp;'_ OsStr&gt;
    #[structopt(parse(from_os_str))]
    arg4: B,

    // A: std::convert::From::from&lt;bool&gt;
    #[structopt(parse(from_flag))]
    arg5: A,
}

// Generated:
impl&lt;T, U, B, A&gt; StructOpt for ImplicitBounds&lt;T, U, B, A&gt; 
where
    T: StructOpt + FromStr&lt;&amp;'_ str&gt;,
    U: StructOpt + From&lt;&amp;'_ str&gt;,
    B: From&lt;&amp;'_ OsStr&gt;,
    A: From::from&lt;bool&gt;
{
    // ...
} 


// User is able to override the automatic bounds via 
// `#[structopt(bound(...))]` attribute
//
#[derive(StructOpt)]
struct ExplicitBounds&lt;S, T, U&gt; {
    #[structopt(bound(S: FromStr + AnotherTrait)), parse(from_str))]
    arg: S,

    #[structopt(flatten)]
    #[structopt(bound(T: StructOpt + AnotherTrait))]
    flatten: T,

    // The bounds will be generated automatically 
    // since there's no `bound` attribute present 
    error: U 
}

// Generated:
impl&lt;S, T, U&gt; StructOpt for ExplicitBounds&lt;S, T, U&gt; 
where
    T: StructOpt + AnotherTrait,
    S: FromStr + AnotherTrait,
    U: FormStr
{
    // ...
}
</code></pre>
<p>cc @TeXitoi do you agree with this design?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Tuesday Jan 07, 2020 at 20:38 GMT</em></p>
<hr />
<p>I don't think bound should be on fields, more on the struct.</p>
<p>Automatic bound seems complicated to anticipate for the user.</p>
<p>It might complexify the code a lot.</p>
<p>I'm afraid it will be a lot of work for little usage.</p>
<p>I'm not totally against this feature, but it must be simple enough to understand, implement, document and maintain.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/CreepySkeleton"><img src="https://avatars.githubusercontent.com/u/50968528?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/CreepySkeleton">CreepySkeleton</a></strong>
<em>Wednesday Jan 08, 2020 at 05:38 GMT</em></p>
<hr />
<p>I must confess, I just stole the design from <a href="https://serde.rs/attr-bound.html"><code>serde</code></a>.</p>
<blockquote>
<p>I don't think bound should be on fields, more on the struct.</p>
</blockquote>
<p>I think that &quot;fields vs struct bound attr&quot; is quite irrelevant here, either will do.</p>
<blockquote>
<p>Automatic bound seems complicated to anticipate for the user.</p>
</blockquote>
<p>Not really. I tried to design the automatic bounding so it will work in 99% cases, as any good heuristic would. Thus, in 99% cases users shouldn't even be aware of it since everything &quot;just works&quot;.</p>
<p>Explicit <code>bound</code> attributes are for cases like <code>Foo&lt;T&gt;</code>, where it's unclear what to do: <code>Foo&lt;T&gt;: Trait</code> vs <code>T: Trait</code> (i.e if the generic is just a part of the type, not the type itself). In such cases, no bounds will be generated anyway ¯\<em>(ツ)</em>/¯</p>
<p>I honestly can't see a case where this auto bounding may misfire, can you?</p>
<blockquote>
<p>It might complexify the code a lot. I'm afraid it will be a lot of work for little usage.</p>
</blockquote>
<p>Not really. In essence, all we need is:</p>
<ul>
<li>Traverse the graph (already implemented)</li>
<li>Collect the info (partially implemented)</li>
<li>Pass it to the top level (this is where dragons be, but should be fairly easy after the refactoring).</li>
<li>Generate and emit the <code>where</code> clause (easy).</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/nathan-at-least"><img src="https://avatars.githubusercontent.com/u/4369700?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/nathan-at-least">nathan-at-least</a></strong>
<em>Wednesday Sep 01, 2021 at 19:53 GMT</em></p>
<hr />
<p>I just ran into this with a similar use case to @vorner: I want an &quot;app framework&quot; library that provides consistent logging options across all apps, and then also initializes logging for apps, so I naively just reached for this:</p>
<pre><code>trait Command: StructOpt {
    fn execute(&amp;self) -&gt; std::io::Result&lt;()&gt;;
}

#[derive(StructOpt)]
pub struct Options&lt;T: Command&gt; {
    #[structopt(flatten)]
    log_opts: loglib::LogOptions,

    #[structopt(subcommand)]
    cmd: T,
}

fn do_main&lt;T: Command&gt;() -&gt; std::io::Result&lt;()&gt; {
    let opts = Options::&lt;T&gt;::from_flags();
    opts.log_opts.init_logging()?;
    opts.cmd.execute()
}
</code></pre>
<p>When I follow the link in https://github.com/TeXitoi/structopt/issues/128#issuecomment-408409015 I don't see any code relevant to <code>structopt</code>, so I don't know what the workaround was.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/TeXitoi"><img src="https://avatars.githubusercontent.com/u/5787066?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/TeXitoi">TeXitoi</a></strong>
<em>Wednesday Sep 01, 2021 at 20:44 GMT</em></p>
<hr />
<p>I'll try to look at it tomorrow, but, as a first read, don't you want to flatten your T instead is subcommand?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:14</div>
            <div class="timeline-body"><p><a href="https://github.com/vorner"><img src="https://avatars.githubusercontent.com/u/11783500?v=4" align="left" width="48" height="48" hspace="10"></img></a> <strong>Comment by <a href="https://github.com/vorner">vorner</a></strong>
<em>Thursday Sep 02, 2021 at 06:29 GMT</em></p>
<hr />
<p>Ah, sorry, the code moved to another place since then :-(.</p>
<p>It is now here and the workaround is updated since then a bit. This link probably should keep its content:
https://github.com/vorner/spirit/blob/ce2ec171320b33ff34e645250c8951a5cce3a926/src/cfg_loader.rs#L76</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2021-12-09 16:22</div>
            <div class="timeline-body"><p>I believe this is now resolved, check out the tests at https://github.com/clap-rs/clap/blob/master/tests/derive/generic.rs.</p>
<p>if I missed anything in this thread, feel free to let me know</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2021-12-09 16:22</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-derive</span> added by @epage on 2021-12-09 16:41</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:34:46 UTC
    </footer>
</body>
</html>
