```yaml
number: 2389
title: Clap derive should parse markdown doc comment into normal text
type: issue
state: closed
author: ducaale
labels:
  - C-bug
  - E-medium
  - A-derive
  - S-blocked
assignees: []
created_at: 2021-03-06T20:39:44Z
updated_at: 2025-02-03T22:38:07Z
url: https://github.com/clap-rs/clap/issues/2389
synced_at: 2026-01-10T01:57:44Z
```

# Clap derive should parse markdown doc comment into normal text

---

_Issue opened by @ducaale on 2021-03-06 20:39_

Maintainer's notes:
- Workaround: `verbatim_doc_comment` attribute
- `unstable-markdown` feature is being tracked in #5900

---
### Please complete the following tasks

- [X] I have searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [X] I have searched the existing issues

### Rust Version

rustc 1.48.0 (7eac88abb 2020-11-16)

### Clap Version

3.0.0-beta.2

### Minimal reproducible code

```rust
use clap::Clap;

#[derive(Clap, Debug)]
#[clap(name = "xh")]
struct Cli {
    /// Optional key-value pairs to be included in the request.
    ///
    /// - key:=value to add a complex JSON value (e.g. `numbers:=[1,2,3]`)
    /// - key@filename to upload a file from filename (with --form)
    /// - header:value to add a header
    /// - header: to unset a header
    /// - header; to add a header with an empty value
    ///
    /// A backslash can be used to escape special characters (e.g. weird\:key=value).
    #[clap(value_name = "REQUEST_ITEM")]
    raw_rest_args: Vec<String>
}

fn main() {
      let _ = Cli::parse();
}
```


### Steps to reproduce the bug with the above code
```
cargo run -- --help
```

### Actual Behaviour
```
ARGS:
    <REQUEST_ITEM>...
            Optional key-value pairs to be included in the request.

            * key==value to add a parameter to the URL \n * key=value to add a JSON field (--json)
            or form field (--form) * key:=value to add a complex JSON value (e.g.
            `numbers:=[1,2,3]`) * key@filename to upload a file from filename (with --form) *
            header:value to add a header * header: to unset a header * header; to add a header with
            an empty value

            A backslash can be used to escape special characters (e.g. weird\:key=value).
```
### Expected Behaviour
```
ARGS:
    <REQUEST_ITEM>...
            Optional key-value pairs to be included in the request.

            * key==value to add a parameter to the URL
            * key=value to add a JSON field (--json) or form field (--form)
            * key:=value to add a complex JSON value (e.g. `numbers:=[1,2,3]`)
            * key@filename to upload a file from filename (with --form)
            * header:value to add a header
            * header: to unset a header
            * header; to add a header with an empty value

            A backslash can be used to escape special characters (e.g. weird\:key=value).
```
### Additional Context

In StructOpt, it possible to use the `long_help` attribute to preserve newlines but ~~I couldn't find something similar in clap-derive~~.

Just found that it is called `long_about` in clap-derive.

### Debug Output

Will add if requested

---

_Label `T: bug` added by @ducaale on 2021-03-06 20:39_

---

_Label `C: derive macros` added by @pksunkara on 2021-03-06 20:45_

---

_Label `D: easy` added by @pksunkara on 2021-03-06 20:45_

---

_Label `:money_with_wings: $5` added by @pksunkara on 2021-03-06 20:45_

---

_Added to milestone `3.0` by @pksunkara on 2021-03-06 20:45_

---

_Referenced in [clap-rs/clap#2401](../../clap-rs/clap/pulls/2401.md) on 2021-03-09 19:24_

---

_Label `:money_with_wings: $5` removed by @pksunkara on 2021-04-06 08:47_

---

_Label `D: easy` removed by @pksunkara on 2021-04-06 08:47_

---

_Comment by @pksunkara on 2021-04-06 08:49_

There is quite a bit of discussion in #2401 

---

_Removed from milestone `3.0` by @pksunkara on 2021-04-23 09:25_

---

_Added to milestone `3.1` by @pksunkara on 2021-04-23 09:25_

---

_Renamed from "Preserve newlines in Doc comments" to "Clap derive should parse markdown doc comment into normal text" by @pksunkara on 2021-11-14 00:32_

---

_Referenced in [clap-rs/clap#3019](../../clap-rs/clap/issues/3019.md) on 2021-11-14 00:32_

---

_Referenced in [ouch-org/ouch#196](../../ouch-org/ouch/pulls/196.md) on 2021-11-14 01:14_

---

_Referenced in [epage/clapng#181](../../epage/clapng/issues/181.md) on 2021-12-06 21:13_

---

_Referenced in [clap-rs/clap#3122](../../clap-rs/clap/issues/3122.md) on 2021-12-10 01:39_

---

_Removed from milestone `3.1` by @epage on 2021-12-13 16:25_

---

_Label `S-waiting-on-design` added by @epage on 2021-12-13 16:31_

---

_Comment by @epage on 2021-12-13 16:33_

One of the challenges with this is we'd basically need to pull in pulldown-cmark which is quite a large dependency.  This would need to be put behind a feature flag.

---

_Comment by @ducaale on 2021-12-13 16:53_

My main goal was to preserve newlines in the doc comment and that should be achievable with the `verbatim_doc_comment` attribute.

#### Example

```rust
// clap = { version = "3.0.0-rc.4", features = ["derive"] }

use clap::Parser;

#[derive(Parser, Debug)]
#[clap(name = "xh")]
struct Cli {
    /// Optional key-value pairs to be included in the request.
    ///
    ///   â€¢ key:=value to add a complex JSON value (e.g. `numbers:=[1,2,3]`)
    ///   â€¢ key@filename to upload a file from filename (with --form)
    ///   â€¢ header:value to add a header
    ///   â€¢ header: to unset a header
    ///   â€¢ header; to add a header with an empty value
    ///
    /// A backslash can be used to escape special characters (e.g. weird\:key=value).
    #[clap(value_name = "REQUEST_ITEM", verbatim_doc_comment)]
    raw_rest_args: Vec<String>,
}

fn main() {
    let _ = Cli::parse();
}

```

#### Output
```
USAGE:
    temp-clap [REQUEST_ITEM]...

ARGS:
    <REQUEST_ITEM>...
            Optional key-value pairs to be included in the request.

              â€¢ key:=value to add a complex JSON value (e.g. `numbers:=[1,2,3]`)
              â€¢ key@filename to upload a file from filename (with --form)
              â€¢ header:value to add a header
              â€¢ header: to unset a header
              â€¢ header; to add a header with an empty value

            A backslash can be used to escape special characters (e.g. weird\:key=value).

OPTIONS:
    -h, --help
            Print help information
```

I wouldn't mind if this issue was to be closed.

---

_Comment by @epage on 2021-12-13 17:03_

I think its still an interesting topic for us to weigh out.  I did call out the workaround in the issue so its more discoverable.

---

_Referenced in [clap-rs/clap#3198](../../clap-rs/clap/issues/3198.md) on 2021-12-18 18:57_

---

_Referenced in [clap-rs/clap#3228](../../clap-rs/clap/pulls/3228.md) on 2021-12-28 04:27_

---

_Comment by @I60R on 2021-12-29 02:51_

We may need only a subset of markdown features in CLI parser:

- newline escaping (implemented in #3228)
- lists as suggested here (should be relatively easy to implement, even with nesting)
- bold, italic, bold-italic, inline code - if colors enabled (not sure whether it's worth effort, but why not?)
- fenced code blocks (without syntax highlighting, of course)

There also could be some mechanism to cut off help message from doc comment as @epage suggested [here](https://github.com/clap-rs/clap/issues/3198#issuecomment-1002154924) â€” IMO markdown headers are a perfect mechanism for that e.g.:

- without any header everything goes to -h --help output
  - that's the same as if everything was placed under `# Help` header
- if `# Long help` is specified that section will be appended to --help output (only)
- we may also have `# Manpage` section (if clap will provide some mechanism for manpage generation)
- text under all other headers will be ignored by clap

---

I think this subset should satisfy 99.9% of all use cases of clap, everyone should like it, and it doesn't seem to be so complicated to require pulldown-cmark or any other heavy dependency.

---

_Comment by @epage on 2021-12-29 16:23_

My experience writing one off parsers has made me a bit cautious of doing so.  I threw together some [md parser benchmarks](https://github.com/epage/md-benchmarks-rs) to see what might be small enough for being an optional dependency.  `minimad` looks tempting.

---

_Comment by @epage on 2021-12-30 12:32_

Another thought on markdown support, should we support it at runtime, compile time, or both?

The core of this Issue is our line breaks which is a problem exclusive to the derive API.  For that, we could build markdown parsing directly into `clap_derive`.

Another step up is markdown formatting.  For that, we'd want to expose it to both APIs.  Say we generalized our `Colorizer` struct and accepted it for all our user-facing inputs (for #1790, #1433), users can do whatever styling they want, though it might be a bit arduous.  We then provided a markdown-parsing macro that would code-generate `Colorizer`.  `clap_derive` would then have this built-in for all doc comments.

The main benefit of this is that this would remove the binary-size overhead of the markdown parser.  We'd still need to compile it (though it'd be optional).  Though this would mean we wouldn't regress in `--help` and error performance by introducing markdown, the performance would have to be pretty bad for us to care.

This has the added benefit that we wouldn't need yet-another Setting in the API for doing controlling this at runtime.


---

_Comment by @epage on 2021-12-30 12:34_

Another question for us to answer in this issue is how disruptive would markdown parsing be.   While `--help`s output is not considered "stable", we shouldn't dramatically alter users crafting of their help output.  To what degree of markdown parsing can we add in a patch, a feature release, or a breaking release?

---

_Referenced in [clap-rs/clap#3230](../../clap-rs/clap/issues/3230.md) on 2021-12-30 17:44_

---

_Referenced in [clap-rs/clap#3231](../../clap-rs/clap/pulls/3231.md) on 2021-12-30 17:45_

---

_Comment by @gibfahn on 2021-12-30 19:38_

>Another thought on markdown support, should we support it at runtime, compile time, or both?

Compile time only sounds reasonable to me (but I only use the derive API, so I guess I would say that ðŸ˜) .

> Another question for us to answer in this issue is how disruptive would markdown parsing be.

I _think_ that (as a user) if markdown parsing were turned on for existing help text that would probably break a bunch of people, but if it was behind a flag, or minor updates to the markdown output were later made in minor/patch updates, that would probably be fine, as what was intended to be output would still be there, just maybe looking slightly prettier.

>The core of this Issue is our line breaks which is a problem exclusive to the derive API. For that, we could build markdown parsing directly into clap_derive.

For what it's worth there are a bunch of other things I would use if we had markdown support, not least:

1. _Italic_ and **bold** `inline code`
2. Subheadings and code blocks, e.g.:
   ````markdown
   ## EXAMPLES: <!-- Should be highlighted yellow the same way the other sections in the generated help like USAGE: are today. -->

   <!-- Syntax highlighting in examples would be really neat. -->
   ```console
   # Run the subcommand with the arg specified.
   â¯ my-command my-subcommand --my-arg
   ```
   ````
3. docs.rs compatibility -> If you have a binary/library combo that takes a set of options, it's nice to be able to use the same documentation for docs.rs and for `mycmd --help`.

---

_Comment by @epage on 2021-12-30 20:36_

> `<!-- Syntax highlighting in examples would be really neat. -->`

I was hoping someone wasn't going to say that :)

syntect is the main go-to for syntax highlighting.    It can be a bit slow to compile and big.  It can be made optional.    Looks like we can also disable the built-in language / theme set.  I doubt we need all of them.  The question is what languages do we need at minimum and how should we respond *if* someone asks for another language.

We'll need to do some analysis to decide how worth it this is vs [generating help at build-time](https://github.com/clap-rs/clap/issues/2914)

---

_Referenced in [clap-rs/clap#3234](../../clap-rs/clap/issues/3234.md) on 2021-12-31 12:46_

---

_Referenced in [NNPDF/pineappl#89](../../NNPDF/pineappl/issues/89.md) on 2022-01-07 17:06_

---

_Referenced in [clap-rs/clap#1695](../../clap-rs/clap/issues/1695.md) on 2022-01-20 15:36_

---

_Referenced in [clap-rs/clap#3108](../../clap-rs/clap/issues/3108.md) on 2022-01-20 21:17_

---

_Referenced in [clap-rs/clap#4110](../../clap-rs/clap/pulls/4110.md) on 2022-08-24 15:27_

---

_Referenced in [clap-rs/clap#4114](../../clap-rs/clap/pulls/4114.md) on 2022-08-25 18:44_

---

_Referenced in [clap-rs/clap#4132](../../clap-rs/clap/issues/4132.md) on 2022-08-27 02:18_

---

_Referenced in [clap-rs/clap#4444](../../clap-rs/clap/pulls/4444.md) on 2022-11-02 22:58_

---

_Comment by @epage on 2023-07-17 13:22_

One design problem I've been running into is how to render markdown at compile time when the colors aren't known until runtime.

I think the way to do this is to allow a `fn(fmt, palette) -> fmt::Result` to be passed into `StyledStr` and the derive would generate this, parsing the markdown at compile time but rendering the styles at runtime.

---

_Label `S-waiting-on-design` removed by @epage on 2023-07-18 01:26_

---

_Label `E-medium` added by @epage on 2023-07-18 01:26_

---

_Label `S-blocked` added by @epage on 2023-07-18 01:27_

---

_Referenced in [clap-rs/clap#5053](../../clap-rs/clap/issues/5053.md) on 2023-07-30 05:03_

---

_Referenced in [clap-rs/clap#5144](../../clap-rs/clap/issues/5144.md) on 2023-09-27 15:44_

---

_Referenced in [clap-rs/clap#5196](../../clap-rs/clap/issues/5196.md) on 2023-11-06 19:52_

---

_Referenced in [rust-lang/rust-clippy#12747](../../rust-lang/rust-clippy/pulls/12747.md) on 2024-05-06 15:44_

---

_Referenced in [prefix-dev/pixi#1338](../../prefix-dev/pixi/pulls/1338.md) on 2024-05-07 11:52_

---

_Comment by @pronebird on 2024-07-02 20:03_

I'd only ask for italic and bold for basic formatting.

---

_Referenced in [fulcrumgenomics/fqtk#45](../../fulcrumgenomics/fqtk/pulls/45.md) on 2024-07-16 20:47_

---

_Referenced in [oxidecomputer/oxide.rs#782](../../oxidecomputer/oxide.rs/pulls/782.md) on 2024-08-12 15:27_

---

_Referenced in [stellar/stellar-cli#1551](../../stellar/stellar-cli/pulls/1551.md) on 2024-09-26 20:22_

---

_Comment by @nrdxp on 2024-10-20 05:02_

In my case I just want to add a space in a list without having to add a newline between the bullets and without having to use verbatim doc comments (so wrap_help is respected properly)

---

_Referenced in [clap-rs/clap#5802](../../clap-rs/clap/issues/5802.md) on 2024-11-04 18:18_

---

_Referenced in [clap-rs/clap#5803](../../clap-rs/clap/pulls/5803.md) on 2024-11-04 18:21_

---

_Referenced in [jj-vcs/jj#4808](../../jj-vcs/jj/pulls/4808.md) on 2024-11-09 00:51_

---

_Comment by @ModProg on 2025-01-19 22:06_

Is there some specification on how this should work? Should we fully parse markdown, or should we just implement the parts that make sense, i.e., lists, bold, italic? I'm currently quite annoyed by lists not working so I'd be willing to invest some time into implementing some solution here.

---

_Comment by @alerque on 2025-01-19 22:16_

How established is CommonMark in Rust docs contexts? I would suggest pulldown-cmark or, if another Markdown parser is established in Rust context whatever that is, as a full flow Markdown parser makes more sense than a "whatever makes sense/minimalist" approach. Markdown is notoriously hard to actually get right even if small things like emphasis or list parsing.

---

_Comment by @epage on 2025-01-20 15:44_

Subsets of markdown were covered earlier in the thread
https://github.com/clap-rs/clap/issues/2389#issuecomment-1002370465



---

_Comment by @ModProg on 2025-01-20 17:19_

https://github.com/clap-rs/clap/issues/2389#issuecomment-1002673827 you also cautioned against writing a custom parser should we just use pulldown-cmark and ignore the ones we don't support?

Also should this be configurable, for some the mapping to ANSI is pretty clear e.g. **bold** or *italic* while for others it's unclear e.g. `code_block` should that set a backgroun? or keep the quotes ` ?

Another thing to consider would be should support be implemented for html tags like in color_print: https://docs.rs/color-print/latest/color_print/index.html#list-of-accepted-tags

---

_Comment by @epage on 2025-01-20 17:27_

> https://github.com/clap-rs/clap/issues/2389#issuecomment-1002673827 you also cautioned against writing a custom parser should we just use pulldown-cmark and ignore the ones we don't support?

Looking at [md parser benchmarks](https://github.com/epage/md-benchmarks-rs),  I would be curious about how well we could get by with minimad.

Details like `code_lock` would need to be figured out.  In a way, it is another form of literal.

It would be good to have a way for people to set colors but I would be worried about full HTML support.

---

_Comment by @ModProg on 2025-01-20 18:18_

> It would be good to have a way for people to set colors but I would be worried about full HTML support.

The only reason I mentioned `color_print` is that it is referenced in the clap docs, and it could be nice to also be able to use it inside of markdown.

I would agree that any block elements would be annoying to deal with, so only inline ones could work. Maybe adding some tags for all the styles definable could be useful, i.e., `<header>`, `<error>`, `usage`, ...

> Details like `code_block` would need to be figured out. In a way, it is another form of literal.

Makes sense, though one could also add the different markdown elements to `Styles`, e.g., if someone wants to color their bold text red. 

The other question is should mark down parsing be enabled at runtime as well? If not, the compile time parsed markdown needs to be converted like you suggested here:
> One design problem I've been running into is how to render markdown at compile time when the colors aren't known until runtime.
> I think the way to do this is to allow a fn(fmt, palette) -> fmt::Result to be passed into StyledStr and the derive would generate this, parsing the markdown at compile time but rendering the styles at runtime.

Even if we support markdown parsing at runtime, one might like to move that effort to compilation where possible, but we could also just implement it for runtime first and then check if there is a relevant performance penalty end disable it if so.

The whole markdown feature should probably be behind a feature flag anyway.

Would you be in favor of building a PoC for markdown parsing to test it out?

---

_Comment by @epage on 2025-01-20 19:08_

I suspect we should do this all at compile time though either direction comes with its problems.

One combination of challenges
- I intentionally switched `StyledStr` to only hold ANSI escape codes
- If we want to provide style classes like "header",  the conversion of that to ANSI is only really available at runtime

iirc there were more.  Feel free to play around and come back with more ideas.  I feel like I'd want things settled a little more before adding an unstable feature for this.

---

_Comment by @ModProg on 2025-01-24 14:27_

I found two issues with minimad, doesn't support lists using `-` and doesn't support multilevel list, because it thinks they are codeblocks https://github.com/Canop/minimad/issues/2.

While multilevel lists probably aren't as important, the list style could be quite confusing and result in unnecessary issues :D

```md
- Not recognised as list
* Is a list
    * is a code block
```
results in:
```rust
Text {
    lines: [
        Normal(
            Composite {
                style: Paragraph,
                compounds: [],
            },
        ),
        Normal(
            Composite {
                style: Paragraph,
                compounds: [
                    "- Not recognised as list",
                ],
            },
        ),
        Normal(
            Composite {
                style: ListItem(
                    0,
                ),
                compounds: [
                    "Is a list",
                ],
            },
        ),
        Normal(
            Composite {
                style: Code,
                compounds: [
                    "* is a code block",
                ],
            },
        ),
    ],
}
```

I'm gonna experiment with pulldown, but shouldn't be too bad to switch that later on

---

_Comment by @epage on 2025-01-24 14:31_

I wonder if they'd be open to adding more list styles.

---

_Comment by @ModProg on 2025-01-24 14:53_

> I wonder if they'd be open to adding more list styles.

Might be, but the issue was open for 4 years, and I was more interested in the other parts of this, but I think the main considerations are independent of parser and should be therefor easy enough to replace.

---

_Comment by @passcod on 2025-01-24 18:15_

Just because I looked it up, I'll note for context that rustdoc uses pulldown-cmark, so that would be the most directly compatible.

---

_Referenced in [clap-rs/clap#5891](../../clap-rs/clap/pulls/5891.md) on 2025-01-24 22:44_

---

_Comment by @ModProg on 2025-01-24 22:49_

Created an initial PoC https://github.com/clap-rs/clap/pull/5891

![Image](https://github.com/user-attachments/assets/321f847b-6f33-47f8-9650-6b8d45e2dacc)

Still some things to figure out, like should we use Unicode characters for list items? And which styles should we apply as we don't have access to the actual styles.

One thing I also need to fix is that `anstyle` fully resets the style when ending e.g. bold, so I need to restart italic manually.

---

_Comment by @epage on 2025-01-24 22:53_

I know at least Cargo is cautious on the use of unicode, auto-detecting when terminals should support it with a config to override it.

---

_Comment by @ModProg on 2025-01-25 15:55_

> I know at least Cargo is cautious on the use of unicode, auto-detecting when terminals should support it with a config to override it.

As that'd be hard to do at compile time, should we only output ASCII for now? The only alternative would be to generate 2 help messages and then in the generated builder switch between them depending on Unicode capability.

---

_Comment by @ModProg on 2025-01-26 03:12_

Short works as expected, i.e., only taking the first paragraph:

![Image](https://github.com/user-attachments/assets/70664c24-9d8d-4e8c-a787-c698dfecf737)

Long takes everything

![Image](https://github.com/user-attachments/assets/ded494de-c2a3-4613-8f3e-5b2d55647f5b)

@epage Should we also investigate using headings for separating sections and if so what would be the names? `# Help` and `# Long help` (probably matching any casing)? 

Following https://github.com/clap-rs/clap/issues/2389#issuecomment-1002370465 the implementation would be as follows:

1. if the doc comment contains no top-level heading with the content `help` (any casing) then follow regular procedure, i.e. take first paragraph as `help` and everything as `long_help`.
2. if the doc comment contains a top-level `help` heading take everything below it and use it for `help` if there is also a `long help` heading take everything below `help` and `long help` and use it for the long help.

This leaves the following questions for me:
1. What if the doc comment only contains `# Long Help`?

And the following alternative implementations
1. We could instead of `# Long Help` use a sub heading of `# Help` called `## Long`.
2. We could (if there is no `# Long Help`) apply the default parsing behavior to the content of `# Help` i.e. use the first paragraph for `help` and everything for `long_help`.
3. Should we, if `# Long Help` is specified only output this section as the complete text for `long_help`? This could be helpful if the short help is redundant when the `long_help` is also printed. In this case we could use `# Long Help` to contain the complete `long_help` and use the `## Long (Help)` below `# Help` to have the behavior of everything before `## Long` is only contained in `help` while `long_help` would contain everything in the `# Help` section including `## Long`.

---

_Comment by @ModProg on 2025-01-26 03:15_

btw there was one test where the output changed because of this, as now `` ` `` is dropped in the output.

---

_Comment by @epage on 2025-01-27 16:23_

imo any handling of `# Help` and `# Long Help` would be a breaking change and doesn't need to be handled with improved markdown handling, so I'd recommend someone open a dedicated issue on it once we have this.

---

_Comment by @ModProg on 2025-01-27 17:31_

> imo any handling of `# Help` and `# Long Help` would be a breaking change and doesn't need to be handled with improved markdown handling, so I'd recommend someone open a dedicated issue on it once we have this.

Agreed, solves a very different problem to simple markdown parsing as well.

---

_Comment by @ModProg on 2025-01-27 23:55_

@epage I did document the styling in the PR-description (#5891). Feel free to expand on it.

---

_Closed by @epage on 2025-02-03 21:32_

---

_Comment by @epage on 2025-02-03 22:38_

See #5900 for the tracking issue

---
