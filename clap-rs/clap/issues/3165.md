```yaml
number: 3165
title: "Create a group from an `Args` struct"
type: issue
state: closed
author: epage
labels:
  - C-enhancement
  - E-medium
  - E-help-wanted
  - A-derive
  - ":money_with_wings: $20"
assignees: []
created_at: 2021-12-13T17:01:34Z
updated_at: 2023-03-28T17:20:59Z
url: https://github.com/clap-rs/clap/issues/3165
synced_at: 2026-01-10T01:57:46Z
```

# Create a group from an `Args` struct

---

_Issue opened by @epage on 2021-12-13 17:01_

Maintainer's notes
- [x] #4210 
- [x] #4303
- [x] #4305 
- [ ] #4697
- [x] #4574

---
### Please complete the following tasks

- [X] I have searched the [discussions](https://github.com/clap-rs/clap/discussions)
- [X] I have searched the existing issues

### Clap Version

3.0.0-rc.4

### Describe your use case

I have a group of fields that I want to make a group for conflicting with other fields

### Describe the solution you'd like

Inspired by #2621, what if we implicitly created a group from a struct? 
```rust
#[derive(Args)]
struct Group {
    arg1: String,
    arg2: String
}
```
would have an implicitly created `ArgGroup::new("Group").multiple(true)`.

You could then do
```rust
#[derive(Args)]
#[group(...group builder methods...)]
struct Group {
    arg1: String,
    arg2: String
}
```

### Alternatives, if applicable

Manually define the args and deal with typos in arg and group names and issues like #2475 

### Additional Context

~~The big issue is defining this to not conflict with other app or group attributes.  Somewhere I brought up the idea of more explicitly naming our attributes as `clap::app`,. `clap::args`, etc (#1553).  Maybe that can help?~~

Per-builder attributes are n
ow in

---

_Label `C-enhancement` added by @epage on 2021-12-13 17:01_

---

_Label `A-derive` added by @epage on 2021-12-13 17:01_

---

_Label `S-waiting-on-design` added by @epage on 2021-12-13 17:01_

---

_Renamed from "Create a group from an `Args`" to "Create a group from an `Args` struct" by @epage on 2021-12-13 17:01_

---

_Referenced in [clap-rs/clap#3171](../../clap-rs/clap/issues/3171.md) on 2021-12-14 00:31_

---

_Referenced in [clap-rs/clap#2621](../../clap-rs/clap/issues/2621.md) on 2022-05-09 14:50_

---

_Referenced in [clap-rs/clap#4210](../../clap-rs/clap/issues/4210.md) on 2022-09-13 14:39_

---

_Label `:money_with_wings: $20` added by @epage on 2022-09-13 14:39_

---

_Label `S-waiting-on-design` removed by @epage on 2022-09-13 14:39_

---

_Label `E-medium` added by @epage on 2022-09-13 14:39_

---

_Comment by @epage on 2022-09-13 14:46_

#4210 reserved some functionality in 4.0.0 that we could use for this.

---

_Referenced in [clap-rs/clap#4211](../../clap-rs/clap/issues/4211.md) on 2022-09-13 14:49_

---

_Label `E-help-wanted` added by @epage on 2022-09-20 14:34_

---

_Referenced in [clap-rs/clap#4279](../../clap-rs/clap/issues/4279.md) on 2022-09-28 22:16_

---

_Added to milestone `4.x` by @epage on 2022-09-29 20:31_

---

_Referenced in [clap-rs/clap#4302](../../clap-rs/clap/pulls/4302.md) on 2022-09-30 16:25_

---

_Referenced in [clap-rs/clap#4303](../../clap-rs/clap/pulls/4303.md) on 2022-09-30 16:44_

---

_Referenced in [clap-rs/clap#4305](../../clap-rs/clap/pulls/4305.md) on 2022-09-30 17:24_

---

_Comment by @ModProg on 2022-10-17 16:24_

I was actually stumbling on this trying to design a shard set of options for dynamic completions.

Would we support the use case of conflicting groups? I see two ways of doing it with increasing type safety (both not fully supported yet AFAICT):

### Semi-Typesafe
Type system ensures completeness of groups
```rs
#[derive(Parser)]
struct CompleteArgs {
    #[clap(flatten)]
    register: Option<Register>,
    #[clap(flatten)]
    complete: Option<Complete>,
}
#[derive(Args)]
#[group(conflicts_with = Complete)]
struct Register {
    #[arg(long)]
    shell: String,
}
#[derive(Args)]
struct Complete {
    #[arg(long)]
    current: String,
}
```
### Fully-Typesafe 
Type system ensures group conflict
somewhat related to #2621
```rs
#[derive(Parser)]
struct CompleteArgs {
    #[clap(arg_group)]
    register_or_complete: RegisterComplete,
}
#[derive(ArgGroups)]
enum RegisterComplete {
    Register(Register),
    Complete(Complete),
}
#[derive(Args)]
struct Register {
    #[arg(long)]
    shell: String,
}
#[derive(Args)]
struct Complete {
    #[arg(long)]
    current: String,
}
```

---

_Comment by @epage on 2022-10-17 16:41_

My expectation is we'll eventually support the fully type-safe solution as part of #2621

---

_Referenced in [clap-rs/clap#4569](../../clap-rs/clap/issues/4569.md) on 2022-12-22 15:07_

---

_Referenced in [clap-rs/clap#4574](../../clap-rs/clap/issues/4574.md) on 2022-12-23 18:02_

---

_Referenced in [clap-rs/clap#4697](../../clap-rs/clap/issues/4697.md) on 2023-02-08 13:43_

---

_Comment by @epage on 2023-03-28 17:20_

I'm going to consider this done with a known bug (#4697)

---

_Closed by @epage on 2023-03-28 17:20_

---

_Referenced in [oxidecomputer/offline-keystore#159](../../oxidecomputer/offline-keystore/issues/159.md) on 2023-05-10 18:34_

---
