<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Short options with arguments conflicts with `allow_hyphen_values` - clap-rs/clap #3410</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Short options with arguments conflicts with `allow_hyphen_values`</h1>

    <div class="meta">
        <span class="state-icon state-open"></span>
        <a href="https://github.com/clap-rs/clap/issues/3410">#3410</a>
        opened by <a href="https://github.com/197g">@197g</a>
        on 2022-02-06 17:06
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/197g">@197g</a> on 2022-02-06 17:06</div>
            <div class="timeline-body"><h3>Please complete the following tasks</h3>
<ul>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/discussions">discussions</a></li>
<li>[X] I have searched the <a href="https://github.com/clap-rs/clap/issues">open</a> and <a href="https://github.com/clap-rs/clap/issues?q=is%3Aissue+label%3AS-wont-fix+is%3Aclosed">rejected</a> issues</li>
</ul>
<h3>Clap Version</h3>
<p>3.0</p>
<h3>Describe your use case</h3>
<p>The program GNU <code>seq</code> requires us to parse floating point values as arguments, which may be negative or have formatting different from the standard <code>&lt;f64 as FromStr&gt;</code> style. At the same time it accepts some short options to control the output. The problematic case is combining those two: we must utilize <code>AllowHyphenValues</code> while also accepting short option values.</p>
<pre><code class="language-bash">$ seq -s, -1 2
-1,0,1,2
$ # Demonstrating non-f64-style arguments that must also match positional values:
$ seq -0x.ep-3 -0x.1p-3 -0x.fp-3
-0,109375
-0,117188
</code></pre>
<p>This is solved in GNU by external iteration over the arguments where <code>seq</code> itself decides what constitutes a flag, and what starts the value arguments: <a href="https://github.com/coreutils/coreutils/blob/master/src/seq.c#L593-L604">https://github.com/coreutils/coreutils/blob/master/src/seq.c#L593-L604</a></p>
<p>In clap, however, when <code>AllowHyphenValues</code> is active then only short options character are allowed to appear in an option. Otherwise, it is interpreted as a position argument. See https://github.com/clap-rs/clap/blob/5c3868ea4cb8063731d8526e8e97414942a987ae/src/parse/parser.rs#L994-L995</p>
<h3>Describe the solution you'd like</h3>
<p>Now, I would propose to add a new setting that slightly modifies these rules. Where an hyphenated argument may <em>start</em> with short options but where short option parsing stops at the first value-taking option, and any other characters are permitted when such an option is recognized. That is, in this context, where the short options <code>w</code> and <code>s</code> exist, <code>-ws,</code> would be interpreted as:</p>
<ol>
<li><code>w</code> matches a short option without argument, continue.</li>
<li><code>s</code> matches a short option that does take an argument, switching to value mode because this option takes a value.</li>
<li><code>-</code> is ignored as part of the value.</li>
<li>The argument <code>-ws,</code> is interpreted as options.</li>
</ol>
<h3>Alternatives, if applicable</h3>
<p>A more intricate solution would be to enable external iteration, where arguments are consumed by clap one-by-one. That is, more like the GNU style parsing loop where some <code>get_first_argument(iterator)</code> consumes only some arguments from the iterator but returns control to the caller after the first option has been consumed. This could enable an iteration loop in the style of GNU <code>seq</code> where the arguments are pre-tested by the program logic on whether they constitute a positional argument; allowing us to break manually instead of require <code>AllowHyphenValues</code> to control <code>clap</code> to do this internally.</p>
<h3>Additional Context</h3>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @197g on 2022-02-06 17:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/197g">@197g</a> on 2022-02-06 17:07</div>
            <div class="timeline-body"><p>Sorry, I forgot to fill out additional context: It's mentioned in <code>uutils/coreutils</code>: <a href="https://github.com/uutils/coreutils/pull/3081">https://github.com/uutils/coreutils/pull/3081</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-parsing</span> added by @epage on 2022-02-07 15:09</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">E-medium</span> added by @epage on 2022-02-07 15:09</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-02-07 15:10</div>
            <div class="timeline-body"><blockquote>
<p>Now, I would propose to add a new setting that slightly modifies these rules. Where an hyphenated argument may start with short options but where short option parsing stops at the first value-taking option, and any other characters are permitted when such an option is recognized</p>
</blockquote>
<p>I think this makes sense</p>
<blockquote>
<p>A more intricate solution would be to enable external iteration, where arguments are consumed by clap one-by-one. That is, more like the GNU style parsing loop where some get_first_argument(iterator) consumes only some arguments from the iterator but returns control to the caller after the first option has been consumed. This could enable an iteration loop in the style of GNU seq where the arguments are pre-tested by the program logic on whether they constitute a positional argument; allowing us to break manually instead of require AllowHyphenValues to control clap to do this internally.</p>
</blockquote>
<p>This sounds more like <code>lexopt</code>.  We have plans to modularize clap so we provide a lexopt-like crate and allow you to use all of the other parts of clap built up together.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3450.html">clap-rs/clap#3450</a> on 2022-02-11 22:06</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../getsentry/sentry-cli/issues/1186.html">getsentry/sentry-cli#1186</a> on 2022-04-12 10:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/6018.html">clap-rs/clap#6018</a> on 2025-05-27 17:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Short options with arguments conflicts with AllowHyphenValues" to "Short options with arguments conflicts with `allow_hyphen_values`" by @epage on 2025-05-27 17:00</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-05-27 17:01</div>
            <div class="timeline-body"><p>If I'm reading this correct, this is the same issue as #6018.  A more modern reproduction case is</p>
<pre><code class="language-rust">#!/usr/bin/env nargo
---
[dependencies]
clap = { version = &quot;4&quot;, features = [&quot;debug&quot;] }
---

use std::ffi::OsStr;

use clap::Command;
use clap::arg;


fn main() {
    let mut cmd = Command::new(&quot;build&quot;)
        .arg(arg!(-P --parallel &lt;N&gt;))
        .arg(arg!(&lt;ARGS&gt;...).trailing_var_arg(true).allow_hyphen_values(true));
    cmd.build();
    dbg!(&amp;cmd);

    let matches = if false {
        cmd.get_matches_from(vec![&quot;build&quot;, &quot;-P&quot;, &quot;32&quot;, &quot;foo&quot;, &quot;--bar&quot;])
    } else {
        cmd.get_matches_from(vec![&quot;build&quot;, &quot;-P32&quot;, &quot;foo&quot;, &quot;--bar&quot;])
    };

    dbg!(&amp;matches);

    assert_eq!(matches.get_one(&quot;parallel&quot;), Some(&amp;String::from(&quot;32&quot;)));
    let mut args = matches.get_raw(&quot;ARGS&quot;).unwrap().into_iter();
    assert_eq!(args.next(), Some(OsStr::new(&quot;foo&quot;)));
    assert_eq!(args.next(), Some(OsStr::new(&quot;--bar&quot;)));
}
</code></pre>
<p>(<code>if true</code> will succeed, <code>if false</code> will panic).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2025-05-27 17:02</div>
            <div class="timeline-body"><p>What I'm wondering is why we didn't consider just changing the behavior so that a short that takes a value is always considered a short, rather than a <code>MaybeHyphenValue</code>.</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:34:54 UTC
    </footer>
</body>
</html>
