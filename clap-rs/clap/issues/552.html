<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-generate manpage, help docs, etc. - clap-rs/clap #552</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Auto-generate manpage, help docs, etc.</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/552">#552</a>
        opened by <a href="https://github.com/joshtriplett">@joshtriplett</a>
        on 2016-06-30 08:55
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/joshtriplett">@joshtriplett</a> on 2016-06-30 08:55</div>
            <div class="timeline-body"><p>Maintainer notes:</p>
<ul>
<li>Blocked on https://github.com/clap-rs/clap/issues/2914 for decoupling help information gathering from formatting</li>
<li>help2man can be a source of inspiration for how to integrate this into a users process</li>
</ul>
<hr />
<p>I'd love to have support to generate a manpage.  This would use a mechanism and infrastructure similar to #376. Additional functions to override or augment portions of the generated manpage could come later, but I think with relatively few additions this could become an incredibly useful mechanism.</p>
<ul>
<li>The manpage title should default to the <code>bin_name</code> value.</li>
<li>The section should default to <code>1</code>.</li>
<li>The <code>NAME</code> section should default to <code>bin_name \- about</code>, where <code>about</code> is the string set by <code>.about</code>.</li>
<li>The <code>SYNOPSIS</code> section should contain the usage strings for the command and every subcommand.</li>
<li>The <code>DESCRIPTION</code> section would need some new paragraph-style information provided (also usable as a more structured <code>.before_help</code>).</li>
<li>The &quot;OPTIONS&quot; section should document the flags and args for the top-level command.</li>
<li>If the command has subcommands, a &quot;SUBCOMMANDS&quot; section should document each subcommand in a sub-section.</li>
<li>The <code>AUTHORS</code> section should contain the author information, if provided.</li>
<li>The <code>SEE ALSO</code> section would need some new mechanism to populate it.</li>
</ul>
<p>I'd be happy to help with manpage markup, once I see the details of the mechanism used in #376.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-06-30 13:29</div>
            <div class="timeline-body"><p>I like this idea! I'll have a better idea about what all it would take once I finish #376 but I think it could be done. And if nothing else, it'll at least give a really good starting point that one could then tweak manually with little effort.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/joshtriplett">@joshtriplett</a> on 2016-06-30 14:53</div>
            <div class="timeline-body"><p>Absolutely. I'm also hoping that, similar to <code>help2man</code> (which doesn't handle most of what clap can do), this could support providing arbitrary additional documentation to integrate into the generated manpage.  That would allow maintaining information in only one place (such as options and their documentation).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> added by @kbknapp on 2016-06-30 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">P4: nice to have</span> added by @kbknapp on 2016-06-30 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: hard</span> added by @kbknapp on 2016-06-30 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 2.x</span> added by @kbknapp on 2016-06-30 17:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: man page gen</span> added by @kbknapp on 2016-06-30 17:39</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/555.html">clap-rs/clap#555</a> on 2016-07-01 13:26</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/hgrecco">@hgrecco</a> on 2016-07-03 01:33</div>
            <div class="timeline-body"><p>I was thinking about the same thing recently and I think we can reuse much of the infrastructure done for the templated help. But I would also like to propose a different way to generate the man page (and access the completion). I am opening another issue for this.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Renamed from "Auto-generate manpage" to "Auto-generate manpage, help docs, etc." by @kbknapp on 2016-11-02 03:01</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2016-11-02 03:05</div>
            <div class="timeline-body"><p>Addressing this issue soon. I'd like to get the ability to generate man pages, help docs, etc. For the help docs, I'd especially like to be able to generate based off a template exactly like <code>App::template</code> works. Except recursively going through subcommands. The template would allow doing things like markdown, etc.</p>
<p>Also, for help docs I'd like to choice to split the files or use a single document.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: help pages gen</span> added by @kbknapp on 2016-11-02 03:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: intermediate</span> added by @kbknapp on 2016-11-02 03:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: hard</span> removed by @kbknapp on 2016-11-02 03:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x blocker</span> added by @kbknapp on 2017-05-09 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 2.x</span> removed by @kbknapp on 2017-05-09 18:55</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/matthiasbeyer">@matthiasbeyer</a> on 2017-06-01 11:16</div>
            <div class="timeline-body"><p>As far as I can see, this was moved to the <code>3.x</code> release for clap? Either way, I'd like to pronounce interest in this feature. Not only for <a href="https://github.com/neithernut/git-dit/">git-dit</a> but also for <a href="https://github.com/matthiasbeyer/imag/">imag</a>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../git-dit/git-dit/issues/92.html">git-dit/git-dit#92</a> on 2017-06-01 11:18</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2017-06-16 20:39</div>
            <div class="timeline-body"><p>@matthiasbeyer yes, this is a feature I want, but need to get 3.x out the door first because otherwise it'll just keep getting pushed off and pushed off.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../sharkdp/fd/issues/77.html">sharkdp/fd#77</a> on 2017-10-08 07:47</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../XAMPPRocky/tokei/issues/184.html">XAMPPRocky/tokei#184</a> on 2018-01-29 18:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x blocker</span> removed by @kbknapp on 2018-02-05 15:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x</span> added by @kbknapp on 2018-02-05 15:28</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1037.html">clap-rs/clap#1037</a> on 2018-02-15 14:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-cli/team/issues/1.html">rust-cli/team#1</a> on 2018-02-20 18:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-cli/team/issues/8.html">rust-cli/team#8</a> on 2018-02-20 19:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-cli/team/issues/14.html">rust-cli/team#14</a> on 2018-03-01 16:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-lang/cargo/pulls/5341.html">rust-lang/cargo#5341</a> on 2018-04-11 15:54</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../mesalock-linux/mesabox/issues/1.html">mesalock-linux/mesabox#1</a> on 2018-06-15 02:53</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/valpackett">@valpackett</a> on 2018-06-26 11:07</div>
            <div class="timeline-body"><p>Since clap has plenty of information about the structure of commands and args and whatnot, it should be possible to build pages in the <a href="https://manpages.bsd.lv/mdoc.html">mdoc</a> language, which is semantic (i.e. it has entities like &quot;flags&quot; and &quot;commands&quot; instead of just &quot;bold text&quot; etc.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "v3.0" by @kbknapp on 2018-07-22 00:50</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yoshuawuyts">@yoshuawuyts</a> on 2018-07-22 22:59</div>
            <div class="timeline-body"><p>Heya, on the CLI WG repo we've been working on this! It's a bit rough, but I reckon we might be able to create a compelling story!</p>
<ul>
<li>https://github.com/killercup/roff-rs/ exists to generate <code>.troff</code> files. It's a bit versose, so we built</li>
<li>https://github.com/rust-clique/man The goal is to have this generate (structured) man pages. We're mostly just waiting to merge https://github.com/rust-clique/man/pull/6 before it should be usable!</li>
<li>We also have <a href="https://github.com/rust-clique/man/blob/fc11e3765a3a94e4ba6e1943eb747fd704f69a61/src/lib.rs">an initial implementation of clap v3 -&gt; man page</a>. Perhaps it would make sense to move it into a separate repo first, and if it works out alright we could eventually stabilize it and move it into Clap.</li>
</ul>
<h2>Screenshot</h2>
<h3>Structured man page, generated by the <code>man</code> crate</h3>
<p><img src="https://user-images.githubusercontent.com/2467194/43051062-75fadd76-8e13-11e8-8731-177d0c137caf.png" alt="2018-07-19-141825_1920x1080" /></p>
<hr />
<p>Hope this is all useful. Excited to have man page support for Clap!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2018-07-23 18:01</div>
            <div class="timeline-body"><p>@yoshuawuyts this is awesome! My thoughts were to place the manpage generation into the <a href="https://github.com/clap-rs/clap_generate"><code>clap_generate</code></a> crate (I'm not opposed to a rename if there is something more fitting) along with the shell completion script generation since they're doing very similar things.</p>
<p>If you'd like I'd be more than willing to add people to the org and repo! So we can make it official.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/yoshuawuyts">@yoshuawuyts</a> on 2018-07-24 09:26</div>
            <div class="timeline-body"><p>@kbknapp oh awesome, that def seems like the right way forward! Would be happy to join in!</p>
<p>Also cc/ @spacekookie here (she wrote all the <code>clap v3 -&gt; man</code> glue code). Perhaps you would be interested in joining?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-cli/man/issues/9.html">rust-cli/man#9</a> on 2018-07-24 09:29</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/killercup">@killercup</a> on 2018-07-24 10:09</div>
            <div class="timeline-body"><p>@kbknapp not sure if you've seen it yet but I spend an hour yesterday to throw https://github.com/rust-clique/clap-md together -- its goal is to render Markdown documentation for clap applications. Feel free to move this to clap-generate, too! (I'd be sad to see that crate name go, though)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2018-07-25 03:39</div>
            <div class="timeline-body"><p>@killercup I love it! This is something I've been thinking about in the back of my mind that I'd love to put some time into! I've been passively looking at things like <a href="http://ricostacruz.com/flatdoc/">flatdoc</a> and how other projects with large CLIs have provided docs (ones like Docker, etc.) to see if there is something we could use. But it's been on the back burner with this 3.x work :stuck_out_tongue_winking_eye:</p>
<p>I've sent out the invites to the clap-rs org to the three of you above, and yeah I'd love to move that to the org as well!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-lang/cargo/issues/5729.html">rust-lang/cargo#5729</a> on 2018-08-07 12:25</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-lang/cargo/pulls/6405.html">rust-lang/cargo#6405</a> on 2018-12-17 17:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vn971">@vn971</a> on 2019-03-12 13:25</div>
            <div class="timeline-body"><p>Folks, how can I generate man pages from clap now? Is it possible?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-12 13:49</div>
            <div class="timeline-body"><p>I actually just accomplished a non-pure-rust version of that last night in the rewrites I did for my <a href="https://github.com/ssokolow/rust-cli-boilerplate">rust-cli-boilerplate</a>.</p>
<p>Basically, I tweaked the output from <code>StructOpt</code> to properly match Linux platform conventions (eg. setting <code>author=&quot;&quot;</code> and starting <code>about</code> with a newline so the <code>&lt;name&gt; &lt;version&gt;</code> line doesn't get wrapped into the beginning of the description text) and then ran <a href="https://www.gnu.org/software/help2man/"><code>help2man -N</code></a> on it.</p>
<p>If you want to poke at it, it's <code>just dist-supplemental</code> or the <code>just dist</code> and <code>just install</code> commands which depend on it. (They'll also build and, if requested, install completions for zsh, bash, and fish.)</p>
<p>(My next goal will probably be to clear out that &quot;build and publish a bundle of Clap validators for common cases&quot; TODO at the bottom of the readme.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-12 14:15</div>
            <div class="timeline-body"><p>Since I didn't think a boilerplate template necessitated screenshots in an already quite long README, here's what it looks like when I run <code>./apply.sh ../boilerplate; cd ../boilerplate; just install; man boilerplate</code>:
<img src="https://user-images.githubusercontent.com/46915/54206887-186a8b00-44d1-11e9-8b38-e0dfba5151f7.png" alt="screenshot2" /></p>
<p><strong>EDIT:</strong> And I just realized that I forgot to make <code>dist-supplemental</code> guarantee that the binary had already been built before calling help2man. Fixed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2019-03-13 15:37</div>
            <div class="timeline-body"><p>@ssokolow I think those generated man pages are using too much spaces, can you please try it with 80 columns for your terminal? It may look ugly on some terminal with lesser width though.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vn971">@vn971</a> on 2019-03-13 15:42</div>
            <div class="timeline-body"><p>@ssokolow will it work correctly with subcommands? The way <code>--help</code> works on clap now, it will just list the subcommands, but it will not show subcommand-specific keys and arguments. This will lead to incomplete man if piped to an external process directly.
Are the subcommands currently addressed in your project?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-13 17:48</div>
            <div class="timeline-body"><p>@pickfire Here's a screenshot at 80 columns (as lazily determined by running <code>print 'x'*80</code> in a Python REPL and then resizing the window to just fit it without wrapping)</p>
<p><img src="https://user-images.githubusercontent.com/46915/54300285-715f1f80-45b4-11e9-9701-f4d19fd042ad.png" alt="screenshot2" /></p>
<p>@vn971 I hadn't gotten around to trying to accomodate subcommands yet because I'm using my own needs to set the priority of various features and I don't use subcommands often.</p>
<p>For example:</p>
<ul>
<li><p>At the moment, I'm about to rewrite <code>apply.sh</code> in Python, add a config file, and have the default config file run <code>xdg-terminal</code>, <code>xdg-open src/main.rs</code>, and <code>git gui</code> after creating the new project since <em>that</em>'s the current number-one thing I could do to reduce my urge to turn to Python rather than Rust for quick little throwaway scripts which will turn out to be anything but. (I'll bundle copies of the XDG utilities as fallbacks that don't get copied into new projects.)</p>
<p>(I'm used to running <code>gvim script_name.py</code> in my Quake-style terminal followed by <code>boiler\c</code>, then bringing git into the mix when I realize it's not going to be a throwaway. This would solve that while making it even more convenient.)</p>
</li>
<li><p>I'm planning to experiment with a quick custom derive that allows me to hang StructOpt and something like config-rs off the same struct, then call <code>serde_output.merge(structopt_output)</code> as an &quot;I'm tired of waiting for a proper solution and I think ripgrep's solution is ugly&quot; way to get config files without duplicating the schema.</p>
</li>
<li><p>Both as a convenient reference for myself and as part of my commitment to good documentation, I'm planning to rename the validators after their intended uses (ie. <code>output_file_path</code> rather than <code>path_valid_portable</code>) and include a block like this at the top of each validator's rustdoc page:</p>
<blockquote>
<p><strong>Conventions:</strong>:</p>
<ul>
<li>Use <code>-o</code> to specify the output path <a href="http://www.catb.org/esr/writings/taoup/html/ch10s05.html">[1]</a></li>
<li>Interpret a value of <code>-</code> to mean &quot;Write output to stdout&quot; <a href="http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html">[2]</a></li>
<li>Because <code>-o</code> does not inherently indicate whether it expects a file or a directory, consider also providing a GNU-style long version with a name like <code>--outfile</code> to allow scripts which depend on your tool to be more self-documenting.</li>
</ul>
</blockquote>
</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2019-03-15 06:18</div>
            <div class="timeline-body"><p>@ssokolow Nice. Maybe you can just use <code>env MANWIDTH=80 man boilerplate</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-15 06:55</div>
            <div class="timeline-body"><p>That said, I just noticed that, when I call help2man <em>now</em>, I'm getting a doubled body on the manpage, so I'll have to <code>git bisect</code> to find the cause tomorrow.</p>
<p>I'll also add a test for that odd behaviour to my test suite for the build automation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-15 16:02</div>
            <div class="timeline-body"><p>Found the problem. I had a &quot;Durr&quot; moment when writing the justfile.</p>
<p>Originally, I'd accidentally written <code>cargo run -- help</code>, which worked because <code>help2man</code> adds <code>--help</code> and <code>--version</code>, which causes the <code>help</code> to have no effect.</p>
<p>Later, I &quot;fixed&quot; it to <code>cargo run -- --help</code>, so help2man was running <code>boilerplate --help --help</code> and <code>boilerplate --help --version</code> to extract the info.</p>
<p>I've pushed a fix and added a regression test to the <code>test_justfile.py</code> I use to make sure I don't screw up my justfile while refactoring.</p>
<p>(On a related note, I spent yesterday's coding time putting together a <code>gen_justfile_reference.py</code> script which is now responsible for generating and injecting the reference tables in the <code>README.md</code> by parsing <code>justfile</code>. I'll probably rewrite these helpers in Rust once I've moved the project template into a subfolder.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2019-03-16 13:42</div>
            <div class="timeline-body"><p>@ssokolow Just wondering, how does <code>boilerplate</code> generate the <code>ENVIRONMENT</code> section in man page?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-16 13:51</div>
            <div class="timeline-body"><p>At present, <code>rust-cli-boilerplate</code> simply doesn't (generate an <code>ENVIRONMENT</code> section) and I don't see how it <em>could</em> automatically extract that information, given how the it doesn't currently <strong>do</strong> anything with the environment.</p>
<p>(ie. In its current stage of development, loading configuration beyond command-line arguments is up to you, so documenting them is also.)</p>
<p>However, it's trivial to add an <code>--include</code> or <code>--opt-include</code> call to the <code>help2man</code> line in the <code>justfile</code> to append a chunk of raw *roff text for an <code>ENVIRONMENT</code> section and I'll consider adding an <code>--opt-include</code> (include if exists) by default to broaden the scope of people who can use the <code>justfile</code> without modification.</p>
<p>In the longer term, once I've got unified configuration of some sort, I'll look into doing something similar to <code>--dump-completions</code>  to allow the program to report the environment variables it obeys so I can have a build script generate said *roff text.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2019-03-16 15:05</div>
            <div class="timeline-body"><blockquote>
<p>However, it's trivial to add an --include or --opt-include call to the help2man line in the justfile to append a chunk of raw *roff text for an ENVIRONMENT section and I'll consider adding an --opt-include (include if exists) by default to broaden the scope of people who can use the justfile without modification.</p>
</blockquote>
<p>Would not that be limited to just *roff? How about mandoc and friends?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-16 15:42</div>
            <div class="timeline-body"><p>The <code>man</code> command is a *roff renderer. <code>--include</code> and <code>--opt-include</code> literally just copy the contents of the files you specify into the final output.</p>
<p>mandoc and friends, by definition, must output *roff markup for <code>man</code> to understand it, so you can use <code>--include</code> or <code>--opt-include</code> with their output.</p>
<p>(It's like something which generates HTML docs providing an option to copy blocks of raw HTML into the final output.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dashohoxha">@dashohoxha</a> on 2019-03-28 10:21</div>
            <div class="timeline-body"><p>I am not sure whether this is useful, but in the past I have used http://rtomayko.github.io/ronn/ for writing man pages. They look like this:</p>
<ul>
<li>https://gitlab.com/EasyGnuPG/egpg/blob/gnupg-2.2/man/egpg.1.ronn</li>
<li>https://gitlab.com/EasyGnuPG/egpg/tree/gnupg-2.2/man</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-03-28 10:38</div>
            <div class="timeline-body"><p>I'm not really a huge fan of adding more Ruby dependencies. I'd probably do something with <a href="https://github.com/rust-cli/man">rust-cli/man</a> instead.</p>
<p>(But thanks for the effort nonetheless.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../greshake/i3status-rust/pulls/391.html">greshake/i3status-rust#391</a> on 2019-07-08 16:06</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2019-09-23 12:24</div>
            <div class="timeline-body"><p>Would it be good to generate the commands output to rustdoc as well? The CLI docs can be viewed in rust offline docs as well.</p>
<p>It could take advantage of the existing comments (which rustdoc already does) in addition to the extra commands, seems useful in context like https://github.com/mozilla/neqo/blob/6c012fb3416586b7c9604348b128e4cffc250338/neqo-server/src/main.rs#L26-L28</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-09-23 12:38</div>
            <div class="timeline-body"><p>I'd need to see a mockup of the kind of thing you'd expect to generate, but my instinct is &quot;Yes, it would be good&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dylan-DPC-zz">@Dylan-DPC-zz</a> on 2019-09-23 15:36</div>
            <div class="timeline-body"><p>Have you looked at https://github.com/rust-cli/man?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2019-09-23 15:49</div>
            <div class="timeline-body"><p>@Dylan-DPC</p>
<p>Already been mentioned.</p>
<blockquote>
<p><strong>ssokolow commented on Mar 28</strong>
I'm not really a huge fan of adding more Ruby dependencies. I'd probably do something with <a href="https://github.com/rust-cli/man">rust-cli/man</a> instead.</p>
<p>(But thanks for the effort nonetheless.)</p>
</blockquote>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2019-09-24 01:36</div>
            <div class="timeline-body"><p>@Dylan-DPC I did saw that but if I am correct you are replying to https://github.com/clap-rs/clap/issues/552#issuecomment-534080103, the context was generating help similar to man pages but to rustdoc instead since rustdoc is not fully utilized for binary packages as of now. Maybe I should go ask in #rustdoc.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/msarfati">@msarfati</a> on 2020-01-10 03:26</div>
            <div class="timeline-body"><p>After working a bit on this problem on my own, I wonder if the best solution for man-page autogen is to support the ability to convert a <code>clap::App</code> to YAML, after it's been built using its builder pattern, and then just parse the YAML into man / *roff with rust-man. This feature can also help users migrate from the builder pattern to YAML.</p>
<p>I would be very interested in working on this and maintain it part of Clap (and not my own unicorn fork of Clap), but I'm not really sure how the Clap team feels about introducing a feature like this, or how to go about pitching this. Also would like to know if anyone else is working manpage autogen?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-01-10 03:56</div>
            <div class="timeline-body"><p>Waitaminute.</p>
<p>When did YAML come into the picture? I'm very much against using YAML in new code for a variety of reasons that boil down to how the spec's <a href="https://www.arp242.net/yaml-config.html">hugely overcomplicated</a> from trying to be too many things for too many different people (longer than the XML spec and <a href="https://metacpan.org/pod/JSON::XS#JSON-and-YAML">doesn't even achieve all those goals</a>), it's got various <a href="https://noyaml.com/">lurking footguns</a> such as confusing an unquoted string literal for Norway's country code (<code>no</code>) with an alternative &quot;do what I mean&quot; representation of boolean false, and different YAML implementations seem <a href="https://github.com/cblp/yaml-sucks">unable to agree</a> on how to implement it.</p>
<p>This has <a href="https://ciaranm.wordpress.com/2009/03/01/yaml-sucks-gems-sucks-syck-sucks/">caused real-world problems</a> in the past. (Not even counting the various problems caused by libraries implementing <a href="http://tenderlovemaking.com/2013/02/06/yaml-f7u12.html">insecure by default</a> decoding APIs.)</p>
<p>It's also at odds with the Rust philosophy when it comes to footgun-encouraging design, reminding me more of CoffeeScript's use of whitespace and PHP's weak typing.</p>
<p>Any chance you could bypass the serialization/deserialization step entirely or at least use JSON or TOML instead?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-01-10 06:38</div>
            <div class="timeline-body"><blockquote>
<p>ability to convert a clap::App to YAML, after it's been built using its builder pattern, and then just parse the YAML into man / *roff with rust-man.</p>
</blockquote>
<p>If  you mean https://github.com/rust-cli/man by <code>rust-man</code> here than I think the most sensible approach here is to convert <code>clap::App</code> into <a href="https://docs.rs/man/0.3.0/man/struct.Manual.html"><code>man::Manual</code></a> directly, without any intermediate formats, YAML or not YAML.</p>
<p>Serializing <code>App</code> to / deserializing <code>Manual</code> from some config file can be implemented separately.</p>
<p>The only thing is that https://github.com/rust-cli/man is kind of dead as I see it (a year of no updates). cc @rust-cli</p>
<blockquote>
<p>Any chance you could bypass the serialization/deserialization step entirely or at least use JSON or TOML instead?</p>
</blockquote>
<p>I'm seconding @ssokolow here, YAML is not a good choice for config files.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/msarfati">@msarfati</a> on 2020-01-10 13:12</div>
            <div class="timeline-body"><p>Those are fair criticisms of my YAML idea @ssokolow and @CreepySkeleton -- I only proposed YAML because it was something already supported by clap (albeit in a different use-case), but that approach indeed has its issues.</p>
<p>I suppose I could bypass serialization/deserialization entirely and just use a <code>clap::App</code> to construct a <code>man::Manual</code> in <code>rust-cli/man</code>. It seems like this approach might involve exposing some of <code>clap::App</code>'s attributes as public, or writing new getter functions/macros for accessing some of <code>clap::App</code>'s attributes not currently exposed. I'll get to work on a prototype and get a better sense of what's required.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-01-10 13:57</div>
            <div class="timeline-body"><blockquote>
<p>. It seems like this approach might involve exposing some of clap::App's attributes as public, or writing new getter functions/macros for accessing some of clap::App's attributes not currently exposed.</p>
</blockquote>
<p>Those fields are <code>pub</code> but <code>#[doc(hidden)]</code> in both <code>App</code> and <code>Arg</code>. While I don't think that relying on such fields is fine for a <em>release</em> of minimal viable product, I think that this is acceptable for a <em>prototype</em>. So go ahead and &quot;draw a sketch&quot;!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/1630.html">clap-rs/clap#1630</a> on 2020-01-10 15:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-01-10 17:32</div>
            <div class="timeline-body"><blockquote>
<p>The only thing is that https://github.com/rust-cli/man is kind of dead
as I see it (a year of no updates). @rust-cli cc</p>
</blockquote>
<p>Hey!</p>
<p>Indeed we haven't been working on this stuff actively in the last year, but we're getting the CLI WG started again. There's regular meetings (every first Monday of the month), and notes on the meetings here: https://hackmd.io/NKG9jUiFThGqgAqhsIniyg</p>
<p>Truth be told, we've been thinking about how to generate documentation in general, and have been looking at yamr and toml as formats. Toml is &quot;simple&quot; in the sense that it quite awful to write and structure. We wanted to put some tech demos together and announce them soon.</p>
<p>I encourage you to join the next meeting if you have feelings about this. We also have a ML now that you can add yourselves to via the rust/teams repo.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-01-16 21:52</div>
            <div class="timeline-body"><p>I agree with @CreepySkeleton here that we can easily create a <code>to_man</code> fn in <code>clap::App</code> that converts it into <code>man::Manual</code>. Clap already takes in config file, we don't need to create one more.</p>
<p>@spacekookie Thanks for the info on the meetings. Looking forward to join the next one.</p>
<p>We recently got a stream created in Zulip chat too <a href="https://rust-lang.zulipchat.com/#narrow/stream/220302-wg-cli">#wg-cli</a></p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-01-22 17:00</div>
            <div class="timeline-body"><blockquote>
<p>I agree with @CreepySkeleton here that we can easily create a <code>to_man</code>
fn in <code>clap::App</code> that converts it into <code>man::Manual</code>. Clap already
takes in config file, we don't need to create one more.</p>
</blockquote>
<p>I have to strongly disagree here.</p>
<p>There's a few problems with just having the documentation in code.  For
one it's impossible to translate, which is a huge problem at the moment,
on the other hand a man page can't just be generated from a clap::App
definition.  A manual page is more than just listing the options from
<code>--help</code> in a slightly different format.  In fact, those pages exist
sometimes, and they're usually useless.  Instead, a manual page needs to
go into a lot more detail about the semantics of a tool.  This is
something that requires free form text and is best done in external
files.</p>
<p>The exact format of these files, I'm not sure about.  We could even have
a folder with documentation, which is only supplimented with a config to
put it all together, but it can't just be derived from the clap::App
definition.</p>
<blockquote>
<p>We recently got a stream created in Zulip chat
too. https://rust-lang.zulipchat.com/#narrow/stream/220302-wg-cli</p>
</blockquote>
<p>We decided on chat being on matrix in a past meeting
(matrix.org:#rust-cli).  I'm not sure there's enough volume to fill two
chat channels, but in any case, do be aware that there's also
discussions going on in the matrix channel.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/vn971">@vn971</a> on 2020-01-22 17:24</div>
            <div class="timeline-body"><p>To correct a bit, the room id is <code>#rust-cli:matrix.org</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-01-22 18:26</div>
            <div class="timeline-body"><p>@spacekookie  Totally agree on the &quot;translations&quot; thing, I didn't think about it, oops.</p>
<p>(I must confess that I'm no expert in  man pages and if you think something of the following is wrong - tell me and the apologizing cat will apologize).</p>
<blockquote>
<p>A manual page is more than just listing the options from <code>--help</code> in a slightly different format</p>
</blockquote>
<p>The funny thing is that the man pages are <em>exactly</em> &quot;the options from <code>--help</code> in a slightly different format&quot; with some sort of header and a footer.</p>
<p>Let's look at the <a href="https://linux.die.net/man/1/gcc"><code>gcc</code> man page</a> - header + options + footer.
<a href="http://man7.org/linux/man-pages/man1/git.1.html"><code>git</code> man page</a> - header + options + footer. (This case is pretty interesting since they use two <code>subcommand</code> sections instead of just one, but still.)
<a href="https://curl.haxx.se/docs/manpage.html"><code>curl</code> man page</a> - header + options + footer.
...</p>
<p>I have yet to see a man page <strong>for a binary</strong> that stands out too drastically.</p>
<p>My core point here is that at least the &quot;option&quot; part can very well be generated from --help.</p>
<blockquote>
<p>a folder with documentation, which is only supplimented with a config to put it all together,</p>
</blockquote>
<p>For project-level man pages that cover multiple binaries - maybe. For a single binary? Not sure, but leaning to &quot;one config file&quot;.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-01-22 19:33</div>
            <div class="timeline-body"><blockquote>
<p>@spacekookie Totally agree on the &quot;translations&quot; thing, I didn't think
about it, oops.</p>
</blockquote>
<p>I think this is quite an important point that a lot of people forget
about, which is a problem.  And whatever tooling we have needs to
address this.</p>
<blockquote>
<blockquote>
<p>A manual page is more than just listing the options from <code>--help</code> in
a slightly different format</p>
</blockquote>
<p>The funny thing is that the man pages are <em>exactly</em> &quot;the options from
<code>--help</code> in a slightly different format&quot; with some sort of header and
a footer.</p>
</blockquote>
<p>To rephrase my initial point: content can't just be derived from the
clap definitions, structures possibly could but I don't really see the
point.  Yes, man pages are usually &quot;just&quot; the set of options, but with
significantly more explanation and cross-references to other man pages
(see the git manuals for referenc).</p>
<p>I think it's important to keep the actual text outside of the Rust code
for a few reasons.  One is that we want to encourage people to write
longer sections to explain their program, and doing so in a format that
is optimised to convey emphasis, such as markdown, restructured text,
etc is much better that having to write it in multiline strings in Rust
files.  Two is that we want these files to be translatable.</p>
<p>So considering that these files will need to follow some kind of
structure anyway, to not create a huge mess between different language
versions of the same texts, I don't really see the need to generate
anything from clap.  Rather, we would associate a documentation key with
the option names or help text in clap.  The idea is that this tool could
be used in far more applications than just clap CLIs, and also allow
other argument parsers to implement the same trait to benifit from
translations, man page support, etc.</p>
<p>I think this is a far more elegant solution to this problem than having
to couple it to one particular argument parser library.</p>
<hr />
<p>Are you subscribed to the mailing list yet?  I recommend you do that
(over at the teams repo) and also check out the meeting notes we took in
the last 2 meetings: https://hackmd.io/NKG9jUiFThGqgAqhsIniyg</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-01-22 19:53</div>
            <div class="timeline-body"><p>I think you misunderstood my intention. You are right that we don't want to couple the man pages generator to clap. What I meant is we can use doc comments in the CLI built using <code>clap_derive</code> to generate default man pages which the author can override later if he wants.</p>
<blockquote>
<p>I think it's important to keep the actual text outside of the Rust code
for a few reasons.  One is that we want to encourage people to write
longer sections to explain their program, and doing so in a format that
is optimised to convey emphasis, such as markdown, restructured text,
etc is much better that having to write it in multiline strings in Rust
files.</p>
</blockquote>
<p>Well, <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html#doc-comments">doc comments</a> is already a standard here.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-01-22 20:36</div>
            <div class="timeline-body"><blockquote>
<p>Well, <a href="https://doc.rust-lang.org/rust-by-example/meta/doc.html#doc-comments">doc
comments</a>
is already a standard here.</p>
</blockquote>
<p>I really don't think this is a good way to go about this.  Doc comments
are convenient for documenting actualy functions, but now writing a
book, for example.</p>
<p>Anyway, the clap_derive can do whatever, really.  The idea is to have a
&quot;Doc&quot; Trait, that allows tools to hook into sources and sinks, which
means that you can have your doc comments if you want them, and then
swap out the comments later for actual docs.</p>
<p>I personally don't think this is a good way about writing an
application, because it depends on editors having good support for
editing doc comments (not all of them do), and makes translating
impossible, but obviously that's just my feelings about how software
should be written ;)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-01-22 23:18</div>
            <div class="timeline-body"><p>Bear in mind that, on the Python side, I'm just finishing up a migration to Sphinx and the number-one factor that came into play on multiple occasions is internal consistency.</p>
<ol>
<li><p>What is the number-one thing I hate about Sphinx's API documentation support? That the best I can do for ensuring nothing gets missed in refactoring is to babysit one <code>foo.rst</code> file per source file containing an <code>.. automodule:: foo</code> directive.</p>
<p>Doing so constrains my ability to document things compared to using more fine-grained <code>autowhatever</code> directives, but my number-one concern is minimizing the ability for things to drift out of sync because, in practice, I've run into too many Python libraries where I had to read the source because the Sphinx docs were incomplete somehow.</p>
<p>(I'm upgrading from an unmaintained Python 2.x documentation tool that behaves more like rustdoc.)</p>
</li>
<li><p>How did I handle the command's manpage? I chose a third-party <code>.. autoprogram</code> directive because, as constraining as it is to just use a stupid &quot;Generate it from the <code>argparse.ArgumentParser</code> instance&quot;, I value guaranteed consistency between my parser and my manpage far more highly than being able to put in more details. (Note that <code>argparse.ArgumentParser</code> doesn't expect any kind of rich markup as input.)</p>
</li>
</ol>
<p>If you force me to do too much babysitting of my documentation to, I'll just stick to my current solution of tweaking the <code>clap</code> template to bring it into compliance with GNU conventions and then running <code>help2man</code> after compilation.</p>
<p>(At <em>minimum</em>, have some kind of lint which complains if the data from clap appears to not line up with the externally provided data.)</p>
<p>Also, note that, while it requires raw *roff input, <code>help2man</code> provides a potential avenue for allowing external content to integrate with generated content.</p>
<pre><code>INCLUDE FILES
       Additional material may be included in the generated output with the --include and --opt-include options.  The format is simple:

           [section]
           text

           /pattern/
           text

       Blocks of verbatim *roff text are inserted into the output either at the start of the given [section] (case insensitive), or after a paragraph matching /pattern/.

       Patterns use the Perl regular expression syntax and may be followed by the i, s or m modifiers (see perlre(1)).

       Lines before the first section or pattern which begin with `-' are processed as options.  Anything else is silently ignored and may be used for comments, RCS keywords and the like.

       The section output order (for those included) is:

           NAME
           SYNOPSIS
           DESCRIPTION
           OPTIONS
           ENVIRONMENT
           FILES
           EXAMPLES
           other
           AUTHOR
           REPORTING BUGS
           COPYRIGHT
           SEE ALSO

       Any [NAME] or [SYNOPSIS] sections appearing in the include file will replace what would have automatically been produced (although you can still override the former with --name if required).

       Other sections are prepended to the automatically produced output for the standard sections given above, or included at other (above) in the order they were encountered in the include file.

       Placement  of  the  text within the section may be explicitly requested by using the syntax [&lt;section], [=section] or [&gt;section] to place the additional text before, in place of, or after the default
       output respectively.
</code></pre>
<p>If I had a solution which auto-generated from Clap but also looked for <code>.md</code> override files with those <code>[&lt;section]</code>, <code>[=section]</code>, <code>[&gt;section]</code> or <code>/pattern/</code> references, and it complained if they didn't match or matched more than once without some kind of &quot;This one is expected to match <code>regex repetition specifier</code> times&quot;, I'd be happy.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codesections">@codesections</a> on 2020-01-23 17:38</div>
            <div class="timeline-body"><p>@ssokolow I have a genuine question that I hope doesn't come off as snarkyI really am curious.  You wrote:</p>
<blockquote>
<p>If you force me to do too much babysitting of my documentation to, I'll just stick to my current solution of tweaking the clap template to bring it into compliance with GNU conventions and then running help2man after compilation.</p>
</blockquote>
<p>Why do you want to have a man page at all, if you'd be happy with it duplicating the <code>--help</code> output?  As an end user, I nearly always consult <code>--help</code> <em>first</em> and then, if my question wasn't answered, check the man page.  Given that, I'd strongly prefer <em>no</em> man page to a man page that duplicates the <code>--help</code> output.  In either case, my question isn't getting answered, but at least <code>No manual entry for &lt;COMMAND&gt;</code> doesn't cause me to waste time figuring out that the man page has no new info.</p>
<p>Do you have a use case for man pages where a man page that copies <code>--help</code> output is useful rather than annoying?</p>
<p>@CreepySkeleton wrote:</p>
<blockquote>
<p>The funny thing is that the man pages are exactly &quot;the options from --help in a slightly different format&quot; with some sort of header and a footer.  Let's look at the gcc man page - header + options + footer.</p>
</blockquote>
<p>That isn't how I'd describe the <code>gcc</code> man page at all.  (At least on my system.  The man page I have is very similar to the <a href="https://linux.die.net/man/1/gcc">online one</a>.  Is that what you were talking about?)</p>
<p>I'd describe the <code>gcc</code> man page as a 15,746-line document that extensively documents the <code>gcc</code> command.  This includes several sections before documenting options, and an <code>OPTIONS</code> section divided into several subsections, and then several sections after <code>OPTIONS</code>.  Within its <code>OPTIONS</code> section (which contains multiple subsections not documented via <code>--help</code>), it documents many options that are <strong>not</strong> documented in the (61-line) <code>--help</code> output.  Even when options are documented in both the man page and the <code>--help</code> output, their description in the manual is <em>much</em> more detailed than their description in the <code>--help</code> output.</p>
<blockquote>
<p>My core point here is that at least the &quot;option&quot; part can very well be generated from --help.</p>
</blockquote>
<p>Do you mean that the <code>OPTION</code> section of the <code>gcc</code> man page could be generated from the <code>--help</code> output?  If so, I disagree  the <code>OPTION</code> section is far, far longer than the <code>--help</code> output and includes options not documented in via <code>--help</code>.</p>
<p>Or do you mean that a <strong>list</strong> of options could be generated from <code>--help</code>, and that list could form a framework for an expanded <code>OPTIONS</code> section in the man page?  If so, I agree.  The man page will eventually be much longer than the <code>--help</code> output, but starting with a list of all options/flags documented in with <code>--help</code> seems like a helpful starting point/way to avoid inadvertently omitting some options.  On the other hand, I don't think that starting with the <code>--help</code> <em>descriptions</em> for options is all that useful  in my view, the man page descriptions should be significantly more detailed.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-01-23 17:55</div>
            <div class="timeline-body"><p>Fair enough, I think I was wrong.I would still like to see the relationship between options is documented in some standardized way(conflicts, one option implying another...), along with default values, possible values and so on.I agree that the detailed description should not be the same as in --help but I'm very convinced that the stuff above must be derived from the actual implementation to ensure they never get out of sync.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-01-23 18:12</div>
            <div class="timeline-body"><p>@codesections</p>
<p>There are several important details:</p>
<ol>
<li><p>There's a surprising amount of inconsistency about how programs implement built-in help. I've actually got a Zsh script, the whole purpose of which is to veto GNU's decision that <code>-h</code> should not be an alias for <code>--help</code>. Heck, I can't remember which, but I think I even ran into some programs where they didn't implement <code>-h</code> or <code>--help</code> (They might have been using <code>-?</code> or X11-style <code>-help</code>) and did something unwanted and annoying to clean up after if you tried to ask for help that way.</p>
</li>
<li><p>As primitive as *roff markup rendered in <code>man</code> is, <code>--help</code> output from pretty much anything other than a program specifically configured to use clap's coloured output option is worse. (Plus, there's a nifty hack which overrides the terminal escapes used in <code>man</code> to get colourization reminiscent of what clap's colourization does.)</p>
</li>
<li><p><code>man command</code> is more concise and easier to remember than <code>command --help | less</code>, especially if I then decide that, oops, I need less so I can use <code>/</code> searching.</p>
</li>
<li><p>While I'm not using it yet (partly because I hate *roff markup), help2man allows you to add blocks of information above, below, or within your autogenerated stuff.</p>
</li>
</ol>
<p>My mention of rustdoc vs. Sphinx was carefully chosen. I want a solution where omitting an entry can only be done intentionally and it's impossible for the auto-generated parts to fall out of sync with reality unless you are specifically overriding them with manual bits rather than just augmenting them.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codesections">@codesections</a> on 2020-01-23 18:34</div>
            <div class="timeline-body"><p>@CreepySkeleton</p>
<blockquote>
<p>I would still like to see the relationship between options is documented in some standardized way(conflicts, one option implying another...), along with default values, possible values and so on. I agree that the detailed description should not be the same as in --help but I'm very convinced that the stuff above must be derived from the actual implementation to ensure they never get out of sync.</p>
</blockquote>
<p>Agreed 100%</p>
<p>@ssokolow, thanks for the detailed reply.  As mentioned upthread, the CLI working group is working on a solution for this space, and hearing about your use-case is helpful.  Our goal is to support man output (and other documentation) in a way that is both synchronized to the actual application and that allows easy customization without hand-writing *roff.</p>
<blockquote>
<p>As primitive as *roff markup rendered in man is, --help output from pretty much anything other than a program specifically configured to use clap's coloured output option is worse.</p>
</blockquote>
<p>I <em>believe</em> this should be fixed in the current master version of Clap, since Clap will now output non-colored text when ANSII escape codes aren't supported.  #963</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-01-23 19:00</div>
            <div class="timeline-body"><blockquote>
<p>I believe this should be fixed in the current master version of Clap, since Clap will now output non-colored text when ANSII escape codes aren't supported. #963</p>
</blockquote>
<p>You misunderstand. I'm saying that clap is pretty much the only thing that matches <code>man</code> for making good use of slightly rich markup to make the text more scannable and only if it's a program that opts into using coloured output.</p>
<p>Here's one of my own programs using Python's <code>argparse</code> for <code>--help</code> generation (I'm in the middle of modernizing it. A few days ago, it was using <code>optparse</code>):</p>
<p><img src="https://user-images.githubusercontent.com/46915/73014280-c93ff700-3e11-11ea-8ad8-7225a6319b5d.png" alt="Screenshot_20200123_135126" /></p>
<p>...and here's the result of using Sphinx's third-party <code>.. autoprogram::</code> directive, then outputting the resulting page via Sphinx's manpage renderer without having added any supplementary sections below it yet:</p>
<p><img src="https://user-images.githubusercontent.com/46915/73014392-f8eeff00-3e11-11ea-956e-f264b4cda27a.png" alt="Screenshot_20200123_135542" /></p>
<p>(It'll take some reworking to get Sphinx generating both a manpage and an HTML manual without either having to write and maintain two slightly different versions of the same content or having at least one of them looking terrible.)</p>
<p>In case you're wondering, the colourization is accomplished by this shell function:</p>
<pre><code class="language-sh"># Launch man with modified `less` termcap in subshell to colourize it
man() { (
    export LESS_TERMCAP_mb=$(tput bold; tput setaf 2)
    export LESS_TERMCAP_md=$(tput setaf 6)
    export LESS_TERMCAP_me=$(tput sgr0)
    export LESS_TERMCAP_so=$(tput setaf 7; tput setab 4)
    export LESS_TERMCAP_se=$(tput rmso; tput sgr0)
    export LESS_TERMCAP_us=$(tput smul; tput setaf 7)
    export LESS_TERMCAP_ue=$(tput rmul; tput sgr0)
    export LESS_TERMCAP_mr=$(tput rev)
    export LESS_TERMCAP_mh=$(tput dim)
    export LESS_TERMCAP_ZN=$(tput ssubm)
    export LESS_TERMCAP_ZV=$(tput rsubm)
    export LESS_TERMCAP_ZO=$(tput ssupm)
    export LESS_TERMCAP_ZW=$(tput rsupm)
    export GROFF_NO_SGR=1         # For Konsole and Gnome-terminal
    command man &quot;$@&quot;
) }
</code></pre>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/codesections">@codesections</a> on 2020-01-23 20:22</div>
            <div class="timeline-body"><p>I did misunderstand.  Thanks for the clarification :+1:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-01-25 02:33</div>
            <div class="timeline-body"><blockquote>
<p>The funny thing is that the man pages are exactly &quot;the options from --help in a slightly different format&quot; with some sort of header and a footer.</p>
</blockquote>
<p>Most man pages are more elaborated as compared to <code>--help</code> page. Most of the time I try <code>man</code> page first because it is easier, just pressing alt-h when I typed the command.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../casey/intermodal/issues/24.html">casey/intermodal#24</a> on 2020-01-31 13:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "3.0" by @pksunkara on 2020-02-05 08:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Added to milestone "3.1" by @pksunkara on 2020-02-05 08:36</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../http-rs/tide/issues/101.html">http-rs/tide#101</a> on 2020-03-01 11:37</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Removed from milestone "3.1" by @pksunkara on 2020-03-03 12:42</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/casey">@casey</a> on 2020-04-09 23:06</div>
            <div class="timeline-body"><p>I just wanted to jump in and +1 the idea of producing output in an intermediate format, which can then be fed in to various back ends.</p>
<p>Since this output will be produced and consumed by code, JSON seems like a good choice, since it's simple and universally supported. TOML is also simple, but deep nesting in TOML gets weird.</p>
<p>This would also make the initial implementation very simple, just output some JSON describing the CLI, and then backends could come later. Additionally, it would allow backends to be fully decoupled from clap.</p>
<p>My own use case is that I'd like to generate both roff, to display with <code>man</code>, but also generate markdown, for inclusion in an mdbook book. Both formats aren't so complicated, so I wouldn't mind writing my own JSON to roff and JSON to markdown backends.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: generator</span> added by @pksunkara on 2020-04-12 10:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: help pages gen</span> removed by @pksunkara on 2020-04-12 10:08</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C: man page gen</span> removed by @pksunkara on 2020-04-12 10:08</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-05-24 09:01</div>
            <div class="timeline-body"><p>@pksunkara I would like to help out with man page generation, maybe I will try generating <code>mdoc</code> format first then <code>troff</code> since I like that format.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-05-24 09:08</div>
            <div class="timeline-body"><p>IIRC @codesections is working on it.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-05-24 10:11</div>
            <div class="timeline-body"><p>@pksunkara I believe I am working on a different man page format here which most likely @codesections is not using which is <code>mdoc</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-05-24 11:58</div>
            <div class="timeline-body"><blockquote>
<p>@pickfire wrote:</p>
<p>pksunkara I would like to help out with man page generation, maybe I
will try generating <code>mandoc</code> format first then <code>troff</code> since I like
that format.</p>
</blockquote>
<p>I think what is important to consider is that man page generation only
partially has to be integrated with clap.  A man page isn't just a set
of options with the same help text as --help (well, some of them are and
they're utterly useless!)</p>
<p>Instead, a man page need to be more long-form text that is merged with
the structure of the clap arguments, with some sections just being
free-form explanation of the rationale of the tool.</p>
<p>@codesections was working on that a few months ago, I don't know if he's
made any progress on it though.  I've since written a crate to introduce
a (work in progress) on-disk format/ structure to handle text assets in
Rust crates.  I did this also with the goal of making all strings easily
translatable (something I'd love to integrate with clap!)</p>
<p>Maybe you wanna have a look to see how you can make <code>mandoc</code> (or
<code>troff</code>), my crate (<code>traduki</code><a href="https://git.open-communication.net/spacekookie/traduki">1</a>) and clap work well together.  I'd also
be happy to help out with this.  There's so many many ways to be lazy
about this and get it wrong, I very much want to help get it right!</p>
<p>~k</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-05-24 15:13</div>
            <div class="timeline-body"><p>@spacekookie I understand since man pages will usually have more items not even in help. Thanks for sharing traduki. But from my personal point of view, I prefer writing man pages either mdoc or troff by hand at the expense of duplicated help. Also, I don't quite like using yaml and I also think building all the man pages is better than building just one.</p>
<p>Still, one could use the man page generated as the base and modify it later.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dylan-DPC-zz">@Dylan-DPC-zz</a> on 2020-05-24 15:57</div>
            <div class="timeline-body"><p>I think for something that is a bit of complex, It's better that it is done separately as a separate crate so that we can iterate and find the better solution. I remember as Katherina said, that codesections is working on something so I'd wait on that to decide where this goes after that.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-05-26 09:55</div>
            <div class="timeline-body"><blockquote>
<p>Also, I don't quite like using yaml and I also think building all the man pages is better than building just one.</p>
</blockquote>
<p>@pickfire sorry, I'm not sure I understand what you mean by &quot;building all the man pages&quot; here. Could you clarify that a bit maybe?</p>
<p>Also regarding traduki: I picked yaml as a format because it's flexible enough to do all the things without much syntactic overhead. I'm not opposed to add more format support, if there's something you're more comfortable with.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-05-26 10:00</div>
            <div class="timeline-body"><p>@spacekookie I reiterate my earlier opposition to YAML that got <a href="https://github.com/clap-rs/clap/issues/552#issuecomment-572862739">buried in the fold</a>.</p>
<p>(I wish GitHub had a way to turn that off.)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-05-26 10:11</div>
            <div class="timeline-body"><p>@joshtriplett While trying out some tests cases in mdoc, I believe we should have multple manpages instead of sticking everything into one man pages. I think it would be better to split each subcommands into their own manpages instead since subcommands usually have their own flags, options and description.</p>
<p>The naming of other files could be <code>myapp-subcommand</code> and we could have a <code>SEE ALSO</code> section at the bottom to link them. But still, we could keep the subcommand and their options at the main <code>SYNOPSIS</code>, in each subcommand man pages, they could have their own <code>SYNOPSIS</code>.</p>
<p>While trying out, I figured out that <code>mdoc</code> have no good default support for GNU-style <code>--long</code> help. I also figured out it would be interesting if we can find <code>env!()</code>, <code>option_env!()</code> or related calls and document them under <code>ENVIRONENT</code> section. It would also be nice to show some examples in the <code>EXAMPLES</code> section. We could also add the version at operating system part, bottom left.</p>
<p>This requires changes in <code>clap_generate</code> since currently the generator only expects a single file change. With this, <code>fn generate(app: &amp;App, buf: &amp;mut dyn Write) {</code> is not possible since it may write to multiple files.</p>
<p>I am still thinking of how to put long commands into <code>SYNOPSIS</code> section, or try to use short flag instead of long flag by default. An implementation note, I am substituting <code>myapp</code> (application name) in the description to get highlighting. So far, what I get:</p>
<details><summary>Rust code</summary>

<pre><code class="language-rust">    App::new(s)
        .author(&quot;John Doe &lt;john@example.org&gt;:Jane Doe &lt;jane@example.org&gt;:anonymous&quot;)
        .about(&quot;Tests completions&quot;)
        .long_about(&amp;format!(&quot;The quick brown fox jumps over the lazy dog.
{} is an application with super cow powers.&quot;, s))
        .before_help(&quot;Send help!&quot;)
        .arg(Arg::new(&quot;file&quot;).about(&quot;Some input file&quot;))
        .subcommand(
            App::new(&quot;test&quot;).about(&quot;tests things&quot;).arg(
                Arg::new(&quot;case&quot;)
                    .long(&quot;case&quot;)
                    .takes_value(true)
                    .about(&quot;the case to test&quot;),
            ),
        )
</code></pre>
</details>

<p><img src="https://user-images.githubusercontent.com/4687791/82886826-a8331280-9f79-11ea-9f37-5fbdcfb884bb.png" alt="2020-05-26-175048_564x340_scrot" />
<img src="https://user-images.githubusercontent.com/4687791/82886822-a79a7c00-9f79-11ea-8433-203733f81cad.png" alt="2020-05-26-175102_564x340_scrot" /></p>
<details><summary><code>mdoc.1</code></summary>

<pre><code class="language-mdoc">.\&quot; Generated by clap
.Dd $Mdocdate$
.Dt MYAPP 1
.Sh NAME
.Nm myapp
.Nd Tests completions
.Sh SYNOPSIS
.Nm
.Op Fl h
.Op Fl V
.Op Ar file
.Sh DESCRIPTION
Send help!

The quick brown fox jumps over the lazy dog.
.Nm
is an application with super cow powers.
.Sh OPTIONS
.Bl -tag -width Ds
.It Fl h , Fl -help
Prints help information
.It Fl V , Fl -version
Prints version information
.It Ar file
Some input file
.El
.Sh AUTHORS
.An John Doe Aq Mt john@example.org
.An Jane Doe Aq Mt jane@example.org
.An anonymous
.Sh SEE ALSO
.Xr myapp-help 1 ,
.Xr myapp-test 1
</code></pre>
</details>

<p><img src="https://user-images.githubusercontent.com/4687791/82886820-a701e580-9f79-11ea-8957-34391ed58305.png" alt="2020-05-26-175114_564x340_scrot" /></p>
<details><summary><code>mdoc-help.1</code></summary>

<pre><code class="language-mdoc">.\&quot; Generated by clap
.Dd $Mdocdate$
.Dt MYAPP-HELP 1
.Sh NAME
.Nm myapp-help
.Nd Prints this message or the help of the given subcommand(s)
.Sh SYNOPSIS
.Nm myapp help
.Ar subcommands ...
.Sh AUTHORS
.An John Doe Aq Mt john@example.org
.An Jane Doe Aq Mt jane@example.org
.An anonymous
.Sh SEE ALSO
.Xr myapp 1 ,
.Xr myapp-test 1
</code></pre>
</details>

<p><img src="https://user-images.githubusercontent.com/4687791/82886818-a5d0b880-9f79-11ea-96f4-41273d8bfc74.png" alt="2020-05-26-175125_564x340_scrot" /></p>
<details><summary><code>mdoc-test.1</code></summary>

<pre><code class="language-mdoc">.\&quot; Generated by clap
.Dd $Mdocdate$
.Dt MYAPP-TEST 1
.Sh NAME
.Nm myapp-test
.Nd tests things
.Sh SYNOPSIS
.Nm myapp test
.Op Fl h
.Op Fl V
.Op Fl -case Ar case
.Sh OPTIONS
.Bl -tag -width Ds
.It Fl h , Fl -help
Prints help information
.It Fl V , Fl -version
Prints version information
.It Fl -case Ar case
the case to test
.Sh AUTHORS
.An John Doe Aq Mt john@example.org
.An Jane Doe Aq Mt jane@example.org
.An anonymous
.Sh SEE ALSO
.Xr myapp 1 ,
.Xr myapp-help 1
</code></pre>
</details>

<p>Side note, I just realized <code>mdoc</code> have <code>BSD General Commands Manual</code> at the top. <code>fish-manpage-completions</code> also does not support generating completions for <code>mdoc</code> format yet. So <code>groff</code> will still be recommended. But I like <code>mdoc</code> since it have more advanced and specific macros. <code>mdoc</code> and <code>groff</code> would crash since the filename is the same but BSD might be better off generating the <code>mdoc</code> version.</p>
<p>@spacekookie Regarding traduki, I prefer not to write additional docs but embed it into clap options itself, I personally think yaml would be the last choice of additional docs that I can think of. I think internationalization should be tackled in another issue and at the same time, I believe we should use something mature to do internationalization such as gettext or project fluent.</p>
<p>@ssokolow While reading your old screenshots, I noticed that the sections and stuff are not well indented, I could help out with those markup and stuff if you want. I could also help out with the <code>groff</code> if you want me to, but still I would like to try out <code>mdoc</code> first. Maybe we can share test code.</p>
<p>What do you all think of separating it into multiple files?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-05-27 15:10</div>
            <div class="timeline-body"><p>@ssokolow :</p>
<blockquote>
<p>(I wish GitHub had a way to turn that off.)</p>
</blockquote>
<p>Yea  me too.</p>
<p>&amp; @pickfire: regarding yaml, it was the first format I picked because <em>I</em> personally find it easy to work with. But I know that many people have different preferences and that's totally fine. I am in no way opposed to writing other parser backends. <code>json</code>, <code>toml</code>, <code>MO</code>, some web tool, whatever...</p>
<p>Regarding the structure of additional documentation: the problem is that tools that don't use external asset tools are usually not translated, or if they are only to a few select languages that become a big maintenance burden. Furthermore, <code>man</code> pages or <code>GNU info</code> mages require more data than clap. The title description for a command might be the same, but do you really want to embed long-form text into your Rust code, that you might as well want to share in different places?</p>
<p>As to yaml, I really don't understand why you're getting hung up on it. I think I've been nothing but clear on the fact that the current <code>yaml</code> backend is a proof of concept and that more formats should be added.</p>
<p>As for translations, I feel strongly that the solution we integrate with remains as slim as possible. There are a lot of people who only want a simple approach to deal with assets and that don't want to learn how to setup and use something like <code>fluent</code>.</p>
<p>When it comes to the issue of separating pages, I think it's the right choice to do this. This is a standard across many tools, and results in shorter and more manageable pages for users. (also <code>man tool-sub-command</code> is much easier than <code>man tool</code>, then having to search around for <code>sub-command</code>.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-05-27 16:10</div>
            <div class="timeline-body"><p>@spacekookie I believe using <code>yaml</code> is not slim and may introduce a lot of old missing translation. If they would not want <code>fluent</code>, they could always fallback to gettext which is widely used from what I see.</p>
<p>Yes, when separating man pages into <code>tool-subcommand</code>, fish is able to detect the man page when the user press <code>a-h</code> to display the correct man page.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alerque">@alerque</a> on 2020-05-27 18:24</div>
            <div class="timeline-body"><p>YAML is not a terrible option for describing a bunch of meta data. I'm aware of its shortcomings, but it is also flexible and powerful and pretty easy to use (if you're not the programmer working on the edge cases). On the other hand it's a terrible way to represent translation data.</p>
<p>If the main use of YAML was to describe the interface I'd be all for it, but if the main use case is providing alternate localization of the same interface it should be scrapped on favor of just using one of the other app declaration methods (I like the #derive macros, but this should go for the other methods too) and adding hooks into Fluent to load the user facing strings.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-05-28 12:11</div>
            <div class="timeline-body"><p>@pickfire can you please stop trying to derail the conversation with talk about yaml? I get it. We all get it. It's secondary to the actual point and at this point honestly off-topic.</p>
<p>The point of having a central translations crate was exactly not to pick favourites. You have your opinions on how to handle assets, others have theirs. I think it's not out of scope for a language ecosystem to have a system for handling translation assets, that isn't reliant on another system, with the option of hooking into other libraries.</p>
<p>I'd point you to the mail archive where we had a pretty long conversation about this but r0tty's mail archive seems to be offline right now.</p>
<p>I don't really feel like talking about this for ever and ever. I'm gonna start working on a proof of concept integration into <code>clap</code> next week and any changes people want to make to <code>traduki</code> will probably be merged. Add all the backends and formats. But I think it's a sensible approach to have <em>one</em> crate you need to patch to implement additional backends for (or switch backends without breaking your project).</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pksunkara">@pksunkara</a> on 2020-05-28 12:13</div>
            <div class="timeline-body"><p>The consensus in clap was that we export the doc strings you give us into whatever format the generator needs.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-05-28 12:18</div>
            <div class="timeline-body"><p>@spacekookie Normally, I would, but I just realized that I don't remember an explicit mention of the intersection of these three facts:</p>
<ol>
<li>We're talking about translations.</li>
<li>One of YAML's known flaws is that its &quot;do what I mean&quot; approach to strings and quoting makes it very easy for someone to intend Norway's ISO 3166 code (<code>no</code>) or Norwegian's ISO 639-1 code (also <code>no</code>) but get a boolean false.</li>
<li>Rust encourages an ecosystem where footguns should be minimized.</li>
</ol>
<p>Now that it's on the record, I can stop talking about YAML.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/pickfire">@pickfire</a> on 2020-05-28 15:04</div>
            <div class="timeline-body"><p>@spacekookie I am not trying to derail the conversation talking about YAML (in fact this came secondary to me). Of course we can switch to any other format but I would say using any serialization format would probably be bad against battle tested translations such as gettext and fluent. I also did mentioned the other facts like internationalization should be something out of scope for this discussion, using <code>traduki</code> would leave fluent and gettext out of the table, that is one main point.</p>
<p>But yes, if we have a way to hook traduki in using the existing docstrings method without having the users doing much work such as maintaining multiple saparate like what traduki is now I think that would be helpful. Of course it may be useful to maintain some separate document which is useful for translations but I believe that should be another issue.</p>
<p>I think this issue should target english only man pages as the default as of now (i18n can be done later) to maintain focus, mainly by using docstrings and not having to do additional steps to auto-generate man pages. I believe the best would be that the maintainer can add just one line of code in build.rs to generate the man pages without any additional efforts, that would be the best.</p>
<p>The reason why I think it would be best for internationalization to be done later is because the rust team planned to integrate it, I don't recall how. Maybe @Manishearth would know more about that, hopefully he can give some insights on how that will relate to this project.</p>
<p>@ssokolow By the way, are you still working on this?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/spacekookie">@spacekookie</a> on 2020-05-28 15:55</div>
            <div class="timeline-body"><p>@pickfire</p>
<blockquote>
<p>I believe the best would be that the maintainer can add just one line of code in build.rs to generate the man pages without any additional efforts, that would be the best.</p>
</blockquote>
<p>But that's not how man pages work!  Have you ever looked at a man page? What, do you want to embed pages and pages of documentation into your Rust code? Because Rust is so famous for being amazing to write multi-line strings in. Give me a break.</p>
<p>If we go down the route of &quot;just add this one line&quot; Rust applications are going to have man pages that are utterly and completely useless. And I just think we shouldn't aim so low and do better. The design of the tools people use encourage and discourage behaviour. If we go down this route, if we settle for ease of use to the developer in favour of usefulness for the user, we might as well just not bother at all.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/ssokolow">@ssokolow</a> on 2020-05-28 16:05</div>
            <div class="timeline-body"><p>Not necessarily.</p>
<p>If we were to follow the approach of <a href="https://www.gnu.org/software/help2man/">GNU help2man</a>, then the &quot;this one line&quot; would take an optional <code>include</code> argument that would be appended below the auto-generated stuff as part of the manpage build process... and that <em>does</em> feel very structopt-ish.</p>
<p>help2man enforces a standard ordering for the conventional manpage sections, but you can specify content for each one, as well as create your own.</p>
<blockquote>
<p><strong>Including Additional Text in the Output</strong></p>
<p>Additional static text may be included in the generated manual page by using the <code>--include</code> and <code>--opt-include</code> options (see <a href="https://www.gnu.org/software/help2man/#Invoking-help2man">Invoking help2man</a>). While these files can be named anything, for consistency we suggest to use the extension <code>.h2m</code> for help2man include files.</p>
<p>The format for files included with these option is simple:</p>
<pre><code> [section]
 text
 
 /pattern/
 text</code></pre>
<p>Blocks of verbatim *roff text are inserted into the output either at the start of the given <code>[section]</code> (case insensitive), or after a paragraph matching <code>/pattern/</code>.</p>
<p>Patterns use the Perl regular expression syntax and may be followed by the <code>i</code>, <code>s</code> or <code>m</code> modifiers (see <a href="http://perldoc.perl.org/perlre.html#perlre">perlre(1)</a>)</p>
<p>Lines before the first section or pattern which begin with <code>-</code> are processed as options. Anything else is silently ignored and may be used for comments, RCS keywords and the like.</p>
<p>The section output order (for those included) is:</p>
<pre><code> NAME
 SYNOPSIS
 DESCRIPTION
 OPTIONS
 ENVIRONMENT
 FILES
 EXAMPLES
 other
 AUTHOR
 REPORTING BUGS
 COPYRIGHT
 SEE ALSO</code></pre>
<p>Any <code>[name]</code> or <code>[synopsis]</code> sections appearing in the include file will replace what would have automatically been produced (although you can still override the former with <code>--name</code> if required).</p>
<p>Other sections are prepended to the automatically produced output for the standard sections given above, or included at other (above) in the order they were encountered in the include file.</p>
</blockquote>
<p>I could see such a thing also allowing for easy generation of either a single manpage or one for each subcommand. One top-level &quot;make a manpage&quot; attribute/call? Generate one manpage. Hang one off a subcommand's definition, that subcommand gets broken out of the main manpage into its own manpage.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-05-28 16:54</div>
            <div class="timeline-body"><p><em><strong>Moderator note:</strong></em> <em>Please keep in mind that this discussion is about <strong>manpages generation</strong> in clap, not file formats. I'm answering certain yaml criticism below because it's quite objective but misleading, but please, try to stay on topic. . Please also keep in mind that <a href="https://git.open-communication.net/spacekookie/traduki/-/issues">traduki has it's own bug tracker</a>. If you think there's something to do with traduki, like supporting multiple formats, move your discussion there. This issue is unnavigatable already.</em></p>
<details>
  <summary>Click to expand</summary>

<blockquote>
<p><strong>Important:</strong> YAML spec didn't drop on us from on high, it was being developed iteratively, hence <a href="https://yaml.org/spec/">multiple versions</a> exist. For the purposes of this discussion, we are only interested in <code>1.1</code> and <code>1.2</code>. It is important to keep in mind that the <code>yaml-rust</code> crate supports only <code>1.2</code> to the best of my knowledge.</p>
</blockquote>
<p>User @ssokolow points out that YAML has a number of pretty serious flaws that considerably affect user experience and may inflict harm in certain circumstances, but it turns out that the flaws are either being <code>eval</code>-class bugs in certain libraries and have nothing to do with YAML itself, or exist solely in yaml <code>1.1</code>, and thus <code>yaml-rust</code> is unaffected.</p>
<p>The said flaws:</p>
<ol>
<li><p><em>YAML treats all of <code>y</code>, <code>n</code>, <code>true</code>, <code>false</code>, <code>yes</code>, <code>no</code>, <code>off</code>, <code>on</code> (along with their capitalized and uppercase forms) as boolean values rather that strings. This is very confusing and clashes with <code>no</code> being also the country code for Norway.</em></p>
<p><a href="https://yaml.org/type/bool.html">That is true</a>. For YAML 1.1. YAML 1.2 <a href="https://yaml.org/spec/1.2/spec.html#tag/repository/bool">restricts</a> boolean to either <code>true</code> or <code>false</code>. <code>yaml-rust</code> is unaffected by this.</p>
</li>
<li><p><em>Many YAML implementation has been known for being vulnerable to <a href="https://en.wikipedia.org/wiki/Code_injection">code injection</a> attacks</em>.</p>
<p>Yes, this is true, and <a href="http://tenderlovemaking.com/2013/02/06/yaml-f7u12.html">sometimes it led to awful consequences</a>. But then again, this happened because certain libs in many interpreted languages used <code>eval</code> as a shortcut for building runtime objects, and that allowed malicious user to execute arbitrary code at runtime. <code>yaml-rust</code> does no such thing because Rust, being compiled language, doesn't have <code>eval(&quot;Rust_code&quot;)</code> function. <code>yaml-rust</code> is unaffected by this (unless you explicitly write code doing that).</p>
</li>
<li><p><em>YAML spec is very very huge and implementations seem to unable to implement it properly. Meh, they seem to unable to agree even <a href="https://github.com/cblp/yaml-sucks">among themselves</a>!</em></p>
<p>Yes, and that is very true. It looks like there's only one YAML parser for Rust, <a href="https://github.com/chyh1990/yaml-rust"><code>yaml-rust</code></a>, and it's not fully spec-compatible.</p>
</li>
</ol>
<p>I'm not touching such things as &quot;42 is a number and not string by default&quot; and &quot;some specific implementation had a bug that didn't parse negative numbers properly&quot; here because I'm really not sure whether it's trolling or something else.</p>
</details>

<p>If you need to discuss it further, create a separate issue.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-05-28 17:02</div>
            <div class="timeline-body"><p>It looks like we're throwing out the same arguments again and again. For the sake on moving <em>somewhere</em>, let's try to come to some sort of consensus on the following topics:</p>
<ul>
<li>Should/can man pages be the same as <code>--help</code> or they should be more descriptive?</li>
<li>Should manpage generator use the same input as <code>--help</code> messages generator?</li>
<li>Should the data be compiled into the executable or be a separate asset?</li>
</ul>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @Dylan-DPC-zz on 2020-05-28 17:10</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Locked by @clap-rs on 2020-05-28 17:11</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @pksunkara on 2020-05-28 17:12</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @Dylan-DPC-zz on 2020-05-28 17:43</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Reopened by @kbknapp on 2020-05-28 21:21</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/kbknapp">@kbknapp</a> on 2020-05-28 21:27</div>
            <div class="timeline-body"><h2>Admin Note</h2>
<p>The discussion here got a little heated and derailed, which is totally possible and common with online discussions.</p>
<p>Just a reminder for everyone to remain civil, even when differences of opinion exist. We can, and <em>I expect</em> us to debate technical issues, but those debates must remain calm and professional.</p>
<p>This issue will remain <strong>locked</strong> for the next 48 hours to allow everyone involved a chance to take a break and perhaps consider other angles. Personally, I think this is a great time to attempt to see something from another's point of view.</p>
<p>One final note, as we're discussing technical details this thread is already very long so lets do our best to keep the discussion related to this issue, and within the realm of what is actionable by clap code. If there are other debates to be had, lets move them to chat, GH discussions, or dedicated issues here/issue trackers on other projects.</p>
<p>I appreciate the passion everyone is displaying for this feature, I want it to land and I want a design that pushes this library forward. I think we all want that :smile:</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../coreos/coreos-installer/pulls/323.html">coreos/coreos-installer#323</a> on 2020-07-28 14:21</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Unlocked by @clap-rs on 2020-08-13 01:36</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dkg">@dkg</a> on 2020-12-18 16:13</div>
            <div class="timeline-body"><p>@CreepySkeleton  wrote:</p>
<blockquote>
<pre><code>* Should/can man pages be the same as `--help` or they should be more descriptive?</code></pre>
</blockquote>
<p>I think that <code>--help</code> should typically produce a brief reference, and man pages should provide a superset of that information.  they can be more descriptive, and include more details/nuance/gotchas/etc that would be inappropriate to view in the console running <code>--help</code>.  But the point here is <em>superset</em>.  If something shows up in <code>--help</code> it definitely should be visible (and easy to find) in the manpage.  And of course it should be in sync.</p>
<blockquote>
<pre><code>* Should manpage generator use the same input as `--help` messages generator?</code></pre>
</blockquote>
<p>Yes, i think it should (because we want them to stay in sync).  Whatever is generating these things should be pulling from the same place if possible.</p>
<blockquote>
<pre><code>* Should the data be compiled into the executable or be a separate asset?</code></pre>
</blockquote>
<p>I think that the details/nuance/etc for the manpage doesn't need to be compiled into the executable, but if it happens by accident (or because it's more convenient for the text to be stored/manipulated/translated that way) then it's not much of a problem (space is the only concern i see here, and rust binaries are large enough anyway that i can't imagine a few paragraphs of text being significant).</p>
<p>Thanks for thinking about this and working on it!  I'd really like to see convenient autogeneration of manpages for clap binaries (e.g. in <a href="https://gitlab.com/sequoia-pgp/sequoia/-/issues/299">sequoia</a>)</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/alerque">@alerque</a> on 2020-12-18 18:43</div>
            <div class="timeline-body"><p>Pretty much everything that @dkg said, except that man page content should be generated and stored in a separate resource file. Many distros require that this be packaged and the build and package routines  to extract it by running the binary to reconstruct the source would be more complicated than need be, packing a man source file is much easier and a very standard operation.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/anthraxx">@anthraxx</a> on 2021-01-28 20:36</div>
            <div class="timeline-body"><blockquote>
<p>Pretty much everything that @dkg said, except that man page content should be generated and stored in a separate resource file. Many distros require that this be packaged and the build and package routines to extract it by running the binary to reconstruct the source would be more complicated than need be, packing a man source file is much easier and a very standard operation.</p>
</blockquote>
<p>As being a distro packager myself i strongly disagree. All that matters as a distro packager is that it's reasonably easy to invoke the transformation chain. All that matters as a developer is that it's reasonably easy to read/write and convenient to keep it in sync with the rest of the definitions -- the CLI <code>--help</code> declaration. All that matters as a user is that you can easily obtain manpages and completions no matter if you pulled a software out of a distro repository or via <code>cargo install</code>.</p>
<p>Clip already does exactly that for completions and frankly it is no disadvantage for packagers to generate them out of a binary before putting them somewhere else. This could even be made easier by downstream projects by providing an appropriate Makefile whose interaction with won't be any different from what an average packagers already uses elsewhere.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../ducaale/xh/issues/63.html">ducaale/xh#63</a> on 2021-02-15 22:07</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../ostreedev/ostree/pulls/2296.html">ostreedev/ostree#2296</a> on 2021-03-12 19:03</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../rust-cli/man/pulls/10.html">rust-cli/man#10</a> on 2021-03-22 20:34</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../quickwit-oss/quickwit/issues/256.html">quickwit-oss/quickwit#256</a> on 2021-07-09 11:44</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../peap/git-global/issues/5.html">peap/git-global#5</a> on 2021-07-19 07:13</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../BLAKE3-team/BLAKE3/issues/190.html">BLAKE3-team/BLAKE3#190</a> on 2021-08-11 16:23</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">W: 3.x</span> removed by @pksunkara on 2021-08-13 10:40</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../NNPDF/pineappl/issues/89.html">NNPDF/pineappl#89</a> on 2021-11-17 15:33</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/64.html">epage/clapng#64</a> on 2021-12-06 16:27</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../epage/clapng/issues/131.html">epage/clapng#131</a> on 2021-12-06 18:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">T: new feature</span> removed by @epage on 2021-12-08 21:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">C-enhancement</span> added by @epage on 2021-12-08 21:18</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">P4: nice to have</span> removed by @epage on 2021-12-09 16:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">D: medium</span> removed by @epage on 2021-12-09 16:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">S-blocked</span> added by @epage on 2021-12-09 16:49</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/2914.html">clap-rs/clap#2914</a> on 2021-12-09 16:51</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-completion</span> removed by @epage on 2021-12-13 17:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Label <span class="label">A-help</span> added by @epage on 2021-12-13 17:53</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../pulls/3174.html">clap-rs/clap#3174</a> on 2021-12-14 16:32</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../orhun/git-cliff/issues/35.html">orhun/git-cliff#35</a> on 2021-12-16 09:38</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../pkgcraft/pkgcraft/issues/73.html">pkgcraft/pkgcraft#73</a> on 2021-12-24 14:42</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @epage on 2022-01-28 20:55</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../issues/3354.html">clap-rs/clap#3354</a> on 2022-01-28 21:00</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../louib/fpcli/issues/1.html">louib/fpcli#1</a> on 2022-01-28 21:01</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Referenced in <a href="../../louib/fpm/issues/3.html">louib/fpm#3</a> on 2022-01-28 21:02</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/Dzordzu">@Dzordzu</a> on 2022-04-12 12:31</div>
            <div class="timeline-body"><p>Is there any way to generate json schema from the command?</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/epage">@epage</a> on 2022-04-12 13:49</div>
            <div class="timeline-body"><p>At this time, we do not.  The issue for that is https://github.com/clap-rs/clap/issues/918.</p>
<p>The <code>clap-serde</code> project could be a good place for this.  See https://github.com/aobatact/clap-serde/issues/11.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/tgross35">@tgross35</a> on 2022-12-22 17:51</div>
            <div class="timeline-body"><p>For anyone like me who stumbles across this long issue but can't find the correct answer: the official crate is <code>clap_mangen</code> (it's not mentioned anywhere on this thread)</p>
</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:33:18 UTC
    </footer>
</body>
</html>
