<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance of YML vs performance of code? - clap-rs/clap #1635</title>
    <link rel="stylesheet" href="../../../style.css">
</head>
<body>
    <div class="back-link">
        <a href="../../../index.html">Back to index</a>
    </div>

    <h1>Performance of YML vs performance of code?</h1>

    <div class="meta">
        <span class="state-icon state-closed"></span>
        <a href="https://github.com/clap-rs/clap/issues/1635">#1635</a>
        opened by <a href="https://github.com/dominikbraun">@dominikbraun</a>
        on 2020-01-17 10:10
    </div>

    <div class="timeline">
        <div class="timeline-entry">
            <div class="timeline-header">Issue opened by <a href="https://github.com/dominikbraun">@dominikbraun</a> on 2020-01-17 10:10</div>
            <div class="timeline-body"><p>This is just a quick question concerning the performance of parsing the CLI app structure:</p>
<p>How does building the app from a YML file compare to building the app in the source code in terms of performance? I'd assume that loading and parsing the file is slower, but are there some benchmarks showing the differences? Can a large YML file even slow down the CLI app?</p>
<p>Thanks in advance!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-01-17 11:41</div>
            <div class="timeline-body"><p><strong>Those are my subjective conclusions based on my personal experience!</strong></p>
<p>Most certainly the parsing does have it's own performance impact, <strong>but this impact is relative</strong>.</p>
<p>We don't have a benchmark for YAML parsing in this repo so I can't give any determinate numbers, but let's just make a couple of educated guesses.</p>
<ul>
<li><p>The CLI parsing is done <em>only once per program run</em>, we can call it O(1). Your program, in turn, is going to process some data, perform some calculations, render something etc... those are tend to be O(n) with respect to the input data.</p>
</li>
<li><p>Large YAML files, you say? How many of your yaml files have the size of megabytes? I bet none ðŸ˜„ . Just so you could feel the scale, it would take ~250 ebook pages (text only). How many of your CLI descriptions take the size of novella?</p>
<p>I'm fairly certain that few kilobytes will be processed in no time [citation needed].</p>
</li>
</ul>
<p>With all that said, even if the YAML parser is slow, the difference will be negligible - and effectively imperceptible - for end user.</p>
<p>99% of CLI apps have no need to care about it.</p>
<p>I would also like to recommend <a href="https://www.doxsey.net/blog/a-response-to-hello-world">this article</a> to anyone who likes premature optimization. Optimize something only when your debugger told you so.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-01-17 11:47</div>
            <div class="timeline-body"><p>@CreepySkeleton That's a fine analysis. But to add to that, there is a fairly common case where process overhead can be observed, and it's actually one of the reasons why I use clap (because it's fast). Namely, when running processes many times in a short period of time. This can occur in a loop, or perhaps more commonly, with <code>xargs</code>.</p>
<p>Definitely agree with your conclusion though! Just wanted to mention a case where startup overhead (even a small amount) can be a factor.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/CreepySkeleton">@CreepySkeleton</a> on 2020-01-17 11:56</div>
            <div class="timeline-body"><p>@BurntSushi Good point with <code>xargs</code>, I forgot about it!</p>
<p>Just wanted to note here that, even when a program is executed in a loop repeatedly, the CLI parsing is probably the least significant part of it; it's very likely that  process creation + data processing + IO will likely take the most of the time.</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/BurntSushi">@BurntSushi</a> on 2020-01-17 12:22</div>
            <div class="timeline-body"><p>Sometimes. Really depends on what you're doing. It certainly matters for tools like grep, where even spawning a few threads has noticeable overhead in an <code>xargs</code> pipeline. Turns out you can do a lot in 10-30ms of overhead!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="timeline-header">Comment by <a href="https://github.com/dominikbraun">@dominikbraun</a> on 2020-01-17 16:12</div>
            <div class="timeline-body"><p>@CreepySkeleton Thanks for your opinion - that is pretty much what I've expected. Your O(1) consideration is interesting as well.</p>
<p>I merely wanted to make sure that there isn't a certain risk of getting a performance penalty when using a YML file. At least for most cases. :)</p>
<p>Thanks to @BurntSushi, too!</p>
</div>
        </div>
        <div class="timeline-entry">
            <div class="event">Closed by @dominikbraun on 2020-01-17 16:12</div>
        </div>
    </div>

    <footer>
        Synced at 2026-01-10 01:34:04 UTC
    </footer>
</body>
</html>
