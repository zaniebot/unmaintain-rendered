```yaml
number: 259
title: "RFC: Clap, from scratch re-write and redesign discussion"
type: issue
state: closed
author: WildCryptoFox
labels:
  - C-enhancement
  - M-breaking-change
  - A-builder
  - A-parsing
assignees: []
created_at: 2015-09-19T10:37:19Z
updated_at: 2016-03-28T18:11:22Z
url: https://github.com/clap-rs/clap/issues/259
synced_at: 2026-01-10T01:57:39Z
```

# RFC: Clap, from scratch re-write and redesign discussion

---

_Issue opened by @WildCryptoFox on 2015-09-19 10:37_

**[Drafting; @kbknapp @sru please feel free to update this OP as you see fit. Please "create a lock" by posting a comment saying that you're editing - and then delete when done]**

From: https://github.com/kbknapp/clap-rs/issues/259#issuecomment-143956337
- [x] List **all** current `clap` features and capabilities in the OP (**EDIT**: This is already mostly done, but not quite complete. There are a few features missing, or some that should be broken down into further sub-sections. **EDIT 2**: Also, I'm speaking more about separating current features, from proposed features, from implementation details...currently it's all mixed into one list)
- [ ] Determine which of those capabilities will be **changed** (i.e. _implemented_ but in a slightly different manner from the `clap` **consumer** standpoint...breaking changes)
- [ ] Implement all current capabilities in `clap` 2.x tracked by individual 2.x issues with this issue being the overarching 2.x discussion forum and overall tracking issue
- [ ] Determine which **new** features will be present in 2.x (i.e. custom `Matches` struct allowing things like `matches.some_arg` fields instead of the current `matches.value_of("some_arg")`)
- [ ] Implement all new features in individual 2.x tracking issues, again with this issue being the overarching 2.x discussion forum
- [ ] Test / Bench the 2.x branch to ensure we didn't lose ground
- [ ] Once all features / bugs / benches have been worked from the 2.x branch we'll ensure docs are good to go and release
## Current (ripped from the README) feature
- Auto-generated Help, Version, and Usage information
- Flags
  - Short version (i.e. `-f`)
  - Long version (i.e. `--flag`)
  - Combining short versions (i.e. `-fBgoZ` is the same as `-f -B -g -o -Z`)
  - Multiple occurrences (i.e. `-vvv` or `-v -v -v`)
- Positional Arguments (i.e. those which are based off an index from the program name)
  - Multiple values (i.e. `myprog <file>...`)
  - Supports the unix `--` meaning, only positional arguments follow
  - Optionally sets value parameters
    - Minimum values
    - Maximum values
    - Exact number of values
- Option Arguments (i.e. those that take values as options)
  - Short version (i.e. `-o value`)
  - Long version
    - `--option value`
    - `--option=value`
  - Multiple values
  - Named values
  - Value parameters
    - Minimum values
    - Maximum values
    - Exact number of values
- Sub-Commands (i.e. `git add <file>` where `add` is a sub-command of `git`)
  - Their own sub-arguments, and sub-sub-commands independent of the parent
  - Get their own auto-generated Help, Version, and Usage independent of parent
- Requirement Rules
  - Required by default
  - Required only if certain arguments are present
  - Can require other arguments to be present
- Exclusion/Confliction Rules
  - Can be disallowed when certain arguments are present
  - Can disallow use of other arguments when present
- Groups
  - Fully compatible with other relational rules (requirements and exclusions) which allows things like requiring the use of a group, or denying the use of a group conditionally
- Specific Value Sets
  - For positional
  - For option
- Default Values: Although not specifically provided by `clap` you can achieve this exact functionality from Rust's `Option<&str>.unwrap_or("some default")` method (or `Result<T,String>.unwrap_or(T)` when using typed values)
- Automatic Version from Cargo.toml
- Typed Values
- Suggestions
- Colorized (Red) Errors (Non Windows OS only)
- Global Arguments
- Custom Validations
- POSIX Compatible Conflicts
- Support for building CLIs from YAML
## Current Implementation Details

(Something about the current design that needs attention)
## Proposed
- [x] Flags
  - [x] Short version (i.e. `-f`)
  - [x] Long version (i.e. `--flag`)
  - [x] Combining short versions (i.e. `-fBgoZ` is the same as `-f -B -g -o -Z`)
  - [x] Multiple occurrences (i.e. `-vvv` or `-v -v -v`)
- [ ] Positional Arguments (i.e. those which are based off an index from the program name)
  - [x] Multiple values (i.e. `myprog <file>...`)
  - [x] Supports the unix `--` meaning, only positional arguments follow
  - [x] Optionally sets value parameters
    - [ ] Minimum values (needs post parser validation test)
    - [x] Maximum values
    - [x] Exact number of values
- [ ] Option Arguments (i.e. those that take values as options)
  - [x] Short version (i.e. `-o value`)
  - [x] Long version
    - [x] `--option value`
    - [x] `--option=value`
  - [x] Multiple values
    - [x] ~~`-o value -o other_value` abbreviated to `-o value other_value`~~
      - [x] Instead abbreviated to `-oo value other_value`. The one instance of `-o` is too easily problematic.
    - [x] `--option=val1,val2,val3`
  - [x] Named values
  - [x] Value parameters
    - [ ] Minimum values (needs post parser validation test)
    - [x] Maximum values
    - [x] Exact number of values
- [x] Specific Value Sets (possible values?)
  - [x] For positional
  - [x] For option
- [ ] Sub-Commands (i.e. `git add <file>` where `add` is a sub-command of `git`)
  - [ ] Their own sub-arguments, and sub-sub-commands independent of the parent
  - [ ] Get their own auto-generated Help, Version, and Usage independent of parent
- [ ] Requirement Rules
  - [x] ~~Required by default~~ Required through consumer decision. No default. Macro uses `[]` for optional and `<>` for required.
  - [ ] Required only if certain arguments are present
  - [ ] Can require other arguments to be present
- [ ] Exclusion/Confliction Rules
  - [ ] Can be disallowed when certain arguments are present
  - [ ] Can disallow use of other arguments when present
- [ ] Groups
  - [ ] Fully compatible with other relational rules (requirements and exclusions) which allows things like requiring the use of a group, or denying the use of a group conditionally
- [ ] Global Arguments
- [ ] Default Values
- [ ] Automatic Version from Cargo.toml
- [ ] Suggestions
- [ ] Custom Validations
  - [x] Partial
- [ ] Auto-generated Help, Version, and Usage information
- [ ] Support for building CLIs from YAML
- [ ] Typed Values
- [ ] POSIX Compatible Conflicts
- [ ] Colorized (Red) Errors (Non Windows OS only **[why not, it has colors too?]**)
## Proposed Implementation Details
## RFCs

[Naming change](#issuecomment-142627487)
[Settings](#issuecomment-143527061)

<!--
Features (partial checklist)

---

**Names could likely do with some renaming**

- [ ] Automatic usage/help string
  - Filter, allow to hide options (and show with `help -v` command)
- [ ] `App`
  - [ ] Own metadata and a vector of argument rules
- [x] `CollectionMatcher` trait implements the standard parser which `App` is currently the only implementer of.
- [x] `Matcher`, purely internal. Applies `Rules` over the `Accumulator`, which 'accumulates' values.
  - [x] During-parsing rules apply here (I.e. Limit occurrences, validate, etc)
- [ ] Argument `Rules`
  - [x] Define parser rules for runtime parsing by the `CollectionMatcher`
  - [x] Arguments are positional when they have no `long` or `short` flags
  - [x] Required
  - [x] Occurrence limit (`-v ..3`, `short(v)` `max_occurrence(3)`, `-vvv` is good, `-vvvv` is bad)
  - [x] Multiple is an alias to `max_occurrence(0)` (Default is 1 occurrence)
  - [x] Take values, either named or unnamed; may specify how many times captured. `--option foo foo2`
  - [ ] Requires, conflicts
- [x] Macro builder to ease consumption
- [ ] Subcommands
- [ ] Argument groups
  - [ ] Conflict / require_one
- [x] `validation` functions including `possible_values`
- [ ] Suggestions "`foo` not found. Did you mean: `foobaz` or `foobar`?"
- [ ] Struct with `impl From<CollectedMatches>` for `app.verbose == 3` accesses
  - [ ] Default values
- [ ] Documentation

Macro builder usage (move to documentation)

---

```rust
clap_app!{ TestApp;
    (meta => author: "James McGlashan"
             about:  "Testing application")
    (args => config:  (--config conf {exists}) "Configuration file"
             verbose: [-v --verbose..3]        "Verbosity level"
             input:   (input_file)             "Input file"
    )
//  (@subcommands => TestApp) // recursion
};
```

<!--Quickly hacked together today. Incomplete and demonstrates a number of refactoring ideas.

Current sample code: <https://gist.github.com/james-darkfox/c318258835114f3be4c9>

**Notes**

- This was **quickly hacked together**, and is **not** feature complete.
- I'm **not** attempting to replace clap, just **demonstrating** some ideas.
- I started this for the purpose of refactoring down clap as it is currently **HUGE** (10k total, 7k sloc)
- There is no builder macro due to not having a stable builder API yet.
- All meta for the application is not included in the `ArgCollection`, for a usage string to be generated; the meta would need to exist in an external struct.
  - `fn arg_collection_as_usage(ac: &ArgCollection, meta_config: meta) -> String`
  - Without panics, this also gives the consumer more control to opt for how low level or handheld they wish to be. Ranging from manually constructing the `ArgRules` to using the builder macro (with everything provided 'by default' or otherwise configurable)
- The `ArgCollection` is just a `HashMap<Cow<'static, str>, ArgRules>` with a match function returning a similar map of `HashMap<Cow<'static, str>, ArgMatcher>`.
- `ArgRules` is passed by reference to create the `ArgMatcher`, allowing for reuse.
- #256 not an issue as respective ClapError's are returned.
- #254 just needs to get the list of keys in the `HashMap`, which we do not consume when matching.
- #235 can easily bring it's own usage format and have the matcher re-used without cloning.
- #146 will require integration into the builder macro and may need some type tricks to extract the desired value types. (Associated types)
- **BREAKING** change :wink: 

**Note**: The effort required to refactor the current state of clap would be more than adopting a redesign (like I've started).

### Checklist

- [x] ~~`Cow<'static, str>` for handling ownership of `&'static str` and String together~~
- [ ] Clean user consumable interface
  - [x] Builders factored down into rules, which are refereed to when matching
  - [x] Error type with no `panic!`
  - [ ] Builder macro
  - [ ] Consumer uses `struct.field` instead of `matches.get("foo")`
- [ ] Pre matching asserts
  - [ ] Positional requirements
    - [x] Cannot capture multiple or repeat;
    - [ ] Unless subcommand
- [ ] Matching
  - [x] Counting and limiting occurrences (multiple = unlimited = 0; default is 1)
  - [x] Grab N values from the iterator (0 = flag, 1+ = argument)
  - [x] Positional arguments
  - [ ] Subcommand last positional argument, another `ArgCollection` fed the remaining of the iterator.
  - [x] `--` to denote only positional arguments
- [ ] Post matching asserts
  - [ ] Requires and conflicts (including groups)
  - [ ] Validation functions
  - [x] Required
- [x] **No `-o foo foo` to expand to `-o foo -o foo`**
  - [x] Use `-oo foo foo` which allows for `-vvoo foo foo` to expand to `--verbose --verbose --option foo --option foo`
- [ ] Usage string
  - [ ] `description` on `ArgRule`
  - [ ] Subcommands as last positional
  - [ ] Called via trait such that consumers can create their own usage string formats to fit their context

### Updated: Implementation notes

- `multiple` is defined as `max_occurrences(0)`
- `-o foo foo` is no more. Instead `-oo foo foo`; both equivalent to `-o foo -o foo`
- `-abc 1 2 3` where a takes one argument, and c takes 2; results in `a: 1`, `b` `c: 2, 3`-->


---

_Label `T: enhancement` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `T: RFC / question` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `T: new feature` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `E: breaking change` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `C: args` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `C: app` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `C: subcommands` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `D: intermediate` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `C: matches` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `C: parsing` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `E: tedious` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `C: examples` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Label `R: needs review` added by @WildCryptoFox on 2015-09-19 10:39_

---

_Comment by @WildCryptoFox on 2015-09-19 12:45_

`impl ArgRules; fn matcher` should really be `impl ArgMatcher; fn with_rules`


---

_Comment by @WildCryptoFox on 2015-09-19 12:51_

`ArgMatcher` should be renamed to `ArgMatches` and possibly an enum respecting the `ArgType` and used as a tuple aside the rules `(ArgRules, ArgMatches)`; dropping this down to the matches when returning the final `HashMap` for further handling.

``` rust
enum ArgMatches {
    Flag(u8), // occurrences of the flag
    Argument(Vec<CowStr>), // arguments provided
        // doesn't need 'occurrences' as we have vec.len() already
        // assert!(vec.len() % self.rules.values_collected == 0)
//    Positional(Vec<CowStr>), // Just use Argument at this level
    // SubCommand?
}
```


---

_Comment by @sru on 2015-09-19 14:06_

I think there is over usage of `CowStr`. If we know that we need to format or own the `str`, then we should use `String` and vice versa for `&str`. Otherwise, `CowStr` is good idea as we might allocate more `String` when the user provided `String`. 

We can easily provide macro for `impl From<ArgBuilder> for MyApp`.

I am not sure about `-oo foo foo` expanding to `-o foo -o foo` because it may be confusing for the user (of this library and of the program that uses this library). Maybe allow comma separated? (`--option=foo,foo`)

I think subcommands require more special treatment than "just a positional argument that eats the rest of the iterator" (what if two subcommands are specified?)


---

_Comment by @WildCryptoFox on 2015-09-19 14:11_

@sru I find the current `-o foo foo` as confusing itself. And yes, comma separated does look nice.
- `-oo foo foo` is common in other places. One notable source being IRC channel/user modes.
- `-o foo foo` is confusing and I've only seen in clap
- `-ofoo`, compilers? `-lsomelib`
- What should be the expected result of `-abc 1 2 3` where `a` takes 1 argument and `c` takes 2? I'd expect `-a 1` `-b` `-c 2 3`. In any case, this is shorthand and is the most flexible option such far, also easier to implement.

---

As for two subcommands. Say like `cmd --foo subcmd --bar subsubcmd --baz` ? Nothing wrong with this.


---

_Comment by @WildCryptoFox on 2015-09-19 18:04_

**Updated gist, slightly less `Cow`**

I might solve the 'short' vs 'long' issue with a map of shorts/longs to u8 indexes of a vector containing the matchers.


---

_Comment by @sru on 2015-09-20 04:36_

@james-darkfox Yes, `-o foo foo` is quite confusing too. Should `cba 1 2 3` be `-c 1 2 -b -a` then?


---

_Comment by @WildCryptoFox on 2015-09-20 04:47_

Yes. For implementing this, it is simply for each short we see. Call the handle function (lending it the iterator); then it may grab as many arguments as it needs. See the commented out code for the general gist. (Commented out because `verbose` may be the key, but `verbose` as the long "works" but `v` is not `verbose`; I'll likely solve this with a map for long/short to vector index)


---

_Comment by @WildCryptoFox on 2015-09-20 04:50_

Noticed two typos in your question. `-cba 1 2 3` should be `-c 1 2 -b -a 3`. Notably the `-cba` vs `cba` and `-a` takes `3`


---

_Comment by @sru on 2015-09-20 04:59_

@james-darkfox Ah yes, that was what I meant.


---

_Comment by @WildCryptoFox on 2015-09-20 05:24_

@sru What is your preference for the handling of shorts and their arguments?


---

_Comment by @WildCryptoFox on 2015-09-20 13:18_

**Updated gist**

@sru The last test `-babcb 1 2 3` results in `Foo { a: vec![1], b: 3, c: vec![2, 3] }` **(Not yet doing the struct)**


---

_Comment by @WildCryptoFox on 2015-09-20 13:40_

~~I need to flatten a few things (easier split for quick code):~~ I've flattened a number of things down.
- [x] `enum Arg` into `struct Arg`
- [x] `ArgMeta` and `Rules` are both used in the builder, and matcher. Neither are for direct consumer usage. Might as well be flattened too.
- [x] `max_occurrences` None is equal to Some(1), should drop the Option and default to 1
- [x] Currently not using `Cow` at all. So much for that optimization. :wink:

**Updated checklist, and gist**


---

_Comment by @WildCryptoFox on 2015-09-20 17:43_

- [x] Basic positional arguments
- [x] Required arguments

**Updated gist**


---

_Comment by @WildCryptoFox on 2015-09-20 17:47_

**Hacky**

https://gist.github.com/james-darkfox/c318258835114f3be4c9/revisions#diff-096d8044f81d02e61e0c93b463725feeR72


---

_Assigned to @WildCryptoFox by @WildCryptoFox on 2015-09-20 18:03_

---

_Comment by @WildCryptoFox on 2015-09-20 18:35_

- Possible values. I think this should just be a validation function?
- Overrides... Practical? Even re-setting arguments is fairly useless (unless you have lazy shell aliases calling each other) `ls --color=auto --color=never`, uses `never`.
- `ArgRule` will need to also have `description`
- `ArgCollection` will likely be renamed to `App`
- Should subcommands just be RDT (Recursive Data Types), paired aside normal arguments?
  - If so, they must be the last positional argument in the `Vec<ArgRule>`

``` rust
type App(AppMeta, Vec<Foo>);
enum Foo {
    Arg(ArgRule),
    SubCommand(App),
}
```


---

_Comment by @sru on 2015-09-20 19:12_

need @kbknapp...


---

_Comment by @kbknapp on 2015-09-20 22:57_

Since I've been quite busy recently without much time for `clap` I'll through out some ideas real quick.

**NOTE:** These aren't directed squarely at the gist, but more in general :wink: 

Let me preface this by saying I'm all for a refactor/re-write _on the condition_ that all functionality remains intact _and_ there is a big enough gain to justify the effort. Granted, is all purely volunteer and people can work on anything they like, but if we're going to make a concentrated effort I'd like to make sure the juice is worth the squeeze. Also, as everyone probably knows, I'm ok with extremely minor breaking changes prior to 2.x if there is a huge ergonomic/performance gain from doing so. All other breaking changes will have to wait for 2.x. 

Just to be clear, there a few things I'm adamant about staying in `clap`; that is an intuitive or pain-free consumer experience (i.e. not having to be super familiar with API or tons of different structs, internals, etc.), readability (one's first impression of `clap` is usually reading someone else's code), and good performance.

I think there are certain things which make _our_ lives easier to develop `clap` but make using it far more difficult. Take `getopt` for example, having `OptOpt` `FlagOpt`, etc. etc. vs. `clap`s single `Arg` struct. I'm a bigger fan of making using `clap` easier than developing it. It's _very_ easy assume something is simple or better as the developer because we are already on the inside and take that knowledge for granted...I'm super guilty of this at times!

So having said that, what I would like to do is incorporate (as best as possible) those two methodologies together. I.e. exposing a _clean_ and _simple_ API to the user, but internally making our lives easier by using various structs, etc. to keep track of everything. In fact I really like how some of this was broken up by @james-darkfox in the gist. i.e. lets keep it to the internal workings and not burden the user with that. We can always `panic!` with a good error message if something is ambiguous during the building process to guide the user (`clap` consumer, _not_ end user).

> What should be the expected result of -abc 1 2 3 where a takes 1 argument and c takes 2? I'd expect -a 1 -b -c 2 3. In any case, this is shorthand and is the most flexible option such far, also easier to implement.

Personally I think that's _way_ too much shorthand. I'm good with some, but that's a little overkill IMO. If it's a bi-product of how we parse strings, that's fine, I just don't want to go out of our way to try and support a super amount of shorthand (going back to the readability and first impressions being other people's usage).

Similarly, we're going to have to make trade-offs on what we support and like-wise what we don't. For example, `clap` doesn't support the compiler-esque `-oSomeOpt` expanding to `-o SomeOpt` which some arg parsers do because it instead supports the `-abc`->`-a -b -c` which I find to be a little more common (granted this is purely subjective). I am **very much** in favor of supporting both, if we can find a clean way to do it. The difficult part is if in the above example there was also a valid `-S` flag. 

I also agree that `-o foo1 foo2`->`-o foo1 -o foo2` can be confusing and should be the exception and not the rule, but I find that _less_ confusing than `-oo foo1 foo2`, again subjective. But I _have_ had users request `-o foo -o bar` be allowed to be shortened to `-o foo bar` but never `-oo foo bar`. Also, `docopt` allows for options to have multiple values as well in a similar manner as well.

> Maybe allow comma separated? (--option=foo,foo)

`--long=option` is a form that I don't personally like, but I know tons of people who do, which is why it's supported. Allowing multiple values inside of this form would be a huge gain, and I'd be in favor of this change in mainline `clap`, it should also be easy to implement.

> POSIX overrides, `ls --color=auto --color=never` -> `ls --color=never`

I like this to be purely optional for exactly the reasons you mentioned; lazy shells and aliasing. If someone wants to support POSIX overrides, awesome they can, but it's not forced on them in case they want it to be a hard error.

> should subcommands just be RDT (Recursive Data Types), paired aside normal arguments? If so, they must be the last positional argument in the Vec<ArgRule>

I'm not 100% sure which you're asking? In my mind a subcommand should be able to come anywhere in an invocation string, but all the args _following_ the subcommand apply to that subcommand, all the args _prior_ to that subcommand apply to parent command (or application in general).

i.e. `$ prog arg1 arg2 subcmd1 arg3 arg4 subcmd2 arg5` where args 1-2 apply to `prog`, args 3-4 apply to `subcmd1` and arg5 applies to subcmd2...if that makes sense :stuck_out_tongue_winking_eye: 

> using `.multiple()` vice `.multiple(true)`

While this saves a few keystrokes, it makes doing things dynamically a little more challenging. Ideally, Rust would allow method overloading...but one can only dream :wink:

I'm not totally against changing dropping the literal `bool`, but I'd like to discuss it more before doing so.

> `n_values()`, `max_occurrences()`, etc.

I really like some of these names and believe those should be used upon `clap` 2.x

> `get("foo")`

I'm also a fan of the shorter `.get("foo")`, but perhaps even shorting by supporting indexing? `matches["foo"]` ? The returned `Arg` (or rather `Arg inside an`Option<Arg>`) could then deref to`&str`

> `get_vec()`

I'm unsure how I feel about this one. Perhaps the `Arg` derefs to `&str` but also has a `.as_slice()` to get `[&str]`? This would follow the stdlib's lead a little closer.

#### Finally

Overall I like the direction and looking for an easier to maintain and develop code base. I just want to caution about re-inventing (or re-factoring) for the sake of doing it. There's some quote about "great being the enemy of good, or programmers refactoring endlessly."...I can't remember :stuck_out_tongue_winking_eye: 

Point being, I'd like to take some of the concepts an incorporate them into mainline `clap` without having to re-invent the whole codebase unless there is a large enough gain to make the effort worth it.


---

_Comment by @sru on 2015-09-21 01:17_

@james-darkfox Following up on @kbknapp's post, categorize the changes into "internal" change and api change to accomodate the SemVer. Also, group them up into minor breaking change and major breaking change. I think @kbknapp is saying that he doesn't want to change the public API except few naming changes and internal change is fine as long as it is worth the time and effort.

I believe that the internal change is needed sooner or later to give more extensive control to the user (of clap library). I think it is possible to stay simple and easy enough for casual user to use with ease and extensible enough for users who want more or want to use this library for other purposes.


---

_Comment by @WildCryptoFox on 2015-09-21 01:32_

@kbknapp Firstly: The best benefit is increasing performance, readability, and maintainability of clap, without any usability or consumer hit. This is a huge breaking change that would be a 2.0, without loosing any functionality.

10k lines of code is **NOT** maintainable, and far from inviting for developers to make simple changes. @sru had difficulties finding where clap terminates and where the help and version subcommands are created and handled. When I ran grep for @sru, I noticed just how large `src/app/app.rs` was, and took a little look inside. Surprised with the length; I created this. :wink: 

I was not looking at the opened issues to determine "goals" of my refactor. I simply started writing with flexibility in mind. (Top post's `#NNN` references for opened issues). Notably: The core doesn't need to exit, however the usage string related level can handle that on behalf of the consumer (without requiring that they use the provided default, also making it suitable for a consumer to write their own usage string format (which just iterates over the vector of rules)).

---

Secondly: All current functionality of clap can be implemented. The `-o foo foo` is a strange repeating case that cannot be followed with a positional argument? `-abc 1 2 3` shorthand has no cost. As the user is more likely to write `-ba 1 -c 2 3` anyway - this was purely a biproduct of iterating over each short `char` and working on the same `Iterator`. This has the added benefit that arguments with values can be collected without splitting up the `-c foo` arguments. Again, this shorthand has no cost and gives the user more flexibility. "Where they are otherwise forced to write the longhand anyway"

We already have chaining of shorts like `-vvv` for increasing occurrence, doesn't make sense to prevent this chaining on options with arguments - hence `-babcb 1 2 3` -> `{a: ["1"], b: 3, c: ["2, "3"]}` is valid.

Alternatively with comma separated captures, this could also be `-o foo,foo` which would work with the one capture of `-o`.

---

Thirdly: I'm open for all names to be changed, Boolean states to be provided and any other simple API related differences.

As you may have noticed, I'm not yet handling any `USAGE STRING` yet. I intend for this to be the `ArgCollection` or better renamed to `App` for consistency. Considering the specialized use-case of #254 as the consumer needs to at most split the arg vector out, iterate over the list and extract the names.

> > should subcommands just be RDT (Recursive Data Types), paired aside normal arguments? If so, they must be the last positional argument in the Vec
> 
> I'm not 100% sure which you're asking? In my mind a subcommand should be able to come anywhere in an invocation string, but all the args following the subcommand apply to that subcommand, all the args prior to that subcommand apply to parent command (or application in general).

This may be the Haskell in me thinking. :wink: The subcommands could be registered normally in the same vector as arguments; and just like positional arguments, handled in their own scope. A subcommand would contain the same exact object that the normal `ArgCollection` or `App`. Panics can be handled at this level, however, the consumer must be able to opt-in/out for this path (especially for cases where the parsing may be used outside of 'command line argument parsing', like an interactive CLI as discussed in #235)

The same usage of `prog arg1 arg2 subcmd1 arg3 arg4 subcmd2 arg5` remains.

---

@sru as I started off in this comment; due to the breaking changes it'll need to be 2.0. However, the end interface for the consumers will not differ all that much as the same functionality will remain. Even the 'internal' case would be breaking due to not having 6 lifetimes on `App`, `Arg`, and arg groups (which would be implemented in a map of `group -> Option<Index>` where the map can be set on the first instance of a group member (preventing any other member)).

The consumers will need to make some code alterations, however, with the builder macro I'll be writing - this should just be "call a macro and ask for your matches". Everything else from there would be internal, hidden from the consumer (unless they opt to dive in deeper for advanced hooks).

As for the builder, the `struct` might need to be created in a separate macro or just together as one macro at the item-level and the consumer then uses `Foo::new()` in `fn main` and uses `foo.field` directly.

---

As for deployment of clap2, I'll create a branch soon and when I've got the feature complete implementation, I'll write up examples and docs. (Speaking of docs, there are quite a number of typos in the existing docs; **Edit**: Appears `260` covered this. :ghost: )

---

Limited time right now, if I missed anything that you feel as important feel free to remind me of the section and I'll take a better look.


---

_Added to milestone `v2.0` by @WildCryptoFox on 2015-09-21 01:35_

---

_Comment by @WildCryptoFox on 2015-09-21 01:59_

> I just want to caution about re-inventing (or re-factoring) for the sake of doing it. 

Just want to add quickly, I'm working on a number of security projects and I have a personal rule that I won't use dependencies if their surface is too large for their purpose. I.e. 7k sloc for a nice argument parser? That's more code than any of my projects! (I tend to write dense functional code ^ See gist for sample :wink: )

In this case, security isn't much of a concern but the maintainability of 7k sloc alone is not so ideal.


---

_Comment by @WildCryptoFox on 2015-09-21 04:09_

@kbknapp RFC?

---

Request For @kbknapp Comments


---

_Comment by @WildCryptoFox on 2015-09-21 05:35_

**See commit reference above**: Prepared a branch for tracking the redesign. I'll be pushing to my `james-darkfox/clap-rs:redesign` first, then PR across to rebase into this new branch.


---

_Referenced in [clap-rs/clap#254](../../clap-rs/clap/issues/254.md) on 2015-09-21 11:42_

---

_Referenced in [clap-rs/clap#262](../../clap-rs/clap/issues/262.md) on 2015-09-21 17:22_

---

_Comment by @WildCryptoFox on 2015-09-21 17:52_

As discussed in #262, `Args` should be preferred over `ArgsOs`.

https://gist.github.com/james-darkfox/7897c09aab4186186576

> to_string_lossy: Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.
- Lossy matching prevents flags and positional arguments from containing the invalid Unicode (in raw form). While in `--foo <arg>`, arg may contain invalid Unicode.


---

_Comment by @sru on 2015-09-21 18:57_

@james-darkfox 

You can also use `Cow` with `OsStr`.

Is there a reason why `Args` should be preferred over `ArgsOs`?


---

_Comment by @kbknapp on 2015-09-21 23:22_

@james-darkfox Yep, I'm totally fine with re-writing for maintainability and performance. I think I misunderstood originally, because excluding tests, benches, etc. I think the current `clap` is around ~4,500 SLOC which I'm betting we could get down to around ~3k maintaining all functionality. Even though argument parsing should be simple, there are tons of edge cases and just because someone only needs the bare basics, I like to allow more advanced features when required...it all adds up quick! :smile: Having said that, I'll be the first to admit, `clap` was originally developed while I was learning Rust so there are _many_ things that could be improved and factored out / shifted to the type system.

Current `cargo count` output:

```
$ cargo count -s , -e src/tests.rs -- src/
Gathering information...
         Language  Files  Lines  Blanks  Comments  Code
         --------  -----  -----  ------  --------  ----
         Rust      19     7,223  358     2,354     4,511
         --------  -----  -----  ------  --------  ----
Totals:            19     7,223  358     2,354     4,511
```

---

> Prepared a branch for tracking the redesign. I'll be pushing to my james-darkfox/clap-rs:redesign first, then PR across to rebase into this new branch.

:+1:  for creating a 2x branch in the main `clap` repo. This will also allow other contributors to track and add to as well.

---

> ArgsOs vs Args (and unicode support)

Because POSIX allows non-valid unicode in file names, arguments, etc. I do believe we should support non-unicode...although IMO this should be the exception and not the rule. Consumers should opt-out of strict unicode handling as they do with the stdlib by using `*_lossy()` methods and functions.

How we go about this, either in 2x or 1x is up for debate, in fact I'm up for discussion in #262 

When I've flirted with this before `OsStr`s are a _pain_ to work with, just FYI :wink:


---

_Comment by @sru on 2015-09-22 02:07_

@kbknapp I think there is a slight misunderstanding on `*_lossy` functions. I always assumed they were named `lossy` because they will lose some of the data in some way.

:+1:  for opt-out of strict unicode handling, on the condition that it is well documented. I think the users want `str` to work with, not `OsStr` in `ffi` module. 


---

_Comment by @kbknapp on 2015-09-22 02:14_

@sru There is the _potential_ for loss of data. Any invalid unicode characters will be replaced with `U+FFFD`

Example:

``` rust
use std::os::unix::ffi::OsStringExt;
use std::ffi::OsString;

fn main() {
    let invalid = OsString::from_vec(vec![0xE9]);
    let data_loss = invalid.to_string_lossy();
    assert_eq!(&*data_loss, "\u{FFFD}");
}
```


---

_Comment by @sru on 2015-09-22 03:14_

@kbknapp Yes, I meant that rather than silently losing data through implemented `*_lossy` functions, we could have an option to expose the `OsStr` directly.

@james-darkfox Currently the checklist only lists what has been done and hasn't been done. Can you update the OP with structured list of features? For example with current clap library:
- `App`
  - holds the name of binary, version, usage string, and list of arguments
    -`get_matches_*` functinos
- `Arg`
  - flags
    - multiple
  - options
  - positionals
  - subcommands

Note that this is just an example and is really brief and not detailed.

I want to discuss and decide on concrete features before moving into implementation toward 2.0. Of course, I want others @Vinatorul, @kbknapp, or some random GitHub user to be able to comment and discuss as well.


---

_Comment by @WildCryptoFox on 2015-09-22 07:06_

@sru I'll update the OP soon. I also want others to comment and discuss. I'll upload the `Iterator; over AsRef<str>` soon and PR it into the v2 branch. I'm not happy with my current `OsStr` code (I want it to fully accept invalid Unicode freely).

@kbknapp Nice cargo-count. This beats whatever I came up with using find/grep/wc. :)

```
Full:       find . -name '*.rs' -exec cat {} \; | wc -l            8361
 +per-file  find . -name '*.rs' -exec wc -l {} + | sort -n | tail -4
    942 tests.rs
   1082 args/arg.rs
   3736 app/app.rs
   8361 total
Blanks:     find . -name '*.rs' -exec grep -e '^$' {} \; | wc -l   453
Comments:   find . -name '*.rs' -exec grep '//' {} \; | wc -l      2492
```

Speaking of which... `tests.rs` should be in `/tests/`.

---

@kbknapp I thought about a little while ago for a counter that counts `expressions` `statements` `conditions` `functions` `types` `allocations`, etc. Note: This would expand _one-liners_ into their true numbers. The numbers would be larger but would explain more about implementations than lines of `blank` `comments` `code` `unsafe code`, etc. And be ran against each function/type in a file, maybe even expand macros and see weights in dependencies.


---

_Label `P3: want to have` added by @kbknapp on 2015-09-22 13:38_

---

_Label `R: work in progress` added by @kbknapp on 2015-09-22 13:38_

---

_Label `W: 2.x` added by @kbknapp on 2015-09-22 13:38_

---

_Label `C: examples` removed by @kbknapp on 2015-09-22 13:38_

---

_Label `R: needs review` removed by @kbknapp on 2015-09-22 13:38_

---

_Comment by @WildCryptoFox on 2015-09-22 17:01_

@kbknapp @sru New macro builder ;-)

### Invocation sample

``` rust
#[test]
fn testapp() {
    clap_app!{ TestApp;
        (@meta => author: "James McGlashan"
                  about:  "Testing application")
        (@args => --config=<config> [-v|--verbose...3] <input_file>)
//      (@subcommands => TestApp) // recursion
    };
}
```

### Generated rust

Stripped down to the `vec`, ignoring the meta which only exists in the `AppBuilder` currently.

``` rust
vec![
  Rule::with_name(stringify!(config))
    .long(stringify!(config))
    .takes_value(stringify!(config)),
  Rule::with_name(stringify!(verbose))
    .short(stringify!(v).chars().next().unwrap())
        // Hacky, might just make this char a &'a str too and assert that it is of length 1
    .long(stringify!(verbose))
    .max_occurrences(3),
  Rule::with_name(stringify!(input_file))
    .positional()
    .required()
]
```

**Note**: This will likely have a `"description forced on each argument"`. It'll make the macro **HUGE** if I make that optional. Also, the current token parsing is quite limited....

**Edit**: I might change some semantics to the token parsing here. Namely reserving `<>` and `[]` for normal requirement, `pat|pat2|pat3` for groups, and `=` only on long; with comma separated named fields. As the description will be the last token-tree per argument, the `:tt` space might need to be shared for these per group sections. I should be able to factor things down for all of these categories.

**Gist**: https://gist.github.com/james-darkfox/820d6685adc4e2b363e9

---

I've been busy doing a number of non-clap things today. Finished my day with this macro and now... zzZZZ


---

_Comment by @WildCryptoFox on 2015-09-23 06:28_

Updated macro: https://gist.github.com/james-darkfox/820d6685adc4e2b363e9/

``` rust
    clap_app!{ TestApp;
        (meta => author: "James McGlashan"
                 about:  "Testing application")
        (args => config:  (--config conf {exists}) "Configuration file"
                 verbose: [-v --verbose..3]        "Verbosity level"
                 input:   (input_file)             "Input file"
        )
//      (@subcommands => TestApp) // recursion
    };
```

Requirement is implied by `()` and `[]` instead of `<>` and `[]`. This is because `<$($tt:tt)*>` is invalid due to `<>` not having the same token-tree affect of `()`, `[]` and `{}`.

**Note**: This implementation uses repeating for each meta variable, and for each argument definition. If the latter were moved to a `TT-muncher`; then we could get `<>` however, the cost will be quite a hit on the complexity of the macro.

---

Although I don't yet have subcommands and groups. Subcommands at least by design now, are by-ident for their type, assumed to be defined in scope.


---

_Comment by @WildCryptoFox on 2015-09-23 12:55_

@sru updated OP as requested


---

_Renamed from "RFC: Mass refactorization (or rewrite?)" to "RFC: Clap2, from scratch re-write and redesign" by @WildCryptoFox on 2015-09-23 12:59_

---

_Comment by @WildCryptoFox on 2015-09-23 13:57_

@kbknapp @sru 
Branch updated: https://github.com/kbknapp/clap-rs/tree/redesign
Travis building status: https://travis-ci.org/kbknapp/clap-rs/builds/81777547

Sorry for the Travis failed builds. Tired + `git rebase -i` ~= eh


---

_Comment by @sru on 2015-09-23 14:32_

@james-darkfox 

First, you spelled "chore" wrong.

Is there reason behind the naming choice? I think that `Accumulator` could be named to `Match`, and the `CollectedMatches` to just `Matches`.

The clap user needs to import `CollectionMatcher` every time along with `App`, which can be quite misleading if we do not emphasize that `CollectionMatcher` needs to be imported as well. I am unsure of splitting `CollectionMatcher` and `App`. `CollectionMatcher` sounds a bit weird to me and is too long... (although it is only my opinion)

`OsStr`? `Cow`?


---

_Comment by @WildCryptoFox on 2015-09-23 14:41_

@sru I've ammended the commit, thanks.

Naming choices were just me cleaning the code for myself; I'm open for other names as mentioned in the updated top post.

As for the trait, I'm thinking about hiding this in the macro as a `use $crate::CollectionMatcher`. This would also work for `UsageStringHandler` (`Vec<Rule>` to usage string).

As for OsStr, left out for simplicity of the 'first commit', I do intend to include this. I'm unsure for how the API should be exactly here.


---

_Comment by @kbknapp on 2015-09-23 14:41_

@james-darkfox ref #274 about YAML parsing, I would absolutely want to include it in a 2.x branch. Similar to how 1.x works now, we have a base "builder pattern" back-end so to speak, and other forms of building valid arguments (macros, usage, yaml, etc.) all boil down to the base builder pattern, and are purely supplemental front-ends, if you will.


---

_Comment by @WildCryptoFox on 2015-09-23 14:44_

@kbknapp Okay. Worth noting that any such YAML parsing would be implemented in `src/yaml.rs` and `lib.rs` would need at most `#[cfg(feature = "yaml")] pub mod yaml` with nothing yawl-specific in any other file.

From usage string, same feature rule.


---

_Comment by @kbknapp on 2015-09-23 14:45_

Yep that's fine! For the features, I would only gate them if they incur additional dependencies or are unstable.


---

_Comment by @kbknapp on 2015-09-23 14:47_

Also, about the naming. I agree with @sru that everything should short and concise as possible, without require too many imports...as for the names themselves I don't really care too much until we start landing final products and have to name them for real. Names during development can be whatever. :wink:


---

_Comment by @WildCryptoFox on 2015-09-23 14:51_

@kbknapp Okay. (No feature gate for usage string)

@kbknapp Feel free to commit. And add yourself to `Cargo.toml` authors :wink: 


---

_Comment by @WildCryptoFox on 2015-09-23 14:52_

@kbknapp What do you think about the macro hiding the trait imports? The consumer needs to at most `#[macro_use] extern crate clap;` as the macro brings everything it needs through `$crate`


---

_Comment by @sru on 2015-09-23 14:53_

@james-darkfox @kbknapp @Vinatorul 

### RFC: Renaming

```
Accumulator               -> Match
CollectedMatches          -> Matches
CollectionMatcher         -> ??? (MatchParser)
CollectionMatcher.matches -> CollectionMatcher.get_matches
Rule.values_collected     -> Rule.values_to_collect
```

For `CollectionMatcher` I chose `MatchParser` because it is parsing matches. `UsageStringHandler` can be `UsageParser` too.

@james-darkfox I don't agree with hiding `CollectionMatcher` inside macro. I think it should be transparent to user as much as possible. I am not sure if the `use` statement inside macro affects the outside.


---

_Comment by @WildCryptoFox on 2015-09-23 15:04_

I'm not sure about the suggested names. `matches -> get_matches` I approve.

@sru as `$crate` is the crate path, the internals of the macro are already fully qualified (expands to `::clap::Rule`, etc). I just confirmed on IRC that the use for the trait will be within the scope of the callee function.


---

_Comment by @WildCryptoFox on 2015-09-23 15:11_

@sru As you may have noticed from `macros.rs` in the last matching arm, I'm thinking more for an item-position for creating `App`s. Namely at the item level the consumer gets a new struct `TestApp`, which they can call (at least) 2 functions on. `new` for a new parser of this type. `get_matches` which internally knows the respective trait and expands the matches into the struct `TestApp { config: String, verbose: usize, input: String }` Note if any of these had defaults they would be applied here. Also; I'm not _entirely_ sure about how to track the to-struct code; I'm expecting some fun with macros and associated types.

In any case, if the consumer wants more advanced usage that requires going below the abstraction layers, they are free to do so.


---

_Comment by @WildCryptoFox on 2015-09-23 15:14_

Speaking of the item level. Subcommands are likely to be created **EXACTLY** the same way as the normal `App`s.


---

_Comment by @sru on 2015-09-23 16:52_

@james-darkfox Ooooh. Just like the serialization at `docopt` yeah?

I think it is fine to `use $crate::CollectionMatcher` inside the macro as long as the user of this library is aware of the trait.


---

_Comment by @WildCryptoFox on 2015-09-23 17:03_

Either using `RustcDecodable` or manually; not yet decided. In contrast to `docopt` all arguments have names and as such we don't need silly naming for fields. I'll be leaning towards the `RustcDecodable`; unsure how it'll work for `vec!["foo"]` to extract the first (and only) for fields expecting a `String`, or handle various other types. In all cases asserting the length expected is the same for the field as it is for the `rule` the parser worked with.


---

_Referenced in [clap-rs/clap#280](../../clap-rs/clap/pulls/280.md) on 2015-09-25 02:22_

---

_Comment by @sru on 2015-09-26 17:23_

I will change the names after four days (~week from the original post on name change)

Also `Rule.values_collected` is a bit confusing to me. It's more like "values to be collected," but I read it as values already collected.


---

_Referenced in [clap-rs/clap#282](../../clap-rs/clap/pulls/282.md) on 2015-09-26 22:16_

---

_Comment by @WildCryptoFox on 2015-09-27 04:31_

@sru Indeed "to be collected". `values_to_collect` ?


---

_Comment by @sru on 2015-09-27 04:44_

@james-darkfox :+1: 


---

_Comment by @WildCryptoFox on 2015-09-27 05:55_

While using `darcs` (Haskell's git-alternative), I found the luxury of lazy completions to be very nice.
- `command su` -> `command subcommand` where `subcommand` is the only `su` prefixed subcommand. Otherwise error saying there was an ambiguous command given, providing the list of full valid values. As subcommands are positional arguments, this also applies for anything else with `possible_values` set.
- `--ver` -> `--version` such that `version` is the only `ver` prefix in the long variety
- This has no affect to shorts

It might be nice to throw this in as a feature. Anyone have any thoughts for this? These completions are better than just 'suggestions' as if a possible value is close enough, it is highly likely that is the one.

**Note**: I'm measuring the prefix of the possible values, this is not accounting for typos which should simply error with 'close' suggestions like `clap1`


---

_Comment by @sru on 2015-09-27 06:06_

@james-darkfox Yes, I also think it would be a nice feature (I use it all the time in vim).


---

_Comment by @WildCryptoFox on 2015-09-27 07:42_

### RFC: Settings
- Chained commands? `fake clean build test` -> `fake clean` `fake build` `fake test`.
  - Side affect: Multiple positional captures must end with -- to chain another command
- Requires command `fake` -> `Expecting command => list of commands` (not `--help`) **fatal**
- Requires command else help `fake` -> `fake --help` **fatal**
- Derive help: add `-h --help`
- Derive version; add `-V --version`
- Derive help command; add `help` to commands; alias mapping to `--help` for the respective supplied command. `help foo` -> `foo --help`
- Lazy command, flag, possible_values, completion. `--ver` -> `--version` such that `ver` is not ambiguous.

### RFC: Renaming ext.
- `subcommand` -> `command`: `prog command`, when commands are present they are the true focus and are not so secondary.

---

@sru I've edited your RFC for renaming such that it can be found easily by `/rfc:`


---

_Comment by @kbknapp on 2015-09-28 16:39_

I'm of a slightly different mind about the suggestions and auto correction, or lazy `--ver`->`--version` idea. I think it's a nice feature, but I'm far more of a fan of just informing the user of the mistake and letting them correct it. Reason being, if the application author adds functionality which changes the auto-correction, the user could get unintended results. And in extreme cases these changes could be detrimental. There is also the case where the user typos something, which actually auto-corrects to something destructive. Instead of just asking them if they meant to do it, it just does it.

Just my 2 cents. 


---

_Comment by @WildCryptoFox on 2015-09-28 17:38_

@kbknapp Note that if there were two `ver` prefixed options, then it would already inform about the ambiguity. How about that goes into the Settings RFC?

### RFC: Settings ext.

`+ lazy command, flag, possible_values, completion`

---

Anyone writing scripts should **REGARDLESS** use full words


---

_Comment by @kbknapp on 2015-09-28 21:53_

I'm good with making it an optional setting, just not the default. We'll just need to ensure the docs are clear on the pros and cons of using it. 


---

_Comment by @kbknapp on 2015-09-28 21:56_

As for a name, `AutoComplete`, `AutoCorrectIncompleteArgs`, etc?


---

_Comment by @sru on 2015-09-29 02:34_

@kbknapp `InferUnambiguous`? `AutoComplete` seems too general. And `AutoCorrectIncompleteArgs` is a bit off-topic because it's not exactly "correcting" the command. Or just, `LazyCommands` is fine too.

@james-darkfox What do you mean "fatal"?

Also, @kbknapp talked about opt-out for the help and version, instead of opt-in.

I don't really like the chained command. I am unsure if there is enough use case for the chained command to have the extra complexity in the library.


---

_Comment by @WildCryptoFox on 2015-09-29 03:36_

@kbknapp Automatic correction is much more dangerous than completion. So much so that I'd opt against that entirely.


---

_Comment by @WildCryptoFox on 2015-09-29 03:41_

@sru Same definition as with current clap. **Fatal** ends the program with the error code of 1, after showing the relevant information. None of the fatal commands would be enabled by default. Documentation would define the differences.


---

_Comment by @WildCryptoFox on 2015-09-29 03:42_

@sru Chained commands; I was thinking much like `make`, and it wouldn't be difficult for any consumer to adopt that structure by just collecting multiple positional values.


---

_Comment by @sru on 2015-09-29 04:14_

@james-darkfox Yes, I was also thinking of `make` as a prime example. Since it wouldn't be too difficult for any consumer to adopt the structure by just collecting multiple positional values (and check the values with `validate`), I am unsure if there are enough use cases for this particular structure to actually include in the library. (Is it actually useful for majority of people vs. is it just a code bloat)


---

_Comment by @WildCryptoFox on 2015-09-29 04:59_

@sru :)


---

_Comment by @kbknapp on 2015-09-29 06:12_

@james-darkfox Are you talking about auto-completion as in the shell auto-autocompletion? If that's the case, I've been thinking about a way to easily take a `clap` `App` definition and generate a bash, or zsh auto-completion file for some time (on the back burner of my mind at least). I thought you were talking about someone typing `$ myapp --ver` and `clap` interpreting that as `$ myapp --version` and continuing execution.

---

Going forward to keep discussion and implementation focused I'm proposing we do the following:
- [ ] List **all** current `clap` features and capabilities in the OP (**EDIT**: This is already mostly done, but not quite complete. There are a few features missing, or some that should be broken down into further sub-sections. **EDIT 2**: Also, I'm speaking more about separating current features, from proposed features, from implementation details...currently it's all mixed into one list)
- [ ] Determine which of those capabilities will be **changed** (i.e. _implemented_ but in a slightly different manner from the `clap` **consumer** standpoint...breaking changes)
- [ ] Implement all current capabilities in `clap` 2.x tracked by individual 2.x issues with this issue being the overarching 2.x discussion forum and overall tracking issue
- [ ] Determine which **new** features will be present in 2.x (i.e. custom `Matches` struct allowing things like `matches.some_arg` fields instead of the current `matches.value_of("some_arg")`)
- [ ] Implement all new features in individual 2.x tracking issues, again with this issue being the overarching 2.x discussion forum
- [ ] Test / Bench the 2.x branch to ensure we didn't lose ground
- [ ] Once all features / bugs / benches have been worked from the 2.x branch we'll ensure docs are good to go and release

I'm proposing we do these **in that order** because it appears to me we need some structure to this re-design and rebuild. **EDIT 3:** This means if box 1 isn't checked, we shouldn't be working on box 2. It's very easy to get side-tracked working on the latest and greatest new idea without implementing the "must haves" or doing so with an incomplete feature set in mind...which is how `clap` 1.x go to where it is today.

**Most importantly** if we don't have a full picture of the feature set 2.x will include we **cannot** make sound design decisions. Meaning certain choices are dictated by other features that must be present. An example of this is validators. And this is **not** picking on @sru , it's just a an example :smile: But validators as currently implemented in the 2.x branch will probably not work with global arguments (because of the need to clone args down through child subcommands). If we go at this re-design without first fully listing the features and capabilities of `clap` 2.x we have the potential of not making fully informed design decisions which we'll have to fix, adjust, duct-tape, band-aid fix throughout the process...which is **exactly** how `clap` 1.x became a less friendly mess (or at least one of the reasons :stuck_out_tongue_winking_eye:). 

I just want to be clear that all current capability must be present in 2.x although some of it may be tweaked/modified/combined/etc. 

---

I'm not afraid to scrap any 2.x designs we come up with if we determine it's no better than 1.x. I want 2.x to be **rock solid** and something we're all extremely proud of. 

So let's not be afraid to break things and change things in 2.x. This is our chance to get things right, and set ourselves up for the future...but we need to do so correctly and not back step at all, unless a current feature is truly a mistake that should never have been :smile:

**See EDIT 1, 2, and 3 above**


---

_Comment by @WildCryptoFox on 2015-09-29 08:44_

@kbknapp I was talking about completion for `--ver` to `--version`. This is completion. While `--verion` -> `--version` would be correction. As for shell completions, one common method is to just provide a list separated by newlines '--help' '--version' '-h' '-V' ... Alternatively, more complicated shell completions could exist too.

As for the structure. Please free free to create the respective issue/threads. I also think we should have an IRC channel for private discussion and interactive design decisions. Dumping ideas and responding after often-hours via GitHub isn't quite so ideal. I've just created `irc.mozilla.org 6697 +ssl #clap-rs`.

As I've mentioned in one of @sru's PRs, I have a number of things that I need to do and so I won't be able to contribute as much as I'd like; I should be freed up in a couple of months.

**2.0 does not need to be released anytime too soon**

@kbknapp **rock solid** may not necessarily be correctly implemented. See [git vs darcs](https://youtu.be/iOGmwA5yBn0) and the [suckless philosophy](http://suckless.org/philosophy). In either case, the balance of science and engineering is what determines the result.

---

Clap1.x is pretty solid, covering many edge cases; while clap2 avoids the need for edge cases through a stricter design.

---

I mentioned git vs darcs because git is very rock solid, but not so well designed. While darcs is very well designed, and not yet as solid. I happen to be working on implementing the patch theory from darcs in rust for one of my projects.


---

_Comment by @kbknapp on 2015-09-29 22:07_

@james-darkfox :+1: to everything you said, I agree very much. I'll start idling in the orc when I can too, that's a good idea.


---

_Comment by @WildCryptoFox on 2015-09-30 05:00_

`irc.mozilla.org 6697 +ssl #clap-rs`
- [x] @james-darkfox
- [x] @sru
- [x] @kbknapp 
- [x] @Vinatorul 


---

_Comment by @kbknapp on 2015-09-30 12:48_

I think yo-bot has some irc pinging ability as well, it's just not enabled right now. 


---

_Comment by @sru on 2015-10-06 14:28_

@kbknapp I am not sure how this will work out. Since we are virtually rewriting the library, it is difficult to separate breaking changes from non-breaking changes. I agree that clap2 should have almost all the functionality that current clap has and that we should be more wary of what features will be in the library. However, I think that categorizing by feature is not a good idea because as of right now, 

I think it should be divided into three big categories: implementation, tests, and documentations. tests and documentations will be fine with just checklists,and we could divide implementations by... implementation.


---

_Comment by @Vinatorul on 2015-10-06 14:35_

@james-darkfox wow, irc channel, just saw.
I will join when come home


---

_Comment by @kbknapp on 2015-10-06 15:44_

@sru to be clear, I'm ok with losing some functionality for a clean implementation so long as that's not functionality we want anyways. There are certain parts of `clap` that I'd pull out and _not_ re-implement in 2.x, but _most_ of 1.x I do want to keep.

My main goal that I'm trying to avoid is pulling features out for a clean implementation, only to add them back in later putting us right back where we started or in the same boat as 1.x.

Once I get some time I'll sit down and look at the current feature set and decide what my personal priorities are and rank them similar to issues (i.e. "required", "want to have", "nice to have", "remove", etc.). This doesn't have to be the final list, just my own thoughts on the matter :smile:


---

_Comment by @nagisa on 2015-11-09 07:16_

> What should be the expected result of -abc 1 2 3 where a takes 1 argument and c takes 2? I'd expect -a 1 -b -c 2 3. In any case, this is shorthand and is the most flexible option such far, also easier to implement.

This kind of flag usually fails to parse with most arg parsers. Id probably expect the same because its ambiguous somewhat, not really intuitive, doesnt match previous parsers etc.

Short flags should only take arguments if theyre last in a concatenation of arguments (in your case `-ba 1` and `-bc 1 2` both work, but not `-ac 1 2` or `-ca 1` or `-ab ` or `-cb `)


---

_Comment by @kbknapp on 2015-11-09 07:35_

@nagisa :+1: I agreee


---

_Comment by @WildCryptoFox on 2015-11-10 00:54_

This shorthand was a side affect for the method that I was using to quickly parse shorts. It would take **more** effort to prevent the shorthand. There is nothing really wrong with the shorthand, and will likely not be the advertised method from developers of some project. They would split things up naturally.


---

_Comment by @sru on 2015-11-10 02:21_

@james-darkfox Some users of clap library might think it as "unexpected behavior" though.


---

_Comment by @WildCryptoFox on 2015-11-10 11:05_

@sru Maybe so, but if clearly explained there isn't anything wrong with it?

Speaking of behavior.. Anyone have any thoughts to either an environment variable, feature-gate, or simple function to dump the argument parsing result. Would be nice for troubleshooting parsing and clearly demonstrate how the configuration actually parses what the developer or users provide the program.


---

_Comment by @kamalmarhubi on 2016-01-06 21:54_

@kbknapp

> I've been thinking about a way to easily take a clap `App` definition and generate a bash, or zsh auto-completion file for some time (on the back burner of my mind at least).

Is this in the feature list? I just started using clap, and the structure seems very amenable to allowing completion. Though rather than generating an auto-completion file, I had been thinking of a special completion mode enabled by flag or env var. Completion mode would take a partial command line and offer a list of completions. The benefit is that the program can use runtime information to complete values for some args, eg drawing values out of a database.

Either way, I think it's a really worthwhile feature.


---

_Comment by @kbknapp on 2016-01-09 18:48_

@kamalmarhubi

Yes it is....although I have created anew issue to track it since it's just been on the back burner. I've thought about doing like you said but what I'm leary of is including that functionality unconditionally in programs that don't need or care about it. Perhaps only compiling in that functionality only in debug mode? I need to think on this and am open to all suggestions :)


---

_Referenced in [clap-rs/clap#376](../../clap-rs/clap/issues/376.md) on 2016-01-09 18:54_

---

_Comment by @sru on 2016-01-12 06:48_

- formats
  - short
    - flag `-f`
    - option `-o val1`
    - combining multiple shorts `-fBgoZ` == `-f -B -g -o -Z`
  - long `--f`
    - flag `--flag`
    - option `--option value`
    - option `--option=value`
  - multiple occurences
    - short `-v -v -v`
    - long `--verbose --verbose --verbose`
  - multiple values
    - short `-o val1 val2`
    - long `--option val1 val2`
    - long `--option=val1,val2`
  - unix `--` meaning
- values
  - default values
  - multiple values
    - mininum (at least)
    - maximum (at most)
    - exact
  - possible values
  - typed values
  - validation
  - required / optional
- rules (the relationships between arguments and state of arguments)
  - depends
  - conflicts with
  - mutually exclusive
  - groups
- subcommands
  - global argument
  - external subcommands
- meta data
  - automatically generate help, version, and usage
    - get version from Cargo.toml
- builder
  - YAML parsing
  - macro
- settings
  - SubcommandsNegateReqs
  - SubcommandRequired
  - ArgRequiredElseHelp
  - GlobalVersion
  - VersionlessSubcommands
  - UnifiedHelpMessage
  - WaitOnError
  - SubcommandRequiredElseHelp
  - Hidden
  - TrailingVarArg
  - NoBinaryName
- misc
  - POSIX-ly currect compatible conflicts
  - suggestion
  - colors
- default behaviors
  - ????
  - **very important**

I made this list according to what I think clap can be divided into, from the list of features above.

First, I'd like to point out that "multiple occurence" and "multiple values" are separate things and should be emphasized so. Consider `--option=val1,val2,val3 --option=val4,val5,val6`. It has an occurence of 2 and values of 3 for each occurence. Of course, this separation loses meaning in positional arguments, but for options (and flags), it could be a great way to separate things.

I think separating the meta data (authors, versions, and any extra information) from the actual parsing and match of argument is good idea because meta data isn't needed to parse arguments.

If done right, I believe that clap can be modularized. For example, parser doing parser thing, meta data doing meta data thing and so on. This could give the consumer customization and control in the intermediate steps of clap. Of course, it would reduce the number of AppSettings as well.

It is also important that these customizations have to come with sane defaults such that clap can run out of the box without much configuration.

I typed this up at a whim, so I am not sure if deviates too much from what clap currently is. The details has to be ironed out before actually doing anything (as mentioned by @kbknapp), but I think this is a good start to look into which will be changed, same, or new.

It was rather lengthy, I apologize :P


---

_Comment by @kbknapp on 2016-01-12 07:38_

@sru 
No problem with the length :)

And you're very correct about multiple occurrences being different from multiple values. Your example is spot on. I also totally agree with your comments.

The one thing I'd add is, I'm all for (and encourage) modularizing clap **internally** but don't necessarily want to modularize it too much **externally** (beyond `App`, `Arg`, `Setting`, and `SubCommand`). Because while making things modular does help conceptualize it once you're familiar with how everything works and fits together, when you're new it just adds confusion. This was on of my main complaints with `getopts` (and really just libraries in general). I think something that resonates with people is that `clap` is very intuitive (or close to), where you can _almost_ use it without documentation...just an auto-completer.

To be clear, i **do** want to modularize things internally as best we can, and that's something I've started to slowly refactor in. And I am good with modularizing certain things on the public facing API when it's intuitive enough, and provides a significant advantage in one way or another. My goal is to keep the external public facing API as simple as possible.


---

_Comment by @sru on 2016-01-12 15:52_

@kbknapp 
I see. So, the goal of 2.0 should be introduce breaking changes, but as little as possible, and overhaul the internal workings of clap.

I agree that exposing something to public API should provide significant advantage, but I am ambivalent about the intuitiveness. For example, let's say there are three possible ways to print help (this is a silly example):
1. By `print_help()` function
2. By `print_help_with(some_string: &str)` that takes custom string
3. By exposing the metadata through some means (say `get_metadata()`)
The third method may or may not be intuitive (some would say why would you need third method while others are delighted to get the metadata). However, it theoretically gives consumer total control of what should be done when printing help (again, this is a silly example). Consumers should default to first method or second method if they do not care much about help message, and clap should encourage them to use the first method. That's why I say default behaviors are very important.

On to breaking changes. The most obvious breaking changes would be:
- getting rid of deprecated methods
- reduce number of `get_matches_*` variants (by returning Result<...> as default)
- `SubCommand` -> `Subcommand` (not sure...)

These would not be complete list of breaking changes because we do not have implementation yet, but they are guaranteed breaking changes, yes?

On the sidenote, since, I am not able to go on IRC often and I don't have IRC bouncer, it is not an effective way to communicate for me. I noticed clap has gitter. Is it viable platform for communication?


---

_Comment by @kamalmarhubi on 2016-01-12 17:00_

Have a path for localization and translation https://github.com/kbknapp/clap-rs/issues/380


---

_Referenced in [clap-rs/clap#372](../../clap-rs/clap/issues/372.md) on 2016-01-13 07:07_

---

_Comment by @kbknapp on 2016-01-13 07:15_

@sru You can see in #372 what you listed is almost exactly what's happening (minus the SubCommand->Subcommand....which I agree with, but I'm trying to keep breaking changes minor-ish and it's more of a bike-sheddding thing anyways). But with the addition of decreasing the lifetime annotations in public types `App`, `Arg`, et. al.

So everyone is tracking, I'll be putting out a 2x release shortly with these minor breaking changes, but ergonomic wins and a chance to clean up some cruft. 

This full re-design can still be discussed, and once some solid implementation happens it'll just be the next major release. I'm not scared of large version numbers :smile: Bottom line, continue with discussion and implementation, just cause 2x is coming out does not mean this thread is done! :smile: 


---

_Renamed from "RFC: Clap2, from scratch re-write and redesign" to "RFC: Clap, from scratch re-write and redesign discussion" by @kbknapp on 2016-01-13 07:15_

---

_Removed from milestone `v2.0` by @sru on 2016-01-13 18:25_

---

_Comment by @kbknapp on 2016-03-28 15:11_

I think conversation has staled a bit on this. I'm preferring individual tracking issues related to re-designing components. So I'm closing this for now.


---

_Closed by @kbknapp on 2016-03-28 15:11_

---

_Comment by @kamalmarhubi on 2016-03-28 18:10_

:+1: I feel like this thread served its purpose quite well :-)


---
