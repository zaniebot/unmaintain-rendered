---
number: 9799
title: "`PLR6301` (`no-self-use`) gives false positive for overriding method that does not call super()"
type: issue
state: closed
author: jakob-keller
labels:
  - bug
assignees: []
created_at: 2024-02-02T20:31:26Z
updated_at: 2024-02-08T08:26:35Z
url: https://github.com/astral-sh/ruff/issues/9799
synced_at: 2026-01-07T12:31:13-06:00
---

# `PLR6301` (`no-self-use`) gives false positive for overriding method that does not call super()

---

_Issue opened by @jakob-keller on 2024-02-02 20:31_

<!--
Thank you for taking the time to report an issue! We're glad to have you involved with Ruff.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `ruff /path/to/file.py --fix`), ideally including the `--isolated` flag.
* The current Ruff settings (any relevant sections from your `pyproject.toml`).
* The current Ruff version (`ruff --version`).
-->

I ❤️  ruff!

While playing with the current set of preview rules, I stumbled upon this edge case: 

```python
# test.py


class Foo:
    def __init__(self) -> None:
        self.value: int = 1

    def get_value(self) -> int:
        return self.value


class Bar(Foo):
    def get_value(self) -> int:
        return 2
```

```
$ ruff --version
ruff 0.2.0

$ ruff check --isolated --preview --select PLR test.py
test.py:13:9: PLR6301 Method `get_value` could be a function, class method, or static method
   |
12 | class Bar(Foo):
13 |     def get_value(self) -> int:
   |         ^^^^^^^^^ PLR6301
14 |         return 2
   |

Found 1 error.
```

Admittedly, the example is a bit construed. Yet I believe this is valid code and should not trigger an error.

A related issue was addressed in #6961. 

By the way: PyCharm correctly handles this case. On the other hand, ruff is (currently) not a type checker and might be unable to do anything about it.

---

_Label `bug` added by @zanieb on 2024-02-02 21:22_

---

_Comment by @charliermarsh on 2024-02-08 02:57_

Thank you so much for the kind words!

I'm torn on what to do here (in the short-term, while we don't support multi-file analysis). We could...

1. Detect this when the parent class is defined in the same file (as in the example above).
2. Limit this rule to only flag for classes without any parent classes.
3. Nothing?

By the way, one workaround here: if you decorate the method with `@typing_extensions.override`, we'll avoid flagging it.


---

_Comment by @jakob-keller on 2024-02-08 08:26_

> if you decorate the method with `@typing_extensions.override`, we'll avoid flagging it.

Great suggestion! Our codebase is still on Python 3.11 and doesn't use the override decorator yet. But I will probably use the backport available from `typing_extensions`. That's the most elegant solution I can think of.

I am closing this issue in favor of option 3 (won't fix) since:

> 1. Detect this when the parent class is defined in the same file (as in the example above).

Is rarely the case in substantial codebases.

> 2. Limit this rule to only flag for classes without any parent classes.

Introduces too many false negatives IMHO.

---

_Closed by @jakob-keller on 2024-02-08 08:26_

---
