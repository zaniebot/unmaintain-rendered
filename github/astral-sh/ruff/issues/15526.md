---
number: 15526
title: Allow Self-Assignment of variable in TYPE_CHECKING block
type: issue
state: open
author: spacemanspiff2007
labels:
  - rule
  - docstring
assignees: []
created_at: 2025-01-16T08:21:08Z
updated_at: 2025-01-30T11:05:22Z
url: https://github.com/astral-sh/ruff/issues/15526
synced_at: 2026-01-07T12:31:13-06:00
---

# Allow Self-Assignment of variable in TYPE_CHECKING block

---

_Issue opened by @spacemanspiff2007 on 2025-01-16 08:21_

I have subclasses which implement different behavior or restrict the data types of the base class.
Additionally I have a docstring on the class which describes the behavior and the instance variables.
Sphinx can only document the instance variable type if it's imported into the module.
To prevent automatic deletion of the (falsely marked as unused) import I self assign the data type in the TYPE_CHECKING block.

Example.:

a.py:
````python
from decimal import Decimal

class MyComplexBaseClass:
    def __init__(self) -> None:
        self.var: Decimal = Decimal('1.3')
````

b.py
````python
from decimal import Decimal  # <-- Must be imported otherwise sphinx fails
from typing import TYPE_CHECKING

from a import MyComplexBaseClass

if TYPE_CHECKING:
    Decimal = Decimal  # <-- Self assign to prevent removal during import optimation

# sphinx uses the datatype of ivar, if it is not imported if fails
class MyClass1(MyComplexBaseClass):
    """
    :ivar Decimal value: Some instance var with description
    """
````

This works well, however it triggers [PLW0127](https://docs.astral.sh/ruff/rules/self-assigning-variable/)

````text
b.py:8:5: PLW0127 Self-assignment of variable `Decimal`
  |
6 | if TYPE_CHECKING:
7 |     Decimal = Decimal
  |     ^^^^^^^ PLW0127
```` 

How about allowing Self-assignment in the `TYPE_CHECKING` block?

---

_Label `rule` added by @MichaReiser on 2025-01-16 09:13_

---

_Comment by @MichaReiser on 2025-01-16 09:15_

Thanks for the detailed write-up. 

The main issue here seems to be that ruff doesn't understand the use of `Decimal` in the docstring. That's why I'm leaning against making this, also somewhat obscure and hard to discover, exception and instead prefer teaching Ruff to understand docstrings better.

---

_Comment by @Daverball on 2025-01-16 09:35_

I personally feel that importing symbols purely for use in docstrings, is a bit of a code-smell. Shouldn't you be able to instead use the fully qualified name `decimal.Decimal` in the docstring? Or potentially `~decimal.Decimal` so it's still rendered as `Decimal`. That seems like a better solution to me.

But I agree that Ruff could do a better job here. Detecting the case where an import is only used for its use inside a docstring could then easily become its own rule.

---

_Comment by @spacemanspiff2007 on 2025-01-16 09:51_

> Shouldn't you be able to instead use the fully qualified name `decimal.Decimal` in the docstring? Or potentially `~decimal.Decimal` so it's still rendered as `Decimal`. That seems like a better solution to me.

I'm not sure if this works.
However `Decimal` is only a placeholder (I needed something that has to be imported) and the value is in my case typically a custom datatype. If I import the module my IDE properly refactors the import when I move the implementation around in my project which will not be the case if I use the fully qualified name.

> That's why I'm leaning against making this, also somewhat obscure and hard to discover, exception

I agree it's not very nice. 
However PyCharm does also not discover this properly, too.
I have to do it anyway if I don't want PyCharm to flag it as an unused import.
ðŸ˜• 


---

_Comment by @Avasam on 2025-01-17 00:03_

Idk if you can do so in PyCharm, but in VSCode I disable organization and removal of unused imports.

That way my linter (here Ruff's `I` group) takes care of it on save instead. And I can noqa it.

https://github.com/python/typeshed/pull/13363

---

_Comment by @InSyncWithFoo on 2025-01-17 02:23_

For the record, PyCharm's support for reStructuredText/Sphinx in general [is pretty bad](https://youtrack.jetbrains.com/issue/PY-73814), and [it won't be improved anytime soon](https://youtrack.jetbrains.com/issue/PY-73814#focus=Comments-27-10865300.0-0).

---

_Label `docstring` added by @dhruvmanila on 2025-01-17 05:04_

---

_Comment by @spacemanspiff2007 on 2025-01-30 04:41_

I'm don't think this is related to docstring only. 

There are many use cases that requires where one would want to import an module or object that normally would be moved to the `TYPE_CHECKING` block or that even would be removed during import sort. 
E.g.
- if I access something dynamically (e.g. through `getattr` or `globals()`) 
- if I want to resolve type hints and further work with the resolved types

The most easy and consistent way to achieve this is to keep a self-assignment in the `TYPE_CHECKING` block.
That's why I still think it's a good idea to make an exception for the `TYPE_CHECKING` block and allow the self assignment there.

---

_Comment by @Daverball on 2025-01-30 07:01_

I respectfully disagree. When static analysis gets something wrong, due to how  dynamic of a language Python is, the solution isn't to add some hack to your code, the solution is to add a `noqa` comment, that's what they're for.

Self-assignment in type checking blocks is non-idiomatic, and besides you, nobody will understand what it's supposed to do, or that it can/should go away, once it's no longer needed to avoid the import related violation.

Only once `noqa` isn't enough, because there's a whole cascade of issues that would require their own suppression comments, should you really be tempted to reach towards trickery using `TYPE_CHECKING` and even then you should ask yourself if a refactor of your code wouldn't serve you better.

---

_Comment by @spacemanspiff2007 on 2025-01-30 07:33_

Thank you for your response. I agree that dynamically accessing module imports is somewhat hacky and a good candidate for refactoring. For this use case a `noqa` is sufficient because it doesn't happen often.

However I think you only addressed one point of my argument:
Resolving type hints to the corresponding type and accessing it is something that is quite common and both done during testing and during code execution.
Pseudo example using pydantic, but this works the same for any class:

file a:
````python
class MyValue1(BaseModel):
    type: Literal['MyValue1Type']
    ...

class MyValue2(BaseModel):
    type: Literal['MyValue2Type']
    ...
````

file b:
````python
from a import MyValue1, MyValue2

class MyOuterValue(BaseModel):
    event: MyValue1 | MyValue2
    ...
````

If I want to build a list of types that are allowed for `MyOuterValue` I can programmatically get that from the class with ``typing.get_origin()`` and ``typing.get_args()``.
Accessing the type hints for further processing is something quite common when working with these models.
However to make it work the import has to be available and a self assignment in the `TYPE_CHECKING` block is the common way to consistently achieve this across all checkers and IDEs.


---

_Comment by @Daverball on 2025-01-30 10:36_

@spacemanspiff2007 In order to support pydantic and other kinds of libraries that need to access type information at runtime there are settings like [runtime-evaluated-base-classes](https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-base-classes) and [runtime-evaluated-decorators](https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-decorators), which can give you the desired effect.

It's not a complete solution and there are still some other required runtime uses that are difficult/impossible to detect statically (there are also cases where we can't statically know either way, like forward references to models in SQLAlchemy's `Mapped`). I am actively working to make `flake8-type-checking` more flexible and support more use-cases, but it's never going to be able to be the right tool for absolutely everyone. If it's not the right fit, it's better to just disable the `TC` rules, or at least the ones that are causing issues for you.

But either way, any solutions should ideally only rely on configuration and noqa directives, not on some magical piece of Python code.

---
