---
number: 10247
title: Add an option to warn about each undefined name only once
type: issue
state: closed
author: Beliavsky
labels:
  - question
  - wontfix
  - rule
assignees: []
created_at: 2024-03-06T14:50:05Z
updated_at: 2024-03-11T17:14:30Z
url: https://github.com/astral-sh/ruff/issues/10247
synced_at: 2026-01-07T12:31:13-06:00
---

# Add an option to warn about each undefined name only once

---

_Issue opened by @Beliavsky on 2024-03-06 14:50_

Sometimes I refactor by copying some lines from a source file to a function in a new source file and then
use ruff to find undefined names, which should either be function arguments or module imports. If variable
`foo` is used in many lines before being set, ruff will give an error message

`func.py:2:35: F821 Undefined name foo`

for each such line. It would be nice to see this error message only the first time `foo` is encountered, since fixing the error will cause the other error messages involving `foo` to also go away.


---

_Comment by @MichaReiser on 2024-03-06 14:59_

Hi @Beliavsky, Thanks for reporting this issue. I understand the motivation for this request, but it seems difficult for Ruff to know which variables it is safe to omit the warnings for. We want to avoid new *undefined name* warnings popping up after making changes (fixing one issue should not result in more issues that you weren't aware of before). 

Given:

```python
bar = 5
print(foo)

if foo:
	print(foo + bar)

def inner():
	print(foo - bar)

foo + 2
```

Now, the obvious fix is to define `foo` at the top of the module. That would fix all errors:

```python
foo = 10
bar = 5
print(foo)

if foo:
	print(foo + bar)

def inner():
	print(foo - bar)

foo + 2
```

However, you could define `foo` in other places where it only resolves some of the warnings:

```python
# In the function
bar = 5
print(foo)

if foo:
	print(foo + bar)

def inner():
	foo = 40
	print(foo - bar)

foo + 2

# In the if branch
bar = 5
print(foo)

if foo:
	foo = 10
	print(foo + bar)

def inner():
	print(foo - bar)

foo + 2

# After the first use
bar = 5
print(foo)

foo = 10

if foo:
	print(foo + bar)

def inner():
	print(foo - bar)

foo + 2
```

---

_Label `question` added by @zanieb on 2024-03-11 17:14_

---

_Label `wontfix` added by @zanieb on 2024-03-11 17:14_

---

_Label `rule` added by @zanieb on 2024-03-11 17:14_

---

_Closed by @zanieb on 2024-03-11 17:14_

---
