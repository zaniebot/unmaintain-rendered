---
number: 10653
title: ☂️ Error recovery improvements for the new parser
type: issue
state: open
author: dhruvmanila
labels:
  - parser
  - tracking
assignees: []
created_at: 2024-03-29T07:58:47Z
updated_at: 2025-12-01T09:17:54Z
url: https://github.com/astral-sh/ruff/issues/10653
synced_at: 2026-01-07T12:31:13-06:00
---

# ☂️ Error recovery improvements for the new parser

---

_Issue opened by @dhruvmanila on 2024-03-29 07:58_

This issue tracks any improvements that could or should be made when working on error recovery for the new parser. This will be _after_ #10036 is merged and when error recovery work is started.

- [ ] 1. Avoid including the invalid expression node for empty and unclosed container types. For example,

	```py
	[
	```
	
	Here, there are no elements and the list isn't closed. Currently, the parser would emit an invalid node and report an error. The AST would contain a list expression with a single invalid node. Refer https://github.com/astral-sh/ruff/pull/10554#discussion_r1540762104

	This should be done for list, set, dictionary, and tuple literals and possibly their comprehension variants.

- [ ] 2. Re-visit error recovery in pattern parsing. Refer https://github.com/astral-sh/ruff/pull/10966#pullrequestreview-2002663533

- [ ] 3. https://github.com/astral-sh/ruff/issues/10570

- [ ] 4. Check if we should use the list parsing to recovery from a syntax error in a `case` block: https://github.com/astral-sh/ruff/pull/10831#discussion_r1557231096

- [ ] 5. Double starred expression in a dictionary can only be used as a standalone element. If it's combined with either key or value in dictionary literal or comprehension, the parser doesn't recover well. For example,

	```py
	# Used as key or value
	{1: 2, **a: b, a: **b}
	
	# Used in comprehension
	{**x: y for x, y in iter}
	{x: **y for x, y in iter}
	```
	
	Possible solution [as suggested here](https://github.com/astral-sh/ruff/pull/10636#discussion_r1542405830) to recover is by parsing this as a power operator without a left hand side
	
	```py
	{ x: <missing>**y for x, y in data}
	```
	
	See https://github.com/microsoft/TypeScript/blob/02bb3108ad625cddcec228846b9ff56cc5398976/src/compiler/parser.ts#L5506-L5569

- [ ] Possible improvement to recovery from an unparenthesized named expression at the statement level. For example,

	```py
	x := 1
	```
	
	Currently, the parser would parse the `x` as a statement and throw an error at the `:=` token as it cannot start any statement. One way would be to _allow_ named expression and check if it's parenthesized or not. Refer https://github.com/astral-sh/ruff/pull/10641#discussion_r1542500243

- [ ] 6. If there are multiple expressions in a parenthesized context **not** separated by a comma, we could possibly use the tuple parsing. For example,

	```py
	(1 2)
	```
	
	Here, it could be a missing comma error but currently the parser would expect a closing parenthesis after `1`. Refer https://github.com/astral-sh/ruff/pull/10641#discussion_r1542503837

- [x] #20849

- [ ] 8. Currently, the top level expression parsing uses the `star_expressions` rule which is what the grammar has. This means that for an unparenthesized named expression, the error messages aren't really that useful. We could potentially use `star_named_expressions` rule and report an error if an unparenthesized named expression was found. Refer https://github.com/astral-sh/ruff/pull/10659/files#r1547373837

- [ ] 9. The default case for expression parsing gives confusing error message:

	```
	  |
	3 | (x :=
	4 | 
	5 | def foo():
	  | ^^^ Syntax Error: Expected an identifier, but found a keyword 'def' that cannot be used here
	6 |     pass
	  |
	```
	
	This is because the if the expression parsing didn't find any valid start token for an expression, it first checks if it's a keyword and if it is then it parses it as a named expression ([source](https://github.com/astral-sh/ruff/blob/9a4bed5eec6584950afc5458a2e1f3273ef168be/crates/ruff_python_parser/src/parser/expression.rs#L523-L524)). Refer https://github.com/astral-sh/ruff/pull/10659/files#r1547376735

- [ ] 10. Possible improvement when the left-hand side is missing for an infix expressions such as binary, boolean and compare expression. Currently, the parser would drop the token and parse the right-hand side as a standalone expression. Refer https://github.com/astral-sh/ruff/pull/10730#discussion_r1547606839

- [ ] 11. Currently, the parser drops the left side of `=` of the keyword argument in a call expression when it's not a name expression. The reason being that only a name expression is allowed at that position. A possible recovery would be to add it to the `args` list but that means that it's a missing comma. For example, `call(x + y = 1)`, here `x + y` isn't allowed. Refer https://github.com/astral-sh/ruff/pull/10733#discussion_r1547831007

- [ ] 12. In `for` statement, the parser should parse the target if it's _not_ at `in` token. This could improve error recovery in case the target is absent. For example, `for in b: ...`. Refer https://github.com/astral-sh/ruff/pull/10816#discussion_r1555479143. 
	
	The underlying problem could be something else. If the parser doesn't find a token which starts an expression, then the expression parsing's fallback mechanism is to first check if the token is a keyword, if so then parse it as `ExprName`, else report an error and return an empty `ExprName` ([Internal discussion](https://discord.com/channels/1039017663004942429/1144561539219734578/1227243794190045236)).

- [ ] 13. In `try` statement, if `finally` is present then the `else` block can come only before it. If it comes after the `finally` block, it's an error. In that case, the parser will not parse the `else` block as part of the try statement and it'll parse the statements inside the block as per of the outer node. Refer https://github.com/astral-sh/ruff/pull/10815#discussion_r1555451275

- [ ] 14. Decorators with missing expressions or decorators being applied on the wrong node. Refer https://github.com/astral-sh/ruff/blob/f4fd047ea43e2c32cf4b12e73e9106e038c2db59/crates/ruff_python_parser/src/parser/statement.rs#L2224-L2237

- [ ] 15. Avoid dropping the `async` token while parsing an async statement. Refer: https://github.com/astral-sh/ruff/pull/10819#discussion_r1555471523

- [ ] 16. For `Mode::Expression`, currently the parser will drop all of the remaining tokens after the first expression is parsed. We could potentially have a better recovery by continue parsing till the current token is not the start of an expression and collect all the parsed expressions as a `ExprTuple`. The parser would raise an "expected a comma" error between each expression. Even after this, there could potentially be extra tokens which could represent a statement so we should keep dropping the tokens. Refer: https://github.com/astral-sh/ruff/pull/10981#pullrequestreview-2004395758

- [ ] 17. https://github.com/astral-sh/ruff/issues/16140

---

_Label `parser` added by @dhruvmanila on 2024-03-29 07:58_

---

_Assigned to @dhruvmanila by @dhruvmanila on 2024-03-29 08:39_

---

_Referenced in [astral-sh/ruff#10730](../../astral-sh/ruff/pulls/10730.md) on 2024-04-03 09:13_

---

_Referenced in [astral-sh/ruff#14315](../../astral-sh/ruff/issues/14315.md) on 2024-11-14 04:44_

---

_Unassigned @dhruvmanila by @dhruvmanila on 2025-02-14 08:37_

---

_Referenced in [astral-sh/ruff#16140](../../astral-sh/ruff/issues/16140.md) on 2025-02-14 08:49_

---

_Label `tracking` added by @dhruvmanila on 2025-02-19 03:05_

---

_Referenced in [astral-sh/ruff#16493](../../astral-sh/ruff/pulls/16493.md) on 2025-03-08 03:31_

---

_Comment by @dhruvmanila on 2025-03-08 03:36_

- [ ] 18. Consider changing `ast::ExprSubscript` to make `slice` field `Optional` so that an empty slice (which is an error) does not need to include an empty `ExprName` node as a placeholder.

---

_Referenced in [astral-sh/ruff#18281](../../astral-sh/ruff/pulls/18281.md) on 2025-05-26 11:29_

---

_Comment by @11happy on 2025-11-07 03:40_

Hello @dhruvmanila , is this issue still open ? I noticed its not marked as `help_wanted` so I just wanted to check. I am interested to work on this and would really appreciate any pointers or context to get started. Thank you : )

---

_Comment by @ntBre on 2025-11-07 19:15_

@11happy are you interested in any of the sub-tasks in particular? I think these could be pretty tricky to work on and may require some design work from us, but Dhruv would know better than me.

---

_Comment by @11happy on 2025-11-09 10:15_

I am interested to start with first one `Avoid including the invalid expression node for empty and unclosed container types` , overall I am interested on this broader task & exploring other subtasks as I go, 

---

_Comment by @MichaReiser on 2025-11-10 08:59_

@11happy this seems like a good start as it doesn't require any changes to the AST. Do you have any specific questions? 

---

_Referenced in [astral-sh/ruff#21703](../../astral-sh/ruff/pulls/21703.md) on 2025-11-30 13:41_

---

_Comment by @11happy on 2025-11-30 13:42_

I have linked the PR for first one.
Thank you : )

---

_Referenced in [astral-sh/ruff#21720](../../astral-sh/ruff/pulls/21720.md) on 2025-12-01 09:13_

---

_Comment by @11happy on 2025-12-01 09:15_

I have linked the PR for 5th one , would appreciate a review.
Thank you : )

---
