---
number: 15572
title: False positive PLE0302 with special methods as properties.
type: issue
state: open
author: mikeshardmind
labels:
  - bug
  - rule
assignees: []
created_at: 2025-01-18T19:34:17Z
updated_at: 2025-01-24T19:25:48Z
url: https://github.com/astral-sh/ruff/issues/15572
synced_at: 2026-01-07T12:31:13-06:00
---

# False positive PLE0302 with special methods as properties.

---

_Issue opened by @mikeshardmind on 2025-01-18 19:34_

Example code that works at runtime and which type checkers do understand


Code sample in [pyright playground](https://pyright-play.net/?code=GYJw9gtgBAxmA28CmMAuBLMA7AzgOgEMAjGKdCABzBFSgEEcBPLGAcSSyRANWoBoo7Tt14gBAYQKJiyCdTABXDJwBQoSFFSMK6LAHMylarTpZGK8lRqxsMBSBAdUeYEvtIcUAp5jAVKrQokegBRADkAFRCAJSgAXihJaSJkAG1UgF05cCVdJFTTRgFC4qYWIS4eagKzKAAfKDDsJAzWgO1guhCADQBJCPjEqXgZfNTA-IAhbyQQgA8YJAoMbAz6xuaBaZxZhaWVrHWmzgEwIgArFFQsxPlczhqi%2BjMBIjAENpUYEZxPOnEIt1UgBNDIALhUUChUAAJkhgFAAPqI3ToVDIgAUO3gwAEejB9DKbA4lVEIJuwAJvjwADE3I5UscWgBKKAAWgAfBtOBDoXyoNjgHgDAk9JD%2BVDBS5Bn5xVDvMxSHCEciCE4uJjBazOYTFRURNVQbyJVBHKh7IcpWK5V4ibD4UjEWq5mjMTa%2BYK%2BO7oUgFoiJgSJqltrtFstMFg1g0mV6TVBfTBEQA3KQKJAEkPzMMHI6bb1Q1DcRZEAgwADWBLOlzQseh2q5bwQxol6ARCeTqeC6E8WDAtCZzbjAqQOJceB26IT%2BwjGPbKfgaeZ-jjBAA7gQ0cPR3pCN8wDsMUu42aLVAaVIdv4VAqWPaVQQMWg5gT-oDHhl61B4N3UO-BzfSFXNEAAtYFQOZbVgQc%2BRPEBDlSJNbUVKBgGoKBEN0WAMhtWD4Ow-xvm8Tx5hQJQkAAdW4CgghAQdlUdVF0URLER1xJEYBfAEgUKD9oOhKVEVIBJBOXaF6NVddXWYrV2S5fUqhAR5iheL8f3fcF81NJBzTgqAMUYdARxhFDwGgJ0WNHQTmTwCSNyYw8lxtAABChwBorQbXEp11RATVWOZPioVwrchUEmzvKwVANURG1nNcsB3PMPkvOdKSLOAALNOCgSYHC1KmNE%2BU7Xo4BtJgYDmnSz9ClzHlNIAqAgNQUDBUg-FNL5BrUJAdCpDIQ52qHE1gvnLLtNPJkgA)

```python
from collections.abc import AsyncGenerator, Generator, Callable, Coroutine
from typing import Any
import concurrent.futures as cf

type AENTER = Callable[[], Coroutine[Any, Any, AsyncGenerator[Any | None]]]
type AEXIT = Callable[[type[BaseException] | None, BaseException | None, object], Coroutine[Any, Any, bool]]

class ACTX[Y]:
    def __init__(self, g: AsyncGenerator[Y], f: cf.Future[None]) -> None:
        self.g = g
        self.f = f

    async def __aenter__(self) -> AsyncGenerator[Y]:
        return self.g

    async def __aexit__(
        self,
        exc_type: type[BaseException] | None,
        exc_value: BaseException | None,
        traceback: object,
    ) -> bool:
        if exc_value is not None:
            self.f.set_exception(exc_value)

        await self.g.aclose()
        return False


async def _a(ctx: ACTX[Any]) -> list[Any]:
    async with ctx as c:
        return [v async for v in c]
    return []


class ExecuteWrapper:
    def __init__(self, _c: ACTX[Any]):
        self._c = _c

    def __await__(self) -> Generator[Any, Any, list[Any]]:
        return (yield from _a(self._c).__await__())

    @property
    def __aenter__(self):
        return self._c.__aenter__
    
    @property
    def __aexit__(self):
        return self._c.__aexit__

    async def fetchone(self) -> Any | None:
        async with self as g:
            async for val in g:
                return val
        return None
```


Rewriting `ExecuteWrapper` as:

```py
from operator import attrgetter

class ExecuteWrapper:
    def __init__(self, _c: ACTX[Any]):
        self._c = _c

    def __await__(self) -> Generator[Any, Any, list[Any]]:
        return (yield from _a(self._c).__await__())

    __aenter__: AENTER = property(attrgetter("_c.__aenter__"))  # pyright: ignore[reportAssignmentType]
    __aexit__: AEXIT = property(attrgetter("_c.__aexit__"))  # pyright: ignore[reportAssignmentType]

    async def fetchone(self) -> Any | None:
        async with self as g:
            async for val in g:
                return val
        return None
```
for contrast has better runtime behavior (slightly, anyhow), but unfortunately, properties are not generic in the type system, so this ends up not type-checked, though ruff has no issue with this definition.

---

_Label `bug` added by @dylwil3 on 2025-01-18 22:32_

---

_Label `rule` added by @dylwil3 on 2025-01-18 22:32_

---

_Comment by @dylwil3 on 2025-01-18 22:34_

I think it seems reasonable to skip the check when there's a property decorator (or maybe _any_ decorator).

---

_Referenced in [astral-sh/ruff#15582](../../astral-sh/ruff/pulls/15582.md) on 2025-01-19 01:14_

---

_Comment by @charliermarsh on 2025-01-19 18:40_

I assume I'm lacking understanding. Can `ExecuteWrapper` not use methods for this?

```python
    async def __aenter__(self):
        return await self._c.__aenter__()

    async def __aexit__(self, exc_type, exc_value, traceback):
        return await self._c.__aexit__(exc_type, exc_value, traceback)
```


---

_Comment by @InSyncWithFoo on 2025-01-19 20:22_

@charliermarsh That would require duplicating type hints for the parameters. The return type might not be necessary (Pyright can infer that flawlessly), but the same cannot be said about parameter types.


---

_Comment by @mikeshardmind on 2025-01-19 20:40_

Using properties here has multiple benefits, from better automatic type inference to better runtime behavior. With using methods, this would be multiple awaits for a simple wrapper or require `self._c.__aexit__(exc_type, exc_value, traceback).__await__()` which is  harder for human reviewer to reason about. Perhaps that's not the strongest argument given the existing use of similar there to define `__await__` in this particular case, but in general I try to avoid writing simple coroutines that only await other coroutines with pass-through.

---

_Comment by @mikeshardmind on 2025-01-24 19:25_

This might be better to hold off on for now, there are enough static analysis tools that are getting subtle things wrong about dunder methods as descriptors beyond what is visible here that it may still be beneficial to nudge people to slightly different solutions even at a small runtime or legibility cost to ensure their tooling has the expected benefits.

---
