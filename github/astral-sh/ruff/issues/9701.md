---
number: 9701
title: "Formatter: Doesn't format module docstrings"
type: issue
state: closed
author: MichaReiser
labels:
  - bug
  - good first issue
  - formatter
  - help wanted
assignees: []
created_at: 2024-01-30T13:37:17Z
updated_at: 2024-02-05T15:03:36Z
url: https://github.com/astral-sh/ruff/issues/9701
synced_at: 2026-01-07T12:31:13-06:00
---

# Formatter: Doesn't format module docstrings

---

_Issue opened by @MichaReiser on 2024-01-30 13:37_

The formatter doesn't format the module's docstring.

See this example taken from the bokeh project [playground](https://play.ruff.rs/6c27cb3d-b10a-42c4-b16d-e5e2f2b0d77b)

The code block of the module level docstring doesn't get formatted, but gets formatted just fine if it is a function-level docstring

```python
""" Represent granular events that can be used to trigger callbacks.

Bokeh documents and applications are capable of supporting various kinds of
interactions. These are often associated with events, such as mouse or touch
events, interactive downsampling mode activation, widget or tool events, and
others. The classes in this module represent these different events, so that
callbacks can be attached and executed when they occur.

It is possible to respond to events with ``CustomJS`` callbacks, which will
function with or without a Bokeh server. This can be accomplished by passing
and event class, and a ``CustomJS`` model to the
:func:`~bokeh.model.Model.js_on_event` method. When the ``CustomJS`` is
executed in the browser, its ``cb_obj`` argument will contain the concrete
event object that triggered the callback.

.. code-block:: python

    from bokeh.events import ButtonClick
    from bokeh.models import Button, CustomJS

    button = Button(                 )

    button.js_on_event(ButtonClick, CustomJS(
        
        
        code='console.log("JS:Click")'))

Alternatively it is possible to trigger Python code to run when events
happen, in the context of a Bokeh application running on a Bokeh server.
This can accomplished by passing an event class, and a callback function
to the the :func:`~bokeh.model.Model.on_event` method. The callback should
accept a single argument ``event``, which will be passed the concrete
event object that triggered the callback.

.. code-block:: python

    from bokeh.events import ButtonClick
    from bokeh.models import Button

    button = Button()

    def callback(event         ):
        print('Python:Click')

    button.on_event(ButtonClick, callback)

.. note ::
    There is no throttling of events. Some events such as ``MouseMove``
    may trigger at a very high rate.

"""

def function():
    """ Represent granular events that can be used to trigger callbacks.

Bokeh documents and applications are capable of supporting various kinds of
interactions. These are often associated with events, such as mouse or touch
events, interactive downsampling mode activation, widget or tool events, and
others. The classes in this module represent these different events, so that
callbacks can be attached and executed when they occur.

It is possible to respond to events with ``CustomJS`` callbacks, which will
function with or without a Bokeh server. This can be accomplished by passing
and event class, and a ``CustomJS`` model to the
:func:`~bokeh.model.Model.js_on_event` method. When the ``CustomJS`` is
executed in the browser, its ``cb_obj`` argument will contain the concrete
event object that triggered the callback.

.. code-block:: python

    from bokeh.events import ButtonClick
    from bokeh.models import Button, CustomJS

    button = Button(                 )

    button.js_on_event(ButtonClick, CustomJS(
        
        
        code='console.log("JS:Click")'))

Alternatively it is possible to trigger Python code to run when events
happen, in the context of a Bokeh application running on a Bokeh server.
This can accomplished by passing an event class, and a callback function
to the the :func:`~bokeh.model.Model.on_event` method. The callback should
accept a single argument ``event``, which will be passed the concrete
event object that triggered the callback.

.. code-block:: python

    from bokeh.events import ButtonClick
    from bokeh.models import Button

    button = Button()

    def callback(event         ):
        print('Python:Click')

    button.on_event(ButtonClick, callback)

.. note ::
    There is no throttling of events. Some events such as ``MouseMove``
    may trigger at a very high rate.

"""
```

---

_Label `bug` added by @MichaReiser on 2024-01-30 13:37_

---

_Label `formatter` added by @MichaReiser on 2024-01-30 13:37_

---

_Label `good first issue` added by @MichaReiser on 2024-01-30 13:37_

---

_Label `help wanted` added by @MichaReiser on 2024-01-30 13:37_

---

_Added to milestone `Formatter: Stable` by @MichaReiser on 2024-01-30 13:37_

---

_Comment by @Glyphack on 2024-01-30 17:46_

I'll try to tackle this. Just writing to avoid double work. ðŸ˜ƒ 

---

_Comment by @charliermarsh on 2024-01-30 17:49_

Awesome :)

---

_Comment by @MichaReiser on 2024-01-30 19:54_

@Glyphack awesome! The formatting of statements happens in `suite.rs`. There's already logic to format class and function docstrings, but it doesn't yet kick in at the top level. Let me know if you want more pointers.

---

_Comment by @Glyphack on 2024-01-30 20:15_

I found that the stringaLiteralKind is not set correctly. I'm planning to add a function to see if a node is first statement and then set the doc string kind for string literal. Will open the pr shortly. Thanks for your help.

---

_Comment by @MichaReiser on 2024-01-30 21:14_

There's already logic in suite.rs that tests if it's the first statement. I'm not at my computer so sharing the source is a bit difficult but search for the place where we identify docstrings for classes and functions 

---

_Referenced in [astral-sh/ruff#9725](../../astral-sh/ruff/pulls/9725.md) on 2024-01-30 22:56_

---

_Closed by @MichaReiser on 2024-02-05 15:03_

---
