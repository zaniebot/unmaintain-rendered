---
number: 5871
title: Detecting Any in generic types and variables
type: issue
state: open
author: ItsDrike
labels:
  - rule
  - typing
assignees: []
created_at: 2023-07-18T20:38:47Z
updated_at: 2024-07-29T08:41:45Z
url: https://github.com/astral-sh/ruff/issues/5871
synced_at: 2026-01-07T12:31:12-06:00
---

# Detecting Any in generic types and variables

---

_Issue opened by @ItsDrike on 2023-07-18 20:38_

This is a continuation from issue #5803, which assumed the lack of support for this is a bug, which it was not, making it a feature request.

The proposal here is that currently, the `flake8-annotations` rules only detect the `Any` type when used in function arguments, or their return types directly. I think it would be beneficial to also add new linter rules (or extend the existing ANN401, however that would make it different from the original handling in `flake8-annotations`).

Here's a recap of the issue:

### `Any` in generic arguments

```python
from typing import Any

def foo(x: dict[str, Any]) -> None:  # Should be an error
    ...
    
def bar() -> list[Any]:  # Should be an error
     ...
 ```
 
I think there is value in having a linter rule capable of finding use of `Any` in these kinds of nested type definitions too. Even though they are a much more precise than just pure `Any`, there is still a lot of ambiguity being introduced there, and there's no good reason for it.

If a function can really accept any kind of values, it should use `object` in the annotation, not `Any`. As an example: `Mapping[str, object]` would be a much better option than `Mapping[str, Any]`, because the type checker would later not allow you to blindly access any variable or name from that any type, while still allowing any kinds of objects in.

### `Any` in variable annotations

```python
from typing import Any, ClassVar

x: Any = 5  # Should be an error

class Foo:
    X: ClassVar[Any] = 10  # Should be an error
    Y: Any = 50  # Should be an error
```

There is no reason to only disallow the use of `Any` in functions, but not in variables. It brings in just as much type ambiguity as in functions.

---

_Comment by @ItsDrike on 2023-07-18 20:38_

Following [remarks brought up by @zanieb in the original issue]( https://github.com/astral-sh/ruff/issues/5803#issuecomment-1640820274), I decided to provide an answer here, and leave the original issue  just for addressing the incorrect (bug) behavior of ANN401.

> Regarding generic arguments, `dict[str, Any]` is fairly common in my experience. Anytime you're working with `kwargs` (outside of the definition itself) e.g.
>```python
>from typing import reveal_type
>
>def foo(**kwargs):
>   reveal_type(kwargs)  # dict[str, Any]
>```
>
>It seems better to use a generic that's partially complete than not at all. It would probably be reasonable to allow people to opt-in to enforcing narrower types though. I see a less controversial diagnostic for cases like list[Any] (either write list or narrow the generic) where all of the generic arguments are Any.

This example wouldn't be allowed by `flake8-annotations` anyway (at least not without disabling [`ANN003`](https://beta.ruff.rs/docs/rules/missing-type-kwargs/)). When a type is specified here, kwargs would be a concrete type.

![image](https://github.com/astral-sh/ruff/assets/20902250/bea977f5-6cdf-45db-aa48-8cf4327c70d6)

If you really need to take in the arguments with the any type, like say because you're later passing the kwargs to another function, you'd need to use `**kwargs: Any` in the type-hint directly anyway, which would then be breaking `ANN401`, so you'd need a noqa there anyway.

However I wouldn't say this comes up that often, as in decorators, you should generally use a ParamSpec, and annotated kwargs with `P.kwargs`, and there isn't that many other places where you'd want to pass over kwargs like this, because it'd be losing information. You should make a TypedDict and annotate the kwargs with that if you want to allow some specific kwargs (say from another function).

If you're creating the dict yourself, you could consider `Mapping[str, object]` annotation instead, which would then be passable into a function expecting `**kwargs: Any` , and won't let you use any custom methods and naively hope that they exist for the values. So the actual `dict[str, Any]` annotation wouldn't be needed here.

The problem with having `Any` in a generic attribute of some concrete type is that it can very quickly become an `Any` that is in one of your variables (from `dict[str, Any]`, iterating over values would mean those values are `Any` types).

So I'd say there is value in at least reconsidering whether it really wouldn't make sense to make this a default rule, rather than an opt-in one. But it is true that it could be annoying to create typed dicts everywhere you'd need this, and people do use `dict[str, Any]` a fair bit (even though in many cases they really don't need to), so I will completely understand making this an opt-in.

---

_Label `rule` added by @dhruvmanila on 2023-07-19 01:07_

---

_Label `typing` added by @dhruvmanila on 2023-07-19 01:07_

---

_Referenced in [astral-sh/ruff#5803](../../astral-sh/ruff/issues/5803.md) on 2023-07-31 09:45_

---

_Referenced in [py-mine/mcstatus#590](../../py-mine/mcstatus/pulls/590.md) on 2023-07-31 09:57_

---

_Comment by @mrcljx on 2024-07-29 08:41_

This rule sounds similar to https://typescript-eslint.io/rules/no-explicit-any/ and also assumed `ANN401` (aka `any-type`) would work this way.

> The `any` type in TypeScript is a dangerous "escape hatch" from the type system. Using `any` disables many type checking rules and is generally best used only as a last resort or when prototyping code. This rule reports on explicit uses of the `any` keyword as a type annotation.
> 
> Preferable alternatives to any include:
>
> - If the `type` is known, describing it in an `interface` or `type`
> - If the `type` is not known, using the safer `unknown` type

I would really love if it existed for Ruff, because it's so easy to _accidentally_ use `Any`: sometimes the brain thinks "any object" and instead of using `object` (Python's obscure variant to TS' `unknown`) one writes `Any` without realizing the implicatons.

I was contemplating banning import of `typing.Any` completely but:

1. managing `noqa` (for the rare case where it might actually be fine) often is frustrating,
2. once ignored there, would allow free-use throughout the file,
3. doesn't allow adding easy file-based exception in `ruff.toml` (for test suites).

It would save me lot code reviews comment writing if Ruff could **always** call out `list[Any]` and `dict[str, Any]` and don't need this to be _perfect_ (i.e. handling aliases or other things Ruff might not be able to determine because it doesn't type check).

---
