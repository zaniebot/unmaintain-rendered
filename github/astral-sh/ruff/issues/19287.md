---
number: 19287
title: "[pyupgrade] - UP046 incorrectly erroring for constrained TypeVars being used"
type: issue
state: closed
author: cgearing
labels:
  - question
assignees: []
created_at: 2025-07-11T15:49:56Z
updated_at: 2025-07-24T11:59:26Z
url: https://github.com/astral-sh/ruff/issues/19287
synced_at: 2026-01-07T12:31:13-06:00
---

# [pyupgrade] - UP046 incorrectly erroring for constrained TypeVars being used

---

_Issue opened by @cgearing on 2025-07-11 15:49_

### Summary

Hi, thanks for your hard work on Ruff!

We recently upgraded to the latest version and have been working through the errors generated relating to pyupgrade and the new `type` expression syntax, however we are seeing some tricky behaviour that we think might need looking at.

MRE below:
```python
from typing import Generic, TypeVar


class One: ...


class Two: ...


EitherT = TypeVar("EitherT", One, Two)


class Test(Generic[EitherT]):...

```
Running `ruff check --select=UP` on this will give the following error:

```bash
min.py:13:12: UP046 Generic class `Test` uses `Generic` subclass instead of type parameters
   |
13 | class Test(Generic[EitherT]):...
   |            ^^^^^^^^^^^^^^^^ UP046
   |
   = help: Use type parameters
```

However, TypeVars don't seem to be valid to be used in the new syntax, nor can you create reusable constrained type definitions using the new `type` expression, you would have to do the below:

```python

from typing import TypeVar, Generic

class One: ...

class Two: ...

class Test[T: (One, Two)]: ...
```

Is it intended that this error should just be ignored wherever a constrained TypeVar needs to be used across multiple sites?  

### Version

ruff 0.12.2

---

_Comment by @ntBre on 2025-07-11 19:02_

Thanks for the kind words!

@AlexWaygood gave a really nice answer on a closely-related issue [here](https://github.com/astral-sh/ruff/issues/18894#issuecomment-2996595541) with an example for a reusable type alias with bounds, but I'm not sure it extends to constrained type variables, as you point out.

---

_Label `question` added by @ntBre on 2025-07-11 19:03_

---

_Comment by @MichaReiser on 2025-07-14 08:07_

I'm not very familiar with Python's type syntax and I'm sure I'm overlooking some subtle behavior but can't you use 

```py
class One: ...


class Two: ...


type OneOrTwo = One | Two


class Test[EitherT: OneOrTwo]: 
    def a(self, arg: EitherT): pass

    def b(self, arg: EitherT) -> EitherT: pass


test: Test[One] = Test()
test.a(One())
x = test.b(Two()) # errors

```

---

_Comment by @AlexWaygood on 2025-07-14 08:22_

@MichaReiser no â€” that would create a TypeVar with an upper bound rather than a value-constrained TypeVar unfortunately. https://docs.python.org/3/library/typing.html#typing.TypeVar gives some details on the differences in semantics between the two

---

_Comment by @cgearing on 2025-07-14 11:04_

@AlexWaygood would a PR adjusting the behaviour of UP046 to not error when countering a constrained `TypeVar` be a good approach?  It seems like an oversight in PEP695 that constrained types in the new syntax should be a literal tuple expression, but unless that changes it seems that there is a genuine use-case for keeping `class SomeClass(Generic[SomeConstrainedType])`.

I'd be happy to have a go if so!

---

_Comment by @AlexWaygood on 2025-07-14 16:45_

I agree that you can't switch from an old-style TypeVar with constraints to a PEP-695-style TypeVar with constraints without adding some degree of code duplication. That's a bit unfortunate.

However, as, PEP-695 [explains](https://peps.python.org/pep-0695/#points-of-confusion):

> The scoping rules for type variables are difficult to understand. Type variables are typically allocated within the global scope, but their semantic meaning is valid only when used within the context of a generic class, function, or type alias. A single runtime instance of a type variable may be reused in multiple generic contexts, and it has a different semantic meaning in each of these contexts. This PEP proposes to eliminate this source of confusion by declaring type parameters at a natural place within a class, function, or type alias declaration statement.

So you could really think of the whole concept of a "reusable TypeVar" as being deprecated, since it very often causes confusion. Even `typing.AnyStr` (which is also a constrained TypeVar, and is perhaps the most often used "reusable TypeVar") [is now deprecated](https://github.com/python/cpython/issues/105578). If you want to have clearly scoped TypeVars that use modern syntax, and you only support Python 3.12+, I think you should aim to use PEP-695 syntax wherever possible, even if it adds a bit of duplication to your code.

---

_Closed by @MichaReiser on 2025-07-24 11:59_

---
