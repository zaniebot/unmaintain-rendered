---
number: 15629
title: "new rule - function decorated with `@contextlib.contextmanager` that does not wrap its `yield` statement in a `try`/`finally` block"
type: issue
state: open
author: DetachHead
labels:
  - rule
  - accepted
assignees: []
created_at: 2025-01-21T05:20:39Z
updated_at: 2025-01-30T00:55:14Z
url: https://github.com/astral-sh/ruff/issues/15629
synced_at: 2026-01-07T12:31:13-06:00
---

# new rule - function decorated with `@contextlib.contextmanager` that does not wrap its `yield` statement in a `try`/`finally` block

---

_Issue opened by @DetachHead on 2025-01-21 05:20_

`contextlib.contextmanager` is dangerous because its `__exit__` won't get run if an exception is raised, which is rarely what you want:

```py
from contextlib import contextmanager

@contextmanager
def foo():
    print('starting')
    yield
    print('ending')

with foo():
    raise Exception
```

it would be nice if ruff had a rule to enforce `try`/`finally` on these types of context managers:

```py
from contextlib import contextmanager

@contextmanager
def foo():
    print('starting')
    try:
        yield
    finally:
        print('ending')
```

---

_Label `rule` added by @MichaReiser on 2025-01-21 07:32_

---

_Label `needs-decision` added by @MichaReiser on 2025-01-21 07:32_

---

_Comment by @AlexWaygood on 2025-01-21 13:32_

we would need to make sure to also support context managers that delegate to other context managers. E.g. the `g()` function definition is fine here:

```pycon
>>> from contextlib import contextmanager
>>> @contextmanager
... def f():
...     try:
...         print('hi')
...         yield
...     finally:
...         print('bye')
...         
>>> @contextmanager
... def g():
...     print('hiiiii')
...     with f():
...         yield
...         
>>> with g():
...     raise Exception
...     
hiiiii
hi
bye
Traceback (most recent call last):
  File "<python-input-3>", line 2, in <module>
    raise Exception
Exception
```

---

_Comment by @DetachHead on 2025-01-21 14:33_

isn't that still unsafe if you have anything after the `yield` statement in `g`?

```py
@contextmanager
def g():
    print("hiiiii")
    with f():
        yield
        print("byeee")  # doesn't run
    print("byeee2")  # neither does this
```

i guess the rule can just not report on context managers where `yield` is the last statement:

```py
@contextmanager
def g():
    print("hiiiii")
    with f():
        yield # no error
```

```py
@contextmanager
def f():
    print("hi")
    yield # no error
```
but the last example probably isn't very common

---

_Comment by @AlexWaygood on 2025-01-21 14:41_

> isn't that still unsafe if you have anything after the `yield` statement in `g`?

yes, fair point

> i guess the rule can just not report on context managers where `yield` is the last statement:

sure, that seems like a reasonable way to handle this.

---

Overall this seems like a reasonable rule to me, since you're right that this is easy to get wrong, and it's never _incorrect_ to put the `yield` inside a `try`/`finally` guard. Some might find it a little strict/noisy, since in some cases it isn't actually necessary to do the post-`yield` cleanup in the event that an exception is terminating the current scope's execution. But I do agree that it is strictly more correct to make sure that you always use `try`/`finally` in a `@contextmanager`-decorated function or method.

---

_Label `needs-decision` removed by @AlexWaygood on 2025-01-21 14:41_

---

_Label `accepted` added by @AlexWaygood on 2025-01-21 14:41_

---

_Comment by @MichaReiser on 2025-01-21 15:00_

Should we wait until after rule categorization with adding this rule, considering that it is rather noisy/strict.

---

_Comment by @mishamsk on 2025-01-29 23:15_

I'd take a stab at this one if/when you confirm it should be taken.

PS. very helpful rule for pytest fixtures that ensures no side-effects. Been bitten more than once due to the lack of try-finally

---
