---
number: 20553
title: inconsistent first-party/third-party auto-resolution for non-permanent files (rule I001)
type: issue
state: closed
author: jsurany
labels:
  - question
  - isort
assignees: []
created_at: 2025-09-24T16:41:38Z
updated_at: 2025-09-26T05:40:20Z
url: https://github.com/astral-sh/ruff/issues/20553
synced_at: 2026-01-07T13:12:16-06:00
---

# inconsistent first-party/third-party auto-resolution for non-permanent files (rule I001)

---

_Issue opened by @jsurany on 2025-09-24 16:41_

### Summary

We have a workflow that generates ephemeral files in-source that are used only for type-checking and are not checked in to source control or used by python at runtime. An example project may look something like -

```
project
├── pyproject.toml
├── src
    └── foo
        ├── __init__.py
        ├── bar_types.xsd  # some schema
        └── bar_types.py   # ephemeral, auto-generated by plugin from the schema
└── tests
    └── test_foo.py
```

We have a build plugin that generates a type stubs (all `TypeDict`s) file in-source (for editable installs). This generated file is used by other files like -

```python
# __init__.py

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from baz import monte  # some third party module

    from foo.bar_types import BarType

def do_something() -> BarType:
    ...
```

```python
# test_foo.py

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from baz import monte  # some third party module

    from foo.bar_types import BarType

def test_something() -> None:
    bar_type: BarType = {...}
    ...
```

If I don't explicitly tell ruff that `foo` is a first party package, rule I001 behaves differently between `__init__.py` and `test_foo.py` modules when the generated type stubs file does not exist in the source tree. For `__init__.py`, the module is considered first-party and the sorting order is perserved. For `test_foo.py`, the module is instead considered third-party, and ruff wants to make the following change -

```python
# test_foo.py

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from baz import monte  # some third party module
    from foo.bar_types import BarType  # also considered a third-party module

def test_something() -> None:
    bar_type: BarType = {...}
    ...
```

When `foo` is explicitly specified as a first party package, ruff does not want to make the above change.

My preference when resolving this issue would be that the ephemeral file is considered a first-party module even if it doesn't exist, for both src and tests files. It seems to be consistent with how explicit first party resolution seems to work.

### Version

0.13.0

---

_Comment by @MichaReiser on 2025-09-24 17:31_

CC: @dylwil3 

---

_Label `isort` added by @MichaReiser on 2025-09-24 17:31_

---

_Label `question` added by @MichaReiser on 2025-09-24 17:31_

---

_Comment by @dylwil3 on 2025-09-25 16:44_

Thanks for your description and question!

I'm not sure I fully understand the details of your workflow, but I think the short answer is: This is a situation where one probably has to use the configuration option [known-first-party](https://docs.astral.sh/ruff/settings/#lint_isort_known-first-party).

But let me try to respond more directly in case that is helpful as well.

> We have a workflow that generates ephemeral files in-source that are used only for type-checking and are not checked in to source control or used by python at runtime.

This could cause import sorting to differ locally and in CI since Ruff analyzes the directory structure to determine whether imports are first or third party.

> rule I001 behaves differently between __init__.py and test_foo.py modules when the generated type stubs file does not exist in the source tree.

Unless I'm misunderstanding there are actually two different things happening here. First, there is the question of whether a file exists or not, which would certainly affect what Ruff thinks is first or third party. Second, there is the question of whether a (non-relative) import in `__init__.py` might be classified differently than _the same import_ in `test_foo.py`. That _should not_ be happening and I would consider it a bug. 

But in your example you don't have the same import in both files - in `__init__.py` you have `from foo.bar_types import BarType` and in `test_foo.py` you have `from foo.bar.types import BarType`. I would expect that, given the directory structure you laid out in the beginning, the second import would be classified as third party whether it appears in `__init__.py` or in `test_foo.py`, because the `bar` subdirectory does not exist.

> My preference when resolving this issue would be that the ephemeral file is considered a first-party module even if it doesn't exist, for both src and tests files.

Unfortunately there's no way for Ruff to infer that such a non-existent file "ought" to exist without the user specifying this in the form of the configuration `known-first-party`. And again - the behavior should not differ between `src` and `test` files here, as long as we are comparing apples to apples and use the same import statement.

Hopefully this is helpful, but let me know if there's something I'm misunderstanding or anything additional that needs clarification.

---

_Comment by @jsurany on 2025-09-25 18:03_

Thank you for the response, it was very helpful - I know this is a bit of a weird use-case.

> Second, there is the question of whether a (non-relative) import in __init__.py might be classified differently than the same import in test_foo.py. That _should not_ be happening and I would consider it a bug.

You hit the nail on the head - the import (possibly) being classified differently between in-source files and test files is exactly what I'm trying to highlight with this issue. Whatever solution for this issue ends up being implemented, I'll fix my broken CI if needed.

> But in your example you don't have the same import in both files - in __init__.py you have from foo.bar_types import BarType and in test_foo.py you have from foo.bar.types import BarType.

Sorry, this was my mistake when I was imagining a project where this issue would happen. I've edited my original comment to have the correct import path in the `test_foo.py` file examples.

> Unfortunately there's no way for Ruff to infer that such a non-existent file "ought" to exist without the user specifying this in the form of the configuration known-first-party. And again - the behavior should not differ between src and test files here, as long as we are comparing apples to apples and use the same import statement.

Yeah as long as the behavior was made consistent I would be satisfied. In my original post, was just suggesting a potential path that would work better for me (my CI wouldn't be broken), but again I'll adapt to whatever solution is accepted.

Let me know if things are still confusing.

---

_Comment by @dylwil3 on 2025-09-25 18:54_

Thank you for clarifying! Let's ignore the non-existent file then and focus on consistency.

Here was my attempt to reproduce. When the file actually exists, you can see that both imports are categorized as the same (first party), but for different reasons.

(I've removed unnecessary debug logs for brevity)

```console
~/Documents/dev
❯ uv init --lib foo && cd foo
Initialized project `foo` at `/Users/dmbp/Documents/dev/foo`

foo on  main [?]
❯ echo "from foo.bar import baz" > src/foo/bar.py

foo on  main [?]
❯ mkdir tests

foo on  main [?]
❯ echo "from foo.bar import baz" > tests/test_foo.py

foo on  main [?]
❯ ruff check --no-cache --isolated --select I001 -v src/foo/bar.py
[2025-09-25][13:42:11][ruff_linter::rules::isort::categorize][DEBUG] Categorized 'foo.bar' as Known(FirstParty) (SamePackage)
All checks passed!

foo on  main [?]
❯ ruff check --no-cache --isolated --select I001 -v tests/test_foo.py
[2025-09-25][13:42:17][ruff_linter::rules::isort::categorize][DEBUG] Categorized 'foo.bar' as Known(FirstParty) (SourceMatch("/Users/dmbp/Documents/dev/foo/src"))
All checks passed!
```

So if the file _doesn't_ exist, you will see different behavior as you mentioned.

If you set [`detect-same-package`](https://docs.astral.sh/ruff/settings/#lint_isort_detect-same-package) to `false` I think you get what you expected. In that case the classifications should be the same: they will both be first-party if the file actually exists, otherwise they will both be third party.

I wonder if it would make sense to change our default value of `detect-same-package` now that the detection of first-party imports is slightly more refined. (Before 0.13, in this example, the "source match" and "detect same package" would have accidentally agreed because Ruff was only searching for `foo` in your `src` directories for "source match", not `foo/bar`.)

Thanks for diving into this a bit further - I agree this is confusing!

---

_Comment by @jsurany on 2025-09-25 19:57_

ah I didn't know about that configuration, and yes it is doing as you said. I'm ok with closing this, unless you want to chase down making the defualt value of `detect-same-package` to `false` and make this issue the motivator.

---

_Closed by @MichaReiser on 2025-09-26 05:40_

---
