---
number: 8725
title: TCH002 false positive with pydantic subclassing
type: issue
state: closed
author: sorgfresser
labels:
  - type-inference
assignees: []
created_at: 2023-11-16T16:45:09Z
updated_at: 2024-10-24T14:34:11Z
url: https://github.com/astral-sh/ruff/issues/8725
synced_at: 2026-01-07T12:31:12-06:00
---

# TCH002 false positive with pydantic subclassing

---

_Issue opened by @sorgfresser on 2023-11-16 16:45_

<!--
Thank you for taking the time to report an issue! We're glad to have you involved with Ruff.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `ruff /path/to/file.py --fix`), ideally including the `--isolated` flag.
* The current Ruff settings (any relevant sections from your `pyproject.toml`).
* The current Ruff version (`ruff --version`).
-->
I am using ruff together with pydantic which works well most of the times, but here it does not seem to get it right.
So sometimes, if enough subclasses etc. are involved, it happens that ruff triggers a TCH002 on fields in a pydantic model - which is plain wrong as they have to be defined properly, not only in a type checking block.

As an example
```python
from __future__ import annotations

from abc import ABC, abstractmethod
from typing import ClassVar, Generic, TypeVar

from langchain.schema import BaseMessage
from pydantic import BaseModel, SerializeAsAny


class SuperFoo(BaseModel, ABC):
    """Base class foo."""

    @abstractmethod
    def value(self) -> int:
        """Return the value of foo."""


class ChildFoo(SuperFoo):
    """Subclass foo."""

    def value(self) -> int:
        """Return the value of foo."""
        return 0


_BT = TypeVar("_BT", bound=SuperFoo)


class _SuperBar(BaseModel, ABC, Generic[_BT]):
    something: SerializeAsAny[_BT]
    type_var: ClassVar[type[_BT]]


class ChildBar(_SuperBar[ChildFoo]):
    """Subclass bar."""

    type_var = ChildFoo
    where_it_breaks: list[BaseMessage]


if __name__ == "__main__":
    # Create ChildBar
    child = ChildBar(where_it_breaks=[], something=ChildFoo())
```

Run with `ruff <filename> --no-cache` and the following pyproject.toml config

```yaml
[tool.ruff]
target-version = 'py39'
line-length = 120
select = ['ALL']
ignore = [
    'ANN101', # don't type self
    'D100', 'D104', 'D203', 'D212', # limited docs
]

[tool.ruff.flake8-type-checking]
runtime-evaluated-base-classes = ["pydantic.BaseModel"]

[tool.ruff.pyupgrade]
keep-runtime-typing = true
```

raises an 
```python
TCH002 Move third-party import `langchain.schema.BaseMessage` into a type-checking block
```

I thought the `pydantic.BaseModel` as runtime-evaluated-base-class should fix it, but seemingly it does not.
I believe this can be considered a bug, but I might be missing something.

This happened with ruff version `0.1.5`

---

_Comment by @charliermarsh on 2023-11-16 18:01_

So we don't currently traverse the full class hierarchy, within a file or across files. So if you wanted `ChildBar` to be considered a runtime-evaluated class, you'd need to either add `BaseModel` as a _direct_ parent class, or add `_SuperBar` to the list of runtime-evaluated base classes. These are just limitations in Ruff's semantic model right now.

---

_Label `multifile-analysis` added by @charliermarsh on 2023-11-16 18:01_

---

_Comment by @charliermarsh on 2023-11-16 18:02_

I'm gonna merge this into https://github.com/astral-sh/ruff/issues/7893 -- thank you fro the clear write-up!

---

_Closed by @charliermarsh on 2023-11-16 18:02_

---

_Comment by @charliermarsh on 2023-11-16 18:03_

How much of the problem would it solve, for you, if we were able to support this for classes defined in the same file, like above? Or is that not-very-useless unless it also works for classes imported from other files?

---

_Comment by @sorgfresser on 2023-11-19 19:39_

Thanks a lot for the response!

Actually being aware of the incomplete parsing is already a huge benefit. It will most certainly not solve all of my problems, but parsing at least classes within the same file would be helpful - I think there is only one case I can think of where the same file would be insufficient for our codebase.

---

_Comment by @charliermarsh on 2023-11-19 20:12_

No worries! In the next release, this should work for subclasses within the same file -- I just fixed it today. Hopefully that helps!

---

_Label `type-inference` added by @MichaReiser on 2024-10-24 14:34_

---

_Label `multifile-analysis` removed by @MichaReiser on 2024-10-24 14:34_

---

_Referenced in [tablegpt/tablegpt-agent#10](../../tablegpt/tablegpt-agent/pulls/10.md) on 2024-10-28 06:12_

---

_Referenced in [apify/apify-sdk-python#326](../../apify/apify-sdk-python/pulls/326.md) on 2024-11-19 14:11_

---
