---
number: 19914
title: PYI016 treats distinct interpolations as duplicates
type: issue
state: open
author: dscorbett
labels:
  - bug
  - rule
assignees: []
created_at: 2025-08-14T12:29:11Z
updated_at: 2025-08-19T06:36:56Z
url: https://github.com/astral-sh/ruff/issues/19914
synced_at: 2026-01-07T12:31:13-06:00
---

# PYI016 treats distinct interpolations as duplicates

---

_Issue opened by @dscorbett on 2025-08-14 12:29_

### Summary

[`duplicate-union-member` (PYI016)](https://docs.astral.sh/ruff/rules/duplicate-union-member/) treats f-strings’ and t-strings’ interpolations as duplicates whose values are duplicates but whose expressions are not. This applies to f-strings’ interpolations with `=` and to all t-strings’ interpolations. Either the fix should be marked unsafe in this case, or the rule should be suppressed in this case. [Example](https://play.ruff.rs/a0f3f060-9cd0-451e-9842-6f68e63c28cb):
```console
$ cat >pyi016.py <<'# EOF'
from typing import Annotated, get_args, get_origin

f: Annotated[int, f"{00=}"] | Annotated[int, f"{000=}"] | None = None
print([get_args(a)[1] for a in get_args(__annotate__(1)["f"]) if get_origin(a) is Annotated])

t: Annotated[int, t"{00}"] | Annotated[int, t"{000}"] | None = None
print([get_args(a)[1].interpolations[0].expression for a in get_args(__annotate__(1)["t"]) if get_origin(a) is Annotated])
# EOF

$ python3.14 pyi016.py
['00=0', '000=0']
['00', '000']

$ ruff --isolated check pyi016.py --select PYI016 --target-version py314 --preview --fix
Found 2 errors (2 fixed, 0 remaining).

$ cat pyi016.py
from typing import Annotated, get_args, get_origin

f: Annotated[int, f"{0=}"] | None = None
print([get_args(a)[1] for a in get_args(__annotate__(1)["f"]) if get_origin(a) is Annotated])

t: Annotated[int, t"{0}"] | None = None
print([get_args(a)[1].interpolations[0].expression for a in get_args(__annotate__(1)["t"]) if get_origin(a) is Annotated])

$ python3.14 pyi016.py
['0=0']
['0']
```

### Version

ruff 0.12.8 (f51a228f0 2025-08-07)

---

_Label `bug` added by @ntBre on 2025-08-14 13:00_

---

_Label `rule` added by @ntBre on 2025-08-14 13:00_

---

_Comment by @MichaReiser on 2025-08-18 15:32_

CC: @dylwil3 

---

_Comment by @dylwil3 on 2025-08-18 18:49_

Both of these behaviors stem from our implementation of `ComparableExpr` which provides a coarser equivalence relation on expression AST nodes. I think it makes sense to make the comparable version of f-strings sensitive to the presence of the `=` / self-documenting expression specifier, since a user would explicitly put this in an f-string expression to modify its actual value as a string.

However, I'm not convinced we should do the same for template strings. While it is technically true that one can access the literal source text of an interpolation expression, this is intended for debugging/introspection purposes - it is an optional field and is only automatically populated by a non-empty string if you construct a t-string as a literal. (I can't really justify this beyond a philosophical point since `string.templatelib.Template` does not implement `__eq__`). Although it is not disallowed, I believe the intention is that any consumer of a template string should be processing it in such a way that only the value (or perhaps the AST?) of the expression is relevant.

---

_Comment by @MichaReiser on 2025-08-19 06:31_

>  Although it is not disallowed, I believe the intention is that any consumer of a template string should be processing it in such a way that only the value (or perhaps the AST?) of the expression is relevant

My understanding from the discussion on discuss python was that whitespace in a debug expression isn't semantically meaningful and tools are free to change the expression's whitespace (e.g. a formatter). 

I otherwise think that comparing t-strings should account for the debug expression (or we need to make `ComparableExpr` parametrizable because the right behavior might differ from rule to rule)

---
