---
number: 1546
title: "Unify terminology: error vs. check vs. rule"
type: issue
state: closed
author: not-my-profile
labels:
  - core
assignees: []
created_at: 2023-01-02T05:59:13Z
updated_at: 2023-01-10T06:48:46Z
url: https://github.com/astral-sh/ruff/issues/1546
synced_at: 2026-01-07T12:31:12-06:00
---

# Unify terminology: error vs. check vs. rule

---

_Issue opened by @not-my-profile on 2023-01-02 05:59_

The documentation currently uses all of them switching between them at random. For example in the `--help`:

* `--select`: Comma-separated list of **error** codes to enable (or ALL, to enable all **checks**)
* `--exclude` List of paths, used to exclude files and/or directories from **checks**
* `--explain` Explain a **rule**

The README also contains "lint rule" thrice, "lint check" once, "check code prefix" 7 times and "error code prefix" once.

It would be better to use consistent terminology to avoid confusing the user.

Prior art:

Linter | Term used
--|--
clippy | lint(s)
ESLint | rule(s)
pyflakes | check(s) (but not used often)
pycodestyle | check(s) & error code(s)
pydocstyle | error(s) & error code(s)

Some thoughts:

* If rules can be both errors or warnings as suggested in [#1256](https://www.github.com/charliermarsh/ruff/issues/1256), then we probably want to discontinue any uses of the term "error code".
* Ruff is a linter so lint(s) might be the most obvious choice semantically, however users are less likely to be familiar with the noun "lint" than with a more common noun like "rule" or "check".
* Some lint(s) perform several checks or enforce several rules. For example TID251 checks both import statements as well as attribute access, T100 checks for several imports, etc. With that in mind "lint(s)" might make the most sense.
* While it is not strictly necessary that our UI lingo matches the lingo we use within the codebase, I think for the sake of consistency and seamless onboarding of contributors we should aim for consistent terminology throughout the project (CLI, API, documentation). I do consider the consistency of the user-facing terminology to be most important.

---

_Referenced in [astral-sh/ruff#1547](../../astral-sh/ruff/issues/1547.md) on 2023-01-02 07:41_

---

_Comment by @charliermarsh on 2023-01-02 17:48_

Yes, good idea.

My thoughts:

- For the reasons you describe, I also dislike "error" or "error code".
- We probably need two terms: one for the abstract rule (like "lines are too long"), and one for a rule that has been triggered. For example, we could have "rule" and "violation" (in the code, this is basically `CheckKind` and `Check`).
- We also need terms for what are currently called "check code" and "check code prefix".

I think my preference is "rule" and "violation" (which could be more specifically broken down into errors and warnings, both of which are kinds of violations).


---

_Label `core` added by @charliermarsh on 2023-01-02 18:41_

---

_Comment by @charliermarsh on 2023-01-04 16:03_

@andersk - Sorry to ping and please feel free to ignore if uninterested but you tend to have good and thoughtful opinions on this kind of stuff. Any preferences on the stabilization of this nomenclature?

---

_Comment by @charliermarsh on 2023-01-04 20:58_

When we change this, we should also change the internal convention that "plugin" refers to any function that takes a `Checker` and adds a rule, where "check" refers to a pure function that returns a `Check`. It's super confusing.

---

_Comment by @andersk on 2023-01-05 05:31_

Perhaps â€œdiagnosticâ€ might be less unfamiliar than â€œlintâ€ and less judgmental than â€œerrorâ€ or â€œviolationâ€? Some other possibilities that came to mind are â€œdefectâ€ and â€œissueâ€.

I recently noticed the [SARIF specification](https://www.oasis-open.org/committees/sarif/), which seems to have â€œrulesâ€ and â€œresultsâ€, but thatâ€™s pretty generic.

I guess the â€œpluginâ€ terminology was inherited from Flake8, but yeah, itâ€™s not going to make much sense in the future when Ruff takes over the world to the point where people stop writing Flake8 plugins for us to clone and start contributing directly to Ruff. Usually â€œpluginsâ€ are things that can be separately installed and added at runtime (maybe weâ€™ll have that in the future?).

---

_Comment by @charliermarsh on 2023-01-05 05:35_

â€œWhen Ruff takes over the worldâ€ made my day ðŸ˜„ 

---

_Comment by @not-my-profile on 2023-01-06 23:41_

I like your suggestion of rule & violation since these words are commonly understood and the relationship between these concepts is clear: when you violate a rule you have a violation. Fun sidenote: Google claims to have >600k results for "violate a rule" but only 3 results for "violate a lint".

I don't really see the point of grouping rule implementations by their function signatures into files like `checks.rs` and `plugins.rs` ... I think it would make more sense to have one `.rs` file per rule, which would contain the function implementing the rule (no matter if it takes a Checker or returns a Check) and would also contain the definition of the new violation struct & `Violation` implementation (see #1685). Especially because the idea is to document the rules as docstrings on the structs, so it would be nice to have everything important for a rule (implementation, struct, struct impl and documentation) in one file.

---

_Comment by @charliermarsh on 2023-01-06 23:50_

Yeah let's run with "rule" and "violation", I think.

I don't feel strongly about grouping by signature. I more like that there's some nomenclature that indicates whether the function is pure or mutates the checker. We could even have a `_mut` suffix or something. It's not a hard requirement for me though.


---

_Referenced in [astral-sh/ruff#1685](../../astral-sh/ruff/pulls/1685.md) on 2023-01-07 00:35_

---

_Comment by @not-my-profile on 2023-01-07 06:42_

We need a better name for the `Check` struct:

```rust
pub struct Check {
    pub kind: CheckKind,
    pub location: Location,
    pub end_location: Location,
    pub fix: Option<Fix>,
    pub parent: Option<Location>,
}
```

After #1685 each variant of the `CheckKind` enum will contain structs implementing the `Violation` trait, so `kind` should probably be renamed to `violation` ...

We notably cannot name `Check` violation as well since that we want both the now-called Check struct and the new trait to be usable in the same module without having to rename them. I am starting to think `Diag` (short for diagnostic) would be a good name for the `Check` struct.

So the idea would be: a Diagnostic consists of a Violation, the context where the violation occured and optionally a suggested Fix.


---

_Comment by @not-my-profile on 2023-01-07 07:06_

Haha I guess I might just as well use this issue as a general place to raise terminology issues:

I don't think what we currently call "category" should be called category. IMO pyflakes, pycodestyle, isort, etc. aren't categories ... they are origins (answering the question "where does the lint originate from?"). I think a much better use for the term "category" is [what clippy calls categories](https://github.com/rust-lang/rust-clippy#clippy), namely categories such as all, correctness, suspicious, style, complexity, perf, pedantic or nursery.

---

_Comment by @charliermarsh on 2023-01-07 16:29_

Does `CheckKind` then become `ViolationKind`? Or `DiagnosticViolation`?

E.g.:

```rs
pub struct Diagnostic {
    pub violation: DiagnosticViolation,
    pub location: Location,
    pub end_location: Location,
    pub fix: Option<Fix>,
    pub parent: Option<Location>,
}
```

Is that right?

---

_Comment by @charliermarsh on 2023-01-07 16:33_

(The last struct to consider here is `Message`, which maybe we just leave as-is for now. )

---

_Comment by @not-my-profile on 2023-01-07 16:57_

> Does CheckKind then become ViolationKind? Or DiagnosticViolation?

I think either would work. I don't think the exact naming of the enum matters much since it should actually only occur very seldomly in code (because the `Check::new` or `Diagnostic::new` calls `into()`).

What's the difference between `Message` and the current `Check`? They look very similar.

---

_Comment by @charliermarsh on 2023-01-07 17:40_

They're very similar. They exist because `Check` is generated in a single-file context. `Message` then adds the filename to `Check` (and extracts the source, if the user has that setting enabled).

---

_Comment by @charliermarsh on 2023-01-07 20:21_

@not-my-profile - For now, if you start work on any of the TODOs from #1685, can you file a new issue, and I'll assign you? (Or just comment here if you prefer -- either is fine.)


---

_Comment by @charliermarsh on 2023-01-10 02:11_

This has been improved enough that I'm gonna go ahead and close out for now (as of https://github.com/charliermarsh/ruff/pull/1760).

---

_Closed by @charliermarsh on 2023-01-10 02:11_

---

_Comment by @charliermarsh on 2023-01-10 02:11_

Thanks to @not-my-profile for the push here and for a bunch of great work on the migration itself.

---

_Comment by @not-my-profile on 2023-01-10 06:48_

You're very welcome :) Thank you for being so supportive!

---

_Referenced in [astral-sh/ruff#2046](../../astral-sh/ruff/issues/2046.md) on 2023-01-21 01:07_

---
