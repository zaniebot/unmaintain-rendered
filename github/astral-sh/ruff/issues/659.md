---
number: 659
title: "Expose Ruff's public API as a Python library"
type: issue
state: open
author: charliermarsh
labels:
  - core
  - help wanted
assignees: []
created_at: 2022-11-08T14:36:51Z
updated_at: 2025-09-22T18:46:15Z
url: https://github.com/astral-sh/ruff/issues/659
synced_at: 2026-01-07T12:31:12-06:00
---

# Expose Ruff's public API as a Python library

---

_Issue opened by @charliermarsh on 2022-11-08 14:36_

See: #593

---

_Label `enhancement` added by @charliermarsh on 2022-11-08 14:36_

---

_Referenced in [astral-sh/ruff#593](../../astral-sh/ruff/issues/593.md) on 2022-11-09 05:45_

---

_Comment by @facundobatista on 2022-11-25 11:56_

This would mean that we could do something like the following, right?

```
import ruff
errors = ruff.check_files(list_of_paths)
...
```

Thanks!

---

_Comment by @charliermarsh on 2022-11-25 14:49_

Yup, that's right!

---

_Comment by @charliermarsh on 2022-11-25 14:50_

@messense - I wasn't certain on this last time -- if we bundle a Python API with Ruff, will we need to build separate wheels for every Python version?


---

_Comment by @messense on 2022-11-25 14:54_

If you can use [`abi3` features](https://pyo3.rs/v0.17.3/building_and_distribution.html#py_limited_apiabi3), one wheel per platform, otherwise you need to build separate wheels for every Python version.

---

_Comment by @charliermarsh on 2022-11-25 14:55_

Awesome thank you. I think we should be able to do that, so maybe this will be really straightforward.

---

_Comment by @provinzkraut on 2022-12-08 17:52_

Hello there, do you happen to have a rough timeline for when (if?) this is going to happen? I'm looking to integrate ruff into a tool I'm developing, which would require an API of some sort. It would be very helpful to know if this is something I can wait on, or look for another solution / workaround!

---

_Added to milestone `Release 0.1.0` by @charliermarsh on 2022-12-08 18:39_

---

_Comment by @charliermarsh on 2022-12-08 18:40_

@provinzkraut - It's definitely going to happen! I could probably ship it within the next week or so. I'd just been punting on it until I had more people asking for it.

Could I hear a bit more about your use-case, if you don't mind sharing?

---

_Comment by @provinzkraut on 2022-12-08 19:43_

@charliermarsh That's good to hear!

> Could I hear a bit more about your use-case, if you don't mind sharing?

Sure. I'm working on a markdown extension to automatically generate [pymdown tabs](https://facelessuser.github.io/pymdown-extensions/extensions/tabbed/) for different Python versions from a source version, i.e. generate 3.7, 3.8, 3.10 tabs from a 3.7 source ([repo](https://github.com/provinzkraut/AutoPyTabs)). 

Currently I'm using `pyupgrade` to generate the versions and `autoflake` to clean imports that have become superfluous. Especially `autoflake` is quite slow, making up a majority of the extensions runtime. Since ruff is way faster at this, I'd like to use it (also one less dependency). I fiddled around with using the CLI version, but that's messy and a performance degradation.

---

_Comment by @charliermarsh on 2022-12-09 04:12_

@provinzkraut - Ok, cool. Let me see what I can do. I don't know if you're comfortable reading Rust, but would the current [Rust public API](https://github.com/charliermarsh/ruff/blob/a0a6327faecdb9f0fed8c69f4c84947677a8577d/src/lib.rs#L85) suit your use-case, were it callable from Python with Python objects etc.?

---

_Comment by @charliermarsh on 2022-12-09 04:13_

In short: it takes a file path (to find the `pyproject.toml`), the raw Python source code, and an autofix setting, and returns a list of checks (which themselves include the raw fixes / patches).

I'm guessing that for your use-case, what you actually want is a function that takes source code (plus settings, to enable a list of checks) and returns fixed source code?

---

_Referenced in [python-lsp/python-lsp-ruff#1](../../python-lsp/python-lsp-ruff/pulls/1.md) on 2022-12-09 08:51_

---

_Comment by @provinzkraut on 2022-12-09 09:52_

> but would the current [Rust public API](https://github.com/charliermarsh/ruff/blob/a0a6327faecdb9f0fed8c69f4c84947677a8577d/src/lib.rs#L85) suit your use-case, were it callable from Python with Python objects etc.?

I looked at this yesterday because I though that maybe it could be as simple as adding a tiny wrapper around the rust lib myself, but it seems to be a bit more involved. The current API doesn't really lend itself that well to my usecase.

> I'm guessing that for your use-case, what you actually want is a function that takes source code (plus settings, to enable a list of checks) and returns fixed source code?

That would be ideal, yes. Dealing with a list of checks and extracting what I need from it also wouldn't be that big of an issue, but passing in configuration directly and omitting the config file is crucial, both for the needed configurability (I need to run the fixers with varying configuration for every invocation) and performance (I'm running the fixers many times on small snippets, which means the overhead of looking for and parsing a `pyproject.toml` every time adds up).

---

_Comment by @squiddy on 2022-12-27 14:16_

I'm working on this now.

---

_Referenced in [astral-sh/ruff#1407](../../astral-sh/ruff/pulls/1407.md) on 2022-12-27 16:04_

---

_Label `enhancement` removed by @charliermarsh on 2022-12-31 18:18_

---

_Label `core` added by @charliermarsh on 2022-12-31 18:18_

---

_Comment by @phillipuniverse on 2023-01-17 20:18_

I had a need to execute Ruff as an [Alembic post write hook](https://alembic.sqlalchemy.org/en/latest/autogenerate.html#writing-custom-hooks-as-python-functions). I came up with a very hamfisted approach that I found from the distributed `__main__.py`

<img width="940" alt="image" src="https://user-images.githubusercontent.com/684275/213002331-06311cab-dd24-471a-83ea-6cdc91aeb6d2.png">

`alembic.ini`:

```ini
[post_write_hooks]
# post_write_hooks defines scripts or Python functions that are run
# on newly generated revision scripts.  See the documentation for further
# detail and examples

# format using "black" - use the console_scripts runner, against the "black" entrypoint
hooks = ruff, black

ruff.type = ruff

black.type = console_scripts
black.entrypoint = black
```

and then Alembic's `env.py`:

```python
import os
import sysconfig
from alembic.script import write_hooks

@write_hooks.register("ruff")
def run_ruff(filename, options):
    ruff = os.path.join(sysconfig.get_path("scripts"), "ruff")
    os.spawnv(os.P_WAIT, ruff, [ruff, filename, "--fix", "--exit-zero"])
```

---

_Comment by @charliermarsh on 2023-01-17 20:30_

ðŸ‘ Yup that should be safe to do! (The downside being that you have to go through the CLI rather than calling a function directly. Hoping to enable that soon but not working on it right now.)

---

_Removed from milestone `Release 0.1.0` by @charliermarsh on 2023-02-03 18:28_

---

_Referenced in [astral-sh/ruff#2969](../../astral-sh/ruff/issues/2969.md) on 2023-02-16 20:14_

---

_Comment by @asmeurer on 2023-03-16 22:38_

Is the plan here to make a Python library that links to ruff directly? I want something that I can use in an interactive Python REPL to check for errors as the user types stuff, and shelling out to a subprocess on each character typed doesn't sound like a good idea (especially if I also have to write out the code to a tempfile or heredoc).

If you're curious, here's what I'm currently using with pyflakes https://github.com/asmeurer/mypython/blob/a836d0956a6443f7a85a032dc625ff3da1479a91/mypython/processors.py#L196. The code is complicated in part because pyflakes doesn't handle syntax errors very well, so I have to parse them separately. I haven't checked if ruff handles them better. There's lot of opportunities to improve over pyflakes' barebones Python API. 

The main thing I would want from a Ruff Python API is a function that takes a string of Python code and returns a list of errors with line number, start and stop column numbers (where relevant), and the error message. Being able to get corresponding fixes would be nice too, I guess. The best API I can think of for a "fix" would be to return the whole block of code with the specific warning fixed, along with a new line and column number corresponding to the line and column of the original warning (so that I can interactively keep the cursor in the "same" location).

I'm happy to discuss API ideas more in depth or test out any prototypes if you're interested.

---

_Comment by @MichaReiser on 2023-03-17 07:35_

That sounds cool!

> If you're curious, here's what I'm currently using with pyflakes [asmeurer/mypython@a836d09/mypython/processors.py#L196](https://github.com/asmeurer/mypython/blob/a836d0956a6443f7a85a032dc625ff3da1479a91/mypython/processors.py#L196). The code is complicated in part because pyflakes doesn't handle syntax errors very well, so I have to parse them separately. I haven't checked if ruff handles them better. There's lot of opportunities to improve over pyflakes' barebones Python API.

Ruff creates a diagnostic for files with syntax errors. Adopting a more error-resilient parser is something that we consider doing. 

> The main thing I would want from a Ruff Python API is a function that takes a string of Python code and returns a list of errors with line number, start and stop column numbers (where relevant), and the error message.

That sounds reasonable, but we aren't there yet (your best shot is to call into the CLI). One of the biggest problems of exposing a linter API right now is that Ruff writes one-off warnings to stdout and relies on the global state to track whether to write the warning. Cleaning this up probably requires a larger refactoring around the diagnostic system... so that may take a while. 

---

_Comment by @charliermarsh on 2023-03-17 22:04_

For what it's worth, we power `ruff-lsp` and the VS Code extension over subprocess, and the CLI actually supports enough behavior to power the operations needed there. For example, you can use `--format json` to get a structured list of violations and their fixes. Similarly, if you pass input via `stdin`, and run with `--fix`, we print the "fixed" output to `stdout`.

---

_Referenced in [pytorch/pytorch#99280](../../pytorch/pytorch/pulls/99280.md) on 2023-04-18 00:29_

---

_Comment by @provinzkraut on 2023-06-11 08:57_

> For what it's worth, we power ruff-lsp and the VS Code extension over subprocess, and the CLI actually supports enough behavior to power the operations needed there

How do you feel about adding a Python module that wraps this up in a convenient API?

I've been using the solution you suggested in a few of my tools now, and not having to implement that boilerplate every time would certainly be nice. 

If that sounds good to you, I'd be happy to contribute.


---

_Referenced in [asmeurer/removestar#51](../../asmeurer/removestar/issues/51.md) on 2023-09-22 02:24_

---

_Comment by @Zac-HD on 2023-10-15 20:40_

I'm keen to replace `autoflake`+`isort` with `ruff` in my `shed` all-in-one autoformatter - the subprocess trick works pretty well, _except_ that if there's any way to change the isort settings in ruff without a config file I can't see it - and running isolated from any config is pretty important in this use-case.  Any suggestions, or do I just need to wait for the library interface in this issue?

---

_Referenced in [astral-sh/ruff#8401](../../astral-sh/ruff/issues/8401.md) on 2023-11-01 09:51_

---

_Referenced in [astral-sh/ruff#8673](../../astral-sh/ruff/issues/8673.md) on 2023-11-14 19:58_

---

_Referenced in [deephaven/deephaven-core#3453](../../deephaven/deephaven-core/issues/3453.md) on 2023-12-15 21:05_

---

_Referenced in [NixOS/nixpkgs#280298](../../NixOS/nixpkgs/pulls/280298.md) on 2024-01-11 21:52_

---

_Comment by @pawamoy on 2024-02-22 13:27_

Adding a data point: in mkdocstrings-python we format function signatures with Black if it is installed. We would like to support Ruff to, but spawning a subprocess for each signature is very costly, so we would greatly appreciate a Python binding that doesn't use subprocesses :slightly_smiling_face: A wrapper that hides the subprocess calls sounds nice, but won't be enough for our use-case.

---

_Comment by @MichaReiser on 2024-02-22 13:46_

@pawamoy that sounds neat. We plan to integrate our LSP into ruff (implemented in Rust). I know, it's not as convenient as a Python API but it would allow you to format files without spawning a process for every signature (although it might still be very costly because it requires multiple LSP calls to format a single code snipped)

---

_Comment by @pawamoy on 2024-02-22 14:13_

By calls do you mean network calls? Or could we somehow spawn the LSP server locally (like a daemon)?

---

_Comment by @MichaReiser on 2024-02-22 14:27_

You would spawn the LSP like a daemon and communicate over stdin/stdout.

---

_Comment by @pawamoy on 2024-02-22 14:39_

Ah, interesting. Then yeah, that's already much better than subprocesses :slightly_smiling_face: Thanks for the info!

---

_Comment by @amyreese on 2024-02-22 17:10_

> Adding a data point: in mkdocstrings-python we format function signatures with Black if it is installed. We would like to support Ruff to, but spawning a subprocess for each signature is very costly, so we would greatly appreciate a Python binding that doesn't use subprocesses :slightly_smiling_face: A wrapper that hides the subprocess calls sounds nice, but won't be enough for our use-case.

I put together an experimental package that uses PyO3 to wrap the  Ruff formatter in a Python API that doesn't require any subprocesses. I'd still consider it alpha at best (there's only one callable function), but maybe it could be helpful to others as well?

https://github.com/amyreese/ruff-api

---

_Comment by @pawamoy on 2024-02-22 19:45_

Amazing, thanks for sharing! I'll check it out :)

---

_Comment by @Zac-HD on 2024-02-22 20:43_

@charliermarsh just checking in - is there any way to configure the `isort` settings in `--isolated` mode, or do I just have to wait?  No worries if so, I'm just looking forward to replacing `black` too...

---

_Comment by @AlexWaygood on 2024-02-22 21:03_

> @charliermarsh just checking in - is there any way to configure the `isort` settings in `--isolated` mode, or do I just have to wait? No worries if so, I'm just looking forward to replacing `black` too...

@Zac-HD, yes, there is! We recently extended the `--config` flag so that arbitrary configuration options can be overridden via the command line using "inline TOML": https://docs.astral.sh/ruff/configuration/#the-config-cli-flag. So to override the isort `extra-standard-library` setting in `--isolated` mode (for example), you'd do something like `ruff check path/to/file.py --config "lint.isort.extra-standard-library = ['path']"`.

---

_Referenced in [astral-sh/ruff#9720](../../astral-sh/ruff/issues/9720.md) on 2024-02-23 21:34_

---

_Comment by @mbelak-dtml on 2024-03-06 15:38_

Adding another data point:
In [edvart](https://github.com/datamole-ai/edvart/blob/8f63194d48bd707c3c2f43d42a87773c116b0181/edvart/report.py#L158), we are currently using `isort` to sort imports in Python code which is being dynamically.
With a Python API, we could fully switch to ruff. For now, we are using ruff to format the source code, but keeping `isort` to format the generated code.

---

_Comment by @jankatins on 2024-06-04 11:12_

Another data point: it would make it easier to replace programmatic calls to black, like in mdsformat-black: https://github.com/hukkin/mdformat-black/blob/master/mdformat_black/__init__.py

```py

def format_python(unformatted: str, _info_str: str) -> str:
    return black.format_str(unformatted, mode=black.Mode())
```

---

_Referenced in [adamchainz/blacken-docs#352](../../adamchainz/blacken-docs/issues/352.md) on 2024-07-01 21:35_

---

_Comment by @adamchainz on 2024-07-01 21:36_

Iâ€™d want to use an API like `black.format_str` over in `blacken-docs`, where Ruff support is tracked in this issue: https://github.com/adamchainz/blacken-docs/issues/352 

---

_Comment by @MichaReiser on 2024-07-17 06:37_

Not the most elegant solution and I haven't tried it myself, but it should soon be possible to call the ruff WASM API from Python:

* https://github.com/astral-sh/ruff/pull/12317
* https://github.com/wasmerio/wasmer-python

Considering that we have a WASM API now, I'm open to reconsidering a PyO3 API. Let me discuss this internally.

> Note: The API would not fall under any semver guarantees. We expect a major breaking change once we introduce multifile analysis. Practically, the API hasn't changed in months. 



---

_Comment by @MichaReiser on 2024-07-18 14:13_

I would be open to expose a Ruff Pyo3 API:

* Shipped as a separate python package (ruff-api?)
* Has the same or a very similar API as `ruff_wasm`
* The API itself isn't under semver. Breaking API changes are possible, even in patch releases (we don't feel comfortable committing to that yet). Otherwise, the same versioning policy as for Ruff applies
* The package should be released automatically as part of our release workflow. 

I'm happy to support if anyone's interested in contributing the API to ruff.

---

_Label `help wanted` added by @MichaReiser on 2024-07-18 14:14_

---

_Referenced in [ament/ament_lint#497](../../ament/ament_lint/issues/497.md) on 2024-07-25 14:14_

---

_Referenced in [fern-api/fern#4199](../../fern-api/fern/pulls/4199.md) on 2024-08-05 04:28_

---

_Referenced in [astral-sh/ruff#12687](../../astral-sh/ruff/issues/12687.md) on 2024-08-05 12:43_

---

_Referenced in [astral-sh/ruff#12793](../../astral-sh/ruff/issues/12793.md) on 2024-08-12 08:26_

---

_Comment by @maxschulz-COL on 2024-08-12 12:00_

Hey, just to add another data-point: we at [Vizro](https://github.com/mckinsey/vizro) would also love to be able to invoke `ruff` from within python without subprocess. Something like `black.format_str` indeed :) 

---

_Comment by @n8henrie on 2024-08-30 19:28_

Same here -- would love to replace `black.format_str` in automatically formatting jupyter cells with https://github.com/n8henrie/jupyter-black/ !

---

_Comment by @amyreese on 2024-08-30 22:31_

@maxschulz-COL @n8henrie @adamchainz I would like to remind folks that https://github.com/amyreese/ruff-api has a working, simple API wrapping both the formatter and import sorter from Ruff, just a `pip install ruff-api` away. We have been using it to successfully migrate from Black in our monorepo while still maintaining our existing integrations/tooling written in Python. :)

---

_Comment by @analog-cbarber on 2024-08-31 17:31_

That looks great, but it is also documented as "highly experimental", so people maybe reluctant to add that to their tool chains. Why don't you contribute that to the ruff project?

---

_Comment by @n8henrie on 2024-08-31 18:51_

Agreed -- it would be great to have this under ruff's umbrella!

---

_Referenced in [DemocracyClub/UK-Polling-Stations#8082](../../DemocracyClub/UK-Polling-Stations/pulls/8082.md) on 2024-09-26 08:22_

---

_Referenced in [astral-sh/ruff#13975](../../astral-sh/ruff/issues/13975.md) on 2024-10-29 04:04_

---

_Referenced in [astral-sh/ruff#14836](../../astral-sh/ruff/issues/14836.md) on 2024-12-08 13:43_

---

_Referenced in [mkdocstrings/python#216](../../mkdocstrings/python/pulls/216.md) on 2024-12-13 15:55_

---

_Comment by @scnerd on 2025-01-16 00:35_

Note that `ruff-api` above is also a great demonstration of how to use `ruff` API's from _rust_ code, in case you happen to be [managing Python strings in Rust](https://github.com/rearc/spl_transpiler/).

---

_Referenced in [astral-sh/ruff#18153](../../astral-sh/ruff/issues/18153.md) on 2025-05-18 15:27_

---

_Comment by @jorenham on 2025-05-20 16:38_

For what it's worth; here's an example of how you could `ruff format` a Python string using `subprocess`: https://gist.github.com/jorenham/63942278b01515ffdeb0c7d4d1895684

---

_Referenced in [Josverl/micropython-stubber#668](../../Josverl/micropython-stubber/issues/668.md) on 2025-05-20 18:33_

---

_Referenced in [astral-sh/ruff#18655](../../astral-sh/ruff/issues/18655.md) on 2025-06-13 06:20_

---

_Referenced in [Josverl/micropython-stubber#678](../../Josverl/micropython-stubber/pulls/678.md) on 2025-08-29 20:08_

---

_Comment by @GDYendell on 2025-09-06 17:11_

https://github.com/astral-sh/ruff/pull/1407 was closed because the public API was not considered stable enough. Is that still the case or would it be reasonable to try this again now?

---

_Comment by @ntBre on 2025-09-08 19:49_

I think the API not being considered stable enough is still accurate. Thanks for checking in.

---

_Comment by @MichaReiser on 2025-09-15 12:02_

@GDYendell feel free to open a discussion with a proposed API. I think a good start would be something like:

```python
def format(contents: &str, options: FormatOptions) -> str: ...

def lint(contents: &str, options: LintOptions) -> str: ...
```

The parts that are unclear to me:

* We should allow an optional file name for `lint`
* Should `format` throw if there's a syntax error or should the method return a `Result` like type
* How to expose diagnostics? Just use the JSON output or offer some basic formatting

---

_Comment by @kabouzeid on 2025-09-15 13:18_

I would expect format to throw.

Not sure about how to expose the lint API in general, as I don't know what use cases people have for this.

---

_Comment by @Freed-Wu on 2025-09-20 13:02_

Expect that ruff can provide a python binding for other python projects like [mdformat-ruff](https://github.com/Freed-Wu/mdformat-ruff).

---

_Comment by @amyreese on 2025-09-22 18:42_



> The parts that are unclear to me:
> 
>     * We should allow an optional file name for `lint`

FWIW, the API that I built in `ruff-api` looks similar to your example, but requires a filename for both `format` and `isort` for consistency. Without a filename, things like first-party import detection doesn't work, and I think it makes sense to design an API that has matching usage between variants, even if something like filename isn't necessarily "used" by the underlying  implementation. 

>     * Should `format` throw if there's a syntax error or should the method return a `Result` like type

I think a `Result` object would be better, and let that contain an `error` property with any exceptions like syntax error. That result object could contain diagnostics and resulting code after applying fixes/formatting, etc.

---

_Comment by @amyreese on 2025-09-22 18:45_

> For what it's worth; here's an example of how you could `ruff format` a Python string using `subprocess`: https://gist.github.com/jorenham/63942278b01515ffdeb0c7d4d1895684

I also built [`rufffmt`](https://pypi.org/project/rufffmt/) which will combine format+isort as a single CLI/API, and uses a similar approach for running via `subprocess`, but sometimes subprocess is not an option for various reasons, like running on in-memory strings.

---
