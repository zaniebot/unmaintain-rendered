---
number: 13933
title: "[red-knot] model that class/comprehension bodies run immediately"
type: issue
state: closed
author: carljm
labels:
  - ty
assignees: []
created_at: 2024-10-25T22:08:45Z
updated_at: 2025-02-19T22:58:12Z
url: https://github.com/astral-sh/ruff/issues/13933
synced_at: 2026-01-07T12:31:13-06:00
---

# [red-knot] model that class/comprehension bodies run immediately

---

_Issue opened by @carljm on 2024-10-25 22:08_

Currently, we have a general strategy for name lookups in enclosing scopes: they use the type as seen from end of the scope where it's defined. For example:

```
x = 1

def f():
    # This is correct for any call to `f` that would happen after this module has
    # fully executed. It could be wrong if `f` is called during execution of the
    # module body.
    reveal_type(x)  # revealed: Literal["foo"]

x = "foo"
```

For nested functions, this is a pretty reasonable default behavior.  Another option would be to consider _all_ definitions of `x` (or at least all definitions of `x` visible from the point where `f` is defined, forwards). This would result in revealing `Literal[1] | Literal["foo"]` for `x` in the inner scope of `f`, instead. This would be safer, but also more annoying for the more common case where `f` is not called from the module body. It would also mean we would always consider `x` possibly-undefined inside `f`, if `f` is defined before `x`, which could be really annoying.

We could try to be smarter by detecting, for example, that the function `f` is (or might be) called from module level, and only consider earlier definitions if we observe this possibility. But this will always be best-effort, since reliably detecting all possible paths (other functions, even possibly in other modules) through which `f` could be called from module level isn't feasible.

But there are cases where we can be quite sure that the nested scope will run before the end of the outer scope. For example, class definitions:

```
x = 1
class C:
    y = x
x = "foo"

# This is currently what we reveal, but it's clearly wrong: should be `Literal[1]`
reveal_type(C.y)  # revealed: Literal["foo"]
```

The class body always runs immediately, so it should resolve types in the enclosing scope from the class definition's point in control flow, not from end-of-scope.

---

_Label `red-knot` added by @carljm on 2024-10-25 22:08_

---

_Comment by @AlexWaygood on 2024-10-26 18:39_

Should we do the same for list/dict/set comprehensions? (Generators expressions obviously do not run immediately, unlike list/dict/set comprehensions.)

---

_Comment by @carljm on 2024-10-26 18:45_

Yes!

---

_Renamed from "[red-knot] model that class bodies run immediately" to "[red-knot] model that class/comprehension bodies run immediately" by @carljm on 2024-10-26 18:55_

---

_Added to milestone `Red Knot 2024` by @carljm on 2024-11-07 15:21_

---

_Referenced in [astral-sh/ruff#13879](../../astral-sh/ruff/issues/13879.md) on 2024-11-13 16:18_

---

_Assigned to @AlexWaygood by @carljm on 2024-11-14 17:37_

---

_Referenced in [astral-sh/ruff#14379](../../astral-sh/ruff/pulls/14379.md) on 2024-11-16 15:37_

---

_Removed from milestone `Red Knot 2024` by @carljm on 2025-01-09 17:43_

---

_Added to milestone `Red Knot Q1 2025` by @carljm on 2025-01-09 17:43_

---

_Comment by @carljm on 2025-01-09 17:51_

See https://github.com/astral-sh/ruff/issues/13879 for discussion of generator expressions as it relates to this task.

---

_Assigned to @dcreager by @dcreager on 2025-02-10 22:55_

---

_Comment by @dcreager on 2025-02-10 22:56_

https://github.com/astral-sh/ruff/pull/16079

---

_Comment by @MichaReiser on 2025-02-19 20:34_

@dcreager is this complete now?

---

_Comment by @carljm on 2025-02-19 20:37_

I think it is.

---

_Closed by @carljm on 2025-02-19 20:37_

---

_Comment by @dcreager on 2025-02-19 22:58_

I'm looking at how we're representing the bindings snapshots next, to see if there's any performance we can squeeze out of it.  But I'm :+1: to closing this since the functionality is there and working.

---
