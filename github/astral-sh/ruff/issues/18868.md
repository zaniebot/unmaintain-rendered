---
number: 18868
title: "formater: PEP8 operator recommendations"
type: issue
state: closed
author: DerWeh
labels:
  - question
assignees: []
created_at: 2025-06-22T21:50:49Z
updated_at: 2025-07-07T08:01:56Z
url: https://github.com/astral-sh/ruff/issues/18868
synced_at: 2026-01-07T12:31:13-06:00
---

# formater: PEP8 operator recommendations

---

_Issue opened by @DerWeh on 2025-06-22 21:50_

### Question

(Sorry, if this issue already popped up, but I didn't find anything.)
Thank you very much for this incredible formatter, which helps to end pointless discussions on stylistic choices.

I just have one problem, that is the spacing operators, which in fact reduces readability. And we all know:
> Readability counts.

`ruff` consistently places a single space around binary operators. [PEP8](https://peps.python.org/pep-0008/#other-recommendations), on the other hand, suggests:

> If operators with different priorities are used, consider adding whitespace around the operators with the lowest priority(ies). Use your own judgment; however, never use more than one space, and always have the same amount of whitespace on both sides of a binary operator:
> 
> ```python
> # Correct:
> i = i + 1
> submitted += 1
> x = x*2 - 1
> hypot2 = x*x + y*y
> c = (a+b) * (a-b)
> ```
> 
> ```python
> # Wrong:
> i=i+1
> submitted +=1
> x = x * 2 - 1
> hypot2 = x * x + y * y
> c = (a + b) * (a - b)
> ```

The `use your own judgment` is, of course, not really suitable for an automatic formatter, but I am confident, that we can do better than the current default. My suggestion: don't put spaces around the highest priority operator if there are operators with different priority in the same parenthesis or line if there are no parentheses.[^1]
In my opinion, enforcing this with an automatic formatter would reduce misunderstandings, as the reader is less likely to make wrong assumptions on the operator priority.

Other alternatives are to always use parentheses or to always split the equation on multiple lines, but both options reduce readability due to visual clutter.

Currently, this issue is a showstopper for me to adopt `ruff` for numerical code. Of course, I can turn off formatting selectively for equations, but this is a rather error-prone solution that counters the purpose of automatic formatters.

<details>
<summary> ðŸ”½ Note: ruff puts spaces around `**` if there are parentheses or brackets involved, else not</summary>

```python
3**2
(2 + 1) ** 2
3 ** (1 + 1)
sqrt(9) ** 2
3 ** sqrt(4)
np.finfo(np.float64).eps ** 0.25
tt[small] ** 2
```
The behavior seems a little odd to me. Is this intentional?
</details>

----
<details>
 <summary>In the following, I provide some more code examples from my own code base</summary>

```python
# mine
W = (0.25*U*U + 4*t*t)**0.5
E_0 = 0.5*U - W
gf_z = (0.5 + s*t/W) / (z - (E_0 + s*t))
gf_z += (0.5 - s*t/W) / (z - (U + s*t - E_0))
# ruff
W = (0.25 * U * U + 4 * t * t) ** 0.5
E_0 = 0.5 * U - W
gf_z = (0.5 + s * t / W) / (z - (E_0 + s * t))
gf_z += (0.5 - s * t / W) / (z - (U + s * t - E_0))
```
The formatted equation is very difficult to read... We have to introduce further parenthesis and reorder some expressions:
```python
W = ((0.25 * U * U) + (4 * t * t)) ** 0.5
E_0 = (0.5 * U) - W
gf_z = (0.5 + (s * t / W)) / (z - (s * t + E_0))
gf_z += (0.5 - (s * t / W)) / (z - (s * t + U - E_0))
```
But it still seems too hard to read, we probably need to introduce some sub-expressions and split equations, but this in turn reduces readability...

```python
# mine
denominator = 0.5 * np.pi / wn[-1]**2
# ruff
denominator = 0.5 * np.pi / wn[-1] ** 2
```
This example is not all too bad, we are used that `**` has high priority and `/` is read like a fraction.

```python
# mine
self_cpa = self_cpa_re - mu + 1j*self_cpa_im  # add contribution of mu
# ruff
self_cpa = self_cpa_re - mu + 1j * self_cpa_im  # add contribution of mu
```

We are trained to read complex numbers as `re + 1j*im`. `re + 1j * im` is harder when we read left-to-right, as we see the tokens in the order `re` â†’ `re + 1j` â†’ `re + 1j * im`. Inverting the order `1j * im + re` is not a good option as we are conditioned to first get the real, then the imaginary part. `re + (1j * im)` is probably the best option, but adds visual clutter, which might be problematic for more complicated equations. Here it would be fine
```python
self_cpa = (self_cpa_re - mu) + (1j * self_cpa_im)  # add contribution of mu
```

```python
# mine
gf_z = delta_tt * (weight1*g_dft + weight2*dg_dft)
# ruff
gf_z = delta_tt * (weight1 * g_dft + weight2 * dg_dft)
# parenthesis
gf_z = delta_tt * ((weight1 * g_dft) + (weight2 * dg_dft))
```

```python
# mine
return 0.25 * (np.pi**2 * z) * _u_ellipk(m)**2
# ruff
return 0.25 * (np.pi**2 * z) * _u_ellipk(m) ** 2
```

```python
# mine
m = 0.5 - 0.5j*np.sqrt(eps_rel[finite]**-2 - 1)
Ksqr = _u_ellipk(m)**2
# ruff
m = 0.5 - 0.5j * np.sqrt(eps_rel[finite] ** -2 - 1)
Ksqr = _u_ellipk(m) ** 2
```

```python
# mine
gf_d1 = (2. / half_bandwidth**2) * (1 - 1/sqrt)
# ruff
gf_d1 = (2.0 / half_bandwidth**2) * (1 - 1 / sqrt)
```

```python
# mine 
gf_d2 = (2.0 / half_bandwidth**3) * z_rel * sqrt / (1 - z_rel**2)**2
# ruff
gf_d2 = (2.0 / half_bandwidth**3) * z_rel * sqrt / (1 - z_rel**2) ** 2
```

```python
# mine
xi = mp.sqrt(1 - mp.sqrt(1 - z_sqr)) / mp.sqrt(1 + mp.sqrt(1 - 9*z_sqr))
k2 = 16 * xi**3 / ((1 - xi)**3 * (1 + 3*xi))
green = (1 - 9*xi**4) * (2 * mp.ellipk(k2) / mp.pi)**2 / ((1 - xi)**3 * (1 + 3*xi)) / z
# ruff
xi = mp.sqrt(1 - mp.sqrt(1 - z_sqr)) / mp.sqrt(1 + mp.sqrt(1 - 9 * z_sqr))
k2 = 16 * xi**3 / ((1 - xi) ** 3 * (1 + 3 * xi))
green = (1 - 9 * xi**4) * (2 * mp.ellipk(k2) / mp.pi) ** 2 / ((1 - xi) ** 3 * (1 + 3 * xi)) / z
```
</details>

[^1]:  One could think of augmenting this rule such that from a certain priority there are no spaces by default unless there is another higher priority operator, such that something like `x**y` has no spaces by default.


### Version

0.12.0

---

_Label `question` added by @DerWeh on 2025-06-22 21:50_

---

_Comment by @chirizxc on 2025-06-22 23:06_

also linter has a rule ([`E226`](https://docs.astral.sh/ruff/rules/missing-whitespace-around-arithmetic-operator/)) that completely contradicts pep8 

---

_Comment by @Tapeline on 2025-06-22 23:14_

> a rule that completely contradicts pep8

It actually has many of them. Are there any initiatives on making ruff fully pep8 compliant?

---

_Comment by @chirizxc on 2025-06-22 23:18_

> > a rule that completely contradicts pep8
> 
> It actually has many of them. Are there any initiatives on making ruff fully pep8 compliant?

idk, but it seems to me that it is pep8 that we should be following, not just porting rules from other linters that have already been made not by pep8

---

_Comment by @charliermarsh on 2025-06-22 23:58_

There's extensive discussion of formatting for these kinds of operators over in the `scientific-python` repo: https://github.com/scientific-python/specs/pull/326/. I might suggest participating there -- we don't have any plans to change our own operator spacing unilaterally, and the current rules are designed to match Black.


---

_Closed by @charliermarsh on 2025-06-22 23:58_

---

_Comment by @Tishka17 on 2025-06-23 00:14_

@charliermarsh it is ok to keep current rule as is, but 
1. remove notification that it is compliant with pep8
2. add new rule which is actually compliant

At least you need to remove note - it is lying

---

_Comment by @charliermarsh on 2025-06-23 00:17_

Sure, we can remove the mention of PEP 8. ("Lying" is a bit strong because it implies malicious intent -- this is just a mistake.)

---

_Referenced in [astral-sh/ruff#18870](../../astral-sh/ruff/pulls/18870.md) on 2025-06-23 00:26_

---

_Comment by @DerWeh on 2025-07-01 21:37_

@charliermarsh Thanks for the reference.

Could you maybe explain, what's the reasoning behind the spacing around the `**` operator? If I understood why you format it
```python
f(yy) ** 2 + xx**3 + tt[small] ** 4
```
I might be bugged less by it. On the other hand, I do relate why you don't give any explanations for your formatting rules. Most is a matter of taste, and you just invite endless discussions by giving a reason.

---

_Comment by @MichaReiser on 2025-07-07 08:01_

We inherited this design from Black. The style guide doesn't go into the details on the why power operands are only sometimes spaced with one space, see https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html#line-breaks-binary-operators

---
