---
number: 21133
title: Detect variables used after context-manager exit
type: issue
state: open
author: loribonna
labels:
  - rule
  - needs-decision
assignees: []
created_at: 2025-10-30T08:34:49Z
updated_at: 2025-11-12T09:58:39Z
url: https://github.com/astral-sh/ruff/issues/21133
synced_at: 2026-01-07T12:31:13-06:00
---

# Detect variables used after context-manager exit

---

_Issue opened by @loribonna on 2025-10-30 08:34_

### Summary

# Summary  

Add a lint rule that flags variables bound via `with … as var` (or `async with … as var`) when they are used *after* the context manager has exited.

# Motivation

Context-manager variables (e.g., DB sessions, file handles) are only valid inside the `with` block. Using them afterward is a common source of subtle bugs (for example, SQLAlchemy async sessions silently closing and leaking connections).

Example:

```python
async with get_session() as session:
    await session.execute(...)

await session.execute(...)  # ❌ should be flagged — session is closed here
```

My main issue with the code above is that everything done on the session outside the `with` block is allowed but will result in hard-to-trace runtime errors and potential connection leaks.

Today Ruff does not report this usage. Pyright/mypy also don’t catch it.

---

_Label `rule` added by @ntBre on 2025-10-30 13:35_

---

_Label `needs-decision` added by @ntBre on 2025-10-30 13:35_

---

_Comment by @MichaReiser on 2025-11-10 17:54_

This rule makes sense to me and seems generally useful. @amyreese what do you think? Should we add it to RUFF?

---

_Comment by @AlexWaygood on 2025-11-10 18:03_

This would forbid a very popular pattern used in unittest and pytest to catch exceptions, save information about the caught exception, and then make assertions about the exception that was caught, e.g.
- https://github.com/saltstack/salt/blob/904d08b6ad311fd95c75004fbc3dab2b241f9ce6/tests/unit/utils/test_vsan.py#L53-L58
- https://github.com/django/django/blob/c135be349ddd9fd71b15d4b20e7fc46814e4ca7c/tests/validation/__init__.py#L11-L14
- https://github.com/python/cpython/blob/ed0a5fd8cacb1964111d03ff37627f6bea5e6026/Lib/test/test_codecs.py#L731-L733
- https://github.com/pydantic/pydantic/blob/27c95fd56e217f6cfc6ee96e07e1fb0646ef0d49/pydantic-core/tests/validators/test_model_fields.py#L79-L84
- https://github.com/readthedocs/readthedocs.org/blob/8c4761ac6ae147609c575f8f4f35111cb1b0664a/readthedocs/rtd_tests/tests/test_unresolver.py#L75-L79
- https://github.com/Azure/azure-sdk-for-python/blob/715a3a015895b8b959c11f18e3d2aacad7dc250f/sdk/keyvault/azure-keyvault-keys/tests/test_crypto_client.py#L278-L281

---

_Comment by @MichaReiser on 2025-11-10 18:17_

Thanks @AlexWaygood. Now that you bring it up. I get the impression that this is something we talked about before (it sounds very familiar)

---

_Comment by @loribonna on 2025-11-11 09:14_

Thanks @AlexWaygood I was not aware of this use. However, wouldn't it make more sense to put the assert inside the context?

I still think it's weird to create and initialize a variable with the `with` clause and use it outside, it makes code error prone with very hard to debug errors.

---

_Comment by @AlexWaygood on 2025-11-11 09:24_

> However, wouldn't it make more sense to put the assert inside the context?

No — you generally want to make a `self.assertRaises` or `pytest.raises` block as small as possible, ideally holding only a single statement. Otherwise, you can't be sure that the asserted exception is being raised in the place you expected and for the reason you expected. Ruff already has other lints to stop you from doing this, such as https://docs.astral.sh/ruff/rules/pytest-raises-with-multiple-statements/.

> I still think it's weird to create and initialize a variable with the with clause and use it outside, it makes code error prone with very hard to debug errors.

I agree that you should be careful and deliberate about doing this, but I'm not sure I see a way to establish a general rule here, since there are certainly cases where this pattern is essential. Possibly we could create a rule that special-cases certain specific, known context managers where we know this pattern will lead to bugs?

---

_Comment by @loribonna on 2025-11-11 10:00_

> No — you generally want to make a `self.assertRaises` or `pytest.raises` block as small as possible, ideally holding only a single statement. Otherwise, you can't be sure that the asserted exception is being raised in the place you expected and for the reason you expected. Ruff already has other lints to stop you from doing this, such as https://docs.astral.sh/ruff/rules/pytest-raises-with-multiple-statements/.

I see, yeah it makes sense.

> Possibly we could create a rule that special-cases certain specific, known context managers where we know this pattern will lead to bugs?

That would be great but I think most times you are dealing with custom context managers, like for my example of getting a session from the DB. 

I'd really like if python allowed me declare or mark a variable as "scoped" to enforce this kind of rules!

---

_Comment by @MichaReiser on 2025-11-11 10:18_

I wonder how far we could get with allow-listing some common context managers and allowing users to specify additional "safe" context managers. This is something that at least is suspicious to be *wrong*. 

---

_Comment by @amyreese on 2025-11-11 16:33_

I'm kind of -0 on this being a useful rule. Whether or not the variable declared in the context manager is "valid" outside the context manager is entirely dependent on what you're doing and what you're using as a context manager. I've seen/written multiple systems where it's extremely handy to capture a "result" value for use outside of the with context. Eg, things like success/failure indicators, or timing instrumentation, as well as the aforementioned testing harnesses. Anything where you want implicit actions to happen at both enter/exit of the context, and to capture some state for use afterwards, without needing to intentionally declare a variable before the context.

If we could tag rules as "pedantic", I would absolutely put this in that category, and I would probably have it disabled on my own projects.

---

_Comment by @loribonna on 2025-11-12 09:58_

I think the fact that context managers give this much flexibility is not inherently a good thing and should be used with consideration, similarly to type hints for variables. 

Even from the python's docs the `with` statement is usually described as something to contain the execution of some code without affecting the code outside, so in my mind it makes more sense to consider:
- `__enter__`: initialize stuff that you need inside the body
- `__exit__: restore the execution as it was before the context and perform cleanups

The only exeption i can think of are exceptions, as pointed out by @AlexWaygood . 

Of course this is just my preference, I understand that i can already achieve "correct" variable scoping by wrapping everything inside a function.

---
