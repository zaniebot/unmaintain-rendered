---
number: 20211
title: "Edge case for `FBT001` is not handled."
type: issue
state: open
author: NiKuma0
labels:
  - rule
assignees: []
created_at: 2025-09-03T12:59:38Z
updated_at: 2025-09-03T15:43:30Z
url: https://github.com/astral-sh/ruff/issues/20211
synced_at: 2026-01-07T12:31:13-06:00
---

# Edge case for `FBT001` is not handled.

---

_Issue opened by @NiKuma0 on 2025-09-03 12:59_

### Summary

I found this while reviewing some dude's code:
```python
from typing import Literal


def test(arg: bool):  # Error: Boolean-typed positional argument in function definition (Ruff FBT001)
    pass

def foo(arg: Literal[True, False]):  # No error.
    pass
```
I expect that both funcs will throw `FBT001`

### Version

ruff 0.12.8

---

_Renamed from "Eadge case for `FBT001` is not handled." to "Edge case for `FBT001` is not handled." by @NiKuma0 on 2025-09-03 13:01_

---

_Comment by @chirizxc on 2025-09-03 13:07_

there is a rule [RUF038](https://docs.astral.sh/ruff/rules/redundant-bool-literal/#redundant-bool-literal-ruf038) `Literal[True, False]` -> `bool`

---

_Comment by @chirizxc on 2025-09-03 13:20_

To FBT001 catch these, we can do something like this:
```diff
--- a/crates/ruff_linter/src/rules/flake8_boolean_trap/rules/boolean_type_hint_positional_argument.rs
+++ b/crates/ruff_linter/src/rules/flake8_boolean_trap/rules/boolean_type_hint_positional_argument.rs
@@ -190,6 +190,18 @@ fn match_annotation_to_complex_bool(annotation: &Expr, semantic: &SemanticModel)
                 semantic.match_typing_qualified_name(qualified_name, "Optional")
             }) {
                 match_annotation_to_complex_bool(slice, semantic)
+            } else if qualified_name.as_ref().is_some_and(|qualified_name| {
+                semantic.match_typing_qualified_name(qualified_name, "Literal")
+            }) {
+                // Literal[True, False]
+                match slice.as_ref() {
+                    Expr::Tuple(ast::ExprTuple { elts, .. }) => elts.iter().all(|elt| matches!(
+                        elt,
+                        Expr::BooleanLiteral(_)
+                    )),
+                    Expr::BooleanLiteral(_) => true,
+                    _ => false,
+                }
             } else {
                 false
             }
```

---

_Label `rule` added by @ntBre on 2025-09-03 15:43_

---

_Comment by @ntBre on 2025-09-03 15:43_

Thanks for the issue and @chirizxc for the patch! I happened to look at https://github.com/astral-sh/ruff/issues/16129#issuecomment-2657268827 for an unrelated issue today, and one of the comments definitely supports handling this `Literal` case here:

> In general (even not considering overloads specifically) anywhere a type checker fails to treat bool and Literal[True, False] the same, it's a type checker bug IMO -- those types are equivalent

So that patch looks good to me if you want to open a PR. I think we should preview gate it just to be safe, though.

---
