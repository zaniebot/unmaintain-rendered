---
number: 2195
title: "Implement configuration options from `flake8-type-checking`"
type: issue
state: closed
author: charliermarsh
labels:
  - configuration
assignees: []
created_at: 2023-01-26T14:49:35Z
updated_at: 2023-03-07T04:34:54Z
url: https://github.com/astral-sh/ruff/issues/2195
synced_at: 2026-01-07T12:31:12-06:00
---

# Implement configuration options from `flake8-type-checking`

---

_Issue opened by @charliermarsh on 2023-01-26 14:49_

- [x] `exempt-modules`
- [x] `strict`
- [ ] `pydantic-enabled`
- [ ] `pydantic-enabled-baseclass-passlist`
- [ ] `fastapi-enabled`
- [ ] `fastapi-dependency-support-enabled`
- [ ] `cattrs-enabled`

See: #1785

---

_Referenced in [astral-sh/ruff#2096](../../astral-sh/ruff/issues/2096.md) on 2023-01-26 14:50_

---

_Referenced in [astral-sh/ruff#2193](../../astral-sh/ruff/issues/2193.md) on 2023-01-26 14:50_

---

_Comment by @charliermarsh on 2023-01-26 14:51_

@sondrelg - not urgent, but any input on these options based on your experience? Any thing you'd warn me about, etc.?

---

_Assigned to @charliermarsh by @charliermarsh on 2023-01-26 14:51_

---

_Label `configuration` added by @charliermarsh on 2023-01-26 14:54_

---

_Comment by @sbrugman on 2023-01-26 15:24_

Is it feasible to create another script in addition to `add_rule.py` and `add_plugin.py`, e.g. `add_option.py`?
Not sure if this can be automated, didn't look into it. Could be a good thought to have in mind when new options are implemented.

ps. @charliermarsh some other options are labelled `isort` but I think should also have the `configuration` tag


---

_Comment by @sondrelg on 2023-01-26 18:36_

Yeah `exempt-modules` and `strict` are easy and probably fine to implement, but the rest are.. sub-optimal:

The follow snippets represent code that's incompatible with the general premise of the flake8-type-checking plugin:

### Pydantic model annotations
```python
from pydantic import BaseModel
from pandas import DataFrame    


class Foo(BaseModel):
    df: DataFrame
```

### FastAPI view function annotations
```python
@app.get()
def foo(request: Request) -> Response:
    ...
```

### Any FastAPI dependency functions

```python
# dependencies.py
async def is_authorized(request: Request) -> bool:  # Request here cannot be wrapped in quotes
    ...
```

```python
# endpoints.py
async def foo(request: Request, is_authorized: bool = Depends(is_authorized)) -> bool:
    ...
```

------------

Since we're performing static single file analysis, there is no way to be certain whether a function can be used as a "dependency" in FastAPI, or whether a class that inherits from some base class is pydantic model or not. `attrs` classes are a little simpler to spot, but we can never be certain there either.

The reason this matters is because if we guard an import within a `TYPE_CHECKING` block, and it is attempted to be evaluated by, e.g., `pydantic` at runtime the consequences are runtime errors. This is a pretty terrible consequence, so my thinking has been that the bar for what uncertainty we'll tolerate should be very high.

So the pydantic plugin essentially just treats ALL classes with base classes as potential pydantic classes. The `type-checking-pydantic-enabled-baseclass-passlist` setting then gives users a way to tell us which base classes are definitely not an alias for- or abstract class containing `BaseModel`.

The same thing happens for the FastAPI option. Any decorated function is ignored, and you can opt-into ignoring any function, since they may be used in the `Depends` wrapper.

--------------

I think I would recommend adding a disclaimer to the readme informing users that this plugin is fundamentally incompatible with projects that evaluate type hints at runtime, and drop these config options -- but obviously feel free to add them if you want. In general though I think it's a lot of work for very little gain. 


---

_Referenced in [astral-sh/ruff#2230](../../astral-sh/ruff/pulls/2230.md) on 2023-01-26 21:47_

---

_Comment by @sasanjac on 2023-02-10 14:44_

I don't understand the problem for `pydantic` support. Can't we just assume that every class that has `pydantic.BaseModel` as a base class needs to have the types of their class attributes checked at runtime?

---

_Comment by @charliermarsh on 2023-02-10 14:45_

Oh, I believe we do now require that class attributes are present at runtime.

---

_Comment by @charliermarsh on 2023-02-10 14:46_

Weird to link to a tweet for reference but: https://twitter.com/charliermarsh/status/1623389778375843840

---

_Comment by @sondrelg on 2023-02-10 15:53_

> I don't understand the problem for `pydantic` support. Can't we just assume that every class that has `pydantic.BaseModel` as a base class needs to have the types of their class attributes checked at runtime?

What if you do this?

```python
# a.py

class AppBaseModel(BaseModel):
    name: str  # every model in my app will have this attribute
``` 

```python
# b.py 
from a import AppBaseModel

class Foo(AppBaseModel):
```

It's been a while since we discussed it, but I think there's a number of way to assume incorrectly. And since the consequence of a false negative is potential runtime errors in your prod app, we should try to avoid that at all costs.

Does that make sense @sasanjac?

---

_Comment by @sondrelg on 2023-02-10 15:55_

That's news to me @charliermarsh. Is that a 3.11 or 3.12 thing?

---

_Comment by @sasanjac on 2023-02-10 16:25_

nvm, my brain left me there for a bit.

> Does that make sense @sasanjac?

~~No, because `Foo.mro()` still contains `BaseModel`.~~

---

_Comment by @charliermarsh on 2023-02-10 16:30_

@sondrelg - I don't _think_ so but I haven't really looked back on it. You can see the docs [here](https://docs.python.org/3/reference/simple_stmts.html#annotated-assignment-statements). The logic is that if you're in a module or class scope, the annotations need to be added to `__annotations__`, so they end up getting evaluated at runtime. In a function scope, there's no such construct, so they just get skipped.

There are some comments from Python core contributors in that thread: https://twitter.com/MissingClara/status/1623435238289608709

---

_Comment by @sasanjac on 2023-02-10 17:08_

> nvm, my brain left me there for a bit.
> 
> > Does that make sense @sasanjac?
> 
> ~No, because `Foo.mro()` still contains `BaseModel`.~

But can't we then turn the procedure around? Explicitely state all base classes that inherit from BaseModel?

---

_Comment by @ofek on 2023-02-10 17:14_

Tangentially related: is there a way to enforce imports that must be present like `from __future__ import annotations`?

---

_Comment by @charliermarsh on 2023-02-10 17:14_

@ofek - Yeah, we support it via [`required-imports`](https://github.com/charliermarsh/ruff#required-imports) (which maps to [`I002`](https://github.com/charliermarsh/ruff/blob/main/docs/rules/missing-required-import.md)).

---

_Comment by @sondrelg on 2023-02-10 23:22_

> > nvm, my brain left me there for a bit.
> > > Does that make sense @sasanjac?
> > 
> > 
> > ~No, because `Foo.mro()` still contains `BaseModel`.~
> 
> But can't we then turn the procedure around? Explicitely state all base classes that inherit from BaseModel?

The example above isn't the worst case - we could have `n` layers of base classes and mixins to traverse located in `m` different files. Since flake8 operates in a one-file-at-the-time type of way, leaving the scope of the single file was not something that seemed worth the investment in the original plugin, but maybe ruff has some foundations that make it worth considering :slightly_smiling_face:

---

_Comment by @sasanjac on 2023-02-11 09:02_

Yeah I totally forgot about that. But why don't leave it up to the user to specify all `pydantic` base classes in the config file? I mean with the default config, the user will encounter runtime errors anyway.

---

_Comment by @sondrelg on 2023-02-11 09:31_

Mostly because no one has requested it :slightly_smiling_face:  How will they run into runtime errors anyway?

---

_Comment by @sasanjac on 2023-02-11 11:28_

Because with the default config they will move all typing imports into the `TYPE_CHECKING` block.
For me it just seems the most straightforward way to have something like `type-checking-pydantic-enabled-baseclasses` instead of dropping the config options.

---

_Comment by @sondrelg on 2023-02-11 20:24_

Maybe just call it `type-checking-pydantic-baseclasses`? Yeah I don't see why not if you want that feature :slightly_smiling_face: 


---

_Comment by @sasanjac on 2023-02-14 13:54_

Ok, now I only have to learn rust ðŸ™ˆ 

---

_Referenced in [astral-sh/ruff#3292](../../astral-sh/ruff/pulls/3292.md) on 2023-03-01 11:50_

---

_Comment by @charliermarsh on 2023-03-07 04:34_

The remaining options are covered by #3292 (albeit with an API that differs from the original `flake8-type-checking`), thanks to @sasanjac!

---

_Closed by @charliermarsh on 2023-03-07 04:34_

---
