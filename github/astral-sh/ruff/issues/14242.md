---
number: 14242
title: SIM300 (yoda-conditions) triggered by CAPITAL class attributes with function call
type: issue
state: closed
author: DanielYang59
labels:
  - question
assignees: []
created_at: 2024-11-10T08:11:31Z
updated_at: 2025-02-07T12:06:02Z
url: https://github.com/astral-sh/ruff/issues/14242
synced_at: 2026-01-07T12:31:13-06:00
---

# SIM300 (yoda-conditions) triggered by CAPITAL class attributes with function call

---

_Issue opened by @DanielYang59 on 2024-11-10 08:11_

[The following would trigger `SIM300`](https://github.com/materialsproject/pymatgen/pull/4159/commits/30e0f66de63c1605b2077394f4c21657455599f2), similar to #10848:

`bar` in the following code snippet seems stupid, in our case however it's `pytest.approx`.

```python
class Foo:
    def __init__(self):
        self.Z = 0.0
        self.Z_VAL = 0.0
        self.Z_val = 0.0

def bar(val):
    return val

kls = Foo()

assert kls.Z == 0.0           # all good
assert kls.Z == bar(0.0)      # SIM300 [*] Yoda condition detected
assert kls.Z_val == bar(0.0)  # all good
assert kls.Z_VAL == bar(0.0)  # SIM300 [*] Yoda condition detected
```

`--preview` would also trigger this, `ruff` version `0.7.3`.


Is it expected to treat `kls.Z` as a constant?


---

_Renamed from "SIM300 (yoda-conditions) triggered by CAPITAL class attributes with `pytest.approx`" to "SIM300 (yoda-conditions) triggered by CAPITAL class attributes with function call" by @DanielYang59 on 2024-11-10 08:16_

---

_Comment by @charliermarsh on 2024-11-10 15:59_

Yeah it's expected that `kls.Z` is considered to be a constant -- it uses the screaming capitalization case.

---

_Label `question` added by @charliermarsh on 2024-11-10 15:59_

---

_Comment by @DanielYang59 on 2024-11-11 03:40_

Okay thanks for the input!

---

_Closed by @DanielYang59 on 2024-11-11 03:40_

---

_Comment by @jakobhansen-blai on 2025-02-05 19:10_

I ran into this problem in the following context:

```python
class C:
    def __init__(self, X):
        self.X = X

xs = [C(i) for i in range(10)]
val = xs[0].X
for x in xs:
    assert x.X == val # SIM300
```

I don't think it makes sense to assume `x.X` is a constant in this situation, since `X` is scoped to the class instance, so different instances could have different values of this property.

---

_Comment by @gsakkis on 2025-02-07 12:06_

Another case with pydantic-settings:
```python
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    foo: int = 1
    BAR: int = 1


settings = Settings()

print(settings.foo == 1)                 # ok
print(settings.foo == [])                # ok
print(settings.foo == frozenset())       # ok

print(settings.BAR == 1)                 # ok
print(settings.BAR == [])                # ok
print(settings.BAR == frozenset())       # SIM300
```


---
