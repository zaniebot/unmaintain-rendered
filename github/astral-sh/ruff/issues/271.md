---
number: 271
title: "Meta issue: editor integrations"
type: issue
state: closed
author: charliermarsh
labels: []
assignees: []
created_at: 2022-09-28T18:04:34Z
updated_at: 2023-02-12T16:25:31Z
url: https://github.com/astral-sh/ruff/issues/271
synced_at: 2026-01-07T12:31:12-06:00
---

# Meta issue: editor integrations

---

_Issue opened by @charliermarsh on 2022-09-28 18:04_

Creating a parent issue to track and document the state of ruff's editor integrations.


---

_Label `enhancement` added by @charliermarsh on 2022-09-28 21:38_

---

_Comment by @charliermarsh on 2022-09-28 21:39_

We should support and document integration with VS Code and PyCharm at the very least. I know there was some prior work + discussion in #118.

---

_Comment by @charliermarsh on 2022-09-28 21:40_

Part of the work here could be making @harupy's VS Code extension publicly available. I'm happy to take that on if needed.

---

_Comment by @Seamooo on 2022-09-29 09:52_

I've been playing around with the microsoft lsp as a way of making ruff available to a wider number of editors (particularly vscode and coc-nvim). The major blocker for me is that the main function for linting `ruff::linter::lint_path` only accepts a `Path` for the source. There's currently no public interface for linting from contents, or lower level access to the checking functions (i.e. `check_path` is private and `check_ast` requires `autofix::fixer::Mode` but `autofix` is private)

---

_Comment by @charliermarsh on 2022-09-29 12:18_

I havenâ€™t had time to dig in on this, but is the solution to exposure lint_path and then have the LSP use the ruff crate as a library? Or do we need to expose that functionality as a binary / CLI? Iâ€™m happy to do whicheverâ€™s necessary.

---

_Comment by @charliermarsh on 2022-09-29 12:24_

In other words: if I added a lint_path function that was publicly exposed (with public args etc.), would that unblock this?

---

_Comment by @Seamooo on 2022-09-29 12:28_

The critical blocker is being able to take a source input, rather than just the path, whether that be in a publically exposed api or from stdin, both are viable. As a preference working with a public api would be nicer, also leaving open the opportunity for incremental linting.

---

_Comment by @charliermarsh on 2022-09-29 12:39_

Ok cool, very doable. Will put something together.

---

_Referenced in [astral-sh/ruff#289](../../astral-sh/ruff/pulls/289.md) on 2022-09-29 22:30_

---

_Comment by @charliermarsh on 2022-09-29 23:09_

(I added some documentation for PyCharm.)

---

_Comment by @vikigenius on 2022-10-21 22:01_

@charliermarsh

Comenting on your question from https://github.com/charliermarsh/ruff/pull/289#issuecomment-1263866024 here since it's a more relevant thread.


> What does it take to enable others to use the LSP from VS Code and elsewhere?

Alternatively most python language servers are expected to be able to installed as a python package itself. So just distributing the language server as a python package using maturin would be enough.

Once that is done, the editors that support lsp would start developing clients to interact with the ruff language server.

Although personally I would like to have a general purpose language server to enable completions and use ruff as just an additional checker either as a separate binary or as an extension. Because the existing language servers for python are implemented in python and extremely slow or implemented in JS/TS (pyright) which I don't like.

Now that you have shown what we can do with Rust for python ecosystem hopefully in the future we can build an entire language server from the ground up in Rust for Python and have ruff as a checker extension for it. Like how Rust Analyzer is for Rust.

---

_Comment by @charliermarsh on 2022-10-21 22:19_

ðŸ‘ This makes sense! I want to spend some time exploring this soon (maybe this coming week), and putting together some official extensions. I use PyCharm, not VS Code, so Iâ€™m less familiar with the ecosystem (I need to understand the relationship between the LSP implementation, Ruff as a library, and then the actual editor extensions or actions and how those are distributed). But I do want Ruff to have the best possible editor support for VS Code given its popularity :)


---

_Comment by @vikigenius on 2022-10-21 22:35_

Yep. As long as you have good language server support following the protocol. The people working on the editors will automatically start working on a client if the server is good/popular enough.

For instance, the moment we have a language server for ruff, I will try to contribute a client to Emacs https://github.com/emacs-lsp/lsp-mode so that I will be able to use it in Emacs. Similar would happen to all editors I am sure.

So the question basically becomes should the language server be a separate implementation? Or should it be somehow integrated into the same Repo (different crate) like how Rust-Analyzer does it for example. 

I know @Seamooo had an inital prototype implementation here https://github.com/Seamooo/ruffd it is a good POC for what a language server will look like in general.

---

_Comment by @vikigenius on 2022-10-21 22:51_

The LSP specification https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/ is actually very readable unlike most specifications if you want a reference

Additionally something to consider is that all language servers will have different capabilities that they supports. A hypothetical `ruff-language-server` will support formatting related capabilities such as `codeActionProvider` and `diagnosticsProvider`.

But it won't support static checking and completion capabilities like `completionProvider` `declarationProvider` (goto declaration) etc.

A language server like Rust-Analyzer basically supports everything since it integrates, formatting, diagnostics, completion etc. all in one.

I know that linting itself is a huge task that you are taking on, but it might be useful if things like the parsing, AST/CST logic etc. can be well defined and reusable enough that in the future we can think of adding completion and type checking related capabilities as well for an all in one rust based python language server.


---

_Comment by @charliermarsh on 2022-10-21 23:05_

Awesome. I'd like it to be in the same repo, if possible. We can use @Seamooo's implementation as a starting point (or would it ever make sense to build atop something like [`tower-lsp`](https://github.com/ebkalderon/tower-lsp)? I have to do some research here).

You're exactly right that it'd be good to design this with future capabilities in mind. Ruff already supports auto-fix, but auto-formatting is another good example of a capability that would be interesting to explore within the scope of the project.


---

_Comment by @charliermarsh on 2022-10-21 23:08_

(Let's keep using this issue to discuss for now, and I'll open something else specific to the LSP if / when I have work ready for review / feedback.)

---

_Comment by @vikigenius on 2022-10-21 23:11_

Oh, I didn't know about tower-lsp before. It seems like a pretty useful abstraction. The protocal itself is not that hard to implement as can be seen from the prototype implementation https://github.com/Seamooo/ruffd

But having something like tower-lsp will definitely make it easier and maybe more easily maintainable (hopefully).

---

_Comment by @b4rlw on 2022-10-23 01:13_

Are there any plans for neovim integration?

---

_Comment by @Seamooo on 2022-10-24 03:34_

Definitely like the look of tower-lsp, and would be a big step for maintainability. Only reservervations would be having to dig into how it does scheduling as request ordering is important in the case of mutations.
If we're looking to create a code action provider for fixes, the api exposing Check, rather than Message, and making Fix a public type should enable everything.

---

_Comment by @Seamooo on 2022-10-24 03:39_

@beatslikeahelix https://github.com/Seamooo/ruffd works with coc.nvim admittedly there isn't a release candidate right now as it's  very POC. To get it to work you can add below to your `coc-settings.json`
```json
{
	...
	"languageserver": {
		...
		"ruffd": {
			"command": "/path/to/ruffd",
			"filetypes": ["python"],
		}
	}
}
```
(obviously the ellipses indicating any other config you might have there)

---

_Referenced in [Seamooo/ruffd#1](../../Seamooo/ruffd/issues/1.md) on 2022-10-24 05:52_

---

_Comment by @charliermarsh on 2022-10-24 20:00_

I'm going to try building a VS Code extension atop `ruffd`.

---

_Referenced in [astral-sh/ruff#463](../../astral-sh/ruff/issues/463.md) on 2022-10-24 21:39_

---

_Comment by @fannheyward on 2022-10-25 11:34_

coc-pyright has added ruff support, only lint for now.

---

_Label `enhancement` removed by @charliermarsh on 2022-10-26 01:55_

---

_Added to milestone `Editor integrations` by @charliermarsh on 2022-10-26 01:55_

---

_Renamed from "Editor integrations" to "Meta issue: editor integrations" by @charliermarsh on 2022-10-26 01:56_

---

_Comment by @charliermarsh on 2022-10-26 15:10_

@fannheyward - That's awesome! Thank you for doing that. I'll plug it in the Ruff docs.

---

_Referenced in [gradientinstitute/causal-inspection#43](../../gradientinstitute/causal-inspection/issues/43.md) on 2022-11-01 06:49_

---

_Comment by @JafarAbdi on 2022-11-04 11:18_

For those who are using neovim, you could integrate ruff directly with [efm](https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#efm) just add the [following lines](https://github.com/JafarAbdi/myconfigs/blob/6f0b6b2450e92ec8fc50422928cd22005b919110/efm-langserver/config.yaml#L14-L20) to your config file 

---

_Comment by @fannheyward on 2022-12-02 11:14_

`coc-pyright` has added `ruff` fix support, can be triggered with code action manually.

---

_Comment by @charliermarsh on 2022-12-02 14:30_

Thanks @fannheyward!

---

_Comment by @koxudaxi on 2022-12-03 02:49_

@charliermarsh 
I have started to develop the Pycharm plugin `ruff`
I will come back with more information.
https://github.com/koxudaxi/ruff-pycharm-plugin

---

_Comment by @koxudaxi on 2022-12-07 17:02_

I implemented the three features on the [ruff pycharm plugin](https://github.com/koxudaxi/ruff-pycharm-plugin). 
- Run `ruff --fix` as an action
-  Integrate Reformat Code with `ruff --fix` 
-  Run `ruff --fix` for a file when the file is saved


And, We can install the plugin on PyCharm settings from [JetBrains marketplace](https://plugins.jetbrains.com/plugin/20574-ruff)
The version invokes `ruff` command and give the python code to `stdin`.

@charliermarsh 
As the next step, I would try to support `ruffd` (LSP).
I can't find the current status of the `ruffd`

Do you have the roadmap for supporting LSP?
If we need the time. I will skip the task now. And I will take another task. 

---

_Comment by @charliermarsh on 2022-12-07 17:24_

@koxudaxi - Awesome! I'll give it a try today.

I'm still figuring out the roadmap for `ruffd`. Right now, I'm slightly more interested in using the LSP from https://github.com/charliermarsh/vscode-ruff and seeing if I can leverage it outside of VS Code (e.g., in Sublime Text).


---

_Comment by @koxudaxi on 2022-12-07 17:47_

@charliermarsh 
OK, I will check the repository. Thank you.
I feel the speed is not bad for only applying to 1 file using CLI from the plugin.
What LSP request type is supported by `ruffd`?
Should I check the source code? :sweat_smile: 


---

_Comment by @charliermarsh on 2022-12-07 18:03_

The most relevant stuff in `vscode-ruff` is [here](https://github.com/charliermarsh/vscode-ruff/blob/main/bundled/tool/server.py) -- the bundled Python server running on `pygls`. You can see the supported actions in the `@LSP_SERVER.feature` decorators.

---

_Comment by @charliermarsh on 2022-12-07 18:04_

(I know you asked about `ruffd`, but right now `vscode-ruff` is more familiar to me.)

---

_Comment by @charliermarsh on 2022-12-07 18:12_

@koxudaxi - Does the extension surface errors in the editor? Or is it meant to be invoked with the "Run Ruff" action?

---

_Comment by @koxudaxi on 2022-12-08 01:40_

This version runs `ruff --fix,` and it doesn't show any message, including an error from the command. 
I will expect to show the message in the `message window` like `console window` or/and highlight the code with the error message on the editor in future versions.
If ruff can inspect the code quickly, we can run the ruff by every user action(changing code).
Or, Can ruff partial inspection with cache?

---

_Comment by @fannheyward on 2022-12-08 01:59_

> Run `ruff --fix` for a file when the file is saved

I did `ruff` linting in coc-pyright, also provided `fix` code action to pick and use.

But for `ruff --fix` on save, I don't have a strong desire to add. Apply fixes on save may change the whole file that bring unpredictable changes.

This is my OWN opinion, what do you think for this feature?

---

_Comment by @koxudaxi on 2022-12-08 02:41_

> But for ruff --fix on save, I don't have a strong desire to add. Apply fixes on save may change the whole file that bring unpredictable changes.

The plugin is designed to prevent unexpected changes.
1. This is an optional feature. Users can enable the feature from the settings panel.
2. The plugin invokes `ruff` and gives the source code as stdin. And The plugin gets formatted code from stdout. `ruff` command doesn't write the file directly. PyCharm writes the file.
3. PyCharm manages the write action with exclusive access control. 

---

_Comment by @charliermarsh on 2022-12-08 04:00_

My general take is that fix-on-save should be entirely opt-in and disabled by default.

---

_Comment by @koxudaxi on 2022-12-08 04:14_

I agree with you. The feature is disabled by default. 

---

_Comment by @charliermarsh on 2022-12-08 17:36_

> If ruff can inspect the code quickly, we can run the ruff by every user action(changing code).

The Ruff VS Code plugin just runs constantly on the open file, I think it's fast enough to do it on-user-change.

---

_Comment by @tsugumi-sys on 2022-12-17 10:28_

Are there any plans for [helix-editor](https://github.com/helix-editor/helix) integration?

---

_Comment by @cole-jacobs on 2022-12-22 19:08_

> For instance, the moment we have a language server for ruff, I will try to contribute a client to Emacs https://github.com/emacs-lsp/lsp-mode so that I will be able to use it in Emacs. Similar would happen to all editors I am sure.

Any progress on this, @vikigenius ? Anything special I need to do to get this working in emacs?  


---

_Comment by @koxudaxi on 2022-12-23 00:34_

@charliermarsh 
I have published version v0.0.3 of the ruff pycharm plugin. 
I added the feature `inspection` and `quick fix`
Could you please try it? you can download it [marketplace](https://plugins.jetbrains.com/plugin/20574-ruff)
If you feel good, I want to put the link on the ruff documents. 
![quickfix](https://user-images.githubusercontent.com/630670/209247492-d79fdbb3-2f52-4ccd-af5f-0c60a9c38ab9.png)
![inspection](https://user-images.githubusercontent.com/630670/209247496-f1cfe9a8-6897-47ab-a518-0d334724f62e.png)


https://github.com/koxudaxi/ruff-pycharm-plugin

---

_Comment by @charliermarsh on 2022-12-23 02:46_

@tsugumi-sys - I bet that https://github.com/charliermarsh/ruff-lsp would work with Helix, it's just a matter of configuring it.

Same for Emacs @cole-jacobs.

I can try to figure out how to integrate with those editors and add instructions to the `ruff-lsp` docs -- there are already a few examples, for Neovim and Sublime Text -- but would also love PRs to that effect.


---

_Referenced in [astral-sh/ruff#1345](../../astral-sh/ruff/pulls/1345.md) on 2022-12-23 02:50_

---

_Comment by @charliermarsh on 2022-12-23 02:50_

Done, thanks @koxudaxi!

---

_Comment by @charliermarsh on 2022-12-23 02:50_

I'm going to close this for now since we have a good thing going with the LSP, VS Code extension, and so on. I'll file some issues on the LSP repo to figure out integrations with Emacs and Helix.

---

_Closed by @charliermarsh on 2022-12-23 02:50_

---

_Referenced in [astral-sh/ruff-lsp#18](../../astral-sh/ruff-lsp/issues/18.md) on 2022-12-23 02:51_

---

_Referenced in [astral-sh/ruff-lsp#19](../../astral-sh/ruff-lsp/issues/19.md) on 2022-12-23 02:51_

---

_Comment by @fannheyward on 2022-12-23 02:56_

coc.nvim + ruff-lsp https://github.com/neoclide/coc.nvim/wiki/Language-servers#using-ruff-lsp

```json
"languageserver": {
  "ruff-lsp": {
    "command": "ruff-lsp",
    "filetypes": ["python"]
  }
}
```

---

_Comment by @charliermarsh on 2022-12-23 03:00_

Amazing, thanks @fannheyward, I'll add those to the docs.

---

_Comment by @charliermarsh on 2022-12-23 03:14_

Added Helix docs in https://github.com/charliermarsh/ruff-lsp/pull/20 @tsugumi-sys.

---

_Comment by @tsugumi-sys on 2022-12-23 04:15_

@charliermarsh 
I can use ruff in my project now and Omg, ruff is so first and I love it! Thank you very much:)

---

_Comment by @charliermarsh on 2022-12-23 04:37_

Yay, thanks so much for the kind words!

---

_Comment by @kuator on 2022-12-23 17:02_

This is awesome!

---

_Comment by @charliermarsh on 2022-12-23 17:04_

I spent a little bit of time installing `lsp-mode` with Emacs but couldn't figure out how to get `ruff-lsp` to work with it, just too unfamiliar with Emacs. If anyone is able to set it up, and wants to contribute instructions, it would be hugely appreciated.

See: https://github.com/charliermarsh/ruff-lsp/issues/19.

---

_Comment by @charliermarsh on 2023-02-11 21:08_

@koxudaxi - Just wanted to say thanks again for building and maintaining the PyCharm plugin! I was playing with it today, and I love that you're surfacing the fix messages etc. in the UI.

---

_Comment by @koxudaxi on 2023-02-12 16:25_

@charliermarsh 
Last week, I added ruff to my project https://github.com/koxudaxi/datamodel-code-generator
After using ruff in the actual project, I am excited about ruff and the PyCharm integration.
I will continue to maintain and add features to the PyCharm plugin.

Thanks for the feedback and your fantastic project.

PS. After knowing your commit history on ruff. I contribute to OSS every day ðŸ˜¸ 

---
