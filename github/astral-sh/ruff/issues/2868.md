---
number: 2868
title: N805 False Positive
type: issue
state: closed
author: sharyar
labels: []
assignees: []
created_at: 2023-02-13T20:31:24Z
updated_at: 2023-12-03T19:39:35Z
url: https://github.com/astral-sh/ruff/issues/2868
synced_at: 2026-01-07T12:31:12-06:00
---

# N805 False Positive

---

_Issue opened by @sharyar on 2023-02-13 20:31_

<!--
Thank you for taking the time to report an issue! We're glad to have you involved with Ruff.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `ruff /path/to/file.py --fix`), ideally including the `--isolated` flag.
* The current Ruff settings (any relevant sections from your `pyproject.toml`).
* The current Ruff version (`ruff --version`).
-->

Noticed that ruff gives a false positive with pydantic validation method as shown here:

```python
class MyClass(BaseModel):
    name: str

    @validator('name')
    def name_validator(cls, v):
        if v is None:
            return "John Smith"
        else:
            return v

```
Running `ruff . --fix` gives me the following message: `...N805 First argument of a method should be named "self"`
Ruff Version: ruff 0.0.246

Sections from pyproject.toml:
```
[tool.ruff]
fix = true
line-length = 120
target-version = "py39"
select = ["I", "E", "F", "Q", "W", "N"]
ignore = [
    "F541",
    "N803",
    "N806",
    "Q000",
    "Q003",
]
[tool.ruff.pydocstyle]
convention = "numpy"

[tool.ruff.flake8-quotes]
avoid-escape = false
inline-quotes = "double"
docstring-quotes = "double"
multiline-quotes = "double"

[tool.ruff.isort]
known-first-party = [
    "tools"
]
```

---

_Comment by @g-as on 2023-02-13 20:33_

See https://github.com/charliermarsh/ruff#classmethod-decorators

and
https://github.com/PyCQA/pep8-naming/issues/169
https://github.com/PyCQA/pep8-naming/pull/39
for the context

---

_Comment by @charliermarsh on 2023-02-13 20:36_

Yeah you should be able to add:

```toml
[tool.ruff.pep8-naming]
# Allow Pydantic's `@validator` decorator to trigger class method treatment.
classmethod-decorators = ["classmethod", "pydantic.validator"]
```

...to help with this. But if that doesn't work, let us know!

---

_Closed by @charliermarsh on 2023-02-13 20:36_

---

_Comment by @sharyar on 2023-02-13 20:37_

Thank you! Will do :) 

---

_Comment by @charliermarsh on 2023-02-13 20:37_

Thanks for the clear issue.

---

_Comment by @sharyar on 2023-02-14 16:50_

Hi @charliermarsh, it looks like this doesn't work unfortunately. I have to manually disable the N805 check to force the error to go away. 

---

_Comment by @sharyar on 2023-02-14 16:52_

Here is part of my config file: 
![image](https://user-images.githubusercontent.com/9103610/218803637-ada7ad5b-45a4-47db-93b2-32b2647d0349.png)

And here is the error still showing up: 
![image](https://user-images.githubusercontent.com/9103610/218803773-88955901-301a-4404-a942-353d73755b48.png)


---

_Comment by @g-as on 2023-02-14 17:11_

```toml
[tool.ruff.pep8-naming]
# Allow Pydantic's `@validator` decorator to trigger class method treatment.
classmethod-decorators = ["classmethod", "validator"]
```
since you called the decorator with `@validator` (and not `@pydantic.validator`)

---

_Comment by @sharyar on 2023-02-14 18:34_

That does not work either sadly. Just tried it. 

---

_Comment by @charliermarsh on 2023-02-14 18:39_

I just tested myself and this works as expected for me:

```py
from pydantic import validator

class MyClass(BaseModel):
    name: str

    @validator('name')
    def name_validator(cls, v):
        if v is None:
            return "John Smith"
        else:
            return v
```

Along with:

```toml
[tool.ruff.pep8-naming]
# Allow Pydantic's `@validator` decorator to trigger class method treatment.
classmethod-decorators = ["classmethod", "pydantic.validator"]
```

Gives me empty output with `ruff foo.py --select N` (and an error if I remove `"pydantic.validator"` from that list).

Can you post the entire file? Are you perhaps importing `validator` from some other file?


---

_Comment by @sharyar on 2023-02-14 18:41_

I realized the issue. I was on an earlier version of ruff (my poetry.lock file cause me to go back a version). Sorry to bother you guys! Great job on the application! i heard about you on the python podcast and since then have been a convert :D Getting everyone to use it ðŸ‘ 

---

_Comment by @charliermarsh on 2023-02-14 18:43_

Amazing, thank you for the kind words! (I think this was broken for a release or two due to an internal refactor, but should be fixed in the last few.)

---

_Comment by @copdips on 2023-06-09 14:10_

> I just tested myself and this works as expected for me:
> 
> ```python
> from pydantic import validator
> 
> class MyClass(BaseModel):
>     name: str
> 
>     @validator('name')
>     def name_validator(cls, v):
>         if v is None:
>             return "John Smith"
>         else:
>             return v
> ```
> 
> Along with:
> 
> ```toml
> [tool.ruff.pep8-naming]
> # Allow Pydantic's `@validator` decorator to trigger class method treatment.
> classmethod-decorators = ["classmethod", "pydantic.validator"]
> ```
> 
> Gives me empty output with `ruff foo.py --select N` (and an error if I remove `"pydantic.validator"` from that list).
> 
> Can you post the entire file? Are you perhaps importing `validator` from some other file?

Thanks, and for me without classmethod is ok too.

```toml
[tool.ruff.pep8-naming]
classmethod-decorators = ["pydantic.validator"]
```

---

_Comment by @blakeNaccarato on 2023-12-01 18:13_

I was bit by this old issue again when bumping a project to Pydantic v2 while still using the old interface (e.g. `from pydantic.v1 import ...`). It's simple enough to fix, but it took me a minute to figure out, so I figured I'd detail it here in case a search engine brings you here as well. You must add `pydantic.v1.validator` to your `classmethod-decorators`.

```TOML
[tool.ruff.pep8-naming]
classmethod-decorators = ["pydantic.validator", "pydantic.v1.validator"]
```

---

_Comment by @charliermarsh on 2023-12-01 18:20_

Maybe we should just add those to the defaults.

---

_Comment by @blakeNaccarato on 2023-12-02 04:05_

That seems sensible, especially for something as big as Pydantic. Sorry, I didn't intend to make a feature request in a closed issue, just a tip for the wary. I can raise it properly in a new Issue if that helps keep track of it.

---

_Comment by @g-as on 2023-12-02 15:13_

Pydantic v2 allows to insert the `classmethod` decorator inbetween, specifically to play nice with linters & type checkers:

https://docs.pydantic.dev/latest/concepts/validators/#field-validators

```python
class UserModel(BaseModel):
    id: int
    name: str

    @field_validator('name')
    @classmethod
    def name_must_contain_space(cls, v: str) -> str:
        if ' ' not in v:
            raise ValueError('must contain a space')
        return v.title()
```

> @field_validators are "class methods", so the first argument value they receive is the UserModel class, not an instance of UserModel. We recommend you use the \@classmethod decorator on them below the @field_validator decorator to get proper type checking.

Same applies to `model_validator`.

So, IMHO, there is less need for special behaviour in ruff. I've removed my `[tool.ruff.pep8-naming]` overrides.

---

_Comment by @blakeNaccarato on 2023-12-03 19:38_

Also a fair point, I'll just leave the issue raising decision to the team. Either Pydantic's `@classmethod` recommendation or https://github.com/astral-sh/ruff/issues/2868#issuecomment-1836564993 are explicit, existing solutions with some repetition burden. Implicit defaults would eliminate repetition at the expense of more special-casing, a slippery slope. I would say that we're getting into bikeshedding, but I guess if there's anywhere that it's appropriate to bikeshed, it would be in the closed issue section of a linter/formatter.

---
