---
number: 6697
title: new rule - detect when decorators are in the wrong order
type: issue
state: open
author: DetachHead
labels:
  - rule
  - accepted
assignees: []
created_at: 2023-08-20T03:36:46Z
updated_at: 2025-01-27T14:24:02Z
url: https://github.com/astral-sh/ruff/issues/6697
synced_at: 2026-01-07T12:31:12-06:00
---

# new rule - detect when decorators are in the wrong order

---

_Issue opened by @DetachHead on 2023-08-20 03:36_

some examples:
```py
from collections.abc import Iterator
from contextlib import contextmanager


class Foo:
    @contextmanager
    @staticmethod
    def foo() -> Iterator[None]:
        yield None

    def bar(self):
        with self.foo():
            ...


Foo().bar() # TypeError: Foo.foo() takes 0 positional arguments but 1 was given
```
```py
from abc import abstractmethod

class Foo:
    @abstractmethod # AttributeError: attribute '__isabstractmethod__' of 'property' objects is not writable
    @property
    def foo(self) -> int:
        ...
```
both of these errors are fixed by swapping the order of the decorators

---

_Comment by @charliermarsh on 2023-08-20 14:16_

Would probably require that we maintain a set of known, proper orderings for the standard library decorators (like `@property`, etc.), but that's not too hard...

---

_Label `rule` added by @charliermarsh on 2023-08-21 04:15_

---

_Label `needs-decision` added by @charliermarsh on 2023-08-21 04:15_

---

_Comment by @namurphy on 2023-08-22 20:00_

Thank you for raising this issue!

I'm wondering if this rule could have a configuration option so that users could add their own decorator ordering rules.  Even if not needed for correctness, this could help improve consistency and readability.

There's also a chance that users might want to specify the order of â‰¥3 decorators...though this would quickly add complexity to the rule.  For â‰¥3 stacked decorators, a possible edge case would be when two decorators have to be in a certain order, but there might be a middle intervening decorator:

```python
from abc import abstractmethod

class Foo:
    @abstractmethod
    @here_be_dragons
    @property
    def foo(self) -> int:
        ...
```

I don't know if this happens often in the pythoniverse (hopefully not!), but I'm not sure what would be best to do in this case.  Perhaps it would be best for the rule to not be applied to cases with an intervening decorator.

---

_Comment by @zanieb on 2023-08-22 20:18_

I think adding configuration should generally be carefully considered only once we have a reasonable first implementation. I often get confused about the correct order of property / method decorators as well, I think this would be pretty useful even in a limited scope.

I'm not sure we should handle cases with interleaved decorators.



---

_Comment by @charliermarsh on 2023-08-22 20:39_

I like the idea of handling the known, common, invalid permutations from the standard library.

---

_Label `needs-decision` removed by @zanieb on 2023-08-22 21:26_

---

_Label `accepted` added by @zanieb on 2023-08-22 21:26_

---

_Comment by @namurphy on 2023-08-22 21:28_

Agreed on all of the above!  Perhaps my suggestion for a configuration option for this rule would be best brought up in a follow-up issue after this rule gets implemented for decorators in the standard library.  

For anyone curious about the use case motivating my suggestions, we use two decorators in PlasmaPy to process and validate arguments to functions and methods.  The order of the decorators matters when they are applied to instance or class methods.  When applied to class methods (which is admittedly rare), the `@classmethod` decorator would also be present. Right now, we handle the situation by noting this in admonitions in the docstring of [`@particle_input`](https://docs.plasmapy.org/en/stable/api/plasmapy.particles.decorators.particle_input.html#particle-input).  This use case motivates a configuration option, but I have no idea if it's a common enough use case to warrant adding the capability.

Thank you!

---

_Comment by @evanrittenhouse on 2023-08-25 21:07_

Feel free to assign this to me, I can take a look. Only major hurdle I see is the ordering of stdlib decorators. How would I even go about determining that?

---

_Assigned to @evanrittenhouse by @zanieb on 2023-08-26 00:33_

---

_Comment by @zanieb on 2023-08-26 00:44_

@evanrittenhouse basically by using them and seeing if they behave correctly at runtime.

The potentially relevant ones I can think of are:
- `abc.abstractmethod`
- `classmethod`
- `staticmethod`
- `property`
- `contextlib.contextmanager`
- `contextlib.asyncontextmanager`
- `functools.wraps`
- `functools.cache`
- `functools.cached_property` ([maybe helpful context](https://docs.python.org/3/faq/programming.html#faq-cache-method-calls))
- `functools.lru_cache`

---

_Comment by @DetachHead on 2023-08-26 00:48_

also `property.setter`

---

_Comment by @evanrittenhouse on 2023-08-26 04:53_

@zanieb Thanks for the list - was hoping there were some docs somewhere, but off to REPL I go... ðŸ˜„ 

---

_Referenced in [astral-sh/ruff#6965](../../astral-sh/ruff/pulls/6965.md) on 2023-08-29 03:25_

---

_Comment by @DetachHead on 2023-08-31 13:04_

also `@final` and `@deprecated`

for some reason it's apparently intended behavior for `@deprecated` to only work if there are no other decorators under it, even though there's no runtime error (https://github.com/microsoft/pylance-release/issues/4600#issuecomment-1632023633)

---

_Unassigned @evanrittenhouse by @evanrittenhouse on 2023-12-09 03:59_

---

_Comment by @irdkwmnsb on 2025-01-27 14:24_

I'm using ruff for a project of mine and wanted to add custom lint rules for my own decorators.  
If this feature gets implemented I would also really love the ability to specify my own order for the decorators.
For example when using with https://python-dependency-injector.ets-labs.org/wiring.html#decorator-inject

---
