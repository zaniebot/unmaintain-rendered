---
number: 3933
title: "Extend SLF001 to allow accessing private fields on \"other\" instance in binary operators?"
type: issue
state: closed
author: tpgillam
labels:
  - bug
  - type-inference
assignees: []
created_at: 2023-04-11T13:31:51Z
updated_at: 2024-02-17T10:46:39Z
url: https://github.com/astral-sh/ruff/issues/3933
synced_at: 2026-01-07T12:31:12-06:00
---

# Extend SLF001 to allow accessing private fields on "other" instance in binary operators?

---

_Issue opened by @tpgillam on 2023-04-11 13:31_

Suppose I run the follow code through ruff with the `SLF` module enabled, with Ruff 0.0.256:

```python
class Moo:
    def __init__(self, a: int):
        self._a = a

    def __eq__(self, other) -> bool:
        return isinstance(other, Moo) and self._a == other._a
```

Currently the last line will trigger `SLF001: private member access`, specifically the `other._a` call.

Since this is a fairly common pattern (and also within other binary operations, e.g. addition, multiplication), arguably it would be nice if this were permitted without a `# noqa` (*).

Is this something that could be addressed within Ruff? Or is the policy to first decide changes inside flake8-self, and then ensure that Ruff always replicates upstream exactly?

If it _were_ something that could be addressed within Ruff I'm not sure the best approach to implement it. It seems as though the current implementation relies on the string `"self"` being used, as opposed to noting what `self` would have been bound to given its position in the argument list to the method. A generalisation to the latter method could presumably also tag the _second_ object in e.g. `__eq__, __add__, __radd, ...` as "allowed to access private members"

(*) At least, everywhere I have worked has preferred this approach, as opposed to e.g. explicitly publicising any necessary internal state via properties.


---

_Label `type-inference` added by @charliermarsh on 2023-04-12 04:10_

---

_Comment by @charliermarsh on 2023-04-12 20:58_

I'm torn on this but find myself erring on the side of "it's a reasonable thing to expect" (that we wouldn't enforce `SLF` here).

We may be able to handle it in the common case with our current semantic analysis tools.


---

_Label `bug` added by @charliermarsh on 2023-04-12 20:58_

---

_Assigned to @charliermarsh by @charliermarsh on 2023-06-08 17:18_

---

_Referenced in [astral-sh/ruff#4968](../../astral-sh/ruff/pulls/4968.md) on 2023-06-08 17:29_

---

_Closed by @charliermarsh on 2023-06-08 17:36_

---

_Comment by @nickbutsky on 2024-02-17 10:46_

Is there any reasoning why it only would be allowed in dunder methods?

---
