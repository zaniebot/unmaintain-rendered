---
number: 20782
title: "`UP037` causes runtime errors in Python 3.14"
type: issue
state: closed
author: tylerlaprade
labels:
  - bug
  - fixes
  - needs-mre
assignees: []
created_at: 2025-10-09T09:18:51Z
updated_at: 2025-12-10T17:29:37Z
url: https://github.com/astral-sh/ruff/issues/20782
synced_at: 2026-01-07T12:31:13-06:00
---

# `UP037` causes runtime errors in Python 3.14

---

_Issue opened by @tylerlaprade on 2025-10-09 09:18_

### Summary

After upgrading to Ruff 0.14.0 and Python 3.14, I autofixed my codebase to remove thousands of quoted annotations, which is great. However, when I run my app, those names are undefined. If I add `from __future__ import annotations` to the file, the runtime errors go away, but
1. I did not think this would be needed, and
2. If it is needed, the autofix should've added it

*UPDATE:* The only two affected files both had `from django.db.models.signals import ModelSignal` in an `if TYPE_CHECKING` block, so that's likely related.

*UPDATE2:* Another file was affected, but it's only used in the Django admin portal, so I didn't notice. This one doesn't have `ModelSignal`, but it does have `SimpleLazyObject`

### Version

0.14.0

---

_Comment by @MichaReiser on 2025-10-09 09:36_

Thanks for reporting. Could you share a minified version of the code before UP037 rewrote it?

---

_Comment by @tylerlaprade on 2025-10-09 09:48_

@MichaReiser, here's one affected snippet. It was failing to find `CondorBaseModel`, which is a custom base class we've defined for all our Django objects. Ruff removed the quotes from the annotation.
```python3
    @abstractmethod
    def get_models(self) -> list['type[CondorBaseModel]']:
```
Any repro is going to have to be run as part of a Django project, so I can't easily show anything meaningful in the playground.

---

_Comment by @tylerlaprade on 2025-10-09 09:53_

Okay, so I played around with that file and found that it happens for this specifically and not other usages of `CondorBaseModel` annotations:
```python3
    def _make_log_create(self) -> Callable[..., None]:
        def _log_create(
            sender: type['CondorBaseModel'], instance: 'CondorBaseModel', created: bool, **kwargs
        ) -> None:
            if created:
                self.create_non_m2m_log_entry(
                    action=Action.CREATE, instance=instance, diff_old=None, diff_new=instance
                )

        return _log_create
```
I suspect my initial thought around specific Django imports was a red herring, and that it's actually just failing for annotations in nested function definitions.

---

_Comment by @tylerlaprade on 2025-10-09 09:55_

The other file it's failing in is trickier, though. In here, it's failing on `ModelSignal`:
```python3
@receiver(post_delete, sender=Forecast)
@receiver(post_delete, sender=ForecastFolder)
@receiver(post_soft_delete, sender=Forecast)
@receiver(post_soft_delete, sender=ForecastFolder)
def forecast_or_forecastfolder_deleted_callback(
    sender: type[Forecast | ForecastFolder],
    instance: Forecast | ForecastFolder,
    signal: 'ModelSignal',
    **kwargs,
) -> None:
```
Presumably this is due to some kind of introspection performed by `@receiver`.

---

_Comment by @ntBre on 2025-10-09 13:37_

Coincidentally, https://github.com/astral-sh/ruff/issues/6510 also appeared in my notifications this morning. I wonder if we should be respecting the [runtime-evaluated-base-classes](https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-base-classes) and [runtime-evaluated-decorators](https://docs.astral.sh/ruff/settings/#lint_flake8-type-checking_runtime-evaluated-decorators) settings from the TC rules in `UP037` too?

I guess it might not make sense to reuse those directly, but something similar seems helpful here.

---

_Comment by @kamikaze on 2025-10-09 16:46_

same here

---

_Label `bug` added by @MichaReiser on 2025-10-09 17:02_

---

_Label `fixes` added by @MichaReiser on 2025-10-09 17:02_

---

_Comment by @MichaReiser on 2025-10-09 17:03_

CC: @dylwil3 We might need to mark the rule as unsafe for Python 3.14 if there's no from future import

---

_Comment by @dylwil3 on 2025-10-10 19:31_

I'm still trying to understand this a bit better, and it would help if I could reproduce it. In one of your comments you said this:

> I suspect my initial thought around specific Django imports was a red herring, and that it's actually just failing for annotations in nested function definitions.

Can you provide a minimal reproducible example that doesn't have anything to do with Django? If not - could you provide a minimal reproducible example that does involve Django (but include the full steps to reproduce)?

---

_Comment by @danparizher on 2025-10-13 05:40_

I was able to reproduce this with the following snippet:
```py
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Tuple, List

class CustomModel:
    """A custom model class that simulates Django's behavior"""
    pass

def outer_function():
    """Outer function that returns a function with annotations"""
    
    def inner_function_with_annotation(
        sender: "type[CustomModel]", 
        instance: "CustomModel", 
        created: bool, 
        **kwargs
    ) -> None:
        """Inner function with type annotations that may be evaluated at runtime"""
        if created:
            print(f"Created instance: {instance}")
    
    return inner_function_with_annotation
```

I think the problem lies here - from what I understand, `checker.semantic().in_runtime_evaluated_annotation()` is not correctly detecting runtime-evaluated contexts: https://github.com/astral-sh/ruff/blob/0e8c02aea68e75e8d86030bc182b98613f86824b/crates/ruff_linter/src/rules/pyupgrade/rules/quoted_annotation.rs#L104-L110

---

_Comment by @dylwil3 on 2025-10-13 18:03_

Thanks for the investigation! Unfortunately I'm still having trouble reproducing the actual error here. Maybe I'm missing steps or something obvious? I copied and pasted your snippet into `ex.py` and then did:

```console
❯ uvx python3.14 ex.py

❯ ruff check --isolated --no-cache --select UP037 --target-version py314 ex.py --output-format concise
ex.py:14:17: UP037 [*] Remove quotes from type annotation
ex.py:15:19: UP037 [*] Remove quotes from type annotation
Found 2 errors.
[*] 2 fixable with the `--fix` option.

❯ ruff check --isolated --no-cache --select UP037 --target-version py314 ex.py --fix
Found 2 errors (2 fixed, 0 remaining).

❯ uvx python3.14 ex.py
```

No runtime errors. I also tried adding a call to `outer_function` which did not produce an error either.

---

_Label `needs-mre` added by @dylwil3 on 2025-10-13 18:08_

---

_Comment by @tylerlaprade on 2025-10-13 18:25_

@dylwil3, what if you call the function returned by `outer_function`?

---

_Comment by @dylwil3 on 2025-10-13 18:55_

Still no error

```pycon
>>> from typing import TYPE_CHECKING
...
... if TYPE_CHECKING:
...     from typing import Tuple, List
...
... class CustomModel:
...     """A custom model class that simulates Django's behavior"""
...     pass
...
... def outer_function():
...     """Outer function that returns a function with annotations"""
...
...     def inner_function_with_annotation(
...         sender: type[CustomModel],
...         instance: CustomModel,
...         created: bool,
...         **kwargs
...     ) -> None:
...         """Inner function with type annotations that may be evaluated at runtime"""
...         if created:
...             print(f"Created instance: {instance}")
...
...     return inner_function_with_annotation
...
>>> outer_function()(CustomModel,CustomModel(),True)
Created instance: <__main__.CustomModel object at 0x10355d010>
>>> outer_function()(CustomModel,CustomModel(),False)
```

---

_Referenced in [astral-sh/ruff#21120](../../astral-sh/ruff/issues/21120.md) on 2025-10-29 14:58_

---

_Comment by @MichaReiser on 2025-12-10 17:29_

I'll close this because I think we still don't have an MRE? Happy to re-open if someone can provide an MRE (or can describe cases where the fix causes runtime errors)

---

_Closed by @MichaReiser on 2025-12-10 17:29_

---
