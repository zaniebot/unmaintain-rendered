---
number: 6878
title: "F841 \"Undefined name\" false positive in exception-nested-closure"
type: issue
state: open
author: ndevenish
labels:
  - needs-decision
assignees: []
created_at: 2023-08-25T17:09:03Z
updated_at: 2025-03-07T18:26:28Z
url: https://github.com/astral-sh/ruff/issues/6878
synced_at: 2026-01-07T12:31:12-06:00
---

# F841 "Undefined name" false positive in exception-nested-closure

---

_Issue opened by @ndevenish on 2023-08-25 17:09_

ruff 0.0.285.

Using an exception value in a nested function erroneously triggers F841 and F821, even though python is fine with the usage.

This same issue occurs in flake8/https://github.com/PyCQA/pyflakes/issues/265; if ruff is aiming for bug-for-bug compatibility then this is working as intended.

Minimal reproduction stolen from that issue as it's shorter than my example (my example was a nested-def; lambda seems to work the same):
```python
try:
    assert False
except Exception as e:
    lambda: e
```

```
% ruff t.py
t.py:3:21: F841 [*] Local variable `e` is assigned to but never used
t.py:4:13: F821 Undefined name `e`
Found 2 errors.
[*] 1 potentially fixable with the --fix option.
```

Edit: To note that since this is "fixable", allowing ruff to fix will break the code by removing the `as e`

---

_Comment by @charliermarsh on 2023-08-25 21:25_

Interesting... I was a little surprised that this code worked at all given the semantics around bound exceptions:

```python
try:
    1/0
except Exception as e:
    func = lambda: print(e)
    func()
```

But I then realized that this version _does_ lead to a `NameError` (`NameError: name 'e' is not defined`):

```python
try:
    1/0
except Exception as e:
    func = lambda: print(e)

func()
```

Although neither Mypy nor Pyright catch this.

I'm not exactly sure how to handle. I'll have to think on it. My initial reaction is that our behavior is reasonable since the variable could be unbound depending on when the lambda is called, but it would be nice not to remove the `as e` there when autofixing.


---

_Label `needs-decision` added by @charliermarsh on 2023-08-25 21:25_

---

_Comment by @ndevenish on 2023-08-25 21:56_

This was obviously a contrived, extremely minimised example case; the linked pyflakes issue noted the same behaviour.

The actual code this was encountered on is below; a sub-function using [rich](https://github.com/Textualize/rich) [group](https://rich.readthedocs.io/en/latest/group.html) decorator to conveniently wrap a whole set of renderables into a panel - in a name that is never used outside of the exception scope:
```python
try:
    ...
except requests.exceptions.HTTPError as e:

    @rich.console.group()
    def _error_output():
        yield Text(str(e), style="bold red")
        yield ""
        yield f"The request: {e.request.url}"
        req_text = e.request.body
        if e.request.headers["content-type"] == "application/json":
            req_text = JSON(e.request.body)
        yield Padding(req_text, (0, 0, 1, 4))
        yield "Error response:"
        resp_text = e.response.text
        if e.response.headers["content-type"] == "application/json":
            resp_text = JSON(e.response.text)
        yield Padding(resp_text, (0, 0, 1, 4))

    print(Panel(_error_output()))
```
obviously the code could be written to do this a different way. But it's definitely not an F821 undefined name, or an F841 variable assigned but not used.

---

_Comment by @charliermarsh on 2023-08-25 22:10_

Totally understand!

What I'm trying to convey is that it's difficult to guarantee that this is completely safe, as you have to ensure that the function or lambda is only called within the scope of the exception block.

Even in the example above, what if `@rich.console.group()` stores a reference to the function and executes it at a later point in time? What if `_error_output` is imported by another module?

Given that Python unbinds `e` as soon as the exception block exits, I would almost always recommend re-binding `e` to another variable if you're going to access it in a potentially-deferred manner. Is there any downside to that? I feel like the best we could plausibly do here is detect that `e` is used in such a context and emit a more targeted diagnostic.


---

_Comment by @ndevenish on 2023-08-25 22:18_

I could see an “Exception-bound variable used in closure” diagnostic being potentially useful, and easily `# ignore`-a-ble. Perhaps the documentation for the diagnostic could explicitly suggest passing it in as a parameter

That would also solve the problem of `—fix` outright breaking the code (so would still have to work out how to stop this diagnostic)

---

_Comment by @zanieb on 2023-08-26 00:58_

Interesting example! I think I'd recommend refactoring `error_output()` to `error_to_rich_output(e: Exception)` and moving it out of the exception block. Perhaps we should have coverage for this in another rule and/or as Charlie said improve the specificity of this diagnostic but I don't think this is pattern the linter should be expected to be happy with. 

For what it's worth, there are a few duplicates reports of this issue over in pyflakes so this is a confusing thing that people encounter.

---

_Referenced in [tinygrad/tinygrad#2473](../../tinygrad/tinygrad/pulls/2473.md) on 2023-11-27 22:35_

---

_Referenced in [astral-sh/ruff#14521](../../astral-sh/ruff/issues/14521.md) on 2024-11-23 07:14_

---

_Comment by @FranciscoKnebel on 2025-01-03 20:42_

Had this same error: an except defining a variable, using it inside a lambda and auto-fix breaking the code.
I'm disabling this rule so it doesn't break code and re-adding the removed variable.

I understand it's a bad pattern and the method should be refactored, but the variable _exists_, so it is a false positive.

---

_Comment by @ewall-ot on 2025-03-07 15:23_

I'm not sure if this error is related, but I'll mention here I'm seeing F841 (assigned to but never used) triggered as a false alarm in code like this:
```
try:
    assert False
except Exception as e:
    print(f'Error: {e}')
```

---

_Comment by @ntBre on 2025-03-07 17:46_

@ewall-ot this might be a different issue. In fact, I'm having some trouble triggering F841 on your example with recent versions of ruff:

```python
# try.py

def f():
        try:
            assert False
        except Exception as e:
            print(f'Error: {e}')
```

```shell
# shell output

> ruff check try.py --select F841 --diff
> echo $?
0
```

I can reproduce the F841 with the original issue code, though.

---

_Comment by @ewall-ot on 2025-03-07 18:26_

Thanks for the response, @ntBre. Sorry, I thought I was on the latest version of ruff but clearly was a bit behind, because sure enough this isn't reproducible on the latest, along with a related one I had noticed (F401 "unused-import" if the imported module was only used inside the f-string).

Nice to see this product under such active development!

---

_Referenced in [VOICEVOX/voicevox_engine#1563](../../VOICEVOX/voicevox_engine/pulls/1563.md) on 2025-03-22 01:18_

---

_Referenced in [astral-sh/ruff#19612](../../astral-sh/ruff/issues/19612.md) on 2025-07-30 12:17_

---
