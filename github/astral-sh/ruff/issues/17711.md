---
number: 17711
title: PyUpgrade autofix fails when objects stem from factory
type: issue
state: closed
author: TrevorWinstral
labels:
  - question
assignees: []
created_at: 2025-04-29T14:47:29Z
updated_at: 2025-05-02T08:10:34Z
url: https://github.com/astral-sh/ruff/issues/17711
synced_at: 2026-01-07T12:31:13-06:00
---

# PyUpgrade autofix fails when objects stem from factory

---

_Issue opened by @TrevorWinstral on 2025-04-29 14:47_

### Summary

Using Python 3.10, I have the following code:

```python
from threading import RLock
from typing import Optional

def fn(lock: Optional[RLock]) -> None:
    """Dummy."""
    if lock is None:
        print("Lock is None")
        return
    else:
        with lock:
            print("Lock aquired")
```
Which is perfectly viable and functional code.

I have this in my `pyproject.toml`
```toml
[tool.ruff]
line-length = 80
target-version = "py310"
```

When I run `ruff check --fix`, I get the following:

```python
from threading import RLock

def fn(lock: RLock | None) -> None:
    """Dummy."""
    if lock is None:
        print("Lock is None")
        return
    else:
        with lock:
            print("Lock aquired")

```

Which when run yields:

```
Traceback (most recent call last):
  File "/home/twinstral/Documents/Projects/capital-iq-afl/capitalafl/models/twinstral/mwe.py", line 8, in <module>
    def fn(lock: RLock | None) -> None:
TypeError: unsupported operand type(s) for |: 'function' and 'NoneType'
```

This is because the `RLock` object is actually a factory function. The actual type is private in threading, so this breaks my code. This is fixed in 3.12 so adding the following line: `from __future__ import annotations` fixes my issue. I have FA selected in the `tool.ruff.lint` section of my `pyproject.toml` and I believe this should have caught that. 

### Version

ruff 0.11.7

---

_Comment by @ntBre on 2025-04-29 21:16_

It sounds like [future-required-type-annotation (FA102)](https://docs.astral.sh/ruff/rules/future-required-type-annotation/#future-required-type-annotation-fa102) is the `FA` rule that could have caught this, but its docs say:

> As such, this rule will only flag such usages if your project targets Python 3.9 or below.

So it sounds like your `target-version` is high enough to disable the check.

I'm not a typing expert, so I could certainly be wrong here, but it kind of sounds like your original annotation wasn't strictly correct since `Rlock` isn't a type, it just didn't get evaluated inside of `typing.Optional`.

It looks like @AlexWaygood commented on a related [CPython issue](https://github.com/python/cpython/issues/114315), and he'd know better than me anyway.

---

_Label `question` added by @ntBre on 2025-04-29 21:16_

---

_Comment by @TrevorWinstral on 2025-04-30 07:55_

I agree that the original typing wasn't strictly correct, however running ruff then 'broke' the code, which is probably unexpected behavior, no? And the type hint works just fine when it is standalone, only when combined with the `|` operator does it act as a function.

This code runs as expected:

```python
from threading import RLock


def fn(lock: RLock) -> None:
    """Dummy"""
    with lock:
        print("Aquired lock")


fn(RLock())
```

So the typing works as expected when using `RLock` and when using `Optional[RLock]`, and only `RLock | None` fails, which is the change made by ruff.

---

_Comment by @Daverball on 2025-05-01 21:52_

There are bunch of factory functions in the standard library that are exported as types in typeshed for convenience, so you don't have to import a private type, but this problem isn't unique to the standard library. This sort of issue can occur in any code where the type annotations are provided through third party stubs and the annotations make some convenient lies about the runtime type of objects in order to improve the ergonomics of interacting with the API when making use of type annotations.

While we could certainly enumerate the places where this sort of issue can occur in the standard library and prevent fixes/violations from being emitted in those cases, I'm not fully convinced it's worth it, considering it can happen with third party dependencies too. We could maybe think about adding a setting for faux-types, but it would be difficult to ensure that all the rules and fixes take that setting into account properly.

Generally my stance is, if you're fine with using `from __future__ import annotations`, you should just be using it in every file (apart from empty `__init__.py` files). That way you get more consistent behavior. I personally think the `FA` rules are kind of bad, since you'll end up with a mix of stringized and proper annotations, depending purely on whether or not it would allow to modernize some type expressions.

Edit: The only somewhat maintainable solution I can think of, is adding new rules that detect and flag runtime uses of `__or__` and `__class_getitem__` on faux-types and surrounding those runtime uses with quotes, so they're no longer runtime uses. But that would still be awkward if you want the annotation to be runtime introspectable, so then you'd be back to having to add exceptions to the `pyupgrade` rules. So the value of something like that would still be questionable.

---

_Closed by @TrevorWinstral on 2025-05-02 08:10_

---

_Referenced in [astral-sh/ruff#18619](../../astral-sh/ruff/issues/18619.md) on 2025-06-11 01:13_

---

_Referenced in [astral-sh/ruff#19144](../../astral-sh/ruff/issues/19144.md) on 2025-07-04 14:42_

---
