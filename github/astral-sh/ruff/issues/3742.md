---
number: 3742
title: "`UP035` is showing as unfixable, when I would expect it to be fixable"
type: issue
state: closed
author: samuelcolvin
labels: []
assignees: []
created_at: 2023-03-26T15:35:14Z
updated_at: 2023-03-26T23:30:12Z
url: https://github.com/astral-sh/ruff/issues/3742
synced_at: 2026-01-07T12:31:12-06:00
---

# `UP035` is showing as unfixable, when I would expect it to be fixable

---

_Issue opened by @samuelcolvin on 2023-03-26 15:35_

I'm trying to use ruff as a replacement for pyupgrade when generating docs with different examples for different python versions, however I immediately ran into a problem where "errors" which I would expect to be fixable, are coming back as unfixable, specifically `UP035`.

---

Run `ruff --select U --target-version py310 --fix test.py` on the following code.

```py
from datetime import datetime
from typing import List, Optional
from pydantic import BaseModel


class User(BaseModel):
    id: int
    name: str = 'John Doe'
    signup_ts: Optional[datetime] = None
    friends: List[int] = []
```

I'm getting the following error:

```
test.py:2:1: UP035 `typing.List` is deprecated, use `list` instead
Found 3 errors (2 fixed, 1 remaining).
```

I would expect `UP035` to be fixable

(updated to use code before running `--fix`)

---

_Comment by @charliermarsh on 2023-03-26 16:05_

Can elaborate when I’m back at my computer, but the immediate workaround would be to enable the F rules. The “fix” is to remove the unused import, since List is now unused (presumedly), and the UP rules alone don’t handle unused import removals.

---

_Comment by @samuelcolvin on 2023-03-26 16:30_

amazing, I'll try that.

---

_Comment by @samuelcolvin on 2023-03-26 18:59_

works great, however interestingly still significantly slower than pyupgrade when invoked via subprocess for each code snippet.

---

_Closed by @samuelcolvin on 2023-03-26 18:59_

---

_Comment by @charliermarsh on 2023-03-26 19:57_

Yeah I guess the subprocess overhead is probably non-negligible in that context. We should benchmark that against a proper `pyo3` API. We could probably ship a `pyo3` API _relatively_ quickly... the main blocker is deciding whether we want to support it or whether there's some other style of programmatic usage we might prefer instead (vague handwave-y statement, not suggesting any specific alternative right now).


---

_Comment by @JonathanPlasse on 2023-03-26 20:09_

I started working on a `pyo3` API.
Currently, it takes a toml string as configuration.
I only implemented lint checks.
The lint function returns a wrapper of `Message`.
https://github.com/JonathanPlasse/ruff-api/blob/main/src/lib.rs

---

_Comment by @samuelcolvin on 2023-03-26 21:05_

In my experience the overhead of a pyo3 function call is ~80us, much much less than spinning up a process.

You could run ruff as a server and pipe data to it in this case, but in general it would be much less ergonomic than a python API.

---

_Comment by @charliermarsh on 2023-03-26 21:11_

Yeah that's probably the most notable alternative: run Ruff as an LSP or something. Another would be to make a more flexible command-line API, e.g., something that takes JSON in and spits JSON out but supports all these use-cases. I expect that we'll end up shipping a `pyo3` API over those options.

---

_Comment by @samuelcolvin on 2023-03-26 23:30_

You could ship a rust crate, then build a python API package using the rust crate, just to keep the current package small and simple.

---
