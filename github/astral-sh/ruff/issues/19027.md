---
number: 19027
title: Improve detection of redundant parenthesis
type: issue
state: open
author: robsdedude
labels:
  - rule
  - needs-decision
assignees: []
created_at: 2025-06-29T15:43:38Z
updated_at: 2025-09-12T14:50:02Z
url: https://github.com/astral-sh/ruff/issues/19027
synced_at: 2026-01-07T12:31:13-06:00
---

# Improve detection of redundant parenthesis

---

_Issue opened by @robsdedude on 2025-06-29 15:43_

### Summary

## Problem Statement

I'm maintaining a flake8 plugin that (besides some other things) lints on redundant parenthesis: https://github.com/robsdedude/flake8-picky-parentheses

It covers many more cases compared to `UP034`. Examples are
```python
a = (("a"),)  # same as `a = ("a",)`
a = (1 + 2)  # same as `a = 1 + 2`
a = foo(*(a))  # same as `a = foo(*a)`
foo[(1):]  # same as `foo[1:]`
```

## Proposed Solution
The plugin works by implementing a more complex and therefore computation costly algorithm:
 * For each statement:
   * *optional for optimization*: Replace the body of the statement if any with a placeholder, e.g., turn a function's body into  `pass`
   * Tokenize statement and find each parens pair in the statement
   * Compute/get AST `ast_baseline`
   * For each parens pair:
     * on a copy of the statement, remove the pair and compute the AST
     * if the AST is different from `ast_baseline` :
       * parens were necessary; do nothing for this pair
     * else, if not in one of the exception cases (s. below):
       * emit the lint

By not operating on the token level, but the AST level, many more cases can be covered at the cost of this being potentially much slower.

## Open Questions
A while back I asked on Discord if there's interest in integrating such functionality into `ruff`, but I didn't get a decisive answer.

 * Are you interested in Ruff supporting such a check?
 * How to go about managing the runtime cost?
   * Maybe make it a different, opt-in rule with the docs stating the drawback
   * Maybe make it config option for `UP035` something like `thorough-extraneous-parentheses`

## Exceptions to the Rule
(redundant parenthesis that wouldn't trigger the lint)

<details>

<summary>quote from plugin's `README`</summary>

> [...] there are some notable exceptions to this rule:
>  1. Parentheses for tuple literals.
>  2. A single pair or parentheses in expressions to highlight operator
>     precedence.
>     Even if these parentheses are redundant, they help to divide parts of
>     expressions and show sequence of actions.
>  3. Parts of slices.
>  4. Multi-line<sup>1)</sup> expression, `if` and `for` parts in comprehensions.
>  5. Multi-line<sup>1)</sup> keyword arguments or argument defaults.
>  6. String concatenation over several lines in lists, tuples, and function arguments.
> 
> ### Footnotes
> 
> 1. Multi-line means that either
>    * the expression spans multiple lines, e.g.,
>      ```python
>      (a
>       + b)
>      ```
>    * or the first part of the expression is on a new line (e.g., if a name is very long), e.g.,
>      ```python
>      (
>          veeeeeeeeeeery_looooooong_name
>      )
>      ```
>      but also
>      ```python
>      (
>          a
>          + b
>      )
>      ```
>    Multi-line expressions do **not** include
>    ```python
>    (a + b
>    )
>    ```
</details>


## Related
 * https://github.com/astral-sh/ruff/issues/2389

---

_Label `rule` added by @ntBre on 2025-06-30 13:08_

---

_Label `needs-decision` added by @ntBre on 2025-06-30 13:08_

---

_Comment by @ntBre on 2025-06-30 13:13_

I think it sounds interesting, I use the "remove redundant parentheses" code action from rust-analyzer fairly often. That does sound like an expensive approach, though. We may want to try exploring other potential designs first.

---

_Comment by @MichaReiser on 2025-07-07 08:55_

As a note. The formatter already handles many of those cases. There are also cases where the parentheses are technically not necessary but can improve readability or help to split the code over multiple lines (because Python...). 

Overall, I don't think the generic approach described in the summary works for us because it doesn't guarantee formatter compatibility. It would have to be a more opinionated set of rules.

---

_Comment by @robsdedude on 2025-07-07 10:27_

> not necessary but can improve readability

That's exactly what the list of exceptions is for. If there are cases missing, it's easy enough to add them.

> help to split the code over multiple lines

In those cases, the parentheses are likely actually necessary. Because 
```python
a = (
    something_very_long + something_that_is_even_longer
)
```
yields a valid AST while (same code with parens stripped)
```python
a = 
    something_very_long + something_that_is_even_longer

```
is a syntax error.

> doesn't guarantee formatter compatibility

Would the formatter ever produces parentheses where it's not necessary?

I've already started to POC the approach, just because I'm curious. I fully appreciate that the work might go straight into the trash bin as you're both not very convinced ðŸ˜¬ I still want to see where it leads me. @MichaReiser are there any tests that check for linter-formatter compatibility in the code base? If so, could you kindly point me towards them?

---

_Comment by @MichaReiser on 2025-07-07 14:23_

> I still want to see where it leads me. @MichaReiser are there any tests that check for linter-formatter compatibility in the code base? If so, could you kindly point me towards them?


I don't think there are any. Sorry

> yields a valid AST while (same code with parens stripped)

That's true. Although I'm not convinced that calling the parser for every parenthesized expression will give us good performance. I'd expect a more handcrafted implementation similar to the [`NeedsParentheses` trait in biomejs](https://github.com/biomejs/biome/blob/2649ac625de963bf7411368cdd06142bda362322/crates/biome_js_syntax/src/parentheses/mod.rs#L49)

---

_Comment by @robsdedude on 2025-07-07 15:28_

> Although I'm not convinced that calling the parser for every parenthesized expression will give us good performance

Yes, that's my biggest concern as well as written initially. Assuming that AST parsing is in polynomial complexity `O(n^p_ast)` (I guess `p_ast` might even be `1`), then the proposed algorithm has a complexity of `O(n_line_len^(p_ast + 1) * n_line_num)` where `n_line_len` is the length of the longest logical line and `n_line_num` is the number of logical lines in the file. 

My thought is, while you theoretically can write an insanely long logical line, I expect typical Python programs to have a fairly limited max line length, especially if the author cares about readability and maintainability - which I'd argue is indicated by them using ruff in the first place.

Now what all the big O notation fluff does deliberately not account for is the constant factor. That's exactly why I want to POC the idea to see what performance would look like for a long but still reasonable logical line length (say 10 lines filled with 80 characters or so).

Thanks so far for your thoughts and the biomejs link. I'll see if there's some inspiration I can draw from there :)

---

_Comment by @flying-sheep on 2025-09-12 14:50_

I just came across `some_func(foo=("bar"))`. I think these parentheses should definitely be removed, they only serve into confusing people to thing that this is a tuple.

---
