---
number: 8601
title: Suppress RUF100 (unused noa) if we see a PGH004 (blanket noqa) error?
type: issue
state: open
author: alanhdu
labels:
  - suppression
  - needs-decision
assignees: []
created_at: 2023-11-10T14:47:09Z
updated_at: 2023-11-11T15:25:27Z
url: https://github.com/astral-sh/ruff/issues/8601
synced_at: 2026-01-07T12:31:12-06:00
---

# Suppress RUF100 (unused noa) if we see a PGH004 (blanket noqa) error?

---

_Issue opened by @alanhdu on 2023-11-10 14:47_

This is potentially a very niche request, but I was wondering if there was a way to suppress RUF100 errors for blanket noqa when PGH004 is enabled (and `external` lints are on)?

Right now, we live in a monorepo with flake8 configured along with our particular sub-codebase's `ruff` linting. The monorepo wide linting also comes with some company-specific error codes that we use the [`external`](https://docs.astral.sh/ruff/settings/#external) setting for. Unfortunately, we're hitting a problem with blanket noqas -- things like:

```
some_code_that_triggers_internal_lint # noqa
```

which triggers RUF100 when the *real* problem is that it should be annotated with `# noqa: <internal>`. I was hoping to use `PGH004` instead to flag these blanket noqa, but am running into two problems:

* Such errors will trigger two lints (unnecessary noqa and needs a specific error code). This is a little confusing, b/c the error code is actually the one users should pay attention to.
* The RUF100 autofix will delete the `# noqa`, even when it's necessary to silence the monorepo wide flake8.

I think the two things that'd help us with the ruff roll out are to:

* Change the RUF100 to be an unsafe-fix for blanket noqa if `external` is specified
* If PGH004 *and* RUF100 both trigger on the same noqa, only emit the PGH004 lint error (maybe hidden behind some flag)?

Would that make sense? Not sure if this is a reasonable thing to support our if our setup is too idiosyncratic.

---

_Comment by @charliermarsh on 2023-11-11 15:25_

Yeah I totally see the issue here. I think the second suggestion is going to be challenging, since we really prefer to keep rule behavior independent of the set of enabled rules (that is, we really want rules to operate independently, such that enabling or disabling one rule shouldn't affect the behavior of another). Breaking that principle can lead to confusing interactions, e.g., if you run `ruff check` with `RULE` in your `pyproject.toml` vs. `ruff check --select RULE`, you could then see different diagnostics for `RULE` if it relies on enabled codes. (I should admit that `RUF100` is the one rule that actually _does_ suffer from this problem, since it can only detect whether a `# noqa` is used for the _enabled_ rules, but it at least tells you which rules are known-but-disabled codes.)

A few options, which may all be bad, I'm not sure:

1. Change the RUF100 to be an unsafe-fix for blanket noqa if `external` is specified (as proposed above -- this seems reasonable).
1. Don't flag `RUF100` on blank `# noqa` _at all_ if `external` is enabled.
3. If `external` is enabled, consider making the `RUF100` fix such that we add the external codes to a blanket `# noqa`? I don't know how long `external` gets in practice.

---

_Label `noqa` added by @charliermarsh on 2023-11-11 15:25_

---

_Label `needs-decision` added by @charliermarsh on 2023-11-11 15:25_

---
