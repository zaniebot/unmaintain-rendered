---
number: 5559
title: "`TCH` setting to autofix with conversion to string"
type: issue
state: closed
author: smackesey
labels:
  - core
assignees: []
created_at: 2023-07-06T11:46:36Z
updated_at: 2023-12-13T03:12:39Z
url: https://github.com/astral-sh/ruff/issues/5559
synced_at: 2026-01-07T12:31:12-06:00
---

# `TCH` setting to autofix with conversion to string

---

_Issue opened by @smackesey on 2023-07-06 11:46_

Currently the `TCH` (`flake8-type-checking`) rules require annotations to be stored as strings (i.e. not evaluated). Annotations are stored a strings if:

- The annotations are string literals (i.e. are quoted)
- The annotations are in a module with `from __future__ import annotations` (which causes evaluation of all annotations in the module to be skipped)
- The annotations are of local variables (the Python interpreter does not evaluate local variable annotations)

One approach to getting `TCH` autofix working is to inject `from __future__ import annotations` into all your source modules (using `I002`). This is not ideal because string annotations unavoidably break code that meets these conditions:

1. annotations are being created in a local scope
2. an annotation references a symbol only available in that local scope
3. the annotation must be operated on at runtime

Here is an example of code meeting these conditions:

```
def make_bar():
    class Bar:
        ...

    def bar(x: "Bar"):
        ...
    return bar

bar = make_bar()

# `bar` has a string annotation-- if we want to operate on it, we need to evaluate it. This requires
# calling `get_type_hints`, but this fails because "Bar" can't be dereferenced since referent `Bar`
# vanished with local scope
get_type_hints(bar)  # => NameError: name 'Bar' is not defined.
```

We have plenty of code meeting these conditions in Dagster (mostly in tests), so my [experiment](https://github.com/dagster-io/dagster/pull/14675) in injecting `from __future__ import annotations` to enable `TCH` autofix has failed. Other projects that use runtime type annotation introspection are likely to encounter the same issues.

Therefore, a significant enhancement to `TCH` autofix would be to detect where annotations _could_ be stored as strings, and perform a targeted conversion for you using quoting. Example:

```
from threading import Lock

def foo(lock: Lock):
    ...
```

After applying `TCH` autofix:

```
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from threading import Lock

def foo(lock: "Lock"):
    ...
```

This would make `TCH` autofix a lot more useful for us and probably many other projects.

---

_Referenced in [dagster-io/dagster#14675](../../dagster-io/dagster/pulls/14675.md) on 2023-07-06 11:52_

---

_Comment by @charliermarsh on 2023-07-06 13:54_

Yeah, I agree this would be useful. I'm not yet certain how hard it is to get right, but I agree that it would be useful... flake8-type-checking has rules for this, which we could look at for reference: https://pypi.org/project/flake8-type-checking/.

> annotations are being created in a local scope.

Can you give an example of this, just to illustrate the problem?


---

_Label `core` added by @charliermarsh on 2023-07-06 13:54_

---

_Comment by @smackesey on 2023-07-06 14:04_

>Can you give an example of this, just to illustrate the problem?

I updated OP with an example.

---

_Referenced in [astral-sh/ruff#5753](../../astral-sh/ruff/issues/5753.md) on 2023-07-14 01:41_

---

_Comment by @charliermarsh on 2023-07-14 20:28_

Thanks. I think it will be difficult to reliably determine whether an annotation is required at runtime ðŸ˜“ 


---

_Comment by @smackesey on 2023-07-14 20:48_

>I think it will be difficult to reliably determine whether an annotation is required at runtime

Haven't thought it all the way through, but can't you just see if the only uses of a symbol are inside non-local type annotations, while also applying the existing settings used to special case e.g. Pydantic? Maybe determining scoping is harder than I think.

---

_Comment by @charliermarsh on 2023-07-14 21:02_

Can you explain what you mean in terms of this example? (I.e., why `x: Bar` can't be quoted.)

```python
def make_bar():
    class Bar:
        ...

    def bar(x: Bar):
        ...

    return bar

bar = make_bar()

print(get_type_hints(bar))
```

---

_Comment by @smackesey on 2023-07-14 21:08_

>Can you explain what you mean in terms of this example? (I.e., why x: Bar can't be quoted.)

- With `x: Bar` (unquoted case), `bar.__annotations__["x"]` stores a direct reference to `Bar`.
- When `x: "Bar"` (quoted case), `bar.__annotations__["x"]` stores the string `"Bar"`.
- When `get_type_hints(bar)` is applied, Python tries to resolve each annotation
    - If it's a type, just return it.
    - If it's as string, dereference it.
- When Python tries to dereference the string "Bar", it comes up empty and throws a `NameError`.

I'm not sure why Python fails in exactly this scenario. I guess the defining module for the object holding the annotations is known, so Python is able to look up the referent of string annotations if they exist in the defining module's `__dict__`.

---

_Comment by @charliermarsh on 2023-07-14 21:10_

But, does "whether we can quote it" depend on whether and when `get_type_hints` is called? Or is there a more robust and general methodology we can follow?

---

_Comment by @smackesey on 2023-07-14 21:15_

>But, does "whether we can quote it" depend on whether and when get_type_hints is called? Or is there a more robust and general methodology we can follow?

I would say just be conservative and always assume that `get_type_hints` might be called-- so if it references a local scope symbol, don't quote it.

In practice referencing local scope symbols is going to be pretty rare in 99% of Python code anyway.

---

_Comment by @charliermarsh on 2023-07-14 21:16_

Ah I see -- so we would avoid quoting annotations that rely on symbols defined outside of the module scope.

---

_Comment by @charliermarsh on 2023-07-14 22:30_

It's also a little less critical for the TCH rules in particular since we're only dealing with imported symbols. But I suppose if the import itself is within a function scope...

---

_Referenced in [astral-sh/ruff#6001](../../astral-sh/ruff/pulls/6001.md) on 2023-07-23 04:42_

---

_Comment by @charliermarsh on 2023-07-23 04:44_

I have something that I've been testing against Dagster here: https://github.com/astral-sh/ruff/pull/6001. The outputs look correct to me -- one example:

```diff
--- a/examples/assets_smoke_test/assets_smoke_test/pure_python_assets.py
+++ b/examples/assets_smoke_test/assets_smoke_test/pure_python_assets.py
@@ -1,5 +1,9 @@
+from typing import TYPE_CHECKING
+
 from dagster import SourceAsset, TableSchema, asset
-from pandas import DataFrame
+
+if TYPE_CHECKING:
+    from pandas import DataFrame

 raw_country_populations = SourceAsset(
     "raw_country_populations",
@@ -19,7 +23,7 @@


 @asset
-def country_populations(raw_country_populations) -> DataFrame:
+def country_populations(raw_country_populations) -> "DataFrame":
     country_populations = raw_country_populations.copy()
     country_populations["change"] = (
         country_populations["change"]
@@ -32,13 +36,13 @@ def country_populations(raw_country_populations) -> DataFrame:


 @asset
-def continent_stats(country_populations: DataFrame) -> DataFrame:
+def continent_stats(country_populations: "DataFrame") -> "DataFrame":
     result = country_populations.groupby("continent").agg({"pop2019": "sum", "change": "mean"})
     return result


 @asset
-def country_stats(country_populations: DataFrame, continent_stats: DataFrame) -> DataFrame:
+def country_stats(country_populations: "DataFrame", continent_stats: "DataFrame") -> "DataFrame":
     result = country_populations.join(continent_stats, on="continent", lsuffix="_continent")
     result["continent_pop_fraction"] = result["pop2019"] / result["pop2019_continent"]
     return result
```

But not sure how best to check whether the rule is having any unintended effects on runtime behavior.

---

_Comment by @tylerlaprade on 2023-07-23 16:04_

If there's an easy way for me to locally run a preview version of Ruff, I'm happy to run your enhanced rule on my private codebase and verify the runtime behavior. Obviously would be easier if someone else has a large open-source codebase to test on, though.

---

_Comment by @charliermarsh on 2023-07-23 16:08_

Thanks! I can kick off a release build dry-run which will generate wheel files that you can download and `pip install`. I'll post here with the link.

---

_Comment by @charliermarsh on 2023-07-23 16:43_

If you'd like, you can click [here](https://github.com/astral-sh/ruff/actions/runs/5637406313), download the "Wheels" at the bottom, unzip, and `pip install` the wheel that matches your platform.

---

_Comment by @tylerlaprade on 2023-07-23 16:52_

This looks much more comprehensive than when I made `from __future__ import annotations` required (which barely modified anything)! I really like the looks of it. However, a runtime error has been introduced that doesn't get detected by my typechecker:

<img width="570" alt="image" src="https://github.com/astral-sh/ruff/assets/5475199/597ebbd3-de0f-4b8b-aa38-5df63452a40d">

<img width="535" alt="image" src="https://github.com/astral-sh/ruff/assets/5475199/494ac5ac-9ed6-4b7d-9993-7ee0d314a40e">

<img width="492" alt="image" src="https://github.com/astral-sh/ruff/assets/5475199/1be5355e-a95d-473f-8b88-3528432e85f0">



---

_Comment by @tylerlaprade on 2023-07-23 17:15_

I did a global find-and-replace to convert `"(\w+)" \| None` to `$1 | None`. This fixed all my runtime issues (at least until I re-ran Ruff).

EDIT: The above find-and-replace loses some of the benefits of this rule. Replacing with `"$1 | None"` is much better for two reasons:
1. It retains the performance benefits of this rule.
2. It does not get undone when re-running Ruff.

---

_Comment by @charliermarsh on 2023-07-23 17:31_

Oh yes, that case makes sense, we need handle it. Thanks so much for testing it out!

---

_Comment by @smackesey on 2023-07-24 13:16_

The above outputs look good to me, as long as there's a setting to avoid applying the rule to functions with certain decorators (and IIRC this already exists).

>But not sure how best to check whether the rule is having any unintended effects on runtime behavior.

Potential unintended runtime effects are unavoidable since people could always be accessing `.__annotations__` and performing arbitrary logic with it. But as long as those annotations aren't coming from local scope, they can be easily worked around by changing direct `.__annotations__` access to use `typing.get_type_hints`.

---

_Comment by @charliermarsh on 2023-07-26 20:09_

I'm blocked on supporting unions (e.g., when quoting `DataFrame` in `DataFrame | int`, you need to quote the entire union, like `"DataFrame | int"`). There are just a bunch of edge cases and we don't have access to the full AST when constructing the fix (so we need to do manual lexing). This might require some new infrastructure to be fully robust.

---

_Comment by @tylerlaprade on 2023-07-26 20:50_

Totally understandable. For now, is there value in shipping it with an exclusion to not add quotes to any types involving unions? It still seemed like a major improvement over `from __future__ import annotations` when I tested the preview.

---

_Closed by @charliermarsh on 2023-12-13 03:12_

---
