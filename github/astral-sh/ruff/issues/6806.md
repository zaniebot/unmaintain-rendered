---
number: 6806
title: Kind request for pylint rule E0110
type: issue
state: closed
author: shager
labels:
  - rule
assignees: []
created_at: 2023-08-23T09:13:52Z
updated_at: 2024-04-05T07:40:56Z
url: https://github.com/astral-sh/ruff/issues/6806
synced_at: 2026-01-07T12:31:12-06:00
---

# Kind request for pylint rule E0110

---

_Issue opened by @shager on 2023-08-23 09:13_

Hello,

I would like to ask whether it would be possible for one of the ruff developers to implement the pylint rule "E0110" (abstract-class-instantiated).
Here is an example for a code that produces a finding with pylint:
```python
import abc


class A(abc.ABC):
    @abc.abstractmethod
    def f(self):
        """abstract"""


class B(A):
    pass

    @abc.abstractmethod
    def f(self):
        """still abstract"""


def main():
    b = B()     # <--------- there should be a finding here 


if __name__ == "__main__":
    main()
```

The relevant pylint output is:
```
...
blub.py:19:8: E0110: Abstract class 'B' with abstract methods instantiated (abstract-class-instantiated)
...
```

Thank you very much in advance!

---

_Comment by @charliermarsh on 2023-08-25 21:44_

Thank you for the kind issue :)

I'm going to merge this into the broader Pylint tracking issue #970. We can definitely implement this, but until we support multi-file analysis (analyzing code _across_ files), we'd only be able to detect this for instantiations of classes in the file in which they're defined.


---

_Closed by @charliermarsh on 2023-08-25 21:44_

---

_Label `rule` added by @charliermarsh on 2023-08-25 21:44_

---

_Comment by @ChaserZ98 on 2024-04-05 07:40_

New Ruff user here. Is there any plan of implementing this rule and abstract-method W0223 this year? It would help a lot in developing OO projects.

---
