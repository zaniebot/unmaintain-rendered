---
number: 18513
title: "Proposal: Disallow Instance Variable Shadowing of Class Variable Annotations"
type: issue
state: open
author: stacey-gammon
labels:
  - rule
  - needs-decision
assignees: []
created_at: 2025-06-06T20:07:12Z
updated_at: 2025-06-10T09:27:11Z
url: https://github.com/astral-sh/ruff/issues/18513
synced_at: 2026-01-07T12:31:13-06:00
---

# Proposal: Disallow Instance Variable Shadowing of Class Variable Annotations

---

_Issue opened by @stacey-gammon on 2025-06-06 20:07_

### Summary

## Background

I've encountered some potentially problematic patterns in our codebase regarding Python class and instance variable declarations. Specifically, I'm concerned about the pattern where a class-level type annotation is shadowed by an instance variable:

```python
class Foo:
    bar: str  # Class-level annotation
    
    def __init__(self, bar: str):
        self.bar = bar  # Instance variable shadowing
```

## The Problem

This pattern can lead to subtle bugs and confusion:

1. The class-level annotation suggests `bar` is a class variable, but it's actually used as an instance variable
2. Can lead to bugs if someone intends it to be instance but forgets to initialize in the init method. e.g.:


```python
class Foo:
    bar: list[str] = [] 
    
    def __init__(self, bar: str):
        # self.bar = [] oops forgot to do this - 
  
    def add(elem: str):
       self.bar.append(elem). # oops - adding to class var not instance var!
```

## Current State of Guidance

There's some tension in the Python ecosystem about this pattern:

- [Robusta.dev](https://home.robusta.dev/blog/common-python-mistakes-mixing-up-instance-and-class-members) explicitly calls this out as a common mistake
- PEP 526 seems to suggest this pattern is acceptable, showing examples like:
  ```python
  class BasicStarship:
      captain: str = 'Picard'               # instance variable with default
      damage: int                           # instance variable without default
  ```

This part of PEP 526 seems wrong because of the problem example above - if I don't override `self.bar = []` in the init method, it's a class var.

## Proposed Rule

I suggest we add a linting rule that flags instances where a class-level type annotation is shadowed by an instance variable assignment in `__init__`. The clearer pattern would be:

```python
class Foo:
    def __init__(self, bar: str):
        self.bar: str = bar  # Type annotation at point of instance creation
```

I have been playing around with an AST parser that does this and there are some corner cases I encountered:
- pydantic models
- SQLAlchemy models
- frozen dataclasses
- typed dicts

Those classes would probably need to be excluded.

## Questions
1. Is this even considered an anti-pattern? (unclear)
2. Are there legitimate use cases where shadowing is actually desired?


---

_Comment by @ntBre on 2025-06-06 20:46_

There are a few related rules here:
- [implicit-class-var-in-dataclass (RUF045)](https://docs.astral.sh/ruff/rules/implicit-class-var-in-dataclass/#implicit-class-var-in-dataclass-ruf045)
- [mutable-class-default (RUF012)](https://docs.astral.sh/ruff/rules/mutable-class-default/#mutable-class-default-ruf012)
- [mutable-dataclass-default (RUF008)](https://docs.astral.sh/ruff/rules/mutable-dataclass-default/#mutable-dataclass-default-ruf008)
- [function-call-in-dataclass-default-argument (RUF009)](https://docs.astral.sh/ruff/rules/function-call-in-dataclass-default-argument/#function-call-in-dataclass-default-argument-ruf009)

RUF012, in particular, should catch the mutable default case, like the `list` example, which I think is the main confusing case.

---

_Comment by @s-banach on 2025-06-08 14:50_

If you want to write a Protocol, declaring all the attributes at the "class level" is the way to do it:

```python
class Example(Protocol):
    x: str
    y: str
    z: ClassVar[str]

    def f(self) -> list[str]: ...
```

For me, this is the problem with existing tooling:
I can write `Example.x = "hello"`, and my type checker doesn't raise an error.
It should not be permissible to access an attribute at the class level if it is not declared as a `ClassVar`!

For that reason, the example from PEP 526 should be considered problematic.
(Annotating `captain` as an instance variable, but instantiating the value `captain = "Picard"` at the class level.)


---

_Label `rule` added by @ntBre on 2025-06-08 15:44_

---

_Label `needs-decision` added by @ntBre on 2025-06-08 15:44_

---

_Comment by @MichaReiser on 2025-06-10 09:27_

I think the problem with such a rule (as s-banach pointed out) is that `x: str` can be either a class or instance variable. If you want to be explicit, you have to use `ClassVar` like this, in which case PyRight will warn about the assignment to `self.bar`


```py
from typing import ClassVar

class Foo:
    bar: ClassVar[list[str]]
    
    def __init__(self, bar: str):
        self.bar = [] # warning here
        pass
  
    def add(self, elem: str):
       self.bar.append(elem)
```

---
