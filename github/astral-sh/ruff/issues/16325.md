---
number: 16325
title: RUF010 has false positives and false negatives
type: issue
state: closed
author: dscorbett
labels:
  - bug
assignees: []
created_at: 2025-02-23T16:13:50Z
updated_at: 2025-06-26T15:53:53Z
url: https://github.com/astral-sh/ruff/issues/16325
synced_at: 2026-01-07T12:31:13-06:00
---

# RUF010 has false positives and false negatives

---

_Issue opened by @dscorbett on 2025-02-23 16:13_

### Description

[`explicit-f-string-type-conversion` (RUF010)](https://docs.astral.sh/ruff/rules/explicit-f-string-type-conversion/) has many errors in Ruff 0.9.7.

If the argument to `ascii`, `repr`, or `str` is a comprehension or display for a set or dictionary, the rule does not report it.
```console
$ cat >ruf010_1.py <<'# EOF'
print(f"{ascii({})}")
# EOF

$ ruff --isolated check --select RUF010 ruf010_1.py
All checks passed!
```
That false negative is intentional, to fix #5530, but a better solution is to add a space as `ruff format` does.
```python
print(f"{ {}!a}")
```

Skipping those comprehensions and displays does not fix that problem anyway. If the argument starts with one but continues further, the rule introduces a syntax error.
```console
$ cat >ruf010_2.py <<'# EOF'
print(f"{ascii({} | {})}")
# EOF

$ ruff --isolated check --select RUF010 ruf010_2.py --diff 2>&1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.
```

The fix is suppressed when the conversion function expression is not exactly `ascii`, `repr`, or `str`. Since the rule is able to detect equivalent expressions it should be able to fix them.
```console
$ cat >ruf010_3.py <<'# EOF'
import builtins
print(f"{builtins.ascii(1)}")
print(f"{ð‘Žð‘ ð‘ð‘–ð‘–(1)}")
# EOF

$ ruff --isolated check --select RUF010 ruf010_3.py --output-format concise
ruf010_3.py:2:10: RUF010 Use explicit conversion flag
ruf010_3.py:3:10: RUF010 Use explicit conversion flag
Found 2 errors.
```

The fix for an expression followed by an equals sign is not safe, because it changes behavior. In that specific case, the fix should be marked unsafe or should be suppressed.
```console
$ cat >ruf010_4.py <<'# EOF'
print(f"{ascii(1)=}")
# EOF

$ python ruf010_4.py
ascii(1)='1'

$ ruff --isolated check --select RUF010 ruf010_4.py --fix
Found 1 error (1 fixed, 0 remaining).

$ cat ruf010_4.py
print(f"{1=!a}")

$ python ruf010_4.py
1=1
```

RUF010 introduces a syntax error when the argument is an unparenthesized lambda expression. The fix should add parentheses around the lambda expression.
```console
$ cat >ruf010_5.py <<'# EOF'
print(f"{ascii(lambda: 1)}")
# EOF

$ ruff --isolated check --select RUF010 ruf010_5.py --diff 2>&1 | grep error:
error: Fix introduced a syntax error. Reverting all changes.
```

When the argument is an unparenthesized assignment expression, the fix misinterprets the colon of the `:=` as the sigil of a format specifier. The fix should add parentheses around the assignment expression.
```console
$ cat >ruf010_6.py <<'# EOF'
x = 1
print(f"{ascii(x := 2)}")
# EOF

$ python ruf010_6.py
2

$ ruff --isolated check --select RUF010 ruf010_6.py --fix
Found 1 error (1 fixed, 0 remaining).

$ python ruf010_6.py
Traceback (most recent call last):
  File "ruf010_6.py", line 2, in <module>
    print(f"{x := 2!a}")
            ^^^^^^^^^^
ValueError: Invalid format specifier '= 2!a' for object of type 'int'
```

The fix deletes the star from a starred expression. RUF010 should be suppressed in that context.
```console
$ cat >ruf010_7.py <<'# EOF'
args = (b"\xa1", "latin-1")
print(f"{str(*args)}")
# EOF

$ python ruf010_7.py
Â¡

$ ruff --isolated check --select RUF010 ruf010_7.py --fix
Found 1 error (1 fixed, 0 remaining).

$ cat ruf010_7.py 
args = (b"\xa1", "latin-1")
print(f"{args!s}")

$ python ruf010_7.py
(b'\xa1', 'latin-1')
```

---

_Label `bug` added by @dylwil3 on 2025-02-23 19:12_

---

_Comment by @LaBatata101 on 2025-06-15 23:04_

For the last case just the fix should be suppressed right?

---

_Referenced in [astral-sh/ruff#18690](../../astral-sh/ruff/pulls/18690.md) on 2025-06-15 23:25_

---

_Comment by @ntBre on 2025-06-16 18:24_

> For the last case just the fix should be suppressed right?

I think it makes sense to suppress the whole rule. That's what we do currently for this case, for example:

```python
print(f"{str(b"\xa1", "latin-1")}")
```

I think we can treat `*args` just like multiple positional arguments and avoid the diagnostic. I don't think the lint would be very actionable for `*args` anyway since the behavior is so different from actually calling `str`.

---

_Comment by @ntBre on 2025-06-16 18:31_

I think we also technically have a false negative in the presence of keyword arguments, which appear to be valid for `str` only:

```pycon
>>> str(object=args[0])
"b'\\xa1'"
>>> repr(object=args[0])
Traceback (most recent call last):
  File "<python-input-7>", line 1, in <module>
    repr(object=args[0])
    ~~~~^^^^^^^^^^^^^^^^
TypeError: repr() takes no keyword arguments
>>> ascii(object=args[0])
Traceback (most recent call last):
  File "<python-input-8>", line 1, in <module>
    ascii(object=args[0])
    ~~~~~^^^^^^^^^^^^^^^^
TypeError: ascii() takes no keyword arguments
```

That's not clear in the online docs (e.g. for [`ascii`](https://docs.python.org/3/library/functions.html#ascii)), but the signature in `help(ascii)` does show the positional-only indicator: `ascii(obj, /)`.

---

_Comment by @MichaReiser on 2025-06-25 08:21_

> When the argument is an unparenthesized assignment expression, the fix misinterprets the colon of the := as the sigil of a format specifier. The fix should add parentheses around the assignment expression.

This is also either a bug in CPython's parser or in our parser (CC: @dhruvmanila )

Edit: Never mind, this isn't a syntax error, it's a runtime error.

---

_Comment by @dhruvmanila on 2025-06-25 08:37_

Not sure I follow but as I already typed this out I'll send it :)

That looks correct to me because named expression in f-string interpolation requires parentheses so the `:` token would be interpreted as the start of a format specifier. The issue is in the fix generation, named and lambda expressions should be parenthesized.

---

_Closed by @MichaReiser on 2025-06-26 15:53_

---
