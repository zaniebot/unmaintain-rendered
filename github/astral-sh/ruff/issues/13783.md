---
number: 13783
title: non-pep585-annotation rule throws incorrectly for Type on Python <3.9
type: issue
state: closed
author: Stealthii
labels: []
assignees: []
created_at: 2024-10-16T20:30:25Z
updated_at: 2024-10-16T21:49:25Z
url: https://github.com/astral-sh/ruff/issues/13783
synced_at: 2026-01-07T12:31:13-06:00
---

# non-pep585-annotation rule throws incorrectly for Type on Python <3.9

---

_Issue opened by @Stealthii on 2024-10-16 20:30_

Related: #10290, #2981, #12256

PEP 585 allows usages like `list[X]` to be used in type annotations and type aliases. In Python 3.7 and 3.8 this syntax can be used in type annotations if paired with `from __future__ import annotations`. However, support for `type[X]` was only added in Python 3.9 (see [typing.Type](https://docs.python.org/3/library/typing.html#typing.Type) documentation).

Ruff 0.6.9 (and earlier) incorrectly raises an UP006 (non-pep585-annotation) against uses of `typing.Type` in typehints when Python Version is set to < 3.9:
```
â¯ ruff check --config "target-version='py38'" --select UP
src/example.py:137:26: UP006 Use `type` instead of `Type` for type annotation
    |
136 |     @classmethod
137 |     def from_string(cls: Type[Bytes], string: str) -> Bytes:
    |                          ^^^^ UP006
138 |         """Convert a string to an int of bytes."""
139 |         return cls(HumanBytes.convert(string))
    |
    = help: Replace with `type`
```

---

_Comment by @sbrugman on 2024-10-16 21:37_

Hi @Stealthii,

The rule is guarded against <= Python 3.8 unless `from __future__ import annotations` is imported. Support for `type` is added in 3.9, but can be enabled by importing annotations just as for `list`, `tuple`, `set`.

You can verify that this works:
```python filename="hello.py"
from __future__ import annotations
from functools import partial

def func(a: type[object]):
    return a


print(func(partial))
```

```shell
uv run --python 3.8 pep585.py
```

prints

```text
<class 'functools.partial'>
```

Whereas without the import a type error is produced:

```text
    def func(a: type[object]):
TypeError: 'type' object is not subscriptable
```

---

_Comment by @Stealthii on 2024-10-16 21:44_

@sbrugman flip you're right. Disregard this report as invalid - I incorrectly reported this against an instance that did have future annotations enabled, when investigating a mixed library. Also mis-diagnosed based on an [SO answer](https://stackoverflow.com/a/46092347) that was not using future annotations in its example.

---

_Closed by @Stealthii on 2024-10-16 21:44_

---
