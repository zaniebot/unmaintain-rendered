---
number: 6199
title: "[feature request]: custom lint rule for unittest mock.side_effect"
type: issue
state: open
author: upstartjohnvandivier
labels:
  - rule
  - needs-decision
assignees: []
created_at: 2023-07-31T15:16:33Z
updated_at: 2023-08-07T15:09:42Z
url: https://github.com/astral-sh/ruff/issues/6199
synced_at: 2026-01-07T12:31:12-06:00
---

# [feature request]: custom lint rule for unittest mock.side_effect

---

_Issue opened by @upstartjohnvandivier on 2023-07-31 15:16_

as a developer, I would like ruff to lint two improper uses of .side_effect, so that I can avoid hard-to-troubleshoot issues in writing unit tests and I can improve readility and test performance:
1. side_effect arrays with a length less than two
2. side_effect arrays where each element is the same value

eg:
```python
# error
foo.side_effect = [bar]
foo.side_effect = [bar, bar]

# prefer to above
foo.return_value = bar

# okay usage
foo.side_effect = [bar, baz]
```

---

_Renamed from "custom lint rule for unittest mock.side_effect" to "[feature request]: custom lint rule for unittest mock.side_effect" by @upstartjohnvandivier on 2023-07-31 15:19_

---

_Referenced in [pytest-dev/pytest#11267](../../pytest-dev/pytest/issues/11267.md) on 2023-07-31 23:24_

---

_Comment by @upstartjohnvandivier on 2023-08-03 15:04_

possibly a separate rule: If the side_effect is set to a function that returns a constant, that's also non-preferred to return_value

---

_Label `needs-decision` added by @charliermarsh on 2023-08-03 23:53_

---

_Comment by @charliermarsh on 2023-08-03 23:54_

Can you refresh my memory, what's the problem with these usages?

```python
# error
foo.side_effect = [bar]
foo.side_effect = [bar, bar]
```

---

_Label `rule` added by @charliermarsh on 2023-08-03 23:54_

---

_Comment by @upstartjohnvandivier on 2023-08-04 14:23_

this usage is intent breaking and unintuitive; if you set a mock to return a value, that is not a side effect and it is a use case for `.return_value`

further, when we do return values with side_effect, it is intended to provide [different values for different calls](https://docs.python.org/3/library/unittest.mock.html#the-mock-class). For example, side_effect can be set to a function that returns conditional on the arguments it receives. Setting it to a constant, or a function that returns a constant, or an array with equal values; those are all antipatterns

at least, many developers see it this way :) I'm not advocating whether this rule is enabled by default. just that it exists. otherwise I will end up making a custom linter which isn't ideal

---

_Comment by @zanieb on 2023-08-04 14:43_

What happens if you set a single return value side-effect and call the function multiple times? 

---

_Comment by @upstartjohnvandivier on 2023-08-04 14:50_

> a single return value side-effect

for an ordinary value like the int 3, this is simply illegal. you will get `TypeError: 'int' object is not an iterator`

then, the special value behavior depends on its type. Above we discuss problems with a mock value.

the normal case of a non-functional assignment would be a list, and the side_effect would return the ith value at the ith call. So it kind of extends `.return_value` by maintaining its internal call_count and returning at that index

---

_Referenced in [pytest-dev/pytest-mock#376](../../pytest-dev/pytest-mock/issues/376.md) on 2023-08-04 14:55_

---

_Comment by @upstartjohnvandivier on 2023-08-04 14:59_

I just added a feature request to pytest-mock to similar effect: It would outright fail a spec on improper usage rather than catching it at linting time. I would eagerly point out two benefits of adding this to ruff invariant to whether they accept the feature request:
1. The actual projects where I use ruff and pytest don't currently include pytest-mock. I would have to add an additional dep if ruff doesn't support this.
2. Ruff is many times faster than running the unit test suite. So, for rapid developer feedback it would be nice to have this rule whether or not the test will later fail.

---

_Comment by @upstartjohnvandivier on 2023-08-04 15:51_

Python language proposal created at https://discuss.python.org/t/feat-unittest-mock-side-effect-fails-on-improper-usage/31003

Support is welcome

---

_Comment by @zanieb on 2023-08-04 17:21_

I meant

```python
from unittest.mock import MagicMock

foo = MagicMock()

foo.side_effect = [1]

print(foo())
print(foo())
```

which will throw a stop iteration error on the second call. The meaning _changes_ when you use `return_value = x` instead of `side_effect = [x]` in that the mock can be called more times now without error. For this reason, I'd be hesitant to automatically change this declaration although it may be reasonable to suggest the change still.

Additionally, side-effects have different meanings for exception types, e.g.

```python
from unittest.mock import MagicMock

foo = MagicMock()
foo.return_value = ValueError()
foo()  # Does not raise


bar = MagicMock()
bar.side_effect = [ValueError()]
bar()  # Raises
```

I'm curious to see where the discussion goes upstream.

---

_Comment by @upstartjohnvandivier on 2023-08-04 19:33_

> The meaning changes when you use return_value

Yes, the StopIteration error is one of the hard to troubleshoot test issues that I referred to. I've never seen it actually intended. It generally represents a mis-implemented test in the codebases that I work in, rather than an expected effect of the method under test.

One of the benefits of this ruff lint rule would be early detection of such cases, without the need to run a full test suite. However, this ruff rule would also prevent other issues beyond that.

> Additionally, side-effects have different meanings for exception

Yes. This is the main and proper use case for .side_effect, not a special additional consideration. This feature request would allow this use, not flag it. Those cases using exceptions are proper side effects: `z = bar()` wouldn't return a `ValueError` as you wrote it. It would throw the error as a side effect. z wouldn't be assigned a value of `ValueError`.

Further, `bar.side_effect = [ValueError(), ValueError(), ValueError()]` would be extremely weird. I've never seen a need for that. tests will generally error on the first invocation. Even if such code were written, I think the developer intent would probably be like "I call foo three times and always get a value error" not "I call foo four times and get three value errors then a stop iteration error". For the expected intent, `bar.side_effect = ValueError()` is more readable, intuitive, less prone to unexpected errors, etc

I think `bar.side_effect = ValueError()` is generally preferred to `bar.side_effect = [ValueError()]`, so I think the length check lgtm, but if we want to apply a special exception for a list of errors I would still consider that better than the state without any lint rule. Did that make sense?

---
