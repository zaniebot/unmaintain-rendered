---
number: 13291
title: "[internal] `ComparableExpr` docstring does not match behavior"
type: issue
state: closed
author: dylwil3
labels:
  - internal
assignees: []
created_at: 2024-09-09T05:38:15Z
updated_at: 2024-09-25T14:58:58Z
url: https://github.com/astral-sh/ruff/issues/13291
synced_at: 2026-01-07T12:31:13-06:00
---

# [internal] `ComparableExpr` docstring does not match behavior

---

_Issue opened by @dylwil3 on 2024-09-09 05:38_

In the docstring for `ComparableExpr`, it says:

https://github.com/astral-sh/ruff/blob/e1603e3dca680d76e9e5a3fe9b832dd05b3b8e11/crates/ruff_python_ast/src/comparable.rs#L14-L16

However, the following test for that behavior fails:

```rust
#[cfg(test)]
mod tests {
    use ruff_text_size::TextRange;

    use crate::{self as ast, comparable::ComparableExpr, StringLiteralFlags};
    #[test]
    fn compare_concatenated_string_to_value() {
        let concatenated_string_expr: ast::Expr = ast::ExprStringLiteral {
            range: TextRange::default(),
            value: ast::StringLiteralValue::concatenated(vec![
                ast::StringLiteral {
                    range: TextRange::default(),
                    value: "a".into(),
                    flags: StringLiteralFlags::default(),
                },
                ast::StringLiteral {
                    range: TextRange::default(),
                    value: "b".into(),
                    flags: StringLiteralFlags::default(),
                },
            ]),
        }
        .into();
        let string_expr: ast::Expr = ast::ExprStringLiteral {
            range: TextRange::default(),
            value: ast::StringLiteralValue::single(ast::StringLiteral {
                range: TextRange::default(),
                value: "ab".into(),
                flags: StringLiteralFlags::default(),
            }),
        }
        .into();

        assert_eq!(
            ComparableExpr::from(&concatenated_string_expr),
            ComparableExpr::from(&string_expr)
        );
    }
}
```

If we want the docstring to match the behavior then probably these snippets

https://github.com/astral-sh/ruff/blob/e1603e3dca680d76e9e5a3fe9b832dd05b3b8e11/crates/ruff_python_ast/src/comparable.rs#L781-L784

https://github.com/astral-sh/ruff/blob/e1603e3dca680d76e9e5a3fe9b832dd05b3b8e11/crates/ruff_python_ast/src/comparable.rs#L1025-L1029

should be modified - presumably `comparable::ExprStringLiteral` should just have a `value` not `parts`, and the match arm should populate that field with the computed value?

Same goes for bytes and fstrings.

---

_Comment by @MichaReiser on 2024-09-09 11:40_

Storing a `&str` or `&[u8]` for `ExprStringLitral`/`BytesLiteral` does make sense to. 

I went back and noticed that we changed this behavior in https://github.com/astral-sh/ruff/pull/7927. There's an unresolved comment https://github.com/astral-sh/ruff/pull/7927/files#r1399535432 which makes me think that this indeed was unintentional. @dhruvmanila, do you remember if this was an intentional change?

---

_Label `internal` added by @MichaReiser on 2024-09-09 11:40_

---

_Comment by @dhruvmanila on 2024-09-09 14:03_

I think that might have been an unintentional change, I can't remember the reasoning behind it.

---

_Comment by @dylwil3 on 2024-09-09 16:19_

Great! So for string, I think I can do the following two changes:

```diff
diff --git a/crates/ruff_python_ast/src/comparable.rs b/crates/ruff_python_ast/src/comparable.rs
index bdc80bfbe..aaf4411f9 100644
--- a/crates/ruff_python_ast/src/comparable.rs
+++ b/crates/ruff_python_ast/src/comparable.rs
@@ -780,7 +780,7 @@ pub struct ExprFString<'a> {
 
 #[derive(Debug, PartialEq, Eq, Hash)]
 pub struct ExprStringLiteral<'a> {
-    parts: Vec<ComparableStringLiteral<'a>>,
+    value: ComparableStringLiteral<'a>,
 }
 
 #[derive(Debug, PartialEq, Eq, Hash)]
@@ -1024,7 +1024,9 @@ impl<'a> From<&'a ast::Expr> for ComparableExpr<'a> {
             }
             ast::Expr::StringLiteral(ast::ExprStringLiteral { value, range: _ }) => {
                 Self::StringLiteral(ExprStringLiteral {
-                    parts: value.iter().map(Into::into).collect(),
+                    value: ComparableStringLiteral {
+                        value: value.to_str(),
+                    },
                 })
             }
             ast::Expr::BytesLiteral(ast::ExprBytesLiteral { value, range: _ }) => {

```

But I think I need some Rust help for what to do with the `BytesLiteral` case. I tried:

```diff
diff --git a/crates/ruff_python_ast/src/comparable.rs b/crates/ruff_python_ast/src/comparable.rs
index aaf4411f9..daae22866 100644
--- a/crates/ruff_python_ast/src/comparable.rs
+++ b/crates/ruff_python_ast/src/comparable.rs
@@ -785,7 +785,7 @@ pub struct ExprStringLiteral<'a> {
 
 #[derive(Debug, PartialEq, Eq, Hash)]
 pub struct ExprBytesLiteral<'a> {
-    parts: Vec<ComparableBytesLiteral<'a>>,
+    value: ComparableBytesLiteral<'a>,
 }
 
 #[derive(Debug, PartialEq, Eq, Hash)]
@@ -1031,7 +1031,9 @@ impl<'a> From<&'a ast::Expr> for ComparableExpr<'a> {
             }
             ast::Expr::BytesLiteral(ast::ExprBytesLiteral { value, range: _ }) => {
                 Self::BytesLiteral(ExprBytesLiteral {
-                    parts: value.iter().map(Into::into).collect(),
+                    value: ComparableBytesLiteral {
+                        value: &value.bytes().collect::<Vec<u8>>().into_boxed_slice(),
+                    },
                 })
             }
             ast::Expr::NumberLiteral(ast::ExprNumberLiteral { value, range: _ }) => {
```

But the borrow checker is not happy with me. I can see how to get an `&[BytesLiteral]` out of `BytesLiteralValue` but I don't see how to get the corresponding `&[u8]` from there. I think the borrow checker would be happy if `ComparableBytesLiteral.value` was `Box<[u8]>` (and I removed the borrow), but I'm not sure if that's the right way to do this sort of thing...

---

_Comment by @MichaReiser on 2024-09-09 16:23_

Yeah, you have to store the `bytes` somewhere either by adding a `to_bytes` method to `BytesLiteral` or storing a `Vec` inside `ComparableBytesLiteral`. I'm leaning towards storing a `Cow<'ast, [u8]>` in `ComparableBytesLiteral` which is `Cow::Borrowed` if it is a single value literal and `Owned` when it consists of multiple values.

---

_Referenced in [astral-sh/ruff#13301](../../astral-sh/ruff/pulls/13301.md) on 2024-09-10 04:54_

---

_Closed by @MichaReiser on 2024-09-25 14:58_

---
