---
number: 19817
title: "Rule request: Avoid mutable types for `dict.fromkeys.value`"
type: issue
state: open
author: hunterhogan
labels:
  - rule
  - needs-decision
assignees: []
created_at: 2025-08-08T01:11:33Z
updated_at: 2025-08-11T03:12:22Z
url: https://github.com/astral-sh/ruff/issues/19817
synced_at: 2026-01-07T12:31:13-06:00
---

# Rule request: Avoid mutable types for `dict.fromkeys.value`

---

_Issue opened by @hunterhogan on 2025-08-08 01:11_

### Summary

From [Python.org](https://docs.python.org/3/library/stdtypes.html#dict.fromkeys):

> ### _classmethod_ `fromkeys(iterable, value=None, /)`
> 
> Create a new dictionary with keys from iterable and values set to value.
> 
> [fromkeys()](https://docs.python.org/3/library/stdtypes.html#dict.fromkeys) is a class method that returns a new dictionary. `value `defaults to `None`. All of the values refer to just a single instance, so it generally doesnâ€™t make sense for `value` to be a mutable object such as an empty list. To get distinct values, use a [dict comprehension](https://docs.python.org/3/reference/expressions.html#dict) instead.

I use `fromkeys()`, but the "single instance" detail caught me by surprise. In a recent project, I used an empty dictionary as `value`, and after a few hours of troubleshooting, I figured out the issue was related to `fromkeys()`.

Nevertheless, I still missed the "single instance" feature, and cpython [cured my ignorance](https://github.com/python/cpython/issues/137364).

Therefore, perhaps y'all can figure out a clever way to distinguish statements such as:

```python
dictionaryCurveLocations: dict[int, dict[int, int]] = {}.fromkeys(range(bridges + 1), {})

return dict.fromkeys(listCurveLocations, 1)
```

Thanks for your hard work!

---

_Label `rule` added by @ntBre on 2025-08-08 11:59_

---

_Label `needs-decision` added by @ntBre on 2025-08-08 11:59_

---

_Comment by @ntBre on 2025-08-08 12:00_

Ah, I think this is already covered by [mutable-fromkeys-value (RUF024)](https://docs.astral.sh/ruff/rules/mutable-fromkeys-value/#mutable-fromkeys-value-ruf024)!

Thanks for the kind words!

---

_Comment by @ntBre on 2025-08-08 12:06_

It looks like it only works on `dict.fromkeys` literally, not `{}.fromkeys`, as in your example, though.

https://play.ruff.rs/db41b319-5f35-4580-a56c-4f7ff50a9e1f

We could probably also check if the object is a dictionary, not just the `dict` builtin.

---

_Comment by @hunterhogan on 2025-08-11 03:12_

> Ah, I think this is already covered by [mutable-fromkeys-value (RUF024)](https://docs.astral.sh/ruff/rules/mutable-fromkeys-value/#mutable-fromkeys-value-ruf024)!

Excellent!

> 
> Thanks for the kind words!

Y'all are very welcome!



> It looks like it only works on `dict.fromkeys` literally, not `{}.fromkeys`, as in your example, though.
> 
> https://play.ruff.rs/db41b319-5f35-4580-a56c-4f7ff50a9e1f

I hadn't seen the playground before. I like it. 

> 
> We could probably also check if the object is a dictionary, not just the `dict` builtin.

Of course, that seems reasonable. I'm not a programmer, so the following might be gobblegook.

I'm interpreting your words to mean something like Ruff has a data structure like:

table_of_RUF024_objects
builtin.dict
{}

But, this: https://play.ruff.rs/2c7fd472-027c-4c6f-949e-e83796fcc48e
Maybe, from time to time, run `dict.__subclasses__()` and see if you want to add anything. Or automate it. 

```python
from collections import *
from pprint import pprint

listRUF024 = []
for whatWhat in dict.__subclasses__():
	if whatWhat.__module__ == 'collections':
		try:
			print(whatWhat.fromkeys(range(5), 0))
		except Exception as ERRORmessage:
			print(whatWhat.__module__, whatWhat.__name__)
			print(ERRORmessage)
		else:
			listRUF024.append(whatWhat)

pprint(listRUF024)
```

Well, I have two other half-formed ideas rattling around in my head, but my brain is not cooperating right now. 


---
