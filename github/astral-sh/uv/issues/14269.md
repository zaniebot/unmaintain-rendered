---
number: 14269
title: "In-tree build `uv pip install .` will create PEP-517 venv twice which breaks build-requires (e.g., `cmake` / `ninja` with absolute path in first venv)"
type: issue
state: closed
author: XuehaiPan
labels:
  - bug
assignees: []
created_at: 2025-06-26T09:13:40Z
updated_at: 2025-07-01T16:50:20Z
url: https://github.com/astral-sh/uv/issues/14269
synced_at: 2026-01-07T12:31:16-06:00
---

# In-tree build `uv pip install .` will create PEP-517 venv twice which breaks build-requires (e.g., `cmake` / `ninja` with absolute path in first venv)

---

_Issue opened by @XuehaiPan on 2025-06-26 09:13_

### Summary

As per the issue title, `uv pip install [-e ].` will create two venv. For PyTorch, the `setup.py` will run CMake commands, which generate Ninja build commands. As the following trimmed log reports, the `ninja` command does not exist. The absolute path of the `ninja` command is in the first venv, which is removed after build. The `ninja` command is installed in the second venv but not invoked because the `ninja` command is invoked by absolute path.

<details>
<summary>`uv pip install -v -e .` log</summary>

```console
$ uv pip install -v -e .
DEBUG uv 0.7.15
DEBUG Marking explicit source tree for reinstall: `/home/panxuehai/Projects/pytorch`
DEBUG Searching for default Python interpreter in virtual environments
DEBUG Found `cpython-3.13.3-linux-x86_64-gnu` at `/home/panxuehai/Projects/pytorch/venv/bin/python3` (active virtual environment)
Using Python 3.13.3 environment at: venv
DEBUG Acquired lock for `venv`
DEBUG Using request timeout of 30s
DEBUG Found PEP 621 metadata for /home/panxuehai/Projects/pytorch in `pyproject.toml` (torch)
DEBUG No static `pyproject.toml` available for: torch @ file:///home/panxuehai/Projects/pytorch (DynamicField("dependencies"))
DEBUG Acquired lock for `/home/panxuehai/.cache/uv/sdists-v9/editable/17f48f3bb31b12e6`
DEBUG Computed cache info: Some(Timestamp(SystemTime { tv_sec: 1750927304, tv_nsec: 527953603 })), None, None, {}, {"src": None}
DEBUG Preparing metadata for: torch @ file:///home/panxuehai/Projects/pytorch
DEBUG No workspace root found, using project root
DEBUG Assessing Python executable as base candidate: /home/panxuehai/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/bin/python3.13
DEBUG Using base executable for virtual environment: /home/panxuehai/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/bin/python3.13
DEBUG Ignoring empty directory
DEBUG Resolving build requirements
DEBUG Solving with installed Python version: 3.13.3
DEBUG Solving with target Python version: >=3.13.3
DEBUG Adding direct dependency: setuptools>=62.3.0
DEBUG Adding direct dependency: wheel*
DEBUG Adding direct dependency: astunparse*
DEBUG Adding direct dependency: cmake>=3.27
DEBUG Adding direct dependency: ninja*
DEBUG Adding direct dependency: numpy*
DEBUG Adding direct dependency: pyyaml*
DEBUG Adding direct dependency: requests*
DEBUG Adding direct dependency: typing-extensions>=4.10.0
DEBUG
DEBUG > ...
DEBUG > Resolving venv
DEBUG > ...
DEBUG
DEBUG Installing in idna==3.10, charset-normalizer==3.4.2, pyyaml==6.0.2, astunparse==1.6.3, cmake==4.0.3, urllib3==2.5.0, ninja==1.11.1.4, typing-extensions==4.14.0, six==1.17.0, requests==2.32.4, numpy==2.3.1, certifi==2025.6.15, wheel==0.45.1, setuptools==80.9.0 in /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0
DEBUG Registry requirement already cached: idna==3.10
DEBUG Registry requirement already cached: charset-normalizer==3.4.2
DEBUG Registry requirement already cached: pyyaml==6.0.2
DEBUG Registry requirement already cached: astunparse==1.6.3
DEBUG Registry requirement already cached: cmake==4.0.3
DEBUG Registry requirement already cached: urllib3==2.5.0
DEBUG Registry requirement already cached: ninja==1.11.1.4
DEBUG Registry requirement already cached: typing-extensions==4.14.0
DEBUG Registry requirement already cached: six==1.17.0
DEBUG Registry requirement already cached: requests==2.32.4
DEBUG Registry requirement already cached: numpy==2.3.1
DEBUG Registry requirement already cached: certifi==2025.6.15
DEBUG Registry requirement already cached: wheel==0.45.1
DEBUG Registry requirement already cached: setuptools==80.9.0
DEBUG Installing build requirements: idna==3.10, charset-normalizer==3.4.2, pyyaml==6.0.2, astunparse==1.6.3, cmake==4.0.3, urllib3==2.5.0, ninja==1.11.1.4, typing-extensions==4.14.0, six==1.17.0, requests==2.32.4, numpy==2.3.1, certifi==2025.6.15, wheel==0.45.1, setuptools==80.9.0
# DEBUG Creating PEP 517 build environment
DEBUG Calling `setuptools.build_meta.get_requires_for_build_editable()`
DEBUG Building wheel torch-2.8.0a0+git1c5da4f
# DEBUG running egg_info
DEBUG writing torch.egg-info/PKG-INFO
DEBUG writing dependency_links to torch.egg-info/dependency_links.txt
DEBUG writing entry points to torch.egg-info/entry_points.txt
DEBUG writing requirements to torch.egg-info/requires.txt
DEBUG writing top-level names to torch.egg-info/top_level.txt
DEBUG reading manifest file 'torch.egg-info/SOURCES.txt'
DEBUG reading manifest template 'MANIFEST.in'
DEBUG warning: no previously-included files matching '*.o' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.obj' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.dylib' found anywhere in distribution
DEBUG no previously-included directories found matching '*/.git'
DEBUG warning: no previously-included files matching '*~' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.swp' found anywhere in distribution
DEBUG adding license file 'LICENSE'
DEBUG adding license file 'NOTICE'
DEBUG writing manifest file 'torch.egg-info/SOURCES.txt'
DEBUG No workspace root found, using project root
DEBUG Calling `setuptools.build_meta.prepare_metadata_for_build_editable()`
DEBUG Building wheel torch-2.8.0a0+git1c5da4f
DEBUG -- Building version 2.8.0a0+git1c5da4f
DEBUG
DEBUG > ...
DEBUG > CMake Configure Log ...
DEBUG > ...
DEBUG
DEBUG -- Configuring done (44.7s)
DEBUG -- Generating done (3.2s)
DEBUG -- Build files have been written to: /home/panxuehai/Projects/pytorch/build
DEBUG [1/4] Generating ATen declarations_yaml
DEBUG [2/4] Generating ATen headers
DEBUG [3/4] Generating ATen sources
DEBUG [1/811] Creating directories for 'nccl_external'
DEBUG
DEBUG > ...
DEBUG > CMake Build Log ...
DEBUG > ...
DEBUG
DEBUG cmake -GNinja -DBUILD_PYTHON=True -DBUILD_TEST=True -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/home/panxuehai/Projects/pytorch/torch -DCMAKE_PREFIX_PATH=/home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/lib/python3.13/site-packages -DPython_EXECUTABLE=/home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/bin/python -DTORCH_BUILD_VERSION=2.8.0a0+git1c5da4f -DUSE_NUMPY=True /home/panxuehai/Projects/pytorch
DEBUG cmake --build . --target install --config Release
# DEBUG running dist_info
DEBUG creating /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info
DEBUG writing /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/PKG-INFO
DEBUG writing dependency_links to /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/dependency_links.txt
DEBUG writing entry points to /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/entry_points.txt
DEBUG writing requirements to /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/requires.txt
DEBUG writing top-level names to /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/top_level.txt
DEBUG writing manifest file '/home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/SOURCES.txt'
DEBUG reading manifest file '/home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/SOURCES.txt'
DEBUG reading manifest template 'MANIFEST.in'
DEBUG warning: no previously-included files matching '*.o' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.obj' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.dylib' found anywhere in distribution
DEBUG no previously-included directories found matching '*/.git'
DEBUG warning: no previously-included files matching '*~' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.swp' found anywhere in distribution
DEBUG adding license file 'LICENSE'
DEBUG adding license file 'NOTICE'
DEBUG writing manifest file '/home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch.egg-info/SOURCES.txt'
DEBUG creating '/home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/metadata_directory/torch-2.8.0a0+git1c5da4f.dist-info'
DEBUG Prepared metadata for: torch @ file:///home/panxuehai/Projects/pytorch
DEBUG No workspace root found, using project root
DEBUG Released lock at `/home/panxuehai/.cache/uv/sdists-v9/editable/17f48f3bb31b12e6/.lock`
DEBUG Solving with installed Python version: 3.13.3
DEBUG Solving with target Python version: >=3.13.3
DEBUG Adding direct dependency: torch*
DEBUG Searching for a compatible version of torch @ file:///home/panxuehai/Projects/pytorch (*)
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: filelock*
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: typing-extensions>=4.10.0
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: setuptools{python_full_version >= '3.12'}*
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: sympy>=1.13.3
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: networkx*
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: jinja2*
DEBUG Adding transitive dependency for torch==2.8.0a0+git1c5da4f: fsspec*
DEBUG ...
DEBUG Resolving venv
DEBUG ...
DEBUG Requirement already installed: sympy==1.14.0
DEBUG Requirement already installed: markupsafe==3.0.2
DEBUG Requirement already installed: filelock==3.18.0
DEBUG Must revalidate requirement: torch
DEBUG Requirement already installed: networkx==3.5
DEBUG Requirement already installed: typing-extensions==4.14.0
DEBUG Requirement already installed: jinja2==3.1.6
DEBUG Requirement already installed: fsspec==2025.5.1
DEBUG Requirement already installed: mpmath==1.3.0
DEBUG Requirement already installed: setuptools==80.9.0
DEBUG Unnecessary package: pyyaml==6.0.2
DEBUG Unnecessary package: aiohappyeyeballs==2.6.1
DEBUG Unnecessary package: aiohttp==3.12.13
DEBUG Unnecessary package: aiosignal==1.3.2
DEBUG Unnecessary package: astroid==3.3.10
DEBUG Unnecessary package: asttokens==3.0.0
DEBUG Unnecessary package: astunparse==1.6.3
DEBUG Unnecessary package: attrs==25.3.0
DEBUG Unnecessary package: build==1.2.2.post1
DEBUG Unnecessary package: certifi==2025.6.15
DEBUG Unnecessary package: charset-normalizer==3.4.2
DEBUG Unnecessary package: click==8.2.1
DEBUG Unnecessary package: cmake==4.0.3
DEBUG Unnecessary package: decorator==5.2.1
DEBUG Unnecessary package: dill==0.4.0
DEBUG Unnecessary package: executing==2.2.0
DEBUG Unnecessary package: expecttest==0.3.0
DEBUG Unnecessary package: flake8==7.3.0
DEBUG Unnecessary package: frozenlist==1.7.0
DEBUG Unnecessary package: ghstack==0.11.0
DEBUG Unnecessary package: hypothesis==6.135.15
DEBUG Unnecessary package: idna==3.10
DEBUG Unnecessary package: ipython==9.3.0
DEBUG Unnecessary package: ipython-pygments-lexers==1.1.1
DEBUG Unnecessary package: isort==6.0.1
DEBUG Unnecessary package: jedi==0.19.2
DEBUG Unnecessary package: lintrunner==0.12.7
DEBUG Unnecessary package: markdown-it-py==3.0.0
DEBUG Unnecessary package: matplotlib-inline==0.1.7
DEBUG Unnecessary package: mccabe==0.7.0
DEBUG Unnecessary package: mdurl==0.1.2
DEBUG Unnecessary package: multidict==6.5.1
DEBUG Unnecessary package: mypy==1.16.1
DEBUG Unnecessary package: mypy-extensions==1.1.0
DEBUG Unnecessary package: ninja==1.11.1.4
DEBUG Unnecessary package: numpy==2.3.1
DEBUG Unnecessary package: optree==0.16.0
DEBUG Unnecessary package: packaging==25.0
DEBUG Unnecessary package: parso==0.8.4
DEBUG Unnecessary package: pathspec==0.12.1
DEBUG Unnecessary package: pexpect==4.9.0
DEBUG Preserving seed package: pip==25.1.1
DEBUG Unnecessary package: platformdirs==4.3.8
DEBUG Unnecessary package: prompt-toolkit==3.0.51
DEBUG Unnecessary package: propcache==0.3.2
DEBUG Unnecessary package: psutil==7.0.0
DEBUG Unnecessary package: ptyprocess==0.7.0
DEBUG Unnecessary package: pure-eval==0.2.3
DEBUG Unnecessary package: pycodestyle==2.14.0
DEBUG Unnecessary package: pyenchant==3.2.2
DEBUG Unnecessary package: pyflakes==3.4.0
DEBUG Unnecessary package: pygments==2.19.2
DEBUG Unnecessary package: pylint==3.3.7
DEBUG Unnecessary package: pyproject-hooks==1.2.0
DEBUG Unnecessary package: requests==2.32.4
DEBUG Unnecessary package: rich==14.0.0
DEBUG Unnecessary package: ruff==0.12.0
DEBUG Unnecessary package: six==1.17.0
DEBUG Unnecessary package: sortedcontainers==2.4.0
DEBUG Unnecessary package: stack-data==0.6.3
DEBUG Unnecessary package: tomlkit==0.13.3
DEBUG Unnecessary package: traitlets==5.14.3
DEBUG Unnecessary package: types-dataclasses==0.6.6
DEBUG Unnecessary package: urllib3==2.5.0
DEBUG Preserving seed package: uv==0.7.15
DEBUG Unnecessary package: wcwidth==0.2.13
DEBUG Unnecessary package: wheel==0.45.1
DEBUG Unnecessary package: yarl==1.20.1
DEBUG Acquired lock for `/home/panxuehai/.cache/uv/sdists-v9/editable/17f48f3bb31b12e6`
DEBUG Computed cache info: Some(Timestamp(SystemTime { tv_sec: 1750927304, tv_nsec: 527953603 })), None, None, {}, {"src": None}
   Building torch @ file:///home/panxuehai/Projects/pytorch
DEBUG Building: torch @ file:///home/panxuehai/Projects/pytorch
DEBUG No workspace root found, using project root
DEBUG Assessing Python executable as base candidate: /home/panxuehai/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/bin/python3.13
DEBUG Using base executable for virtual environment: /home/panxuehai/.local/share/uv/python/cpython-3.13.3-linux-x86_64-gnu/bin/python3.13
DEBUG Ignoring empty directory
DEBUG Resolving build requirements
DEBUG Solving with installed Python version: 3.13.3
DEBUG Solving with target Python version: >=3.13.3
DEBUG Adding direct dependency: setuptools>=62.3.0
DEBUG Adding direct dependency: wheel*
DEBUG Adding direct dependency: astunparse*
DEBUG Adding direct dependency: cmake>=3.27
DEBUG Adding direct dependency: ninja*
DEBUG Adding direct dependency: numpy*
DEBUG Adding direct dependency: pyyaml*
DEBUG Adding direct dependency: requests*
DEBUG Adding direct dependency: typing-extensions>=4.10.0
DEBUG
DEBUG > ...
DEBUG > Resolving venv
DEBUG > ...
DEBUG
DEBUG Installing in idna==3.10, charset-normalizer==3.4.2, pyyaml==6.0.2, astunparse==1.6.3, cmake==4.0.3, urllib3==2.5.0, ninja==1.11.1.4, typing-extensions==4.14.0, six==1.17.0, requests==2.32.4, numpy==2.3.1, certifi==2025.6.15, wheel==0.45.1, setuptools==80.9.0 in /home/panxuehai/.cache/uv/builds-v0/.tmpBE9W53
DEBUG Registry requirement already cached: idna==3.10
DEBUG Registry requirement already cached: charset-normalizer==3.4.2
DEBUG Registry requirement already cached: pyyaml==6.0.2
DEBUG Registry requirement already cached: astunparse==1.6.3
DEBUG Registry requirement already cached: cmake==4.0.3
DEBUG Registry requirement already cached: urllib3==2.5.0
DEBUG Registry requirement already cached: ninja==1.11.1.4
DEBUG Registry requirement already cached: typing-extensions==4.14.0
DEBUG Registry requirement already cached: six==1.17.0
DEBUG Registry requirement already cached: requests==2.32.4
DEBUG Registry requirement already cached: numpy==2.3.1
DEBUG Registry requirement already cached: certifi==2025.6.15
DEBUG Registry requirement already cached: wheel==0.45.1
DEBUG Registry requirement already cached: setuptools==80.9.0
DEBUG Installing build requirements: idna==3.10, charset-normalizer==3.4.2, pyyaml==6.0.2, astunparse==1.6.3, cmake==4.0.3, urllib3==2.5.0, ninja==1.11.1.4, typing-extensions==4.14.0, six==1.17.0, requests==2.32.4, numpy==2.3.1, certifi==2025.6.15, wheel==0.45.1, setuptools==80.9.0
# DEBUG Creating PEP 517 build environment
DEBUG Calling `setuptools.build_meta.get_requires_for_build_editable()`
DEBUG Building wheel torch-2.8.0a0+git1c5da4f
# DEBUG running egg_info
DEBUG writing torch.egg-info/PKG-INFO
DEBUG writing dependency_links to torch.egg-info/dependency_links.txt
DEBUG writing entry points to torch.egg-info/entry_points.txt
DEBUG writing requirements to torch.egg-info/requires.txt
DEBUG writing top-level names to torch.egg-info/top_level.txt
DEBUG reading manifest file 'torch.egg-info/SOURCES.txt'
DEBUG reading manifest template 'MANIFEST.in'
DEBUG warning: no previously-included files matching '*.o' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.obj' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.dylib' found anywhere in distribution
DEBUG no previously-included directories found matching '*/.git'
DEBUG warning: no previously-included files matching '*~' found anywhere in distribution
DEBUG warning: no previously-included files matching '*.swp' found anywhere in distribution
DEBUG adding license file 'LICENSE'
DEBUG adding license file 'NOTICE'
DEBUG writing manifest file 'torch.egg-info/SOURCES.txt'
DEBUG No workspace root found, using project root
DEBUG Calling `setuptools.build_meta.build_editable("/home/panxuehai/.cache/uv/builds-v0/.tmpfM5YkL", {}, None)`
DEBUG Building wheel torch-2.8.0a0+git1c5da4f
DEBUG -- Building version 2.8.0a0+git1c5da4f
DEBUG no such file or directory
DEBUG CMake Error: Generator: build tool execution failed, command was: /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/bin/ninja install
DEBUG -- Checkout nccl release tag: v2.27.3-1
DEBUG cmake --build . --target install --config Release
DEBUG Released lock at `/home/panxuehai/.cache/uv/sdists-v9/editable/17f48f3bb31b12e6/.lock`
  × Failed to build `torch @ file:///home/panxuehai/Projects/pytorch`
  ├─▶ The build backend returned an error
  ╰─▶ Call to `setuptools.build_meta.build_editable` failed (exit status: 1)

      [stdout]
      -- Checkout nccl release tag: v2.27.3-1
      cmake --build . --target install --config Release

      [stderr]
      Building wheel torch-2.8.0a0+git1c5da4f
      -- Building version 2.8.0a0+git1c5da4f
      no such file or directory
      CMake Error: Generator: build tool execution failed, command was: /home/panxuehai/.cache/uv/builds-v0/.tmp8yZxY0/bin/ninja install

      hint: This usually indicates a problem with the package or the build environment.
DEBUG Released lock at `/home/panxuehai/Projects/pytorch/venv/.lock`
```

</details>

For detailed build log:

- https://github.com/pytorch/pytorch/issues/152276#issuecomment-2995393253

PR pytorch/pytorch#156709 fixes the PyTorch build failure caused by `uv pip install` creates two PEP-517 venv, that does not run CMake for `python setup.py dist_info`. But `uv pip install` still creates two  PEP-517 venv. FYI, `pip install` works fine without that fix.

- pytorch/pytorch#156709

------

Build commands for PyTorch:

```bash
git clone --recurse-submodules --branch=pyproject https://github.com/XuehaiPan/pytorch.git && cd pytorch
uv venv venv
source venv/bin/activate
fd -HI 'CMakeCache\.txt|.*\.ninja.*' | xargs -I '{}' bash -c "echo '{}'; rm -rf '{}'"
uv pip install -v -e .
```

### Platform

Ubuntu 20.04 amd64

### Version

uv 0.7.15

### Python version

Python 3.13.3

---

_Label `bug` added by @XuehaiPan on 2025-06-26 09:13_

---

_Referenced in [pytorch/pytorch#152276](../../pytorch/pytorch/issues/152276.md) on 2025-06-26 09:34_

---

_Comment by @charliermarsh on 2025-06-26 15:35_

Does `pip install --use-pep517` also succeed?

---

_Comment by @charliermarsh on 2025-06-26 15:36_

I'm confused by what the "two venvs" are here, what are the two different environments?

---

_Comment by @XuehaiPan on 2025-06-26 15:57_

> I'm confused by what the "two venvs" are here, what are the two different environments?

See the build log in the collapsed block in https://github.com/astral-sh/uv/issues/14269#issue-3178422949. There are two "DEBUG Creating PEP 517 build environment":

```console
$ $ uv pip install -v -e .
DEBUG uv 0.7.15
DEBUG Marking explicit source tree for reinstall: `/home/panxuehai/Projects/pytorch`
DEBUG ...
DEBUG Creating PEP 517 build environment
DEBUG ...
DEBUG running egg_info
DEBUG ...
DEBUG running dist_info
DEBUG ...
DEBUG Creating PEP 517 build environment
DEBUG ...
DEBUG running egg_info
DEBUG ...
```

---

_Assigned to @charliermarsh by @charliermarsh on 2025-06-26 16:34_

---

_Comment by @zanieb on 2025-06-26 17:27_

This looks similar to https://github.com/astral-sh/uv/issues/13896#issuecomment-2952556112

---

_Comment by @XuehaiPan on 2025-06-26 17:27_

> Does `pip install --use-pep517` also succeed?

FYI, it works.

```console
$ fd -HI 'CMakeCache\.txt|.*\.ninja.*' | xargs -I '{}' bash -c "echo '{}'; rm -rf '{}'"
$ pip install -v -e .  # SUCCESS

$ fd -HI 'CMakeCache\.txt|.*\.ninja.*' | xargs -I '{}' bash -c "echo '{}'; rm -rf '{}'"
$ pip install --use-pep517 -v -e .  # SUCCESS

$ fd -HI 'CMakeCache\.txt|.*\.ninja.*' | xargs -I '{}' bash -c "echo '{}'; rm -rf '{}'"
$ uv pip install -v -e .  # FAIL
```

---

_Comment by @charliermarsh on 2025-06-26 17:29_

Maybe what's happening is:

- We write some stuff to `/home/panxuehai/Projects/pytorch/build`
- The second invocation reuses the files in `/home/panxuehai/Projects/pytorch/build`, which include absolute paths to a non-existent environment

---

_Comment by @charliermarsh on 2025-06-26 17:30_

(I think it's correct that we create two environments: one to get the metadata during resolution, another to build the wheel afterwards.)

---

_Comment by @charliermarsh on 2025-06-26 17:32_

If we put up a PR, are you able to test it for us?

---

_Comment by @XuehaiPan on 2025-06-26 17:34_

> Maybe what's happening is:
> 
> * We write some stuff to `/home/panxuehai/Projects/pytorch/build`
> * The second invocation reuses the files in `/home/panxuehai/Projects/pytorch/build`, which include absolute paths to a non-existent environment

Yes.

> (I think it's correct that we create two environments: one to get the metadata during resolution, another to build the wheel afterwards.)

The PyTorch `setup.py` will run cmake configure and cmake build in the first run (which is really heavy though, even for just running `python setup.py --version`). The second run found the cmake cache file (and skipped cmake configure) created by the first run, which is not valid for the second venv.

------

I think the solution can be either:

1. Create only one PEP-517 venv.
2. Create two PEP-517 venvs, but only remove the two venvs on program exit. I.e., do not remove the first venv before the installation process is done.

---

_Comment by @XuehaiPan on 2025-06-26 17:34_

> If we put up a PR, are you able to test it for us?

Yes, I can.

---

_Comment by @charliermarsh on 2025-06-26 17:45_

I think either of those could be reasonable. I was also considering clearing the `build` directory when we restart a build, but I guess that would lose the CMake cache.

---

_Comment by @XuehaiPan on 2025-06-26 17:51_

> I was also considering clearing the `build` directory when we restart a build, but I guess that would lose the CMake cache.

For PyTorch, the build cache is managed by custom `setup.py` logic. I don't think the build frontend (`uv` or `pip`) can detect arbitrary user-custom caching mechanic.

---

_Comment by @charliermarsh on 2025-06-26 17:52_

Honestly I think this isn't a bug in uv -- it's likely a violation of the spec to be caching in this way. But we should probably still support it.

---

_Comment by @rgommers on 2025-06-26 18:00_

> (I think it's correct that we create two environments: one to get the metadata during resolution, another to build the wheel afterwards.)

There's nothing in PEP 517 that says anything either way, but it was definitely designed with a single build env in mind. The intermediate stage where a build backend writes out a partial build tree assumed that the direct next step was to reuse that partial build tree and continue.

> it's likely a violation of the spec to be caching in this way.

It isn't I believe, and this caching is important for build performance.

From https://peps.python.org/pep-0517/#prepare-metadata-for-build-wheel:
*The hook MAY also create other files inside this directory, and a build frontend MUST preserve, but otherwise ignore, such files; the intention here is that in cases where the metadata depends on build-time decisions, the build backend may need to record these decisions in some convenient format for re-use by the actual wheel-building step.*

That doesn't exactly cover this case I think, but you can see the intent of the "set up the prerequisites for starting a wheel build" being that the build backend can be doing what's most efficient here, rather than having to assume that the frontend may remove or invalidate everything.

---

_Comment by @charliermarsh on 2025-06-26 18:47_

Hmm... I'm not _totally_ convinced that it's acceptable for `build_wheel` to fail because `prepare_metadata_for_build_wheel` was called with a separate build environment (and we _are_ preserving the files created outside the build directory; they're just referencing files that are later removed), but I understand that the "two environment" approach here doesn't really match the intent of the PEP. I might be wrong, though -- I know you've thought about the frontend/backend relationship a lot. I think we should support this use-case either way.


---

_Referenced in [astral-sh/uv#14304](../../astral-sh/uv/pulls/14304.md) on 2025-06-27 02:42_

---

_Comment by @rgommers on 2025-06-27 08:14_

I understand that you're not totally convinced @charliermarsh; there's an unfortunate amount of ambiguity in the `prepare_metadata_for_build_wheel` spec, so there's only intent and no very clear rules. I don't like it for multiple reasons, and since it's optional I've chosen to not implement it yet in `meson-python` - it avoids potential pitfalls like this. The intent of the hook when it was added to PEP 517 was only to get an option for the front-end to bail out early if dynamic metadata would otherwise cause it to discard the wheel anyway (static metadata should be read from `pyproject.toml` whenever possible, which also took a long Discourse thread to get a verdict on). The spec should have clarified all that better and say that it should only be called (a) by a build frontend, and (b) right before calling the `build_wheel` hook.

---

_Comment by @konstin on 2025-06-27 08:57_

Without going into the specific of these hooks should be used, I think a build backend should invalidate its cache when paths it uses such as venv, cwd or tool versions change.

---

_Comment by @rgommers on 2025-06-27 10:01_

> Without going into the specific of these hooks should be used, I think a build backend should invalidate its cache when paths it uses such as venv, cwd or tool versions change.

Versions yes, to the extent possible. And this is typically handled quite well by `ninja`, `cmake`, `meson` et al. by hashing contents of headers and the like, and reconfiguring/rebuilding as needed. 

Paths sometimes yes too, but paths changing in arbitrary fashion is impossible to fully support in a performant manner. That's like saying a build frontend should always consider all its metadata as dynamic - that wouldn't work well for `uv` either. There are assumptions made there by build tools, so reusing the build directory between different venvs is not supported in general. There are some other constraints, like upgrades of the build tool itself that change the binary format of its own cache may not be supported.

Usually when you upgrade a build environment and then reuse the build dir it "just works", since many path/dependency changes are handled fine. And otherwise you get a reasonable error message from the build tool - at which point you can `rm -rf build`. That is okay and expected I'd say, since version changes of build-time dependencies that will result in errors are quite rare.

---

_Comment by @charliermarsh on 2025-06-27 13:40_

What about the following case:

- The user runs `uv lock`, so we resolve all the metadata, but don't build the wheel (i.e., we create a build environment and call `prepare_metadata_for_build_wheel`).
- The user later runs `uv sync`, so we need to build the wheel.

Supporting this would require that tools persist (and reuse) build environments across invocations, and do so indefinitely, right?


---

_Comment by @rgommers on 2025-06-27 14:46_

> Supporting this would require that tools persist (and reuse) build environments across invocations, and do so indefinitely, right?

You don't need to persist it I think, but you just need to ensure that the path it's recreated at isn't arbitrary? Just remove & recreate with the env in the same path. Either by storing the path containing a random component, or probably better by having some scheme for it (something like `<envs-rootdir>/project-name/build-env/`). If you're always immediately removing envs, I'd think a fixed scheme should work and avoid such problems. That has come up with editable installs as well as an issue IIRC.

---

_Comment by @charliermarsh on 2025-06-27 14:57_

I think there are still plenty of ways that can go wrong, though. What if the interpreter version changes, and the `build` directory is now referencing paths that don't exist? What if the build dependencies themselves change, and some referenced dependency doesn't get included in the recreated build environment? Builds also depend on all sorts of other user input that can change across invocations: `--config-setting` values, environment variables, etc. But from your prior message, I think you're saying that such cases are rare and okay, and thus it's fine for those to fail with the assumption that the user can manually recover.

---

_Comment by @rgommers on 2025-06-27 15:21_

I'm not sure I understand how dependency versions can change at the `uv sync` step without re-rerunning `uv lock` first. 

That aside, I think it is less of a surprise if `uv sync` worked differently and so it doesn't seem like a problem to me if you choose to implement different behavior from `pip` here, and always start from scratch for `uv sync`, since for that operation there is much less of an expectation of optimal performance like in-place builds (plus it doesn't even exist in `pip`).

> Builds also depend on all sorts of other user input that can change across invocations: `--config-setting` values, environment variables, etc.

True. `pip` leaves this up to the developer, who should either clean up manually if dependencies change in a build-breaking way, or choose a different build directory when that happens. I typically do the latter - my scipy repo contains about 10 build directories for various environments.

I'd summarize as:
- `uv pip install .` should not break (this issue) and I'd expect it to work like `pip` (I think that's a design goal?)
- editable installs should be efficient and hence use a single build env, either kept or recreated
    - kept around is best, otherwise you're also breaking rebuild-on-compiled-sourcefile-changes functionality in meson-python and scikit-build-core
- `uv sync` I personally have no expectations for. If you'd want it to never reuse a build dir but use the old `pip` way of copying the project's sources to a tmpdir before building a wheel, it'll be slower but least surprising.

>  I think you're saying that such cases are rare and okay, and thus it's fine for those to fail with the assumption that the user can manually recover.

Indeed. And there's no way to avoid it completely I think, unless you by design never reuse a build directory at all.

---

_Comment by @charliermarsh on 2025-06-27 17:00_

> True. pip leaves this up to the developer, who should either clean up manually if dependencies change in a build-breaking way, or choose a different build directory when that happens. I typically do the latter - my scipy repo contains about 10 build directories for various environments.

To clarify, when you say "choose a different build directory", are you referring to the build environment, or, like, the `build` directory created by the build backend? How is that configuration exposed?


---

_Comment by @rgommers on 2025-06-27 17:25_

The `build` directory. And it's backend-specific, so passed on via config-settings. It's `-Cbuild-dir=<builddir>` in both `meson-python` and `scikit-build-core`. 

Side note: this is an interesting puzzle, but I'm about to sign off for a week of holiday, so I will probably be slow in responding. Perhaps we should get together at some point and see if we can talk through this stuff - there's a lot that could be better specified or improved.

---

_Comment by @charliermarsh on 2025-06-27 18:28_

100%, thank you for engaging here and helping me understand! (Also: hope you have a great holiday!)

---

_Comment by @konstin on 2025-06-27 18:37_

> editable installs should be efficient and hence use a single build env, either kept or recreated
> 
>     * kept around is best, otherwise you're also breaking rebuild-on-compiled-sourcefile-changes functionality in meson-python and scikit-build-core

We may be talking past each other here: uv totally keeps the source tree around and editable builds in that source tree. Only the build venv is ephemeral and may change places.

To make this more concrete for the torch case: The problem is that cmake has generated an absolute path for ninja, and stores it in `CMakeCache.txt`. This means the build will fail when e.g. switching from `uv pip install -e .` and `python -m build`. I tried to hack it into the torch build system to replace those paths with the current one, but the absolute paths seems pervasive with no option to change to change or invalidate this in cmake without rebuilding torch.

---

_Comment by @charliermarsh on 2025-06-27 18:45_

(Yeah it's possible that I've completely misstated the problem by using the wrong terminology. This is absolutely something that can break with other tools that aren't uv.)


---

_Referenced in [astral-sh/uv#14338](../../astral-sh/uv/pulls/14338.md) on 2025-06-27 23:41_

---

_Referenced in [pytorch/pytorch#156958](../../pytorch/pytorch/pulls/156958.md) on 2025-06-28 10:13_

---

_Closed by @charliermarsh on 2025-07-01 16:50_

---
