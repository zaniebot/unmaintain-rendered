---
number: 14256
title: Best practices for Docker builds to exploit layer caching
type: issue
state: open
author: timchap
labels:
  - question
assignees: []
created_at: 2025-06-25T09:26:05Z
updated_at: 2025-07-04T12:10:50Z
url: https://github.com/astral-sh/uv/issues/14256
synced_at: 2026-01-07T12:31:16-06:00
---

# Best practices for Docker builds to exploit layer caching

---

_Issue opened by @timchap on 2025-06-25 09:26_

### Question

A problem that often arises when optimising Docker builds for Python projects is that if your Python project includes an auto-incremented version in the pyproject.toml, this invalidates the build cache:

```Dockerfile
...
# This line invalidates the cache when version is bumped from 0.1.0 to 0.1.1, 
# even if external dependencies are unchanged
COPY pyproject.toml uv.lock ./
RUN uv sync --frozen
...
```

As a long-time Poetry user, I have previously used an approach like the following:

```Dockerfile
...
# Intermediate target to clobber pyproject.toml version
FROM base AS prevent-pyproject-cache-misses

COPY pyproject.toml ./
RUN sed -i '/^version = "[^"]*"/s/version = "[^"]*"/version = "0.0.0"/' pyproject.toml

FROM base AS installer
COPY --from=prevent-pyproject-cache-misses pyproject.toml .
COPY poetry.lock
...
```

This is obviously a bit of a hack, and it doesn't seem to work in all build environments, but in most cases it correctly ensures that the hash of the clobbered pyproject.toml is found in the build cache.

In `uv`, this seems to be even more difficult as the version of the current root package seems to be included in uv.lock itself. This means that both uv.lock and pyproject.toml will invalidate the cache when the root package version is auto-incremented, even when the external dependencies are unchanged. And I'm a bit reluctant to try the same trick with the lockfile...

What is the guidance for this? For projects with extremely slow external dependency builds, the ability to cache a Docker layer which includes the venv (but no project files) is very important. It seems like the general advice is to pin using requirements.txt instead, but to my mind this has a few disadvantages:

- This requires a pre-commit and/or other CI to ensure that the requirements.txt doesn't drift with respect to uv.lock
- Requirements.txt doesn't play as nicely with exotic package indexes and platform markers. In particular, I've had trouble installing from private package indexes when using the exported requirements.txt (maybe I need to try harder though).

Has anyone else got a good solution working?

### Platform

_No response_

### Version

_No response_

---

_Label `question` added by @timchap on 2025-06-25 09:26_

---

_Comment by @konstin on 2025-06-27 12:17_

Did you see https://docs.astral.sh/uv/guides/integration/docker/? It contains detailed guidance on caching.

---

_Comment by @zanieb on 2025-06-27 13:34_

I'm not sure we have a good way to handle the version in the lockfile problem. If it's `dynamic`, we won't include it in the lockfile, but I wouldn't really recommend that. I guess you could use `uv export --no-emit-project` then consume a file without your project's version in it.

---

_Comment by @timchap on 2025-07-04 12:10_

> Did you see https://docs.astral.sh/uv/guides/integration/docker/? It contains detailed guidance on caching.

Yeah, it doesn't really discuss the scenario where the cache is invalidated due to root editable project version update though.

> I'm not sure we have a good way to handle the version in the lockfile problem. If it's `dynamic`, we won't include it in the lockfile, but I wouldn't really recommend that. I guess you could use `uv export --no-emit-project` then consume a file without your project's version in it.

Ok, this is more or less what we are doing already üëç as mentioned, the main downside is that it requires (the way I see it) one of the following:
- add some CI to run the export before `docker build`, in which case building locally requires additional manually steps
- add a pre-commit to run the export, in which case developers need to be careful to install the pre-commit in order to avoid drifts between `uv.lock` and the exported lockfile.

@zanieb you mentioned using `dynamic`, which I'm not familiar with. Searching the docs I see a discussion of this in the context of cache-keys, but it's not clear to what `dynamic` (in code-quotes) refers to here. Can you clarify how you would use it in this scenario, and why you would recommend against it?

<img width="791" alt="Image" src="https://github.com/user-attachments/assets/182c1b41-e190-4e6a-944f-3fda229581df" />

Many thanks.

---
