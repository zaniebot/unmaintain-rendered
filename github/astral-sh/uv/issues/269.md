---
number: 269
title: Develop a caching strategy for URL dependencies
type: issue
state: closed
author: charliermarsh
labels:
  - bug
assignees: []
created_at: 2023-11-01T13:20:11Z
updated_at: 2023-12-15T04:16:27Z
url: https://github.com/astral-sh/uv/issues/269
synced_at: 2026-01-07T12:31:14-06:00
---

# Develop a caching strategy for URL dependencies

---

_Issue opened by @charliermarsh on 2023-11-01 13:20_

We can either respect HTTP caching, never cache, or always cache (and provide a mechanism for ignoring the cache)...

Another option is that we have one caching semantic during resolution, and then we write a SHA of some sort to the lockfile, so when we _install_ we're always allowed to read from the cache in perpetuity. Needs more research.

---

_Added to milestone `Initial release` by @charliermarsh on 2023-11-01 13:20_

---

_Label `enhancement` added by @charliermarsh on 2023-11-01 13:20_

---

_Label `enhancement` removed by @charliermarsh on 2023-11-01 13:20_

---

_Label `bug` added by @charliermarsh on 2023-11-01 13:20_

---

_Removed from milestone `Initial release` by @charliermarsh on 2023-11-02 12:55_

---

_Added to milestone `Future` by @charliermarsh on 2023-11-02 12:55_

---

_Comment by @charliermarsh on 2023-11-02 12:55_

I'm moving this to future.

---

_Comment by @charliermarsh on 2023-11-10 05:06_

@konstin - We might need a story around how to update a URL dependency that's already installed in your environment. Like, if you run `pip install https://some/package/that/is/flask` and Flask is installed already (from that URL), under what conditions do we try to reinstall it? I don't know that this is fully covered by caching, since the distribution in the virtualenv won't know anything about caching.

One option is that we _never_ update it unless the user explicitly requests it somehow (like `--force-update`), I don't know.

---

_Comment by @konstin on 2023-11-10 11:38_

Do we have a hash in the lock requirements.txt? If yes, we can cache a mapping url -> (cache_policy, hash) and on install compare that hash with `direct_url.json`, then do a cached request (this does no actual http request if the server cache policy is immutable, otherwise it's generally a cheap 304) to check that the url would still return or cached hash.

If not (i wrote this initially before realizing we may have the hash in the lockfile):

---
I'm not sure, what about this: We cache a mapping url -> (cache_policy, hash). When we get the request to install the url, we look at the venv. If `direct_url.json` does not exists or does not point to the url, remove the existing installation. If it exists do a cached query for the url (this does no actual http request if the server cache policy is immutable) and compare the hashes. If the there is no cache, if think we have to download and hash to compare with `direct_url.json`, the only case.

The bad cases (we download the file even if we didn't have to), are
* Another tool has installed the package and it didn't change on the remote and we don't have a cache entry / the other tool didn't write a `direct_url.json` (bad caching when tool mixing)
* The server does not implement http caching semantics (we can't salvage bad servers)

A small disadvantage is that we have to make one (cheap, the server replies 304) request for each url each time if the server didn't mark the file as immutable.

I think we can't have a stale install that way

---

_Comment by @charliermarsh on 2023-12-15 04:16_

We added a story for updating these via `--reinstall`.

---

_Closed by @charliermarsh on 2023-12-15 04:16_

---
