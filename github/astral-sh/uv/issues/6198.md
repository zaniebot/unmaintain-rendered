---
number: 6198
title: "`uv pip install --target` inconsistencies"
type: issue
state: closed
author: schlamar
labels:
  - question
assignees: []
created_at: 2024-08-19T07:20:49Z
updated_at: 2024-08-20T07:00:04Z
url: https://github.com/astral-sh/uv/issues/6198
synced_at: 2026-01-07T12:31:14-06:00
---

# `uv pip install --target` inconsistencies

---

_Issue opened by @schlamar on 2024-08-19 07:20_

I use `pip install --target` to build compatible package directories for different platforms to distribute applications. For example

`pip install --platform=win_amd64 --target packages-win64 --only-binary=:all: --python-version 310 "sqlalchemy>=2,<3"` 
`pip install --platform=win32--target packages-win32 --only-binary=:all: --python-version 310 "sqlalchemy>=2,<3"`

There are inconsistencies using `uv pip install` compared to `pip`.

**1) It requires an active virtual environment**

```
> .\venv\Scripts\uv.exe pip install --target temp --only-binary=:all: --python-version 3.12 --python-platform windows sqlalchemy
error: No virtual environment found
```
When using `--target` an active virtual environment doesn't make sense for me.

**2) You cannot install binary packages with different architecture on Windows**

With pip I can install 32bit packages running a 64bit Python and vice versa. With `uv` I couldn't find a way to explicitly select 32bit packages. 

Running `uv install` with a 64bit Python I couldn't find a way to install 32bit packages (I guess that's a missing feature).

Running `uv install` with a 32bit Python and without `python-platform` installs 32bit packages. Running `uv install` with a 32bit Python and `--python-platform windows` installs 64bit packages. I would consider the latter behavior as a bug - that's really unexpected.

**3) Parameter `--implementation` missing in uv**

With `pip` you can use `--implementation py` to only select packages which don't have platform dependent binary content. I couldn't find a way to reproduce this behavior with `uv`. See https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/ 


---

_Comment by @charliermarsh on 2024-08-19 14:00_

> When using --target an active virtual environment doesn't make sense for me.

You can pass `--system` to avoid requiring a virtual environment.

> Running uv install with a 32bit Python and without python-platform installs 32bit packages. Running uv install with a 32bit Python and --python-platform windows installs 64bit packages. I would consider the latter behavior as a bug - that's really unexpected.

We don't have a target triple for 32-bit Windows. We could add one. But the current behavior is intentional. If you pass `--python-platform`, we entirely ignore the Python platform of your current interpreter. And the docs mention that `windows` is an alias for `x86_64-pc-windows-msvc`. If we start mixing the current interpreter with the `--python-platform`, you lose all of the guarantees that `--python-platform` provides (i.e., that it's independent of the current platform).


---

_Label `question` added by @charliermarsh on 2024-08-19 14:00_

---

_Comment by @schlamar on 2024-08-19 16:14_

Thanks for your quick reply! First of all, I didn't know about the docs at all. They are quite hard to find at https://docs.astral.sh/uv. Maybe you could improve visiblity a little bit more. :-)

**1)**

I have thought about this point and changed my expectation.

A common use case is to use pip from an virtual environment without having the virtual environment activated. One scenario would be in a CI pipeline. For example

```
py -m venv venv
venv\Scripts\pip install ruff
venv\Scripts\ruff check src tests
```

This example with uv fails with `error: No virtual environment found` 

```
py -m venv venv
venv\Scripts\pip install uv
venv\Scripts\uv pip install ruff
venv\Scripts\ruff check src tests
```

So my expectation here is actually that ruff should detect automatically if it is installed in a virtual envrionment and use that.

I just found out that `py -m venv .venv` would actually work but I don't like such an implicit behavior (the Zen of Python says "Explicit is better than implicit."). You could argue that automatic detection is kind of an implicit behavior, too. But I think that invoking an executable from a path in a virtual environment is an explicit action to justify this behavior.

**2)**

The point that `windows` is an alias for `x86_64-pc-windows-msvc` makes the current behavior pretty consistent. 

It would be really great if you could add a triple to target win32 Python packages.

Generally, I wonder why win32 isn't an officially supported platform as it is in [Python](https://peps.python.org/pep-0011/#tier-1) **and** [Rust](https://doc.rust-lang.org/nightly/rustc/platform-support.html#tier-1-with-host-tools) tier 1 list? 

**3)**

I have edited the issue to add another point, so maybe you missed it completely?





---

_Comment by @zanieb on 2024-08-19 16:20_

See https://github.com/astral-sh/uv/issues/5973 regarding the documentation — it's not announced/public yet but will be soon.

> So my expectation here is actually that ruff should detect automatically if it is installed in a virtual envrionment and use that.

If you want uv to do this, use `venv\Scripts\python -m uv` — it'll detect and use the parent interpreter's environment then.

> A common use case is to use pip from an virtual environment without having the virtual environment activated

If you don't want to activate the environment, but want uv to detect it, set `VIRTUAL_ENV` to the path.

> With pip you can use --implementation py to only select packages which don't have platform dependent binary content.

I'd presume we could add this without too much difficulty, but I'd prefer we discuss support for it it in a dedicated issue instead of lumping everything together.


---

_Comment by @schlamar on 2024-08-19 16:48_

Sorry, I totally agree. This has gone wild. I will split this in separate issues tommorrow.

---

_Comment by @schlamar on 2024-08-20 06:51_

> If you want uv to do this, use venv\Scripts\python -m uv — it'll detect and use the parent interpreter's environment then.

Didn't expect this to behave differently than executing `venv\Scripts\uv`. But in this case I guess this is fine.

---

_Referenced in [astral-sh/uv#6245](../../astral-sh/uv/issues/6245.md) on 2024-08-20 06:55_

---

_Referenced in [astral-sh/uv#6246](../../astral-sh/uv/issues/6246.md) on 2024-08-20 06:58_

---

_Comment by @schlamar on 2024-08-20 07:00_

I made #6245 for 2) and #6246 for 3)

I consider 1) as resolved by the statement above.

Sorry again for mixing different points in one issue.

---

_Closed by @schlamar on 2024-08-20 07:00_

---

_Referenced in [astral-sh/uv#9356](../../astral-sh/uv/issues/9356.md) on 2024-11-22 20:33_

---
