---
number: 11152
title: "feature request: `uv install`"
type: issue
state: closed
author: MilkClouds
labels:
  - enhancement
assignees: []
created_at: 2025-02-01T12:33:01Z
updated_at: 2025-02-01T17:34:17Z
url: https://github.com/astral-sh/uv/issues/11152
synced_at: 2026-01-07T12:31:15-06:00
---

# feature request: `uv install`

---

_Issue opened by @MilkClouds on 2025-02-01 12:33_

### Summary

I'm ML Engineer and I frequently manage multiple ML repositories who have loosely-defined dependencies.

Even if I manage my project's dependency strictly, it's impossible to manage their(other many ML researcher's repo) dependency strictly. It's because their repo is their repo and not my repo.

So I frequently use virtual environment managed by `conda` and I manage many packages with loose dependency consideration. In `poetry`, it's possible to run `poetry install` on my own `conda` environment and install/uninstall necessary packages in once. But in `uv`, I can't find equivalent one to `poetry install`.

Note that it's different with `uv sync`, which uninstalled all the packages which are not explicitly represented in dependency; `poetry install` only uninstall package if package's desired version is different with installed ones.

Since `uv lock` generated well-defined `uv.lock`, I guess it's sufficient to make a way to install packages in `uv.lock` without strict syncing. There might be a two way: implementing `uv install` or `uv pip install uv.lock`-like thing.

### Example

_No response_

---

_Label `enhancement` added by @MilkClouds on 2025-02-01 12:33_

---

_Comment by @MilkClouds on 2025-02-01 12:56_

I guess there's multiple way to mock my required usecases:

1. using `uv pip install`
```sh
uv pip install -r pyproject.toml
```

but notably, `uv pip install` has lacking features than `uv sync`, e.g. dependency group, workspace, ....

2. using `uv export` followed by `uv pip install`

```sh
uv export -o requirements.txt # or uv pip compile pyproject.toml -o requirements.txt 
uv pip install -r requirements.txt
```

This supports dependency group/workspace since `uv export` supports `--package/--group`, but it's two-line command and is not intuitive so much.

**I want `uv install` which provides similar set of features(dependency group/workspace/...) as `uv sync`.**

poetry supports this; `poetry install` provides `--with` flag(dependency group feature) and `--no-root` flag(skip pkg itself's install).

I'm managing mono-repo and `--with` flag and `--no-root` flag is mandatory to `install` command for me. following is my use-cases.
```sh
# at project root, install common pkg as `projects/core` and dev pkg as `ruff, pytest`. project root itself is not a pkg; so `--no-root` is needed. only `projects/*` is pkg.
poetry install --no-root --with dev
# at each sub-project, install them if necessary
cd projects/abcd
poetry install
```

---

_Comment by @MilkClouds on 2025-02-01 13:09_

to whom require same need as me: following is a script that implements â uv install as a temporary measure.

```sh
uv() {
  if [ "$1" = "install" ]; then
    shift
    if uv export -o requirements.txt "$@" > /dev/null; then
      uv pip install -r requirements.txt
      rm -f requirements.txt
    else
      echo "Error: 'uv export' failed." >&2
      return 1
    fi
  else
    command uv "$@"
  fi
}
```

---

_Comment by @MilkClouds on 2025-02-01 13:32_

implementing `--no-root` is much more complex since `uv` does not install pkg itself as default. following script works, but it's long.

```sh
uv() {
  if [ "$1" = "install" ]; then
    shift
    no_root=false
    args=()
    for arg in "$@"; do
      if [ "$arg" = "--no-root" ]; then
        no_root=true
      else
        args+=("$arg")
      fi
    done
    if uv export -o requirements.txt "${args[@]}" > /dev/null; then
      uv pip install -r requirements.txt
      rm -f requirements.txt
      if [ "$no_root" = false ]; then
        uv pip install -e .
      fi
    else
      echo "Error: 'uv export' failed." >&2
      return 1
    fi
  else
    command uv "$@"
  fi
}
```

---

_Comment by @FishAlchemist on 2025-02-01 14:14_

Does this command meet your expectations?
```bash
uv sync --inexact
```
```
--inexact
          Do not remove extraneous packages present in the environment
```

---

_Comment by @MilkClouds on 2025-02-01 16:51_

@FishAlchemist Excellent, but it's not enough because it `uv` only deals with `python-venv` type virtual environments. 

---

_Comment by @MilkClouds on 2025-02-01 17:14_

I found a way.

executing `uv sync` after `export UV_PROJECT_ENVIRONMENT=~/miniforge3/envs/agent` installs pkgs in `conda`'s virtual environment.

However, I think accessibility to this method is very low. If there are quite a few people with similar needs, it might be necessary to add a command like `uv install` or include it in the documentation.

Overall, I'm concerned about `uv`'s design of managing `venv` forcefully.

Compared to `pip`, package managers like `poetry` and `uv` play a good role in managing lockfiles to prevent dependency conflicts. However, the functionality of (1) "managing lockfiles" and (2) "managing virtual environments" are **orthogonal** functions, and having `uv`, which (1) "manages lockfiles", also forcefully (2) "manage virtual environments"  is not a good design choice in my opinion. How to (2) "manage virtual environments" should be the user's choice and freedom.

---

_Comment by @zanieb on 2025-02-01 17:34_

As suggested above, the `poetry install` equivalent is `uv sync --inexact`. We've intentionally avoided adding a top-level `uv install` command because it seems confusing to have multiple similar top-level options and expectations about `install` semantics differ, e.g., `cargo install` installs a binary like `uv tool install`.

I understand you feel like managing the virtual environments should be separate, but we've also very intentionally abstracted that concept. We don't think people should need to worry about managing virtual environments. We provide lower-level interfaces (as you discussed, `uv export`, `uv pip`) allowing you to do so if that's a feature you need. We also provide the  `UV_PROJECT_ENVIRONMENT` escape hatch for targeting arbitrary environments.

These concepts are fundamental to uv and are very unlikely to change. It seems you just want an easier way to set `UV_PROJECT_ENVIRONMENT` or different behavior around project environment detection?

Closing because we won't add a `uv install` command with the described semantics.


---

_Closed by @zanieb on 2025-02-01 17:34_

---

_Referenced in [astral-sh/uv#11273](../../astral-sh/uv/issues/11273.md) on 2025-06-06 10:39_

---
