---
number: 11273
title: "Add environment variable to always use `--active` flag"
type: issue
state: open
author: albireox
labels:
  - enhancement
  - good first issue
  - configuration
assignees: []
created_at: 2025-02-06T04:51:21Z
updated_at: 2025-08-11T21:48:59Z
url: https://github.com/astral-sh/uv/issues/11273
synced_at: 2026-01-07T12:31:15-06:00
---

# Add environment variable to always use `--active` flag

---

_Issue opened by @albireox on 2025-02-06 04:51_

### Summary

The new `--active` flag (#11189) is a great addition and I think it goes some way to allow `uv` and `pyenv` to work better together (see #6204).

Would it be possible to add a new environment variable to make that flag the default? For example, the PR suggested something like `UV_PROJECT_ENVIRONMENT=ACTIVE` but could also be `UV_ACTIVE=1`. Or maybe this already works? If so, it's not clear from the documentation.

### Example

_No response_

---

_Label `enhancement` added by @albireox on 2025-02-06 04:51_

---

_Label `configuration` added by @zanieb on 2025-02-08 02:32_

---

_Comment by @zanieb on 2025-02-08 02:33_

I posted some ideas in https://github.com/astral-sh/uv/pull/11189#issuecomment-2631810023 but did not add one yet. I'm not sure what name is best.

---

_Comment by @albireox on 2025-02-08 02:38_

I think any of the options in that comment would work. My personal preference would be a new variable, so something like `UV_PROJECT_USE_ACTIVE`.

---

_Referenced in [astral-sh/uv#11458](../../astral-sh/uv/issues/11458.md) on 2025-02-12 18:42_

---

_Referenced in [astral-sh/uv#8878](../../astral-sh/uv/issues/8878.md) on 2025-02-16 04:14_

---

_Comment by @albireox on 2025-04-07 23:36_

Any updates on this?

---

_Label `good first issue` added by @zanieb on 2025-04-07 23:37_

---

_Comment by @juditnovak on 2025-04-11 14:34_

May I give it a try (ore there's another volunteer already :-) )?

---

_Assigned to @oconnor663 by @oconnor663 on 2025-05-28 15:22_

---

_Referenced in [astral-sh/uv#13714](../../astral-sh/uv/pulls/13714.md) on 2025-05-29 00:31_

---

_Comment by @oconnor663 on 2025-06-05 16:46_

I'd like to get everyone's thoughts on @zanieb's questions from here: https://github.com/astral-sh/uv/pull/13714#issuecomment-2940490221

> - An environment variable here would apply equally to projects and scripts with inline metadata, is that what people would want? Or would you still expect a script to be run in a separate environment? Does that imply we want separate variables? Do we just want to tackle the `UV_PROJECT_ENVIRONMENT` case? 
> - How would this behave if `VIRTUAL_ENV` is not set? Would it error?

Now that I've read a bit more about `pyenv[-virtualenv]`, I'm starting to worry that setting `UV_[whatever]_ACTIVE=true` in e.g. `.bashrc` (is that how folks would do it?) could create some other confusing interactions. Here are some scattered thoughts:

`uv run` does an "inexact" sync by default where it only adds dependencies to the environment, and doesn't remove anything. But `uv sync` does an "exact" sync by default, where it removes unneeded dependencies. Doing exact syncs in implicitly activated environments might break things in surprising ways, and editors and IDEs might do that for/to you automatically. (Inexact syncs can also break things by switching between incompatible versions of a package.)

The `.python-version` file that determines `pyenv-virtualenv`'s "scope" might also be at a different level of the directory hierarchy than the `pyproject.toml` that `uv` looks for. `~/.python-version` (do folks use those?) could interact with `~/foo/bar/baz/pyproject.toml`, and `foo/pyproject.toml` could interact with `foo/bar/baz/.python-version`. Both of those might be unexpected?

At a high level, `uv` thinks it "owns" the environment it's working in. The `--active` flag sort of violates that assumption, but in a way that the user understands and intends. However, _always_ violating that assumption seems like asking for trouble?

Could folks say more about the workflows they'd like to enable here? I wonder if there might be less footgun-y ways.

---

_Comment by @samypr100 on 2025-06-06 02:17_

Strictly personally I have historically used `pyenv-virtualenv` together with `direnv` using something like the `layout activate <venv>` [pattern](https://github.com/direnv/direnv/wiki/Python#pyenv-virtualenv) on a `.envrc`. Other times via the `.python-version` pyenv [pattern](https://github.com/astral-sh/uv/issues/6204#issue-2473353444).

Post uv-era, when I need to use centrally managed uv environments with the project api I still fundamentally use the same recipe with a few tweaks and ends up looking like:

```bash
export UV_PROJECT_ENVIRONMENT=$(pyenv root)/versions/<venv>
layout activate <venv>
```

For me at least having something like `UV_PROJECT_ENVIRONMENT=VIRTUAL_ENV` (or equivalent) would simplify this usage or recipes like [this one](https://github.com/astral-sh/uv/issues/6204#issuecomment-2448148190) by having to think less about where the environment lives when working on a uv project that uses a centralized managed environment.

Hence if something like `UV_PROJECT_ENVIRONMENT=VIRTUAL_ENV` ends up being supported,
* I would expect it to fail if there's no activated venv.
* I would not plan to permanently activate this environment variable, only when I'm on the valid uv project.




---

_Comment by @MilkClouds on 2025-06-06 10:39_

## Proposal: Flexible Environment Management Strategy

Hi @oconnor663,

I'd like to propose a solution that addresses the different environment management needs expressed in issues #11315 and #11152.

### Problem
Currently, by default, uv assumes all users want automatic per-project environment management with exact syncing. However, many users (myself included) prefer managing their own virtual environments with full control, often sharing environments across multiple projects.

### Proposed Solution

**1. Add `uv install` command**
- Equivalent to `uv sync --inexact` 
- Installs/updates packages without strict environment recreation
- Matches Poetry's `poetry install` behavior

**2. Add environment configuration**
- Environment variable: `UV_MANAGE_VENV` 
- Values:
  - `true` (default): uv creates and manages project-specific environments
  - `false`: uv operates on the currently active environment without managing it
- Could be implemented as a config option (`--active`) instead of env var, but it gonna be inconvenient for myself and users.
- Existing environment variable, such as `UV_PROJECT_ENVIRONMENT`, gonna be considered only when `UV_MANAGE_VENV=true`. Of course `uv` can raise error or warn if both `UV_PROJECT_ENVIRONMENT` and `UV_MANAGE_VENV=false` is set.
- `UV_USE_ACTIVE_ENV=true` instead of `UV_MANAGE_VENV=false` may be better.

### Usage Examples

**Current workflow (unchanged):**
```bash
uv sync  # Creates/manages project venv automatically
```

**New workflow for manual environment management:**
```bash
export UV_MANAGE_VENV=false
conda activate my-shared-env  # or any venv activation
uv install  # Installs to active environment without recreation
```

Also I think `uv sync` for `UV_MANAGE_VENV=false` must request confirm to user after execution. Accidentally calling `uv sync` for existing environment is very annoying and dangerous; I've met that situation several times, especially when running Cursor Agent mode.

### Benefits
- Maintains backward compatibility (default behavior unchanged)
- Supports both use cases without breaking existing workflows
- Clear separation of concerns between environment creation and package installation

### Reference Implementation
I've created a proof-of-concept wrapper called `vuv` that it similar to this approach, but with `vuv` CLI executable rather than defining `UV_MANAGE_VENV`: https://github.com/open-world-agents/vuv

What are your thoughts on this direction?

---

_Comment by @zanieb on 2025-06-06 13:53_

@milkclouds, appreciate that you took the time to write something up, but it probably would be best as its own issue as it's much larger in scope than adding an environment variable to persistently control an existing behavior.

---

_Comment by @Wangnov on 2025-06-12 03:04_

> At a high level, `uv` thinks it "owns" the environment it's working in. The `--active` flag sort of violates that assumption, but in a way that the user understands and intends. However, _always_ violating that assumption seems like asking for trouble?

Hi @charlierm, thank you for the detailed explanation in your comment and for creating such a fantastic tool.

I'd like to share a common workflow for many full-stack developers that highlights why a smoother `uv`-`conda` integration would be incredibly valuable.

Many of us rely on **conda/mamba as a universal environment manager** to handle multi-language projects. For a single project, it's common to have an environment that includes specific versions of Python, Node.js, and perhaps even Rust or other system dependencies. Conda excels at creating and managing this isolated, multi-language "outer shell."

Within this activated conda environment, **we want to use `uv` to completely manage the Python portion**. Our ideal workflow is for `uv` to recognize the Python provided by the active conda environment and "take full ownership" of it, treating it as the authoritative virtual environment.

Currently, to achieve this, the process is quite manual and adds significant overhead:
1.  After running `mamba activate my-env`, we must manually set `export VIRTUAL_ENV=$CONDA_PREFIX`.
2.  Even with `VIRTUAL_ENV` set, when a `pyproject.toml` is present, we still need to add the `--active` flag to nearly every `uv` command (`add`, `sync`, `run`, etc.) to force `uv` to use the conda environment instead of looking for a local `.venv`.

This need to configure environment variables and consistently remember the `--active` flag adds a lot of friction and management cost to our daily workflow.

Therefore, we are hoping for a more seamless, **"set-it-and-forget-it"** way for `uv` to collaborate with conda/mamba. This could perhaps involve `uv` automatically recognizing `CONDA_PREFIX` when `VIRTUAL_ENV` is not set, or a global configuration option to always prefer the active conda environment.

Thank you again for your incredible work. We believe a smoother integration would make `uv` an even more indispensable tool for the wide community of developers who rely on conda for multi-language environment management.


---

_Comment by @zanieb on 2025-06-12 03:11_

@Wangnov why not set `UV_PROJECT_ENVIRONMENT=$CONDA_PREFIX`? You could also make an alias for `mamba activate` that also sets `VIRTUAL_ENV` (and / or the above variable), so you don't need to do so manually?

---

_Comment by @Wangnov on 2025-06-12 03:21_

> [@Wangnov](https://github.com/Wangnov)为什么不设置`UV_PROJECT_ENVIRONMENT=$CONDA_PREFIX`？您还可以为`mamba activate`设置`VIRTUAL_ENV`(和/或上述变量)​​创建一个别名，这样就不需要手动执行此操作了？

@zanieb Thank you so much for the quick and insightful reply! I really appreciate you pointing out the `UV_PROJECT_ENVIRONMENT` variable; that's a variable I had overlooked, and I will be testing it right away.

To provide some context on our current workflow, we are already doing something very similar to your suggestion. We have a function in our `.bashrc` that hooks into `mamba activate` to automatically set `VIRTUAL_ENV=$CONDA_PREFIX`.

In addition to that, we have another function for the `uv` command itself, which automatically adds the `--active` flag to top-level commands. I admit, this second part might indeed be a bit clunky if setting `UV_PROJECT_ENVIRONMENT=$CONDA_PREFIX` makes the `--active` flag unnecessary. I'm keen to try this more direct approach.

However, this brings me to the main point I wanted to share. Relying on custom shell functions in `.bashrc` for this kind of core integration, while functional, comes with inherent risks. It can be brittle, breaking with shell or tool updates, and it creates an extra setup step for every team member, which can sometimes lead to "it works on my machine" issues.

If `uv` could offer some level of native support for this conda/mamba workflow, it would feel like a safer and more elegant solution. I've read through the related issues and I understand and respect the team's commitment to PEP standards and the "not planned" decisions made on similar topics.

So, please consider this merely a case study from my team and me, shared for your reference. We represent a group of developers who find immense value in using conda for its powerful multi-language environment management and would love for `uv` to be our go-to Python package manager within that ecosystem.

Thank you again for your time and responsiveness!

***

**UPDATE:**

I've just tested setting `UV_PROJECT_ENVIRONMENT=$CONDA_PREFIX`, and I can confirm it works beautifully. It has allowed me to simplify my `.bashrc` function significantly, as I no longer need the separate, complex function to add the `--active` flag to each `uv` command.

This is a much cleaner approach. Thank you so much for this specific and very helpful tip!

BTW: As a developer in China, our situation highlights why a global configuration is so valuable. Due to network reasons, modifying uv's user-level configuration is a mandatory step for us right after installation. We have to write scripts to change the package index-url and the python-build mirror—even the uv installation script itself often needs a special download method. Because we already rely on these custom setup scripts, having a single, global setting for conda integration would be trivial for us to add. It would be a one-time, reliable configuration that we could roll out to our entire team, fitting perfectly into our existing, necessary procedures.

---

_Comment by @RafalSkolasinski on 2025-08-11 21:48_

Though `UV_PROJECT_ENVIRONMENT=$CONDA_PREFIX` does the trick it's not ideal as this needs to be set after activating every conda environment. It would be nice to just set some boolean config option that whenever `$CONDA_PREFIX` is set it is used for UV's project environment.

---

_Referenced in [astral-sh/uv#11315](../../astral-sh/uv/issues/11315.md) on 2025-08-11 22:19_

---

_Referenced in [astral-sh/uv#15603](../../astral-sh/uv/issues/15603.md) on 2025-08-31 08:56_

---
