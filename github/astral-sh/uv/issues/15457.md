---
number: 15457
title: uv run --active seems redundant?
type: issue
state: closed
author: AlKhrulev
labels:
  - question
assignees: []
created_at: 2025-08-22T15:53:37Z
updated_at: 2025-08-24T00:14:31Z
url: https://github.com/astral-sh/uv/issues/15457
synced_at: 2026-01-07T12:31:16-06:00
---

# uv run --active seems redundant?

---

_Issue opened by @AlKhrulev on 2025-08-22 15:53_

### Question

Hello,

This is the documentation for the `--active` flag:

```
Prefer the active virtual environment over the project's virtual environment.
```

However, `uv` already does this by default if we skip the project entirely using `uv run --no-project`.
Because of that, Iâ€™m not sure in which cases the `--active` option produces a different result from `--no-project`.

---

## Example project structure

Hereâ€™s a sample project (`uv_test`, stored in `/uv_test`):

```shell
.
â”œâ”€â”€ .git
â”œâ”€â”€ .gitignore
â”œâ”€â”€ .python-version
â”œâ”€â”€ .venv            # project venv
â”œâ”€â”€ main.py
â”œâ”€â”€ pyproject.toml
â”œâ”€â”€ README.md
â”œâ”€â”€ second_dir
â”‚   â”œâ”€â”€ .venv        # another venv
â””â”€â”€ uv.lock
```

According to the documentation, `uv run` will always prefer the project venv first (regardless of whether itâ€™s currently active).
For example, even if I activate a non-project venv:

```shell
$ source second_dir/.venv/bin/activate   # activate non-project venv
$ uv run which python
/uv_test/.venv/bin/python  # still resolves to project venv(as expected)
```

A warning is printed, which correctly highlights the issueâ€”though it may not be obvious to users:

```
warning: `VIRTUAL_ENV=second_dir/.venv` does not match the project environment path `.venv` and will be ignored; use `--active` to target the active environment instead
```

---

## Behavior with `--no-project`

If I use `--no-project`, `uv` falls back to the active environment due to the priority rules:

```
project venv â†’ active venv â†’ `.venv` in current/parent directories (recursive) â†’ executable in PATH
```

Example:

```shell
$ source second_dir/.venv/bin/activate
$ uv run --no-project which python   # skip project => use active venv(as expected)
/uv_test/.venv/bin/python
```

Even if the project venv is already active, `--no-project` still defaults to it because of the discovery rules.
This is the same behavior youâ€™d get with `--active`:

```shell
$ source .venv/bin/activate  # manually activate project venv
$ uv run --no-project which python
/uv_test/.venv/bin/python # next step is to look at active venv, which happens here
$ uv run --active which python
/uv_test/.venv/bin/python # go directly to active venv=project venv
```

Everything mentioned above applies to non-project folders too as we are effectively passing `--no-project` by default and going directly to discovering an active venv first.

---

## Summary

I havenâ€™t found any case where `--active` provides behavior that `--no-project` does not.

A more useful option might be something like `--no-active`, which would let you the active venv, falling back directly to `.venv` folders. It can be combined with `--no-project`. For example:

```shell
uv run --no-project             # skip project => default to active venv(might be project venv or not, just like now)
uv run --no-project --no-active # skip project & active venv => check .venv folders
```

Otherwise, I would suggest removing the `--active` option entirely, as it seems redundant. Feel free to correct me in case I am wrong somewhere. 

On a separate note, thank you for your efforts! It is a pleasure using uv ðŸ˜„ 


### Platform

Darwin 24.6.0 arm64

### Version

uv 0.8.13 (Homebrew 2025-08-21)

---

_Label `question` added by @AlKhrulev on 2025-08-22 15:53_

---

_Comment by @zanieb on 2025-08-22 16:04_

`--no-project` will not sync your project's dependencies into the active environment (which could be some arbitrary environment). In contrast, `--active` will perform both a lock and sync.

---

_Comment by @zanieb on 2025-08-22 16:06_

So `--active` is intended to change the target environment for the project, while `--no-project` is intended to ignore the project concept entirely.

---

_Comment by @AlKhrulev on 2025-08-22 16:37_

Hey, @zanieb thanks for the quick reply. Based on what you said, if we use `--active`, the active venv will be updated with project requirements from pyproject.toml, while `--no-project` will simply use that venv untouched without installing anything extra?

In terms of locking, you mean that `uv run --active` will essentially run `uv lock` to update the project's `uv.lock` first before installing project dependencies into a new env, while `--no-project` will omit this step?

As a final question, can you give me a practical example of when we would want to switch the target env for the project? My assumption was that `--with` provides necessary tools to change certain requirements already, so the use case for switching the whole venv seems less clear to me.

---

_Comment by @zanieb on 2025-08-22 17:18_

> the active venv will be updated with project requirements from pyproject.toml, while --no-project will simply use that venv untouched without installing anything extra?

Yes

> you mean that uv run --active will essentially run uv lock to update the project's uv.lock first before installing project dependencies into a new env, while --no-project will omit this step?

Yes

> As a final question, can you give me a practical example of when we would want to switch the target env for the project? 

You shouldn't need to, generally. We've added support for this by popular demand. See https://github.com/astral-sh/uv/pull/6834 and https://github.com/astral-sh/uv/pull/11189

---

_Comment by @AlKhrulev on 2025-08-23 04:34_

Thank you again, @zanieb. This clarifies a lot. I do have one final question about your last point before closing this issue. 

To summarize, you could use `uv venv [PATH]` to intialize project venv at any `PATH` besides the default one(`.venv`) but all commands working with project env originally assumed `PATH=.venv`? That's when `UV_PROJECT_ENVIRONMENT` variable was added to let users permanently fix the project venv path for convenience? At the same time, it wasn't flexible enough for some people, so an option `--active` was added to essentially allow one-time `UV_PROJECT_ENVIRONMENT` setup, similar to the one below:

``` shell
uv sync/add/run --active ...
# same as 
UV_PROJECT_ENVIRONMENT="$VIRTUAL_ENV" uv sync/add/run ...
```

**Or so I thought** but then I ran this and realised that uv still created `.venv` in that case...

```shell
$ mv .venv virtual_env
$ uv sync # will recreate .venv(as expected)
$ rm .venv && source virtual_env/bin/active
$ uv sync --exact --active  # I assumed would install packages into virtual_env
Using CPython 3.11.11
Creating virtual environment at: .venv # still created .venv?
...
```
As you can tell, this is where confusion is coming from. Your issues mention `UV_PROJECT_ENVIRONMENT` but I don't see how adding `--active` solved it. Actually, I realised I don't even understand how that variable behaves because the following code also does something I didn't expect:

```shell
$ pwd # for reference
/uv_test
$ UV_PROJECT_ENV=second_dir/.venv uv sync --exact # I assumed would sync with second_dir/.venv
Using CPython 3.11.11
Creating virtual environment at: .venv # still created .venv for some reason?
```

Thank you in advance for your patience! I just want to figure this out

---

_Comment by @AlKhrulev on 2025-08-23 04:43_

Oh, and as an update, I've tested my example will full path to make sure it is not a problem. I am getting the same result, so I don't think that's the case:

```shell
$ UV_PROJECT_ENV=$(realpath second_dir/.venv) uv sync --exact
Using CPython 3.11.11
Creating virtual environment at: .venv
```

---

_Comment by @zanieb on 2025-08-23 14:31_

> you could use uv venv [PATH] to intialize project venv at any PATH besides the default one

`uv venv` is just used for creating arbitrary virtual environments. You could use that environment for the project, but the concepts are not the same. There's no need to ever use `uv venv` when you're using `uv run` and `uv sync` in projects, the project environment is always created â€” even when using `UV_PROJECT_ENVIRONMENT`.

In your examples, you're using the wrong variable name â€” `UV_PROJECT_ENV` is not it.

---

_Comment by @AlKhrulev on 2025-08-23 15:45_


> `uv venv` is just used for creating arbitrary virtual environments. You could use that environment for the project, but the concepts are not the same. There's no need to ever use `uv venv` when you're using `uv run` and `uv sync` in projects, the project environment is always created â€” even when using `UV_PROJECT_ENVIRONMENT`.

Got it but to clarify, your intention with adding `--active` was being able to specify  `UV_PROJECT_ENVIRONMENT=$VIRTUAL_ENV` for a single command, correct? Looks to be the case.

> In your examples, you're using the wrong variable name â€” `UV_PROJECT_ENV` is not it.

Extremely sorry about missing that ðŸ˜… , you are totally right and now that command behaves as expected. This took a load off my mind



---

_Comment by @zanieb on 2025-08-23 17:58_

> Got it but to clarify, your intention with adding --active was being able to specify UV_PROJECT_ENVIRONMENT=$VIRTUAL_ENV for a single command, correct? 

Yeah, it makes that workflow easier.

---

_Comment by @AlKhrulev on 2025-08-24 00:14_

> > Got it but to clarify, your intention with adding --active was being able to specify UV_PROJECT_ENVIRONMENT=$VIRTUAL_ENV for a single command, correct?
> 
> Yeah, it makes that workflow easier.

Perfect, thanks for you help. It might make sense to reflect the distinction behind `--active` and `--no-project`(i.e. locking and syncing for former and doing nothing for latter) in the documentation to make it clearer for users.

---

_Closed by @AlKhrulev on 2025-08-24 00:14_

---

_Referenced in [vibrantlabsai/ragas#2479](../../vibrantlabsai/ragas/issues/2479.md) on 2025-12-09 14:34_

---
