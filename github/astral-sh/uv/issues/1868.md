---
number: 1868
title: "`uv venv` fails because `python3.wrapper` is not available"
type: issue
state: closed
author: csalerno-asml
labels:
  - bug
  - virtualenv
assignees: []
created_at: 2024-02-22T14:13:05Z
updated_at: 2024-07-01T14:46:30Z
url: https://github.com/astral-sh/uv/issues/1868
synced_at: 2026-01-07T12:31:14-06:00
---

# `uv venv` fails because `python3.wrapper` is not available

---

_Issue opened by @csalerno-asml on 2024-02-22 14:13_

<!--
Thank you for taking the time to report an issue! We're glad to have you involved with uv.

If you're filing a bug report, please consider including the following information:

* A minimal code snippet that reproduces the bug.
* The command you invoked (e.g., `uv pip sync requirements.txt`), ideally including the `--verbose` flag.
* The current uv platform.
* The current uv version (`uv --version`).
-->

Machine: RHEL7

```bash
$ python3 -m pip install uv==0.1.7
$ uv venv
Querying Python at `/home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper` failed with status exit status: 127:
  │ --- stdout:

  │ --- stderr:
  │ /home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper: line 5: python3.wrapper: command not found
  │ ---
```

---

_Comment by @konstin on 2024-02-22 14:59_

How did you install python?

---

_Comment by @Crissal1995 on 2024-02-23 23:56_

Via a proprietary enterprise tool, so some shenanigans are happening with paths.

However running `python3 -m venv .venv` works correctly, shouldn't `uv` run the same command? 

---

_Comment by @zanieb on 2024-02-24 00:57_

`uv` implements its own virtual environment creation in Rust, we do not call Python's virtual environment tooling.

---

_Comment by @Crissal1995 on 2024-02-25 09:46_

Isn't possible to implement a fallback in case of custom python installations? 

---

_Comment by @konstin on 2024-02-26 12:56_

Could you run with debug logging?

```
RUST_LOG=debug uv venv -v
```

For background, we rely on `python -c "<our probing script>"` to get information about the python interpreter (e.g. its version and its paths). Is there a reason why `python -m venv` works while `python -c` doesn't?

---

_Comment by @csalerno-asml on 2024-02-28 08:37_

There you go:
```bash
$ RUST_LOG=debug uv venv -v
 uv_interpreter::python_query::find_default_python platform=Platform { os: Manylinux { major: 2, minor: 17 }, arch: X86_64 }, cache=Cache { root: "/home/csalerno/.cache/uv", refresh: None, _temp_dir_drop: None }
      0.016782s  11ms DEBUG uv_interpreter::interpreter Detecting markers for: /home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper
  × Querying Python at `/home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper` failed
  │ with status exit status: 127:
  │ --- stdout:

  │ --- stderr:
  │ /home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper: line 5: python3.wrapper:
  │ command not found
  │ ---
```

Regarding your question, not sure, maybe some enterprise rules, however `python -c` works fine.

```bash
$ python -c 'print("hello world")'
hello world
```

However in our setup, `python` is v2.7.14, while `python3` is v3.10.5, so maybe python2 is actually called by `uv`?

---

_Comment by @MichaReiser on 2024-02-28 08:52_

> However in our setup, python is v2.7.14, while python3 is v3.10.5, so maybe python2 is actually called by uv? 

uv calls python 2 to get its version information. But it won't use it if you have a Python3 installation. 

Can you run `which python` and would you mind sharing the content of `cat /home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper` (assuming it contains no sensitive content)? I wonder if it fails because we canonicalize the path

---

_Comment by @csalerno-asml on 2024-02-29 14:45_

Sure, no sensitive content found :) 

> `which python`

`/home/csalerno/.caddir/RHEL7/cadbin/python`

> `cat /home/cadappl_RHEL7/python3/3.10.5/wrapper/python3.wrapper`

```bash
#!/bin/sh
export PATH=/cadappl/python3/3.10.5/python3/bin:${PATH}
export LD_LIBRARY_PATH=/cadappl/python3/3.10.5/python3/lib:/cadappl/tcl/8.6.11/tcl/lib:/cadappl/tk/8.6.11/tk/lib:/cadappl/sqlite/3.34.1/sqlite/lib:/cadappl/zlib/1.2.11/lib:/cadappl/openssl/1.1.1j/openssl/lib:/cadappl/valgrind/3.16.1/valgrind/lib:/cadappl/gdbm/1.19/gdbm/lib:/cadappl/readline/6.2.4.1/readline/lib:/cadappl/bzip2/1.0.6.a/bzip2/lib:${LD_LIBRARY_PATH}

`basename $0` "$@"
```

---

_Comment by @konstin on 2024-03-01 10:10_

It's probably because we resolve the symlink so the basename changes

---

_Comment by @csalerno-asml on 2024-03-01 14:30_

is there a workaround that I could apply in `python3.wrapper`? or this is something that should be fixed in `uv`?

---

_Comment by @charliermarsh on 2024-03-02 04:10_

@konstin - Related to https://github.com/astral-sh/uv/issues/1640 -- I'm unsure if we should be resolving symlinks for interpreters outside of virtualenvs.

---

_Comment by @konstin on 2024-03-03 17:49_

We should stop resolving the symlinks unconditionally; Initially, it looked like a convenient solution for venv-from-venv use cases, but using `sys._base_executable` with a fallback to resolving should represent the user intent better.

---

_Comment by @charliermarsh on 2024-03-03 17:51_

@konstin - I generally agree, although if we change that, it will "break" cases like this: https://github.com/pypa/virtualenv/issues/2682. (That issue motivated virtualenv to start recursively resolving symlinks (on `main` but unreleased).)

---

_Comment by @konstin on 2024-03-03 18:52_

I've asked at https://github.com/python/cpython/issues/106045#issuecomment-1975257339, this should bring some clarity

---

_Label `bug` added by @charliermarsh on 2024-03-04 00:13_

---

_Label `virtualenv` added by @charliermarsh on 2024-03-04 00:13_

---

_Comment by @Crissal1995 on 2024-04-05 16:12_

Hi, is there any update regarding this issue? 

---

_Comment by @konstin on 2024-07-01 14:46_

We've rewritten interpreter discovery and this should not occur anymore, feel free to reopen if it's still a problem.

---

_Closed by @konstin on 2024-07-01 14:46_

---
