---
number: 11175
title: option to specify a project root directory to be added to the python path
type: issue
state: open
author: DetachHead
labels:
  - enhancement
assignees: []
created_at: 2025-02-03T04:26:24Z
updated_at: 2026-01-02T09:11:33Z
url: https://github.com/astral-sh/uv/issues/11175
synced_at: 2026-01-07T12:31:15-06:00
---

# option to specify a project root directory to be added to the python path

---

_Issue opened by @DetachHead on 2025-02-03 04:26_

### Summary

my project is not intended to be built as a wheel or published, but i would like to be able to import other modules like so:

```
.
├── foo/
│   ├── __init__.py
│   └── a.py
└── bar/
    ├── __init__.py
    └── b.py
```
```py
# ./bar/b.py
from foo import a
```
however this is not possible unless i add and configure a build backend, which adds a lot of complexity to my project for functionality i don't actually need.

all i want is to be able to add the project root directory to the python path. it would be nice if uv had an option to do this

### Example
maybe something like this
```toml
# pyproject.toml
[tool.uv]
python-paths = ["."]
```

---

_Label `enhancement` added by @DetachHead on 2025-02-03 04:26_

---

_Comment by @tpgillam on 2025-02-03 10:24_

Another similar use for this would be for 'development' modules that live alongside a package that is built in a standard way.

For some internal packages we have a structure like:
```
pyproject.toml
src/
   moo/
      __init__.py
      stuff.py
laboratory/
   __init__.py
   common/
      ...
   stuff/
      ...
tests/
   __init__.py
   ...
```

The code under `src/moo` is a module that we treat in a fairly standard way, and is depended upon by other internal packages, should have a build-backend, etc. etc.

But `laboratory` is intended to be a module too; but one that is only available when locally developing a package. (It contains a combination of extended documentation / prototyping of new algorithms / records of computational experiments.) The main point is that it has internal dependencies, and we write `import laboratory.common....` from within other places in `laboratory`.

Having the ability to specify an additional `python-path-extends` or similar field could be a neat solution to this I think. (Especially if it worked nicely with workspaces, and only modified the python path with the context from the active project -- when we have two modules, each with their own 'laboratory' modules, we want to make sure only the one on the currently-in-use project is active)

---

_Comment by @konstin on 2025-02-03 16:59_

As reference, pycharm supports this as a default option:

![Image](https://github.com/user-attachments/assets/d5cdaa07-d8d3-4c4e-a6d5-6672e2215aa1)

---

_Comment by @mjpauly on 2025-02-06 02:01_

If you add

```
[tool.uv]
package = true
```

to your `pyproject.toml` and run `uv sync`, then uv will install a minimal package to your environment that simply points to the modules at the root of your repository by their file path, making them importable without building them.

---

_Comment by @DetachHead on 2025-02-06 02:30_

that just means use a build backend. specifying `package = true` without specifying a build system makes it default to using setuptools ([this behavior is mentioned in the docs here](https://docs.astral.sh/uv/concepts/projects/config/#build-systems)).

in my case, setuptools refuses to build my project because there are multiple top-level packages which means i have to figure out how to configure it to build a package that i don't even want to build in the first place, which is what i'm trying to avoid

---

_Comment by @mjpauly on 2025-02-06 02:54_

What's the error? Seems to handle multiple top-level packages fine.

---

_Comment by @DetachHead on 2025-02-06 03:34_

```
> uv sync
Resolved 150 packages in 26ms
  × Failed to build `project @ file:///C:/project`
  ├─▶ The build backend returned an error
  ╰─▶ Call to `setuptools.build_meta:__legacy__.build_editable` failed (exit code: 1)

      [stderr]
      error: Multiple top-level packages discovered in a flat-layout: ['foo', 'bar'].

      To avoid accidental inclusion of unwanted files or directories,
      setuptools will not proceed with this build.

      If you are trying to create a single distribution with multiple packages
      on purpose, you should not rely on automatic discovery.
      Instead, consider the following options:

      1. set up custom discovery (`find` directive with `include` or `exclude`)
      2. use a `src-layout`
      3. explicitly set `py_modules` or `packages` with a list of names

      To find more information, look for "package discovery" on setuptools docs.

      hint: This usually indicates a problem with the package or the build environment.
```

relying on setuptools doesn't sound like a good idea especially since it's got `__legacy__` in the name. for now as a workaround i'm just using uv's work-in-progress build backend (#8779) with an empty package matching the name of the project.

honestly now that i'm using uv i don't want to have to touch any of these legacy tools ever again. they are just too painful to deal with

---

_Comment by @mjpauly on 2025-02-06 05:01_

Ah yeah you're right it doesn't work with multiple top-level packages out of the box. This seems to work:

```
[tool.uv]
package = true

[tool.setuptools]
packages = ["foo", "bar"]
```

---

_Comment by @trim21 on 2025-03-12 16:44_

This is easy to workaround `echo $(pwd) > .venv/lib/python3.10/site-packages/_project.pth`, but I hope uv can have such option to avoid the trouble.


---

_Comment by @oelhammouchi on 2025-04-14 10:16_

We're experiencing a problem which seems related to this: there seems to be no way of including a top-level module outside of the `src`  tree in a (editable) install. In our case, we have a Flask app configured with a `config.py`:

```
├── config.py
├── pyproject.toml
├── README.md
├── app
├── settings.toml
└── uv.lock
```

Inside the app, we import settings with

```python
from config import settings
```

This used to work fine with Poetry, but with uv we get `ModuleNotFoundError: No module named 'config'`. It would be really useful if this could be solved somehow.

---

_Comment by @rmnppt on 2025-08-16 07:58_

> Ah yeah you're right it doesn't work with multiple top-level packages out of the box. This seems to work:
> 
> ```
> [tool.uv]
> package = true
> 
> [tool.setuptools]
> packages = ["foo", "bar"]
> ```

This worked for me, thanks!

---

_Comment by @kerrickstaley on 2025-12-13 05:13_

Is there a solution that allows importing .py files from the top-level like @oelhammouchi asked about? I'm also running into this.

@trim21 's solution of ```echo $(pwd) > .venv/lib/python3.13/site-packages/_project.pth``` works but doesn't feel like something I can check-in to Git (it hardcodes the Python version). Running ```PYTHONPATH="$(git rev-parse --show-toplevel)" uv ...``` also works but is ugly.

---

_Comment by @konstin on 2025-12-15 17:14_

Note that the `[tool.setuptools]` solution relies on configuring a build backend implicitly, though the PEP 517 legacy fallback. I recommend configuring a build backend explicitly (it's 3 lines for the `[build-system]` table), and configuring it to include the modules you want to import. Both hatchling and uv-build can be configured to include multiple top-level modules.

> But `laboratory` is intended to be a module too; but one that is only available when locally developing a package. (It contains a combination of extended documentation / prototyping of new algorithms / records of computational experiments.) The main point is that it has internal dependencies, and we write `import laboratory.common....` from within other places in `laboratory`.

The best way to achieve this is to move `laboratory` a directory down and give it it's own minimal `pyproject.toml`. I generally recommend trying to build a native python package structure with a `pyproject.toml` and one top level module name. It's more boilerplate than having the project root in `sys.path`, but it avoids some common problems later and it's better accessible to tools and IDEs.

---

_Comment by @DetachHead on 2026-01-02 09:11_

looks like i can use uv's build backend and specify no module names:

```toml
# pyproject.toml

[tool.uv.build-backend]
module-root = "."
module-name = []
```

this is pretty much exactly what i need, since i don't want to have to maintain a separate list of top-level module names in my project since it never gets built as a wheel.

---
