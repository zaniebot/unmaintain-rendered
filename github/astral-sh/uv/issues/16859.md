---
number: 16859
title: "No information about \"operation not supported\" in `uv init` on macos with `--cache-dir`"
type: issue
state: closed
author: byron-hawkins
labels:
  - bug
  - error messages
assignees: []
created_at: 2025-11-26T12:10:59Z
updated_at: 2025-12-15T14:05:07Z
url: https://github.com/astral-sh/uv/issues/16859
synced_at: 2026-01-07T12:31:16-06:00
---

# No information about "operation not supported" in `uv init` on macos with `--cache-dir`

---

_Issue opened by @byron-hawkins on 2025-11-26 12:10_

### Summary

This command works without the `--cache-dir` option, although here it does create a cache but then fails shortly afterward. Setting `UV_LINK_MODE` did not change anything, and symlinks are supported on the filesystem (ExFAT), with a manual test confirming that a symlink works in this directory. Having no information about which operation is not supported, there is no way to explore possible workarounds.

```
> uv init --bare --cache-dir build/uv/cache -v 
DEBUG uv 0.9.12 (0fb123336 2025-11-24)
error: Operation not supported (os error 45)
```

Partially created cache:
```
> ls -R build/uv/cache
CACHEDIR.TAG    sdists-v9

build/uv/cache/sdists-v9:
```

### Platform

macOS 26 arm64 (M1)

### Version

0.9.12 (brew)

### Python version

3.14.0 (brew)

---

_Label `bug` added by @byron-hawkins on 2025-11-26 12:11_

---

_Label `error messages` added by @konstin on 2025-11-26 15:51_

---

_Comment by @konstin on 2025-11-26 15:51_

We should fix both the error message and the underlying bug.

---

_Comment by @pcastellazzi on 2025-11-26 22:09_

I run `uv` with `dtruss` (`/Volumes/untitled/` is my ExFAT device).

```bash
# search for a syscall that failed with os error 45
rm -rf build ; sudo dtruss -f uv init --bare --cache-dir build/uv/cache -v 2>&1 | grep -- "= -1 45"

44754/0x1f7d2b:  renameatx_np(0xFFFFFFFFFFFFFFFE, "/Volumes/untitled/build/uv/cache/.tmpPGgOVr\0", 0xFFFFFFFFFFFFFFFE, "build/uv/cache/.lock\0", 0|0|RENAME_EXCL)              = -1 45
```

It looks like `uv` is renaming a file using `renameatx_np` (a system call) with the flag `RENAME_EXCL` which is not available on all filesystems (man 2 renameatx_np).

Proof of concept:

```C
// clang -Wall -o poc poc.c ; ./poc
#include <fcntl.h>
#include <errno.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

int main() {
    const char *old_filename = "old.txt";
    const char *new_filename = "new.txt";

    int fd = open(old_filename, O_CREAT);
    close(fd);

    int result = renameatx_np(AT_FDCWD, old_filename, AT_FDCWD, new_filename, RENAME_EXCL);
    if (result == -1) {
        fprintf(stderr, "failed to rename file: %s (errno: %d)\n", strerror(errno), errno);
        return 0;
    }

    return 0;
}
```



---

_Assigned to @EliteTK by @EliteTK on 2025-12-04 15:59_

---

_Comment by @EliteTK on 2025-12-08 11:54_

I've tracked this down to `tempfile::file::NamedTempFile::persist_noclobber` called in: https://github.com/astral-sh/uv/blob/28a8194a67726b93524e3ade42d0db884519ec73/crates/uv-fs/src/locked_file.rs#L253

(This is called from https://github.com/astral-sh/uv/blob/28a8194a67726b93524e3ade42d0db884519ec73/crates/uv/src/lib.rs#L1911 which calls `uv_cache::Cache::init` -> `uv_fs::locked_file::LockedFile::acquire` -> `uv_fs::locked_file::LockedFile::create` -> `tempfile::file::NamedTempFile::persist_noclobber`)

With an ExFAT disk mounted at `/Volumes/EXFATDISK` this will reproduce the error (second unwrap):

```
use tempfile::NamedTempFile;

fn main() {
    let tmp = NamedTempFile::new_in("/Volumes/EXFATDISK").unwrap();
    tmp.persist_noclobber("/Volumes/EXFATDISK/test").unwrap();
}
```

This seems to be because `persist_noclobber` uses `renameat_with` to pass `RenameFlags::NOREPLACE` which internally uses `renameatx_np` which is not supported on all filesystems. I think `tempfile` should try (non-permanently) falling back to `std::fs::hard_link` like it does when `renameatx_np` gives `ENOSYS`. But that wouldn't fix this issue as ExFAT also doesn't support hard links.

To support ExFAT on mac for this usecase we will have to come up with some alternative approach rather than using `persist_noclobber`.

Side note: I don't think this matters for this issue, but ExFAT doesn't actually support symlinks, MacOS seems to use Minshall+French symlinks for this. Not sure how that's implemented exactly - weird but cool.

---

_Comment by @EliteTK on 2025-12-08 13:16_

So, just for a run-down of why `persist_noclobber` is used:

* The lockfile needs to be created in case it does not exist.
* To allow other users to also open the lockfile without getting permission errors, the permissions need to be set to 0666.
* In order to avoid a race, the future lockfile must be created as a tempfile, have its permissions changed, and then be moved to its final destination. Otherwise another process could attempt to open the lockfile after it is created but before the permissions are changed.
* Since another process can at any point create the lockfile, the final rename must be done without overriding any existing lockfile which another process may have open. To this end, `renameat2`/`renameat_ex` need to be used.

The permissions race isn't critical, and in the end it would just cause a uv invocation to produce a permission error. So I think a good solution would just be to loosen it. Although we can do even better: simply try with `persist_noclobber` and then fall back to the racy option. As a bonus, this won't matter on exfat anyway as it doesn't have permission bits (everything is always 0777).

---

_Comment by @pcastellazzi on 2025-12-08 22:53_

I run your example on Windows (Windows 11 Pro) and Linux (Ubuntu 24.03 LTS) and it does not fail. On the stack trace you can see it is using renameat2 and not failing. This seems to indicate the problem exists only on macos. 

```bash
# exfat is the the volume location
rm exfat/test ; strace -e trace=file -ff -s 1024 target/debug/example
execve("target/debug/example", ["target/debug/example"], 0x7fff488b3168 /* 36 vars */) = 0
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libgcc_s.so.1", O_RDONLY|O_CLOEXEC) = 3
openat(AT_FDCWD, "/proc/self/maps", O_RDONLY|O_CLOEXEC) = 3
getcwd("/home/ubuntu/Downloads/example", 512) = 37
openat(AT_FDCWD, "/home/ubuntu/Downloads/example/exfat/.tmpzjkFc3", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0600) = 3
renameat2(AT_FDCWD, "/home/ubuntu/Downloads/example/exfat/.tmpzjkFc3", AT_FDCWD, "exfat/test", RENAME_NOREPLACE) = 0
+++ exited with 0 +++
```

I think a warning for that specific case should probably be enough. `uv` is doing something similar when it can change permissions.

```bash
uv init --bare --cache-dir exfat/build/uv/cache -v --python 3.14 exfat/
DEBUG uv 0.9.16 (Homebrew 2025-12-06)
**WARN Failed to set permissions on temporary file: Operation not permitted (os error 1)**
DEBUG Acquired shared lock for `exfat/build/uv/cache`
DEBUG Using Python version `>=3.14` from request `Python 3.14`
Initialized project `exfat` at `/home/ubuntu/Downloads/example/exfat/`
DEBUG Released lock at `exfat/build/uv/cache/.lock`
```

---

_Referenced in [astral-sh/uv#17115](../../astral-sh/uv/pulls/17115.md) on 2025-12-12 23:04_

---

_Closed by @EliteTK on 2025-12-15 14:05_

---
